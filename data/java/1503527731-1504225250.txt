I might be, but there are no interviewers. Not getting past the application stage because they all want EE experience.
Maybe I created a confusion because I listed things I knew along with things I didn’t know, because they’re questions I remembered, I think I’m mostly good with hashmaps and sets, although I do worry a lot maybe my answers might not be good enough 
I'm sorry what? Make a large queue with an array list instead of a linked list and then say linked lists should be deprecated.
you ever work with something that's package starts with javax? that's ee experience. Basically (jpa, jax-ws, jax-rs, jax-b, ejbs, bunch of other shit I'm forgetting) or ever debloyed java to basically any java web server, might get a close enough with spring boot even. It encompasses such a dragnet of shit that I'd be shocked if you really hadn't done any of it, and instead just hadn't realized you where doing it over that time period. hell it's worth a read http://download.oracle.com/otndocs/jcp/java_ee-7-mrel-eval-spec/index.html Although if you where doing weird swing/javafx gui junk there are jobs for that too, I keep seeing people talking about them on reddit, never did that but apparently that's a thing. oo android java devs too, but oracle beats us if we speak of them.
Lot of those junior filter ones aren't really even handled by one of the devs it's often they grabbed an easy mode questionnaire off a site and are using it to cull the several hundred applicants, in that case you have to be strict and precise and it helps to be able to sniff out what java version they're talking about(but that's generally over phone too) If in person, it's generally at a stage where you can be a little looser they're as much judging character there (no one wants to work with high strung nervous) and as long as they get the gist you know it you're good. 
Swing and ImageIO are javax packages I'm used but those are part of Java SE. The companies hiring for Java EE are wanting EJB and web stuff.
yea that's a different horse @.@ pick up some jax-rs, jpa and learn how to play with a web.xml and you'll knock out like 90% of your average jee developers day with it. or search java jobs with swing, that has nothing to do with web junk they shouldn't want jee.
I've only ever spotted one Java job advert that wasn't for EE.
Worth learning, pays gud yo.
Effective Java by Joshua Bloch has a great section on this, I can really recommend it. It's a great read overall, too.
Well, if its a queue you're after then surely ArrayDeque is the choice over both ArrayList and linkedlist.
Java doesn't give you that kind of access to the native hardware. Java runs in a virtual machine. That low level of access would require [JNI](https://www.ibm.com/developerworks/java/tutorials/j-jni/j-jni.html), in which case you're writing C/C++ code.
Wait what? Joking or I haven't read something...
JavaFX will be part of java for the foreseeable future.
Huh, ArrayDeque is optimized more than I thought. I guess I would have to agree with you there. Seems like it would only lose when inserting in the middle which is pretty uncommon.
what's wrong with spring?
The first one is clearly shady but didn't Sun do that already since a decade ago? The second isn't shady at all, they're just a big company protecting their IP - and it isn't as much about them using Java as them using the Java API which really was an unprecedented legal issue before the case was settled in favor of Google. Oracle could have been nicer but they're a company and they wanted a fair share of Android's profits for using their API - nothing really wrong or unethical with that, even if it isn't the "nicest" thing to do like '"hey use all my stuff for free idc".
Oh this is for rest apis. Figured it was for any java library. 
Is Electron a better alternative?
I would not totally dismiss the possibility of extracting modem data, nor would I go as fatalistic as /u/_dban_ in saying that you absolutely need JNI for that purpose. The catch is that you need to know whether your modem supports [SNMP](https://en.wikipedia.org/wiki/Simple_Network_Management_Protocol) (or any other similar mechanism). Then it's fairly easy to extract modem data using a Java SNMP library. Alternatively, quite a lot of modems support [Telnet](https://en.wikipedia.org/wiki/Telnet) a fairly old protocol to interact with remote computers. That could also be used.
**Simple Network Management Protocol** Simple Network Management Protocol (SNMP) is an Internet-standard protocol for collecting and organizing information about managed devices on IP networks and for modifying that information to change device behavior. Devices that typically support SNMP include cable modems, routers, switches, servers, workstations, printers, and more. SNMP is widely used in network management for network monitoring. SNMP exposes management data in the form of variables on the managed systems organized in a management information base (MIB) which describe the system status and configuration. *** **Telnet** Telnet is a protocol used on the Internet or local area networks to provide a bidirectional interactive text-oriented communication facility using a virtual terminal connection. User data is interspersed in-band with Telnet control information in an 8-bit byte oriented data connection over the Transmission Control Protocol (TCP). Telnet was developed in 1969 beginning with RFC 15, extended in RFC 854, and standardized as Internet Engineering Task Force (IETF) Internet Standard STD 8, one of the first Internet standards. The name stands for "teletype network". *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.26
&gt; Can you give an example where we don't detect booleans properly? We'll update to "is" for boolean getters later today. I meant just the is vs get bit. &gt; Lombok is amazing! Do you think we should target it by default? It would be a nice addition. And I definitely think you should just make this a web application, much more convenient than having to install / download something. &gt; What do you mean by "massage" for PascalCased JSON? Do you mean you want to output massaged JSON? PascalCased properties are already lowerCased. I often have to get data from an external API, change it into something else and then pass it on again. The time is not spent for me in creating the Java classes for the JSON (like I said; it's almost no time with Lombox) but the mapping and the @JsonProperty annotation stuff I need to add to change a JSON property like "isEnabled" to "enabled" in the POJO so I don't end up with "isIsEnabled" getters. &gt; Can you share an example where separate classes are generated for the same object type? This shouldn't be the case, perhaps it's a bug. Just try yourself? I can't send you the stuff I'm working with (NDA and all) and creating an example is quite a bit of work. 
Most modems (I'm assuming you're talking about the old analog phoneline ones) can be accessed via a COM port and Java can communicate via COM ports.
&gt; My question is how does someone with bad memory get passed these interviews and why do we even have them?? Like the other day I had an hour long interview, which consisted of questions like difference between comparator and comparable, hashset and hashmaps, what to extend from collections? What is equals and hashcode... all of these questions can be answered with google... there’s no point in memorizing all these. You just showed them you're not a "Java developer". You would've known these things if you had actual experience. You also sound pretty entitled. Companies don't 'owe' you a job. Hiring is a risky business for companies so you can't blame them for being careful. 
&gt; (a lot of it is -- StringBuilder vs. StringBuffer for example). How is knowing that the latter is synchronised a "waste of time"? 
If you like starting up the whole browser each time and use ^shitty JS, go ahead.
Depending on what you're looking to extract, it's definitely possible. A quick google search for 'java modem AT commands' will yield you some results. Modems can be communicated with via COM ports, issued what are known as 'AT' commands. Lookup any references to the Hayes AT command set and you'll see what I mean.
Javafx comes as opnjfx for openjdk 
That's irrelevant - JavaFX isn't part of the ARM build of JRE8, so it is a valid question asking whether it will be in 9 (my suspicion is no, but I have no concrete sources)
Clone core java 10th source code examples, etc. Learn how to use grep.
But you have to build it yourself if you want ARM support, and still not all features are supported. See https://wiki.openjdk.java.net/display/OpenJFX/Platforms 
See this https://bobcares.com/blog/lxc-vs-docker/
Do you think I could learn it in a year (which is when my current contract runs out) well enough to get a job?
Electron has a better developer experience, but it has a long way to go to compete on a user experience.
Do you want to send/receive data to your program or monitor the data flowing through the modem without interfering with the app using the modem? 
volume vs pure data container, the later is more port 
Yet another proof that Hibernate is just awesome!
Strongly suggest taking Handbook of Academic Integrity book or any other academic cheating article and read it before you take that exam... Test are normally designed to have little time per question so I doubt you will have lots of time to search for your answers. If I were you I would just try it without any materials, since it will take too much time to use them imo, but good luck anyway. 
Isn't running a Java Virtual Machine inside a Docker Virtual Machine a bit odd?
I am also against tests that really force you to memorize useless stuff like all methods in some class and be able to type all of them from memory. But all things you wrote are basic java questions. You have to understand that these people don't know you so you need to show them that you know the subject and you just performing really bad on interviews. As example you could show them your personal github account full of projects, you can become some contributor to some open source project or have stackoverflow account with lots of reputation. There are several ways to show your knowledge outside interviews but they require lots of work in your free time. Sometimes if you impress person interviewing you you can get position even if you poorly perform on interview. 
&gt; using Electron no thanks
Container != Virtual machine On Linux a container boils down to namespaces/cgroups to isolate the processes. If you avoid writing to the containers filesystem there's next to zero loss in performance. You can use docker containers in VMs though and that's what Docker is doing to be able to run on Windows.
Second ad in a week?
Honest question, do people honestly use JavaFX? Who? For what? 
I use modem like AT commands to talk to an obd adapter from java, it is just a protocol over serial. Currently I'm using jssc as it is fairly cross-platform. https://github.com/scream3r/java-simple-serial-connector
For starters, every modern IDE will shove you towards StringBuilder if you somehow decide to use StringBuffer. I've yet to run into a situation where a synchronized StringBuilder (aka StringBuffer) is required and off the top of my head the only time I could imagine it would be some sort of logger, but then again, we shouldn't be writing our own loggers these days... Secondly, to your point, it's not a waste of time to **know** about it. However, I'll maintain it's a waste of time to **interview test** people about it. I mean, c'mon -- if your company is needing to hire people who know the difference, then fine -- but I'll betcha $20 you don't.
Wow that's incredibly inaccurate. See the first answer here: https://unix.stackexchange.com/questions/254956/what-is-the-difference-between-docker-lxd-and-lxc
Docker uses LXC.
Of course they don't hire for that knowledge specifically. It will be part of a list of questions. If you know 90% of them but didn't know that one specifically that isn't a problem. But not knowning 90% of these types of questions just shows you have very little experience.
For fucks sake, can we stop this comments here in /r/java? just google a bit and you will see big companies using JavaFX, and if i'm starting new GUI project definitely is going to be JavaFX because i know Java and it's cross platform and maintaining a JavaFX app a cross years is going to be mush easier than making some react or angular app that need mush work to maintain for internal only apps. 
I don't ask to be inflammatory. I've never seen an FX app professionally. I've been in industry for 14 years. I know the support is in the JDK. I see people ask about it here occasionally. Every time I think, "Really?" I'm not unwilling to explore the ecosystem; I just haven't had a reason to since I see nothing being built with it. It's not mocking. JS development is still immature. I'm in full agreement with you there. It doesn't change what I've seen though. 
Totally agree. People have very limited knowledge can do stuff, but that restricts them from doing a good job. 
I'm the other author of quicktype. &gt; Just try yourself? I can't send you the stuff I'm working with (NDA and all) and creating an example is quite a bit of work. The reason we're asking for an example is because we don't know what you mean. If an example is too much work, could you maybe explain it differently? Again, thank you for your feedback!
yes, people use JavaFX. I'm using it. For client side / desktop applications.
I see, I misunderstood the question.
I dunno ;-) But at least, [it's helping me get some cool stuff done](https://blog.jooq.org/2017/08/24/jooq-3-10-supports-jpa-attributeconverter/)
I stopped reading at "The desktop app is built using Electron". Why is an app written in Electron in a Java sub-reddit?
How is this a better software than eclipse ?
I read the article and it looks like it also helped you to write the data, not just to navigate the entity bindings :D
I posted something similar as a stack overflow answer only I used `org.hibernate.boot.SessionFactoryBuilder`
JavaFX is used perhaps more often and for more significant purpose as is realized. For example, iIn our company an entire line of products (analytical instruments) has GUIs implemented with JavaFX and these include embedded systems for hand-held ARM/Linux devices and Windows/x86 desktop systems. Their development started from scratch oroginally with JavaFX 1.3. We are using JavaFX 8+ now.
What most IDE's like Eclipse give you is "Go to definition", "Find All References" and "Find symbol", which is pretty nice for quick lookups, like figuring out where a function is called by looking at all references in the result list. However, if you are working on a big code base, that you didn't write yourself, you spend a lot of time doing these "quick" lookups. About 70% of software developer time is used on that: https://blogs.msdn.microsoft.com/peterhal/2006/01/04/what-do-programmers-really-do-anyway-aka-part-2-of-the-yardstick-saga/) We developed Sourcetrail to make it faster to navigate source code and provide more information at once. The graph visualization gives you a quick overview of how a class/function is referenced/referencing other symbols and the code view shows you all places of interest at once. Every element in the graph and code can be selected with a click to go further down the rabbit hole. Plus Sourcetrail provides features like call- and inheritance graphs, history stack, bookmarking and integrations with most source code editors and IDEs. Please watch our intro video, which explains all of this in detail: https://www.youtube.com/watch?v=ST1AmwUN6rw 
Yes, JavaFX has better and faster FileChooser dialogs for Windows 10.
You should add the SO answer here as well. I'm curious about your solution.
Oh those services...
Most interviews consist of sort of standard questions. Both in HR and technical aspects. And you have to solve algorithmic problems on paper or board. Pretty managable to "study" for the interview. I landed a junior developer job with few months non-professional experience.
Probably, it's not too hard especially if you already have a good base in java. There are many small parts to it, try narrowing down on one you want to learn at a time and make a simple little scratch demo web app for it, probably want to stuff it up on github having a portfolio is sometimes useful. Oracle has a pretty nifty tutorial, https://docs.oracle.com/javaee/7/tutorial/(which now that I'm looking at covers parts not everyone really uses, like don't think I've ever seen someone really use javax.validation for some reason, dunno why looks good), also bunch or quick online you tube videos for smaller parts of it. 
I think I figured out what the issue is. If two object types have the exact same fields; it works and created one class. If two object types have all but one of the same field; it still works. If the delta is two or more it doesn't see the objects as the 'same' thing even if the object with less fields always has the same fieldnames anyway. So it's not obvious you have a 'lite' version of this in place already because in my case the objects had 2 out of 8 fields that were optional. So to get the correct output I need to also add those fields to the input JSON myself. 
&gt; If I chose to write a custom Comparator I (we) would have to ensure that it remains in sync with what the related Comparable is doing; worse, Uh? Why? The entire point of writing a Comparator is that you want to use a sort order that's _different_ from the natural sort order of the type you're sorting. For instance, if you want to sort Strings by their length rather than alphabetically.
https://zealdocs.org/ As a serious answer.
[Portable google] (http://archive.oreilly.com/pub/a/onjava/2003/10/01/searchassist.html) :) .At least one can learn a lot trying make this work with today's java/browser. 
neat. you should probably .gitignore the project settings .iml/.idea/.ide, etc... not sure why you have this in .gitignore: # Allow saving of IntelliJ settings files. !.ide/*
Maybe I’m doing something wrong, I don’t have issues with algorithmic based interviews, just the memorisation portion
Thanks! Yep, this was supposed to be temporary while I was getting my IDE settings finalised. Makes sense to remove it now :)
Yes, we have to use heuristics to figure out which types are the same, and sometimes they fail. In your particular case, are there any other hints that could tip us off that those are the same type?
Vague question :) I'll assume you mean writing a GUI using Java For GUIs built with Java: https://github.com/akullpp/awesome-java#gui 
https://intellij-support.jetbrains.com/hc/en-us/articles/206544839-How-to-manage-projects-under-Version-Control-Systems
Thanks
Damn! this is gold! wish i knew this before the test :D it went ok though :) 
Start [here](http://docs.oracle.com/javase/8/javase-clienttechnologies.htm). Java Swing is the "classic" way to do UIs in Java. JavaFX is the "modern" way. Bonus: There is a third way called [SWT](https://www.eclipse.org/swt/). Java Swing and JavaFX let you create UIs that work on any system by drawing everything, like buttons and text fields. Your UI may not look exactly like other UIs written specifically for that system, but your UI will work the same on any system. SWT uses native controls, letting the system draw buttons and textfields. But your application will behave slightly different on every platform, but at least it will look like it belongs there.
We sure do. On desktop apps. It's such an improvement on swing... We will never go back. 
Yes, Comparator is for defining a self-contained sort order, natural or not. Comparable returns &lt;1, 0 or &gt;1 based on the definition of equals. This is natural ordering. Whether one or the other imposes more maintenance or not entirely depends on the overall implementation and use and planned future use.
Is not Java EE?
A has all the elements of B, so you could assume the rest is optional. And this is why basing it on a Schema instead of Data is in general a better idea. You need to make a lot of assumptions and those tend to be wrong often. 
You are gravely exceeding the *self promotion* to *contribution* ratio. Your only participation in reddit is to promote your site. This is unacceptable behavior. Either you participate in other discussions as well *without promoting your site*, or you leave. Consider this your one and only warning. Should you continue, you will be banned without further ado.
2 days ago: [When can I consider myself intermediate...](https://redd.it/6v9lxh) There: [Still going through the MOOC...](https://www.reddit.com/r/learnprogramming/comments/6v9lxh/at_what_stage_can_you_consider_yourself/dlysta6/) How about you finish at least both parts of the MOOC and become proficient before venturing on? You are just jumping around without actually learning anything well enough to get it to stick.
I will! Thanks for this friendly warning :)
Spring with Webflux 
Your question is too vague to really answer well. What kind of modem is this? What sort of information are you looking to extract?
Yes. Which is why we also support JSON Schema ;-) (only on the command line client)
google "Java interview questions and answers", read it a few times, and you will understand that, and you do not need to memorize it
No reduce/fold, map or flatMap?
And here I am sitting on Jersey 1.x due to compatibility problems.
While the Swing/FX answer is good. You might want to consider a web or mobile interface after command line for maximum portability and to minimize the amount of work you will have to do "from scratch".
Why not suggest why they would be useful and even how they might implemented...
Just in time for them to sell it to another company if they can't manage to find someone to open source it. 
Yep! And pull requests are always welcome! :)
:(
Not really sure what you mean but and I see you get a lot of answers on gui libraries/frameworks. If you want to learn more theory about gui, I recommend "Designing interfaces" of Jenifer Tidwell
Sell it to another company would be particularly weird in this case, sine the Security API has been developed for 97% or so by the OSS community...
I was going to say the same. Unless you absolutely want/need to build a desktop app.. I'd try to find a way to make it work on web. You'll get much more mileage out of learning/building front ends in javascript, with a java back end, if your goal is to get work.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/scala] [How would you code these Scala and Java phone bill calculators? \[x-post from r\/java\]](https://np.reddit.com/r/scala/comments/6vv913/how_would_you_code_these_scala_and_java_phone/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Modem is a iinet TG-789. Ideally, I would like to monitor traffic in a more detailed fashion that what is provided through it's "dumbed-down" web front.
I'm guessing the later? I'm after more detailed monitoring (on something like an hourly basis)
Yet another one. The microservice trend probably indicates a sharp decline in selling webserver licenses for the future, and "JavaEE for microservices" does not smell like lots of license money coming in. It's the fear of the complexities of a monolith that makes customers pay for a commercial webserver instead of using a free alternative. So really, by advocating "JavaEE for microservices", JavaEE evangelists destroy the business model of JavaEE, which pays their salaries.
Oh, that nobody will want to invest into JavaEE anymore is not very meaningful for the future of JavaEE? Your article says "Java EE 9 will see even more APIs designed for the development of microservices and cloud-based applications." But the reason those amazing undisclosed microservice APIs were not delivered in JavaEE 8 already is because nobody invested in making them happen. Oracle certainly did not.
I am in the same dilemma. Was just surfing through the courses an hour ago.
It's a common complaint for people used to work with languages that work well with Editors like Vim or Emacs instead of IDEs.
* Java does not allow micro-optimizations such as pointer arithmetics and custom garbage collection. * Program startup is delayed by the time to start the JVM * Installing java is a bit annoying * Java in the browser had many security leaks (was never a good idea)
Why is backward compatibility an issue here? That's where Java shines, compared to Python2-&gt;Python3, Perl5-&gt;Perl6
He's a bot. He only needs a few moments to learn.
&gt; `Java does not allow micro-optimizations` Which results in very few people using Java for any high-performance, algorithmic, or R&amp;D style work. Which sucks for people like me who love that kind of work. &gt; Installing java is a bit annoying Ask Toolbar &amp; other crap? Adding a few more to my list: * Java culture discourages innovation and creativity, and a lot of Java devs are stuck in their `ServiceUtilAbstractFactoryBuilderImplXmlConfig` ways. * Spring MVC - Technically not Java's fault, but if I never have to fix another vague Spring Autowire dependency issue, I won't complain. Sadly, some Scala libraries follow in it's footsteps with implicit context (etc). * JavaEE - Another can of worms. * Oracle's restrictive policies - You can get just about every free dependency on the planet from Maven central, except anything Oracle. * The Oracle vs Google Android Lawsuit - The only reason I started programming in Java in the first place was Android, and now it just feels dirty. * Java 8 - A step in the right direction, enabling basic FP with reduced verbosity, but their implementation was extremely incomplete and in places deliberately ignores established FP patterns. 
I just started it, but the free version. Its nice to relearn some of the basics of threads, futures, sockets etc. 
A container is not a virtual machine at all. It's a jail. 
Its pretty good. You can audit the courses individually but not the entire specialization. A thing I like about these courses is that it teaches both the concepts and their implementation side by side, which is nice. 
How many more times do I need to tell you: **Do not post tutorials here!** Told you [9 days ago](https://www.reddit.com/r/java/comments/6tybqw/client_server_communication_in_java/dlrrii4/)
This definitely looks interesting. Is it a full code editor though or *just a code explorer*?
Still no asynchronous streaming of large requests or responses with proper back-pressure control :( 
For installation I was also thinking of license issues preventing (Oracle) Java to be installable easily via package managers of linux distributions. The existing solutions are all workarounds. Same for side-by-side installations of different versions, all solutions that exist are workarounds around Oracle's general disinterest in the topic. Or think of sharing docker images with (Oracle) Java on dockerhub.
At the moment it's just a code explorer.
... ok, I'll bite. Did the search, found out some results of the Brian Goetz book. And? Am I missing something?
But let's not all do the search at the same time.
And then we say we can't find good coders coming out of school. 
Because we want smart people, not google monkeys. And because we have so many to choose from, we take the smartest ones. 
Backwards compatibility is a trade off: it let's you run very old codebases together with newer things just fine, but it hurts the consistency and makes adding new and sensible features impossible sometimes. Think about stuff like dropping null or making null an object (e.g. null.map(v -&gt; neverExecuted()) or even going for non nullable types by default (like in C# 8.0). This will never happen because it breaks old code. As for Python2/3: there were just too many (good) changes at once for people to migrate gradually. There wouldn't have been any fuzz if problematic things were phased out gradually.
Good memory doesn’t show intelligence, half of my coworkers from IBM have no idea what they’re doing and the ibm interview is exactly like the one I had....
Why would I want to pay for this when [JHipster](http://www.jhipster.tech/) and [Spring Initializr](http://start.spring.io/) exist?
So get to work then. That's what open source is for.
That's what I was wondering. Not sure what this offers that those two options don't
Definitely, JHipster is a great tool to generate a skeleton project, but SBT [features](https://www.springboottemplate.com/features/) are different and take care of some enterprise commons needs (such as excel and pdf creations) and provides samples for some edge cases which are hardly explained in tutorials.
The more the merrier edit: actually I see that it's a paid for product so maybe not.
Yes SBT is a "commercial" product, not OSS. It helps reducing development time so it may be worth the cost of it.
What about opening one third-party module to another third-party module? Say, a nice library containing a bunch of useful data-holding objects on one hand and a niche serialization library on the other. This is eerily similar to the issue with Rust that you can't implement an external trait for an external type: https://github.com/rust-lang/rfcs/issues/493 while you can in Go or Haskell.
start.spring.io is all what you need to create spring boot app faster !
HTTP2 maybe? H2 is a well known in-memory database.
I was confused, HTTP2 makes more sense.
You'll have to modify the former module.
Yep, a little confusing. Although I have seen HTTP/2 abbreviated as h2, for example in Chrome's dev tools.
It makes me a little sad how often exceptions get abused in Java web frameworks just because its easier to handle errors that way. 404's and validation errors aren't really exceptional circumstances and can easily be handled without exceptions.
I started with a paid online class room, because having other students around you and access to a coach can be invaluable. I had programming experience before, though. After that I started writing code like a maniac for a while to get my brain to adapt to the required thinking patterns until they pretty much became a part of me and to learn the ecosystem. You just need to start somewhere and do something. Also, talk to people and let them talk to you! But that's a lesson you obviously learned already.
Hey thanks for your advice! I think in my situation I have to just sit down and crack open the book. I’ll read the concepts and work all exercises. Surely that method of learning works? But then again it’s like you said... I have to start somewhere and do something. 
10.000 hours of coding with it. 
With what 
Java
Find a project with some depth that you want to complete. Then complete it in Java. If you run into something you don't know how to do, then look it up. The only real way to learn a programming language(unless you have some kind of photographic memory) is to use it. You can't read your way to actually mastering a language.
I learned without a book or class. I knew Perl, but understood the concepts of OO programming. So I just banged out a LOT of code for different projects (both for work and fun), searching for how to do certain things, reading a little bit of other code to see how things worked and using some of the cool libraries out there. But primarily, just banging out a LOT of code worked for me.
Ahhh okay. I thought you meant you spend hours with a certain method of learning
Yes, I read constantly and I coded many many moons solving problems and creating programs. After 10.000 hours I feel like I mastered something. You have google now. When people learned before 1995 there was no such thing, i wonder how these guys did it...hmmmm
Good point... never thought of that :/ Thanks man
That looks like an independent network device, not connected to your computer. You likely will not be able to talk to it except through what it exposes. SNMP is your likely best bet. If that isn't supported, then probably scraping HTTP calls.
I don't think OP has access to a hyperbolic chamber. 
Since I already knew programming, transitioning to Java was not all that difficult. A couple lessons of [Java for Complete Beginners](https://www.udemy.com/java-tutorial) to get a quick overview were enough for me. For someone willing to learn Java, my recommendation would be the MOOC [Object Oriented Programming with Java](http://mooc.fi/english.html) and the above course as supplement. Plus, lots, lots, and lots of practice.
Textbooks are very meh in my opinion especially for beginners. Looking at real life examples is the only way to become comfortable with the concepts. Programmers look at these concepts as puzzle pieces. When you're a beginner, each piece looks like a complete picture. So, looking at the big picture and how each puzzle piece fits gets you in that mindset. You'll learn that there's a learning curve when it comes to learning languages. 
When I was going to university, I found out they teach Java so I worked my way through the recommended textbook during the sunmer break after leaving school waiting for university 1st year to start to get a head start. It was easy as I'd already taught myself OOP before.
4 years watching youtube videos and the next 4 making stuff without help and looking up errors.
I was thinking something similar to Arrango's Foxx framework
Funny you should ask. Helped run a MUD on the guy's machine who would later create Android, back when he was at Motorola, and tracked down that hosting arrangement. That was when the 'net was NSFNet, and only large research institutions were on it and you couldn't just buy access or hosting. Hung out on a MUD dedicated to teaching OO programming that some of the early Java luminaries also taught coding on. Taught many people to program including someone who would later go on to be CEO at McAfee. Interned at the Java and Web Services in the micro division at the University of Minnesota for the guy/team that created Gopher. Owned just about every edition of _Java in a Nutshell_ and thumbed the heck out of them, especially the 2nd ed for 1.1. But I actually know very little Java tech by today's standards.
I already knew how to program, but to learn java specifically, my teacher 'forced' us to read through Bruce Eckel's Thinking in Java, which can be freely found online (or could at that time, it was more than 10 years ago).
&gt; because its easier to handle errors that way Well yeah, it's easier that way because Java was designed to handle errors that way. It's the whole point of checked exceptions. try { // happy path } catch(ErrorCondition1 ex) { // whatever } catch(ErrorCondition2 ex) { // whatever } This pattern neatly divides up normal processing and processing of anomalous conditions, so that you don't clutter up the happy path with conditional logic. Checked exceptions are a compile time indication of what the anomalous conditions can be. Functional languages can do the same thing without exceptions using the `Either` type: let result = do -- happy path case result of Right normal -&gt; -- handle normal result Left error -&gt; case error of ErrorCondition1 -&gt; -- whatever ErrorCondition2 -&gt; -- whatever By the way, Java's [not ready](https://www.reddit.com/r/java/comments/6uyj50/psa_complex_lambda_expressions_murder_eclipse/) for this yet. When Josh Bloch mentioned that exceptions should not be used for flow control, he meant things like using `NoSuchElementException` as a termination condition for a loop. This usage of exceptions confuses the actual termination condition of a loop using an error that should mean that the program is broken.
Is microprofile group working on them!🙄
My point is a not found element shouldn't be an exception. Maps don't throw not found exceptions they return null. public Response doStuff(Request request) { User user = dao.findUserById(1L); if (null == user) { return Response.notFound(); } return Response.ok(user); } This is easily doable in most frameworks but everyone opts for throwing exceptions.
I don't really like this approach. You have to know that the method returns null and specifically check for it. As everyone knows, null is a [billion dollar mistake](https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions). It also doesn't look pretty. You are obscuring the happy path (return the found user) with a conditional check. With checked exceptions, you are forced to deal with that possibility: try { return Response.ok(dao.findUserById(1L)); } catch(UserNotFoundException ex) { return Response.notFound(); } Or even less code: public Response doStuff(Request request) throws UserNotFoundException { return Response.ok(dao.findUserById(1L)); } In Java 8 though, you have `Optional`: return dao.findByUserId(1L).map(Response::ok) .orElse(Response.notFound());
**Tony Hoare: Apologies and retractions** Speaking at a conference in 2009, he apologised for inventing the null reference: I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.26
I think the java8 optional example is fine. The other two are once again using exceptions for control flow which is generally not recommended. I wouldn't be too concerned about the performance from using the exceptions since most requests would be valid and have responses. However, it still adds a layer of indirection. Java has nulls so we are stuck with them and its fairly common for methods to return null this isn't anything new for a java dev. &gt; It also doesn't look pretty. I don't think this is ever really a good argument. Code should be readable, anything mildly complex will never look pretty. A null check and an if branch is nothing complex and even a junior dev would understand it immediately. In the other approach similar to how we have to "know" that a method returns null we have to "know" that there is a magic exception handler wired up somewhere that will eventually handle this case for us. I have been in a lot of code bases where it would take forever to track down some error response because it was being manipulated by exception handlers and it wasn't inherently clear where or why. The slightly more verbose way of inlining it there would never be a doubt why it was happening. 
&gt; The other two are once again using exceptions for control flow which &gt; is generally not recommended. That's not really what Josh Bloch meant when he said don't use exceptions for flow control. He was talking about something like this: int[] items = // ... int i = 0; int sum = 0; try { do { sum += items[i++]; } while(true); } catch(ArrayOutOfBoundsException ex) { return sum; } The problem with using exceptions for flow control is that the flow control is completely obscured. This method exits the loop with a nonlocal goto and returns the sum out of an error handler. I don't mind indirection if it means added safety. &gt; Java has nulls so we are stuck with them Not necessarily. For example, you can throw an exception. Returning null is a choice. The problem is that Java devs *often* forget to check for null (or add defensive null checks everywhere, making code messier), which causes bugs. &gt; I don't think this is ever really a good argument. It's not really an argument, it's an aesthetic preference. But, I do like to minimize the number of branches as much as possible, because that is yet another source of bugs. &gt; we have to "know" that there is a magic exception handler wired &gt; up somewhere that will eventually handle this case for us. If this is Spring and this is a controller method, presumably you have an `@ExceptionHandler` annotated method nearby in the same controller. This lets you basically abstract out the catch block from multiple methods which can throw that exception, further separating out the error cases. I wouldn't go beyond the controller level and create an uber-exception handler. I agree that too much action at a distance is hard to debug.
Im still a Student but I mostly taught it myself. I'm not a professional, but learning the basics isn't too hard. Once you know the basics you can start expanding your knowledge. And of course you need a lot of practice. But since we have the internet finding help and/or inspiration shouldn't be a big deal. I started of by making my own small RPG with Pokémon graphics. What starts as a simple idea can evolve into a way bigger project. And this will turn into new knowledge and experience. Everybody has to start small, don't expect to much when you are getting started with programming. Start small, finish your projects, achieve small milestones. That's how you will slowly gain more and more experience to handle even bigger and more complex problems. 
&gt; That's not really what Josh Bloch meant when he said don't use exceptions for flow control. He was talking about something like this: In my opinion the exception handlers are doing exactly this. Let's rewrite it. public class UserRepo { public User findById(long id) throws NotFoundException { ... } } @Get("/user/{userId}") public User getUser(@Param("userId") long userId) { return userRepo.findById(); } // Some hidden away code in the framework try { Object thing = ... return Response.ok(thing); } catch (Throwable th) { // This is where we map to an error response exceptionHandler.handle(th); } In this case the developer did not write the try catch block but that doesn't mean its not there. This is using exceptions for control flow because it can easily be guarded against. Exceptions are generally more outside of your control like networking issues, sockets closing, a file not existing that should exist. I guess the file thing can be translated to a database but the JDBC driver already gracefully handles that for us so its no longer an exceptional circumstance. I also think people use Unchecked exceptions for this purpose which makes it even more difficult to track down. &gt; It's not really an argument, it's an aesthetic preference. But, I do like to minimize the number of branches as much as possible, because that is yet another source of bugs. Fair point, I do find some people go a little overkill with aesthetic preference but as long as the team agrees its fair game. &gt; I wouldn't go beyond the controller level and create an uber-exception handler, because action at a distance is indeed hard to debug. Agreed, it does make sense to have some global exception handlers but that shouldn't be the norm. Personally I understand why people go this route it just seems to break some rules in my opinion. It definitely makes the code less verbose but can complicate things from the debugging end. Another issue I have seen is global filters / exception handlers that need special logic to handle various different scenarios. In that case I would say it should definitely be in the routes themselves not at a global level.
I learned it after taking AP Computer Science A, and have been going strong with it ever since.
If you know another popular language, learning Java is fairly easy as you can apply concepts you already know to it and just learn the new syntax. If however you don't know any programming language, then yes you should sit down and read through the book once. After that, I'd recommend doing programming examples or little projects/utilities for yourself to gain familiarity. 
I've actually considered buying a pen-camera just to record audio in interviews so I can replay it later and write down what questions they asked. If you do a phone interview it's easy to record the call. 
Can someone ELI5 Netty?
How did I learn Java? Started with Bukkit plugins and started learning how things worked that way. My personal method of learning is figure out how it works by going hands-on. Could never sit and read a book to learn something.
Poweerrrrrrr!! Speeeeeeddd!! Lightweeeeeighttt!
Mostly by doing. Having said so, in recent years, I've spent more time "unlearning" Java (and its inherent but unnecessary enterprisish overengineering)
Any move towards making everything a "collection-like" thing is great as it encourages (to some extent) SQL-esque set based thinking
Cool. Now, when will this get a SQL API? 😉
I must say I found the writing part a bit harder than I expected. Persisting a many-to-many relationship didn't seem too intuitive to me...
writing code. failing. writing again. succeeding. rinse and repeat. 
It is type casting whatever the openConnection() method returns. So for example if the open connection returns an object of type "Connection" then to get an HttpConnection, you can convert (or "cast") it to a different type. This assumes however that the two classes are related in terms of inheritance hierarchy. A simpler example is casting a number of type double to an integer like this: double d = 2.7; int i = (int) d; // i is now 2 Try googling some of the words I used for more info. Like "what is type casting in java" (or any typed language for that matter)
It's called casting. For future reference, from the sidebar: &gt; No programming help questions here! These should be posted in /r/javahelp
It is called a cast of type. Your url.openConnection() returns a reference of type URLConnection, whereas you want to assign it to the HttpURLConnection variable, a subtype of URLConnection. Since subtype can have additional methods, that are not declared in supertype, you need to cast supertype to a particular subtype. But be careful with casting, you need to be sure that reference you want to cast has correct type. You can check this with instanceof operator. Overall I'd suggest you to limit usage of type casts, to avoid runtime exceptions.
&gt; When people learned before 1995 there was no such thing, i wonder how these guys did it...hmmmm library, books and search index :3
That's casting. The `openConnection()` method returns an `URLConnection`, but the author here was sure the returned object is actually `HttpURLConnection` (a more specific type), and so gave the compiler a hint to convert the former to the latter. If the type is not what the author thinks, the program will throw an exception at runtime. If the conversion succeeds, you'll have a correctly typed object to use. https://howtoprogramwithjava.com/java-cast/
The second HttpURLConnection *casts* the object to that type. What url.openConnection() returns is only a URLConnection, but it can be cast to a HttpURLConnection because URLConnection is the *super-class* of HttpURLConnection. To give you a small example of how this works here is a small example: Given two classes: class Foo{ } class Bar extends Foo{ void doSomething(){...} } We can do the following code: Foo object = new Bar(); object.doSomething(); // Compiler error because the "object" variable's type is Foo and not Bar, thus it only has the methods of Foo // But we can still use the doSomething method from our Bar class by casting it! Bar castedObject = (Bar) object; castedObject.doSomething(); I hope I could explain it well enough, usually if you have questions like this I suggest posting them under [StackOverflow](https://stackoverflow.com/), as the community there is geared towards answering questions like these. :) 
Sorry thank you.
That's exactly what I was looking for thank you so much for you helpful reply!
Thank you for your helpful reply!
Any sufficiently advanced technology is indistinguishable from magic.
Thank you for the help!
Thank you, your explanation was great. This reply was very helpful.
I learn best with a good book to read through when I have dead time, and a combination of blogs / working in the language. I don't do well with video tutorials, I have to take notes. I have had a few different Java books, but for me "Core Java for the Impatient" by Cay Horstmann, in addition to a "Data Structures and Algorithms in Java", "Concurrent and Real Time Programming in Java", and "Generics in the Java Programming Language" were helpful. Generics and concurrency might be the hardest areas of the language to gain proficiency at. After you have proficiency in the language itself, I'd install Glassfish, and start working with Java EE. EJB (enterprise java beans) is a good area to explore. I'd also install the Android SDK and pick up mobile application development for Android devices. It's a rewarding application area of the language in terms of what you can do with it.
Since this is help with *Java programming*, it should be, as the *plenty hints on the page* indicate, posted in **/r/javahelp**. **Post removed**: programming help
Writing Minecraft mods
Practice as much as you can. That's what makes you perfect coding Java. But, sometimes Java gets a but too complex and it's important to make sure you know ow to solve errors within your code. Practice is important here as well. It sometimes gets to hard and there tools who helps detect and solve errors such as checkamrx. It's still important to practice as much as you can.
I've presonally stopped trying to learn programming languages from fat books. I forget most of the crap by the time I'm done reading, even if I do the exercises. I personally read tutorials (eg. jenkov.com, vogella.com) that don't insist too much on the internals. That way I get an idea of how I can use the language, and then I start doing some little projects.
Here's the tutorial I used to learn a little about JavaFX: http://zetcode.com/gui/javafx/
Firstly, there is no such thing as Java9, it's Java SE 9 if you're talking about the spec, OpenJDK 9 if you're talking about the source code or JDK 9 if you're talking about a binary distribution. JavaFX is not part of the Java SE specification and is not part of OpenJDK 9. It is a separate project, OpenJFX. Oracle used to ship JavaFX as part of their JDK binary distribution for ARM; they still do for the non-embedded distros (Mac, Linux, Windows). It got dropped for ARM at one of the JDK 8 updates (I forget which one). The EA builds of JDK 9 for ARM do not include JavaFX and there is no reason to suspect it will be included in the final release. Oracle are reducing support on ARM (no more ARMv6 support in JDK 9), not increasing it.
When I was ~14 I've played an MMO type game on an emulated server. The server was written in Java. I wanted to learn so I seized the opportunity and coded. Learned a lot of basics. Many years later I left my comfort zone and applied for a junior position in a company that seemed ok. Time spent coding there and on private projects taught me a lot. Now I feel like I know Java very, very well, and general computer science above average. I suspect another step to keep learning at this stage is to start teaching others :)
I agree.
I thought I would share an example Java project that uses JDK 9 modules and builds with Maven. It has automatic modules (see diagram), and the tests pass. I wasn't able to get the exec-maven-plugin configured (a work-in-progress). I hope it helps others with JDK 9 and Maven. The app is a simple bidding game, derived from a board-game called Rack-O (but quite different).
Well, I don't know so much about Reactive programming, but some time ago I started to study it. I follow the path: * [Reactive Manifesto](http://www.reactivemanifesto.org) * [Reactive Streams](http://www.reactive-streams.org) * [ReactiveX] (http://reactivex.io) I think that this resources will help you to start think in a reactive way which IMHO is the essencial part of all this Reactive thing.
Java programming for Selenium, Java Object Oriented Programming Fundamentals, Java Inheritance, Java Polymorphism, Java Abstraction, and Java Encapsulation. Creating Static and Non Static methods in Java, Reusing Java Class members without Inheritance and With Inheritance. Reusing Java Class 
**Sidebar** -&gt; **Do not post tutorials here!** **First warning** You are a *prime example* of a **spammer**. You only promote your own content and never participate in other discussions. You never even comment on your posts except for promoting your content. This is **spamming** of the finest and absolutely disliked on reddit as well as it is against the **reddit spam rules**.
Very good answer, thanks. Is always good to have things clear very good answer. This is kinda sad, but there are always other options even in other languages. Regards 
I took Computer Science courses back in the 90's where they used Java to teach programming concepts. After that, I read books and did contract work using the language.
I'm glad *you* said it ;-)
Java How To Program (first edition): https://www.amazon.com/Java-How-Program-9th-Deitel/dp/0132575663 
I'm still learning Java, but I learnt other languages the same way anybody learns anything: by *doing*. Making things. Small things. Big things. Interesting things. Useful things. And embrace failure as a natural part of the learning process, try not to get too frustrated with yourself, and remember to build on your failures wherever possible.
It's a library that can provide common client-server framework functionalities on top of java NIO. For example, you can write HTTP server, or any TCP/UDP server application with it
Examples you posted here are not "memory based" questions. It's some very simple questions to screen if a person has at least some very very basic understanding on what he is doing.
I just realized how awesome it would be if Java SDKs came as maven dependencies…
head over to /r/androiddev !
If you already have good grasp of basic Java then you can just directly learn the Android app framework itself. The popular one in /r/androiddev are the Busy Coder Guide to Android Development from Commonsware (there's more in the wiki) For established developers and those who rather had the quick overview and dirty your hands first before heading deeper, use the concise Codepath guides to get the general gist of Android specific "boilerplates" and then refer to the official Android docs AND training by Google (the actual docs and training manual are separate which sometimes can be a major headache if you didn't find what you looking for by just looking at one especially since they both overlap by quite a bit). Just remember your language level fallback is Java 6, while certain Java 7 features are supported from API 19+ (Kitkat) while all Java 7 and subset of Java 8 features are limited to Android Studio 3.0 (which is in beta. Stable is 2.3.3 which support subsets of Java 7). 
!RedditSilver
Java-All-In One for Dummies by Doug Lowe
Just looked up the book and had decent rating. Did it explain everything well? 
Lowe explains everything incredibly clearly. You don't have to have any knowledge of coding to get started with it. 
Is the Android for Dummies any good? 
I remember when it was compared against Perl..... simpler times
Idk I thought of buying it but I wanted a second opinion 
How much does this actually cost? It does look interesting enough.
For starting out, its best if you just stick on familiar language and concentrate on learning the framework first. While there's not much harm on starting out Android with Kotlin, the common gotchas and SO posts for Android largely revolves in Java and might hinder your own pace if you are very new to programming and Android. After learning the framework intricacies, it is pretty easy to switch between the two. Android itself is a pretty vast topic and even after years doing it, I'm still finding new things to break every week. I still can't remember off the top of my head how to properly implement Service binder even after few times doing it, and pretty much requires the doc on my screen before trying to implement it.
Is there a question here? P.s. for these kinds of tasks you'd normally use executors. Also a serializable thread is weird. 
Books get outdated the moment author finishes writing them. Don't learn from books unless you are complete programing newbie and don't know things like loops and so on.
Read the book. Learn the basics first. Once you understand it you can now make different kind of programs just by watching youtube videos. Most likely whenever you have problems just google it and with your foundation you are most likely to understand and apply it to your program. I have a tutorial for making a keystroke logger using javafx (watch this after you have the basics): https://www.youtube.com/watch?v=yhNEE_x6TQQ&amp;list=PLlRMSK1suXjNzJYi2LFrcizgV9mSUto6x Also here is the end demo of the keystroke logger: https://youtu.be/yhNEE_x6TQQ
RxNetty :)
JavaFX **is** a part of the standard JRE since version 7u6. Since JRE 7u6 JavaFX is as much a part of Java as Swing, `java.util` and any other base Java library. The separation of OpenJDK and OpenJFX is merely for historic reasons, it has no standard-based reasoning (i.e. the JRE standard not requiring/requiring not to include JavaFX). From a specification viewpoint, OpenJDK actually cannot be seen as a full JDK/JRE without OpenJFX See: http://www.oracle.com/technetwork/java/javafx/overview/faq-1446554.html#5 
Please read my answer carefully. I state that JavaFX is not part of Oracle's *ARM* distribution. As I also make clear, it is still part of the non-embedded binaries for Mac Linux and Windows. Again, there is no such thing as a JRE standard, only the Java SE standard defined through the JCP as a JSR (I'm on the JCP EC and have worked for both Sun and Oracle so I know what I'm talking about). OpenJDK can most definitely be seen as a full JDK/JRE without JavaFX. We at Azul build OpenJDK and ship our Zulu binaries that do not currently include JavaFX. This still passes the TCK and is a fully compliant JDK.
&gt; Is there a question here? Or any other point to this submission? Is it showcasing something? Also: man oh man that formatting of the Javadoc class comment :O
I couldn't find any official publicly-available specifications of what should or must be included in a JDK/JRE, but any semi-official list I've seen always included JavaFX (sometimes with the note about "since 7u6"). It seems the TCK/JCK is only available after a long and arduous process, and only to large companies, so I doubt I'll ever get to see/use it, but it is very interesting that it does not require JavaFX, yet Oracle insinuate JavaFX is an integral part of the JRE. Can you specify which version of the JRE this TCK/JCK validates? Is there a way you can extract a top-level list of packages it requires, without breaching confidentiality/EULA etc. contracts, of course? Also, since you have worked for Oracle and Sun in the past, do you know or can you elaborate on why such a list isn't publicly available, if presumably it should be a part of the JCK/TCK? Thank you!
I got lucky. I got an internship in a small company and had a training because the company was moving to Java. Ahh, good times working with Netscape Application Server, JDK 1.1... #NOT 
Check out Pluralsights Android learning path. I learned a ton on there 
Are you saying you can’t memorize what methods to override from collections? Are you saying if you don’t know which methods to implement, you don’t know how to override any methods from interfaces in general? Like I said I’ve been a decent developer for the past two years and I haven’t come across these...
Was doing cross platform C++ coding (specifically Microsoft C++ that cross compiled between Mac and Windows) and went looking for something to make that easier. Grabbed Java 1.0.2 and built a small app using the AWT. Since Apple had "Mac Runtime for Java" and Microsoft hadn't yet add their "extensions" to the runtime, and not yet been sued by Sun, it more or less worked. Even used a graphical library called Castanet from Marimba started by a group of former Sun/Javasoft employees. Having a knowledge of C++ made understanding the language easier, the biggest change was the loss of stack level objects and having to allocate each method level object with a new call. Otherwise, not too different. Then became active on various Usenet forums of the day asking and eventually answering questions.
If you are a beginner , I would recommend Android Programming : The Big Nerd Ranch Guide .
After two years lets see if you can say that again, better than java doesn't mean it will top java. 
Java native is not going anywhere. But other JVM languages are eating Java's lunch. I bet you won't argue against that.
[Sounds like bullshit to me.](https://trends.google.com/trends/explore?cat=31&amp;q=java,groovy,scala,clojure,kotlin)
Lol, bad trolling 
&gt; I bet you won't argue against that. The vast majority of development on the JVM is in Java, and that isn't going to change any time soon. However, the alternative JVM languages attract programmers to the Java platform that would otherwise have been turned off by the Java language.
**Sidebar** -&gt; **Do not post tutorials here!**
$49 month
it's "good ol' Java", why would it go anywhere, it's the language of the common man
I took a class that used this book [Big Nerd Ranch Guide to Android Programming](https://www.bignerdranch.com/books/android-programming/). It walks you through making 5 or 6 different small apps that make you learn different skills needed for app development. Liked it so much I bought the ios version and have been going through that! 
Scala jumped the shark a few years ago, I don't know anyone using it for new projects.
Nonsense. If you are into those communities, it surely might appear like that, but if you live in the real world, you will realise that it's actually quite the opposite - in terms of sheer numbers, more new developers are getting into Java rather than any of the other JVM languages, except *maybe* for Kotlin (due to Android).
Hopefully it won't end like groovy did.
Play just released a new version. And spark certainly isn't going away anytime soon.
Java is trash. Kotlin is its messiah
... when you measure a languages worth only by how "FP" it is and how "concise". Those few niche hype driven communities are also the first to jump boat when something new and sparkling pops up. Some boats: Perl, Ruby, JavaScript webframeworks... or most recently Scala. If Kotlin or language x actually manages to gain a substantial marketshare, it's also shoveling it's own grave: The JVM needs continued development which only happens with Java on the top.
It isn't "better". It is "different". Some will like it, some won't. Being picked up by Android folks (of which I used to be myself) probably will be its big downfall/boxing/straight road to lots of shitty uneducated code.
Nice advice that's what's I needed to hear thanks
Play is made by Typesafe/Lightbend, so they really have no choice but to stick with Scala (since their entire business is built on Scala). Note that Play also supports Java, which means it supports Kotlin. Spark also supports Java in addition to Scala, which means it supports Kotlin. I know a number of companies using Spark in production, they all use it through Java except one, and they now regrets using Scala because they recognize that it is on its way out.
I dunno about "mastered Java", but I learned it by working with / on an [open-source game engine](https://github.com/GoranM/bdx) (as I like to make video games). I already knew how to program in general, though. I started off just reporting bugs and the creator of the engine asked if I wanted to fix one myself. I agreed, and have been contributing ever since. It's been almost three years since I started now, and I know Java pretty well.
we use it all the time for spark based projects
I'm starting a 2 year computer programming course this fall at my city's community college. It's ranked 44 in Canada. They teach java and c++ as your first languages. What do you think about that?
The beauty of Kotlin is that the barrier of entry is so low. The integration with plain Java is seamless. You can have a Java project, convert a simple pojo to Kotlin and everything will still work. You can inspect Kotlin byte code and see it's much the same as Java byte code. I've been very sceptical of Scala and other such languages, but Kotlin is just what you would want Java to be if it could drop its backwards compliance baggage and evolve for 20 years.
who say's groovy's over?
The multinational where I work have a number of teams who are building new apps in Scala, and have older (2-4 years) apps that are still maintained and updated with new features, which are in Scala. The team I'm in chose Clojure instead. Mmn, lisp-y goodness...
...why do you need it on your work machine? If there's a business case you should be able to speak to the relevant people to get stuff installed with admin rights. If there's no business case for it then the original question (why) stands, and if you can give a decent answer again you should speak to the relevant people - they won't want you mucking around with stuff on there just because you don't have your own machine though, so pitch it from what the business will gain from it.
Perhaps the serializable thread is for some weird distributed task runner? Not sure how that'd work though.
Scala was too academic. Selling it's rigorous type definition system that no one in industry really cared about. Kotlin sells it's concise syntax and productivity benefits. That's what I really wanted.
Admin people show up once maybe 3 months and I've not even been able to get my own work email as yet. Its not an issue of mucking around in anyone's stuff. The issue is that it's been mucked around for so long by so many that there's a backlog of issues and no one really caring. I could out on a request but but the time it gets responded to, I could literally learn to write Facebook on my phone. Question wasn't "How do I get admin rights?" I'm a programming noob, not a life noob. Obviously, I don't need it for work. As I said originally, I'm trying to learn Java. Since the motherboard in my home of is failing, lots of my programs don't run right at home and seeing as I spend most of my day at work, it would be practical to get in some practice there. Why do you need so much clarification on the why? This seems like a "yes, step 1 is..." or no ask.
It was saved by Gradle and its adoption on Android Studio.
I've done the second answer here before and it's worked. Haven't tried the first but it sounds simpler https://stackoverflow.com/questions/1619662/how-can-i-get-the-latest-jre-jdk-as-a-zip-file-rather-than-exe-or-msi-installe
To be honest, I much prefer Java syntax. I think in classical C-style code, and Kotlinisms are just one big WTF to me. (Also, whoever started this new language trend of putting type declarations after the variable name belongs in an asylum.) Regardless of my personal preferences, I don't think Kotlin will be anything more than an analogue to CoffeeScript from the JavaScript world. Some people will use it in their projects, especially ones that are mostly glue code, but the big JVM libraries and frameworks will forever be written in Java...and therefore knowing Java well will grant a better understanding of the tooling than focusing on Kotlin.
I think that Kotlin already gained enough friction to be popular. Google endorsement and Spring support are two big milestones towards that.
and all the Haskellers that hijacked Scala and in turn drove away those that were promised "a better Java"
&gt; Why do you need so much clarification on the why? Businesses don't typically make a habit of locking down their machines for fun, so even if you find a way of running stuff off, say, a USB stick you may still end up having to answer some tricky questions as to why you did what you did without permission (e.g. in inventory scanning picks up the executive being run, that type of thing). That's why the "why" question is important, as it's the one you'll likely need to answer at some point or another. If there's no benefit to the business, and only risk from allowing someone to run (as they see it) arbitrary applications and code on their machines, then it's a really difficult one for you to sell. In short I'd say you're asking the wrong people the wrong questions here, unfortunately.
Well Eclipse doesn't need an installation and can just be copied. Though if you have no access to the drives at all I see no other way than getting Java and an IDE like [Eclipse Che](http://www.eclipse.org/che/) (never tried) on another machine and develop remotely.
Okay. So do you have any information on the technical side of it though? Because as I reiterate - your concerns about who I'm answering to are a non-issue
Thanks
If we could just take the null safety and add it to java, I would be so happy.
the "trend" of putting type declarations after the variable name has been around longer than java. it's jarring at first but it doesn't take long to get used to it
That will never happen due to Java's need to remain backwards compatible. The best you can do is a new language that keeps what is good about Java while fixing its problems, but while maintaining the Java ethos of pragmatism over ideology. This is Kotlin.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/kotlin] [\[xpost from r\/java\] Kotlin: Not a Scala Killer, just better Java r\/java](https://np.reddit.com/r/Kotlin/comments/6we692/xpost_from_rjava_kotlin_not_a_scala_killer_just/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
&gt; I don't think Kotlin will be anything more than an analogue to CoffeeScript from the JavaScript world CoffeeScript was a preprocessing transpiler, it was always a kludge, lipstick on a pig. Kotlin is a first-class language that supports the JVM as *one* of its compilation targets (the others are JavaScript and native). Kotlin also has first-class tooling thanks to JetBrains (full IDE support by arguably the best IDE). CoffeeScript perhaps represented a few man-weeks of development effort when it hit 1.0. Kotlin represents man-years, perhaps even man-decades of effort. It's really an apples and oranges comparison. &gt; Also, whoever started this new language trend of putting type declarations after the variable name belongs in an asylum Not new at all. ML (which inspired Haskell, and many other languages) uses the `value : type` syntax and it was designed in the 1970s, around the same time as C. I suspect your resistance to it is due to unfamiliarity, not any inherent problem with it. Java was my main programming language from 1996 until about 2 years ago when I switched to Kotlin as my primary language. I find the Kotlin approach very natural and, if anything, better than the Java approach.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/kotlin] [\[xpost from r\/java\] Kotlin: Not a Scala Killer, just better Java](https://np.reddit.com/r/Kotlin/comments/6weapy/xpost_from_rjava_kotlin_not_a_scala_killer_just/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
pretty sure this was the same argument for scala and groovy
It's saved by a lot more than that friend. 
A new minor version of Groovy used to come out once or twice a year, but we haven't gotten a minor version release since [Pivotal offloaded Groovy](https://www.infoworld.com/article/2895752/development-tools/groovy-language-moves-to-apache-dumped-by-pivotal.html) in March 2015. I love Groovy, but I'm not optimistic about its future. I've given Kotlin a try since and it's very similar to Groovy in its flexibility and expressiveness, so I've moved to using Kotlin where possible. &amp;nbsp; Groovy Version | Release Date | Time Since Previous Release ---|---|--- 2.4.0 | Jan 2015 | 8 months 2.3.0 | May 2014 | 6 months 2.2.0 | Nov 2013 | 10 months 2.1.0 | Jan 2013 | 7 months 2.0.0 | Jun 2012 | - 
where i'm at there's a lot of high level grails work being done, groovy lost a lot of momentum getting apache status but it's still got a lot that going for it. I feel it actually fits it's niche pretty great.
I too dislike the type after the declaration, there is a specific name associated with it, I forgot the name though. I keep trying to use Kotlin but 90% of the time I have code that is just as verbose as Java.
But the Kotlin compiler is creating compatible JVM code.
Correct, so? I don't see your point.
Not really. Scala integration with Java isn't seamless. Groovy's dynamic typing "fixed" something that shouldn't have been fixed.
So why can't Java introduce null safety or reified generics (when inlined) and stay backwards compatible (old Java works perfectly fine with Kotlin) while Kotlin can do it?
There is a difference between keeping the code backwards compatible and maintaining backwards compatibility with the generated bytecode. Kotlin only needs to do the latter, Java needs to do both. You can't introduce these features to the language itself without breaking old code, and that's a dealbreaker for Java.
Two different compiling modes would be needed to deal with old and new code. You are right; that could be complicated to configure. Kotlin also is backwards compatible to uncompiled Java code, but you have to tell the compiler yourself, if return values or arguments in old code are nullable.
Honest question: isn't going the Apache route where projects go to die?
&gt; Two different compiling modes would be needed to deal with old and new code. Then you'd have two programming languages, not one. &gt; Kotlin also is backwards compatible to uncompiled Java code, but you have to tell the compiler yourself, if return values or arguments in old code are nullable. I don't understand what this means. All Java code must be compiled to bytecode before it can be executed or used as part of a library. Kotlin has something called a "platform type", where the nullability of a type is unknown, these are written as `String!`, which means "String that may or may not be nullable". This is useful for interop with Java libraries, but it's always better to "clarify" the type's nullability as quickly as possible in your code.
No programming language can turn bad programmers into good programmers, although the language can nudge them in the right direction, and Kotlin does exactly this. Blaming a programming language for bad programmers is silly.
Except now Gradle fully supports Kotlin instead of Groovy
Yes, there must be bytecode finally. But having a component, that uses a new feature and another component that doesn't, does not mean, that those two components have to use different languages. If there are different compilation units, different compiling modes can be used (switch for null safety) while Java is used in both cases.
A compiler switch that makes valid code invalid is a recipe for language fragmentation. This is why Java doesn't do this, and no well-designed programming language will do this.
Scala killed itself. 
Better how? I don't think it is except less typing maybe? Are we paid transcriptionists or software developers? 
Yes, BASIC used it. Side note: Being able to describe a feature as "like BASIC does it" generally isn't a good thing.
Gradle is still **written** in Groovy, right?
Note to beginner Java devs: Never use `extends Thread`. Use `implements Runnable` instead, then pass that to `new Thread` or an `ExecutorService`'s `submit` method.
I learned assembly, then C, then fell in love with C++, and after that Java seemed like a simplification of C-style languages that made perfect sense. C# took the best of Java and improved upon some of the bad, but eff me no way I am going to lock my wrinkled old ass into MS tools. Java until retirement for me.
How can I do 2D graphics and animation in Kotlin? In Java, I can use the Graphics2D class.
&gt; BASIC Basic really wasn't a single programming language, all kinds of mutually-incompatible programming languages were called "basic". I think Python is probably the true heir to "BASIC" (in that it incorporated many of the various basics' best ideas).
(Good (luck (with that))) ;)
Anything you can do in Java you can do in Kotlin, it is fully compatible with all Java libraries.
Can some ELI5 why all major languages (Java, C++) have such a huge downward trend since 2004? Programming surely hasn't gotten less popular.
Kotlin is 100% compatible with Java. You'd still use Graphics2D, just with slightly different syntax. Like if you had this in Java: public class MyCanvas extends JComponent{ @Override public void paint(Graphics g){ Graphics2D g2 = (Graphics2D)g; // ... do stuff } } In Kotlin you'd have: class MyCanvas : JComponent { override fun paint(g: Graphics){ if(g is Graphics2D) { // you can now use g as a Graphics2D, no casting // ... do stuff } } }
right, but that implies I would be writing Java code that Kotlin understands. If I was going to do that, there's no point in using Kotlin
ok, thanks for the great example! Now what's the compelling reason to switch?
I'm actually in the middle of learning Kotlin, and I'm leaning towards recommending my company switch to it as the default language for new projects. So far, the reasons I like it are: 1. 100% Java compatibility. All of our existing libraries will "just work." Legacy projects can be converted piecemeal. Kotlin code generates Java bytecode. Kotlin can be called from Java and vice versa. It works with Maven (or Gradle) and JUnit. 1. Backed by JetBrains and Google. It's not going to die on the vine. 1. Speaking of JetBrains, it has the best IDE support of any language I've used. 1. It makes sense. When I don't know how to do something in Kotlin, I just try something, and I'm right about 80% of the time. 1. Brevity. This code: `data class Foobar( var one: String, var two: String = 5)` generates all of the getters, setters, constructors, equals/hashcode, and toString methods you'd expect. Yes, this can be done with a good IDE, but you don't have to, and you don't have to redo it when you alter the class. 1. "Easy" syntax. Kotlin feels almost like you're writing Javascript, but it's 100% type safe and there are no hidden gotchas that I've come across. `this` always means what you think it means. `val foo = 100` is an `Int`, and Kotlin *knows* that it's an Int. 1. Null safety. No `Optional` classes, your variables are non-null by default, and you have to tell Kotlin if you want a possibly-null variable. The compiler makes sure you test for null if it's a possibility. 1. Final by default. Kotlin promotes immutability, and you have to tell the compiler if you want mutable variables. Collections are immutable by default, too. The compiler yells at you if you use a mutable variable in a thread-unsafe manner. 1. First class functions. You can declare functions at the top-level of a file, with no wrapper/utility class. *But*, if you try to use them in Java, Java will *see* them in a wrapper/utility class. 1. Multiple classes/methods per file. I'm using files in Kotlin kind of like a module; all of the `User` classes and methods go in `User.kt`, for example. 1. Coroutines. I haven't played with these much, but Kotlin (like Go) makes it very easy to use lightweight async functions. Basically, Kotlin is what you would come up with if you were designing Java today, and you knew you were going to have first-class IDE support. A lot of the verbosity and cruft of Java is just gone, but you keep all the benefits of type safety, memory management, a huge standard library and even bigger third-party library collection, the performance of the JVM, and the ability to write once and support multiple platforms.
ok, just for the record I don't really have a problem with verbosity in Java. My coding style is pretty compact already and I generally prefer readability over terseness. However, these are things that would get my attention... 1) ability of use data primitives (your 'Int' example scares me already) 2) groovy-like null-checking via elvis-like operators 3) operator overloading 4) default interface methods as in Java 8 (these are extremely useful) Does the Kotlin compiler generate more performant bytecode? 
The bytecode is about the same, based on the benchmarks I've seen. The `Int` example is comparable to Java's auto-boxing. I don't think you see a performance penalty unless you actually use methods on it. Kotlin does support the elvis operator, and operator overloading. I'm pretty sure that it supports default interface implementations, too, but I don't remember the syntax off the top of my head and my wife is calling me to dinner ;-)
news to me since scala's not dead
How exactly is this different from a traditional multi-module Maven project in say Java 8? I haven't used Maven in a little while now, but I can't say I can see in the poms what's really new here.
How, through a new language feature? It's a non starter for compatibility.
(with (cons Good luck) that)
I don't use really use Maven, so I'm not sure how much has changed in the `pom.xml` files. It may be the case that the Maven team has handled the Java changes seamlessly for the user. I can't tell how much you have followed Java 9, but one big change in that context is the project layout and the new `module-info.java` files. 
Aren't reified generics coming in Java 10?
Type declaration after name is pretty cool, tbh.
No. It's Java.
Or you if you write Java code, you are writing: *Java* which *C++* understands which *assembly* understands which *binary* understands! You know what man? Just write your code in binary! Problem solved! Simple, elegant and minimalistic! Just 0s and 1s! /s 
Groovy is the native scripting language of Jenkins and Artifactory, two tools which I've been using for a while, in addition to Gradle. I don't love Groovy but I use it because of those tools, however I will happily switch over to Kotlin when I can. I've been using Java, Python and Ruby for years, for me Groovy is mish mash of all three of those languages. It's not terrible though, it's just not a language I'm especially attached to. I've been tinkering a bit with Go too. . . I could enjoy coding primarily in Kotlin and Go. . .
Kay parts of Gradle were rewritten in Java for execution speedup a while ago.
&gt; although the language can nudge them in the right direction, and Kotlin does exactly this. Interesting assertion. My views are precisely the opposite.
&gt; I noticed a bit down the page people were reprimanding a guy for not knowing to implement hashcode() when using hash based data structures, but for someone coming to C# that rule isn't obvious. AFAIK this isn't different in C#: https://msdn.microsoft.com/en-us/library/system.object.gethashcode(v=vs.110).aspx Other than that; you're asking an incredibly broad question. A big part of being a "java" developer isn't the language itself but the experience with the ecosystem, all the ins and outs of the different libraries, etc. To quickly get started I can recommend the "Effective Java" book by Bloch. 
IIRC you can put extension methods on interfaces.
&gt; Note that Play also supports Java, which means it supports Kotlin. Kotlin support is rather bad. The only Kotlin that currently works is using the Play libraries and not relying on either the gradle plugin for play and kotlin on sbt wasn't good either anyway.
Why you want to switch to java? Stay in C# or move to .NET. Then u will get a lot of opportunities to work on funky tech like VR.
Haha :) I find the thread macros do for Clojure code what promises did for JavaScript. No more endless nested brackets: ` (-&gt;&gt; that (with) (luck) (Good))` 
Then your next step is just write an application, then another, and so on. Start with something simple.
1) Kotlin will do that automatically, it will use an `Integer` when necessary because of Generics or nullability and otherwise use an primitive int. 4) Yes, they work as in Java 8, but they aren't yet 100% compatible. Java will not see the default Kotlin implementation currently, so if you use a Kotlin library from Java, you have to explicitly implement all interface methods, even if Kotlin defined a default implementation. There's a bug for that somewhere.
Kotlin is influenced by C#
The Kotlin mafia is strong. Speaking of which, you should probably rewrite all your code in Rust.
&gt; The TRUST’s primary goal is to provide the simple way of different test results verification. .. does not describe what it is for. Author is too familiar with what they have made to describe it succinctly to noobs.
OCA: Oracle Certified Associate Java SE 8 Programmer I Study Guide: Exam 1Z0-808 https://www.amazon.co.uk/dp/1118957407/ref=cm_sw_r_cp_api_F0.OzbFGQAH9N OCP: Oracle Certified Professional Java Se 8 Programmer II Study Guide: Exam 1Z0-809 https://www.amazon.co.uk/dp/1119067901/ref=cm_sw_r_cp_api_o1.OzbXN53C24 
Well, only if you are already an IDEA user. As a 50/50 Eclipse/NetBeans user, I tried several times to write Kotlin in IDEA but in the end I gave up because the attrition from using yet another IDE was too much for me.
Not related to Java. Also stop spamming your youtube channel.
&gt; .. does not describe what it is for. Author is too familiar with what they have made to describe it succinctly to noobs. Good point, thank you. Will update description later today or tomorrow.
Because Java &gt; .NET in every single conceivable way. 
Good to hear. My first thought that the tech was like [Pitest](http://pitest.org/) which would be exciting. Of course, Pitest's home page has the same problem. At least in the first paragraph.
God, dont they get tired of this?
snark aside, I think it's fair for a Java developer to openly question the usefulness of any other programming language being promoted on the Java subreddit -- especially when that language is being characterized as a better version (i.e. language-compatible) of Java. I use Java... a lot. But I am not married to it. I am certainly open to considering the merits of another JVM language but the onus is upon Kotlin to overcome the institutional inertia of Java if it wants to replace it.
don't be rude man, i am java developer with 5y exp. I'm really tired of this shitty fight ["ohh.. java is better... nOOO C#"] THis war is total bullshit where the winning site is corporation in one hand is M$ in other 0racle. And also how did u measure this? 
Would love to use kotlin, but I feel like people are looking for java developers not kotlin.
Just go for it. We're of total opposite. I learned java first then studied c# scripting for unity game engine. I realized that I can easily understand how c# works and knows already how to make callbacks. Also, right now Im trying to study typescript cause I kind of want to make an angular 4 app. And I also easily understand it too cause the syntax is somehow the same with java. Almost all OOP languages are the same. They just differ on little things. Go to the ones with more trusted opensource frameworks or libraries so that you don't have to reinvent everything.
In my profession I've used both and both have their merits. I think C# is the better language but Java has the better infrastructure. I use Java now and I still miss auto properties and extension methods. I used to miss Linq but streams and lambdas made up for it. Luckily there's Kotlin which is syntactic sugar heaven and adds all of that good stuff.
Let's see where Kotlin is in two years. I think the Scala community should be concerned and articles like this are "smoke" pointing at a greater fire IMO. There's a small segment of folks who use Scala because they totally grok the Scala worldview around using FP as much as possible. These folks will almost never convert away. There's a much larger segment of folks who begrudgingly use Scala because someone else who is now long gone picked it either because they wanted to use a true FP language or because they wanted "a better Java". Those folks are possible to convert back to Java or Kotlin. 
Did you make sure it follows all the guidelines and rules of the youtube api and youtube itself?
Thats the fucking problem. I didn't do enough research. Now how do I promote my youtube channel?
I think spamming a link on other peoples videos is one of the least effective ways to promote your channel
So, make your own youtube and use it.
Don't know why you're being downvoted, I made this switch to C# after 3 years native Android development and jobs offers are flying at me now. Could just be my city but there is a lot of demand for Xamarin devs in my area. Couldn't be happier. 
You can use the same Graphics2D class in Kotlin while at the same time making use of Kotlin's syntactic sugar features. For more benefit, like a full-blown DSL, you will need to make a wrapper around it.
Why did you expect a spambot not to get blocked?
The Kotlin-Gradle experience isn't great. Gradle was already a PITA to wrangle in Groovy but was manageable via clever Googling and reading the manual. Kotlin just adds a new obfuscation on the DSL. It's poorly documented and when you try to figure out how to something you know how to do in Groovy-Gradle it's not always clear how to accomplish it in Kotlin-Gradle. I'm planning to convert my build.gradle.kts files back to build.gradle in the not so distant future.
Well you/somebody should have told him earlier, now he's continuing the spam here on Reddit. 
Sorry, had no chance to check the [Pitest](http://pitest.org/) techniques but judging by the description provided on their home page I doubt that these two can be comparable. If you need something to compare and in case if we'll consider the API response(s) (`XML` or `JSON` formats) verification as the final step of your test(s) then the nearest tool for comparison can be the [XMLUnit](http://www.xmlunit.org/).
Read the Sun Style Guide it's old but still applies, they are vastly different than Microsoft's. I really like http://tutorials.jenkov.com/ tutorials. 
Welp, luckily, I don't think I have made a hashed data structure in the past year where the Key was a reference Generally I just have a lot of Dictionaries where the key is just a string. I'm surprised I haven't had to use HashSets more often though. I thought the default behavior for reference types was the same for value types where it does reflection to hash the individual members. My team lead has a few HashSets in our DAL without an overriden GetHashCode() method so I will have to talk to him about it. Thanks for letting me know. I'll check out Effective Java. As far as my OP being a broad question, I am primarily interested in microservices with springboot or dropwizard and learning the related libraries (dropwizard metrics, jersey, hibernate, elasticsearch client etc.). Really I am looking to pick up idiomatic java moreso than a specific technology because the general principles behind using elastic search, solr, or a web backend are pretty similar across languages. I'm also not really interested in android development or GUI development with swing or javafx because I feel like it really just ends up making me swap HTML for another random XML based markup language. Microservice based backends would be the same regardless of the view layer. I would use C++ for game engine development and C# for game development with unity so java seems to only have to use to me as a cross platform web backend. If you think java has another strong use case though, I am open to suggestions though.
I have worked first in C# and then Java. They are pretty similar as OOP. I recommend you start working with SpringBoot, but as many other said, it really depends what you want to achieve in Java rather than specific differences. Also, in Java most people start with braces at the end of the function declaration, instead of a new line. That's the first thing people will notice in your code :) 
&gt; (Also, whoever started this new language trend of putting type declarations after the variable name belongs in an asylum.) Both Kotlin and Swift do this and it is very jarring at first. I have no idea what the advantage is supposed to be. I am getting used to it, but I don't like it. It is even worse when you initialize at the same time you declare because it looks like you are assigning a value to the Type and not the variable. I would really like to hear something from the kotlin and swift developers why they chose this: var whatEver: String = "hi" //why am I assigning a value to the type??!? 
still plenty of jobs out there by looks of it. unless they're fake ads
&gt;There is a difference between keeping the code backwards compatible and maintaining backwards compatibility with the generated bytecode. Kotlin only needs to do the latter, Java needs to do both. &gt; &gt;You can't introduce these features to the language itself without breaking old code, and that's a dealbreaker for Java. What about the diamond operator? I think that's invalid in 1.6 but find afterwards. Genetics don't work before 1.5. Aren't language levels like having different languages?
&gt; Kotlin feels almost like you're writing Javascript This isn't a selling point. &gt; Multiple classes/methods per file. I'm using files in Kotlin kind of like a module; all of the User classes and methods go in User.kt, for example. Please stop doing that, it is a maintenance nightmare.
My friend and I are looking into hybrid app platforms so we don't have to worry about the details of each native platform. He knows AngularJS so we're using Ionic 1 right now. It's ok, but we find it a bit weird trying to find plugins that allow you to use native things like local notifications. How's Xamarin?
Pretty great and getting better every month. Microsoft has a lot invested in it and I don't think it's going anywhere. Xamarin university is in a class of its own too, with a bit of C# knowledge you can easily pick up cross platform development and Azure makes stuff like CI and automated testing a breeze. It's not perfect but the vast majority of problems are just minor annoyances, they're not game breaking. 
My day to day job is pretty much creating Java micro-services so while you can obviously make a Desktop app with it it's probably the most common scenario (server-side stuff in general). If you have any specific questions let me know.
&gt; I'm really tired of this shitty fight Then why did you start one? 
1.5 code might not work in 1.4, but 1.4 code will always work in 1.5. 1.6 code might not work in 1.5, but 1.5 code will always work in 1.6. That's what matters.
The point is that the Java code written for 1.5 still compiles on JDK 1.8. You may get warnings that is a deprecated way (e.g. diamond operator) but you still get the bytecode.
Give it time, you'll get used to it, and then you'll prefer it.
&gt; Interesting assertion. My views are precisely the opposite. Examples?
Can anyone give a link to some examples of ideomatic Kotlin code dealing with pure JDBC (not ORM) like getting connections from datasources, navigating resultsets, using prepared and callable statements with proper exception handling and resource closing and maybe some very thin utility library like commons-dbutils for Kotlin? I googled several times but wasn't able to find anything good. I even thought that Kotlin primarily targets Android and therefore no one seems to deal with JDBC (pardon my ignorance)
Kotlin has excellent Java interop. 
I'd like to suggest Map's [entry](http://download.java.net/java/jdk9/docs/api/java/util/Map.html#entry-K-V-) method for doing Map.ofEntries(...)
dunno, I would just expand that zip into your lib directory and reference the contained jars on the buildpath.
It's been a while since I last manually added libraries to a project. It would be much simpler to use the build tool Maven that manages dependencies for you, given that JUNG is on maven central and itself is built by Maven. Anyway here are the steps from start: * Create an Eclipse project. Create a new package under src. Create a new class "JungLearning". Copy the sample code you found into it. Change package declaration to match your package. * Create a folder called "lib" in the root (actually name and location would not be important) * Download the latest version 2.1.1 .jar files from [github](https://github.com/jrtom/jung) to this "lib" folder. You probably don't need the samples. [Image](http://i.imgur.com/GYbuntC.png) * JUNG 2.1.1 has a depencency on [guava 19.0](https://mvnrepository.com/artifact/com.google.guava/guava/19.0). Download it to "lib" too. [Image](http://imgur.com/wI5Mg5F). * In Eclipse, right-click all 6 libraries and "Add to Build Path". [Image](http://imgur.com/Y7gTuli) * Should build and run now.
I'd rather have (maybe) one extra import and read `List&lt;String&gt; empty = Collections.emptyList();` than `List&lt;String&gt; empty = List.of();`.
To commentt on Effective Java, 3rd Edition comes out sometime soon (October, I think). It even has a [preorder on Amazon](https://smile.amazon.com/Effective-Java-3rd-Joshua-Bloch/dp/0134685997).
The only real issue I've had with what little Xamarin I've done is that the Android version they ship with it kinda old. So, you have to use the Android SDK Updater to install versions newer than 6.0. Mind you, 7.0 is a year old and 8.0 just came out. It's extra fun if you use Xamarin Forms as the version the Visual Studio installer installs requires Android 7.1 or newer.
I'll stick with Guava's Immutable collections because the immutability guarantee should be reflected in the static type.
Our profession is entirely knowledge-based. If you really can't remember some of the most common interfaces, classes, and methods used by professional Java developers on a daily basis, you may want to reconsider your career choice. It's a bit like a carpenter not being able to remember the difference between a club hammer and a claw hammer... Unless you are new to Java and programming in general in which case... &gt; got one offer, but the rate wasn’t what I wanted ... It may not have paid as much as you *want*, but it could have given you the experience that you seem to *need*, which would have then helped you get another job that you do *want*. 
wow thanks for the thorough steps :) So far I got this [error](http://i.imgur.com/2rHe9RV.png)
I think you are missing some dependencies search for the missing package and also add it to the referenced libs. This would be easier if you use maven. 
Why? I was actually just thinking of doing this and having a private class that implements Runnable. It seems like an OK thing to do to me...
Hehe, peidevs sounds kinda silly in portuguese :) And now something completely different: I think I read somewhere else that the point of compiler.release is that one dont really need to specify compiler source and target no? Any reason you listed all of them? Thanks for the code btw!
You are right, but something might change...
The two main reasons are: 1. You can only extend a single class. 2. `Thread` is comparatively heavyweight and implementing `Runnable` allows you to only create a `Thread` for your class when you actually need it.
&gt;You can only extend a single class. I'm not following how that's a problem. Either way you are going to end up with a Thread object. With extending you are just dedicating that extended Thread class to a specific Runnable task which, I would think, would be perfectly fine. &gt;Thread is comparatively heavyweight and implementing Runnable allows you to only create a Thread for your class when you actually need it. If you are only doing a personal Java program is that really a big deal? A private class that implements Runnable would be trivial to refactor out if the need ever comes up.
You missed the [jung-api.jar](http://search.maven.org/remotecontent?filepath=net/sf/jung/jung-api/2.1.1/jung-api-2.1.1.jar). You can add it via: Right-click Project &gt; Properties &gt; Java Build Path &gt; Libraries &gt; Add Jar Btw you can replace the first statement with `DirectedSparseGraph&lt;String, String&gt; g = new DirectedSparseGraph&lt;&gt;();` to get rid of the warning (yellow squiggly)
Hey, you can choose to favor inheritance over composition in your own project if you want, but most people are going to tell you that's the wrong way to do it.
it's **jar**ring. heh
[It worked!](http://i.imgur.com/L5c6xio.png) Thanks! I really appreciate it :) you have no idea how much time I've been stuck trying for 13 hours! made my day. 
As far as I'm concerned, Kotlin adds some features that look like short term wins for writing code but will make it a pain on the long term and readability. Java forces you to be explicit for the good and sometimes the bad (you need to type more). Kotlin makes some parts implicit and imo implicit'ness is dangerous. Take extension functions. Sure it's easy and immediately nice to add a whole bunch of functionality to a type you don't own, but there's a grave disadvantage: I will never be sure what a type consists of. I would always have to relearn the "domain" when I join an older project. Here String would have leftPad added, at another place String was left alone and the team pimped Integer and so on. In Java I would know exactly what to expect of String and I know there would be apache.commons.StringUtils for the extra stuff or there's a custom class with a specific name. Similar for operator overloading, top level global functions, ... 
You're welcome. Happy coding.
&gt; These useful methods are used to create a new Non-Empty Immutable Map with 1-10 elements. The methods are designed in such a case that we can add only 10 elements to immutable List, Set, Map, and Map.Entry objects. Maybe I'm just unimaginative, but I don't see how this is particularly useful. Especially because the utility methods are just called `#of()`. I see `List.of()`, and I expect a method that will create a new List out of whatever I stick in the argument -- literals, other lists, whatever. I certainly don't see `List.of()` and expect it to behave like `List.ofTenThingsOrFewer()`. EDIT: Looks like the article was a bit ambiguous or perhaps incorrect in its description of these methods. See /u/cogman10's reply.
I am saying that if developer doesn't know the difference between hashset and hashmap (your own example) I would never ever hire him.
For better readability or some other reason? 
&gt; Groovy's dynamic typing "fixed" something that shouldn't have been fixed. I'm not sure I follow what you mean by this. Can you expand?
Yes, I was only thinking of readability.
What is this? Guilt by association for programmers? :) Also, this 'trend' is also used by SML, OCaml, Haskell, Scala, Eiffel, F#, Typescript, Swift, Go etc.. and for good reason. Or maybe the designers of these languages were all idiots. But of course, the same thing happens, when programmers are unfamiliar with some new concepts or constructs, they think it's stupid, and become angry and dismissive. The same thing happened, when they introduced higher level languages, like C, the same, when language designers introduced recursion, classes, etc... After all, we are all humans with our stupid biases.
Ok, thanks :)
Version 2.5 is in beta.
I would have agreed with you a few years ago. The difference between `"this is some text".toCamelCase()`and `StringUtils.toCamelCase("this is some text")` is trivial, especially if you statically import `toCamelCase`. Both can be looked up by ctrl-clicking in the IDE. More importantly, you always know what the base `String` class looks like. Whether your current project has extension methods added, or a utility class you should be using everywhere, is a matter of semantics. Similarly, `myTopLevelFunction()` in `MyUtilityClass.kt` turns into `MyUtilityClassKt.myTopLevelFunction()` in Java. Again, it's a semantic difference, not a difference of kind. I am less excited about operator overloading, just because I've seen some of the horror shows people unleashed in C++ code. I kind of have PTSD.
He is wrong. There is a list.of(elements... e) method. For performance reasons, they made a bunch of overrides. for 0-&gt;10 elements. Map only has the 0-&gt;10 methods and then one that takes entries. They do this for type safety.
Ah! That makes *way* more sense, thanks for clarifying.
Static typing is a feature, not a bug. By switching from static to dynamic typing, Groovy made things worse.
&gt; I think it's fair for a Java developer to openly question the usefulness of any other programming language being promoted on the Java subreddit In general, sure, but sme06's criticism made no sense.
Kotlin can deal directly with the JDBC API just as Java can, and there are a number of non-ORM database abstraction libs for Kotlin although I don't have personal experience with any of them [example](https://github.com/JetBrains/Exposed).
Yes, having it on the type helps, but still, it is on the interface, on the contract. So even Guava's immutable collections are broken because they implement the Collection interface, have mutation methods like add/remove/clear etc. Java collections API does not have separate object hierarchies for immutable and mutable collections, it is broken by design. Scala got them right.
How about a new rule? You can't talk about Collection improvements until fucking Map.get is typesafe. I get that backwards compatibility is more important than life itself, but can't we at least introduce a typesafe version and deprecate the old?
Maybe you misunderstand. I have not criticized Kotlin in the slightest. I am a Java developer asking for more information about this non-Java language being promoted on the /r/java subreddit. Is that not a reasonable expectation?
Nobody is suggesting that you can't ask about Kotlin, many people already have in this discussion and they've received detailed answers.
How is stating reality rude? I guess if you're a snowflake. 
I think I'm perhaps confused then. How is it different to include a new notation that says something is not nullable? 
&gt;/** &gt;* The code to explain the List.of() in java 9. &gt;*/ That code doesn't *explain* anything. It's just an example.
&gt;&gt; Kotlin feels almost like you're writing Javascript &gt; &gt;This isn't a selling point. &gt; Agree about it not being a selling point. Disagree that it feels like writing JavaScript. Feels more like the nice parts of Python with the good structure aspects of Java. &gt;&gt; Multiple classes/methods per file. I'm using files in Kotlin kind of like a module; all of the User classes and methods go in User.kt, for example. &gt; &gt;Please stop doing that, it is a maintenance nightmare. Has its place. I'd agree that it makes things look messier in general, but it's not required. 
Java Predefined Methods for Selenium, Java Character Methods, and Java Array Methods. ArrayList in Java, Dynamic Data Structure in Java, Create Java Array List, Add Elements to Java ArrayList, and Remove Elements from Java ArrayList. Create Object in Java and store Java ArrayList Element.
I love seeing new JavaFX mini-projects.
Good to know! Thanks.
Also Set.contains. Also Object.equals.
I've started Java a couple of weeks ago (after a couple of years with C#). Using Spring Boot for building a Rest API. Also using IntelliJ. So far I'm pretty happy. Choosing Spring is a great decision because the strength of Java is not the language but the mature ecosystem. Compared to ASP.NET Spring is just miles ahead I have to say retrospectivly. In all regards, especially JPA with Hibernate as provider is pretty wicked (check out Envers!). I now understand why Java is so huge in the "Enterprise" where you have a large domain model and business logic is the main concern (in opposite to say, a video streaming plattform). https://projectlombok.org/ is great! Then in addition to the Jenkow tutorial mentioned already here I think those are helpful, too: http://www.mkyong.com/tutorials/spring-boot-tutorials/ http://www.vogella.com/tutorials/java.html Finally, a small advice from a senior: Take at least one day off. Go hiking or whatever you like. Working all weekend is something that can and should be done only for a limited period.
**Sidebar** -&gt; **Do not post tutorials here!** **Second warning** There will be no third warning. Next tutorial posted here, you will be banned without further ado.
I've just taken a quick look, but seems to be an example, or it is not following the archetype structure I'm used to. For starters the POM is defining a WAR. Also, for clarity I prefer putting the reports plugins inside the reporting tag, instead of inside the Maven site plugin.
Maybe semantics, but Guava's implementations are certainly not "broken." The mutation methods are declared optional by contract -- they are allowed to be unsupported -- so Guava's implementations are still true subtypes.
Wow great. We once did a project where we needed a zoomable and pannable Pane to display big graphs. I felt doing this was a pain in the ass. We had to stack multiple layers of JavaFx panes and then sync them. There were lots of implementation of this on Stackoverflow and other sites but none seemed to match all our requirements or had bugs. At the end we settled with our own implementation but haven't been able to sync the scroll bars. So we set them on hide :) This looks like a great alternative. I will look at it again later and maybe replace our Stack of Panes. Thanks a lot. :)
It's actually **3.1.0** &gt; The Apache Maven team is pleased to announce the release of the &gt; Apache Maven Assembly Plugin Version 3.1.0
In my company we're doing all new projects in Scala. We're using Play, Spark, Kafka that are all written in Scala... Also still a lot of job offers in Scala : https://www.indeed.com/jobtrends/q-scala.html 
Kotlin needed a whole category of compiler tricks to fix this. Yeah, it's awful.
The most important thing to say is, that you could easily write var whatEver = "hi" And the correct type is inferred. I encountered really really few cases where I actually had to give a type definition....most often you simply don't need it, so bothering about the problem seems like a waste of time and discussin for the sake of it. The thing is: I'm a Java developer, working with langauges like Java, C#, C++, Groovy, JavaScript and so on for about 8 years. It took me a few days to get comfortable with Scala's and Kotlin's way and it shouldnt take anyone much more time. It's just different. You are used to C-style syntax, so you read the statement (on prupose?) wrong and wonder why it doesn't make sense. You should read it as "variable whatEver as String is 'hi'". 
4) The good thing is: When you're on Java 8, just implement the interface with default implementation in Java, use it from Kotlin and you're all done.
&gt; This isn't a selling point. Acutally, it IS. (Casual programming) People like writing JavaScript or using dynamic languages because they feel it a burden to explicitely write types everywhere (not saying they are right, it's just like it is). Kotlin (and others) combine the light coding style with static and strong typing, which is probably the best you can get. &gt; Please stop doing that, it is a maintenance nightmare. While I agree, that IN GENERAL it's a good idea to associate files with classes, it is sometimes quite the opposite. For example if you need some kind of multiple return values, you could create a dataclass in place (most times a oneliner in kotlin...) and it's perfectly fine not to create a indirection in form of a file and a otherwise useless class of 5+ lines of code...
The anime thumbnail made me think I was in r/anime
 If an add method that throws an error or worse, just silently doesn't add the element then it is broken. If that is allowable by the contract then the contract is broken.
Sure, you don't need to install anything, just download, drop it into a folder and run IT from there. If you need Java for work though you business should give you a way to install it without needing a workaround.
"We hate scripted languages" *Does everything possible to emulate scripted languages* Really amusing stuff
&gt; Please stop doing that, it is a maintenance nightmare. Do you like navigating between dozens of 4-line files on your 24” monitor?
If you're on Windows, typically anything that modifies the registry (installers) are a no-go. Basically anything that you can unzip and run as-is should be fine though.
Well, actually you can have 1.4 code that does compile with 1.5 (`enum` was not a reserved word before 1.5), and in 1.7 a new method was introduced on `java.sql.Driver`, an interface, breaking all previous implementations. So, while it’s true for all intents and purposes, technically it’s not. :)
&gt; I use Java now and I still miss auto properties I don't understand why people like this auto properties thing. I mean, nobody writes its code using a notepad anymore, so having your getter/setters written for you is only one keystroke away. At the same time, keeping the language simple and concise, with less magic, is a plus for me.
A free tip for you: if you're calling someone a snowflake out of nowhere there's a good chance you are one. Learn to accept that your tech of choice might be not always the vest there is and you'll melt less. 
REPLs are not only part of scripting languages. Other JVM languages like Scala and Kotlin also have a REPL. I see it as a good addition to Java toolbox. You can quickly test anything from the REPL without writing a class or method. For example, let's say you want to quickly test a RegEx in Java. You can directly open JShell and test it out. :)
The genesis of REPLs belongs to Lisp, Smalltalk and BASIC, hardly scripting languages.
I accidentally the package.
This guy is an /r/java troll...don't engage.
I wasn't aware of that re: java.sql.Driver, what was their excuse for doing that?
Pro tip. When responding try to use proper English and proofread your post. Did you miss that episode of Sesame Street? It's easy to find, it's the one brought to you by the letter "V".
You can use Groovy as a scripting language. [There is a JavaScript runtime called Nashorn inside the JDK](https://www.slideshare.net/lagergren/a-new-execution-model-for-nashorn-in-java-9)
Manual getters and setters bloat code because it adds 25-100 extra lines of boilerplate to the file that add no value to the meaning of your code. Its not that big of a deal, but it is a bit repulsive to look at. Stating that not having auto properties keep code concise Also, autoproperties let you see which properties can be read/updated at a glance rather than having to scroll through a bunch of boilerplate to find the one property you are interested in. They are hardly magic because they literally just generate manual getters/and setters.
Cheers mate, hope you find it useful! Be sure to report any issues in the GitHub issue tracker.
Well, being on mobile with autocorrect not in english bites in ass. Also you may have more serious issues than 1 typo. When responding I will use the level of English I have as it's not my native language. Cheers, stay frosty. 
Applied insanity: re-implement npm install, npm-require+es6-import bundling, JSX transpilation in pure java :)
I don't have the power to read your thoughts so maybe you should try to explain better what you mean. If you are talking about Optionals in Java 8, they don't break anything on older code base as they are ... optionals. You can still do `String x = null` in Java 8. Older code will not break. 
What is Java Method?, Types of Methods, When we choose Methods, and Advantages of Methods. Java Methods, Java Predefined Methods &amp; User defined Methods, Create Static and Non Static Methods, Create methods with return value, and create methods without return any value. Call Non Static Methods by invoking Object, and Call Static Methods without invoking any object.
Traded one evil for another, was it worth it?
Upvoted for the Bob Dylan lyric
Java API documentation. Do they have a version of that you can download?
upvote for the upvote for the Bob Dylan lyric
I guess I don't have to abuse my unit tests anymore...
Really depends on what the utility is doing, if it's something maintenance related or doesn't run too often then spawning a new thread is fine. If it is executed frequently, it may warrant it's own service/thread pool. But, it really depends on what it is doing and how frequently it does it
not bad practice, just make it clear and maybe give the caller some control over how many threads it will spawn. I.e. run some tests and figure out a good number of threads, and let them set it from 1 to however many they need. So the API probably would have to change though. Another option is to have a helper that can divide up the work for them and spawn this utility in x number of threads.
It's used for password strength estimation, so when a user signs up, or changes their password, this is called to validate it's strong enough. On a giant website with a ton of users, potentially called often. On my webapp, we usually have less than 100 concurrent users...no problem at all. It's one of those things which I just have never really seen a library do, nor could I find info online when I searched on best practices for this type of thing, so I came here.
I really like react, its a substantial improvement for UI development. However, I dislike doing the server side with nodejs. A key takeaway from a recent project (javascript front end, java server) was the ease of refactoring on the java codebase (in contradiction to the javascript client code). Doing a mixed setup nodejs + npm + webpack + java is kind of annoying and messy, especially when one is interested in the front-end part of the nodejs stack only. So yes it was worth it * Increasingly javascript front end libs do not even publish a pre-bundled artifact, so you are forced into npm/webpack. * I am now an expert in npm module resolution and js bundling / import / require mechanics :). Many dirty secrets over there ... :) * I have a clean and quick way to build a modern js UI backed by java or kotlin * Some features of the kontraktor-platform such as session resurrection / transparency regarding connectivity (unlike REST, client code does not change whether one uses web sockets or HTTP-long-poll) are not available on other platforms AFAIK In addition I'd like to experiment with features beyond what webpack offers: E.g. adaptive runtime-bundling optimization: split the webapp based on observed runtime behaviour dynamically. Another thing might be a true integration of XX-to-javascript transpilers (e.g. kotlin+jsx or so). 
Finally. No more Groovy then?
Does anyone know if you can connect this thing to a running process and use it to modify/run code in that process ?
Yeah! JShell also provides an API for external use. Check out the following links for more detail - http://cr.openjdk.java.net/~rfield/arch/doc/jdk/jshell/JShell.html http://cr.openjdk.java.net/~rfield/arch/doc/jdk/jshell/package-summary.html
Many design patterns with source code in Java. Looks like a good resource. http://java-design-patterns.com/
I also love react, in fact react is the only reason I ever got into web and it's the only reason I stay, but I use Clojurescript (not to come and shill). You made a neato thing, keep it up.
This could end up being a major performance bottleneck if your concurrent user base grows. If you go this route, just be sure to include some way to configure thread pooling; maybe a setter for an `ExecutorService` so how threads are created and used can be changed as the application scales. I don't know if this is still the case, but the HTTP library, `OkHttp` used to create a new thread with every request it sent without any way to control this behavior. It severely limited our ability to scale and we had to replace the library.
* refactorability. This is really important once the code base ages/grows. You need to compare software-lifetime costs not initial build only * if it comes down to core processing (e.g. mass data, image processing, ki, nlp) java still (and probably will keep) a significant performance advantage If you stick to modern java (e.g. undertow instead of jee/spring/servlets) the synchronous tradition of java won't be a disadvantage, you can do java node-style. (btw: my https://github.com/RuedigerMoeller/kontraktor just comes from such a background, it's a java+javascript lib for node-to-node , node-to-java and java-to-java asynchronous communication). 
If you actually need an official "proposal" to convince your company to go to Java instead of Node.js, then you are in the wrong company. The fact that another team has already started and is not even waiting for your proposal makes me think that you have bigger communication problems (and not technology ones)
"gained enough friction to be popular"? Interesting line of thinking. :) Or did you mean "enough traction"? 
I wouldn't add multithreading into such library. Typically a web container already creates separate threads for each session -- when many users sign up concurrently, your library will most likely be called by each user's own thread. Adding your own multithreading on top of that might even create some overhead.
I don't think it is generally a good idea for a general purpose library to manage its own threads, because concurrency is ultimately is a higher level policy decision. For example, Android has significant restrictions on threads. Or, if you're going reactive, you might want to have a limited thread pool and coordinate activity with event handlers. If you're running in a JavaEE app server, the general advice is to not spawn your own threads and to let the app server manage concurrency. I think it is better for a general purpose library to be *thread safe*, so that users of the library can safely run multiple instances however they want.
It is not up-to-date. Service Locator, Singleton and Abstract Factory are no longer needed if you use Dependency injection. In fact, Singleton is now an anti-pattern.
The ecosystem is very stable, the tooling is awesome and the libraries and frameworks quality is top. The whole platform is well-understood. Even rare edge cases and problems are documented and solved by someone. In contrast in JavaScript / Node land you have dramas like "left_pad gate".
you could have added some background music.
Stable ecosystem and tooling and a good supply of developers available in budget.
The idea behind this site is good but the implementation is lacking. First of all, some of those are actually **anti-patterns** and you should not use them in new projects: * Service locator * Singleton * Abstract Factory * Balking Some are general principles that are wrongly mentioned as design patterns. For example * Dependency injection * Lazy Loading * Caching * feature toggle are not specific coding patterns like it is presented. Finally some patterns are just plain wrong. Java already has a [Semaphore on its own](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Semaphore.html), so why redefine it? https://github.com/iluwatar/java-design-patterns/blob/master/semaphore/src/main/java/com/iluwatar/semaphore/Semaphore.java All this after a cursory glance.
I'd like to know how does one get practice, how do you "find" it. I love programming but am not self motivated enough to "make" problems for myself to solve. I'm still a newbie and haven't really compiled anything outside a console window or a dll for a game (in c++)
&gt; Looks like a good resource. That's why it's already linked in the sidebar :)
Generally, not every pattern is usable in every situation, so yes, service locator isn't needed when using DI - but DI also isn't the silver bullet for every project. And even if some of the pattern may not be up to date, a good dev should know them and especially recognize those patterns when seen in real world projects.
There are plenty lists of practice examples floating around on the net. /r/learnprogramming has lots and lots linked in their wiki: [Where can I find practice exercises and project ideas?](https://www.reddit.com/r/learnprogramming/wiki/faq#wiki_where_can_i_find_practice_exercises_and_project_ideas.3F) Unfortunately, all these lists will help very little if one of your main problems is *lack of self motivation*. Let's face the facts: programming requires practice. Lots and lots of practice. Practice requires effort. You first and foremost need to overcome your lack of self motivation in order to improve your skills. This doesn't only apply to programming but to all other skills as well.
I know it's detrimental to my whole being not being able to find motivation in much things. I really love programming and languages in general, and it really fucks me up, because I get fired up "Okay, let's do it, but how?" then I want to do nothing The only thing I look forward to is playing video games. :/ But that's a personal problem, and I really thank you for the resources, I'll check them out asap.
The Spring Cloud suite of tools. Hystrix, Feign and Eureka are fantastic and what Netflix use to tie their microservices together.
Well, then *make your own video games*. Seriously, this is the way I started to learn programming in the middle 1980s. My mother deliberately bought a computer that nobody else in the vincinity had, so that I was forced to write my own programs. Sure, nothing polished came out of it, but I really learned a lot. Write simple games and continuously improve them. Give them more options, make different enemies, etc.
Allow the user to set an executor. So it is up to the user to choose the threading configuration... and it is easy to you to be flexible. 
I'll just leave this image from the *lower part* of the **sidebar** of this very subreddit here: http://imgur.com/Ze2YsPs
I thank you!
How do I do imports? How can I include extra libraries for my imports? 
&gt; those are actually anti-patterns and you should not use them in new projects I don't really like that approach when talking about those patterns. One should know really well when to use them and when not, with all their pros and cons. &gt; are not specific coding patterns As far as I know design patterns are not just coding patterns. If that is the case they would be called that way.
Yup, exactly what I was going for.
I have no real node.js experience, but what I can say, based on some teammates, is that the node ecosystem is still quite young and not as stable as java's. And sometimes, when failure is really expensive, that's a big problem. Also, maybe this helps you: https://www.infoworld.com/article/2883328/java/java-vs-nodejs-an-epic-battle-for-developer-mindshare.html 
Don't get me started on Object. The whole class should not even exist, except maybe with one method (getClass). The rest of the methods are completely useless and/or broken.
Don't. You'll need to solve problems twice. One language is better.
I'd say toString isn't that bad either, but equally well it could be in an interface. I'm ambivalent. Notify and wait however...
toString is terrible. It'd be fantastic as an interface because then you'd actually know what implements it. Instead you get a default implementation that is completely useless and now every class pretends that it has a String representation. Equals and hashcode are the same. Wait/notify is just there to support synchronized methods which are needless syntactic sugar and often leads to bugs. getClass is fine because it's the only method that actually has a sensible implementation for all classes.
Well, if some retards managed to squeeze node.js in already - RUN.
I'd love to hear why a singleton is an anti pattern. You just have to know what you're doing when using it 
vert.x is a good reason.
WildFly Swarm is a great reason. You can create microservices with Java EE standards!
Can confirm...
The topic has been discussed to death. You can find a lot of information with some googling. (even here in reddit) Here is one from Microsoft https://blogs.msdn.microsoft.com/scottdensmore/2004/05/25/why-singletons-are-evil/ and one from Google http://misko.hevery.com/2008/08/17/singletons-are-pathological-liars/ In summary they are a form of global state, making your classes tighly coupled and very hard to test. If you already use Dependency injection you don't need Singletons any more. You can instruct your DI solution to pass you the same instance every time that you ask for a class. 
This, I never understood the hate against JEE, I started with JEE7 on wildfly 8 and moved to swarm recently, pretty simple and predictable standards. What's not to like? 
At this state, I'm sorry to say your first project will be a failure no matter which language you choose. Plan to do the project twice, or even three, four times. Then you can try multiple languages and see which one's better for your case / team / process.
Then why aren't they banned? 
I recommend code academy, always worked for me.. Just so you know as a first language, Java is a pretty complicated one to learn. If you do want to learn it make sure you code correctly as it can be hard to detect errors in you code when programming with Java. You can always use some program for code detection, such as checkmarx and others. Can be useful sometimes. Anyway, good luck!
Because in the first versions of Java EE you had to create three classes for every single EJB and you could not use inheritance for EJBs. Also, application severs were very slow and it took several minutes to start or reboot one. But that's the past. Some people can't move on.
&gt; What's not to like? Not much, many people tried Java EE in 2002, didn't like it then, and assumed nothing has ever changed. It's just like the old joke that gets repeated that Java is supposedly so slow, while in reality it hands down wipes the floor with languages like Python, Ruby, JavaScript etc when it comes to performance.
Java performs better, quite a bit better than node. JavaScript is a bit messy, so TypeScript is a step up, but it's still quite young and unstable. Java has a lot of battle hardened tooling, an amazing ecosystem with libraries for all sorts of things, reliable servers from many vendors, and (should you need it at some point) support options. The Node.js project is a little... unstable at times, with the second major form (Ayo) just announced over reasons that seem to indicate the project steering is somewhat troublesome to say the least. Java has several very interesting options for Microservices. There's WildFly Swarm, Payara Micro, and in general the MicroProfile (which is, just like TypeScript, quite young still and just starting up, so more of an extra at the moment).
singletons should never store state that's singleton 101 and dependency injection can inject singletons in to remove GC pressure. Injecting that same instance is a singleton if you only have one. 
Oups ! edit: relevant username too... ;-) 
But where does that instance come from? Some global state. I love using static fields or enums for singletons I know without a doubt that object is a singleton. When you use DI and it's passed into a constructor you don't know if its a singleton or not without digging into the DI config. Now using singletons might be harder to test but its not impossible.
There are many better choices of JVM languages than Groovy. Groovy does some pretty dirty things and a lot of your compile time safety is pushed to runtime errors. I used it once and will never use it again.
jshell&gt; import java.net.URI; // no error reported, neat jshell&gt; URI("http://google.com") // complains about URI... jshell&gt; java.net.URI("http://...") // complains about java.net, saying package java doesn't exist \^D c:\PHP3\php.exe -i ps: the api is URI.create but still
Do you happen to remember if you tried it before or after the static typing was implemented? I believe it was introduced on version 2. But you are absolutely right: if I were to forgo compilation-time errors I might as well stick to Python instead.
also B used syntax that was a bit closer to ml; "let" keyword IIRC. I guess the 70s were mathy. Then pragmatic unix wiped everything for 20 years.
I disagree. Programming languages may or may not fit your mind. I hated indexed array processing in C-like languages, while I strived in list/tree infused languages (lisp, ml, ...) and it changed my understanding of so many things, including good old imperative C code. Now surely, there are people that just don't give a f.
so you're saying better use php3 ? 
althought Odersky is now active on dot/dotty 
no it's just that Java repl is so bothersome I almost regret PHP's one (it sucks but at least it boots in 0.01s)
How many people per service? If more than one over the lifetime of the service, Java makes much more sense...
0.01s boot is not that big of a deal. When you run a java command for 30 seconds the 0.1 startup compared to the 0.01 is not that much relatively. Of course it's best to avoid starting up as much as possible so if you really want to you can set up your java program as a service. Found a solution here: https://stackoverflow.com/questions/43111018/how-to-import-external-libraries-in-jshell-java-9/43112866 Content: I tried with `9 Build 162 Linux 64-bit` with preparation: - Downloaded `guava-19.0.jar` and `commons-lang3-3.4.jar` to `/opt/libs` The following options are available: 1. Specify `CLASSPATH` environment variable: `$&gt; CLASSPATH="/opt/libs/commons-lang3-3.4.jar:/opt/libs/guava-19.0.jar" bin/jshell` 2. Specify classpath with jshell option: `$&gt; bin/jshell --class-path /opt/libs/guava-19.0.jar:/opt/libs/commons-lang3-3.4.jar` 3. Configure evaluation context within jshell session with command `/env`, `/reset` or `/reload`(these commands are different, you can check out with its help info), take `/env` as example: `jshell&gt; /env -class-path /opt/libs/commons-lang3-3.4.jar:/opt/libs/guava-19.0.jar` And then you're able to either `import org.apache.commons.lang3.StringUtils` or `import com.google.common.base.Optional;`. Hope this could help you :)
Groovy is probably more than ten years old now. Your questions are about is it worthwhile to learn new languages that are possibly dead or in their declining years. That is definitely Groovy, in its declining years. The answer to that question is usually NO unless you're getting paid. But groovy has a place these days, its not really development unless you do Grails work but we use it now for testing with the Spock framework and of course with Gradle. In my opinion, the most productivity comes from running Intelli + Gradle + Spock + favorite code quality tool as a base to any java project. Groovy is also good for doing simple scripting. It's worth learning Groovy because its probably not going to get any less popular than it already is and it still has huge usage in Gradle. But I wouldn't get into it too much. The days of dynamic programming are gone, in the early 2000s it took a whole new generation of programmers to finally disbelieve everything done in computer science for the last 30 years in order to create a Ruby/Rails/Groovy/Grails/NoSql world only to finally say, "oh yea, that's why static typing rules." There's really no jvm language worth learning right now except for Groovy and even then I only recommend learning enough to make gradle work and write spock tests. If Kotlin can make it another two years or becomes the backbone to its own tooling (instead of just trying to be the replacement of Groovy for gradle) then it might be worth learning Kotlin, but right now its so much hype because it really offers nothing other than being the equivalent of what coffeescript is to javascript. Best advice is to stick with Java, learn declarative programming and the streams and concurrency apis. Netty is also one of the more interesting projects that I think is worth learning. Java is not outdated, you just have to adopt the new coding paradigm the Oracle boys have set forth, which in a nutshell is declarative programming in such a way that the jvm can facilitate its own optimizations with the native hardware. And you can't tell if your making progress without running benchmarks with the awesome JMH tool, I've added this "must have" in my java dev stack recently.
very informative, thanks a lot
What are the requirements for the services? Unless there's a strong reason for a polyglot approach, it would be a better choice to standardize on an one language (be that node or Java).
I'm really liking Jooby (Java8) http://jooby.org/quickstart/ 
You'll incur overhead by spawning a thread to do simple password validation, are you querying against another webservice or something? Password validation is something that only gets executed once when a user signs up (or if they change their password), your validation of a password should only take a few milliseconds, if it's taking longer than that you should probably look at how you're validating.
I second refactorability. Doesn't matter how great/flexible you think your design is, changes will be required. Java has the best tooling for this. I love TypeScript, and it greatly improves javascript's refactorability, but in the end its only as strict as the person writing the code wants it to be and it's easy to get a lot of `any` types all over the place
If you are looking for a better Java check out kotlin. It is much newer and provide excellent interop with Java while preserving strong typing.
still mostly synchronous. You cannot build performing distributed systems on top of that. Async support is just plain ridiculous. You probably just don't know that things can be so much better than this ... https://github.com/sgilda/wildfly-quickstart/blob/master/ejb-asynchronous/client/src/main/java/org/jboss/as/quickstarts/ejb/asynchronous/client/AsynchronousClient.java
even worse: the example code of the link isn't really async as it uses old flawed **blocking** future of jdk 7 (?). They just seem to not understand, but you will when you have seen real clusters based on this in production: no throughput, 10% CPU load, everybody is waiting ..
funny : private void getResultAsync() throws InterruptedException, ExecutionException, TimeoutException { Future&lt;String&gt; myResult = accessBean.longerRunning(200); // Start a call with a short duration // simulate something // wait below 200ms will force a timeout during get Thread.sleep(400); // If you handle the TimeoutException you are able to ignore the result // WARNING: there might be an ERROR at server side that the result is not delivered LOGGER.info("Got the async result as expected =&gt; " + myResult.get(1, TimeUnit.MILLISECONDS)); }
And coroutine too...
I took a quick look at it but Kotlin's syntax turns me off - and yeah, that's coming from a Java developer who has written his fair share of curly braces, semicolons and anonymous inner classes... Also it is not even a blip in the recent technology radar, which is very worrying (while Groovy is, at least, a blip) https://insights.stackoverflow.com/survey/2017#most-popular-technologies What reasons would you have to recommend me Kotlin, personally?
It's more than simple password validation. It looks for a ton of different patterns within a password, lookups and fuzzy matching on dictionary words, leaked passwords, and names. It's a Java port of zxcvbn if you've ever heard of that. It's a good bit more advanced than zxcvbn in a lot of areas though. No webservice calls, just somewhat heavy computation. It will estimate a 15 character password in about 10ms. Larger passphrase are where it gets slower as there get to be exponentially more combinations of partial matches. I have to find the combination of those which make up the whole password with the lowest entropy. Here is the repo if you're interested at all: https://github.com/GoSimpleLLC/nbvcxz
Okay cool, I'm guessing you've already come to the same conclusion: I wouldn't bother threading this, if it's only taking 10ms for a 15 character password you'll be fine. I'm guessing you probably don't have more than 1000 users signing up per day? Worst case is 10 user password validation attempts per user * 1000 users * 10ms ~100 seconds over the course of a day. This is a little longer than I thought the worst case would be, but it's still not too bad since this is obviously not going to be 100 seconds straight and it will be parallized by your java application server (assuming each request is it's own thread). But this is also worst case, most people I would assume can supply a usable password within 2-3 attempts and most people don't have a 15 character password. Anyway, best of luck! Cool library though, never heard of it!
Kotlin is a first class language on android, is a first class language in most java web frameworks ([spring](https://spring.io/blog/2017/08/01/spring-framework-5-kotlin-apis-the-functional-way) , [sparkjava](http://sparkjava.com/news#spark-kotlin-released) and a few others), gradle is migrating away from groovy to [kotlin](https://blog.gradle.org/kotlin-meets-gradle). It is built and used by Jetbrains so it has excellent ide support and wont be going anywhere any time soon. Personally, I really enjoy using the language as well. Also I have worked in almost every JVM language. 
To me, not having to rely on npm is enough reason to choose Java instead of Node. npm is a colossal pain in the arse.
Take a look at vert.x, one of the best tool sets for building microservices. In general, modern Java has many advantages over nodeJs: * Maintainability - much easier for debugging and refactoring * Performance - Just check TechEmpower benchmarks * Mature and well tested Ecosystem - no left padding surprise waiting for you * on and on...
My primary recommendation is for you to learn a new JVM language. Almost any of them will be a true growth experience. I won't tell you to pick Groovy, but I am an unabashed Groovy fanboi. Others will mention Grails, Gradle, and Jenkins, and that's great. I love it because it helps me make teams better; that is, there is a multiplier effect that will raise your visibility on a given team, at your real job. The contexts for this include: writing tests, writing devop utilities, and trouble-shooting Prod issues. On the latter, imagine scripting a client that queries REST servers in your Dev, QA, or even Prod environments. It's fabulous (especially when re-using existing, production code). Yes, you _could_ do it in any JVM language, including Java, but in Groovy you _will_ do it. Groovy is especially good for this because it is so similar to Java: it will be easy for you to pick up and easy for others to work with. They may not write idiomatic Groovy at first, but that's fine. For an expert, it is quite expressive. File IO and other common tasks are trivially easy (compared to Java). Others have questioned if Groovy is ascending or not. I don't know. Certainly, Kotlin looks to be on its way up. But, learning Groovy isn't a massive undertaking. Give it a shot for a 2-3 months and then re-evaluate.
Don't use java dude. I don't even like typescript but in your case, go node and TS. Node excels for micro services, especially since microservices are smaller by nature, so there's your maintainability, and if you use typescript (which is now mainstream), there's your refactorability. It's a pleasant stack and you can iterate quickly
&gt; java.net.URI("http://...") &gt; // complains about URI... I just tried it out. This works in JShell - jshell&gt; URI myURI = new URI("https://www.google.com") myURI ==&gt; https://www.google.com jshell&gt; myURI.getHost() $12 ==&gt; "www.google.com" The error comes only when I don't use **new** before URI(), which is expected - jshell&gt; URI("https://www.google.com") | Error: | cannot find symbol | symbol: method URI(java.lang.String) | URI("https://www.google.com") | ^-^ URI.create() also works - jshell&gt; URI.create("https://www.google.com") $14 ==&gt; https://www.google.com Moreover, java.net.* is imported by default in JShell. So you don't need to import it yourself. You can verify that by typing /imports command - jshell&gt; /imports | import java.io.* | import java.math.* | import java.net.* | import java.nio.file.* | import java.util.* | import java.util.concurrent.* | import java.util.function.* | import java.util.prefs.* | import java.util.regex.* | import java.util.stream.* 
Dynamic/weak typing and strong/static typing do tend to ebb and flow, but I don't buy that the days of dynamic programming are gone. It is wise to know languages across that spectrum. Over my career, I find dynamic/static typing to be like offense and defense in team sports. Every now and then one team will define an era with its offense (or defense) but the other approach inevitably returns in force
Typically dynamically typed languages rely on unit-tests instead of the compiler. If you neglect to test, then yes, runtime is going to be unpleasant. In my experience, I haven't found it less safe or less pleasant than programming in Java. Groovy has ultimately been a positive because of the reduced boilerplate and pragmatism vis-a-vis IO, SQL, etc.
dotty is effectively scala 3.0. it's the direction scala is headed in the future.
I have a pretty solid opinion about this: * weak typing 10/10 times for scripts, glue and utilities. Less overhead, faster to write, faster to change. * strong typing 10/10 for bigger, more complex projects that have to be maintained / expanded / understood for years. You need something to manage all that complexity - namely compile-time errors and refactoring tools. It's more cumbersome to write but it pays for itself well over the years. At this point in the time this is self-evident to me, based on the nature of weak/strong typing itself.
I understand what you're saying but having to run a dozen test cases only to find out you misspelled a method name isn't really a proper workflow. What I mean is: sure is nice to have unit tests but they really aren't a replacement for strong typing at all, if they do that it's only coincidentally and not nearly anywhere near to being the real reason why we write them (which is only more evident if you consider strongly typed languages have unit testing too).
As with anything else, use the right tool for the job. I like Groovy for a lot of tasks, Kotlin for others, Ceylon for a few, and so forth. Groovy has some really powerful features, and if they help you get your work done and are still cool following "the next guy" principal, I'm all for it. 
Correct. There is still way too much J2EE stigma associated with Java EE, and the only way to fight it (imo) is by bringing modern Java EE examples to light. To this day google search results around 'java enterprise' keeps bringing back superseded J2EE examples.
We already have Kotlin for a great JVM REPL! 
This wast post version 2. The compiler caught some things but there was a lot it would not catch.
Why is the syntax turning you off? It's way better than Groovy syntax to me. And Groovy is a dying language. Gradle was one of its major backers and they're moving to Kotlin. Kotlin is also a first class language on Android now. 
Instead of writing the proposal, start writing the node services. It's much faster (from a development time point of view). On the other hand, if you have a hankerin' for oracle's tender touch, it might make sense to stick to java (plus you get to write a lot more voluminious code for the coder who loves writing more code ) 
You can make two version, a single thread method that doesn't fork and a multi-thread that takes an user supplied Executor.
&gt; It is much newer... That beats all other potential languages for sure! 😈
This should improve remote debugging then, correct?
Definitely! Testing tools and IDEs can make use JShell's APIs to improve remote debugging.
???
&gt; still mostly synchronous. You cannot build performing distributed systems on top of that. Really? https://techempower.com/benchmarks
&gt; the node ecosystem is still quite young and not as stable as java's That is quite an understatement.
It's not node.js /thread
Why is somebody writing an article about gc in 1.6 in 2017?
My IDE makes it simple to generate them, but they still fill the file with verbosity. I once converted a 100 line Java POJO to a 20 line Kotlin POJO.
Using a concurrent code might result with errors within your code, such as starvation, liveness and others. It's very important to deal with those as soon as possible as they tend to be hard to find later. There are programs you can use in order to help you detecting them, such as checkmarx and others. Make sure you solve them all as they can be a real problem if you don't.
You're looking in the wrong place https://www.tiobe.com/tiobe-index/ http://redmonk.com/sogrady/2017/06/08/language-rankings-6-17/ http://redmonk.com/sogrady/2017/05/24/kotlin/ Ctrl + F -&gt; Kotlin
?
If you liked this article, I have [140 more](https://vladmihalcea.com/tutorials/hibernate/) about RDBMS, transactions, caching, batching, fetching, and how to get the most out of your data access layer.
How man's people are using the library? If the answer is none, don't break a sweat.
TypeScript's structural-only type system is a bad joke. Nominative typing or GTFO.
lol
I use regularly Groovy not as language but as DSL because of Jenkins. I honestly hate it. Not because of Groovy itself, but because Jenkins's implementation differs substantially on some constructs and also forbids to import libraries (eg. Cannot use XmlSlurper to parse an XML, i need to use a function provided by a Jenkins plugin). Also Jenkins pipelines are a PITA to debug because of Groovy not having type safety. I don't use Gradle for the same reason, it is another Groovy DSL, with all the problema and very little advantages. I would like to enter in the mind of whoever thought that a scripting language is better at configuration than a fixed-schema in YAML, json,XML... (╯°□°）╯︵ ┻━┻ 
Vert.x supports Java and JavaScript
There shouldn't be such thing as "optional by contract". The contract means "the set of things implementor is able to do" or "the language the implementor understands". If there is an add method in the contract, as a client, I naturally expect it to work on all implementors.
Don't pick Java. Node tooling is the best, it performs better and is much cheaper to develop. Typescript will provide you the readability you need to share definitions across projects. Just make sure you test every API. Most companies i have seen struggling with node just do because they don't have a good test infraestructure. 
Lol true. In the time it takes to make a powerpoint, the first version of one of the services could be coded up already in Node.
Nice find!
uhm i don't know.. it looks more like a problem with the reordering of instructions. I mean, when one writes down multithreaded code, he plan all possible switch of two threads running the code *linearly*, which is already quite hard, there's no way one can foreplan instruction reordering (at a granularity below java instruction, too).
Article is not accessible without logging in.
also i don't think the claim "BigDecimal is mutable" is correct. Mutability is about the external view of an object, not it's internal workings. An immutable object can still have some internal state that mutates for whatever reason (caching for example), it just need to encapsulate it and make it invisible from the exterior.
!?
&gt; Wow dzone went to shit. DZone was shit as long as I can remember.
I thought it was just me. DZone, why??? 
&gt; The caching of the computed String in an instance variable in the method toString makes the class BigDecimal mutable and the method toString not thread safe. It's important to note that it's perfectly fine to cache and be internally mutable, as long as you do it in a threadsafe fashion. For this you can use an AtomicReference or slap a volatile modifier (which will ensure happens-before between writes and subsequent reads) before the field, at least in this case, or use synchronized. With volatile your program might end up doing some unnecessary work, but you won't encounter the issue described by the blog post*. In the end, for an external observer, the class is immutable. \* depends on the concrete case 
All true, I think I went full python u_u; btw: any idea how to import the new http api ? HttpClient ? it's supposed to be in jdk.incubator.http but I failed hard there too.
You can however make guarantees using volatile and synchronize in cases where it's necessary.
https://webcache.googleusercontent.com/search?q=cache:vQPdqJJc5OgJ:https://dzone.com/articles/javashymathshybigdecimal-tostring-is-not-thread-sa+&amp;cd=1&amp;hl=en&amp;ct=clnk&amp;gl=en For those who interested. tl;dr The article promotes VMLens, paid instrument to detect race conditions.
Huh, it still worked 3 hours ago...
It's just "unsafe publishing" - you need some form of synchronization (such as using the synchronized keyword or a volatile field modifier) to read/write mutable instance fields outside the constructor.
The package `jdk.incubator.http` is declared in module `jdk.incubator.httpclient`. You need to first add `jdk.incubator.httpclient` module to jshell. Just start jshell with the following command - jshell --add-modules jdk.incubator.httpclient And then, You can use httpClient in jshell - jshell&gt; import jdk.incubator.http.* jshell&gt; HttpClient client = HttpClient.newHttpClient() client ==&gt; jdk.incubator.http.HttpClientImpl@345965f2 
Go post some more complete beginner questions on your troll account by accident please. 
I'd personally quit and look for another job if your company is fine with a team just starting work on a bunch of microservices like that without having some kind of understanding between all the teams of what the best approach is. Ignoring all the countless "why we moved away from node" blogposts out there already (it's definitely in the "trough of disillusionment now"), you spend a lot more time reading and maintaining code than you do creating new stuff from scratch. In my experience with both Node is in no way 'faster' to develop if you compare it with for example Spring Boot and JavaScript code is a complete utter pain to debug and refactor. Slow and steady wins the race. Node.js is more like "crash and burn" without even finishing. 
How to handle CPU intensive calculations in a library is generally best left to the user, not the library. You're better off giving some example in the documentation they can use. 
I think Groovy is nice as a scripting language. It's IMHO also a good example why for anything other than a scripting language you'd generally prefer strong typing. 
You should post in /r/javahelp for support questions like these. That said; are you 100% sure you installed the 64 bit VM?
Another thanks. I guess I need to read the module spec too :)
I was registered a long time ago: &gt; Access Denied &gt; &gt; We're sorry, but you do not have permission to do the activity you attempted. If you believe this to be in error, please contact the site administrator(s).
&gt; But where does that instance come from? The instance is created once, either in `main` or when the DI container starts. This isn't global state because it is not globally accessible. &gt; you don't know if its a singleton or not Why do you care? &gt; without digging into the DI config This seems like a preferable problem to hidden dependencies. At least the config is separated.
You can be loose in Java too. 
&gt; The instance is created once Singleton? &gt; either in main or when the DI container starts. This isn't global state because it is not globally accessible. Can't I just @Inject it wherever I want how is that not globally accessible? &gt; Why do you care? If i'm injecting a cache and its not a singleton I'm going to have an awful lot of cache misses. I'd say thats pretty important to know. &gt; This seems like a preferable problem to hidden dependencies. At least the config is separated. I'd disagree. Here is something I see fairly often. public class MyObject { private final Executor cpuExecutor; private final Executor ioExecutor; @Inject public MyObject(@CPU Executor cpuExecutor, @IO Executor ioExecutor) { this.cpuExecutor = cpuExecutor; this.ioExecutor = ioExecutor; } } vs public class MyObject { private final Executor cpuExecutor = Executors.cpu(); private final Executor ioExecutor = Executors.io(); ... } One involves digging through DI modules that could be who knows where. The other involves just clicking the method name in the IDE and jumping into the declaration. Sure some IDEs have better support depending on the DI container but it still seems like quite a bit of indirection. I think DI has a use, I also see it completely and totally abused / overused because people are afraid of the `new` keyword. 
&gt; Code Smells: Mutation Hmm... Two others in those series are raising an eyebrow: - Code Smells: Null - Code Smells: Iteration All of those are by Trisha Gee, whom I respect a lot as a developer. But that's... quite a low bar to declare something a "smell". Sure you can abuse everything. But by that criteria everything is a smell, and lately I see functional paradigms (like Optional, streams and immutability) abused extremely abundantly. Maybe that means they're also a smell. Everything is a smell.
TL;DR: * `BigDecimal` caches the result of `toString()` in a non-volatile private field `stringCache` without synchronization. * ARM processors like to reorder memory reads and writes. * EDIT: The implementation of Java they used has a bug regarding memory barriers and final fields. * Therefore, it's possible that `BigDecimal.stringCache` will contain a non-null reference to a string that hasn't been fully constructed yet and has null as a backing array, because the write to `BigDecimal.stringCache` gets reordered to happen before the write to `String.value`. Another thread might see that non-null `BigDecimal.stringCache` reference, assume the string is ready to use and crash. I'll just add that `BigDecimal.stringCache` was volatile (which would prevent the bug) in [early versions of Java 6](http://grepcode.com/file_/repository.grepcode.com/java/root/jdk/openjdk/6-b27/java/math/BigDecimal.java/?v=diff&amp;id2=6-b14) and it was ~~broken~~changed probably in [update 25](http://www.oracle.com/technetwork/java/javase/6u25releasenotes-356444.html) as a part of "performance improvements".
I'm struggling to see where the reordering can occour. Is it that `layoutChars` can return before the the `StringBuilder` has fully constructed the `String`? 
Code stinks to distinguish mere smells
The CPU does the following (ignoring unimportant details): * allocate a string * call the contructor * allocate an array * schedule a write to `String.value` * return few times * schedule a write to `BigDecimal.stringCache` Unless one sets up appropriate memory barriers, the changes can be executed in any order. But I'm not qualified to get into details of that, especially on ARM.
&gt; Singleton As opposed to Singleton Pattern. &gt; Can't I just @Inject it wherever I want how is that not globally &gt; accessible? Using `@Inject` is in effect the same as a constructor argument. The value is provided externally by another component which actually has the instance, which means that the value is not globally accessible. &gt; If i'm injecting a cache and its not a singleton I'm going to have &gt; an awful lot of cache misses. So create one instance and pass it around. EDIT: Continued... &gt; One involves digging through DI modules that could be who &gt; knows where. Yes, but those static references could be pulling in dependencies from who knows where. Now, suppose I want to use the class with dependencies in another context, and I start seeing random failures because the environment that I'm running in isn't set up the same way in the original context. I have experienced this frustration first hand. Dependency injection, when coupled with dependency inversion, offers context independence, providing a way to avoid annoying coupling that makes code more reusable. 
In order to really immerse yourself in the smells, you need to have the CyberSniff 2000.
The iterations article talks about iterating a collection to find if it contains a value, instead of using a set or map.
Thank you all for your input. I'm glad I asked because as I said, I really couldn't find any info on this when I looked. I agree with the consensus, it's better to just keep the execution path for the library serial. The library is thread safe, so i'll not worry about speeding up single execution.
That benchmark says nothing about performance in a microservice setup. It's known core java is fast. In a microservice / distributed system it comes down how to handle remote call latency. Problem of snychronous communication is that you simply don't get load into your cluster. Example: You have a service's A,B,C. A makes a remote call (~rest request) to B, B then needs to do 10 calls to C (~e.g. a remote key value store service). Say network latency is 10 ms (cloud, machine+network virtualization, far services). The cost of actual operations is near zero (key-value stores, business logic is fast, in the microseconds), so the duration of the processing as seen from A is determined by network latency (A =&gt; B =10*=&gt; C=10*=&gt; B =&gt; A) ~ 200 ms. Let's say you can afford 1000 threads in A, then you can have 1000 requests-in-flight until you run out of threads (all blocked waiting). This means A has a throughput cap of 5.000. As the key-value store actually can do 500.000 lookups per second, you are far from being able to saturate the hardware. If you do this completely asynchronous (not fake async as in example above, this is a wrong example) you get full throughput as latency does not cap the number of requests in flight. The mechanics described above get even worse once there are many services and long remote-call-chains (e.g. A=&gt;B=&gt;C=&gt;D=&gt;E). That's why nodejs seems to be faster in a microservice setup, though its core performance actually isn't.
I only have the stats I can pull from Maven, and as of July, it looks like I have 65 unique IP's which used the library, and downloaded it 1000 times. I developed it mainly to use for my company, but then put a bunch more time into making it something I could release open source with good documentation. It was more a general question on best practices, as it's not something i've ever seen or thought about before.
Yeah, the "beauty" of the b2b space i'm in, is I don't have to handle scale the same way any sort of public facing application does. Each client we get has anywhere from 5-30 users, and that's it. That number only changes if our clients fire / hire someone, or we get another client. It's not a problem for my company at all, I was more just wondering what the best practices were, and if handling your own threads was totally taboo (which I now now, yup...not a good idea). I do have a few other people using the library I can tell, but not sure exactly how many. I can see some stats on Maven that there were 1000+ downloads in July.
Thanks for the feedback, I agree. I'll leave it as-is.
I have written and been maintaining a medium size grails project for quite a few years now so use Groovy there. I like Groovy, its java interoperability is great and you can write pretty concise code. It is very easy to learn because all java code is legal groovy code, so if you don't know the "groovy" way to do something, you can write it just like you would in java. Slowly but surely you can learn the groovy idioms and create more concise code. I would highly recommend you don't go overboard with the dynamic typing and stick with strongly typing your code. Especially if it is something you are hoping to have make sense when you look at it again. Especially make sure to strongly type method return types and method parameters. Dynamically typing a local temp variable won't cause you any grief later and you can still use dynamic types for that. Groovy is also great for scripting since groovy code doesn't have to be wrapped in a class. I still do quite a bit of shell scripting but for scripts where I have to process csv, xml, etc I tend to use groovy instead of bash (especially if I need to use a collection like a Map or Set to keep track of already parsed data). Groovy is the first language that introduced me to multiple return values from methods. That is one feature of groovy I really miss when writing java (kotlin also allows this).
&gt; stick with strongly typing your code Other people in this thread have told me that this is more of an illusion in Groovy. Would you say that is true? Or can it be 100% equal to Java if you use strong typing everywhere? I mean in the sense of everything being compile-time errors and not at runtime only.
I have looked at the Tiobe index and both Groovy and Kotlin are pretty close together: 41 and 48 or something. Sure, it's an almost-ten rank difference but when you're in the 40s that feels like they're pretty much in the same league.
Java EE got a bad reputation in its early days which was deserved (called J2EE back then). Since it got that bad reputation early no one bothers to look at the new Java EE spec, 7 is indeed quite good. A lot of newer java programmers don't realize that most java web frameworks are just wrapping up Java EE for convenience. I would highly recommend people starting a new project at least take a look at the Java EE 7 tutorial before deciding if they really need a framework (http://docs.oracle.com/javaee/7/tutorial/). Tomcat (Servlet/JSP/EL) with Jersey added as a dependency is all most people need. If you have experience with tomcat and jersey and bootstrapping a new project you can have a basic REST app going in about 10 minutes with Java EE 7. If you really need the full Java EE stack you can use TomEE, JBoss, glasshfish, etc. 
As a Scala programmer, I find this claim amusing. Scala has first-class singletons, and uses them heavily. It also makes heavy use of immutable state. No, DI is not the be-all end-all of software componentry. DI has its own problems, most notably that it is difficult to debug problems with the DI system itself (e.g. wrong object being injected).
Take a deep look at the Lagom framework.
The article can be found on the author's website http://vmlens.com/articles/java-math-BigDecimal-toString-is-not-threadsafe/ 
I decided to go back and and read the first one in the series about nulls. What I encountered was Article Smell: Advertising Our Product. I'm not kidding, the entire series feels like an advertisement for features of IntelliJ IDEA to get people who use other IDEs to switch to it. Edit: Strangely, reading the other articles, only the first is basically a blatant advertisement for IntelliJ IDEA.
Though JavaScript and Node are both problems on their own.
I learned Java on the job with my C experience at a time when Java experience was scarce. I doubt I could do that today because of the market's maturity. 
The iterations article can be boiled down to a single sentence: Use the correct data structure for the job.
Ahh yeah, I hear you haha. Where I currently work we are in b2b as well (enterprise focused, same scenario), each client only has 1-100 users. The b2b beast is usually less of a performance problem and more so a complexity problem; where the software tends to do a lot more and touch more things and the clients either have their own process they really want you to conform too and or are often unwilling to put any effort into learning ANYTHING :(
I will grant you that this is clearly a product demo. However the subjects in this article series are in my opinion genuine code smells. Issues that I generally try to avoid creating personally and discourage team members from doing. IDEA provides the tools to quickly fix these issues in existing code. However most of these are also present in Eclipse and NetBeans and I can not point to a single instance where any IDE is better then the others. Taken everything together though I find that doing the same thing in IDEA is just a little bit easier then any other IDE. Which is why I am a paying customer.
Groovy is ten years old and most of it's usage is restricted to gradle/jenkins scripting, afaik, while Kotlin is much younger and used as a main development language. Kotlin is also backed by a company that won't go out of business anytime soon, it is also one of the official Android/Spring languages. Wait til Android Studio 3.0 official release, Kotlin will soon be for Android what Swift is for iOS.
&gt; Typically dynamically typed languages rely on unit-tests instead of the compiler. Ironically DI has the same effect yet is regarded as better than not using it. Really, it's ironic. It would seem a sect of the Java community (my paranoia tells me it's driven by JetBrains); thinks DI and Kotlin are the only way forward for development on the JVM. I guess we should all just submit, it will all become clear when Google acquires JetBrains; JetBrains already is on the JCP. 
Could you throw in a few more words about undertow? Just something to Google for.
There is so much documentation out there on why singletons are an anti-pattern. Just have an open mind, search it and read it. It would be pointless for me to argue here as there are whole articles out there about the topic. &gt;Scala has first-class singletons, and uses them heavily. C/C++ also uses pointers heavily. That does not say anything about how good they are or not. &gt;DI has its own problems, most notably that it is difficult to debug problems with the DI system itself (e.g. wrong object being injected) DI is a principle, not a specific system or framework. You can have DI without any actual DI framework (you just manually inject everything yourself). Maybe not truly practical, but certainly possible. 
My recommendation for strongly typing is for readability reasons (and hence maintainability). Even with strong typing, what would be compile time errors in java will be runtime errors in groovy because in groovy it is perfectly ok to call a method that doesn't exist at compile time. You can statically compile groovy if you would like, see: http://docs.groovy-lang.org/latest/html/documentation/#_static_compilation
There hasn't been any official claim yet (that I'm aware of) that Gradle is migrating from Groovy to Kotlin. They added support for a new DSL in Kotlin and they've started porting their internal Groovy code to Java for performance reasons but that doesn't imply a migration to Kotlin. That said, if Kotlin surges in popularity in the next few years, it might eventually make sense (and their previous actions would certainly help enable that).
&gt; The instance is created once &gt; Singleton? I am against the singleton design pattern, not the singleton as a concept (i.e. having only one instance of a class) &gt;Here is something I see fairly often. Can you also give us the unit tests for your examples? It should be obvious which one is easier...
Leaving language aside. Node is single threaded non-blocking. All good. Let's say you're running this on a fat machine. Ok, you start N processes, each single threaded to match your N CPUs. Still good. Ok, now you realize that sending all requests onto the DB is not cutting it performance wise. So you introduce some caching. BOOM, you're onto the network, even if only the local network or within a machine. Why is that bad: https://people.eecs.berkeley.edu/~rcs/research/interactive_latency.html With java you can place an in-memory cache in the JVM and this can be shared across all the threads serving your requests. This can reduce response latency and even eliminate many context switches. In turn this machine can handle a large number of requests more quickly. How much of a win this depends on the nature of your requests (cache hit rate?), but this can make a huge difference in some situations. 
I would say that there are 0 reasons to use the singleton design pattern in a greenfield project. The cons outweight the pros. &gt;As far as I know design patterns are not just coding patterns I agree with you. The problem is that the site does not really explain that a design pattern is just a concept and then giving an example. It just goes straight into code classes, implying that _everything_ is a coding pattern. Here is what I am talking about: http://java-design-patterns.com/patterns/cqrs/
Another solution is to not go overboard with microservices. Divide your code in a small number of useful services, but don't make a service for every tiny utility. A lot of things become much easier and much faster when doing them in parallel, but without overusing the async pattern and going into callback hell. I've build very high performance systems that dispatched work to a small number of worker services, that on their turn processed batches in stages. Pushed CPU, memory and IO all to the max (we were using a RAID setup with 24 SSDs and 3 Areca raid controllers with 8GB memory each). 
And someone who's had that experience would only need that 1 sentence summary. Other, newer programmers probably benefit from the examples provided in the article ;)
Late to the party but Google Trends are trends across the whole internet and not just within the search terms. Basically as more and more people all over the world are getting internet the relative amount of searches for niches goes down compared to everyday stuff. Still doesn't mean that less people are searching for them.
node tooling involves NPM. NPM is awful. there is zero decent control over the version of the libraries you get built with. Recently they've introduced package-lock.json to try to fix original design problems. But even that is pretty much of a hack. Nope sorry NPM is recapitulating many of the same problems that java had and solved more than a decade ago. It's simply not, yet, primetime. Perhaps another 3 years ? Or perhaps fine if you develop a blogging app and repeatable build are priority #6 or something. Node has one advantage which is you can employ people who know javascript and don't want to become polyglots.
If the HONEST plan is to trash these microservices and rewrite them instead of maintaining them. I think there is some decency to this concept. But MOST managers refuse to throw things out and start over.
The same kind of somebody that writes Java in all capital letters as if it's some kind of acronym. :P
&gt; there is zero decent control over the version of the libraries you get built with Learn to use npm and avoid using software from maintaners such as [hapi](https://github.com/hapijs/hapi/blob/master/package.json) that like to open source dependencies with 2.X.X or 3.X.X for some reason. &gt; Node has one advantage which is you can employ people who know javascript and don't want to become polyglots Advantages: * no useless run-time validation * faster development times * async programing * very low resource usage * Typescript syntax is very similar to JAVA You also avoid: * the most OOP mainstream oriented language with tons of bootstrap code * no Tomcat/Widlfly * I avoid spending my whole day compiling and deploying * paying IntelliJ license since Eclipse and Netbeans are horrible * using Reflection based frameworks * avoid using Software made by the same people that convinced the world that Java applets were a thing
Yeah, "microservice" is definitely overhyped :). Batching can help to overcome limits of sync processing, but it's not always applicable. Anyways we are moving into an always-on (=incremental,partial sw updates), globally distributed world with varying and unforeseeable infrastructure quality (regarding latency), so we need a fundamental shift in the way we architect our systems. Asynchronity is a major requirement (even at the cost of callback hell, but actor systems/promises/async/await can help out ..). 
&gt; The contexts for this include: writing tests, writing devop utilities, and trouble-shooting Prod issues. On the latter, imagine scripting a client that queries REST servers in your Dev, QA, or even Prod environments. It's fabulous (especially when re-using existing, production code). Yes, you could do it in any JVM language, including Java, but in Groovy you will do it. Can you elaborate on that last sentence?
If scalability is a factor then Java is the wise choice. Java supports the event-driven asynchronous design with a single thread or 1000 threads with frameworks such as Vert.x, Akka, or Play. These are (very) competitive in benchmarks https://www.techempower.com/benchmarks/
Undertow is an excellent web server built and maintained by red hat. Its the core of JBoss (but they kind of ruin it by wrapping it with jee soup). Its also available stand alone and has a very usable API and intuitive design. It supports both async and synchronous http processing, which turns out to be very useful. http://undertow.io/
&gt;There is so much documentation out there on why singletons are an anti-pattern. Yes, and most of it is wrong, incomplete, insufficiently specific, or otherwise defective. &gt;Just have an open mind, search it and read it. I *have* had an open mind. I have ample experience with DI systems. I have learned their strengths and weaknesses. DI *is not perfect.* &gt;C/C++ also uses pointers heavily. That does not say anything about how good they are or not. That's not my point. I also have ample experience dealing with Scala singletons, and they've given me very few problems over the years. &gt;DI is a principle, not a specific system or framework. You can have DI without any actual DI framework (you just manually inject everything yourself). Maybe not truly practical, but certainly possible. I'm aware. You can also use other approaches—singletons, service lookup, `ThreadLocal` context—which all have their own strengths and weaknesses. My point is not that DI is useless. My point is that it is not a silver bullet, and the other options are not anti-patterns.
Cool!!!!
Is it any surprise that a Jetbrains evangelist should use the Jetbrains blog to show off some features of a Jetbrains product?
A lot of math operations are being swapped out that way. The default implementation is just for systems which do not support these operations natively (nowadays pretty rare)
To me, it sounds like an advertisement for Scala. No null checks. No mutations. Beautiful streaming.
From small startup to maintainable Enterprise code base, I'd go with: * 1) Java * 2) Spring Boot - deploy to runnable war with embedded Tomcat * 3) Docker - deploy runnable war to an image Once you have that, look at the Docker possibilities for running multiple containers and controlling them, Swarm or kubernetes for example. Edited for formatting. 
Heh, yup sounds exactly the same as what i'm dealing with. The "do a lot more" is the most close to home. Good god the amount of features and flexibility / configuration those features need to all have is where it hurts the most. But I am happy about not having to directly interface with the public. Not my forte.
I love let. If I could change any one thing about Kotlin right now, it would be to change val to let. But, that being my biggest gripe right now, I must confess myself happy as a clam.
All the posts in this series have also been posted to other websites, such as DZone.
Code Smells: Code
https://coderbyte.com/ https://www.hackerrank.com/ https://programmingbydoing.com/
&gt; Well, any tips? Feel free to make suggestions, I'll look them all up. Start by reading [the sidebar](https://www.reddit.com/r/java/about/sidebar).
r/dailyprogrammer
What's the performance benefit of explicitly listing the arguments in the first 10 methods instead of just having the method with vargs?' http://download.java.net/java/jdk9/docs/api/java/util/Set.html#of--
If you are worrying about long-term refactorability of a microservice or the complexity of refactoring you're doing microservices wrong. 
You should take a moment to reflect and ask yourself why you want to use Java so badly if you cannot come up with enough reasons to justify it. The knee jerk reaction to circle the wagons when the unfamiliar encroaches upon your territory is common to most developers but it sounds like you lack the experience or total context to evaluate whether this is a good move for the company. It feels like trying to compile a list to hand to your boss as some sort of persuasive attempt to stop or slow change. I think you're onto something with the polyglot argument. The companies that most successfully adopt microservices are ones where the teams are strongly isolated (often because the teams are geographically distributed). The tech choices from Team A, B and C do not impact each other because each one staffs to fill its own needs. This is not a technical problem but an organizational and management problem. 
Aren't data structures and algorithms a must know for the basic programmer technical interview?
* Not necessarily, and * There are plenty of self-taught, or actively learning, programmers out there who aren't interviewing (students, etc.)
Having done years of development in both environments, I will just say that you're stretching the truth. 
re: elaborate? Sure. Let's say that you want to write a client that uses production code. Let's say that we want to be a mock Tomcat webapp that uses Spring services to query a DB or REST api etc. We could use any JVM language for our client. Obviously, Java comes to mind. But no one can be bothered to do that because the perceived cost of entry is too high. Java has too much boilerplate; Clojure and Scala may be too unfamiliar, and so on. Groovy, by contrast, is like a puppy that won't go away. It is super-easy to get started, and then build on. For our client, it is ultimately just classpath stuff and authentication configuration etc, but the magic is that, with Groovy, _you started_. I have observed this happen on multiple teams. I've given a conference presentation about it (the talk paired my Groovy journey with lessons from Terrence Ryan's book, "Driving Technical Change".). Again, you _could_ write these utilities in _any_ JVM language, but Groovy actually motivates your team to do it.
The java memory model guarantees that this behaviour is safe, as String's value field is final. The implementation of the JVM they are using on their raspberry pi is broken and does not follow the specification.
disagree. In the real world, you need to move stuff/responsibilities e.g. from one service to another, combine or split services and so on, rework messaging interfaces etc.. Frequently, a microservice turns out to be not that "micro" after 3 years of development and feature-bloat. That swarm of tiny 500-liners some people insinuate is just a wacky idea. A 500000 LOC project (this is not unusal) then results in 1000 separate services. Such a system would do nothing than encoding, decoding and networking. It will perform extremely poor. A remote call/request is &gt;&gt;1000 times slower compared to an in-process method invocation. So remoting is something you "need" to do, not something you "want" to do. The design / responsibility assignment of microservices needs to relate to business logic and data locality, not LOC. So in real world systems service size is from 500 lines up to some 10k LOC. Operating + testing + monitoring + debugging and maintaining a swarm style system can be a nightmare + extremely expensive (been there). So first consideration when introducing/splitting a service should be "Do I need it ? Does the benefit justify the added complexity + cost ?" 
I couldn't find the post but I was thinking they had something about moving plugins to kotlin as well.
It sounds like you are saying that Groovy has a lower barrier to entry than other JVM languages, making it easier to get a project started with. I can relate to that. There's a reason most of my command line tools are written with PHP, or Python, or Perl... Thanks.
Oh yeah, spec chapter 17.5: &gt;final fields also allow programmers to implement thread-safe immutable objects without synchronization. A thread-safe immutable object is seen as immutable by all threads, even if a data race is used to pass references to the immutable object between threads. This can provide safety guarantees against misuse of an immutable class by incorrect or malicious code. final fields must be used correctly to provide a guarantee of immutability. &gt;An object is considered to be completely initialized when its constructor finishes. A thread that can only see a reference to an object after that object has been completely initialized is guaranteed to see the correctly initialized values for that object's final fields. &gt;The usage model for final fields is a simple one: Set the final fields for an object in that object's constructor; and do not write a reference to the object being constructed in a place where another thread can see it before the object's constructor is finished. If this is followed, then when the object is seen by another thread, that thread will always see the correctly constructed version of that object's final fields. It will also see versions of any object or array referenced by those final fields that are at least as up-to-date as the final fields are. So BigDecimal is fine, it's their VM that's wrong. 
I remember when I was using the C programming language more than 20 years ago and learned how to use the select system call. In a single thread I could monitor multiple file descriptors for I/O. What's old is new again. 
rock solid stability
Yea I get what you're saying about data locality. Microservices aren't about LOC. "Micro" isn't about size but rather business boundary. That is something newcomers to microservices don't generally grok until much later. When I think refactorability I think of the work I've done with multi-million line monoliths maintained by hundreds of engineers. In those cases being able to easily and safely refactor is about not being a bad neighbor and fucking up several other engineers across several teams. I'm sure we've all experienced the horror of the "com.yourcompany.common" package being shared across thousands of class files. That concern is much smaller in microservices and should be more manageable and has been from my experiences. 
Check out http://www.jhipster.tech/ (no affiliation). It's a Spring based tech stack that generates a robust microservice architecture. The code generated is clean and a good starting point for a microservice based project. They have done all the hard work of integrating all the tools and technologies required for a microservice architecture. Definitely worth checking out.
Mature ecosystem, tooling, better performance and polyglot friendly. The JVM will be more awesome with the addition of value types (i know may be in java 10 or 11) , Shenandoah GC &amp; Graal. Moreover, you can always switch to more expressive languages on JVM like Kotlin with full interop.
I think the following point is important: &gt; A thread that can only see a reference to an object after that object has been completely initialized is guaranteed to see the correctly initialized values for that object's final fields. In this case, a thread can see a reference to the String before the constructor has finished. The Java Version was: java version "1.8.0_65" Java(TM) SE Runtime Environment (build 1.8.0_65-b17) Java HotSpot(TM) Client VM (build 25.65-b01, mixed mode) 
[https://www.codewars.com/](https://www.codewars.com/)
I actually like it, maybe not as the language to write project - I would never do that, I even know a company that went that direction few years back and they needed rewrite because of performance reasons. But it's amazing as a tooling language, Gradle, Jenkins and my biggest favourite - Spock. I will never go back to writing test with JUnit (hopefully).
Ugh, another content-free javadocs regurgiatiung article by that useless site. Guys, stop giving Eugene attention. He is a content spammer. There is _zero_ original or even useful content on that website - just lots of context-less stuff that is more often than not actually DANGEROUS to use without extra research and understanding context.
How does it compare to Jetty? They both seem to serve the exact same purpose.
It would be great if IDEs had a way to display: - The fact that the JDK one is using is swapping some code for an intrinsic version - The code of the intrinsic version in C or assembly or whatever (if accessible / legal)
1. Know what you want, and understand how it suppose to work. 2. Good practice - find out how work the libs that you use . Most the way you can remember exactly how you did write stuff, but knowing the methodology you used will save you most of the time. 3. Experiment with stuff, make weird thing's , make a problem from a nothing, try to solve it with over engineering, see that is bad, simplify it, in the end you will find a good practice to write some things.(Some times it's good to read books, i prefer the hard way, if a one man got his brains to that point, I can also) 4. Concepts are good when you don't wanna think and be a flower pot. But when you step from them a bit, problems occur.
[Codingbat](http://codingbat.com/java) is excellent for small bytes of logic puzzling.
Programming should eventually be like walking or speaking - you don't think about it, you just do it when you know what you want to do (like where to go or what to say). As for now - just write many small and medium size programs. You will gain a lot of knowledge in process by naturally memorizing code you use, learning about new ideas, fixing your own code, reading documentation/books (or stackoverflow ;) ) etc. There is no better way to learn programming other than doing it and overcoming problems you found.
I understand you. ? I guess, what you're trying to say is that programming language for you now is like when you're trying to speak your second language, you are thinking what to say, but not to much, and if you are not exactly sure how to spell a word, you check it out. How long did it took you to speak programming language
Depend which one. Each new is a bit simpler to learn because most ideas (algorithms, patterns) are shared between programming languages and only details differ. Unless it is of different paradigm (procedural, functional, map-reduce etc), but even then previous knowledge helps you to understand it. Also at one point you will have more problems with external libraries (how it works, how to use it, why is it not working as expected) than the language itself. Personally I am Java programmer (with additional JS code here and there) for like 7 or 8 years now, before that I used some C and Basic, however lately I am using Python more and more.
As for the question itself. I was using Java for a year before I applied for a job as a programmer, with some additional experience with C and JS programming, it was enough to get hired. Then it took me another year of "hard, day-to-day coding" to feel comfortable with Java.
This is doable for sure. There's a popular commercial DAW (digital audio workstation) written in Java https://www.bitwig.com/en/home.html If you google around (java DAW) you will find similar things with source code to study. 
It'd be a lot of work for the IDE with very little return.
Optional is good, but it's a PITA sometimes and adds more code than a null check in many cases.
If you're going to throw an exception to avoid returning `null`, it would be better to [throw a checked exception](https://www.ibm.com/developerworks/library/j-jtp05254/index.html). The runtime exception `IllegalArgumentException` indicates that you are using the API incorrectly, which is a programming error and not recoverable. A checked exception like `BlogNotFoundException` would allow the finder method to indicate that it might not return a result (through `throws`), and the compiler will force you to handle that case.
I agree that it's silly to return `null` instead of just an empty collection when a collection is expected. However, I don't agree with returning Optional as this obscures the "actual" return value and doesn't get rid of the necessity to make an absence check. I believe (as in "don't know for sure") that the Optional class wasn't primarily meant to be used as a return value but as an argument in situations where varargs can't or shouldn't be used. Edit: Tehehe :D
I think a good rule of thumb is that if you're only writing "Optional.isPresent()/get()" sequences you aren't using them quite right yet. The ifPresent(), map(), orElse() methods are all really great and can reduce a lot of boilerplate. I'm excited for stream() in Java 9 as being able to flatMap() out an Optional will be handy as well!
Yeeeeah, don't throw exceptions for things that can occur fairly commonly like this. You're making the same mistake the Java devs did when they made `Integer.parseInt` and the like throw a `NumberFormatException` as you have to do it to see if data being passed to you is actually a number. And if you're asking why I refer to this as something that happens very commonly, it's because the blog ID is generally part of the URL, which means it's easily manipulated by end users and generating a stack trace is relatively slow.
External libraries? Yea, yesterday I was trying to learn MySql combined with JavaFX to make GUI database, was way to much for me but just for now. Not to mention Spring, I can't even comprehend what does it look like. What I understand is that it connects things better and easier. I'm glad I took JavaFX first thing to learn, i think concept of OOP is really visible there. MVC. I can see it's very imprtant in todays programming. Right now i have job in economic field, and I'm really happy with it. But I'm the type of person that likes to build. Been making music for 10 years now electronic. Concept of making something for technology is so thrilling, and to get payed for it. Just wow. Been practicing programming for the past 40 days every day for minimal 4 hours. Hopefully I'll reach your lvl guys.
&gt; flatMap() out an Optional Oh, that does sound really handy!
I see your point
&gt; don't throw exceptions for things that can occur fairly commonly &gt; like this. How common a situation is has nothing to do with whether or not it is exceptional. That's not what exceptional situation means, at least as defined by Josh Bloch in Effective Java. Bloch was referring to using exceptions for flow control, such as using `ArrayOutOfBoundsException` as a termination condition for a loop. Loop termination is not exceptional situation, and making it exceptional obscures the logical termination condition of the loop, effectively terminating the loop with a nonlocal goto. &gt; the same mistake the Java devs did when they made &gt; Integer.parseInt and the like throw a NumberFormatException This is actually the proper use of checked exceptions as described by Brian Goetz in the link I provided. One use of checked exceptions is to provide alternate returns. The ordinary return value of `Integer.parseInt` is the parsed integer. An alternate return is `NumberFormatException`, if the passed in string is not parseable as a number. This is not using exceptions as flow control because `Integer.parseInt` is not obscuring any flow control logic. Thus, this is a perfectly reasonable exceptional situation, as per Effective Java. &gt; it's easily manipulated by end users and generating a stack trace &gt; is relatively slow How slow? In agree that using exceptions should not be used in a tight inner loop executed millions of times. But, the cost of network IO and database access dwarf the cost of checked exceptions. Are you sure that checked exceptions in this case would make any noticeable difference to performance?
Don't do that either, see the other reply to this comment. 
In the article example, the author tries to make clear that this should normally not happen, only in exceptional situations, but does a poor job explaining it. With proper use, one would do a query first to get a list of blog IDs and only use getBlog(id) with an ID that was returned before. If somehow an ID is passed referencing a non-existing blog, this demonstrates improper use of the API and then it's okay to throw an unchecked exception. This could happen if someone manually edits a REST URL parameter or something like that. And we don't have to be especially nice to people who do that. :) If you go the Optional-route, I usually prefer a name like "findBlog(id)" instead of "getBlog(id)". For me, get means you will get the thing whereas find means you may or may not find what you were looking for. I know the Java APIs have a bad track record with getThing() returning null though.
&gt; I believe (as in "don't know for sure") that the Optional class wasn't primarily meant to be used as a return value but as an argument in situations where varargs can't or shouldn't be used. The article: &gt;Brian Goetz, Java Language Architect at Oracle, explained the reasoning behind adding its inclusion: “Our intention was to provide a limited mechanism for library method return types where there needed to be a clear way to represent “no result”, and using null for such was overwhelmingly likely to cause errors.”
&gt; doesn't get rid of the necessity to make an absence check With `map` and `flatMap`, the absence check is abstracted away, which allows `Optional` to be used for [null-safe traversal](http://www.oracle.com/technetwork/articles/java/java8-optional-2175753.html). &gt; Optional class wasn't primarily meant to be used as a return &gt; value but as an argument in situations where varargs can't or &gt; shouldn't be used. Actually, it's the opposite. You shouldn't use `Optional` for missing arguments. For that, use method overloads.
This is nonsense. Some methods must return "null" and their JavaDoc (API) must explain why. example: String address = person.getAddress(); // returns null if the person has not got an official address. String id = person.getId(); // returns always non-null a unique string 
My take on it has always been that Optional is fantastic for use at boundaries - such as returns from libraries or even separate modules. It's not so much that they're more convenient than null checks but rather that they enforce expectations. I don't see much utility in using Optional within private/protected methods of a given package.
A manager I worked for had this elaborate framework for returning nulls that weren't nulls. He -hated- nulls.
agree concern is smaller, but still :)
&gt; this should normally not happen, only in exceptional situations, &gt; but does a poor job explaining it. As per Josh Bloch (see the link in my comment, written by Brian Goetz), the OP's reasoning is sound. Not finding the blog is an exceptional situation, as in a deviation from the primary return value, and the checked exception serves as an alternate return. But, that's not what `IllegalArgumentException` is for.
Documentation is a poor way to enforce constraints. `Optional` leverages the type system to more reliably indicate an empty return value, and gives you null-safe traversal as a reward. Also, nothing "must" return null. That is a choice.
Are you disagreeing with Brian Goetz and Josh Bloch?
I think you're missing the point here. At some point someone will call that method, forget to check if the value can be null and you'll end up with a fun little NPE later on. By making that method return an Optional, you force the developer to explicitly address the fact that it's possible for the return value to not be present. Let the compiler work for you instead of hoping everyone reads the javadoc.
No. Effective Java item 57 is "use exceptions only for exceptional conditions". Edit: I hadn't seen your other reply. Interesting.
I don't know jetty too well (have used it as embedded servlet container in the past though). AFAIK Jetty sticks closer to the servlet API, which puts some limits on API flexibility and concurrency details. Correct me if I'm wrong here. I just immediately liked undertow's direct API and undertow also scores well on performance comparitions, offers reverse proxying, websockets etc. AFAIR at time of decision, servlet API's async servlet spec was crippled (improved with 3.1, 3.0 was unusable). Probably Jetty does all this also well, I really don't know .. can you add info ?
Are you sure you know what Josh Bloch means by "exceptional conditions"?
Yes, that I agree with. I think an unchecked exception is better here, because normal API usage should not result in the exception being thrown. Regardless, `IllegalArgumentException` is a poor choice, you would even be better off using `IllegalStateException`
&gt; because normal API usage should not result in the exception &gt; being thrown That entirely depends on what "normal API usage" means If the API says I will return a `Blog` for an id, but if I can't find one, I will throw an exception, neither `IllegalArgumentException` or `IllegalStateException` are the proper choices for that exception. Both of these runtime exceptions indicate programming errors. `IllegalArgumentException` indicates a precondition violation by the caller, while `IllegalStateException` indicates that the program is in an undefined state. Both of these exceptions indicate that it is not safe to continue. If the API cannot return a `Blog`, the program is not in an invalid state and can easily handle the exceptional condition. Thus, in normal API usage, it can throw a checked exception at the proper level of abstraction, `BlogNotFoundException`. On the other hand, *if you define the precondition* as the id must exist, then I can see the case for `IllegalArgumentException`, but I am not convinced that this is a good precondition because it makes the API *very* sensitive to input values.
Like me and my love for chaining.
The whole Optional type seems like a retarded idea to me. All it does is add a second type of null for us to check for. It was stupid in F# and stupid in Java. The only place it makes sense is in languages that have non-nullable reference types.
Mine has the opposite affliction. "Found 701 matches of return null in 133 files."
&gt; This is nonsense. Some methods must return "null" and their JavaDoc (API) must explain why. &gt; example: String address = person.getAddress(); // returns null if the person has not got an official address. This **is** exactly the use case, where returning ``null`` is considered harmful! I think you haven't understood the whole problem yet!
I worked on a big website written like that in Java. It was a nightmare, because any time data was missing, sections of the site would silently not show. There were no error messages or anything, so everything relied on human inspection to figure out whether all the things that were supposed to be there actually were present. And pinpointing exactly where data went missing required lots and lots of searching to find the problem. Yes, nulls expose bugs, but a lot of the "solutions" basically just obscure the bugs, or require you to write more code than before without really guaranteeing anything. Option doesn't force you to check whether the value is there, it just tells you the value might not be there.
You don't "check for" `Optional `. If you are, then you are using it the wrong way. `Optional` is a so called "monadic type", whose effect is to abstract away the check for missing values entirely, giving you null-safe traversal with `map` and `flatMap`, which is more powerful and generic than the elvis operator.
&gt; where there needed to be a clear way to represent “no result”, and using null for such was overwhelmingly likely to cause errors.” This I think is a sane rationale. They're not saying "always use null where there might be no value." They're saying "weigh the pros and cons and *then* decide."
If you using `map` on a non-list you're doing something wrong.
That is only true if you think `map` should only apply to lists, which seems like a silly restriction for a generic mathematical concept.
Clearly, it means conditions that require exceptions...
I'm also thinking of the performance hit versus simply performing a simple null check. Using Optional already creates excessive garbage to account for the wrapper. Now you're adding a function call that wraps a function call? It's like the goal of the game is to make Java as slow as possible.
Newbie here, wouldn't returning an immutable empty collection leave you with the same problem of having to check every time you expected a mutable, non-empty collection?
You can create a microservice by embedding a container like tomcat and jetty into your application too, then it runs as a standalone jar (that is all Spring Boot is doing).
You're assuming that use of `Optional ` will create excessive garbage. The `Optional` type is a single member type that is unlikely to escape to the heap (since you shouldn't *store* an `Optional` value - it is a pure return value). The JIT is very likely to stack allocate the `Optional`, and since it only has one member, can even avoid allocation altogether, by hoisting the single member into a register. The JVM is an old dog that can still learn new tricks.
Java EE 7 itself supports asynchronous processing: http://docs.oracle.com/javaee/7/tutorial/servlets012.htm#BEIGCFDF 
The answer to every question in programming is "It depends"
&gt; String address = person.getAddress(); // returns null if the person has not got an official address. You actually proved the point. In out project we decided to pretty much always return an optional for values that might be absent. Much better.
null values are easily the most performant solution to represent the concept of a missing value. If you use nulls, you have to check before assuming it has a value. This check is several orders of magnitude more efficient than allocating memory for Optionals or other object-based replacements. It's true that programmers get lazy and forget to do the null checks. Language support for operators like ?. are helpful, but ultimately this boils down to the programmer taking the necessary steps to ensure he type checks nullable values. While the constant emphasis on code "smells" and high-level abstractions makes null checks seem undesirable, ultimately you have to choose who your end customer is... the user (where performance is important) or other developers (where code prettiness is important). 
The same problem exists with Optionals. If there's a method that returns an Optional, you have no guarantee that it's not actually returning a null in some cases. Some languages may indeed enforce the capability to return a non-null, but Java is not one of them.
Documentation is often the ONLY way to enforce constraints. Especially when working with code that is not written by you or exposing code to 3rd parties. Are you going to complain that their API returns null instead of Optional and rewrite it or just read the docs and deal with it? After working with Scala for two years where Optionals where returned everywhere in lots of well known libraries I would want nothing to do with that ever again. You basically end up null checking multiple times throughout a call chain or return an Option when you know the value is not null.
NumberFormatException is bad because it is a checked exception. Instead NFE should be an unchecked exception and the SDK should provide an Integer.isNumber() or Integer.isParseable() method that you can use to make sure you have a number before sending it to Integer.parseInt().
Do you have a page or a GitHub repo that demonstrates this? I'm struggling with a JVM backend/typescript/react/webpack frontend and the build solution right now is frankly terrible.
While the engineering feats that the JVM goes to in an effort to mitigate the wasteful designs of the Java API is impressive, it in no way changes my opinion. Though I do love the BS about is being "just a return value". So what? We're supposed to check for nulls when reading from a field and wrap them, just to unwrap them on the other side of the getter? Needless inconsistency or wasted memory and CPU cycles. Not a great choice.
Option forces you to deal with the possibility of data not existing yes. But that doesn't mean it can't be used appropriately to handle error cases (like data should be there). for example, in your case, a person might've been using ```orElse``` to return a default value when it wasn't appropriate. ```orElseThrow``` would allow you to throw an error in the case of no value, if that's what you needed. null is not an appropriate answer. Improper usage of types like optional can obscure bugs, but null itself can too since it can leak out of your methods if you don't do anything with the value that triggers a NullPointerException, and it is strictly inferior to Optional in any case where performance isn't absolutely paramount. edit: Actually, after having thought about it more, usage of null wouldn't have made your situation better as you claimed. For you to get the stack trace/error you wanted, the designer of your website would've had to not handled the possibility of a lack of data, which by your own admission they did. They just didn't handle the lack of data appropriately, which null can never save you from while adding additional risk of error as opposed to an optional type
Sounds consistent. Atleast you have a clear way of checking for a successful return by null checking that is predictable through the code base. 
The real answer is non-nullable reference types. But because C# is getting them Java isn't allowed to. (see value types, properties, events, etc.)
&gt; The JIT is very likely to stack allocate the Optional, and since it only has one member, can even avoid allocation altogether, by hoisting the single member into a register. Do you know this to be true, or are you simply hand-waving away the concern about unnecessary memory allocation?
&gt; The JIT is very likely to stack allocate the Optional, and since it only has one member, can even avoid allocation altogether, by hoisting the single member into a register. Do you know this to be true, or are you simply hand-waving away the concern about unnecessary memory allocation?
But if as you say, throwing an IllegalArgumentException makes the API way too sensitive, then that applies to any exception if it is considered a reasonable work flow, in which case returning a null equivalent and checking it would be a lot easier to code and read than try-catching. 
I agree with you that `IllegalStateException` and `IllegalArgumentException` are bad choices here. I'm not sure that a context-specific exception is necessary, however. Since we're talking REST here, wouldn't the better approach be to return a more general `ResourceNotFoundException`? This should translate into a 404 (or similar error code if not communicating over HTTP) being returned to the calling client.
you're prematurely micro-optimizing
&gt; NumberFormatException is bad because it is a checked exception. That is a tautology. You are saying it is bad because it is bad. &gt; Instead NFE should be an unchecked exception and the SDK should &gt; provide an Integer.isNumber() or Integer.isParseable() method That would be useful. &gt; you can use to make sure you have a number before sending it to &gt; Integer.parseInt(). That doesn't explain why it is *bad* for `Integer.parseInt` to throw a `NumberFormatException`. `Integer.parseInt` cannot return a value if the number if the input is not parseable, but it is not a fatal error. So, according to Java principles regarding exceptions, it throws a checked `NumberFormatException`. This is only *bad* if you think checked exceptions are bad, which is clearly a matter of debate.
&gt; it in no way changes my opinion That's just your opinion, man. &gt; We're supposed to check for nulls when reading from a field and &gt; wrap them No. You have code somewhere that produces a value, such as by reading from a `ResultSet`. This may produce no values. However, you need still need to return *something*. You could return `null`, and then expect your caller to check the result value. But because *all* references are nullable, that would mean that caller would have to depend on the API documentation or put defensive `null` checks everywhere. Or instead of returning a bare `null`, you could wrap it so you can leverage the type system to help your caller out. So, instead of returning `null`, you can return `Optional`. And since the `Optional` type is composable (unlike `null`), you don't have to check *every* single return value, and let the `Optional` type itself handle the null checks and short circuit logic. &gt; Needless inconsistency or wasted memory and CPU cycles. Penny wise, pound foolish.
There is a huge difference between "micro-optimizing" and simply establishing design patterns that are efficient by default. 
I'm basing it on the fact that the JIT constantly performs optimizations, so what code will perform well on JVM is often [counterintuitive](http://www.oracle.com/technetwork/articles/java/devinsight-1-139780.html). One of the optimizations the JIT does is escape analysis, so it can [stack allocate](https://www.ibm.com/developerworks/library/j-jtp09275/index.html) if heap storage isn't necessary. So, you can't make blanket statements as /u/grauenwolf did. Take my word for it, or Brian Goetz's.
If you work with people who can't guarantee a method with a return type of Optional is not returning null, then you should find a new job. Final variables + optional types = impossible to return null unless you are violently incompetent.
&gt; You basically end up null checking multiple times throughout a call chain or return an Option when you know the value is not null. You're doing it wrong.
You've got a point so that specific word I cheerfully retract, still I think you shouldn't design the code to be more error-prone at every call site, in favor of maybe being slightly faster.
This is kind of dumb-ass stuff is exactly why Java added escape analysis. According to this documentation, only single-member objects can avoid heap allocation. (Making escape analysis a lot less useful that one would hope.) https://docs.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html
How's that any different than guaranting a non-optional function doesn't return a null unless it was specifically designed to? The odds of accidentally introducing a bug is basically the same.
How does Optional force the developer to handle it?
Not necessarily. So lets say you call a method that returns a Collection and then you want to iterate over that collection and perform some calculation on each entry. If you attempt to iterate over a null collection you will get a NullPointerException, but if you try and iterate over an immutable empty collection, the code will just skip over the iteration logic and continue. List&lt;String&gt; emptyCollection = Collections.emptyList(); for (String derp : emptyCollection) { //Doesn't print anything and continues System.out.println(derp); } List&lt;String&gt; myNullCollection = null; for (String derp : myNullCollection) { //Throws NullPointerException System.out.println(derp); }
That is a matter of API design. You could create a `ResourceNotFoundException`, which is like `IOException`. Or, you could create `UserNotFoundException` which is a subtype of `ResourceNotFoundException`, in case you want to write a generalized error handler at the REST layer. I personally don't like too much action at a distance. I don't mind catching a `UserNotFoundException` at the top-level and translating that to a 404 response in the REST controller. It's less "magical". But that's just me.
If it adds more code, then your old code probably wasn't sufficiently handling the nulls to begin with.
If `Optional` actually made it less error prone I would change my opinion. But it does nothing to prevent non-Optional functions from returning null so it doesn't actually change anything.
At least in that situation, the error is obvious (no two ways about it: If you return null in a method that returns Optional, you're doing it wrong. If you fail to check for null after a method call, maybe you're not doing something wrong). It's something that's easily caught in review and only has to change in one place. It's like if you have `for(int i=0; i&gt;size; i++)` versus `for(int i=0; boundsCheck(i); i++)`. There's nothing syntactically stopping either from being wrong, boundsCheck could easily be defined as `i&gt;size`, but `i&gt;size` is clearly wrong and a call to boundsCheck seems fine.
No, not really. You're talking about *accidental* nulls, which also should not happen unless you are lazy or incompetent. This post is about *intentional* use of nulls because the method represents a partial function. In that case, the Optional type makes it a total function which leaves only the accidental case. And again, if you can't avoid accidental null values, there is a much more fundamental problem you need to address. Caveat: if you are referencing a lot of shit code from other people using nulls, then of course it's easy to be lazy and not check them all, but *that is why they should be using optionals too*. If *you* are creating an Optional, though, and you can't guarantee it will not be null, then, again, that's is just an incredible level of incompetence. If you write final Optiona&lt;String&gt; result; Then use result = Optional.ofNullable(someValue); There is no way you can create a null Optional and the code won't compile if you don't assign the variable since it's final. If you screw that up, you need to get your shit together.
&gt; the user (where performance is important) That is not representative of all users. First of all, performance is *relative*. How does the performance of `Optional` compare to IO performance and database performance? Second of all, unless your user is counting cycles for some kind of HPE application, the small difference in performance due to `Optional` is not even likely to be noticed by the user. After all, there are plenty of successful Rails apps. More often than not, users are more interested in faster delivery and more features and less bugs. So, given that most performance problems in line of business apps are IO bound, you'd likely get a bigger bang for your buck optimizing the performance of your database and improving your data access patterns. Also, if something like `Optional` reduces bugs, it's well worth the small price. Furthermore, we're talking about Java here. You can't take performance of *Java code* at face value, because it is running inside a JVM which performs [a number](http://www.oracle.com/technetwork/articles/java/devinsight-1-139780.html) of [optimizations](https://www.ibm.com/developerworks/library/j-jtp09275/index.html).
I don't know so much about Node.js. I was told by a consultant/friend that is very easy to implement a scalable platform with node.js ...comments on that?
To clarify NFE has to be a checked exception right now because there is no way to check if a value is parseable as a number. If there were methods to check to see a number was parseable then NFE could be an unchecked exception. As it stands now NFE is frequently used for flow-control because there is no other choice. When you are forced to use an exception for flow-control there is something wrong with the design of the functionality surrounding it. That design problem is the lack of methods to check if a value is a number. BTW, Groovy has an isNumber() method on String and it is very handy
&gt; If there were methods to check to see a number was parseable then &gt; NFE could be an unchecked exception. An unchecked exception, by the exception model in Java, means that the program is in an invalid state and it is not safe to continue. A parse failure is not fatal. &gt; As it stands now NFE is frequently used for flow-control Why should you not use exceptions for flow control? Flow control is like the termination condition in a `for` loop or a `while` loop. The condition tells you whether to repeat the loop or exit the loop, controlling the flow of the program. It is critical that this condition is obvious, so you can understand how the loop works. As Josh Bloch describes it in Effective Java, using exceptions for flow control is like using `NoSuchElementException` as a way to terminate a loop. You are depending on an error condition and a non-local goto to exit the loop instead of checking `hasNext()` on an iterator. This makes the flow control of the loop completely non-obvious. Also, `NoSuchElementException` indicates a fatal error, because the iterator has now become invalid and is no longer safe to use. If you call `Integer.parseInt()` and get a `NumberFormatException` because it was not possible to produce a result, is it not obvious what happened? The program is still in a perfectly good state, because `NumberFormatException` isn't fatal.
The `select` system call has a lot of flaws and was replaced by more efficient APIs a long time ago (e.g. epoll, kqueue). It is an old and outdated API and should only be used as a fallback if modern alternatives are not available. Just because `Selector` sounds similar does not mean it works the same way. Java NIO `Selector` is a portable abstraction that maps to the most efficient API provided by the runtime. On most systems it will be *way* more efficient than `select`.
Not normally. Usually you get a collection to iterate over it. If it's empty then you won't iterate. It's like 0 results in a search. It's not an error. 
anything you want.
&gt; Take my word for it, or Brian Goetz's. who the fuck are you? I mean, if you want to make an appeal to authority you could at least establish authority for yourself, or reference the relevant supporting statement made by Brian Goetz. Take my word for it, or St. Thomas Aquinas'
&gt; who the fuck are you? *Exactly*. Which is why I referenced Brian Goetz, the lead architect of Java. 
Go to https://projecteuler.net/ and start solving them using Java -- Java can solve math problems. Or if you are into graphic games, try make some games, such as tetris, minesweeper, or whatever game idea you may have. Java can make games. Asking what a programming language can do is the wrong question. Instead, ask what problem you want to solve. Nearly all languages are able to solve all problems, and they are more common in how they solve the problems than the difference in their looks.
If you can't be bothered to null check method returns from Java code written by other people, then maybe you are the one who should find a new job.
Do you like video games ? you can create one, do you like apps?, you can create one, do you like to spy girls? you are a pervert, do you like IA?, you can create one, do you pharmaceutics systems? you can create one. With Java and other languages as C, Kotlin, C++, C#, GO, python you can create everything (Depend of you, time and budget), some has better communities as Java has, but i can confirm you, the Java communities are very strong and collaborative. 
I wouldn't call the difference close to zero. GC pressure is a very big issue in Java and often ignored since it doesn't show up in benchmarks as clearly. If almost every function call now has an extra allocation, I would call that a major problem.
Ok, I think I see. Other things that would cause an error, like adding to the collection, should be done by class methods anyway, right?
&gt; you have no guarantee that it's not actually returning a null in some &gt; cases. You don't need a guarantee. Simply don't check for `null` with `Optional`. Any library that returns a `null` value for an `Optional` type has put the program into an invalid state and the `NullPointerException` that you get is the exactly the correct behavior. Fortunately, `Optional` is used in chains, so you will be able to identify the buggy library.
I *love*... no, I really **love** how everyone who wants to dismiss ugly but efficient Java code with JVM optimizations. I mean, I love the link where Brian Goetz basically says, "write inefficient (dumb) code and let the JVM optimize, because the JVM is better at this then a C compiler." Unfortunately for that line of reasoning, there are real examples viewable on YT of significant performance advantages by writing ugly code based on optimizing the data structures rather than hoping the JVM can intuit what you want to do.
Fortunately I can be bothered, and will then nicely wrap them up with Optionals to make life significantly easier for everyone else. If you don't think that's a good thing to do, then you're a bad coworker! 
Yes. Programmers often are not good at realizing that, however, and tend to think in black and white only.
Can you prove that `Optional` causes GC pressure? Can you prove that every function call involving `Optional` now has an extra allocation? Remember, `Optional` is a pure return value, it should never be stored anywhere.
&gt; Well, any tips? Feel free to make suggestions, I'll look them all up. Thanks. Check out the sidebar of **/r/learnjava** where your question would actually belong
Right. If you get the list from somewhere else, then mind your own business and don't try to manipulate it. If you need a different list, make it yourself. 
I think you may have completely misunderstood what Brian Goetz saying. He was saying that you're better off writing simpler, "dumb" code than wasting time prematurely optimizing based on preconceptions of how you *think* the code will perform based on your intuitions about C. Java does not have the same execution model as C, and Goetz elaborated on some details of how the JVM execution model can improve the performance of "dumb" code. That does not mean you *should not* optimize Java code. Of course you should. But that should be based on *empirical* evidence gathered by a *profiler*, guiding optimizations to where it is *most profitable*. A perfect example of this is prematurely avoiding `Optional` in favor of faster, but more dangerous `null` checks, simply because in C, `malloc` always allocates memory. However, the JVM may not always allocate memory when you call `new`. Especially with `Optional`, which is supposed to be used as a return value, the JVM can perform escape analysis to determine that heap allocation is not necessary.
&gt; Option forces you to deal with the possibility of data not existing yes No. You can just call Option.get and be on your merry way. &gt; But that doesn't mean it can't be used appropriately to handle error cases Of *course* it can be used for that. That's not in dispute. &gt; null is not an appropriate answer As the designers of Option noted (quoted elsewhere in this thread), that depends on the question. Sometimes null is better. &gt; the designer of your website would've had to not handled the possibility of a lack of data, which by your own admission they did Not really. There's a big difference between having the core classes (the data access layer, basically) knowing to return NullObject and having the rest of the code base (much bigger) deal with that correctly. &gt; null can never save you from while adding additional risk of error as opposed to an optional type Neither saves you, really. If the data can be missing then you need to do *something* to handle that. What *something* is varies. `map` can make this easier in the case where it's enough to do nothing if the data isn't there (although `map` in Java is ugly), but it doesn't remove the problem. Sometimes you need to do something else when the data isn't there. Yes, Option can help by signalling that the data might not be there. It can also help via `map`. But it doesn't make all the issues disappear. And there are other ways of approaching this. Kotlin, for example, has a different approach. Personally, I feel the solution is worse than the problem. I never use Option and I very rarely see NullPointerExceptions in my code. In well written, well tested code this isn't that big a deal, really.
While use cases will definitely vary, I don't think I have ever had a user reported performance problem that was resolved by something as simple as using nulls. If you are in a situation where that matters, you probably are not representative of most Java developers. Also, just an anecdote: I have been working on rewriting a lot of code which was written to optimize by doing things like using nulls, making everything mutable, using arrays instead of lists, and other things that, on paper, are the most performant way to do things at a micro level. By using optionals, immutable data structures, higher level data structures like lists, and other "non performant" things, I have actually increased performance because the resulting code can be written in a much clearer, simpler way which is less algorithmically complex (and I suspect easier for the compiler to optimize). Of course, you can do both, but it has been my experience that when people worry about micro optimizations, they tend to write themselves into overly complex code that is impossible to maintain and is less performant as well. 
Because if you have an Optional&lt;String&gt; and need a String, your code won't compile. You have to make a conscious decision about how to handle the optional to get a string. You can still *choose* to just call .get() then have a ton of exceptions thrown, or you can *choose* to do it properly with map, flatMap, etc. The key part is that you *have to actively choose what to do* or your code simply does not compile. With nulls, though, you have to have the discipline to always check for nulls, because the passive option is to not check and the code will compile without a complaint. EDIT: I.e., it doesn't force you to handle it *correctly*, but it does force you to *address* the issue. 
I use Optionals all the time but I rarely return them from methods. I handle default / error states as early as possible then pass around the non null value. If you pass Optional around everywhere its unclear wether its empty or not.
I can just as easily pass the static values into a constructor and have a static singleton of the class wired up. This is still technically DI just without a DI framework and is just as testable.
It shouldn't need to be clear, which is why I say you're using it wrong. For example if you have: final Optional&lt;String&gt; maybeString = ... Then you should use it as: return maybeString .map(someLogicWhichReturnsAValueFromAString) .flatMap(someLogicThatUsesThatValueAndReturnsAnOptionalOfSomeKind) .map(someLogicThatDoesSomethingToCreateYourFinalValue); And if you take this to its logical conclusion, you don't have to address the missing value until you are ready to extract it from the final optional. Of course, other Javaisms make this full picture difficult, but the idea is that, as much as possible, you should not be worrying about whether the values actually exist or not. If it *does* matter that much, then I suspect you have gone astray by abusing side effects, or something else which is the real problem. Also, if the Optional is too weak, you may need to upgrade to some thrid party libs like functionaljava so that you can use an Either type, or something else.
its mentioned in youtube sub .. here: https://github.com/RuedigerMoeller/InstrinsicReactJSX don't hesitate to feedback .. there are probably still minor issues as this part of kontraktor is new 
&gt; No. You can just call Option.get and be on your merry way that's still forcing you to deal with the possibility of non-existent data. if you decide "i'd like to blow my foot off! please let me!" is how you want to deal with it, that's on you. null doesn't give you that chance &gt; .Not really. There's a big difference between having the core classes (the data access layer, basically) knowing to return NullObject and having the rest of the code base (much bigger) deal with that correctly. if the other parts of your codebase cannot handle NullObject they shouldn't accept it. Theoretically, NullObject should be it's own type which inherits from the the same type as your NonNullObject type to allow that differentiation. If your NullObject is just a special constant you've already lost the game and committed a similar error as using null. &gt; Neither saves you, really. If the data can be missing then you need to do something to handle that. What something is varies. map can make this easier in the case where it's enough to do nothing if the data isn't there (although map in Java is ugly), but it doesn't remove the problem. Sometimes you need to do something else when the data isn't there. i said as much. Optional doesn't save you from improperly handling the lack of data, but it doesn't expose you to as much risk as null. &gt; Yes, Option can help by signalling that the data might not be there. It can also help via map. But it doesn't make all the issues disappear. And there are other ways of approaching this. Kotlin, for example, has a different approach. &gt; Personally, I feel the solution is worse than the problem. I never use Option and I very rarely see NullPointerExceptions in my code. In well written, well tested code this isn't that big a deal, really. If all your code was well written and well tested then you wouldn't need the higher level abstractions java provides. Or C++. Or C. Or assembly. We have those abstractions because they make it easier to write correct code. Likewise, Optional makes it harder to make mistakes resulting in NPE. You say you very rarely see NPE in your code? I haven't seen them in ages, and when I do see them, they come from outside my codebase. Because I never use null (with the rare exception of hot loops and other things that need to be extremely performant or lightweight). Your typesystem is automatic tests done for you at compile time. By using optional, you are making your codebase better tested. It cannot solve all problems, but neither can type systems. That doesn't mean either are worthless. **tl;dr**: we've chosen statically typed languages for a reason. it's cause we want the type checker to help us. so help it help you. give it information. null gives it no information. Optional does.
Related playground (with runnable code samples): https://tech.io/playgrounds/491/avoiding-null-anti-patterns 
/r/javahelp
 Blog blog = null; long id = blog.getId(); // NullPointerException &gt; Calling a method on a null reference will throw a NullPointerException Uhm, no shit sherlock. if(blog != null) { /* do stuff */ } Solved.
I know, but this is quite bare and isolated (and there are issues in some implementations of that spec). I use this in my servlet adaptor to bridge servlet-world to kontraktor's actor-world. The nasty thing with synchronity is, that's its infesting. An async servlet is of limited use if any other API (EJB remoting, File IO, Cache API, JDBC, ..) is synchronous. Also Java 7's Future is flawed (it's sync). Doing async without actors is really error-prone (callbacks always come inside a different thread, have to synchronize on context data). Java 8 adds some useable API here (CompleteableFuture etc.). Jee needs a major overhaul, I doubt they get this done (especially as many people still have not fully understood implications). I cannot understand why API's are defined snychronous in the first place because: * any asynchronous API can be made synchronous by adding a simple wrapper (just await result blocking), **BUT** you cannot make a synchronous API asynchronous later on (except with creating 1000's of threads) 
&gt;ever had a user reported performance problem that was resolved by something as simple as using nulls. It makes little impact but it and everything else that kind of mindset entails adds up. On your anecdote, it sounds like you did way more than the non-perfomant things. Because everything you mentioned will decrease performance. Also I often find it amazing the optimizations that the compiler *doesn't* make (at least for dotnet). So I doubt it finds it easier to optimize. 
&gt; It makes little impact but it and everything else that kind of mindset entails adds up. Which is why you surely use assembly. &gt; it sounds like you did way more than the non-perfomant things Which is why I explicitly addressed that fact. &gt; So I doubt it finds it easier to optimize. I'm curious, how are you checking to see what optimizations it makes? If you're not checking the binary code caches in the runtime, then you probably have no idea what the compiler is optimizing.
&gt; that's still forcing you to deal with the possibility of non-existent data. if you decide "i'd like to blow my foot off! please let me!" is how you want to deal with it, that's on you. null doesn't give you that chance No, `Optional` doesn't do anything useful, it just pollutes your code. If you're dumb, you will still be getting NPE left and right. `Optional` doesn't make sense at all. The proper solution is to improve compiler with inference which will block usage of possibly null variables without `if` checks. And optional annotation for manual null handling for some rare edge cases for library developers. Basically, you shouldn't be able to compile NPE-prone code, but you should be able to use nulls freely to your benefit when it makes sense. Existing solutions like `Optional` are useless crap.
Since this is help with *Java programming*, it should be, as the *plenty hints* on the page indicate, posted in **/r/javahelp**. Yet, before posting there, please *read* the [**Posting Guidelines**](https://redd.it/48eykt) there. You need to show your code in order to get help. **Post removed**
As I stated above, `Optional` doesn't solve anything in reality. There are different ways to solve the problem and `Optional` is the worst.
actually, removing the get method from optional and removing null from java would achieve the same effect you just described without all the work you just prescribed to fix the problems with null. the way null works in java is as a pseudo bottom type with an instance (really fucking bad idea), and compiler inference isn't gonna save you from that. it might help your code, but it doesn't help you with other people's, while optional does. even kotlin's solution is to just treat all data coming from java-land as potentially null unless it's specially annotated.
As you stated incorrectly, yes. I ignored your claim, though, for obvious reasons.
&gt; And if you take this to its logical conclusion, you don't have to address the missing value until you are ready to extract it from the final optional. I would prefer to address the missing value as soon as possible rather than ignoring it until the very end and then going backwards to figure out where it was missing. Do you propose it's ok to pass Optionals as parameters as well?
You are the reason why smallest Java apps eat 100MBs of RAM on start-up for no freaking reason at all and continue growing.
Actually, my Java apps all tend to run quite small, and I am actually the guy who *fixes* the memory leaks created by prior colleagues who were more concerned with "performant" code.
&gt; I never use Option and I very rarely see NullPointerExceptions in my code. Optional isn't just about saving you from NPE's, it's a nice syntax for driving execution paths based on data being present or absent. Great for you that you don't take advantage of a language feature, but other people will continue to find it very useful. I suppose you prefer Arrays over Lists and never get an ArrayIndexOutOfBoundsException either...
Right, but that's often only necessary to do because of how the code is written in general, not as an inherent property of the problem to be solved. Also, like I mentioned, there are beefier, but similar, types like Either that let you get a result or some other data that you might need to fix a problem. I personally never see any use for Optionals as parameters.
Every cycle counts today. Shitty desktop apps like Slack can reduce laptop battery life by 50% just by running in the background doing nothing visible to the user. Think about smartphone users too. We depend on batteries in our daily life and while our smartphones can do loads of calculations in a snap, the battery drain is insane. Every cycle counts! Yeah, I know, premature optimisation is the root of all evil, but if you learn the habit of choosing correct tools for the job instead of some fancy new crap, you won't need to investigate why your users hate you in the future. Learn about the most efficient tools for the job and use them. Make it a habit.
&gt; I personally never see any use for Optionals as parameters. This was actually the bigger problem I had with Scala. Now wether you use Optional or null is partially personal preference and also partially dependent on the use case. If I have a UserDao object I don't want every single call of findById to return an Optional. 95% of the time I already have the id and know for a fact the user exists. In this case I would just let it hard error whenever there is some unexpected scenario and null check the few scenarios where I know a user might not exist. Another option is just to have two methods. One returns an Optional and one expects the object to exist which you can call when you know the user exists.
You haven't worked with deeply nested objects. Doing this stuff over and over makes your code needlessly big. 
&gt; It was a nightmare, because any time data was missing, sections of the site would silently not show. Well stated, everything in your response is spot on. Not related buy Lombok sucks too.
I am not sure how you are missing the irony of claiming every cycle counts while discussing a feature in a language that runs in a virtual machine and has to be dynamically compiled to native code just to get something similar to native performance. 
It is also one certain way bugs slip past QA, see larsga's response.
This can't be emphasized enough, good design usually trumps micro optimizations by quite a large margin. Most applications are not day trading algorithms.
&gt; it's a nice syntax for Personally I really dislike it.
I guess it doesn't force them to handle it, just acknowledge that the value isn't necessarily present. If they want to do Optional.get() without checking if it's present, you can end up in the same situation as if that method returned null. The difference with optional is that the developer has to explicitly ignore the fact that value can be missing.
don't optimize before you've found the hotspots in your code. a 2x speedup in code consuming 0.1% of your runtime just means your program has eliminated 0.05% of it's original time usage. a 2x speedup in code using 95% of your run time is a massive speedup in comparison. using null in code that takes up .1% of your runtime doesn't help compared to using optional. using null in code that's taking 95% of your runtime makes sense though. write correct, bug free code first, then optimize it to get fast, bug free code.
When QA sees an empty list it doesn't look like an error. When the customer see the same empty list; you will now have one irate customer. That is worse than a null which tells QA immediately that there is a problem _before_ it slips into paying customer's hands. Edit: Optional is for lazy programmers, not good software; anything else is rationalization, not justification.
That was my thought reading this article. OP makes his case best simply by strength of the features of returning what he calls a "null object" (blank template version of the object) or using exceptions. ... but when he's actually shooting to make his case at the start of the article, he (and Tony Hoare, inventor of the null ref) seem only to be dancing around the idea that checking for null isn't, like, OOP-y enough for their stylistic sensibilities. Then all the way at the bottom the very good argument is slipped in of cases where null can mean multiple possible outcomes, but again, I'm not sure I'm seeing a direct connection between problem and prohibition. I think overall the article contains some good advice but with a lot of framing errors in how it's presented such that it somewhat undermines itself.
JVM performance today is extremely close to native performance unless you write some crap. It is a great alternative to native code when you don't require absolute performance at all times and JVM allows CPUs to sleep properly when idling, which is the reason why Electron is a bad choice for apps which run idling for long periods of time and Java is OK IMHO. Java is good for some types of apps and bad for others. Election can also be good for some things. My point is that one should choose the tool which is right for the problem.
The point of using optional is to remove the need for null in your code. period. that goes for library creators too. If you're using null instead of an Optional type, you should consider it a code smell, and you better have a damn good reason for doing it (such as you're optimizing an incredibly hot loop where Optional would cause too much cpu usage and gc pressure).
Why is QA checking return values instead of doing end user testing? We have people testing our code who have no idea what an Optional is before it gets to a customer. Maybe you need to study up on writing safe code and on how to test code in QA.
Good! I approve!
So, what you're saying is that not every cycle counts, actually?
you realize you can just use .orElse or .orElseThrow the second you get an optional right? There's no obligation to keep your data inside the optional... I get that you don't like map, but how is ```String y = optionalString.orElse("hello");``` worse syntax than String y = "hello"; if(nullableString != null) { y = nullableString; }
&gt; It's true that programmers get lazy and forget to do the null checks. The funny part is that Optional does nothing to resolve this. You *still* have to explicitly check for a value. Otherwise you'll call Optional.get() and it'll fart out a big NoSuchElementException. But thank *god* it's not an NPE!
Well, it doesn't really matter how the final solution looks like, but NPE-prone code should not be compilable in the first place.
Lmao
&gt; No. You can just call Option.get and be on your merry way. You're not really supposed to do that, and the method name makes it seem like a safe method to call. There are [discussions](http://mail.openjdk.java.net/pipermail/core-libs-dev/2016-April/040484.html) about deprecating that method because Oracle realized it was a bad idea including it. API design is hard, let's go shopping! &gt; Sometimes null is better. When used internally. Optional is recommended when it is likely that returning `null` will cause errors. That's why `Optional` is exclusively meant as a return type. &gt; NullObject I am not a fan of the Null Object pattern. Having things mysteriously not work because you return something that looks like an ordinary thing but doesn't act like an ordinary thing seems like a recipe for disaster. Fun fact: in Obj-C the `null` value is a universal Null Object. You can actually send messages to `null` and the program will silently continue. Scary stuff. `Optional` is a far superior solution to the Null Object pattern because it doesn't look the same as a normal value. &gt; If the data can be missing then you need to do something to &gt; handle that. The `Optional` object is a monadic type, which abstracts a particular effect, namely short circuiting on an empty value. This gives you null-safe traversal, which is what 90% of null handling usually is. If you need to do something else, `Optional` offers other methods for that purpose, such as `orElse`. And it integrates well with null-safe traversal. &gt; I never use Option and I very rarely see NullPointerExceptions in &gt; my code. This is definitely a YMMV situation. If `null` handling was not such a big deal, why are there so many bugs related to null values? Perhaps the plural of anecdotes is not data? Personally, I kind of like checked exceptions instead of `Optional`, since Java was designed for it. The usage patterns of `Optional` are more functional in nature, yet the existence of lambdas doesn't make Java a functional programming language. But I would rather return `Optional` if I could instead of `null`.
agreed. sadly null is a curse on us all. 
Well, you do realize that if nullableString is null, this will throw an NPE, right?
/r/learnprogramming is more suitable for these types of questions. 
&gt; Option forces you to deal with the possibility of data not existing No fucking way. The lazy implementation of the calling code will just do option.get().someMethod(). 
you're right, fixed. Another reason null shouldn't exist :p tbh, i'm more used to scala, where == and != are used for object equality, not referential equality
&gt; you realize you can just use .orElse or .orElseThrow the second you get an optional right? Assuming that works for what you are doing. Sometimes it does. &gt; how is String y = optionalString.orElse("hello"); worse syntax than I think the option does better there, but you could have gone String y = optionalString != null ? optionalString : "hello" which is about the same.
as i said to someone else, .get is asking to get shot in the foot. You do it maybe once or twice before you figure out that ```option.orElse(defaultVal).someMethod()``` is relatively as easy and doesn't put you at risk like .get(). also, get is safer than null anyway, cause if the Optional is empty, get throws an exception. null can leak away from the context of where it originated TBH, get shouldn't exist on optional, but oh well.
It signifies to the client code that a value needs to be checked, as opposed to nullable values which can be a mystery. That's one big advantage
&gt; Documentation is often the ONLY way to enforce constraints. Documentation doesn't enforce constraints, it only documents them. &gt; Are you going to complain that their API returns null Why would I complain? I can either just deal with it or wrap it with `Optional.ofNullable` if I want null-propagation. &gt; You basically end up null checking multiple times throughout a &gt; call chain You're doing it wrong. &gt; return an Option when you know the value is not null. You don't need to return `Option` if you know that the value is not null. I don't know about Scala, but if you're sure that the value is not null, do `.orElseThrow(IllegalStateException::new)`. This way, if you're right, the program continues on its merry way. If you're wrong, then your understanding is wrong and the system is in an invalid state, and the program will fail loudly.
Right, but that would be just another way of writing (retVal == null ? defaultVal : retVal).someMethod(), so you gained nothing, the calling code still has to handle the case.
&gt;Assuming that works for what you are doing. Sometimes it does. i've not run into a situation where the orElse equivalent in scala hasn't worked for me. then again, i'm not averse to map &gt; I think the option does better there, but you could have gone you're only backing up my point. your example is syntatically about the same, but if you forget to do it it's not a compile time error, it's a run time error. my example is caught at compile time if you forget to do the song and dance.
&gt; I would prefer to address the missing value as soon as possible &gt; rather than ignoring it until the very end Then do it. The big win with `Optional` is `map` and `flatMap` which give you null-propagation, which is a very useful pattern for traversing a chain of objects which can have missing members. However, `Optional` has other methods as well. &gt; Do you propose it's ok to pass Optionals as parameters as well? You should never, ever do this. `Optionals` are a return value only.
no, if I forget ```.orElse``` it's a compile time error. if you forget your ternary test, it's a runtime error. There's a huge difference in a bug that's caught for sure at compile time versus one that might not be triggered for a while in runtime.
&gt; If I have a UserDao object I don't want every single call of findById &gt; to return an Optional How many `findById` methods can you possibly have? Don't most finder methods return collections? And I would rather have an API that returns optional or throws a checked exception rather than return null (I prefer checked exceptions, but that's a different story). I don't want to rely on what I know for a fact to be true, because I'm human and I am often wrong.
Yes, but what it doesn't do is signify that all of the non-optional functions don't need to be checked.
The java.util package has 342 references. Map.get(), Matcher.group(), Scanner.findInLine() to name a few Java is a language that uses null to represent missing values. You can use Optional in your code if you want. But don't pretend it leads to some future where you don't have to worry about nulls. For that, you need to change languages.
No it's not! You *can* call `get()`, and get a runtime error. 
If the application is designed well, you should be able to infer that.
and we've been over this, you have to consciously choose get. and when you do, you get your hand slapped quick and painful enough to learn not to do it fairly quick. tbh, having get as part of optional was a massive mistake on the java designer's part, especially since they had scala as an example, but oh well. meanwhile, it's super easy to forget to do an if check. that's why NPEs exist in java codebases still. also, despite get being shit, its runtime error is still better than NPE cause it will always point right at the offending .get call. a null value can escape from the context that generated it
Try to stay clear of nulls as much as possible when designing and you will be fine. Things like early validation, DDD and NullObjects will help you. Or just use Options or Maybe's 
Yes, but if somebody else already did that and it works, it's better to use it
Maybe you should to the JavaScript world where long term maintainability isn't understood. See how we can all be uncivil as easily as civil.
It gets tiresome seeing people try to make Java a better functional language. I wish they would just try to make Java a better Java. Maybe then we could get some new, interesting, and useful constructs as opposed to poor transplants from other languages that don't fit the paradigm well.
Well then, can't you agree that you have to consciously choose to check for null before you use the returned value in the same way? I don't get why it should be easier to remember calling `orElse(default)` instead of null checking. It's the same thing, with another syntax. 
And I have to add that I agree that if it would be named `getIfPresent()`, maybe more imbeciles would notice what they were doing.
I'm often the person called in to make code perform better after someone like you has "modernized" the code. I work in FinTech where we tend to care greatly about performance and reducing GC along with the proper algo are usually the first two things to look at. Poor use of data structures is usually right up there too (arrays are almost always better than linked list and hash tables are overused). Anything that increases GC pressure for marginal gain is something i would probably only allow at API boundaries not internal to a package.
If it's well designed, I should be able to infer whether or not a function is capable of returning a null without `Optional`. The problems arise when nulls slip into code accidentally.
returning empty collections instead of null is fantastic advice, using optionals is pretty meh. I don't think they add much value. Just ffs put in your java doc if you'll be returning null. (not that it's bad, but it's nice to document) I guess it's good practice to always check, but I'd like to be able to trust the documentation. 
no, cause you can forget to check for null. it's much less likely to forget to use ```.orElse``` in lieu of ```.get```, cause the errors caused by get reinforce it's bad. as for why it's easier to remember calling ```orElse(default)```, if you don't call something the compiler yells at you. it doesn't yell at you for using a possibly null value without checking it
&gt; I work in FinTech where we tend to care greatly about performance and reducing GC along with the proper algo are usually the first two things to look at. Yep, there we go. You work in an incredibly niche part of the industry that requires correctness, simplicity and performance way beyond the majority of developers. I.e., &gt; While use cases will definitely vary Most developers are working on applications whose demands are nowhere near those in FinTech, which is why you probably get paid 3 or 4 times what the average dev does.
I think it's time for a microservices implementation of Enterprise FizzBuzz. If I just had the time :) edit: [someone delivered already](https://github.com/domdavis/fizzbuzz)
 https://youtu.be/rX0ItVEVjHc?t=1h18m 
&gt;[**CppCon 2014: Mike Acton "Data-Oriented Design and C++" [87:46]**](http://youtu.be/rX0ItVEVjHc) &gt; [*^CppCon*](https://www.youtube.com/channel/UCMlGfpWw-RUdWX_JbLCukXg) ^in ^Science ^&amp; ^Technology &gt;*^183,801 ^views ^since ^Sep ^2014* [^bot ^info](/r/youtubefactsbot/wiki/index)
You don't actually. In my code, Optional.isPresent() and Optional.get() are rarely used at all, but my code is still much safer because of map, flatMap, orElse, etc.
Well, the codebases I've seen lately tell otherwise. In a fucking backend service: public void persist(data) { for (ValueObject v : computeValueToPersist(data)) { db.save(v); } } private Optional&lt;ValueObject&gt; computeValueToPersist(data) { // compute, or not } edit: Made more clear.
I'm just getting into Reactive programming and immutability, one thing I've wondered is how do you deal with things having references to the replaced list. Do you not reference the data structure directly and instead reference Observables?
except if your method returns java.lang.Void
That's a little bit like saying static typing is useless because casting exists.
Better not doing real time or firmware.
Because HTTP is a synchronous request-response protocol (at least HTTP 1.x, obviously changing in 2)
Well, you can't return an Optional on an external API because in the infinite wisdom of Oracle, `Optional` isn't `Serializable` :/ I understand they didn't want it to represent fields of objects, but still. Now it's completely useless for `Serializable` channels.
Plus, a quick check on the Composite shows a wrong way of implementing it : - http://java-design-patterns.com/patterns/composite/ - https://en.m.wikipedia.org/wiki/Composite_pattern#Structure Litterally, if you don't have a `Leaf` and a `Container` abstraction all deriving `Node`, then composite is as useless as class Stuff { Collection&lt;Stuff&gt; children; // May be initialized, contain stuff - or not ;) }
Non-Mobile link: https://en.wikipedia.org/wiki/Composite_pattern#Structure *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^107059
i'm not sure i'm seeing the issue here? for each syntax means the code within the for is only executed if the optional value is defined edit: wait, no. I thought this might work like scala, but I get a compilation error. what exactly are you trying to do with this code?
Good bot
Thank you Android487 for voting on youtubefactsbot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
`findById` kinda implies singular results (because most IDs are unique). just saying... i just wanted to jokingly pick that out. no dog in the fight about `Optionals`.
That's like saying static typing is useless because Java allows you to cast. If you deliberately switch off the safety, aim a gun at your foot, and blow it off, then I don't think that's a surprise - and doesn't mean that safeties are useless.
Tried to make it more clear.
Generally sure, but embedding tomcat into an application is a trivial exercise of just a few minutes. Not worth the effort of learning yet another framework to accomplish it.
Problem is that foreach won't accept the input you're giving it, as per [this](https://ideone.com/oFGwg2), so i'm still not sure what this code is supposed to do. is the problem that they're using Optional to say whether or not they did the computation?
I don't believe that analogy holds up. Optional isn't like turning on a safety, it's just like changing to a gun with a different grip. How you handle it is different, but little else is. With optional, you still need to check for the presence of an object before interacting with it, just as you would a null. public void Thingy(Vehicle myTruck){ if(myTruck != null) { myTruck.vrooooom(); } } becomes public void Thingy(Optional&lt;Vehicle&gt; myTruck){ if(myTruck.isPresent()) { myTruck.get().vrooooom(); } }
http://www.oracle.com/technetwork/articles/java/nilsen-realtime-pt1-2264405.html
Good to know, but the code still compiled, since they had their own implementation of Optional, because they were using a JVM from IBM with version 1.6, which did not supply Optional itself.
But the original article made it appear as though using Optional would somehow relieve you of the duty of handling the "no result case".
i mean, it's not a bad idea to allow it. An optional is easily convertible into an iterable (and could be considered one in which you either have 1 or 0 elements). in which case, the code above only executes the code within the for each loop if the optional has a value, which is safe behavior. [here's a scala example of this](https://scastie.scala-lang.org/z0MYlpGnQjKoy70W3umv4g)
Great contribution. Like mine.
Here's the implementation: [pastebin](https://pastebin.com/rgPjdhnL) Right, only executes when the optional has a value. But where I come from, `backendService.persist(data)` doesn't just silently return when something goes wrong. I agree this is not Optionals fault, but the one from the user, but you could say that Optional made it pretty easy to hide that something went wrong, instead of being upfront with an NPE!
&gt; How many findById methods can you possibly have? Just two, one for when you know (have high confidence) there should be a value and one for when you know its optional. If you return an Option every time and 90% of the use cases expect it to be there you are essentially deferring the empty / null check all over the rest of your code. Thats what I meant by multiple null checks. If you use null you can only check it in the few cases you know it can be null (yes this is absolutely error prone but not really the end of the world) or go with the two method approach one errors when the user doesn't exist and the other returns an Optional. In my experience when Optionals are often the return type the code gets littered with things like. User user = userDao.findById(1L).orElseThrow(new UserNotFoundException); User user = userDao.findById(1L).orElse(null); User user = userDao.findById(1L).get(); So now we force the callers to use the Optional but since they are lazy we end up with tons of the above examples littered throughout the code. The worst part is they are inconsistently handled so sometimes its an Optional exception, sometimes custom, sometimes a null pointer. It still comes down to the discipline of the developers and code reviewers.
I'm more concerned about JetBrains tools being used as an attack vector by a state actor. A state actor with few scruples could use leverage on their own citizens to introduce backdoors, time bombs, and the like via the tool. I'd be happier if there was an independent build of IDEA available that had been audited by someone that I trust. 
Spot on!
As in the null object pattern or Optional type?
Programming languages themselves are pretty much interchangeable. The language you choose usually depends on what frameworks and libraries you want to use. *Typically* you favor C and C++ for game programming or systems programming because most of the best frameworks for those things require you to use them. And so on. Learning a framework is more important than learning a language, but it's also very hard to anticipate what framework an employer will want, compounded by the fact that they go in and out of style relatively quickly. So, the important thing is to demonstrate an ability to learn new frameworks/dev environments. If you can, ideally, try to have a couple projects on your github that use frameworks, and use different frameworks.
Isn't there a non null attribute that can apply to packages now?
To your last point, most people actually prefer unchecked exceptions as checked ones force a ton of boilerplate and make for some really odd acrobatics dealing with them properly.
The quote in your post was about how Optional forces you to deal with the possibly missing value - though there is a backdoor you can use that's usually considered ill-advised. This is just like how static typing forces you to deal with the type of a variable - though there is a backdoor you can use that's usually considered ill-advised.
And that backdoor looks so innocent that it spreads itself like floodwater over the codebase.
Bullshit. Even code monkeys messing around with VB 6 could easily figure out that allocating unnecessary memory is bad for performance. This isn't super complicated micro-optimizations, it's just basic hygiene. 
Rust has a true zero cost optional. C++ is close to zero. Java could have a close to zero implementation too if either: 1. The call site can be inlined and the allocation elided from escape analysis. 2. In the future if value types can be used. However the JVM works hard to elide null checks and I hope Oprional doesn't impact that. (The only way Rust has zero cost is because of a hack to allow a special zero value in a tagged union to not take any additional space.)
Memory pressure issues don't appear as hot spots. It's a systemic problem where no one allocation is a problem, but the sum total of them drags everything down.
That doesn't seem to address my analogy at all. The point is that just because there's an ill-advised, unrecommended way to circumvent a safety feature doesn't meant that it has no value. Almost every safety feature in every language has some kind of "backdoor" that lets you switch it off, yet as Java developers we explicitly choose to use a language that strongly emphasizes safety with things like static typing. Optional forces you to handle the optionality of the variable at compile time unless you explicitly switch off that safety by calling `get()`. Static typing forces you to handle the type of a variable at compile time unless you explicitly switch off that safety by casting. All proper use of Optional does is make Java consistent, in that nullability becomes as much a part of the type system as stringability or intabilitiy, fixing a problem which used to temporarily turn Java into something as safe as Python. BTW, your Optional code is very unidiomatic - no use of `map`, and passing Optional as a parameter. Might want to fix that. ;)
&gt; A perfect example of this is prematurely avoiding Optional in favor of faster, but more dangerous null checks I'm not convinced that a null check is somehow safer than a slightly different null check. 
Sure, there might be an argument to be made that the naming was bad. IIRC, there is a debate right now about deprecating `get()` and possibly replacing it with something like `unsafeGet()`. But I'd note that to a Python developer, casting can look pretty innocent. It takes some time for people used to dynamically typed languages to get used to statically typed conventions (don't make everything Object, don't cast, etc.) This might just be a case of people learning that calling `get()` is just as safe as doing `String string = (String) someObject;`
Actually, to put things in their proper context, `ResourceNotFoundException` would be better utilized as a `RuntimeException`. `IOException` has a different set of meanings. As you suggested, you could get more granular by extending `ResourceNotFoundException` by more detailed exceptions such as `UserNotFoundException` or `BlogNotFoundException`. However, this level of granularity is typically discouraged and unnecessary. The context of the exception is already known since you know what method is being called (e.g. getUser() or getBlog()). If additional information about the cause of the exception is needed, that's what the `message` property is used for.
You're not allowed to use logic to refute fallacies. :-)
I totally agree! But I also follow the rule that I use Optional or empty Collections / Maps when I write a public method that is part of an API. Being explicit in code is better than writing a Javadoc comment that could be ignored. And allocating Objects in the JVM is really cheap. So I don't care.
More the prior than the latter, I think. Basically it would treat classes like structs and have default values for everything, so that when it showed up on the UI or something the strings read "Missing Value" or somesuch nonsense. Made testing harder because you had to knew which magic strings to look for.
I agree. Name it so the alarms go off, and hope that then it'll be used with more caution. But still, the question remains if if (opt.isPresent()) doSomething(opt.unsafeGet()) is safer, or much clearer than if (opt != null) doSomething(opt); 
Why do you say that using "Optional.isPresent()/get()" isn't quite right?
&gt; You work in an incredibly niche part of the industry that requires correctness, simplicity and performance way beyond the majority of developers. It's actually even more narrow than that. Trading algorithms is a very small part of FinTech, most stuff in FinTech doesn't need to think about performance at all.
Because it's not just that but atleast: `String y = Optional.ofNullable(nullableStr).orElse("hello");` Which is just too roundabout compared to checking it already: `String y = nullableStr != null ? nullableStr: "hello"` 
I don't give two hoots what his title is or where he works. &gt; using null for such was overwhelmingly likely to cause errors. That is the whole point. It's a huge stop sign that says stop now, report/fix this!!! 
Needs an else case, otherwise proponants will argue with "less LOC"... public void thingy(Optional&lt;Vehicle&gt; myTruck) { // please lowercase this is not C# ;) myTruck.ifPresent(Vehicle::vrooooom); } (In Java 9 there would be `ifPresentOrElse`) 
&gt; Optional forces you to handle the optionality of the variable at compile time unless you explicitly switch off that safety by calling get() Null forces you to handle the nullability of the variable at compile time unless you explicitly switch off that safety by directly calling. They're the same thing. Just handled two semantically different but functionally identical ways.
Yes! Stop returning null... when the contract of a function could not be met. This is asking for trouble: Date getDateOfBirth() { try { // get date of birth from database } catch (IOException e) { return null; } } It will force all callers to check for null. Let the exception run its course. If you catch a checked exception calling the database and do not want to expose it, wrap it and rethrow it: Date getDateOfBirth() { try { // get date of birth from database } catch (LibraryDefinedException e) { throw new RuntimeException(e); } } I do not want to start a discussion on the issue of check vs unchecked exception. This post is about null. The exception raised when dereferencing null is unchecked and does not need to be declared in function definitions. OTOH, DO return null when the requested information is not present, and it is appropriate that the requested information is not present. // will return null if user did not enter a value Date getDateOfBirth() { ... } As in: "The field on the UI is not mandatory, and user did not enter anything. The client said that the software cannot require date of birth, because DOB is not always known when the employee record is created. Sometimes managers hire people and forget to ask the DOB. Employees should be in the system before they can work for insurance reason, but the person has already started and cannot be reached 7PM because they are on a remote location with no phone service. User has to create the record now, to minimize the employer's exposure in case they get injured." This happens in real life software. Source: been writing business software for 25+ years. Sure, you could return some kind of null date object with reasonable defaults. Some callers would have make sure to check for that object, and react accordingly. Except, ~~if~~ when they forget, the code will fail silently. Silent failure is still failure. I see null used as a return value when the requested operation could not be performed: String getFullName(Person person) { if (person != null) { return Person.lastName() + ", " + person.firstName; } else { return null; } } This is wrong, and is one of the source of evil in programs (not programming language). Writing it this way forces the caller to account for null in the return value, and results in null checks in all layers of the application. Rewrite this any way you want, using all the syntaxic sugar and constructs you want, it will never be as short and clear as the correct implementation: String getFullName(Person person) { return Person.lastName() + ", " + person.firstName; } If person is null, let the exception occur, and catch it in application layer of the application where you can do something about it. If person can be null, let the code that knows the context provide alternate value: String getOwnerName(Car car) { return car.owner != null ? getFullName(car.owner) ? "No owner"; } That switch could be performed in the getfullName method, but it would no longer when you use it like this: String getHolderName(Passoprt passport) { return getFullName(passport.holder); } in the later case, it does not make sense to have a passport that does not belong to someone. Null password.holder is an error, and should be handled as such. A car in a dealer's parking lot can be there for maintenance, in which case it would have an person owner, or owned by the dealer, no person owns it. Sometimes, null object or empty collection is the right approach: Set&lt;String&gt; getUniqueCommentwords(Post post) { return post.comment != null ? splitIntoWords(post.comment) ? Collections.emptySet(); } If no-one has commented on the post (since post.comment is null), no words were used. Sorry for the long rant. Appropriate error and rare condition handling is is critical in large software but not always understood properly. Also, there are no solutions that will fit all needs. 
Yes. And they are very difficult and time consuming to fix when people have the mentality that allocation is free because it becomes so widespread in the code. Recently i had a project that it wasn't even fixable. It would have taken so much work that it was better just to rewrite it.
What bothers me is that it isn't hard to avoid excessive allocations, yet far too many so-called professionals think its some sort of scary micro-optimization. Count the number of times people equated basic memory hygiene to assembly programming in this thread. Hell, you often end up writing less code at the same time so its a win-win. 
I never said that DI is a framework. DI is a principle. So you are just validating my point. Because if you do what you say, this is what I suggest, you don't need the singleton design pattern then at all :-)
And?
No one said it isn't bad for performance. Using a JVM is bad for performance. Using a high level language is bad for performance. Using an OS is bad for performance. A lot of things are bad for raw performance, but that still doesn't mean that the loss in performance is relevant. 
There's a difference between being bad for performance and being bad for performance without any gain.
I beg to disagree. Documentation is the only way to enforce constraints where the language can't. So I could have a method that returns an "int" and some documentation that states that it will always be non-negative. And crucially, devs could work on that assumption.
Then I guess it's fortunate that Optional types provide a lot of gains re: safety!
Actually, in some languages optionals have 0 memory overhead and compiled to the equivalent of an = null check.
Pretty much every modern IDE feature matches that description, right?
Bikeshedding. Endless bikeshedding.
&gt; What is PostgreSQL? This post is really for *everybody*, right?
Lol wasn't trying to suggest select should still be used, jut reminiscening. 
How is that *enforcement* in any meaningful sense of the word?
There is no substitute for actually writing code when learning how to code. If you are using a good book and are unsure of a concept it is talking about or an example it is showing then definitely code it and make sure you understand what the code is doing and why. Put extra effort into learning Java data structures and collections, you will use them everywhere. 
&gt; throwing an IllegalArgumentException makes the API way too &gt; sensitive If we take `IllegalArgumentException` as a programming error (constraint violation), then the API seems like it is very prone to failure. Plus, you're not getting any help from the compiler, so you had better really keep up to date with the documentation. &gt; then that applies to any exception if it is considered a reasonable &gt; work flow Except where the checked exception is seen as an alternative return value, advertised (and enforced) through the type signature. &gt; in which case returning a null equivalent and checking it would be &gt; a lot easier to code and read than try-catching. I disagree with that. The catch block neatly separates out error conditions from normal flow. try { return Response.ok(messagesRepository.findMessagesByUserId(userRepository.findByUsername(username).getId()))); } catch(UserNotFoundException ex) { return Response.code(HttpStatus.NOT_FOUND); } catch(UnauthorizedException ex) { return Response.code(HttpStatus.UNAUTHORIZED); } vs. User user = userRepository.findByUsername(username); if(user == null) { return Response.code(HttpStatus.NOT_FOUND); } return Response.ok(messagesRepository.findMessagesByUserId(user.getId()); Unfortunately, because `findByUsername` returns `null`, I have to declare a variable just so I can check the return value. Hope I don't have to chain this, that's going to be a lot more variables and a lot more if statements... Wait, why am I getting HTTP 500 responses? Whoops, the `UnauthorizedException` is an unchecked exception, so I guess I'll have to add `catch` here. I guess I'll have to either put catch blocks everywhere or hope that every method throwing `UnauthorizedException` is well documented. Maybe my web framework has a global exception handler, I guess it'll have to be generic or I have to put logic there...
&gt; Sure, you could return some kind of null date object with reasonable defaults. Some callers would have make sure to check for that object, and react accordingly. Except, if when they forget, the code will fail silently. As an example, if your `post.comment` method returned an `Optional` then your implementation would be: Set&lt;String&gt; getUniqueCommentWords(Post post) { return post.comment.map(splitIntoWords).orElse(Collections.emptySet(); } The compiler will not ^([1]) allow you to get hold of the contents of the `Optional` without also writing code which handles the possible emptiness case. And that's kinda neat. Sure, with `null` it's perfectly possible to write correct code, as you've done. It's just harder. &amp;nbsp; ^([1] assuming you're disciplined enough to never call `.get`.)
&gt; would be better utilized as a RuntimeException This would prevent static enforcement of handling alternative returns. At least as far as Java orthodoxy is concerned, RuntimeExceptions are better utilized for unrecoverable program errors that should be allowed to bubble up the call stack. &gt; IOException has a different set of meanings. Well yeah, of course. It's a different exception. I mean *like* `IOException`, in that it covers a wide range of errors. &gt; However, this level of granularity is typically discouraged and &gt; unnecessary. Unless you want to carry additional information related to the error. Especially if you are separating layers and want to convey additional details from one layer to another. But again, exceptions can be appropriate to the level of abstraction required. &gt; that's what the message property is used for That is a string. Hopefully you aren't suggesting that layers higher in the call stack *parse* status information from lower in the call stack? 
On the contrary, avoiding null reduces incidental complexity and leaves you with more to spend tackling business problems rather than tracking down entirely preventable bugs. If 1) you are genuinely concerned that these short-lived object allocations are going to kill your performance, and 2) you have this concern over more than one or two isolated inner loop cases, then your mistake started when you chose Java.
I wish I could give you another gold. &gt; ultimately this boils down to the programmer taking the necessary steps to ensure he type checks nullable values. This seems to be too hard for some people apparently, hence articles like this. I suppose the old adage is true; it's hard to find good help.
A few random thoughts: * Forgetting to test for `null`. * Not understanding how to copy a list (or any other type of reference object). * Copy/pasted code. * Poor class, variable, method names. * Inconsistent code style (formatting, names, etc). * Lack of abstractions / lots of procedural code (methods/objects that do too much). * Doing too much in the constructor (JDBC calls in the constructor, for example). * Spaghetti code (globals; lots of static crap). * Poor exception handling. * Failure to update documentation after a code change. * Not writing unit tests. * Gets offended during code review. Not really in any order, and there's a lot more I could write but you wanted code-specific things so I tried to limit myself to that area. These are just what immediately came to mind. Are you looking for specific advice or feedback?
&gt; Reactive Programming Is this a new term or something? It seems awfully similar to [event-driven programming](https://en.wikipedia.org/wiki/Event-driven_programming). Is there a difference or is it the same thing, just a different name?
This is so true - the more I've used optionals, the less I've used isPresent() and get()
Not so long as non-optional reference types are still nullable.
I think the argument is that a get() by itself could throw an Exception - rather than checking that yourself, count on the battle tested helper functions built into Optional &gt; Optional&lt;Integer&gt; key = crud.findValue(); &gt; &gt; if (key.isPresent()) { &gt; crud.clearValue(key.get()); &gt; } I would argue that a much cleaner approach would be: &gt; findValue().ifPresent(crud::clearValue); The same could be said if you're trying to map() or flatMap() objects
don't project your character onto others ;)
they are fake, ok? scala = total losers
You sound like a Brexiteer - "now that'd we're no longer tied to Brussels, we are free to trade with the world!" Exciting!
Tangentially related - coming from someone who largely does embedded work and mostly writes procedural code, how do you avoid it? To be honest the OO paradigm has always been vague and fuzzy at best in my head. It's just not at all how I think about a computer working so it's never really clicked. 
But but, Play supports Java, and everyone and their mom knows that Kotlin has _seamless_ Java interop.
that's going to be the next generation Scala
Number one, reimplementing stuff that already exists in the standard API
I'm graduating next semester and I'm going back through past code projects and cringing. I started thinking about my current code and I was wondering if I'm still coding like a novice. I'm in the process of building a github account that showcases my experience, and abilities. I want to check over what I have up and the stuff I put up later
For large code bases with lots of developers, I'll take safety over performance any day.
I'll just be over here writing my safe code while you tell me it's not safe.
Everything. Literally. Desktop applications, web applications, web services, embedded software, real time applications, daemons / services, video games, databases, you name it. Here's a random list of the more interesting applications I have worked on in the last 20 years with Java: * controllers for robots (not toys, warehouse stuff) * stock trading system (real time, high-performance app) * video games (2d and 3d, both single- and multi-player) * relational database system (client-server app) * chat / file sharing system (peer-to-peer app) * point-of-sales system (cash register, product catalog, etc)
&gt; Number one, reimplementing stuff that already exists in the standard API Yeah, I am not sure why that didn't come to mind. But that is also a good one. :)
&gt; I'm going back through past code projects and cringing I have a problem with perfectionism. That may not be a problem in and of itself, except that there is no such thing as perfect code. You would think that after slinging code for 20 years, I would stop caring about code quality, but for people like me, this never goes away. Something to think about. :)
They ask about a problem and say something like "I'm getting an error" instead of saying exactly what the error is. It's a sign they still think of error messages, stack traces, and the like as incomprehensible and meaningless.
&gt; With optional, you still need to check for the presence of an object before interacting with it, just as you would a null. This is not true.
What exactly does this mean? 
&gt; coming from someone who largely does embedded work and mostly writes procedural code, how do you avoid it I typed up my response fairly quickly, and didn't give much thought to how I worded things. I did not mean to imply procedural code is bad and should be avoided in Java. I should have just left it at "Lack of abstractions". That's a bit more what I was thinking when I wrote that. I have a colleague who is primarily an RPG programmer (IBM System i). She maintains a Java program that is a few thousand lines long. It's *all* in `main()`. This is an extreme example of what I meant by that bullet point. I am a very pragmatic programmer. I don't view OO as the end-all, be-all of software development. While Java was designed to be an OO language, there are many patterns that we use in software development with Java that are not OO, and that is ok. Sometimes, a healthy balance of object-oriented, functional, and procedural programming creates a better system. Knowing when and where to strike that balance comes with time and experience. After 20 years, I am still learning and that will probably never change. :)
You want books? There are [plenty to choose from](https://www.reddit.com/r/java/comments/6pvfw8/the_best_java_books_picked_by_rjava/). My specific recommendation is Effective Java by Joshua Bloch. It's a bit old, but it has held up well and is highly recommended by many Java developers. I heard rumors of an updated edition coming soon, but haven't heard much more than rumors.
Do people seriously not make use of @Nullable?
* Code not in proper package but e.g. top-level. * Multiple top-level classes in single source file. * Comments are only about what code does rather than why.
That's debatable. 
I worked on a project as a contractor on an application where the entire team had a serious hate for `null` as well. They wrote their own static analysis tools to literally fail a build if anything returned `null`. I wish they had left it at that, but they took it a step further. We were writing Java 5 at the time (I think? When did we get generics? 6?) and they wrote their own version of `Optional` as well. Trying to figure out what the damn return types were was a nightmare as `Optional#get()` returned an `Object`. :/
This means that Oracle NetBeans will become Apache NetBeans. We don't know how much effort will Oracle put in Apache NetBeans in the future.
Non-sequitur much?
Writing lots of unhelpful comments. Writing imperatively not object oriented. Bugs. Not clarifying requirements. Not pushing back when something is a shit idea.
Or asking how something works or why it does not work, instead of just reading those 20 lines of code, looking at the source of the exception, finding usages(code references) and trying to understand it.
* Trying to be fancy/overly terse/unique. * Writing untestable code. * Only testing "happy" cases. * Complaining about style guides / linters Writing code is the easiest part of the whole job. * Coming up with designs that are flexible enough to deal with unforeseen changes in requirements is hard. * Maintaining existing code is hard, especially when whoever wrote it the first time was trying to be fancy instead of expressive. * Changing code that doesn't have reasonable test coverage is hard. * Understanding a codebase when style changes from file to file is hard. The first point is the one of those hard things that we can't fix by coding one way or another. The rest (and many more) are fixed by good code hygiene, consistent code style, good testing, and all those other development practices that new programmers (including myself long ago) feel like just get in the way of velocity.
&gt; Typically you favor C and C++ for game programming or systems programming Right, but Rust and Go Lang usually are a better fit.
Failure to update documentation? You have documentation? The code is the documentation? Unit tests are for the weak. What is poor exception handling, and what is good? Testing for null, should be using optional.
&gt; Lack of abstractions / lots of procedural code (methods/objects that do too much). The other side of this is over-engineering or optimizing for a use case that is extremely unlikely to ever be needed. (which I've seen a lot from talented junior devs)
Lots of good answers here, but I'll throw in "debugging through guesswork", due to lack of knowledge about how to hone in on a bug using a debugger.
Hah, yeah I completely agree with you. The funny thing is, I see a lot of very experience software developers going way overboard with abstractions. Sometimes that can actually be worse! :)
YouTube didn't exist when I started programming in Java. I checked out books from the local library and read them, followed along, etc. Eventually went to college and the Computer Science courses taught programming with C++ and Java, so I gained a bit more that way. Mostly, just writing endless amounts of software just for the practice, even if it was useless. For example, the first application I ever wrote was written with VB3 (or 4; can't remember) and all it did was convert Celsius to Fahrenheit in a basic GUI. I wrote lots of these crappy little apps just to try and learn something new.
Dynamic tabbed layouts where tabs are spawned containing the FXML of a separate FXML file was surprisingly stupid to complete. When I did the same thing in C# I don't even think I had to do a Google search on how to do it, it was straightforward. Also, extending controls to exhibit custom behaviour is not exactly trivial.
The only comments on the code are related to the stackoverflow question they were cut and pasted from, and bears little relevance in the use-case that code was applied to.
Writing catch more than you write throw.
[Programming by coincidence.](https://pragprog.com/the-pragmatic-programmer/extracts/coincidence) 
As a side project, I've been back-porting all the functional stuff to jdk 6 by looking at the source code in open-jdk 8 and the jdk 1.5 branch of guava. Because I have no experience with functional programming and I'm stuck on jdk6 at work anyway. I've learned quite a bit including about 100 non-optimal ways to do things. I'd say reimplementing existing tools may be a sign of inexperience, but it's also a sign of someone on the right track, if only because they will have the experience of their implementation sucking, and will be in a better place to understand why the existing implementation works better (unless they turn into grognards who think their version is superior and refuse to grow...)
https://www.reddit.com/r/java/comments/6w04dz/how_did_you_learn_java/
If you go out and read all the current best practices and attempt to follow them all, you are pretty likely to over-engineer. I have a terrible memory, so I try to have extremely small classes with very narrow responsibility, because I sometimes lose my mind's eye of my own code. For sure, this leads to over abstraction. Like a lot of my classes have 10 or fewer functions that each have 10 or fewer lines of code - when it gets to the point where I have trouble using my own code... Time to break that shit up. Yet I've realized some very real benefits when I've had to do some major refactoring, and the code is pretty resilient. So limited regrets. I know people look at my 50 hierarchal packages and think it's shit, but I look at their 2000 line monstrosities and feel the same.
Yeah, what is going on here? It’s pretty much entirely ignored in this thread.