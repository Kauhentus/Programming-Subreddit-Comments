What the article misses out on is "Except just ignore all the default panes that Java ships with and use MiGPane instead because it isn't crappy."
Head First Java
JavaFX literally comes with the capability to do this. https://docs.oracle.com/javafx/2/charts/jfxpub-charts.htm Ditch swing.
Guava retrying doesn't require java 8 either.
You *will* pass implementations. But you shouldn't specify that a method HAS to work on an ArrayList -- would it be wrong to call it with a LinkedList? Usually not. You can specify that you need a List, or a Set, or a Map, or something more specific, like a SortedMap. There are plenty of cases where you'll specify some concrete implementation class, too. It's just a very obvious "code smell" when a method takes an ArrayList instead of List. Similarly with arrays: I say "stay away from them" because newcomers, especially from C and C++, are prone to overusing arrays. There are a lot of cases where an ArrayList is faster, easier, cleaner, and more correct. Of course, it uses an array "under the hood", but that's the point: use the abstractions to make your life easier. You'll get more done and generate fewer ArrayIndexOutOfBoundsExceptions.
Same here, so "oracly"
No, the statement after it meant that it integrated nicely (And so does guava retry I imagine if it followed standard java convention).
That was just about the worst introduction to anything that I've ever had the misfortune to read. Nothing was explained, and it raised more questions than it answered. And as it answered precisely no questions, that's no surprise.
I've written better graphs in JavaScript, but what kind of animation are you looking for?
As a former VB'er turned JavaScripter (before the Node hipster revival, yes. I just said I did JavaScript before it was cool and then claimed not to be a hipster. YOU CAN'T JUDGE ME) and eventually Rubyist I came to Java after JDK 8 because I needed to build a service that would be rock solid and was really, really pleasantly surprised by the Steam API. It feels Ruby-esque in chaining code together and made for some pretty tight code. I'm overall pretty excited about the direction the platform is going. Looks like there's a future where it's not all horrible Xml configuration nightmare. Maybe.
hello, I have Dietel &amp; Dietel Java book it is really great book but I am looking for Junit which the book does not cover. Can you suggest another book that covering Junit. 
I have learned to use JUnit from some tutorial and took it from there. If you ask me to suggest a book, I would go with [Manning's JUnit in Action](http://www.manning.com/tahchiev/). Again, I have no first hand experience with this book in particular but I've never got a book from Manning's In Action range that I wasn't happy with.
Maybe they purchased a bigger oracle database
If ANT doesn't work for you then just use something else. Saying there is no excuse to use ANT today is simply incorrect. It still works fine for a lot of people.
Try jfree.org. JFreeChart is pretty comprehensive. At jfree.org here, http://www.jfree.org/jfreechart/faq.html , at the bottom of the page they will link you too alot of other charting and graphing alternative libs as well.
You can choose any from following list : 1) Java : A beginners's guide by Herbert Schildt (most up-to-date, covers Java 8) 2) Core Java Volume 1 9th Edition Cay S. Horstmann (covers till Java 7) 3) Head First Java, great book but not updated recently, covers only till Java 5. You can also check [here](http://java67.blogspot.sg/2015/05/best-book-to-learn-java-for-beginners.html) for more advice.
We get it, you've got a YouTube channel you want to promote. At least post it to a relevant sub, i.e. /r/learnjava, but even then you're coming across awfully spammy.
https://tomcat.apache.org/tomcat-7.0-doc/changelog.html
Excellent write up of an interesting - albeit hopefully rare - issue caused by something during compilation, rather than with your own code/an added jar. Must have been a nightmare for the author to track down when they hit the problem!
&gt; Yes there are components out there which restrict access for you. For those applications, this article is useful to the component writer. Not many of those out there. Sure, a semaphore is good when you are writing a fresh new db driver, but how often do you find yourself in that situation? You should almost always prefer something that is prewritten. Prewritten things often do things much better. The Http Client example is great for this. Often you don't care so much about number of connections, rather you care about number of connections to a given host (who cares if you have 100 connections spread across 10 hosts?). HttpComponents and other libraries quite effectively manage connection creation and assignment based on host in a way that is pretty slick an easy to use. You can specify the max connections, the min connections, the max connections per host. Whatever your crazy heart desires. Now, if you are doing this on your one, you probably wouldn't dream of going that deep in complexity. It boils down to not reimplementing the wheel. Just don't do it if you don't need to. &gt; If you are using a collection which you need restricted, and a restricted version is not currently available. Then a semaphore is a nice way to do this. Not really. It is really easy to do collections wrong and a semaphore is sort of a doubly wrong way to do things. If your collection of choice doesn't have a concurrent representation, the best and safest thing to do is to synchronize on that collection before doing reads/updates/adds. Anything less could leave that collection in a really bad state. By the time you start talking about synchronizing on a collection, semaphores are pointless, you might as well do .size() and restrict it in the addition portion of the code. Semaphores are great for preventing too many readers, but when you start talking about writers all bets are off, you should prefer a mutex/synchronization block. If you don't do this you will end up with data corruption. Now, where have I used it. Debouncing is a nice place for it. In one of our products we have a swing app with a custom event system. When an event fires it registers an `EventQueue#invokeLater` action which goes through the queue and runs all of the events. If something comes in while that is running we didn't want to schedule yet another event runner invocation if one was already scheduled, instead we just accept that it will be run as soon as possible and move on. This prevents us from overloading the event queue with a lot of needless method runs which would essentially boil down to doing nothing. Another place that they are great at is the classic [producer-consumer problem](https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem). You have n producers and m consumers, how do you make sure the consumers are feed at the right rate? Comes up occasionally when you are doing things like batch data processing. It is a good tool to know well, but not one that I commonly use.
that's true of all haskell developers ^^^/s
I wish.
Ow my brains. Fascinating write up!
It is, in fact a problem with the code, and not compilation. The ternary operator took the closest super type of both types (Method, and Constructor) as it was supposed to. The closest type just happened to change to Executable in 1.8. See my comment above on how to fix the issue
where does the performance gain come from? Avoiding the need to (re-)allocate large buffers? This seems a bit wasteful and there's no significant technical details explaining this in the article.
I have encountered this bug when building a Scala project on JDK 1.8 and running it on JDK 1.6. I would imagine this bug would show up a lot in polyglot projects. 
Since you have your answer, is that for one of the https://projecteuler.net/ problem?
Well, I am a kind of person who tries stuff, go to conclusions (ideas), and erases details (arguably irrelevant) out of my mind after few weeks. So I cannot really respond in very detailed way, since last time I tried Boot was few months ago. Just briefly: * Does not support JSP or Facets (which are standards) - huge drawback for me. * Many technical issues I had experienced when doing something that is not just "add new REST endpoint". Sorry cannot elaborate more, since my mind sees no point in remembering all the negative stuff I experienced. Main point here is Spring Boot does not minimize Spring issues you face (as I thought previously), it may increase them by adding additional issues. * Its not "5 minute new project creation technology" I hoped it would be. * Philosophy - in my opinion, Spring has no philosophy (aka "we are too afraid to make any choices so we will allow everything"), Spring Boot adds additional layer of choices. Choices in general are good, but however useless choices that bring nothing to the table are expensive. The result is a shapeless infrastructure where you can do same thing in so many different ways and there are no best practices. 
Presumably the answer is one for any number of primes greater than three - the only way you'd end up with more than one is if any of the subsequent numbers are a multiple of two or five, which obviously they aren't as that would mean they're not prime.
I haven't checked that but it makes sense. Thanks for the addition.
So, to get “good enough” backwards compatibility with a current JDK, all I have to carry around is a copy of the JRE I’m targeting for `-bootclasspath`? Fair enough.
The phrase you're looking for is least upper bound instead of nearest super type.
hm, APL 2.0 is easy to abuse. At least I'd like to keep my name sticking on my stuff. sorry. kontraktor is worth ~80k $ (at least when written by me, there might be cheaper or more effective people out there ofc).
OpenJDK and Oracle JDK offer enterprise support if you pay for it (new features, performance fixes, security patches, etc etc). 
I should have clarified my statement. You can get OpenJDK supported through a Red Hat RHEL subscription (break fix, performance patches, security patches, etc etc). https://access.redhat.com/articles/69154
&gt; Haven't seen such problems in IntelliJ yet, and many regard it to be considerably superior to Eclipse, at least for Java. My bug from this morning with Intellij - create a Java file that's 3 pages long to print. Tell it to print page #3 on the print dialog. It will print out page 1, but label it as page 3 of 3. :-/ 
Ah a search engine, with page ranking? Forgot to mention I'm studying software engineering at university, and believe it or not that was essentially one of out assignments for last semester (currently on break). We had to do graph transversal and ranking based on weighting. Thanks for the suggestion!
Never head of a Markov Chain before, something I'll have to look into! If I was to look into an IRC bot, what client should I use? Never really been that into IRC, I guess I just find a lot of dead channels! Thanks for the suggestion! EDIT: Just realized a Markov Chain is essentially page rank used by google (or based there off). I've already done some stuff to do with weighted graphs (read my reply to /u/PaulBGD).
For android is little more complicated the use of windows and frames, because there are many different kinds of them. If you want to create a game, you have to create a custom view, but if you want to develop an app it's better to use some layout already defined by the android API, like Relative Layout or Linear Layout.
Please share your ideas here so I could march down the patent office, then find some VCs to throw money at me. 
CD key generator with multiple checksums to ensure that the client has different checks than the server. make sure that there are no duplicates and you should be able to continue key production without checking old ones. First order get me 100,000 CD keys, all sold now I want the next 100,000 without duplicates. also ensure that the pattern isn't obvious thus make sure that the main part of the key never has duplicate entries. try to make one and you'll see this is more interesting than you previously thought. and if you are interested I can provide some code of my own key gen.
One thing I found a decent project was to create a database desktop application for video game tournaments that my friends and I have every few months. I used Apache Derby in embedded mode as the database, C3P0 as the connection manager, and then pretty much everything else I created myself. All the database access is done via custom prepared statements, converting the result sets into simple DTOs then manipulating them and displaying them to the user through a GUI. The database schema is something that you will need to create a manage yourself too. I've found the project so far has given me an interesting insight to database schema design, GUI design, MVC pattern, and how to tie it all together into a functional product :)
While the move is a bit strange by DZone, I can't be the only one who thinks Geertjan's email are quite aggressive and unprofessional. Sure, they should have communicated clearly with the moderators, but from their correspondence, all articles are still available. I don't know what the new "high-level" zones will be like, but I guess they'll just be a broader zone category. I don't necessarily think that's a bad thing. Geertjan might be annoyed and disappointed by this, but the tone of his emails is quite terrible, while Kellet's emails are professional and courteous, and genuinely seem interested in opening a dialogue (which should have been done earlier, but mistakes get made).
$8000 for a yearly subscription/licence! But I can see how it is necessary for some applications.
Spring batch is an ETL framework (extract transform load). If what you are doing fits well in that paradigm then i would say its a good choice. If what you need is really a workflow engine then check Activiti or jBpm, there might be other options. do you have the usual requirements of batches? does it need monitoring, restart logic, etc? Do you have multiple data sources like databases, queues, excel files, web services ? Do you have to write to multiple of those, in different JSON, XML formats? Seems to me you need more a workflow engine than an ETL framework but its hard to say. 
Can confirm, this book helped me learn the language and get 100% on my first assignment with Java. So recommended for sure :D
* write a unit testing framework * make a space invaders clone * write your own database engine * teach a neural network to solve a simple problem * implement your own web server without using a framework * write a utility to do math on a large dataset using the GPU instead of CPU (ie batch image manipulation)
then this seems more then like a use case for something like $universe or any other commercial operations task scheduler. in that case i would not recommend spring batch for that or any java framework in general
Nah, Eclipse is definitely wrong :)
Neural networks are a topic that interests me, however I don't know how to start. Space invaders would also be good but again I dont know how to do actual visuals with java. Thanks!
How do you force the JVM to inline something? And doesn't @FunctionalInterface and Function&lt;T,R&gt; already do what your function interface does?
Stop spamming your Youtube tutorials, read the Reddit rules. &gt; [If over 10% of your submissions and conversation are your own site/content/affiliate links, you're almost certainly a spammer.](https://www.reddit.com/wiki/faq#wiki_what_constitutes_spam.3F)
I suppose that would work, but it's more trying to tell whichever programmer is using the library that they are trying to execute blank sql, which is a waste (and bad programming) 
I'm on my phone
That in itself is reasonable. It's essentially Design By Contract. There are better ways of doing it though, such as the JSR-303 annotations and validation. (Though that is surprisingly expensive in performance critical code)
[Our screenshotting at work](http://i.imgur.com/U6xJBgR.jpg)
@NonNull
I'm learning java at the moment. What's wrong with the code? (Beside the exception handling) 
those parentheses are killing my eyes ... 
The test for null doesn't actually change anything except the type of exception generated, for the worse. I don't know what else vecowski is talking about but that "debugMode" flag worries me a lot!
Debugmode toggle in the code, this is horrible to scale or deal with as it's most likely a global setting that outputs "debug" info to the console. Should use a real logger here with the various levels set appropriately. This code looks like he's manually building sql statements, this means he's probably doing data transformation manually and there will be little to no separation of concerns between the logic and the persistence layer. Typically this is fine for smaller projects, but generally you'll want to use some sort of abstraction for anything large.
That's a bit dramatic...
&gt;The test for null doesn't actually change anything except the type of exception generated, for the worse. Obviously a better exception and descriptive message would be better, but there is value in failing sooner rather than later.
Granted, I don't write in Java, but it doesn't seem anywhere near as bad as he's making it out to be.
Given the choice of working with that code base or a person who would react to that code base with "so many things wrong...", I'd choose that code base. :p
No it's really shit
That's fine, I doubt I'll ever work with you.
Well it's a public method so right off the bat you can't claim that it can't happen... If you've got an internal method that should only be called by a smarter method upstream then a) reduce the visibility and b) ditch the null check.
I'd say the worst thing about this code is how it treats the connection. It's a public method, which implies you have little control over the context in which client code can call it. However, the method assumes a connection is live and initialized. This raises two questions: "Where is the connection initialized?" more importantly "Where is it *closed*?" Edit: Even that can be justified with some sort of dao manager pattern... It's really not that bad.
I never said it can't, only that it shouldn't. That being said I agree, but I didn't write this and it's not something I am supposed to modify anyway
To be honest, I feel like it would just as horrible in json. The problem for me is that you outsource a bunch off stuff that have a very direct impact on your code to some other file, and the tooling for those files suck. What you write in those files doesn't really matter, be it xml, json or some special snowflake dsl. Moving towards annotations might be better, but I think we will experience an annotation hell also.
I'd actually disagree on the persistence part. Larger projects tend to require more manual SQL which needs to be able to be tuned easily. That said, SQL should be maintained within a separate file and definitely not built dynamically.
What a coincidence, [our screenshooting at work](http://i.imgur.com/by2c7Bq.jpg).
No. That's against any Java convention I ever heard of/saw/read. Capital initials are for class names only, the only exception being constants which are all in upper case.
I do typically write K&amp;R style braces, as I prefer writing my code that way. More aesthetically pleasing to me. But I actually find it easier to read code I am unfamiliar with if opening braces are on a newline. That being said, when I see it in an enterprise setting, I wonder if the coder was paid by the line. Edited to add: this follows one good principal and ignores a ton of others. The one good principal is have a style and stick to it. He should be using an established, reasoned style, but at least he has one that he sticks to. 
how about creating your personal password protected addressbook? here's how you can do it! ;) http://topwhatsup.com/category/programming/java-based-addressbook
that's what i thought as well. it's weird it's a utility method with all static methods beginning with a capital letter. seems very intentional.
I thought the tone of Kellet's email was condescending. The whole email chain read like "Oh yea, you guys exists. We forgot about you... Sorry! Will try to remember you next time. Let's get together and allow me to convince you to stay"
We use log4j. The next line after that debug mode flag is logger.debug
As you've mentioned, the first thing to know when dealing with this concept is that exceptions are intended to be exceptional, and therefore are pretty slow. So if your codes has any requirements in this area, you should proceed with caution. That said, some people believe that exceptions are just another return type. And so you have function return values which should be some complicated Union type. So exceptions are just another way to return values without needing to create complicated union types. I think this is true, but I also think that exceptions are more than this since they also jump N levels of stack until an appropriate catch statement appears. Simple union returns don't handle that. So to the task at hand, for me it would come down to code complexity. If you can really make the code easier to read by using your exception technique over some complicated set of return values, then I think I'd be all for it. Every rule has a situation in which it should be broken. 
I disagree with this. Without knowing the exact design of that module I could see lots of reasons to throw. If that is a programming bug I think it should absolutely throw a derivative of runtime exception. For example: illegal argument exception. I'd have something along the lines of: Preconditions.checkNotNull(Sql, "cannot accept null sql statement") I'd consider having more checks if that's a public API. IsEmpty? IsValid? Fail early and fail in a consistent manner.
Why do you need the debug mode flag then? Just put the logger.debug in directly if you're only logging.
Stop spamming your website.
the article may help out some body! :)
It can be useful in instances like this: if(debugMode) { logger.debug("Received: " + someFunctionThatIsSlow()); }
Which is where stored procs get handy. Put all that nasty SQL logic in a stored proc and then you don't have it unmaintainably in your java code as giant glob. (Though, i'm not such a fan of stored procs for everything, I am somewhat of a fan for using them in the case of hairy inline sql statements.)
Thanks for the backup. imgur now displays "Error (0) Sorry! There was an error (code: 0)"
I can't decide if I agree or disagree with the op on it being "terrible" code or not. The error message itself is great - short, describes problem, humorous. :-) I'd have to see the context to know whether the rest of the code is bad or not. 1\. Writing try/catch/finally loops around transactions - if your developers are writing these regularly it's a disaster (I speak from project experience). They're going to forget, they're going to not write something right, and most importantly there are time-saving ways to not do that that also produce less buggy code when something in a try/catch is missed. You could use Spring transactions, you could write your own DbAction interface and use the action patterns, there are a number of ways to do it, all of which lead to both less buggy and faster to write code. Can't say 100% for sure though, maybe this is one of only 5 methods and they could copy/paste this quicker than setting something up. 2\. Usually passing sql in is usually very bad as well. It encourages adding parameters values with string concatenation which leads to opening up your code to sql injection attacks. If you only ever allow PreparedStatements, it makes sql injection attacks impossible. However, without knowing the code around this code it's impossible to say 100% for sure. 3\. The StringUtils.substringAfterLast() call looks bizarre to. Again, one shouldn't be duplicating db connection stuff. It should just be in one place that's accessed by all db code. 4\. There usually should not be a separate branch for "if debug" type statements. There should be a logger setup with a logging level, for anything there should never be any separate "if debug" branches at all. If it's logging only, it could possibly be that it's not terrible, they just didn't want to set up logging. It's not the end of the world like having your transactions or statements not always get closed is, it's more of a "better approach" thing. If I saw most of this code in any of my projects, it would be a big problem. I can't say for sure about another persons project without seeing the code around it though. I wouldn't accept it on my own project.
I recently was facing the same question. I'm interested in automation so i decided to work on a web scraper/bot, and i've learned a lot in the process. Perhaps there is a game/service or somthing with an api you could write some tools or such for.
[Deeper!](http://i.imgur.com/GZFOSGX.jpg)
[more, more!](http://imgur.com/dtxiZLL)
Genuine question, what's wrong with setting a Boolean as the result of logger.isDebugEnabled() for use within multiple methods as opposed to calling the function every time it is needed? 
Source control and sane deployment with lots of stored procs is the worst
15 lines inspire so much criticism. Guard statements are good at the beginning of a method. I'd personally go for an assert myself, I'd likely also check to see that the SQL was well formed, though I somehow guess the database backed likely will do this as part of trying to create a query with bad SQL. The problem with throwing RTEs in situations like this is it can go unnoticed for a while and then suddenly you have this situation where your application crashes. As someone consuming an API I'd much rather have the API state that an InvalidQueryException could be thrown to make it obvious and in my conscience that bad things can and will happen if bad input is entered here. I guarantee the next couple of lines will have something similar for if the query fails to parse or execute as well. Sadly we don't live in a deterministic world where database servers never go down. Still though, 15 lines and a torrent of feedback. I'd also make it the loggers responsibility to determine whether or not messages should be logged, I bet if(debugMode) is in multiple places for that exact reason.
Yeah probably. I don't know what debugMode is in OP's code.
Read the Reddit's [site wide rules](https://www.reddit.com/rules/). Last warning (from me). 
I believe loggers can be reconfigured dynamically.
Stored procs are usually a big bag of nope. Debugging them sucks, the tools suck, the the languages suck. Then you have to nag you fellow programmers to keep the creation scripts updated in source control. I only use them if there is no other choice
But the slow method will always be evaluated unless you enclose the invocation within an extra check. That's what they're trying to avoid. The only way they could avoid that without the outer check would be if the api had method overloads which accepted Supllier's for the messages, which would only be invoked if necessary.
Since you're replying to someone who explicitly states that they are learning Java, I feel obligated to point out that RAL_9010_POWER is joking.
Okay, I'm gonna go back to browsing REDDIT on my COMPUTER.
He may be referring to operator-overloading. But personally I think OO is fine.
I think you violated a couple of method in the CALscientific class coming from the Java API for java.lang.math. Sorry but we may have to report you. Don't worry, at least I won't!
At our work, our coding style encourages the use of Guava [Preconditions](https://github.com/google/guava/wiki/PreconditionsExplained). So this code would end up looking like: Preconditions.checkNotNull(sql); Better yet, if you need to check that a constructor argument is not null: this.sql = Preconditions.checkNotNull(sql); Or, I guess what I'm saying is, Guava makes Java much better to work with and encourages better style.
Swing, go away; this is 2015. 
No, it doesn't help anyone, and your swing crap is terrible.
No, it really isn't, it is completely awful.
It should be `NullPointerException`. The convention enforced by Guava's `NullPointerTester` is that all parameters *not* annotated `@Nullable` must cause method invocation to result in an NPE if that parameter is `null`.
Nope, putting business logic in stored procedures is pretty horrible.
Wha...oh my god this is completely new to me. Probably just an artifact of spending most of my time in JRuby land these days. :)
I'm generally against the practice but in 1% of the cases it might be the way to do. I myself did something like that for [uniVocity-parsers](http://www.univocity.com/pages/parsers-features) in [this commit](https://github.com/uniVocity/univocity-parsers/commit/9e936e7a38d04c925539ebdc7fa2ecd7458dcc37) to fix a bug and also for performance reasons. Some context: This is the code for my library for parsing text (CSV, TSV, etc) and it was originally coded with an input provider class that would return '\0' when all the input has been read. The effect of this decision in the code was that EVERY time a character was read for parsing, I'd need to check whether it was a '\0' and stop parsing if it was. The bad effects were: 1 - this verification had to made everywhere in the code. With text processing this can happen billions of times in a few seconds, so it also has a (little) performance impact. 2 - corrupt files and other edge cases might produce '\0' as part of the input - while there's more stuff to read In this case using an exception to indicate an EOF and cleaning up the mess when it happens, in a single place, was faster and produced cleaner code that is also easier to reuse. On thing a learnt over time is that **there are no absolutes**. I cringe when I see people saying "never use goto", "inheritance should be dumped and composition always used instead", "never catch Exception", "don't use JDBC" (seriously, wtf is wrong with these people?), "Java should not have primitives", "utility classes are evil"... and the list goes on. Sometimes you have to break the rules to achieve a better or cleaner solution.
http://stackoverflow.com/questions/18324844/can-findbugs-detect-catching-runtimeexception-in-java
-&gt; https://vimeo.com/131394615
Was it really written by someone at Google? They have fairly strict coding conventions about style - and the conventions definitely recommend let case letters: http://google.github.io/styleguide/javaguide.html
Good compilation Eugen, I have subscribed your list now :)
I would avoid the code base and the developers who created it. If someone said "there are so many things wrong" and proceeded to identify some, I would probably enjoy working with that person.
He should at least be using PreparedStatement though. 
Imgur. 
 /r/styleformattinggore
It's literally there verbatim isn't it! I'd really like to see what happens in the situation that the query is malformed. Catching a Runtime Exception will only lead to bad things (e.g. catching an unexpected RTE, vs the one you think the method is throwing. 
Don't know why you got downvoted, this is textbook defensive programming
"Why is this null?" - FTFY /s
&gt;The following two lines will yield the exact same output. However, the second form will outperform the first form by a factor of at least 30, in case of a disabled logging statement. logger.debug("The new entry is "+entry+"."); logger.debug("The new entry is {}.", entry); [RTFM!](http://www.slf4j.org/faq.html#logging_performance)
More often than not people that complain like this are insecure in their own knowledge and skills. Usually for good reason: &gt;[Yea but your method signature isn't enforcing the throw, so clients using your code will just get a Runtime exception. If your method signature included throws runtime exception, clients would be forced to handle it. ](https://www.reddit.com/r/java/comments/3cton5/our_exception_handling_at_work/csyviv3)
If you don't care about the stack trace, `try`/`catch` is *extremely* efficient: just override `fillInStackTrace` in your exceptions to do nothing (just `return this;`). Filling in the stack is the only slow thing about exceptions. In addition, if you reuse your exception objects (i.e. have one static instance of each), you won't even allocate an exception object each time (though this may be premature optimization). As for your question, I would not rule out this usage offhand. It really depends on the problem you are trying to solve and what the alternatives are. 
Hey thanks for the tip about overriding `fillInStackTrace`! It's never too late to learn a new trick.
&gt; Debugmode toggle in the code You can use debug toggle for much more than just logging to console. In our codebase we have a global static final boolean DEBUG, which is used to enable/disable things like precondition checks. The build tools toggle this to true/false for debug/production builds. This means that in the production build the compiler will not emit any code for the blocks guarded by if(DEBUG).
Oh for sure, if they're being dynamically built it's prone to injection, and it's also highly unlikely it's being cached on the database.
Could i get in on this too? im also starting java and about to begin a CS Major, so i'm trying to start grinding it out and really learn programming. My last class stopped at Arrays in java and im currently taking a udemy.com tutoring and codingBat java warmups
&gt;Stored procs don't necessarily equate to business logic. Sometimes you have to update things in a transaction to ensure data is set properly. Sometimes you have to load things using multiple complex statements. Absolutely reasonable uses of stored procedures
if (sql == null) { throw new runTimeException " (╯°□°）╯︵ ┻━┻" }
Interesting read, thank you! I've been reading the articles published by javaspecialists for a few years and they never fail to come up with interesting (and often surprising) content. EDIT: I've got this explanation for the change of internal behaviour from hacker news: &gt; In short, the previous way of keeping the same underlying character array and just updating the {offset, count} indexes has a drawback in that if the original string is large, it is prevented from being GC'd if one keeps a reference to even a single substring generated from it. &gt; &gt; So, it's a trade-off between the original and new behaviour; the original way more or less caps the memory usage at the size of the original string, but at the expense of not being able to GC it if even a single substring exists, while the new way increases memory usage for each substring generated but does not prevent any of the strings from being GC'd.*
Can you point me to a resource that explains more in-depth why try-catch blocks are so efficient?
Oh I absolutely use `Preconditions.checkNotNull(T)` (which [preferred by Guava developers](http://docs.guava-libraries.googlecode.com/git-history/master/javadoc/com/google/common/base/Preconditions.html) over Java 7's `Objects.requireNonNull(T)`) rather than writing out an if statement. But I don't bother calling `checkNotNull` if there already exists a dot access, because then the NPE will happen regardless. So I typically only need to use it in constructor assignment, or at the beginning of methods that might throw before a parameter becomes dereferenced. Remember: the goal is to get `NullPointerTester` to pass. On rare occasions I'll use `Verify.verifyNotNull(T)` when I'm calling a method I don't trust to never return `null`, possibly because the library poorly documents its nullness contracts, or perhaps the method fetches data that's expected to always be present. In those situations, it can sometimes be advantageous to ensure execution halts immediately. For example, if the result gets assigned to a field rather than dereferenced immediately, it could be quite difficult to ascertain the root cause of the inevitable NPE at some undetermined point in the future.
For one thing the whole exception throwing is unnecessary. Also the method definition is not specifying the it throws an exception.
They just compile to a jump. More info and benchmarks: http://blogs.atlassian.com/2011/05/if_you_use_exceptions_for_path_control_dont_fill_in_the_stac/ http://nerds-central.blogspot.ca/2011/07/jvmdynamic-languages-very-fast-return.html
I would throw an IllegalArgumentException("SQL must not be null!"), so that if the stack trace makes it to the console or a log it is easy to see what happened.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/javahell] [Our exception handling at work \[/r/java\]](https://np.reddit.com/r/javahell/comments/3cxhzp/our_exception_handling_at_work_rjava/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger/wiki/) ^/ ^[Contact](/message/compose/?to=\/r\/TotesMessenger))* [](#bot)
They do have a free tier but if you're a business working with high speed systems and "big data" needs then I'm betting the license is a drop in the bucket. :) Free download that's got a permissive usage license. http://www.azulsystems.com/products/zulu
Hey come on, let's try to be civil here! No need for insults. 
&gt;If you can't figure it out, maybe work on your reading comprehension. That's just being insulting for the sake of being insulting... &gt;One. ... Can't say 100% for sure though, maybe this is one of only 5 methods and they could copy/paste this quicker than setting something up. Not for sure a big deal. &gt;Two. ... However, without knowing the code around this code it's impossible to say 100% for sure. Not for sure a big deal. &gt;Four. There usually should not be a separate branch for "if debug" type statements. There should be a logger setup with a logging level, for anything there should never be any separate "if debug" branches at all. It's a pretty common approach that avoids generating debug messages in cases where they'll be filtered out anyway. Granted, it usually done with "logger.isDebugEnabled()", but there is nothing wrong with "if debug" branches in general. That leaves Three. Which while a legitimate complaint, is, again, not a big deal.
You're probably right about the optimization not belonging in the spec. It's a bit silly. It allows you to use == on Characters &lt; 128, but that's probably too specific a use-case for most folks. You can use an IntStream for chars. There's IntStream, LongStream &amp; DoubleStream using primitives. There's no Boolean, Float, Char, Short or Byte streams, but you can use Int or Double for all of those instead. If you're wondering why these streams don't exist, the implementation is pretty complex, full of duplication and greatly increases the JRE footprint. [Wonderfull detailed explanation here](https://stackoverflow.com/questions/22918847/why-are-new-java-util-arrays-methods-in-java-8-not-overloaded-for-all-the-primit/22919112#22919112). 
&gt; That's just being insulting for the sake of being insulting... &gt; ...That leaves Three. Yeah, but I didn't put any more thought into it because I expected your followup to be ridiculous and make few actual points and it went as expected. "can't 100% say for sure" does not mean "so it's invalidated" no matter how much internet arguers like to pretend it does. All of these things have caused problems on projects I've worked on, especially use "if(debug)" because the first person does it right but the 3rd person starts putting actual code in there and it causes a huge amount of rework to be done. Thing is there's almost no upside to doing it these ways vs the better alternatives that don't have these issues but work just as well or better. If you disgree, ok, you disagree, but we're not having an interesting back and forth either way.
Sometimes.
&gt; Yeah, but I didn't put any more thought into it because I expected your followup to be ridiculous and make few actual points and it went as expected. You can at least see why I would rather spend days tracking down connection leaks than working with somebody like you right?
[This link](http://www.adminarsenal.com/admin-arsenal-blog/beat-java-error-1603-when-deploying) may be of some assistance. 
No, this subreddit is not for learning Java. This subreddit is for people who want to share interesting information regarding Java. You can certainly find help here from willing participants, but you will receive warmer reception from the already-mentioned subreddit(s) and link(s).
Thank you for helping me with my actual problem.
Groovy provides this functionality via the [@Immutable](http://mrhaki.blogspot.ie/2009/09/groovy-goodness-making-class-immutable.html) annotation
Y U NO SCALA?
Internet. It's free and has all the information you could want. As a supplement, however, I'd advise you to buy Effective Java, 2nd Edition, by Joshua Bloch. Written by someone who used to work on Java, it helps you start thinking about how the code is written and functions rather than what it does.
Whats the advantage of this over https://projectlombok.org/features/Value.html and https://projectlombok.org/features/Builder.html
What is the application for this? 
cool, was not aware of this .. transparently remoting futures will not work out of the box ofc, however if one translates them to kontraktor Promise's behind the scenes it could work. might try as I find time :)
Lombok's reliance on undocumented compiler APIs have held me back from trying it. 
Not sure I understand your confusion. Are you asking what immutable classes are good for, or what the library does? 
When would you use it. All I'm seeing is that you can reduce boilerplate. My IDE refactors code to my satisfaction. If you want to use a language that has these features then use Groovy, Clojure, Scala, etc, they too compile to byte code. 
Few interesting points you mentioned I just like to comment. * Regarding quick and dirty vs. Scalable. Some time ago I "bought" this idea. But I am now convinced that this is false - there is nothing fundamental that lets you choose only one. .NET has both, Go (Golang) seems to be on the way to prove that you can have scalable and ridiculously quick and dirty platform. Even on the JVM I could start Scala app in minutes. So I believe this issue is only with attitude, Java developers just got used to terrible conditions and just don't demand better. * The last point. Again I believe its not black and white - "allow everything" vs. "allow only one limited way". We could have things in the middle.
The Reactive Streams publisher available in simple-react at the moment, asynchronously publishes the results rather than the futures themselves. If remoting Futures (or Kontraktor Promises) was possible then that would open a lot of interesting possibilities.
I love the idea of Lombok, however implementation bothers me. Your code doesn't really compile, except through some 'black magic,' that involves installing an IDE plugin. I've used it, and found it too painful. If you want to create a custom Lombok annotation, you must define separate Eclipse and IntelliJ implementations. The Syntax is not Java, so that's another thing you must learn.
I don't know why, but I feel like I'm looking at Javascript generated code..
Who cares? Seriously.
You can use immutable collection instead of array there, so no array is copied on get. Also, there are some primitive immutable collection I guess. Statically proving that array will not be modified is very limited and barely reliable in java. Most array returning APIs in java clone internal arrays to maintain consistency.
yes, because nothing else you've ever used has ever done that. that sounds like a reason somebody trying to sound smarter than they are would use. like people who hated on windows "because it crashes and stuff" or IE because "it doesn't work right" but can't be pressed for any specifics. 
Take a look at the /r/javahelp wiki. You'll find plenty good and free tutorials there. I'd say that the net and books complement each other. I learned most from the internet, but books are an always available, valuable reference.
Don't use theNewBoston. He is a discouraged resource in most programming related subs. He uses terrible variable naming, doesn't stick to common conventions, and in general teaches frowned upon practices. All the above is essential to be avoided especially in the beginning. Derek Banas is the way better alternative.
Style question — what do you prefer: a) instantiating a nested static Builder class directly a la [Joshua Bloch](http://www.informit.com/articles/article.aspx?p=1216151&amp;seqNum=2) or b) a public static class method that returns the nested builder? So when using the class, do you prefer this (a): Item item = new Item.Builder().build(); Or this (b): Item item = Item.builder().build(); And why? 
Citing Effective Java. 2nd ed. Item 2: &gt; ... Instead of making the desired object directly, the client calls a constructor (or static factory) with all of the required parameters and gets a builder object... Guava heavily use factory methods for builders, mainly because of generics (prior to 'diamond' in java 7) and flexibility to have other builder factories: think ImmutableSortedSet.naturalOrder(), reverseOrder() etc. Also we shouldn't forget that Josh Bloch worked at Google at the time when core of Google Collections/Guava was created and was one of the major authorities regarding API design for Google core libraries, so he would not be against using factory methods for this. (That was merely an anecdotal evidence than a point) *Immutables* was primarily designed after Google's immutable collections and uses factory method by default. However you can use constructors for builders or configure other conventions using [styles](http://immutables.github.io/style.html).
Thanks!
We've used Spring Batch a few times and in my experience its main point is "restartability". Use it to allow long-runnning (hours) I/O intensive data processing job of a million+ records to be launched, stopped and resumed at will. The step-oriented design is mainly to help achieve this because the execution pipeline knows what element number is being processed and can persist this state at any time. Think of End-Of-Day or End-Of-Month batch processes for banks, insurance companies or governments which used to have (or still have) mainframe computers printing checks, statements and reports overnight with some poor soul making sure the machines are humming along. Any deviation from this pattern makes Spring Batch quickly become less useful. If you only need scheduling and no manual oversight, use Quartz or a simple cron job. If you have less than a few thousand items to be processed you can probably afford to rerun the whole process from the start if it fails at midpoint or you need to stop it. If you need reuse parts between different jobs, designing your app accordingly will go a long way. If you have complex workflow, something like Apache Camel might help you keep things figured out. If you have continuously changing data, use an event processing framework.
kontraktor promises are magically remotable as long they are part of a async actor message signature (args are scanned when remoting). This does not hold true for "embedded inside some object" promises, as recursive scan of messages would be too slow at runtime ..
I would suggest reading articles online because there are several benifits - * Less intimidating than a thick book. * Much wider choice of authors * A certain author might have covered a certain topic better than others. * Free 
Try Lombok @Value for immutable classes. No, really : https://projectlombok.org/features/Value.html Keep Scala for the functional features.
It depends on how you define "very much java" or "standard java" etc. It's not a standard java because the code no longer complies with the JLS. (for example: if you define private field, accessor method could not appear out of nowhere whatever annotation it may have). It will continue to be non java compliant until AST transformations and their effects would be standardized and described in JLS. On a practical aspect: fraction of tools don't work to full extent with lombok, if you don't use some tools it doesn't mean that other don't use them as well. Lombok community just cannot write adapters or plugins to all variety of java tools.
“Up to Java 6, you could use the substring() method to save memory, if you only needed a small chunk of the String. But since Java 7, both Strings share the same underlying char[] and the old optimizations do not work anymore” This is completely the wrong way around. You've summarised Heinz's article but mixed up the before and after situation. 
This sounds like an excellent way to ensure that no critical security fixes will ever get deployed rapidly, or at all.
This requires you to have an efficient deployment pipeline where new versions can be rolled out in minutes.
Yes, and it requires that the deployment pipeline can get access to packages with security patches already applied with a timely fashion. Since the debian repositories doesn't keep old packages with security holes around I presume that the pipeline will pull them from snapshot.debian.org instead (for example). That sounds like our project would need someone to manually change the dependency so that it's not pointing to 1.0.1e-2+deb7u16 that has a security hole, but to 1.0.1e-2+deb7u17 instead (for example). That means that someone on our team must track CVE's listed for the complete software stack, from the kernel up to the java layer. If I compare that strategy with our current strategy of having our servers on debian stable and installing (only) security updates autocratically I can safely assure you that the average time we would have a security hole in production for some would rise dramatically.
I use Lombok with Netbeans and don't use a plugin, didn't realize one was required.
https://www.youtube.com/watch?v=0hrqZjw6mUY
This is the whole point of docker
Why not both? Pick what's best.
This seems... off ... I might be missing the point, but then again I'm a Java developer and not a systems engineer. Oh wait. This is the Java subreddit; I thought i was in /r/sysadmin for a second.
I use ssh for troubleshooting quite often. How should I do that without ssh?
See also the [proxology](https://github.com/opencredo/proxology) library, linked from the fine article.
true, it was actually a bug on substring() implementation and can cause memory leak if your application is using long Strings and doing substring on them. BTW, its already fixed by author. 
Check out Red Hat Atomic. Designed so that you can manage, deploy immutable infrastructure. Fully supported (performance, security patches, within 2 hour callback 24-7) via enterprise subscription from Red Hat.
By default we try to write at /tmp/, actually to javaTMPDefinedFolder. By some reasons it seems you don't have permissions to do that. There are two options: 1) You grant your user to have write permissions to the /tmp folder or 2) You specify a different tmp folder, with option: java -Djava.io.tmpdir=/MYSUPERPATH/MyNewTmpFolder -jar javosize-1.1.0.jar I have just tested option #2 and works fine.
Thanks for the info, but /tmp is wide open. I can create dirs and files with no issues, just tried it out to be sure. Thanks again, I'll check out this tool later this year perhaps.
I had the same thought, but I can create .so files and turn on the exec flag and all that fun stuff in /tmp. I'll try and specify my home dir. Thanks for your help
Or you generate the server as part of your build like Boxfuse does. No agents and no SSH required.
This issue was new for me too. But it seems that is the problem. Try specifying your home, should work. I am going to try to grab that exception in the code and switch to ~Home in case found. automatically.
Changing the tmp dir using the -Djava.io.tmpdir flag did fix the problem. So it seems there was something preventing any writing to /tmp, even though I can do it manually on the cmd line. Weird. Anyway, cool tool! I'm really liking it so far 
Very nice, looks quite good. I'll try it at work sometime! 
https://news.ycombinator.com/item?id=9873645
If you can apply security patches that implies whatever you are applying them to is not immutable. :/
&gt; Java will break its promise of backward compatibility No, Java 7 promised (by printing a compilation warning) that "Unsafe is internal proprietary API and may be removed in a future release" :)
https://bugs.openjdk.java.net/browse/JDK-8046183?page=com.atlassian.streams.streams-jira-plugin:activity-stream-issue-tab JEP 193 - Define a standard means to invoke the equivalents of java.util.concurrent.atomic and sun.misc.Unsafe operations upon object fields and array elements. Hopefully this is a more structured and open replacement of unsafe.
Removing sun.misc.Unsafe is a **great** decision. It's a shitty API. The "misc" is a good indication of the amount of random crap in there. The "Unsafe" part should pretty much make clear that you'll likely shoot yourself in the foot. The "**sun**" package **really** means that you shouldn't be using it and should never have used it. Sorry to all those framework developers and performance tweaking folks out there. But you should never have relied on this. You should have either used JNI (which is a pain, but so is sun.misc.Unsafe) or have done proper lobbying in the JCP for a proper API on top of some of this stuff. As for this "breaking" Java. Don't be absurd. This won't break anything. This shit is **already** broken. 
I agree with the sentiment of the post, but I end up siding with Oracle as the maintainer of the platform API. On one hand, the problem that i see with removing it is that Unsafe is used by many performance-critical libraries that are thoroughly tested and deeply-deployed throughout the Java ecosystem, but which may not be as actively maintained because of their highly technical nature. On the other hand, this class can only be accessed *now* by first ignoring the fact that it exists in the long-defunct "sun" package, and then by sidestepping a classloader check by using REFLECTION to access a singleton instance. The Oracle spokesperson, in fact, undersells their position to java developers by focusing on the class name, and failing to mention that it is as currently as deprecated as deprecated can be (besides preventing linking to the class altogether). For all the value that exists in these Unsafe-dependent 3rd-party libraries, they must allow some slack for Oracle to be able to cut it off so it can alleviate the obvious security and evolutionary limitations that Unsafe preserves. Remember, the primary mission of the JVM is that it serves as a barrier of abstraction between application code and the enormous variety of systems upon which it runs. Unsafe is a gaping hole in that mission, one which Oracle is duty-bound to fill. Once they do, it will put the onus back on the ecosystem through the JSR process to request PROPERLY-DESIGNED low-level APIs, that preserve JVM abstraction while still providing opportunities for language-agnostic performance optimizations. For god's sake, remember that there are sysadmin's out there who expect that a java application will obey the Xms and Xmx arguments! No matter how well-tested and performant your 3rd-party library is, if it is still using Unsafe, it is cheating, full stop. If you need a level of access that is closer to the metal for your performance requirements, use JNI. Don't expect Oracle to indefinitely maintain a glorified platform-independent backdoor so that you can continue to blame them for security issues while still pushing out libraries that claim zero heap allocations or other some-such nonsense. 
wow! Even better than what I was looking for!!! Thank you SO much.
It's called Unsafe and not Undocumented for a reason.
&gt; Bullshit. Hibernate ORM does not use sun.misc.Unsafe.[1] . Neither does Spring Framework[2] . Nor does Mockito[3] . Stop spreading FUD. I did not claim that they would "break" because they "use" them. I said they rely on it. As in, if you use the library or framework and Unsafe disappeared tomorrow the library or framework would cease to function as expected. It's due to dependencies on libraries like Objenesis. If there is no fallback then it's going to break as soon as you hit related code. In many cases I'm sure there is a fallback. However even in those cases Unsafe is preferred for performance. Dropping into a less performing fallback is a great way to end up with an application that if not "broken" certainly no longer meets the original requirements.
immutable = "unchanging over time or unable to be changed." a patch = "A patch is a piece of software designed to update a computer program or its supporting data, to fix or improve it." you can't change something and call it immutable.
Hi, Did you get a chance to analyse the code? Also, I'm not sure what you meant in your earlier comment about native vs byte code. Surely compiling to native machine instructions will make the execution faster?
Bullshit. Whoever will cry by removing Unsafe, they brought that on themselves. You need that optimization? Ask oracle to provide a documented interface (in java, or javax) and it's all good. It is...unsafe tho. So, cry me a river, life will go on, nothing will happen we will work as we did before. 
Hi. No, not yet, but it is in my pipeline. Java *is* compiled to native machine instructions. It is just compiled to bytecode *first*. Java bytecode is just an intermediate representation that is later compiled to native code by the JVM's JIT. You can even tell the JVM to output the assembly instructions it generates.
Does this only affect Java *applets* running inside browsers? Applets (just like other native browser plugins such as Flash) are a well known risk.
This doesn't seem like new news, there's a reason that browser manufacturers en masse are disabling NPAPI, if people are still getting exploited its their own fault for not upgrading to recent browsers.
&gt; still pushing out libraries that claim zero heap allocations or other some-such nonsense Just because you do not have those requirements does not mean they do not exist. There are many areas where deterministic bounded latency is a requirement which can be fulfilled with current Java implementations if care is taken.
I agree in general that unsafe should be replaced by "safe" alternatives. I disagree in the order of action: * first remove Unsafe * then provide alternatives I think it would be better to reverse the order. Most people are not aware there are some use cases where replacing unsafe adds a huge penalty. Its not that programmers use Unsafe out of fun, its mostly used to implement things which are missing in the "public" API or suffer from utterly bad design choices (such as requiring a full GC to free up native memory)
Unsure where the fool is here. There is high chance the java software stack you are using makes use of Unsafe somewhere. "JSP does not require Unsafe" is kind of simple minded.
I sent in a mail on the form about this but I'll do it here as well. Any chance of IDE integration for IntelliJ or Eclipse with this?
You will find most details here: http://blog.trendmicro.com/trendlabs-security-intelligence/pawn-storm-update-trend-micro-discovers-new-java-zero-day-exploit/
Awful article. The Trend Micro blog post they mention is even worse. Instead of making it explicit that this only affects Java applets, which have been a known problem for so many years, they refer to Java exclusively, not once saying this is about Java in the browser. And on top of that they say the cause of this is a Windows issue. Shit writing all around.
Why are they always saying this like this is affecting the whole java ecosystem - but in reality it is again only the miniminority that still uses java applets.
It's a bit far off right now, but JNI should be made redundant by Panama going forward from Java 10 and beyond.
This makes sense in principle, but afaiu to allow Unsafe to remain right now would either be a detriment to what they intend to do with Jigsaw, or it would cement it in public/sanctioned API, making if far more difficult to get rid of it down the line. There are [subsets](https://bugs.openjdk.java.net/browse/JDK-8046183?page=com.atlassian.streams.streams-jira-plugin:activity-stream-issue-tab) of the functionality provided by unsafe targeted for 9 I think, but it will likely be years before Panama comes along to address the remaining performance and memory layout issues. It's a tricky situation, and for me personally I think they chose a good path through it, but I can see why other people would be disappointed.
The idea is that it forces you to automate things to a degree where not much can go wrong, and that when it does go wrong, you just throw away the server and bootstrap a new one. That's the *idea*, at least. 
Requires registration to download
Plenty of applets are still in use in corporate environments. 
To be fair it's the choice of the website that is trying to hack you to create an Applet that uses the exploit. What Oracle needs to do is to deprecate and abandon Applets all together. They aren't very many things that require Applets that HTML5 can't do. Local resources not accessible by HTML5 should probably be a desktop app anyway.
Wonder how they get their data? Easy to believe Java is more popular than .NET, but hard to believe that C#.NET is #4 below C and C++!
This is my personal account. Yes, I'm from the IntelliJ IDEA team, but I don't see why I can't share this with others. As the post explicitly says that it's not an advertisement.
If I wrote that Java was not pass-by-reference it would probably get downvotes. Just the nature of this particular sub, not sure why.
I've been using intellij in last 6 months. It is a great IDE in the UIX department but it is a performance hog. It always, always updating its damn index and seems unable to manage well high count of maven modules (my project has ~120 module of any size), I had to split it in many project and switch between but then is annoying. Edit: horrible spelling
&gt; I'm from the IntelliJ IDEA team, but I don't see why I can't share this with others. You realize that 79% of your submissions are from jetbrains.com? Did you ever happen to read Reddit's site wide rules – which start with "don't spam" – and its guidelines about self promotion? Edit: 84%. You've posted the same article to Google Docs and submitted that, too. [29 days ago](https://www.reddit.com/r/java/comments/39xaiq/migration_guide_eclipse_intellij_idea/).
When I decided to read more of others' code, I cut my teeth on an early version of Apache Tomcat. Large projects like that can be daunting, but as @mrhhug said, it's real code that's community reviewed and lives on thousands of installs.
You say it's not marketing, yet it's filled with sentences like: &gt; If you have several unrelated projects, you can open them in separate windows. At first you may find this an inconvenience, but, in fact, it works to your advantage helping you stay more productive as you're always focused on one project at a time". Which is, as you probably know, total bullshit. Pardon my French.
http://www.infoq.com/resource/minibooks/java-garbage-collection/en/pdf/The-Java-Garbage-Collection-Mini-book.pdf Here is a direct link
I'm just pointing out - since it's checking for null, you know the value, - it's null, lol...
Yes, if IBM J9 JDK 1.6+. There is a particular JDK j9 1.6.0_XX under which hot deployment does not work, but software will let you know in such a case. So short answer: yes. 
Forgive my hyperbole as I was quite hungover yesterday. I prefer agentless server provisioning, as you don't have to install anything before you can install anything, and it doesn't take space, memory, add possible exploit vector. 
Interesting to see vb.net gained a few positions while objective-c lost a few. Is this 2008? 
Getting a 404
Uploaded to Google Drive. https://drive.google.com/file/d/0B6xRHgMlP_ymczViYjgySVpoVWc/view?usp=sharing 
1. has exposed that Builder is part of Item when the user might not care 2. hides where the builder comes from and you can have multiple builder factories for different use cases just my 2 cents to add on
Well, you still have to roll out ssh keys. That diminishes the advantage in a lot of use cases. 
As I do .NET more than Java I have not needed unsafe code to make things work in my Java apps. However I have used unsafe functionality in .NET many times. What comparable performing APIs are being offered up in its place? Just JNI?
JNI will eventually be superseded by Panama, which will bring significant improvement, and in the shorter term the proposed VarHandle should cover some of the other functionality currently provided by Unsafe. Edit: I'm also interested as to what sort of work you're doing that you find it appropriate to use unsafe functionality *frequently*...
Just a guess, but maybe in test1 the `array[x]` portion is being cached? So it only has to evaluate the `[y]` once per inner loop, whereas test2 has to evaluate the entire `[y][x]` on every loop?
Because of "locality of reference": http://stackoverflow.com/a/9936656/502399
&gt; Also, being able to recover from an RTE is clearly possible when they are being thrown in situations such as these. Ok, I'll bite, how? How do you get the code to figure out what sql string you actually meant to pass in?
There is a JEP being prepared to have an officially blessed class that subsumes most of the functionality of `sun.misc.Unsafe`. However, as Peter Lawrey (of vanilla java) put it on the JEP-off heap group: &gt; My feeling is there is too many holes for them to plug in one release. This will mean we might expect a proper ?fix? in Java 10.
The difference is you are upgrading the *host*, not all of your servers.
Caching and locality. In the first situation, the next int is 4 bytes over. In the second situation, it's somewhere else in memory entirely.
Even though it's not Java programming related (yet the Exception gives a hint that there is something wrong in the program), it should be in /r/Javahelp. /r/Java is for discussions about the Java ecosystem and not for any programming related (applets belong in that category) questions. All questions should be directed to /r/Javahelp. Kindly repost there.
Because more and more financial apps are web based. Java is suited well for web development. Apart from this, you have Java APIs and connectors to most backend systems, like SWIFT for example.
Any chance for .mobi? Thanks.
You should go through the source code of classes from collection API like ArrayList, Hashmap on something like codegrep.
Wrong thread bud &lt;3
+1 for AMAS! Source for inspiration: heroes of Java series
Mod ideas? Is this /r/GameDev? I thought Java mods were called "libraries". *opens thread* Ooohh.
Try /r/javascript. From what I can tell, this writes a binary file to a temporary directory on your PC and then executes it. No way I'm going to test out what that binary actually does; this is sketchy enough as it is.
Nice article that covers more than just standard Java technologies (ie Play, vertx, Spring MVC)
Very good read. I've had Vert.x and Play on my list of things to play with :) 
AMAs with a twist...How about live 1hr demos of latest Java development trends? I like the latest streams on livecoding.tv.
What? Where the hell did that come from? How the fuck is **that** trolling? Discussing how code will behave is trolling? This sub really is full of assholes. How dare I not agree with this twat. Edit: I see you resorted to insults pretty quickly elsewhere ITT. I believe it is you who is the troll. Who'd have thought you'd see such juvenile behaviour on /r/java?
&gt; We are on the fence about joke posts and image posts. Personally I'm against it. I don't see how a single image can provide grounds for a meaningful discussion about Java. It just caters to the fluff, memes, pun threads and oh-my-title-is-so-funny garbage that the default Subreddits have largely succumbed to.
Agreed, except: * if jokes/image posts get out-of-hand, then kill 'em * no job postings -- put useful stuff in the sidebar
Besides, emacs is way better. /s
As someone who started learning programming recently, why do I want classes like these created during runtime?
&gt; You don't, you can just report that the SQL string should not be null, or conversely, it should be valid SQL. Exactly. &gt; Recovering from an error isn't the same as error correction. You can't recover from it. You can drop that chunk of work - like on a web server the request fails but the server doesn't crash and it keeps serving other requests - but to do that you need to at minimum have a try / catch(RuntimeException) block around the work. Exceptions you throw yourself are not fundamentally different than exceptions throw if a value is null and you try to access a property or method on that value. In other words "a.doS()" where a is null throws the same kind of exception as if(a == null) throw new NullPointerException(). It's usually bad practice to catch and hide exceptions. It makes testing and debugging a real pain, and adds a lot of "well it seemed to work" problems for testers. It's almost always (almost) better to throw the exception up the chain and abort the whole thing, so when it comes up in testing the bug in the code is caught and fixed. Of course if you're writing your own web server, or a swing app, or something specialized, you don't want the whole app going down (though usually it would just kill a thread instead anyways), but that's rare. Hiding exceptions is usually considered bad practice, most of the time. &gt; It all comes down to the requirements of the functionality, as I'm sure you can respect that only a subset of the code was given and hardly any context as well. That being said, I've never been asked to write anything like this. True, it's hard to make to many determinations from this small segment of code.
I am currently working on a project that started out doing bytecode generation using Javassist. This kind of run time code generation can get pretty unwieldy and we have since moved to generating the code in the Maven build. Initially for this we were using Roaster https://github.com/forge/roaster, but now we have moved simply to Freemarker templating. Definitely an intersting topic!
Saved
It can do more than that, for example replace or delegate code in existing classes. But maybe if you had a method like this: public Class createClass(Class superType) { return new ByteBuddy().subclass(superType).make().load(superType.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER); } It would allow you to create classes based on user input or other variables.
For AMAS and banning of language hate (also, please ban IDE hate)
If you are developing a library and you want it to enhance user-defined objects that should otherwise know nothing about your framework. For example, in Hibernate, I can create a normal Java object that has properties on it that are simple types (String, Integer, etc.), and the object knows nothing about Hibernate. When Hibernate instantiates it, it can be configured such that it subclasses my class dynamically, and LAZILY retrieve certain values only if/when the getter for that property is called. Without this kind of black magic, I would have to modify my object to return some kind of "Lazy" wrapper type, or modify my property to explicitly retrieve the value via Hibernate APIs in my getter. But the drawback there is I have now coupled my object with the Hibernate framework.
Try this https://plugins.jetbrains.com/plugin/7138?pr= I commonly use 10+ projects without a problem.
-1, just let the votes speak. Java Annotated Monthly is awesome.
Have considered annotation processing for code generation? (I'm not implying that it is easier choice or what so ever, just curious)
http://www.oracle.com/technetwork/java/javase/2col/8u51-bugfixes-2587594.html
so it is running on/using javax.annotation.processing.Processor and javax.lang.model.* or have other engine to obtain model/introspect types/annotations?
Also take a look at the Java Compiler API. If you are compiling class from scratch it is much easier to use than javaassist or the library in question. Javaassist is great when you want to modify the bytecode (in the java agent, for instance).
Just reflection and custom annotations.
Interesting. I've split the maven build into 2 stages where one uses ftl to generate the java source code, as a maven plugin, then build that into the rest of the project. Works fine for what I need. But i'll have a look cheers. And yes, anything has to be easier to use than javassist.
Didn't they say not to depend on sun.* classes?
Yeah, I've seen such approaches, it works well for a lot of cases. Thanks!
On a side note. The Java binaries can be copied and used (path'ed) with out installing it.
I do not know if it fits your project at all, but it may also be worth while to take a look at Scala Macros feature. The documentation is cryptic and you will be dealing with compilers internal AST most of the time, but the feature is very powerful. Groovy AST transformations are great as well. Both are not pure Java, but produce JVM byte code at the end.
Java has support for Javascript in rhino, nashorn and maybe more and there is even an implementation for the node.js api called nodyn. Try Google next time 
How about, Sunday questions posts? 
I disagree. Even if your code is written well, sometimes you just have to do something strange. If it's not commented, someone is going to come along and change or remove something. Then everything goes down and you have to yell at people who will in turn yell at you for not commenting your code. It's a good ideal for wanting code to be readable all the time, but it's just not realistic if you're working on a big application with a lot of different people.
My rule is, let the code be the 'what' and the comments be the 'why'. Yes code should be self documenting to a degree: a low level example being to split-out complex expressions into steps with clearly named values. What you can't express in your source code is contextual information: how this code fits into the wider system. This could be derived by reading it all, but a few natural language comments really do go a long way to lowering the 'barrier of entry'. Being actively helpful with your comments is especially important when working in a team, if you expect your lovingly crafted, re-useable components to gain any traction among colleagues. In this way, comments *multiply* your code's effectiveness. Conversely, failing to comment re-useable components increases the chance of a colleague re-writing it's behaviour, weakening the cohesiveness of the project. That said, one should strive to keep the code obvious enough not to require comments where possible. I don't comment obvious accessor methods. Auto-generated and blatantly obvious comments like setName being 'sets the name' are indeed worse than no comments at all, and should be severely [punished](https://overland.org.au/wp-content/whipping_post_550.jpg).
My preferences: - No hate speech (for languages and IDEs) - yes - AMAs - yes - Job posts - I'd prefer not, as the job post spam is what keeps me away from LinkedIn communities. - Joke/image posts - we don't seem to have a problem with them at the moment, so my thoughts would be to let them be unless they start to become an issue. - Incubator site - what's wrong with Github/JazzHub/Other free respiratory sites? 
Never had some weird really obscure corner case, that makes virtually no sense ... except in this one particular situation with a million dollar customer. &gt; // don't change this, this is because mr Smith is a douche talk to someone in customer services cust id 198 There are loads of good uses of non javadoc comments. The business context of code always help, to echo other replies, the why is important in comments. Just saying all comments are noise, is itself just noise itself. 
those comments are harder to read than the code!
I can see the "what" from the way you have named your method I can see the "how" by looking at your implementation. I cannot see "why" you throw an exception in the value of the second parameter is -2, unless you tell me!
For some reason many of the people who care so much about commenting the code do not care that much about updating comments when the code changes.
&gt; I cannot see "why" you throw an exception in the value of the second parameter is -2, unless you tell me! Usually this hints of the bad design regarding this second parameter and its magic value. Probably the author of code was lazy to use a couple of boolean flags instead of single integer variable or something like this. So if you feel your code needs to be explained - it is time to stop and think thoroughly, if there are some flaws in the code design.
I agree. There may be some corner case where a comment would be helpful but I believe this is the exception. As you have said, well written code should be understandable.
If you have to write comments in your methods, you're usually doing something wrong. Any code quality analysis tool would probably complain about the complexity of that method.
If you write behavior driven tests, you can perfectly explain why you're throwing that exception. I'm not saying comments are bad, but I do not agree with the author, telling us that it's trolling if you tell him to read the tests, reading tests are a necessity if you're developing. 
True. But to be fair, people who expressively dismiss comments probably care even less. In general it is hard to maintain comments if the team disagrees on their importance and use.
sun.misc.Unsafe is *not* being removed in Java 9, nor will it be removed until good alternatives are in place. The author of the post needs to relax.
I'd say the comments make obvious that complex rules are involved. If I were to draw an image of what is going on, I am sure I could o it in half the time from only looking at the comments compared to only looking at the code.
&gt; My rule is, let the code be the 'what' and the comments be the 'why'. This is the proper approach.
I would prefer it to be refactored into something where the logic was clearer and the comments were no longer relevant.
&gt; My rule is, let the code be the 'what' and the comments be the 'why'. Exactly. Your code should be easy to follow, but it can't tell the user *why* you're doing a specific thing. Take, for example, a file watch that checks if a certain configuration is modified, and reloads it if it is. You might have a line that checks if the reloaded configuration is the same as the existing configuration. The code makes sense, but surely the config won't be the same if the file is modified, so why check at all? It turns out, however, that some OS's will write the metadata and the content separately, hence triggering the watch twice for every modification. *That* deserves to go into a comment, as you can't expect future developers to know that (and you may forget yourself).
Be my guest. ;) The method's structure is straight forward and no external knowledge seems to be required.
Guava is hardly typical code. It's used in pretty much every system in Google (and countless other companies) and needs to be ultra efficient and completely correct but mainly it does weird things that you should never need to do in your average web service. This is like comparing NASA code to your college assignment. 
Agree. Unless you have something really unusual or exceptional to add as a comment (to explain why a counter-intuitive solution works for example), comments distract from the reabability of code and are rarely maintained properly (thus lie eventually). Key point about tests : they may document your code (if you are lucky), but they sure as hell do mean an engineer who doesn't understand your solution can more confidently refactor or rewrite it.
I agree, I surely did not mean such cases... Though probably in **such** cases it is better to have thorough documentation of their crappy API rather than vague comments in the code :D
&gt;My rule is, let the code be the 'what' and the comments be the 'why'. Exactly. I even try to put the bug report number over some of the stuff that is inserted later. 
Why are you documenting getters? Commenting everything is a waste of time. Time that could be spent much better. 
 if(customerID == 1938) { handleCustomerID1938(); } Zero comments. Self-documenting code that covers him. And avoid stupid attacks on customers in code. It's always funny until your source code is leaked.
No it doesn't. It means people assume the comment will tell you nothing, so they blank it. Lots of your comments will be pointless re-wording of the function name and if they aren't your function name is probably wrong.
Er well yeah, but I think you are taking my comment rather too literally.
Several reasons. It means that the generated and published Javadoc contains documentations for those methods. That's important enough on it's own, but even more so when you consider that a getter method doesn't have to just return a value as-is - there's no point having a method at all in that case. It could just as easily be a computed value, or delegate through to some other getter, or who knows what. The documentation should tell you things like that. Then there's also the fact that my IDE shows the Javadoc on hovering of a method call, so I can see the reasoning behind the method call, and in the case of a getter see the reasoning behind the field that I'm getting easily without having to jump from where I am to the bean that I'm calling, and then to the field that I'm getting.
Exactly. The number of times I've seen implementation comments remain accurate I can count on one hand. The only possible exception is very clever code or bit manipulation code that may not be clear.
I am not moaning about anything, I think you are taking the point of my comment too literally, and not using common sense.
That's a perfect thing for javadoc comments. Documenting the API is a good thing to do with the exception of trivial methods like straightforward getters and setters.
I would // if 'supertype' is &lt;? super Foo&gt;, 'this' can be: // Foo, SubFoo, &lt;? extends Foo&gt;. // if 'supertype' is &lt;? extends Foo&gt;, nothing is a subtype Is not useful at all 
Don't document and make your code unreadable and complicated. That way you can't be fired. /s
&gt; But the requirement to always write comments means that when it comes to the elements that actually need it then you're already writing the comment so you're more likely to actually write something useful. Is this really true? In my experience it makes people more likely to blindly comment their code with bullshit like: //the widget private final Widget widget; I'm not saying I never comment code but when I do, it's always to say something that the code isn't already saying. If you're commenting every single line of code, you are just adding a bunch of noise. 
&gt;It could just as easily be a computed value, or delegate through to some other getter, or who knows what That's an implementation detail and shouldn't be relevant to your client code. If it's actually expensive to get() then there should be some internal caching in the object or it should be clear from the method name - this is separation of concerns. I shouldn't have to read the JavaDoc to use your code. I don't have time and this leads to errors and inefficient code. &gt;there's no point having a method at all in that case Yes there is, it's called encapsulation. It allows me to change, for example, that the returned value comes from a completely different object instead of the existing object without breaking existing code. You sould stop JavaDocing stuff like this, it's a waste of everyone's time.
This comment was a shot in the dark, but you are surprisingly accurate. Except the caching is happening implicitly, by the cpu caches.
God I can't stress this enough. I'm maintaining a codebase right now where anyone who originally wrote the code base is long since gone. They left behind a mess of 700-line methods with virtually no comments (or making their comment a redundant repetition of the method: Oh your method "sendMsg" sends a message, does it? Gee thanks, WHERE DOES IT SEND A MESSAGE TO??) and terrible variable names like "LJR" and "mtg" that tell me nothing about what's going on. It's a nightmare.
There is a lot of compile time protection against whether return values are null or parameters that can be null thanks to annotation libraries. The name of the exception should be a good indicator as to when it may be thrown or at least why. I think the jab at agile is a bit flippant... If my team were to deliver a library or something to be used by someone external to the team, public interfaces and entry points WILL be documented as they are least likely to change. Core implementation details won't be documented, as although code "ages", comments come off worse from said aging. If an interface changes, I get compile errors, if comments no longer reflect reality, I get nothing. Even worse, the author seems to think that any written comments are going to always be correct at the time of writing. I can't count the amount of times I've been burnt by incorrect comments. I'd much rather have no clear perception than an incorrect one. Although I feel biased towards tests as documentation, I do know and understand it requires a very high level of skill to be able to write succinct tests, it's important to realise that tests often demonstrate the what, not the how. In fact tests that do demonstrate the how are going to be as tedious as documentation to keep up to date (although they'd be a better canary for knowing when documentation needs updating!) I don't think the author would find anyone who doesn't like documentation, or anyone who doesn't aspire to write good documentation, but it is difficult to state whether the effort to write documentation is worth the benefit it may give the few (when it comes to documenting the insides of complex applications.)
But... my code is artisanal, handcrafted, made with love from SF!
You need a billing account before I write code for you, but if you are up to speed on clean code it will be fine without comments. Each class does one thing. It's name describes exactly what it does. If you need to explain it with a comment, refactor the name until you don't need the comment. If you have to write a comment (and occasionally you need a "why this is done" - never HOW -) then you should feel shame as you write it. 
I concur. There's already /r/programmerhumor
For that reason, comments can't be trusted. 
There are about 50 paragraphs to write about why the hell this code 27 is so damn special and whatever idiot VIP requirement and SLA-from-hell requires us to ABSOLUTELY NEVER pass those 35 seconds or we'll get our asses sued. True story. (of course, you may opt to use less cursing in actual comments, although that takes a lot of discipline) This is just to say, I fully agree on the why vs. how argument.
For a client, I wrote a little framework that loads Java code from the database and compiles stuff on-the-fly into a Servlet for immediate use. This feels like PHP, but it's Java and allows the client to release some server-side scripts super fast into production. For this client, the Java compilation APIs were sufficient (as opposed to bytecode manipulation), but you might take this as an idea of why one would do such a thing. For example, Adobe Experience Manager (a CMS, formerly CQ5) works in a similar, more sophisticated way.
http://www.urbandictionary.com/define.php?term=here+be+dragons
I accept that as a reasonable comment, though I still would feel shame as I wrote it.
Then better don't work on 10 year old PL/SQL legacy code :)
more importantly, the almost reasonable variable of twoweeks didn't get refactored. The comment should be deleted and the variable updated to reflect the new reality. (Oh, and I recognize the sarcasm and enjoyed it as it was intended) - edit
&gt; Comment Your Fucking Code! Considered totally outdated and bad practice. Read _Robert C. Martin's Clean Code_ for more information.
You mean, do I have a generic, isolated, simple example of nonreal world code, were even you would admit a comment is required? But hey, sure, I'm up to the task. Since we're talking about foreign code that you may/may not be super competent in the methodology about, let's try C#. Something not Java, but fairly similar. So, here it is: public sealed class UnmanagedHolder : IDisposable { private readonly UnmanagedResource resource; public UnmanagedHolder(string resourceId) { if(resourceId == null) throw new ArgumentNullException("resourceId"); resource = new UnamangedResource(resourceId); } ~UnmanagedHolder() { Dispose(); } public void Dispose() { if(resource != null) resource.CleanUp(); } } For a little info, "resource" here is immutable and cannot be changed, and must be declared in the constructor. What is the format of the "resourceId", what does it actually refer to? Want something more advanced? Quick, why am I checking for null in the Dispose method, is that a mistake? Can you remove it safely? With *real world code*, almost everything can have additional value with comments. Because like everybody tells you, for good reason, the why is not readable from the code.
Ok, so where would you put the comment? What would the comment tell you? Would it explain what the generic variable name resource refers to? If so, can't the variable be refactored to include the same information? What would you have to explain about if(resource != null) resource.CleanUp(); ? What would the comment say here that I can't infer from the context? //this isn't a mistake, don't remove it? /s 
this bug fix... Slow cache performance since JRE 7u06 (August 2012 Java 7 Update 6) http://www.oracle.com/technetwork/java/javase/2col/8u51-bugfixes-2587594.html
Comment sense
Great, name it after a common commandline tool for ultimate confusion.
If you don't know why something is there, changing it and then seeing which tests fail should enlighten you, assuming it was test-driven.
There is nothing clean about limiting methods to 10 or 5 lines of code. Methods should perform a specific function not be broken out by arbitrary number of lines. Sometimes 5 methods in 70 lines is much harder to read than one 40 line method. 
The number of lines is not arbitrary. If you're writing a method that is longer than about 10 lines, it almost certainly is doing more than one task or function and should be broken apart into atomic pieces. One major reason to have small methods is unit testing. Unit testing is much easier when you have atomic methods, as they are obvious cases, not a huge amount of variable output and mocking/stubbing.
I see this as admitting **you failed**, without actually saying it. As in, you could not infer why it was needed. Which is why I have to do it backwards, because if I just gave you the comment at first, why, you'd claim you really could just infer it. So, for your information, why the null check is included, the comment that would appear above that line would be something like: // Resource is null for finalizer if constructor throws an exception. I made it easy for you, by the way. Don't say I didn't give you a chance, I actually put an exception throw clause in the constructor as a really big hint, when the exception might occur down the line. And, of course, it's a simple small example that is surprisingly more complex than it appears. A real class would be even more complex, having a Dispose(bool) method that Dispose() and the finalizer calls, with a GC.SuppressFinalize(this) in the Dispose() method, and actual logic in the class doing things... Did I also mention you can't test for it reliably? If you just say, ran a test throwing an exception in the constructor, nothing would happen in Visual Studio. You have to run it on a separate MSTest instance. And then, you won't get any details of the exception in relation to the calling code because it's on the finalizer thread. So where did the bug come from? Who knows. Why is it null? Good luck finding it out. Even if, you could "infer" all of this, which you couldn't in a real world example of actual code, just think how easy it is to gain ALL this knowledge, with just a single, simple handy comment saying why it's there. And how much time you could waste otherwise.
Wtf is this? You've just proven how bad you are at creating readable code. Why are you setting constructorException to null? What is that, an object even? You set it to var, I have no idea what class you intend it to be. Is it an exception class? How does it relate. It's obviously not the exception itself, or is it? The variable name doesn't reflect what it is. It doesn't even tell you that the finalizer still runs on an constructor exception, which is an important part! This is complete garbage. All because you want to try and avoid a single comment. Why? Does it hurt your pride to admit comments have value? Incredible. Do I need this for every null guard clause? var inputIsNull = null; if(input == inputIsNull) throw new ArgumentNullException("input"); Completely vapid.
I used to work with a really great programmer 15 years ago, but he never commented anything. So I used to tease him about that. He was a very quiet and humble guy, and never said anything in response. Then, one day, he out of the blue explained that his problem was that he'd work with a part of the code for say, two weeks. At the end he'd feel that he understood that part and was tempted to write a comment explaining it. But what if he were wrong? Then he'd just be misleading people, including his future self. (As experienced developers know, wrong comments are really toxic.) So in the end he never wrote any comments. I was impressed with his humility and always felt it was part of why he was so good. I never teased him again after that. His was a special case, though. In general I agree with the author. At least have a comment explaining what each class is for. Don't force me to reverse engineer it out of the code.
As you might have guessed by the fact that I reference the book in the first line, I did. I do not automatically have to agree, do I? And contrary to you I actually address the arguments against my position (e.g. names and tests as documentation).
Because then it would look like this: [Imgur](http://i.imgur.com/Ok9UBOY.png?1) There's already a plethora of ways to find programming jobs. This sub does not need to be one of them. Edit: Grammar 
I also just realized it would be a monthly/weekly post, not individuals so my example does not make too much sense. I believe the message is still the same. There are other, better ways, to find programming jobs.
Great job addressing the arguments. lol
So.... We are not sure it works but due to the glacial pace of language development, we think it will be ready in time. Gotcha. 
Thanks for engaging. Even though I disagree with most points, I appreciate the open discussion. &gt; There is a lot of compile time protection against whether return values are null or parameters that can be null thanks to annotation libraries. This is true for Java and other mainstream, statically typed languages. There are many others out there. Btw, I only pick null because I hate it with a passion. Other guarantees are equally useful to know and hard to demonstrate with tests (albeit less common). &gt; The name of the exception should be a good indicator as to when it may be thrown or at least why. True for some, false for others. What about, e.g., IllegalArgumentException? Which of the arguments caused it? What are the conditions? &gt; Even worse, the author seems to think that any written comments are going to always be correct at the time of writing. No, no, I do not have any such illusions. ;) But I hope that if a team decides on a comment schema they like (strawman example "describe the cause of any checked exceotion"), that there is a real chance that they get updated as code changes (pair programming and code reviews should increase that chance). &gt; I can't count the amount of times I've been burnt by incorrect comments. Same happens with names but admittedly less often. &gt; I don't think the author would find anyone who doesn't like documentation, or anyone who doesn't aspire to write good documentation [Look no further.](https://www.reddit.com/r/java/comments/3dhf9d/comment_your_fucking_code/ct5gcgn)
Don't know, you might have to ask the artist ([like I did](https://twitter.com/nipafx/status/620670505515757569)).
I am [guilty of the same behavior](https://github.com/CodeFX-org/LibFX/blob/835d53e218b3ae11e8642811e4045c3535093a56/src/main/java/org/codefx/libfx/nesting/DeepNesting.java) and understand your arguments. I start to feel differently know. But of course, that is not even the point of the post. I would currently be happy with just having *some* helpful comments.
So instead of benefiting from the abstraction someone created I have to (a) hope that the tests demonstrate every possible scenario which can leave to an exception in an understandable fashion or (b) provoke every possible exception?
Not necessarily because as I said, Gauva does weird stuff (so that you don't have to).
With SQL based databases, some knowledge of indices/query performance is useful. Often it's not the query writing that's the tricky bit, it's getting a query to run quickly.
&gt; Encapsulating the conditionals into their own methods Do I get this right? A method for 'supertype instanceof WildcardType'? That part is actually the most readable for me. :) The line you want to replace might benefit from its own method with a better name, yes. But it would surprise me if the comment would not still help with bridging from the condition to the determination of the return value.
The fact that you've gotten so many up votes scares the fucking shit out of me... ...and also, unfortunately, confirms what I know from my 25+ years of professional software development experience: most developers simply aren't very good.
[I don't think Guava does wird stuff.](https://www.reddit.com/r/java/comments/3dhf9d/comment_your_fucking_code/ct5ttrp) I guess if you use `if`/`return`, you don't need `if`/`else if`.
We can debate what constitutes good comments versus bad, where the line between too many comments and just enough is,.all that kind of metric stuff is up for debate... ...but if you call yourself a "professional" developer and you don't believe in comments then you're NOT a professional and a fucking idiot on top of it. I'm not even going to try and mince words. This is the way it is. If you disagree then you're a moron and I hope you never have a job in this industry because you'll do more harm than good.
I mean weird in the sense in that it makes heavy use of things like reflection, bit manipulation and low level data structures when there are simpler but less efficient ways to achieve the result, which you shouldn't have in your average Java service. This type of code does benefit from comments but most people aren't (and shouldn't) be writing this type of Java code.
Comments should be code reviewed. It's precisely the same principle as having a function named 'addOne' that gets changed over time to do subtraction. If you're lazy and unprofessional, you end up with something misleading. 
I wish I didn't look further... Can you describe what your thought process is when documenting a project? Is it a case of document all the things or do you have a few situations in which you will avoid commenting all together? I do genuinely believe that a projects internals being documented can lead to more troubles than gains but I work in a team that exclusively pairs on implementing functionality. I can imagine I'd appreciate some breadcrumbs if that wasn't the case. When I say document and documentation I am strictly referring to source code comments.
I don't consider official documentation and comments to be related at all. Some people may consider comments to be documentation, but they're only code explanation at best. Writing documentation and examples of your API has nothing to do with commenting the code. That's like saying https://api.jquery.com/ is the same as reading the jQuery source code, since it's commented heavily.
Are you serious? I put a sarcasm tag. You can see it just the re. I didn't think anyone would be so stupid as to need it. Are you? Edit: read my comment again without being a stupid cunt if you can. Id have been nicer, byt you're clearly a twat. Edit2;i'm very drunk. You're still a twat
This is only a simple example, but the code reflects what the comment says, everything in the Guava example could be written in intention revealing style. I think the reason it looks complex, is the comments are explaining co &amp; contra variance. They probably shouldn't (the definitions can be retrieved from StackOverflow if needs be). They could instead encapsulate the logic / rules in method names. Probably at the expense of some performance (which could be optimised later - as others have said, because of performance concerns Guava is not the best material for this type of thing).
I like you.
But how would he be wrong about his own code? He presumably knows what it does.
I'm disappointed that the project contains [legitimate unit tests](https://github.com/lhartikk/JunitQuest/blob/master/src/test/java/org/tsers/junitquest/testgenerator/ArithmeticMethodsTest.java). Eat your own dog food, JUnitQuest! (plus i'm curious to see the kinds of tests it generates)
It absolutely works. I've got it running on a couple hundred different apps with heap sizes ranging from less than a gig up to 96GB and it works like a champ. The people who use the default garbage collector are the people who don't tune a garbage collector, and G1 is by far the best behaving without any additional tuning. There's a very very very small niche where cms might be better, for some batch applications the parallel collector might be better, but for most other things G1 is the best thing you can use. 
I pretty much consider all code bad that is more than an hour old, including my own. To be safe.
I love
Where is cms better? From my reading about g1 it sounds like it is superior to cms in every way. The places where g1 stumbles it sounds like you should use the parallel collectors.
If you want to do modern stuff and work in the "nice" fashionable companies (you know the ones), then get to understand a bit more than your SQL-family databases (those are cool too and are a requirement in general). Try to know about SQL and NoSQL dbs. And cover every kind. So you need to know about: * SQL/RDMS: I advise knowing to use PostgreSQL and MySQL (first is the choice of the true pro and the other is the tool of the IT guy that has no authority to make his own decisions). * "Bigtable" dbs: know about Cassandra at least, or HBase, look into other minor players in that field too. * "Document based" dbs: MongoDB and CouchDB are the main one. Look into ElasticSearch even though it is a bit more than a DB. * "In-memory" storage, like Redis and Memcached are very useful to know about. * I advice to know about Graph dbs too. Look up Neo4j and OrientDB maybe. There is a lot more if you want to become a knowledgeable backend dev, but knowing about this kind of things in general is useful nowadays even if you are a front-end/client-side dev. What you need to know is: Understand CAP (even though it is not the only thing you need). What defines each group. What they offer compared to the other ones. When you should one compared to the other. What is the advantage of transactions, and when you do not need it. That should get you started in the world of DBs ... and I hope one day you might forgive me for what I have given you.
This is a sweet article, thank you for sharing.
// Resource is null for finalizer if constructor throws an exception. You could have made a unit test with sut = new UnmanagedHolder(null) and cover that case. That unit test would act as an executable comment: not only would it document that behavior, like the comment, but it also would alert (with a failing test) the user if the behavior is inadvertently changed. 
But be careful as much of the hate evolves during discussion, not really originally from a critical blog post.
It was a big code base and very complex, so, no, there was always the possibility that he was not 100% sure what it did. Plus, there was the humility. I think part of what made him so good was always being alert to the possibility that he was wrong.
You've mistaken the issue. The case to be covered is a NullReferenceException in the Dispose method when it is called by the finalizer. Catching an exception from the constructor is not enough. It's the dispose exception that is not cover-able. Without the null clause in the dispose function (not the constructor), you'll get a NullReferenceException, **but you won't be able to test it from Visual Studio**. You'll have to run a separate test instance to be able to hit the case, which means you can't make a test for it as you can't guarantee the environment will throw anything and it happens whenever the finalizer thread wants it to anyways (which is likely not within the test method). In other words, you can't test this case. So you can't resort to any tests acting as documentation argument.
Damn, that misunderstanding crops here and there. For me Javadoc and the like are just a special kind of comment. So when I say "no comments" I mean "literally no non-executable line in any damn file". So I guess we agree because my point is not to have people pepper their code with stupid inline comments like "loop through the list". I want some documentation saying "returns all items the customer with the specified ID ordered; throws an Exception if there is no such customer" or some such.
To add to this response: I recommend the book "SQL Performance Explained" (http://sql-performance-explained.com/) Pretty short book, you can get through it in a few days.
This is ace, it essentially automates what i did as a junior dev, write tests that do nothing!
I worked somewhere where this was the policy, must have 80% coverage. That was it, no real thought to it. 
Otherwise, you can inject into UnmanagedHolder a Releaser class whose responsibility is to cleanup unmanaged resources, as suggested in [Should Dispose methods be unit tested?](http://stackoverflow.com/questions/3259456/should-dispose-methods-be-unit-tested#answer-3262010). Anyway, the bottomline is: if tests are hard to write, there's the chance the design can be improved. In our case, the UnmanagedHolder was violating the SRP; its responsibilities were 2: it holded the resources (1) and it created them in the constructor (2). That is, it was both a Resource Holder and a Resouce Factory. This is an anti-pattern that can be improved. And with the improvement, come testability and no need for tests. /u/rfinger1337 requested "a class that is is beautiful, self-documenting, well-written, pristine code". I think your snippet was not the right example. The improvement we did with DI is a better one. And I think you can agree that the tests we were able to write with the improved design are clearer than the comment // Resource is null for finalizer if constructor throws an exception.
I literally just spelled it out for you. &gt; It's due to dependencies on libraries like Objenesis. If there is no fallback then it's going to break as soon as you hit related code.
Are you sarcastic? Dependency injection won't fix anything here. What happens when you pass in a null resource to "UnmanagedHolder"? Oops. Not only did you not fix anything, you created a bigger issue. The example class didn't have any logic around the resource property, but safe to say, a real world class will. You still need a null check there. Not only did you not avoid an if statement, in your current version of the code you completely fail to even consider that. You've replaced good code, with bug ridden crap because you want to avoid a single line of comment. That's right, a single comment and you decide to completely warp the code. And it didn't even work. Again, once you add the null check as needed, you then must also add the null check for the finalizer. You failed badly. Also, you added an implementation for UnmanagedResource. No, I didn't give one for a reason. That there is even a constructor for UnmanagedResource is just an implementation detail that may or may not be true, may or may not have an interface, such has open handles or external representations. If I have a resource **that has to be disposed**, creating it outside of the class that utilizes IDisposable doesn't fix anything. You have to dispose it somewhere, after all, that's what the IDisposable pattern is there to handle. You're basically trying to get around the very pattern that is there to deal with this.
Ah, another post. Why reply to yourself, I might miss these things... I see where you got your implementation from the previous post, although, sorry, it's bug ridden when you pass null as the constructor. In this case, there isn't a chance for the design to be improved. I'm sorry, I stacked the deck against you with my example, it is pretty much the perfect example of a case were a comment is the best way to go, because part of the issue is that how the language handles finalizers creates an issue that makes it hard to test. I mean, take one second, think what happens when you pass null in the constructor, and that you didn't call dispose! You still get the finalizer call to throw an NullReferenceException. Which, by the way, you've mutilated SRP. Holding something is not a responsibility to track. Furthermore, you've fallen into a bad trap of applying patterns to everything instead of actually bothered to realize a patterns strength. In this regard, you are trying dependency injection on something that shouldn't be done. The reason being, is that your factory creates objects that must be disposed, but don't have to be contained by the holder. You have an implicit connection there, but it's not defined, a programmer not aware of your shenanigans can use the factory to get an instance of the resource, and then not dispose it! It causes resource leaks, and there is nothing to stop them. Further even, you have leaked implementation details by utilizing such a setup. Patterns have trade offs, you didn't analyze these tradeoffs, you only looked at the pros then pretended the cons don't exist. And in the end, your given pattern not only didn't work, as I said in the other comment, it made things worse. This is what happens when you try to use patterns blindly. And then, I find it incredible how you've already concluded that your completely bad revision is automatically better... when in fact, it's worse in every imaginable way.
Absolutely an option. The why still needs to be documented *somewhere* though. Basically what I'm saying is that it's easy for me to tell what you're changing and how, but unless I know the reason behind why it's being done, it's a giant nightmare for me to maintain it. Abstracting out the handling of bad data doesn't solve that specific problem if the abstraction isn't documented.
I bet you think also http://stackoverflow.com/questions/3259456/should-dispose-methods-be-unit-tested#answer-3262010 is crap (like you gently defined my snippet) . Haters gonna hate ;) 
No you didn't. I'm still not seeing where Hibernate is using Objenesis. According to Maven it's a test dependency. Hardly a problem.
I think automated unit test are generally overrated. They take a lot of resources to create and maintain without providing that much value. It's basically testing for the scenarios I know about. That is not the kind of error I usually make. I am much more likely to misunderstand a requirement or miss a scenario. They do have some value if you have a lot of resources but I find system testing through the GUI to be much more effective for time spent. I will go hide in my bunker now to dodge the incoming down votes.
No, you're missing my point. Just because the code restrictions on resourceId aren't on the given piece of code you're looking at, doesn't mean such restrictions aren't on it. As in, if I was calling an external resource, which I'm passing that string to, that has those restrictions. You can't look at the code, it's external and not available to you. **That doesn't mean those restrictions aren't there**. Since you don't have access to the code, and we're under the assumption no comments at all because readable code, guess what? You have NO way to know that restriction exists. Even though, it can. Writing additional code that restricts it at this level as well is just bad. That's bad design, repeating checks on every layer that the string visits, but I don't think you'd ever do it in the first place. You're just being argumentative for argument sake. &gt; No... The assumption here is a null check is needed because there is a null check in the code. You made a second assumption, not invalidating the first one. Programmers make mistakes, you assuming code is correct is already a bad assumption especially when you have people having to maintain your code. Looks like you want to avoid the issue altogether. Quite frankly, that kind of attitude doesn't make a good programmer. Why code exists is just important as it existing in the first place, and since people have to maintain and fix your code down the line (even if it's correct now, doesn't mean when assumptions change that it's still correct) you pretending it must exist is not an argument.
Hey, First - it was certainly not my intention so spam. The weekly reviews are mostly Java, so I figured they're relevant. As for karma, some get positive feedback, some don't. I didn't however know that they're reported - so, if these don't fit the section well, I'll definitely stop sharing them. Cheers. 
&gt; Making your code longer, more complex and harder to read to make it slightly easier to write a unit test is a bad practice. Here's the fundamental difference between you're idea of clean code and Bob Martin's; not that he's perfect, but I agree with him in this case. To me, a "hard to write" unit test is a code smell showing I need to clean up the underlying code. A "unit" should be as small and as possible, and hard to break down further. &gt; There are some good points in those books but sometimes people take a general idea and try to make it a hard and fast rule with poor results. Complete opposite for me. My code is 100 times better than it used to be when I just did whatever with long methods, little to no testing, and poor design patterns. I'm evangelizing these books and constantly downvoted because of it, but I don't care because they changed my life as a coder.
&gt; No, you're missing my point. Just because the code restrictions on resourceId aren't on the given piece of code you're looking at, doesn't mean such restrictions aren't on it. &gt;As in, if I was calling an external resource, which I'm passing that string to, that has those restrictions. You can't look at the code, it's external and not available to you. That doesn't mean those restrictions aren't there. You're no longer describing comments... You're describing documentation. Specifically you're suggesting that there is a need to document external APIs in client code comments. If the value of resource id is more restricted than string, it should be it's own type, where the restriction can be coded and read from code. &gt;You made a second assumption, not invalidating the first one. Programmers make mistakes, you assuming code is correct is already a bad assumption especially when you have people having to maintain your code. And you're assuming if there was a comment *it* would be correct and that it would be in synch with the code... 
They would fit the subreddit's theme perfectly well, but it seems that the user base doesn't want them (karma + reporting). Your other contributions are commonly well received, but for some reason unknown to me, the reviews aren't.
This post belongs in /r/javahelp as is stated in many places here. (The big, red button "Seek Programming Help", the big, red banner that appears when hovering over the *submit text* button, the sidebar, and lease the text in the *submit* textbox.) But, according to the rules of /r/javahelp, nobody will actually do the programming for you without any effort on your side (as your post currently stands). Please, before posting there, read and follow the posting guides of /r/javahelp. **Post removed:** wrong subreddit.
&gt; You're describing documentation I hate to apparently bring you this news, but comments are documentation. In C# your autogenerated docs are created by documentation comments. It's similar to how javadocs work. &gt; If the value of a resource id is more restricted than string, it should be it's own type That's complete and utter nonsense that is not adhered to by anybody anywhere. The type would look like what exactly? Nothing would be more readable by making it a type, either. Exactly how would it? Also, check with me how many cmd line programs require or use types for arguments like that. Absolute nonsense. &gt; And you're assuming if there was a comment it would be correct and that it would be in synch with the code... I'm not assuming shit on this. Yeah, since we're talking about my code, and I know exactly what the issue is, it is correct and is in sync with the code. But since the comment says **why**, and not what, you can easily verify it yourself. Not that you want to deal with it, of course, which is why you're avoiding the issue outright.
I mean, specifically, did you get that your solution **did not fix the issue**? Are you reading? I specifically told you why. What happens when you pass a null into the constructor? What happens when it disposes? A NullReferenceException. It's buggy code. It doesn't fix anything or solve the reason why a null guard is required in dispose methods that have finalizers. I mean, it has the bug that the null guard protects against right in it, and then some! By the way, I have no problem testing that things are disposed with an actual implementation of my provided code. This is an issue with the **finalizer**. There isn't even a finalizer in your link, which is required for unmanaged resources otherwise a resource leak will occur. Take a little time and read what I said, as we're not talking about an issue were resources aren't disposed. We're talking about an issue under which the finalizer throws an exception when the object is not fully created. Not that you care, you've shown extreme resilience to even understanding the problem in the first place.
&gt; (yes, api is defined in source, but I hope you see the distinction) No, I don't see a distinction because there is absolutely no distinction. You just don't like it because it ruins your argument. Javadocs and xml documentation comments are comments for your code. The article in question doesn't differentiate between the two. Other people responding me don't, most of the people in this thread don't... but you do, because that's the argument you want to make. &gt; It would model the id Nothing about it would automatically model the id. Nothing about creating a new type changes your initial argument I already rebuked. You wouldn't *ever* create a new type for this instance, there is absolutely zero valid reason to do so. It's the exact same thing as validation code, which is all the type would be for. Okay, so you create this new type and name it what? Then you take what for a constructor? A string, right? Tell me, maybe you might make say, a javadoc or xml documentation to say, expose what format the string requires? This is what I mean, nothing changed. You created a new type for NO reason what-so-ever. And again, the restriction is not in the current layer or code you'd able to modify. Guess what, in the real world, you have to work with other's code that you may not be able to modify. &gt; Without any C# experience, I'm assuming there is some condition under which it could be null, I don't think it's a mistake, and I wouldn't feel it was safe to remove it. This isn't about your feelings. This is about understanding code. It takes a single line comment to tell you why the value can be null, even though it's immutable. But a lot of you are really, **really** trying to get around a single line comment that fixes everything. One guy introduced completely bug ridden code as something... superior. But, sure, you try too. &gt; I'd suggest refactoring the null check into a method "boolean initialized()". This is the general idea behind self-documenting code. ... that's... terrible. Yeah, guess what, a null check is checking if something is initialized. That's already inherent. That doesn't document the issue of **why it's needed in the first place**. Null checks are all over code, do you make an initialized method for all of them? Because that's a lot of dumb work, that doesn't actually help anybody or make anything clearer. &gt; I'm saying this is a bad example of code that should be documented. You just admitted you don't even know what's happening. It's a perfect example of code that should have a comment. Do you know how many people know a finalizer still runs when an object constructor throws an exception? Not many, relatively. A comment explaining this as the why the null checks exists is extremely valuable. Because knowing WHY code exists is extremely valuable, and it's not always clear from reading the code.
as someone who works heavily with the stack that OP is refering to I'm interested in the pros/cons of different tools. Can you compare gradle vs maven as well as Travis vs Jenkins? Guice is definitely a good call.
I think Gradle is easier to pick up, integrates well with Maven, and I like groovy much more than XML. I just assumed that OP doesn't have a CI server setup so why spend time setting that up when he could use a free existing solution.
20% off of a 100% scam.
&gt;No, I don't see a distinction because there is absolutely no distinction. Javadoc is for people using the code, while comments are for people maintaining it... &gt;Nothing about creating a new type changes your initial argument I already rebuked. Example: public class ResourceId { private static final Pattern VALID_PATTERN = Pattern.compile("some pattern"); private final String id; public ResourceId(String id) { if(VALID_PATTERN.matches(id) { this.id = id; } else { throw new InvalidArgumentException("Message " + id); } } ... } Tell me you couldn't honestly figure out what the allowed format of the id is without additional comments. &gt;And again, the restriction is not in the current layer or code you'd able to modify. Guess what, in the real world, you have to work with other's code that you may not be able to modify. This seems as relevant as what happens with the cmd line... I just don't see what it has to do with what we're talking about. We talking about code *you* are writing right? &gt;Yeah, guess what, a null check is checking if something is initialized. That's already inherent. That doesn't document the issue of why it's needed in the first place. Personally, I think the method is fine as is, but I take your point. Let's change the name of the method to "wasInstanceInitializedSuccessfully". &gt;It's a perfect example of code that should have a comment. Do you know how many people know a finalizer still runs when an object constructor throws an exception? Not many, relatively. A comment explaining this as the why the null checks exists is extremely valuable. I suppose it depends on who your audience is. In general, I don't think it's a good idea to write and comment your code as if it's a tutorial for people who are unfamiliar with the language. I mean what are you going to do, include a similar comment in every class that implements dispose? That seems reasonable? Do you also copy/paste the equals() contract every time you implement equals? If this is simply a known pattern for how objects are disposed in C#, I'd argue even the named method is unnecessary.
... OOHHH SQL2o not SQL2Go. I misread your previous statement and searched the wrong product, was super confused for while. SQL2o looks interesting but I'm super sleepy at the moment so I read more into it tomorrow.
&gt; Javadoc is for people using the code, while comments are for people maintaining it... Once again, people maintaining code are also people using said code. &gt; Example: The current issue being talked about is that the id can fit multiple formats. Your example does not reflect this. Furthermore, it is no different than just having that... well, when it's used. You have no reason to make this a type. You could just as easily put the validation on the method that takes in the string parameter and everything is the same. Third, and this is important, what do you do with id? Do you expose it? That's not very good design itself, and the only reason you have this type is to do work in the constructor which is backwards. And, even after all this, if you didn't have access to the code for the type you just created, as again we're talking about code you potentially don't have control of, it's still a black box. Nothing changed. You create a new type, pass in a string, or just pass in a string to a method... zero change except you made more work pointlessly and more code pointlessly. &gt; Personally, I think the method is fine as is, but I take your point. You really haven't. Changing the name doesn't change anything, you still didn't give **why an initialize check is needed in the first place**. This will not change with a method doing null checks for you. You have not resolved the issue, you have not made the code clearer. You have added code for no benefit. &gt; comment your code as if it's a tutorial for people who are unfamiliar with the language Experienced professionals with over 10 years work experience could miss this. I very specifically picked an incredibly hard problem. The solution is simple, the reasoning behind why it occurs is something most people do not know, and won't deal with. It's already a rare occurrence to deal with unmanaged resources in the first place, much less also adhering to immutable practices. &gt; include a similar comment in every class that implements dispose Most classes don't use unmanaged resources and don't need a finalizer, thus this issue does not actually occur. Or go with immutable designs. The disposable pattern applies to other managed objects should they implement the interface, which is as far as most work on this goes. So, we're talking maybe one class every few projects, if even that. So yes, easily. &gt; equals() contract every time you implement equals? Yes? That's part of documentation. I thought you said documentation and comments were different, apparently not. Java makes it easy, just use @inheritdoc and presto. So easy, no work required. Because I document everything, it also makes the code consistent, which is very pleasing on the eyes.
&gt;Once again, people maintaining code are also people using said code. It's fine if you didn't know the difference before, but I've explained it to you now. Now you're just being difficult. People using your code are not necessarily maintaining it. &gt;The current issue being talked about is that the id can fit multiple formats. Your example does not reflect this. The fact that it isn't complete is what makes it an example... The purpose is to demonstrate an approach for restricting id format. &gt;Furthermore, it is no different than just having that... well, when it's used. You have no reason to make this a type. You could just as easily put the validation on the method that takes in the string parameter and everything is the same. Until you have to write another method that has to handle the id... Do you copy/paste validation code? In any case, "validation on the method" should be self-documenting. Again, there might be exceptions where validation is somehow unclear, but in general, the code should be enough. &gt;Third, and this is important, what do you do with id? Do you expose it? That's not very good design itself, and the only reason you have this type is to do work in the constructor which is backwards. Not sure what you mean... The reason for the type is to model the concept of a resource id. &gt;And, even after all this, if you didn't have access to the code for the type you just created, as again we're talking about code you potentially don't have control of, it's still a black box. I still have no idea what you mean by this. If I "don't have control" of the code, I can't modify it *or* add comments to it... If this black box code expects an id in a specific format, I can model that id in the code I do have control over and simply extract the string representation when I need to pass it on the other code. &gt;You really haven't. Changing the name doesn't change anything, you still didn't give why an initialize check is needed in the first place. This will not change with a method doing null checks for you. You have not resolved the issue, you have not made the code clearer. You have added code for no benefit. I think I did. To me it's clear the method is checking whether *this* instance was initialized, and not the resource. &gt;Experienced professionals with over 10 years work experience could miss this. But even in this case, the fact that the null check exists is a strong indicator that this object could be null... &gt;I very specifically picked an incredibly hard problem. The solution is simple, the reasoning behind why it occurs is something most people do not know, and won't deal with. It's already a rare occurrence to deal with unmanaged resources in the first place, much less also adhering to immutable practices. I can see how a comment could maybe educate the uninitiated, but it doesn't add anything to *this* code. It makes it more likely that people that read it will implement their own dispose properly... I can see value in that. &gt;Yes? That's part of documentation. I thought you said documentation and comments were different, apparently not. Are we now in agreement about the difference? &gt;Java makes it easy, just use @inheritdoc and presto. So easy, no work required. Because I document everything, it also makes the code consistent, which is very pleasing on the eyes. But... that doesn't materialize the comment in the code.
Your process sounds great. The only thing I'm not seeing is clear requirements for the game. However I can see why you probably left them out on purpose. Don't get caught up in maven vs gradle, spring vs juice, Jenkins vs team city. Focus on making sure you have a tool that solves the problem at hand. Once you have one you should just run with it. If you constantly argue the pros and cons of the tools or libraries you will go in circles and not get anything done. Good luck! 
&gt; It's fine if you didn't know the difference before, but I've explained it to you now. [...] People using your code are not necessarily maintaining it. You didn't "explain" anything. You claimed it. And I declined your claim. And this is not what was said. I didn't say people using your code are the same as those maintaining it. I said people maintaining your code are people using it. You flipped it dishonestly, because you know how I said it, is right. The maintainers of your code need the documentation too, buddy. &gt; The fact that it isn't complete is what makes it an example... No, listen, it doesn't even fit the situation, at all. It's not a valid example to mine. The **important aspect** of my example was that the string could have two formats. That's a vital aspect to it. Your approach is completely flawed, even beyond that. &gt; Until you have to write another method that has to handle the id... Do you copy/paste validation code? Do you not know what static methods are? This task is not the job of an object's constructor. &gt; In any case, "validation on the method" should be self-documenting. Don't care how self-documenting you think it is, because **once again**, you don't have access to the code that validates it, is what the example given centers around. &gt; The reason for the type is to model the concept of a resource id. But you're passing the resource id to an external resource. You have to do that somehow, which means you have to expose the property in the object. It breaks encapsulation, because you've created an object for no real purpose. You have no need for it to be an object. &gt; If I "don't have control" of the code You can't even read it. This is what happens in the real world working with others and 3rd party libraries. &gt; I can model that id in the code I do have control over and simply extract the string representation when I need to pass it on the other code. And we're back to square one. I rebuked this, **but you ignored my comment** and just decided to go a new type route. Since you are not the consumer of the resource id, you should not be doing the validation. You are not the judge of what resource ids should be valid, that is the responsibility of the 3rd party library or so forth. If you switched libraries, suddenly you have to rewrite your validation code maybe, even though you are not consuming the data itself. It's bad design. &gt; To me it's clear the method is checking whether this instance was initialized, and not the resource. **Again,** this is not answering **why the instance would not be initialized**. It makes zero sense, because how can you call a method on an object that hasn't been initialized? Nothing is clearer, because you never have dealt with the issue in the first place. &gt; the fact that the null check exists is a strong indicator that this object could be null... It's an indicator of nothing. Null guards are common even in cases were they'd never be null. This is not an excuse, nor justification. This does not resolve the problem, this does not make it clearer. &gt; but it doesn't add anything to this code. Yes, it does. It explains **why**, which is very valuable to reading the code and helps maintainers not screw things up while going though things. &gt; Are we now in agreement about the difference? No. I pointing out you're arguing with yourself. Nothing about what I said changed anything at all. &gt; that doesn't materialize the comment in the code I'll take how do Java IDEs work for 200 Alex. That it inherits the same documentation is a "materialized comment" itself. Also, you now referred, once again, to documentation as comments. Still arguing with yourself...
your intention is to run spring and hibernate directly on the end user's ios and Android mobile devices? I don't know much about those but I would assume that won't work easily. can somebody with experience chime in here? 
&gt; Surely you see where I'm going with the example I'm rather amazed at how much code you want to add just because you want to avoid a single comment. I also will once again, point out that a static validator is the superior design to use instead of creating a new type, which you didn't actual ever deal with. It's also how it's normally done, where I've never seen somebody try your method of creating a type with validation in the constructor only to break encapsulation anyways. &gt; if your code works with all strings, then there is no reason to comment the format... Plenty of reason. First off, my code doesn't work with all strings, it only accepts all strings. Whether or not the code works depends upon the consumer of the string, and giving documentation of that doesn't hurt and only helps. &gt; Bug ridden code... I don't know what object refers to. Compiler issue, easy fix. Your issue was a fail in logic. But sure, let's fix it: var resource = new X(); if(resource != null) resource.CleanUp(); Now you have to deal with it and admit you're full of shit. But you won't do that. &gt; It's not about randomly removing null checks either. Nobody said anything about randomly doing anything. Strawman.
For the 3rd time, do you think http://stackoverflow.com/questions/3259456/should-dispose-methods-be-unit-tested#answer-3262010 is crap too? 
Very annoying and violent discussion with you. I tried improving the design. I might have failed, of course, and I suggested another approach considered good on SO. I still think your original snippet had design flaws (a constructor instanciating another object in the constructor, impossible to test),. But you seem much more interested in being rude rather than trying to find a solution together. It must be very pleasant to pair with you man. I quit. Enjoy your lack of doubts. Have a nice day. 
You should consider making your architecture insulated from chosen technologies. You should find if you do this that testing your game will be a lot easier. If you talk about parts of your architecture in terms of HyperSQL then you'll find that concepts from HyperSQL will leak into your own application domain. Soon you'll be "insertPlayerRecord"ing in places, then if you ever move to a flat file system it won't make sense. Look up ports and adapters (hexagonal architecture) and see if you can pull out any of the benefits. I've never used spring myself but doing the MVC portion yourself would likely make things easier to test I imagine. Good luck with it!
Just focusing on the mobile port here. Hibernate and Spring are a big overkill on mobile and might not be easy to get going (at all) on both Android and iOS. If i understood correctly, you really only store game state locally. In that case i'd suggest going with H2 or Sqlite (counter to the original suggestion you got). JDBI is a nice solution between JDBC and a full-blown ORM like Hibernate, and light-weight enough for mobile use. You'll be in a world of pain using Maven for Android/iOS (which is a shame, considering Gradle is less mature than Maven). Go with Gradle instead. Concerning JavaFX: be careful, it's definitely alpha quality on mobile, with unsupportes features and performance issues. Given you simple requirements you'd be better off using native UI, sharing just you business logic. Also, in it's latest mobile iteration, you will have to use Gradle.
You don't really need hibernate. Spring has basic SQL mapping features.
I'd honestly just get started with IntelliJ Community edition. Eclipse is ok. It's not awful like people like to complain, but IntelliJ just makes the process so much more enjoyable for me.
Please Click the link for the poll. Which is used to easily share your opinion with others.
A nice example for both an [IDE flamewar](https://www.reddit.com/r/java/comments/3dd522/the_big_mod_ideas_thread/ct4dt7b) and [spam](https://www.reddit.com/r/java/comments/3dd522/the_big_mod_ideas_thread/ct4eh8c) submission like mentioned in the [Big Mod ideas](https://www.reddit.com/r/java/comments/3dd522/the_big_mod_ideas_thread/) thread.
A lot of people complain about IDEA not being able to auto compile on save, but I'm pretty sure it supports that now. 
That's perfectly fine, maybe it's not the right forum for the reviews. I write these mainly for my email list, so these are readers that already know my work. So maybe it's more for that audience and it doesn't fit well here. Anyways, thanks for letting me know. Cheers, Eugen. 
To clarify yes I probably woudln't be looking to move to a new datastore unless something else came out that's bigger/better/faster/stronger. Also I assume that this is pretty platform agnostic? Also nice link find. Wow did not realize just how slow Hibernate was in comparison to everything else. 
It was more using those techs to build the code, then have it bundled as an executable. Although I might be thinking of this the wrong way.
In Settings you can tell IntelliJ to automatically add unambiguous imports as well as set some defaults for ambiguous imports like List. 
Really! Thanks for the tip!
Netbeans. I just love how it handles pom and build files as the project files. IDE actions map to Ant targets/Maven goals. Integrations out of the box with GUI designers, Java profiling tools. Also quite good support for web development. It is great to have two way editing between Java and JSF/JSP pages. HTML 5 and JavaScript support is also quite good, in terms of auto-complete, static analysis, tooltips showing documentation. And best of all, no workspaces!
&gt; We all know comments tend to get out of sync with the code. This is no law of nature, quite the contrary, it is a consequence of negligence. I am convinced that intelligently placed and formulated comments, an agreed-upon documentation-schema, pair programming and code reviews can eliminate this problem. &gt; We also know that expressive code can be as descriptive as comments. My argument in the post is that this is an illusion. I listed a number of things that code is inherently unsuited to express. And I hinted at the fact that some things just take to long if they are only documented in code. Both is ok and no argument against clean code. Just pick the right tool for the job. PS: Note that I include API-docs in comments, i.e. for me "no comments" also means "no API-docs".
I was expecting 90% eclipse. Why is IntelliJ so far ahead in the poll? Can someone describe from their experience, what IntelliJ does better than eclipse?
@/u/desrtfx : I had some kind of feeling he couldn't stop posting these videos, despite [your warning last time](https://www.reddit.com/r/java/comments/3c0mo6/advanced_java_tutorial_8_find_out_the_java/csr84hv). 
Waning made true - banned.
Insane discussions you two got yourselves into. Keep at it! ;) Just chiming in to clarify something: &gt; If you insist there is no difference between javadoc and code comments, we can agree to disagree. Yes, there is a difference. What you seem to call "Javadoc" is a specially formatted code comment that can be automatically processed by the Javadoc tool (as per [Oracle documentation](http://www.oracle.com/technetwork/articles/java/index-137868.html)). [Other sources](http://blog.codefx.org/techniques/documentation/comment-your-fucking-code/#comment-2140446697) agree on that: documentation in form of code comments are, you guessed it, a form of code comments. So what I am complaining about is not "too little asinine 'loops through the list'-comments, but _no_, _comments_, _at_, _all_!
I'd go with a MEAN stack using Red Hat Mobile (based on top of node.js) on top of Red Hat OpenShift (based on top of their PaaS which uses Google Kubernetes, Docker, git, Jenkins). 
https://en.wikipedia.org/wiki/Cryptographic_hash_function states that one of the required properties of cryptographic hash functions - impossibility to find a byte sequence *s* for the given hash value *h*, so that f(s) = h. xxHash, same as Murmur, City and other functions, use only reversable operations, so finding the 8-byte sequence, hashed to the specific value, is as easy as applying the reverse ops to this hash value 
To answer your questions directly, yes, those programmers need additional training. I don't know about 3 years of Spring bootcamp, but we need to start having professional standards if we're to be taken seriously. I probably came off too harsh, but I do think that if you don't understand something, you shouldn't work with it. I'm pretty good with C, not a rockstar, but pretty good, but I don't understand Scala one bit. It would be wildly irresponsible of me to take a Scala job, despite my experience/ability with C or "average level of knowledge". Take this code for example. I get single inheritance (who doesn't?), but I don't really understand bounds in that context, and the comment `&lt;? super Base&gt; is of no use in checking 'from' being a subtype of 'to'` doesn't really help, because I don't understand what `Base` is. I'm assuming Guava has an extended type system and these are Guava concepts. But all that aside, if I were to work on this code base, I would need additional training. I have two major problems with comments: 1. Some coders end up writing more comments than code. If that's happening, you're not coding, you're documenting, and documentation doesn't belong in code, if only because it's hard to find. 2. A lot of comments just translate the code into human language. Most coders are only doing that to get over their boss' lame "comment your fucking code" requirements. But if you need that, you really shouldn't be coding. And when I say "you really shouldn't be coding", I mean you might introduce a bug that exposes people's private information, or loses tons of money, or creates a security problem for 80% of the world's web servers, or loses precious data that can never be recovered, or destroys hardware, or blah blah blah. It's hard enough (impossible?) for world-class programmers to get that stuff right; if you need code translated into English, you have no chance of getting it right. Harsh maybe, but true.
I don't think anyone's arguing against API docs here.
People voting for Eclipse have possibly tried IntelliJ and didn't see what the fuss is all about. A bit better in some ways, possibly, but when you believe Eclipse works fine, it's not worth switching over. IntelliJ has its own limits, it is not a panacea. NetBeans is ok too. The tool you already know is the best. As for starting from scratch, I don't know, maybe pick the one the rest of your team is using so they can help you?
So it's purpose would be for stuff like in memory hashtables? 
And probably bloom filters. Also, at this speed, the functions wouldn't be very useful for password hashing, as you want very slow hashing functions for that. 
According to [different sources](http://blog.codefx.org/techniques/documentation/comment-your-fucking-code/#comment-2140446697) API docs (like Javadoc) are just a special kind of comment. That was also my understanding. So I ranted against not having *any* non-instructions in a code base because that is what I am currently facing.
That's a fair point, thanks.
Feawen likes this.
I like to use notepad++.
Right here: http://i.imgur.com/Drp0gYS.png
I got it already, but thanks anyways
I don't see a single job post on this subreddit, why are people proposing solutions to a problem that doesn't exist?
Yet another solution to a problem that doesn't exist. Where are all of these joke posts and image posts on r/java? I can't recall the last time I saw one.
Oh now I am reading your "Note from the future" at the top of the post. Yeah I think most devs don't conflate API docs with comments, so it's likely that's the main miscommunication here. In fairness (like you point out), a lot of documentation tools (javadoc, doxygen) use special, language-specific comment block formats for API documentation, so maybe it's easy to conflate the two. But those tools work that way because that workflow actually *is* convenient, compared with combing through the source code to find a big comment block explaining the architecture in a now-unrelated source file. Agree: no API docs would irritate me. Disagree: comments are the norm. I think comments should only exist if something insane is happening, like you over-allocate an array to emulate an overflow access in a previous version of a game or something.
Because I have the timestamp data of each account for each upvote/downvote for all submission in this sub?
How do you have that?
Exactly!
Amateur coder here. Could you elaborate on the magic numbers thing? Do you mean to say just arbitrary numbers? 
You've lost me. So far as I know mods don't have that either.
Unfortunately I think this kind of rule is often over-applied to discourage *any* debate, legitimate or otherwise, making the cure worse than the disease.
It's pretty straight forward, whenever you write a number inside your code it's a magic number, let's assume you have a program that displays blog entries per page and this routine displays the entries based on the page number: int startIndex = pageNumber*20; for (int i = startIndex; i &lt; startIndex+20; i++) { displayEntry(i); } This code basically displays 20 entries per page, now what happens when you want to change to 10 entries? you will have to find all occurrences of that 20 and replace it. In this case it's easy, but this can get messy very fast. a more reliable version would be: int entriesPerPage = 20; int startIndex = pageNumber*entriesPerPage; for (int i = startIndex; i &lt; startIndex+entriesPerPage i++) { displayEntry(i); } or just a CONST, whatever floats your boat, but everything is better than magic numbers. ^you ^can ^keep ^all ^bugs ^and ^logical ^errors ^in ^the ^code ^above ^;p
No, it won't. BlueJ is the equivalent of using a kitchen knife to drive a screw in. BlueJ is a terrible abomination. It's a text editor pretending to be an IDE that got spruced up with some UML capabilities. It doesn't have any useful features that proper IDEs have (autocompletion, code hints, debugging, workspace management, code analyses, and code style analyses, etc.) It has it's own console system that lures BlueJ users into the thought that the OS console is capable of the same things (which it isn't), and it produces unreadable error messages (as we permanently see in the programming-related subs. Just about 90% of questionsregarding error messages originate from BlueJ users.) I wouldn't recommend it even if it was the only thing more advanced than notepad.
Please read the little paragraph above the poll. I can't mention everything. But you can put other and then mention your choice in the comment section.
It's an expression. Magic is stuff you can't explain, a random value somewhere within the code isn't necessarily explainable at first thus magic. 
Cool thanks. I look forward to it =) 
It's my favorite, too, after seriously trying all three (abandoned Eclipse a long time ago, and I still use IntelliJ, but mostly for Clojure). It has the best Gradle integration of the three, far more intuitive than IntelliJ, and, IMO, the best looking, too. IntelliJ also annoys me with the various things requiring a restart and with the one-project-per-window.
I am the author of that article, if you have any comments/questions/suggestions, please post here.
Yeah, it is pretty old, but I try to keep it up to date, purging dead links and adding new tools once every few months.
Hmm, I have that turned on, but still IDEA seems to compile everything before app is started ...
It is good to be able to throw away a broken server and bootstrap a new one to replace it. And it even makes sense to automate that. But if that happens frequently, you will most likely want to investigate why, and then SSH can be a useful tool. You can imagine other ways than SSH though, such as making a read only snapshot of the file system of the decommissioned server available to post mortem analysis. My point is that if you get rid of SSH, you have to provide alternatives to all things it's used for, not just some of them. 
Report a bug.
It doesn't mean *that* much I agree, but historically the JDK has been pretty complete at around build 90/100. Now the milestone are, like you say, the main thing to watch, but build 70 does mean it's quite far already.
Try enabling the EJC. By default IntelliJ uses javac, but it supports using the Eclipse compiler. https://confluence.jetbrains.com/display/IntelliJIDEA/Compiler
I switched long ago from eclipse to netbeans because it's so easy. Maven is directly included and everything is so easy and fast and easily extensible
I would love to hear more about this. I'm currently doing automation work and a web scraper sounds really interesting.. care to PM me some info? 
... or OSGi
According to this picture about planned modularization in Java 9, it looks like a lot of people have a lot of unlearning and relearning to do when surfing API docs. https://bugs.openjdk.java.net/secure/attachment/21573/jdk-tr.png 
I agree it could cause a lot of pain, so hopefully the reasons to upgrade are compelling enough, lest we end up with a Python-esque major version divide.
It's supposed to be compatible with OSGi, or at least I have heard that
Amusing, but it makes kind of sense: https://jira.mongodb.org/browse/JAVA-836
But it could bottleneck on the system's entropy pool which isn't Web Scale.
Oh man, this is beautiful, thanks for this!
Yes, I was joking.
Streams and some of the newer Java 8 concurrency features, such as CompletableFuture.
Job market in NYC is still pretty hot and pay is pretty high even adjusted for the super high cost of living. If you have a good salary, NYC is pretty much the greatest place in the world. EDIT: Just to put numbers, I *think* the market average would be $75K for entry level up to maybe 150K for senior. Finance pays the most, but Silicon Alley and Google are soaking up a lot of people recently.
Yeah, NYC seems great, it was always my dream to live there, at least for a few years! Such a magical place, filled with dreams, beauty, amazing places to visit (yet also with so much misery, but that is a curse of all big cities, eh?). Yet everyone says that it is such an expensive place to live. Can you live there comfortably with an average salary? Good salary is such a broad term, since I don't leave in USA, not even in a western country. Also is it true, that frontend market is so hot and undermanned in USA right now?
&gt; so much misery There's far less misery than there used to be. The spheres of enjoyment have been steadily overtaking the spheres of misery. Salaries for good devs are super high which is enough to offset the cost of living. You won't live like a king, but you can afford a small apartment in a good neighborhood (or a big one in a so-so neighborhood).
In Seattle, it's a great time to be a Java dev. Amazon does most of their new code in Java and is headquartered here, and there are numerous other businesses always looking to hire too. Most devs are paid very well here, to the point where it causes discontent among the general population. But also, any major tech company isn't really going to care what your language background is unless you're hire for specific projects.
Reporting from SF/Oakland. Last week some of us senior java engineers were having a lunch discussion about if we are being paid too little. Our total compensation now is about $180K, but our friends who left teh company last few weeks, or working at other companies say they are making $250K - $350k. So naturally we are thinking of leaving too.
Oddly enough, we used Dagger (https://github.com/square/dagger) for a few projects when I worked at Google. Seems to be popular with Android projects in particular. Unlike Guice, it can report build-time errors.
Spring &amp; Hibernate are still strong, Guava is more for early adopters (unfortunately), nobody uses J2EE anymore (but unexperienced recruiters call Spring + Hibernate J2EE which is wrong), people use JHipster for scafolding projects, JSP and JSF are dead (Rest backend in Java + JavaScript frontend are popular now, take a look at JHipster again)
What about Java 8?
JEE (they dropped the 2 a long time ago) 7 isn't too dissimilar from the way mainstream libraries work (similar annotations, usages, etc.). I wouldn't write it off. Also, I hear Oracle will be making a big show of JEE 8 at JavaOne this year. 
I'm still in school but I also work full time as a .NET programmer. I'm actively looking for employment in the SF Bay area and I think that I could live reasonably at $80k. Making that amount seems like a far off dream for me haha
Accross an entire application or project you can! But each module can only depend on one version (which makes sense, you could never have multiple on the same classpath). You can depend on more than one through transitive dependencies, so long as those dependencies are not explicitly exported. Basically it will behave pretty much like osgi in this one regard, afaiu.
Adelaide, Australia. Great place to live, not many job opportunities and getting a decent pay is rare. If you want to start your own business, it may be a good place to start your own company as the costs (yours, your company's and its employees) are not as high compared to the rest of Australia - that's what I and a few friends ended up doing. IT in Australia in general does not pay very well. I once got a job in one of the biggest companies around (Atlassian) and was struggling to negotiate a salary above 140K. Edit: this made me wonder why Australians earn less. Then I realised we actually work from 9-5 (7 - to 7.5 hours a day) and have 10 days of sick leave per year (just say you are sick and stay home, no one will bother), and 30 day vacation. I think Americans tend to work WAY more, but I might be wrong - let me know.
I'm an ISV so my current experience won't count, but I'll conclude from previous jobs, all in Zurich, Switzerland: - [Most beautiful place on earth](https://www.google.ch/search?q=z%C3%BCrich&amp;tbm=isch). - Usually 40h / week. - Usually 4-5 weeks of vacation (plus 10 official holidays) per year. - Average salaries range between 90kCHF and 150kCHF. - Low income tax. - Relatively cheap health insurance. - [Awesome jug](http://jug.ch) with tons of events and budget, but there are also many other groups and meetups. - With around 25-30% immigrants living in the city, English is well established (at least in professional life). Of course, German is a plus. - Beware of rents averaging 2kCHF per month, or 1kCHF for shared flats if you're into that. Having said so, life is easy as a programmer, here in Zurich (and I'm sure much of the above, apart from the ridiculous rent is also applicable to other Swiss cities).
My experience is the same, living in Hamburg. The salaries are poor compared to what I see in other countries. And the sad thing is, no one talks about salaries here. If I look at all the salary surveys out there, then I am well above the average.
I'm a graduate in Brisbane and making $56k... so not that great
15% is a small percentage but I was expecting less. It is a good library, I dislike the fact that people are not using it more.
JEE need s a big fat container, everybody is moving away from this, people are using Tomcat and Jetty. At least this is the way I see things. Is there anything like Spring Boot in JEE world?
*Jetbrains, to be pedantic. IntelliJ is 'just' the tool. Jetbrains are the people. 
After taxes and rent, you are better off living in a smaller area making $45000 
Spring Boot is great for prototyping apps and getting a quick turnaround, but it scares me for production-quality code. There's too much magic that goes on with it, and too much that it *just does* because it finds classes on the classpath. You can accidentally pull in a dependency as a transitive of something else, and all of a sudden you're running an in-memory database!
I'm in the D.C. area. About to get a raise to almost $110k. But Java is only part of what I do, and while I'm moving in that direction, I don't consider myself to be as highly skilled at Java in general as I do in my specialized niche (Lotus Notes / JSF). It's nice for the area, but I've seen a few jobs in the midwest with a bit lower salary but a much lower cost of living. Comparatively, a person might be able to do better in a lower cost of living area.
I agree that more should use it. However, I disagree that 15% is a small percentage.
If your camera only gets 720, then you can't "upcode" it to 1080. The data isn't there
I've just finished a project to download email attachments from mail servers. Initially I want to periodically back up my email attachments to Dropbox. After looking around I didn't see anything suitable. I went ahead to write the program to download attachments into folders. Pointing to Dropbox folders let me back them up. Scheduling it with Windows Task Manager or with cron job in Linux let it run again and again on schedule. Also it's a good excuse for me to use the new Java 8 features in a new project. 
I can't tell if you're being sincere or making fun of people :(
Newer JEE containers are neither big nor fat. Yes they are somewhat bigger than just a servlet container, it's only marginally so. The idea that Spring=thin and JEE=bloated is outdated. 
JEE is defintiely still blaoted. My current job I have to use it for the first time. The default bean lifecycle with spring is @Component (or controller/service) public MyClass And you get a stateless singleton bean that can be Autowired. Whats the equivalent in ee ... a confusing mess thats what. 
Prague - $35K before taxes which is about twice the average wage in the city. 5 week holiday is standard, Prague is very cheap. There are a lot of companies looking for (sometimes desperately) Java devs.
I've always wondered why there are so many expat software developers stateside and I think I am beginning to see the reason.
Android devs will get paid more than Java devs due to the fact that they already know Java and have specialization in a different technology (Android). In the US I would say that is OK for a contractor salary, but we would have to play 100% of our insurance costs out of pocket. Last I checked you didn't have to worry about that in the UK. So I would say this is an acceptable pay rate in London, but would be amazing elsewhere. I would guess he had to take a pay cut when he went on salary though.
Cheers for the info. And a pay cut isn't so bad when you get paid holidays/sick days and company shares in return
Had to read a bit to be clear, but this is adding an HTTP/2 client. Servers are already trickling in with Undertow and Jetty adding support. The benefits for the web are big and obvious, but I'm curious to see what kind of clever optimizations we can start squeezing into REST services. Server-push could really streamline HATEOAS.
I wish I could think of little projects like these. Small little program that is very useful. Great job!
What about Play Framework?
Paris, freelance java dev. About 70K€/year, free of social charges, which is a lot for France. There is tons of java work in Paris, enough to try to go freelance without too much risks. 
Rest + whatever on the client side (AngularJS, ReactJS). Not Java, not compiled and not duplicating the whole DOM like JSF does it. If I have to pick between JSF and JSP, I pick JSP since I can build my own CSS+JS on top.
Thanks. It was an attempt to address my own mail backup headache. I tried to keep the scope small, using command line only, doing one pass over things per run, and let system services to do the scheduling.
I'd like to understand how this relates to Maven/Gradle/Ivy etc, and also whether it replaces dependency injection frameworks like Guice.
Maybe the hype is over, but that is not necessarily a bad sign. Scala is over ten years old (and about 6 years in the industry), so there are no more a lot of blog posts from people who have just discovered the joy of Scala. Scala is now used to do real stuff. Java 8 is not really a rival for scala since Scala is so much more powerful and cleaner in the design. 
I like razor too. The engine that comes closest to it in the java world is http://rythmengine.org. Very nice! 
Never had the opportunity to try Angular or React. Do they provide advanced stuff like conversation scope, auto mapping for form fields (and a true mapping, not the crap Spring MVC does)?
I'm currently on a project with Spring MVC and Thymeleaf. This is a pain in the ass. It's just templating, whereas JSF2 is a true web framework. I mean, JSF has its flaws, right, but its provides a lot of incredibly good stuff I didn't find anywhere (conversation scope, real and robust pojo2form mapping, easy ajax rerendering, ...).
very comprehensive report. thanks!
Where is asString() defined? I assume it's a static import on HttpRequest?
The most Sci-Fi forms you can imagine...... AngularJS has them.
Denmark. Java devs have plenty of job possibilities, but mostly in the bigger cities. I make a total comp of around 105k usd with 15+ years of java dev experience. Newly educated programmers from the universities earn 50-65k usd/year total
Speak of the devil.
The @Singleton or @ApplicationScoped annotations along with @Inject take care of all of this. No muss, no fuss. 
Good thing you can run Ant tasks in Maven using the antrun plugin then! https://maven.apache.org/plugins/maven-antrun-plugin/
Even better you can run both of them inside gradle without catching the diabetus (XML)
I haven't used Gradle professionally but I do actually like the XML in Maven. Makes builds more declarative than imperative, which is how I seem them. You're defining the structure of your build instead of giving it a list of commands.
In my place, 15 years exp gets you like a whole lot more than a junior like me. Like x6 to x10
My friend's bf is from switzerland too. He made around 30k usd. I assume he is the lowest tier i suppose?
Tallinn, Estonia. Salary is about the same (netto) but the work environment and actual work is pretty cool. Cost of living is also generally a lot lower than the US or western Europe so I am not complaining (too much... ). I did decide to migrate here after all. I'd say if you wqnt to experience a different part of the world qnd you're a software engineer, give Tallinn a try. We have. few very known companies (Skype, Transferwise, Taxify, ZeroTurnaround) but also a whole range of other cool software companies rhat all seem to be open to take English-only speaking employees.
I've been using java and c#, among other languages, for 15 years. It's almost embarrassing how much farther c# has progressed than java. Java is ancient, and people get so excited over the smallest improvements. These 'major' releases are almost cringe worthy.
The very fact that it has to include tools to work out why it's doing things just highlights the fact that it's confusing to people. It should be obvious as to why something happens. In traditional Spring, if I want an embedded database then I include the appropriate dependencies and add: &lt;jdbc:embedded-database /&gt; to my context. That's obvious. What's more, I can toggle that based on spring profiles in a trivial manner, so I can use that in tests and development mode but not production. Spring Boot makes this non-obvious and non-trivial. (And it gets worse. I did training on this at work recently, and it was mentioned that if you use Spring Boot with JPA then it will, by default, drop your entire database and rebuild the entire schema from scratch every time! There is an option to turn that off, but you shouldn't ever need to discover that this is something that is on by default)
This article is blogspam anyway. Literally the only reason it's been written is to give their product exposure. Source: sitting next to a guy who used to work for them
In case it helps, Spring Security has the ability to log a *lot* of information at debug level if you turn it on. That's normally a good way to work out why it's not doing what you want. Spring Security is one of those libraries that's great when you get it working, but a nightmare to actually get working just right in the first place. It's significantly better than it was only a couple of years ago though.
Certainly not in software. Or any other full-time employment that I'm aware of. What did he do? As a reference, at the cash register of a supermarket, you can make 4kCHF per month (e.g. at Lidl)
Finally!
IMO, this post would be better suited for /r/learnjava as it is on a relatively low level and not really fitting for this subreddit. /r/Java is for: **News, Technical discussions, research papers and assorted things of interest related to the Java programming language** and your post is more instructional than inspiring a discussion. It as already been downvoted and reported by the community, so it is removed.
FYI, C# or IIS doesn't have official HTTP/2 support (yet). C# doesn't have official REPL either, except mono's.
Exeter, UK. Lots of java roles been advertised. However, the money is not as much as london, but the rent is cheeper so it all ballances out. However, being able to go to the beach / surfing after work is worth something, compared to living in the midlands/london.
or the @Stateless annoation, and which @singleton are you importing ? And you can also inject with @EJB. Starting to look a bit messy ? One of the singleton annotations doesn't allow concurrent access, better make sure I import the right one then. Or should I just use @stateless annotation, whats the difference between @stateless and @applicationscoped and @singleton ... why do I need to ask these questions! And the documentation is poor - unless a I missed an obvious official link explaining all of the above. Afaik, there are &gt;10 possible combinations of annotations I could use to achieve basically the same goal. Recently used a framework with no annotations, and only allowed constrcutor injection and pure singletons, with no state. It was very nice to use.
It's the market that drives the salaries. Android devs might get paid more due to global trends and supply/demand in their area. Saying an Android dev is both more specialized and versatile than a 'Java dev' is just plain ignorance. There's plenty of complexity in both domains that happen to have solutions in a common platform.
Not sure but she said he paints building wall. (Im not native speaker)
Living in the Surrey area! Its a bit like a secret group, once you are in you see the full extent of the jobs offered but it takes that one initial job. Are you a graduate currently looking for a job? If so i know of a few!
Must've been more than 30k although perhaps that was the net salary after taxes and everything?
Depends on the client, most stick to english for methods/class names etc, but keep french for comments or functionnal stuff. Maybe projects which are outsourcing some stuff abroad are using only english, dunno, never worked on them. Freelance java missions in Paris -&gt; http://www.freelance-info.fr/missions.php?f=ile_de_france&amp;mots=java
If you know it is, or consider it spam, just report it as such.
20+ yrs as dev in US, currently work for large publicly-held non-tech company in a small city (metro area pop ~1mm). Standard vaca is 2 wks, had to piss and moan to get an extra week when hired. 10 paid Holidays. "Unlimited" sick days but calling in sick isn't part of culture at any company I've been at. Total vacation time 27.5d, including holidays and 2.5d bonus for no sick days prior year. I'm salaried and usually do 45h/wk, with emails and work-thoughts after hours too, no weekends. Schedule is flexible, I can work from home and come and go as I please.
And the crowd goes wild.... 
Your 'm' is upside down.
&gt; Afaik, there are &gt;10 possible combinations of annotations I could use to achieve basically the same goal. You are right here. This is probably because JSF, CDI, EJB were designed separately of each other. JSF's annotations are already depracated, and I hope in JEE8 EJBs will be dead, because CORBA is going to be pruned, and every other feature could be extracted to CDI, or exposed through annotations/interceptors. IMO this should be done already in JEE7.
I would like to talk a bit to see if we can cooperate. can you please send us your resume to info @ javosize . com 
When will Java developers have a good package management system? Like npm for Node.js
Intellij has no workspace (period) or even project level level view. That is definitely not beginner friendly. This is a core architectural difference and completely a huge missing feature.
The configuration is hardly opaque. Aside from the superb documentation it's trivial to read the configuration classes. It's also trivial to disable them. There's actually very little magic in Boot compared to most of Spring.
damn, i knew java was good down there but I didn't know how good. I'm up in seattle making ... enough ... but not anywhere near 350 :) 
Everybody is doing web or mobile development now, because the accessibility and scalability is better. Nobody is starting any ***new*** projects with any "thick client" APIs anymore. If you gotta have it for performance reasons (i.e. gaming, real-time data analysis), then switching to a more native implementation (C, C++) is preferred, as the JVM may not be fast enough.
If you're doing Java thick client development, you shouldn't be using SWT or Swing. I mean, it'll work just fine, but JavaFX2 is the preferred way (and the way that is going to get supported changes in the future). That said, JavaFX2 has had some serious growing pains -- especially when it comes to Mac support. PS - I've written 2 applications (new development) within the past 2 years in JavaFX2.
The JVM is plenty fast. It is Apple's policy to kill Mac OS development with Java.
Apple deprecated the Java APIs they built for OSX some time in 2010 if I recall correctly. They have not been updating them since, and it doesn't look like Oracle has contributed to those either.
Yah, but I believe I saw something that exposes a WebService that you can say Spring 3.1.1, and it returns you: "Memory leak here .. whatever" I don't want to the knowledge to know which library has which tracker ? Do you know what I mean ? I am not sure if I dreamt it ... But I really believe I say it .. and the name is in tip of my tongue ... 
I don't think their marketing strategy is what drove their java decision. I think it just became a pain to develop and support a custom JVM when they could just rely on oracle to do it instead.
Why is this being down voted? That's currently the best, and probably the only way of writing native GUI in Java. You can also add an additional library like JFace on top to reduce boilerplate. 
Thanks, I hadn't seen this. Cache code is really boring to write. Does it handle the "if not found in cache, then populate" code for you?
Welcome to Apple.
Well, you can google it yourself or read the well chosen words of Gosling. http://nighthacks.com/roller/jag/entry/steve_jobs_comments_on_apple And about speed: There are plenty of games written in Java. (maybe you heard about that niche game called Minecraft) Finally, Java-based web servers are running circles on most other web technology out there. So, yeah, plenty fast. It is not a systems language though.
Exactly...why have a strategic dependency to an outside group, if you have the deep pockets to act unilaterally? There has to be a specific context and value for an integration between public firms to hold up over time. That's just business!
Wrong. The reason why Apple maintained its own JVM is because it was concerned about security (which is, even Java diehards must admit, a perennial concern about the platform). You are right, however, that Apple's re-emergence, specifically after the success of the iPhone and iPad, has given it the ability to say "Eh, screw it! We don't need to waste our time trying to make sure Java is secure anymore!" I mean, why should they? Oracle has all the resources in the world to build and maintain Mac JVMs for people who want to install them. This is exactly the same as how OS X no longer ships with Flash Player. They used to provide these things essentially as a courtesy, and now they've stopped. Microsoft doesn't include Java with Windows, so why should that be considered a knock against Apple? Worth noting, as well, is that the main reason why Apple shuns non-native development, particularly on iOS devices, is because there's a long track record of non-native apps for Apple devices providing subpar user experience, whether we're talking about apps horribly "ported" with Cider, or the fact that it took Adobe until CS5 to even make their suite of apps OSX-native (considering that Macs have been standard in the design profession for ages, can you even believe that? I barely could when I first stumbled upon that fact). It's not like Apple gets a nickel every time somebody uses Objective-C instead of Java, or whatever. They want the apps that get produced for their platforms to be of the highest possible quality, because that will enhance user perception.
If I were starting today, I'd evaluate JavaFX and use it or SWT (I know SWT works reasonably well, but JavaFX is supposedly the future). Then I would find/write JNA/JNI bindings for the native OS calls I need to support.
i mean it may not be that bad over there in Poland.
http://zeroturnaround.com/rebellabs/java-tools-and-technologies-landscape-for-2014/
I had seen that last night when I was doing some googling. It has some stuff that I am researching more on, like Jenkins, or the true concept of CI.
Melbourne Australia, 18 years exp, contracting to a large insurance firm on $800/day (~196K/year). Just bought my second house. Can't really complain.
Except that, at least in the version we were using in training, it was the default for an external database. We were using an externally running Derby database service so that we could connect to it remotely and see the changes that our training application was making, and several people got bitten by Spring Boot dropping the database underneath them.
Wow. 
How would you serialize and link relational data? 
&gt; The reason why Apple maintained its own JVM is because it was concerned about security Citation? No? I didn't think so. First - Apple was never concerned with security. Just look at their track record. They were always taking 6 months to a year to release Java updates even though Sun provided them the sources to those updates. Second - you're confusing the Java plugin with Java itself. All plugins are inherently insecure. That's why the specification has been deprecated (and here's a citation for you https://www.chromium.org/developers/npapi-deprecation) 
I had a look at the documentation but I couldn't understand it TayzGrid uses JGroups or not: how does the communication between nodes work?
Yes, something like that, but in an open free web page ... 
Pole living in Kraków, Poland here. It's not. If you earn in dollars or euro, Poland is very cheap (well, in most cases - oil is twice the price in US).
Well, since (b) doesn't compile, I'm gonna have to go with (a). Fixing the typo, "for(int i = 1000; i &gt; 0; i––) {}" would be faster.
Thanks for noticing the error. Now, I have corrected the typo. Can you tell me why (b) will be faster?...
First, you have to assume that your compiler and runtime are not going to make any optimizations whatsoever. Then, you can read [this stackoverflow post](http://stackoverflow.com/a/1656540) which breaks down the loops into machine code. You can see that the comparison to zero is theoretically more efficient, but the real world difference depends on what happens inside the loop.
Here's a better java interview question: construct a scenario in which it could possibly matter.
Junit does everything we need. Why learn a new framework ?
This question does not make sense. If there was any performance difference, it would be negligible. Probably there is none, because either the compiler or the runtime optimizes any difference away. It does not provide any information about the platform and runtime version, so it is impossible the verify any statement about the performance about the performance of this loops. /u/FrontLoadedAnvils tested it probably on a x64 system and there was no difference.
JUnit + JBehave :)
Why are you required to use Truezip? Java 6 has built in support for the ZIP file format, and it would most likely be easier to use than an external library, especially one you are having trouble finding documentation for.
Dude, use [zt-zip](https://github.com/zeroturnaround/zt-zip) and never look back. Seriously. Spend a minute to read the examples there. You can pretty much do anything you need with a line of code.
https://docs.oracle.com/javase/7/docs/technotes/guides/io/fsp/zipfilesystemprovider.html Java 7 has a zip FS provider just to do this.
If that's the case, then I agree with you. That's some bullshit and should absolutely not happen. I did stay away from Boot for a while for this very reason (worried it would do something like that). We've been using it for about 6 months now and I haven't seen any issues *now*.
everybody already knows this kink anyway.
I just started a project 8 months ago, so there you go: now you've heard of one.
http://mvnrepository.com/artifact/org.apache.wss4j/wss4j-ws-security-dom/2.1.2
Just curious. I aspire to write code like this but I also know we stand on the shoulders of giants. How much is your code and how much is pasted from online sources? In the interest of time, I like to paste what code I can, while trying to understand it and how it fits into my existing code. 
Considering which one is faster would waste more time than either speedup. You lose readability too, when someone comes in later and tries to figure out why you decremented instead of incremented, you will have wasted even more headspace. (not your own, but some dev's headspace) and both are exactly the same; that dude on the hyperlink is wrong. 
The dude just discover what is a reference, nothing to see here.
Here are two examples of how difficult it can be to estimate performance without profiling: http://stackoverflow.com/questions/11227809/why-is-processing-a-sorted-array-faster-than-an-unsorted-array http://stackoverflow.com/questions/19844048/why-is-long-slower-than-int-in-x64-java 
Suppose that you want to troll a bunch of recent graduates during an interview...
This is a good one ! Didn't even know about it !
Yeah, I'm mainly disappointed that there was no "manifesto" to go along with it. Most projects at least state their goals and what they're hoping to bring to the table. This is just... blank? Javadoc doesn't cut it!
Oh that sounds awesome! The -Xbootclasspath crap is a pain point for me right now so I'd love to see how you dealt with it.
That library states that it uses Java's internal ZIP support. OP stated that he has to use Java 6, which means with this library he can't access ZIP files &gt; 4GB because Java 6 lacks support for ZIP64.
If you get the requirement to use Java 6 just changing it is usually not an option. And you can get ZIP64 support in Java 6 just fine by using libraries like TrueZip or commons-compress.
Why? Why do you care which is faster? Do you have evidence from a profiler that shows that this is a bottleneck that you need to care about? If not then instead concentrate on which one makes more sense for the code you are working with. If you specifically need to count up or down then do that. If you just want to repeat something 1,000 times then either pick one of them - *a* will be more commonly seen than *b*, so is the preferred option - or else do something like: (Java 8 only) IntStream.range(0, 1000).forEach(i -&gt; { }); Since then you don't care at all about how you are iterating, just that you are executing the closure 1,000 times.
Java will be fine.
Can't remember ever having problems with Java when switching/upgrading OS.
Isn't that a downgrade for those running OS X or Linux? :P
Well, as he mentioned nothing about 4gb files then assuming he needs that feature is similar to assuming he can change requirements.
Personally I create transfer objects / representations and send those out instead.
My general preference/practice is to create a JAXB annotated base class, then extend it with an entity. Sometimes this makes creating the entity relationships a little more difficult, but on the other hand you can be very specific about what your serialized output is. IIRC If you're using JAX-RS and annotate your @Consume/@Produces set with application/json, it should automatically serialize/deserialize from JAXB to JSON.
Anything that allows the JDK developers to be lazy also allows you to be lazy, i.e. achieve a goal by writing less code. This is good. I'd love a test framework that fully used all modern java features so that more of the internal logic was checked at compile time. So if you did the equivalent of making a @BeforeClass method non-static you get an error marker before you save the file, rather than an exception when you run it... 
This is a bit more work but I believe it is the recommended practice. (DTOs)
Since this is sort of an opinion question, the answer I'd give is "it depends" If you follow pure "Enterprise" design, you should be wrapping these as DTO objects, maybe even have some validation that'd be helpful to the different endpoints your exposing, etc. If you follow the KISS principle, you'd convert these to DTOs only when it's really needed. If your entities lead to the +1 scenario in parent/child, then yeah, you should probably bring these back as DTOs, but you should really be asked if what your exposing really needs that much data anyhow since that's not only going to take a while to query, but could cause a lot of data to be brought back to the client. I honestly think this is actually a matter of preference. Spring recently released the @RestRepository through the spring-data project which will directly expose entities automagically. They do some pretty slick stuff to get around some of these situations (check out projections), I'd suggest you take a look at it to maybe get some ideas.
Am I going to upgrade to the best Windows OS ever made? Definitely yes.
nice (y)
Less work writing code usually means more work reading code. I read code WAY more than I write code. If I wanted a bunch of magic, implicit bullshit in my code I wouldn't be using Java.
how i do it: i have my full-blown entity objects only with JPA/hibernate annotations. my dropwizard resources refer to interfaces, that sometimes happen to be be implemented by the entity objects. those interfaces have annotations, mostly @JsonRootName("Xyz"), because the interfaces are named "PublicXyz"
In general I do search a lot for solution to problems, API usage, specific techniques, etc when I develop software. I do copy on well done solutions. And I copied from myself, from old projects. When copying, copy snippets and limit the scope, so that you can understand it better and have better control over its impact. Though in this particular project, I did wrote most of it. Only a few I adopted from elsewhere, like the JMail api usage, the getting home dir, the cleanFilename (someone had done great work to figure out all the invalid path characters), and formatByteSize (someone had this version much better and concise than my old version). A lot of specific code are adopted from my old code developed over the years, like the equals/iequals, defval, formatter, dates, TlsCache, CmdLine, Dbg, etc. As for writing style, just don't give a shit. Some people will like a style; some will hate it. E.g. in this particular project I used a lot of static functions and little OO since I believed it's the simplest and best approach to get it done. Write the code as you like it, as long as it's working, consistent, and understandable. You will develop different styles in different stages. Just keep on writing and developing. If you made a mistake, well, you'll learn and do better next time. Remember the end goal is a working software. How to get there is entirely up to you. Make it a pleasant journey. 
He said in the second sentence that he has to use Java 6.
Ask Dr. Google, there are so many good getting started guides out there. If you have a specific question feel free to ask.
Is there any link to the actual presentation?
XP is pretty vulnerable these days...
Is Commonmark going to be used in Atlassian markdown impls such as in their README parser in bitbucket, or their Wikis, etc.?
I think you can use something like @JsonBackReference, which allows you to have those parent child relationships only once.
I have Ubuntu Gnome on one SSD, and Windows 7 on the other. I'm going to upgrade to 10 simply because I don't want to be three versions behind.
I could have used these flame graphs in the past but I did not want to patch and compile a JVM myself. Pretty good news this will be available in every JVM soon.
Yeah this what I was looking at, but was hoping there was some other magic I could be doing.
Generator? Doesn't happen to be open source does it?
Oh this is very useful.
this is cool! especially what it enables ('further work')
See Spring Data REST. This will make an automatic HATEOAS REST API for your Spring Data repositories. Works w one2many and many2many relationships. Also see Jackson JSON views (supported in most recent versions).
JBoss WildFly sounds like a DJ/Hip Hop name, lol.
Not to sound cocky, cause I definitely don't know everything there is to the EE stack, but I do know quite a bit to it already, such as JAX RS, WS, EJB 3.x, JPA, CDI, JCA (connectivity architecture, not cryptography), etc. I do pretty heavy EE daily, so I'm trying to find stuff that isn't necessarily Java EE to help grow myself. Spring is an example of something I know of, but haven't dug into because we actually have it for very limited.
Agreed. I plan to look at Gradle, though I have been trying out IntellijIDE, and strangely enough, so far I prefer eclipse (probably cause I already know so many shortcuts in that IDE). I do need to look into scala a bit as well, but I'm trying to focus one at a time.
check out spring hateoas. keep your JPA data model completely separate from your Rest model and rather return a dynamic JSON object that can accomadate different versions of your data object in the future. edit: and use links to represent relationships. (built into spring hateoas) edit2: keeping your data model (JPA) separate from your REST model (what you return to clients) will allow you to scale if you get a lot of clients.
To pile on with agreement, I've found that not doing this results in: * entities having a bunch of helper methods for rendering, which are unrelated to persistence (e.g. date formatting) * creating weird dependency graphs between your entities and other parts of the application (e.g. making entities dependent on your localization libraries) * bloating views with unnecessary data, because you wanted fields A+B in one view, B+C in another, and out of laziness you end up putting A+B+C in both * or you include all fields to all views, and accidentally expose sensitive information when you add a new column to the db It makes me sad when I see potentially simple and straightforward classes turn into these multi-headed monsters. An entity is simple (maybe a stretch with Hibernate), a view object is simple... it's so easy to draw that line and put them in separate classes. Do it! If getter/setter bloat is the concern, I've found that Lombok helps. The `@Value` annotation fits quite nicely with a lot of view objects.
I'll test it out, but what I've so far heard about it, doesn't sound that great. Well, it does sound great, because the marketing makes it sound great. With Universal Apps (or whatever they are called right now) apparently running on PC, Tablet and Smartphone equally well. But I know that that's not possible, as you will always have to sacrifice information- and control-density to make it work for touch-devices and especially smaller touch-devices. So, I personally assume that it won't be that great, although I haven't followed the recent news on the topic, so my opinion might be as invalid as anything. I suppose, I will still like it better than Windows 8, which frankly isn't hard, as even its predecessor did it, but I also plan on switching to Linux, so if Windows 10 isn't truly as revolutionary as they say, I will have my Linux installation disc ready.
Are you counting 8.1 as a separate version or did you miss that Windows 9 was not actually a thing, because reasons?
Ah, so something which was released 5 days ago for C# makes Java, which will release the same thing in 2 months, "ancient". Not to mention that HTTP/2-support is still not there. Sorry, but this is simply not the thread to make such statements.
Ah, ok. I just personally wouldn't include that as an own version in this context, because it didn't really bring as much changes as a proper release. But I suppose, if you would've written "2 versions", then the next smartass would've come by, just as fast...
Hey. We're planning to use this as [Stash's](https://www.atlassian.com/software/stash) markup implementation. For Bitbucket, I think there are intentions to use CommonMark as well, although it would need to be a Python implementation. Also, it's still unclear what the future of CommonMark is. I haven't seen any announcements by GitHub that they switched for example.
https://news.ycombinator.com/item?id=9943656
&gt; For JPA 2.1 there is no reference implementation That's not true. EclipseLink is the reference implementation. Every Java EE API has a RI, but some are not that clearly marketed as such. For example, nobody knows what the EJB RI is, but it does exists.
Great job! I wasn't ready for such detalied post about lambdas. Can't wait for next post.
&gt; Posted on July 25, 20157 I knew Java was here to stay!! 
Internships are extremely important, regardless of what you do. I rarely hear of an intern actually doing any significant code though, they are usually hired to do the work nobody else wants to do. Like documentation or writing unit tests. The exposure to real world software development is important. In the US Software Engineering and Software Developer are the same thing. Titles are fairly meaningless as far as job duties are concerned. Though, I'd be hesitant to call anyone an "Engineer" without some sort of college education or significant experience. In some other countries being carrying the title of "Engineer" requires actual certification. 
1) Internships are really important. In my experience, interns usually start in their junior year, but I've had one who was in his sophomore year. 2) Java isn't what you'll be going to school for. Depending on your degree (I'm assuming CS), you will use several languages to learn different concepts, so don't get too hung up on specifics right now. A good developer will use the best tool for the job. 3) Nobody is going to treat school work as experience; what you're looking to get to is "New College Graduate" status, and there are plenty of companies that are looking for exactly that.
The summer intern on my team is building a service from the ground up. Granted, he's following a pattern established by a similar service we started building a couple months before he started, and he's had a lot of guidance from us, but that's real code that'll go into production in a month or two.
Just a quick notice for those readers not in the USA, don't worry about your future career if you don't have an internship! Those posters saying how having intern experience is extremely important for getting a job after your studies may be right for the U.S. market but it's not the same elsewhere. Here in the UK, there are a handful of internships available but you generally won't see them outside of London. I personally only know one person who has been an intern in any field and it has made no difference to their employment after uni compared to that of of their peers. It seems odd that people here are saying how vital internships are and yet there are posts every week about how you do not need a degree to get work in software development! I have only one year of experience with programming and am starting my new software engineer job from next week. All of my class mates from the fast track course have found work as well. What is important is demonstratable experience. A company doesn't care who you've worked for, they want to know what you've worked on and what you know because of it. 
:) . Wordpress issue
Very cool idea!
There's plenty of internship in the UK outside of London, but they're not referred to as internships (usually described as an industrial placement or industrial trainee placement). My university CS dept heavily encouraged everyone to do one, and they were certainly very valuable in increasing employability once out of uni.
So this just works exactly how Steamworks does.
Is this like ngrok?
Had never heard of ngrok, but it does seem to be very similar.
&gt; It works by transferring data through relay servers on grappl.io. Well that sounds both fast *and* trustworthy!
They aren't as essential as other posters are making it out to be though. Out of the 12 people who made it through to the final round of the IBM UK graduate scheme interviews this year (or at least, the intake I was part of), only one person had an intern experience. Three out of the 12 had only been programming for six months and one of those three got the job (not me unfortunately). I'm not saying they aren't useful and I am certainly lacking in real world knowledge when it comes to the industry, which an internship would have provided, but I know very few people on the conversion course I've just done who have struggled to find employment and none of them have any industry experience.
No problem with the tutorial but JNI is rarely used because a crash in the native code will take down the JVM. Better to loosely link via a socket or embedded web server. A little more complex but much safer especially for web apps.
Freakin' Oracle :(
Parallel streams are implemented using internal threads. So...not sure if it would make any difference regarding performance. 
Although there may be exceptions, parallel streams should be faster. Starting too many threads can easily result in so much overhead the performance will suffer. You want just enough threads to keep all the CPU cores busy. If you use parallel streams, it should automatically use the optimal number of threads, and you won't have to change your code when it's run on a bigger or smaller machine. 
If you make sure to limit yourself to one thread per hardware core (for example by using `Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors())`, both should have the same performance.
Can you describe the kind of work that is being performed?
Well it is the hippest Java EE application server out there.
No... JavaFX is totally misconception. Today's situation GUI API layer available only HTML5 or iOS/Android. Others are nothing.
&gt; I rarely hear of an intern actually doing any significant code though That depends on the company. Good companies invest in their interns and let them do stuff where a fuck up isn't damaging but where they still learn and contribute. Bad companies see them as cheap semi-skilled labor. 
I'm Dutch and a bunch of years ago had to work on a French codebase that had both the method names and the comments (if there were any) in French. That was fun :(
I guess you creating your account and posting this has nothing to do with /u/tayzgrid being active here right?
Your 'friend' already posted this 3 days ago: https://www.reddit.com/r/java/comments/3eb4yb/new_inmemory_data_grid_has_anyone_tried_tayzgrid/ 
Fine, but as I said in my original post, saying that internships are essential to getting a job is plain wrong (which is what other posters have said) and contrary to all the advice also given on this subreddit about getting jobs without CS degrees. Any experience is looked on positively by employers, it doesn't need to be an internship. 
Swing/AWT - 1 year ago
And yet I spent 2 hours trying to write an app that takes a PNG image, rotates it 90 degrees and displays it in a window that is same size as 90 degree rotated image. I was unable to get the window size right and went back to Swing... The window would stay the size of non-rotated image no matter what I did. I used setRotate on the image control...
It depends on what you are doing. CPUs can do a LOT of work in the time it takes to setup a new thread or handle the overhead of a parallel stream. It very well be that the correct answer is "neither".
Took me less than 5min. package com.example; import javafx.application.Application; import javafx.scene.Scene; import javafx.scene.image.Image; import javafx.scene.image.ImageView; import javafx.scene.layout.Pane; import javafx.scene.transform.Rotate; import javafx.scene.transform.Translate; import javafx.stage.Stage; public class RotatedImageViewer extends Application { public static void main(String[] args) { launch(args); } @Override public void start(Stage primaryStage) throws Exception { Image image = new Image("https://c.thumbs.redditmedia.com/gCMzcSXDxoDQ4e62.png"); ImageView imageView = new ImageView(image); imageView.getTransforms().addAll(new Translate(image.getHeight(), 0), new Rotate(90)); Pane root = new Pane(imageView); Scene scene = new Scene(root, image.getHeight(), image.getWidth()); primaryStage.setScene(scene); primaryStage.sizeToScene(); primaryStage.show(); } } Rotation to the other side is left as an exercise to the reader.
Fairly simple example, first the JAXB annotated base class: @XmlType(name="SimpleCode") public class SimpleCode { private String code; private String description; constructors, etc... } Then the Entity @Entity public class SimpleCodeEntity extends SimpleEntity{ @Override @Column(name="codeValue") public String getCode(){ return super.getCode(); } @Override @Column(name="codeDescription") public String getDescription(){ return super.getDescription(); } Forgive my formatting. 
Hmm, I remember trying something like this, but for whatever reason it still displayed wrong. I'll give it another shot.
 Stage.sizeToScene() This is very important. You have to size the scene and then let the window adjust it self accordingly. Sizing the window directly can include the window decorations (RTFM!).
Nice video, I recommend getting a cardioid vocal microphone which will eliminate background sounds. I use this: http://www.amazon.com/Pyle-Pro-PDMIC58-Professional-Handheld-Microphone/dp/B003GEBGA0 If you want to spend more there are other options out there. But if you need a free solution a voice gate should eliminate most of the background sounds. Try Voicemeeter, it is free. :-)
Is this supposed to be surprising when the compiler gets it wrong too? Trick questions are tricky. Surprise.
I don't like that last, "easiest" question. What does it mean for one initialization style to be "simpler" than another? Is there a formal definition I'm not aware of? If there isn't, then the question is ambiguous, and you could make a case that either A or C is correct.
Question 4 doesn't show the whole class, in theory you could safely say it doesn't compile right away. At least question 5 does mention it's a code snippet.
Who are you talking to? I'm not the author of the video and if you want to do a sales pitch you can comment on youtube.
Version control has a blame command for that crap. For workplace safety, please wear steel toe boots for coaching your coworker. 
You'd think that a quiz that looks that fancy would have enough horizontal space in the code to not have awful formatting from wrapping.
Thread pool, one thread for each core on the cpu? Seems the most efficient for cpu bound operations
Not really sure, but I think the key is the "reference to a string" in the question. Meaning you do not necessarily create a new object, but if possible create a reference to an existing string object, in which case C is the correct answer. EDIT: Nvm, as i finished typing this answer I realized that the question is still retarded. Atleast if you downvote, explain where I'm wrong.
100/100 java developers will never face this problem in their career
yeah, but thats not the point. The point is to have a deep understanding of the language. 
Except when facing overzealous interviewers.
If it fosters bad programmers - yes. We might have to maintain the crap that they have generated.
I disagree that it fosters bad programmers. In fact, I would argue it fosters good programmers. It is obvious that shit like that does not belong in production code, and so no *reasonable* programmer would write it. But what it does do is allow you to think about how many different possible situations interact with each other, and as a result have a more correct mental model of how your tools work.
Didn't realize this subreddit became buzzfeed.
Which will tell the interviewee they probably don't want to work there to begin with
I'm not really sure I understand java any better for reading that. Some of those were interesting just because of how obscure they were, but I doubt knowing any of that will ever contribute to me being a better java developer. Well maybe the last one that everyone got right would help, but I'm pretty sure I have initializing strings on lock down.
"4 out of 5 Java Developers Failed to Solve This Question" - goes on to list 5 questions... Q2. "What will this program print" - no closing brace, so won't even compile. Q3. "Potential out of memory" - how is this an answer? Practically any non-trivial Java program can potentially run out of memory. OMG you new'ed a class, that might potentially run out of memory... Q4."What's wrong with this code" - double-brace initialisation is idiotic. 
True. But I failed to tell you my school has split the IT study into 2 separate studies. Embedded software and software engineering (meaning high level software). This way the students can focus on their own field and learn 'the other side of software' when their jobs actually require them to. So I just learned C#, Java, ObjC and Python and the embedded system students learn C, C++ and stuff like electrical engineering, PCB design, etc.
Not quite, it depends on how much memory is being used. Often "CPU bound" tasks will have some memory lookup portion to them, in that case you can see performance gains by increasing threads past the number of physical cores (and even past logical cores). To get the right number of threads you pretty much need to profile and benchmark the process.
if you write code like this, then you don't deserve to be hired.
Anyone can write code a machine can understand, only a good programmer can write code a human can understand.
What functionality of Takipi, SPECIFICALLY, are you interested in?
Hey don't stereotype. Not everyone that has depression is suicidal.
Ok, I guess that makes sense
As a beginner in programming for so many years, I wish I end up being good enough to be called a *java developer*. 
Thanks :) 
Not sure what Takipi provides explicitly as I've never used it, but tools I've used for JVM / application analytics are: Elastic Search, Logstash, and Kibana - https://www.elastic.co/products Hawt.io console (and by extension, Fabric8) - http://hawt.io Red Hat JBoss Operations Network (I'm trying to track down the upstream community project, but this will do for now) - http://www.redhat.com/en/technologies/jboss-middleware/operations-network In addition, you can use tools like NewRelic to monitor your runtime environments. Hope that helps.
That doesn't explain the motivation. I assumed it was a pricing question, but I was wrong. [OP is really interested in the act of implementing similar work for the experience of it](https://www.reddit.com/r/java/comments/3etxk9/open_source_takipi_clones/ctisc14)
At first glance, it seems to purely be doing code analysis. The errors seem to be *coding* errors and not runtime exceptions and things of that sort. This is still a pretty interesting tool, though.
&gt; Takipi is hiring, perhaps that's an option for you? :) Yes, I was just checking out that page a couple days ago, but a move to Tel-Aviv isn't really going to work for me. If they wanted to have someone working remotely, though, that would be interesting... Stage Monitor looks like it could be interesting. I'll have to check it out.
Upstream of JON is here: http://rhq-project.github.io/rhq/ 
What's the benefit of JRuby, is it just more fun?
I liked that book! I don't get the vitriol against this post, it's not supposed to be practical or attack your status as Java dev. It's a fun exercise of your skills, that's it.
 I read the question as do I need to learn C to learn java, to which I say no. A technical / engineering school should definitely teach a variety of languages as the is no one language for all problems.
On occasion these can be confidence shakers, but realize that this is coming from product people who must understand java inside out at a level most of us never deal with. I'd have called this a puzzle in the title though.
Apparently it does, but why would you use it? It just adds another language to your technology stack...
I think there is enough distinction between Hate posts (aka trolling) and legitimate discussion. 
Brightened up my day :)
so I take it if it is I/O bound it may be less than optimal?
Its just ruby taking advantage of a more mature VM. 
I've been working on something similar for a while now, it's called [GhostWriter](https://github.com/snorbi07/GhostWriter). It uses [pluggable annotation processing](https://www.jcp.org/en/jsr/detail?id=269) and *javac* internals to instrument your code with flow tracking (including state changes and error triggers). You can use this to provide error snapshots similarly to Takipi. The *ghostwriter-rt-snaperr* module is the example for this. Unfortunately I did not yet have time to write proper documentation or to release the corresponding backend service part. If you are interested, check out the [presentation](https://www.fastmail.com/html/GhostWriter_JUM_2015_05_27.pptx?MLS=FS-*&amp;SFS-CD=403659525&amp;u=8df4417f&amp;MSignal=FS-SF**483694929*1) I did at a Java meetup. It has transcripts, "gettings started" links to examples in the repository as well. If you have questions just let me know! Edit: [PDF version of the JUM presentation](https://www.fastmail.com/html/GhostWriter_JUM_2015_05_27.pdf?MLS=FS-*&amp;SFS-CD=403659525&amp;u=8df4417f&amp;MSignal=FS-SF**529431577*1)
Hi, Alex from Takipi here. Glad to hear that you liked the product! This post on InfoQ is a good overview of other alternatives for advanced Java debugging techniques: http://www.infoq.com/articles/Advanced-Java-Debugging-Techniques You might want to look into BTrace: https://kenai.com/projects/btrace
Whys that?
Then voting should be perfectly adequate to deal with trolls.
This stuff is so cool. I've done some work with docker and love it. I can't wait to get the time to experiment with kubernetes. It's great to see them hit 1.0.
Newest RebelLabs report - this time the focus was on application performance for Java. Good read, some expected results and a few unexpected. 
Getting an internship in college was one of the best career decisions I ever made. I was writing real software, and getting paid better than my previous summer job (restaurant server). 15 years later, I'm still using the same basic skills on a daily basis (Java, JavaScript, HTML, CSS, SQL).
ELI5?
I think you would have no problem learning both at the same time. You also don't need to know what `make` even is to learn Java.
I wish people would stop posting articles about the same things over and over again. Yes these are important concepts...no this is not unique or new information. An article like this only waste my time by not providing anything interesting. A much better title would have been 'Lockless concurrency for beginners'...then at least I would have known that this is not an article which is trying to expand the concepts we know today, or talk about interesting new stuff on the horizon. And instead is just a run down of the tools which exist today (and have existed for years). On the other hand, I absolutely would love articles like this which are more advanced, and do go into new strategies, techniques, design patterns, processor support, etc, etc that we have yet to really realize the advantage of.
Like get your ISP to cut you off? 
Thanks. For the life of me I couldn't remember what on earth the upstream was. 
The thing is, all of these would be immediately noticeable if you had proper test coverage. I don't really get why I should have to know all the stupid shit the language can do, if I am being responsible in my testing.
Yea, there are some pain points in mapping from JSON -&gt; JPA. But. Exposing a data model to wild world web creates a dependency on clients. If you want to update your JPA model it'll be difficult/impossible to ensure you aren't breaking clients. If all the clients are expecting is a dynamic object then thats all they need to code against. And you're free to 'dynamically' change it. Also, for my case, it was easy to expose parts of an object for puts (like the client only puts a particular field of the data model, i.e. I want to cancel my coffee order, so ill send a PUT to /{order-id}/status/{new-status}). So the client doesn't need to know what an Order.class object looks like at all. And that way I avoided a complete JSON -&gt; JPA mapping. Ask yourself, does the client REALLY need to send the complete representation of the object? Probably not... If they do your REST methods probably have too much responsibility or your 'over-the-wire-objects' have too much responsibility. Object creation should always be handled by POSTS so the client doesn't need to know the model, and updates via PUT should be simple and clear. This has worked for me and we've been able to painlessly update our API without getting phone calls everyday. Edit: a lot. But wanted to add I hope this makes sense and maybe even helps. And this really only makes sense for Restful backend services but I assume thats what you're doing.
I think you make a good point, but in all honesty even if people are trying to do good testing, the requirements collected, and the budgeted time for testing, are in practice often not sufficient to avoid all bugs. Good point regardless.
Worthless as an interview question -- unless you're going to let them diagnose the problem with javap or a debug build of the jvm and the job is triage. An analogy would be a chef. You wouldn't ask them to spend their time learning to fix terrible failed meals. They learn techniques that produce success -- they don't spend their time worrying about putting happy faces on failures. I would say if your business encounters errors like this often enough to make this exercise useful, your problems likely involve planning, requirements, and architecture -- structural problems that nerd knowledge like this wont fix. 
After reading this I've already added Swagger via Springfox to some new projects at work, we definitely need maintainable REST API documentation. Thanks for a nice writeup.
Interesting, but the results are skewed due to ZT's orientation towards Web apps.
Yea, I didn't know rest documentation was that *easy*. Always thought it wasn't worth the effort. 
This is all nice and good but it won't save you from people exploiting flaws in your services design or implementation. Claiming this eliminates the need to change code is a lie.
Apiary.io is pretty cool too.
thanks. Java is my first language and have not learned an other one yet. Uni does not even provide C++, will have C# in a year. I know it's all about self-education but tbh, I have more than enough to learn without jumping into a completely new, probably more difficult language to learn on my own...maybe later on. :)
thanks. i couldn't agree more with you as far as the teaching process concerned. too bad, most of the - even good ones - Java books does not talk about at the very beginning what the hell psvm means, stating that at this stage it would be to difficult to grasp. guessing this approach makes it vague and difficult for many novices to learn Java.
thanks
To me I think the value here is problem solving. The more problem solving you do in different ways the better you get at it in the future. I really think your abilities improve when you have to solve problems with new tools you have never used before. Sure, the implementation of things is vastly different between Java and assembly but when you get to Java you will already have a bunch of problem solving under your belt.
Well when I worked in the High Frequence Trading space, it mattered a lot! Bring fast was important. Things like: * Object dereferencing is slow if in a tight loop, you are way better off with arrays of primitives * The way the arrays are lined up matters. Generally you can read an entire cache line very fast, so try to stick within a cache line (vs jumping all over) * Because of the two reasons above, the way you lay out a 2d array matters a lot. If you do it naive style, you blow your cache line constantly. * Some apps cannot pause for GC, so you need to be careful to set up all your memory at startup - and only use the stack for temporary stuff so the GC never needs to run Now post trading, I care about correct code. Which means I write in a functional style. Kinda what you would learn in LISP or Haskell in school. My code is not as fast, but what matters is how many features per minute I can code... Every kind of coding has tradeoffs. Know when to make which.
 try { for (int i=0; ; ++i) { // use array[i] } } catch (ArrayIndexOutOfBoundsException e) { }
thanks. so there might be some cases when this knowledge comes in handy even when working with high-level programming languages.
thanks. well, both ArrayLists and LinkedLists have their pros and cons and therefore the time to use them. as for the loops, declaring non-changing variables outside of them are surely important, but certainly not always enough when it comes to code optimization.
As a compromize you could learn Java bytecode language. You can disassemble Java class files with *javap*. You can look [here](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html) for documentation.
Can you recommend a text for learning how TCP/IP, File Systems, memory management, and system architecture work? Several books maybe?
Knowing how all parts of the stack operate is helpful. While knowing how a cache line work doesn't require assembly per say, assembly is a pretty fun way to learn it. Write some little programs and you can see how crazy difference the performance is based on the way you lay out a 2D array.
Maybe it's me, but I don't get your point. When you overrun the array, the exception is raised and caught. I actually coded this up, because I thought perhaps there was some subtlety I was missing, owing to my ignorance of assembly programming. (You threw me with the prefix operator. I only ever use a postfix operator in a for-loop, so I thought the subtlety lay there.) I was excited that maybe I was going to learn something. So, seriously, what's your point? (I will grant, though, that I began programming by learning a bit of C. Are there Java programmers completely ignorant of what exactly is an array? Is that your point?)
okay. this is how it changes: number = 0; number = 10; number = 20; so it would print: 20 20 if i'm not mistaken. "Two variables could be pointing to the same address of memory. In that case, even if you could think that you are modifying the value of one variable, you are modifying the value of both." okay, but...this is sthing that they teach you in a Java class, i mean, you don't actually need to study assembly for this knowledge...
have you not simplified it a bit too much? i'm afraid some might disagree here, maybe rightfully :)
I've read somewhere that the most benefit to a programmer comes from knowing what goes on "one level down" from the language he or she is programming in. So, I would think that if you're primarily a Java programmer, you should have some familiarity with C: specifically, what pointers and arrays and memory management are all about. Knowing these things can inform your programming in Java. Assembly however would be two levels down; and I'm guessing it's arguable that the effort a Java programmer makes there, as opposed the effort made in learning C, would tend toward diminishing returns.
This why I said if you don't have them break the code down and understand the effects introduced by the compiler on the fly, or if they short circuit that exercise by memorizing such issues, then said question told you nothing about the candidate. Just reviewing these questions like this is trivia -- nothing more.
cheers mate :) i don't really care people complaining on my ability to express myself, or the mistakes i made, but it's always delighting receiving compliments like yours. i actually started to learn English 3,5 years ago when moved to the UK but as I already left it a year ago and migrated to Scandinavia, it is not improving as fast as before. All the best to you!
I bought this book when I was curious about exactly how networking happens. It is incredibly good. http://www.amazon.com/Computer-Networks-Internets-6th-Edition/dp/0133587932 From a C.S. prof. at Purdue. https://www.cs.purdue.edu/homes/comer/
Memory usage is rarely an issue but that's my point, there are corner cases. For the most part you are right though. There are better ways you can be spending your time. Just like you may never have to deal with designing a really clever algorithm (simplicity is usually better), or run into a really serious security issue, low level stuff is rarely useful in Java.
This is a moronic and dangerous approach to securing the endpoints of a given webapp. The webapp container + the webapp itself should be configured to enforce the security model instead.
I recommend checking out this: https://vimeo.com/131394615. The value of the optimizations in the video can be debated, but it gets the point across quite well: if speed matters, low level can be very important.
First, why the downvotes? He's just asking for proof or some sources to back up my statements. That's always a good thing. Ok, again, I'll focus on general low level system knowledge, I don't think assembly is that interesting, unless you start looking at SIMD instructions or CAS other concurrency related instructions. Let me find some examples. And again, some of this migh seem like common sense, but I've seen my share of "Java only" developers who just aren't able to do things like this. "This process is using 4 GB of RAM! It shows up right here in the 'top' command." Um no, it has mapped 4 GB of VIRTUAL memory by memory mapping a file, RESIDENT memory usage is 20 mb. "Oh, we are going to use this distributed in-memory grid, it's very fast since it's in memory!" Doh, you are still going to access it over network, incurring latency penaly for each request. "Oh memory usage does not matter, our system is designed to run in a cluster and scale horizontally, and these days you can buy a server with 6 TB of RAM". Right, but if your operational data-set fits into CPU cache, your software will run an order of magnitude faster. "I don't know what went wrong between that server and that client but the login failed! It's a production system and we cannot easily change it and there is nothing in the logs" Here's wireshark, go and inspect TCP/IP traffic! "The process is stuck!" Use strace for this PID, it's repeatedly writing and erasing file 'gah" which is only accessed in 'WriteGah class' method 'blah' "The process is stuck! Jstack doesn't work!". Here's a gdb core dump for this process, inspect it with VisualVM and you'll get stack traces for the threads. I can find more, but I don't want to spend time if you get the idea already.
hmmm...okay. is it necessary to know the machine at hw level to make a right choice between an AL and a LL? 
Thanks. I'm already sort of down that path as I just picked up K&amp;R's C Second Edition and am teaching myself on an Ubuntu partition.
Main use of Java today is server-side/middleware/backend/webserver applications. So your apps are going to run on servers. The other big Java ecosystem is Android phones. And ~60% of servers are running Linux. And Android is also effectively Linux, even though apps run in a special VM/sandbox.
okay...sadly my knowledge is not enough yet to fully understand you but will work on it. thanks
yes sorry - I thought that was obvious.
Memory usage is an issue. Again, depends on the use case, but when you run into systems that have to deal with billions of objects, you need to make them efficient. One example. Primitive "int" takes 4 bytes of RAM, and array of them will take ~n*4 bytes of RAM. An boxed "Integer" object in Java will take 40 bytes of RAM. An ArrayList of Integer will take N*40 bytes of ram, and if if starts small and a million of entries get added to it one by one, it will have re-allocate the storage internally and copy its contents several time at huge performance cost. On top of that, an Integer will need to be allocated in Heap, and freed up in GC. So for example if you are in a tight loop that runs over a billion iterations, and in one case uses an int, in another an Integer. Both cases will work correctly, but the case which allocates and discards and later has to garbage collect a billion objects will be slower. Another use case is a process that has to store say hunded million objects in memory. Each object might not be that big, but when there are millions of them, it adds up quickly. And when GC kicks in and tries to decide whether to keep or discards these millions of objects based on their references, it hurts. So you start looking at things like off-heap Maps and compaction to reduce memory usage of GC overhead. Another area where unnecessary allocations/ size and GC hurt are low-latency/financial systems.
You'll probably have Android phones talking to servers running Java services. You'll need both :)
&gt; both ArrayLists and LinkedLists have their pros and cons and therefore the time to use them. It isn't when you would think to use them. Lets look at the supposed benefits. LinkedLists have fast insertion / deletion time, so it seems like a no-brainer that if you need to do a lot of inserts and deletes that a linked list would be the way to go, right? Wrong. The first thing you have to realize is that for every single operation on a linked list, you are doing a memory lookup. That memory may or may not be cached (it often isn't). This is because a linked list often tends to spread its nodes out throughout all of the memory. Uncached memory lookups are extremely expensive. There isn't much the CPU can do to make things fast here (and they have done their best to make memory lookups as cheap as possible). ArrayLists, on the other hand, are almost always completely cached. Since java doesn't truly have large objects (yet, value types will change this) everything that you would store in an array is something like 8 bytes and not much more. You have to be talking about arrays in the order of 125,000 elements before you start getting to the point where a 10 year old CPU wouldn't have the whole thing in cache. Most lists aren't that big in my experience. But even when you start getting to that size, you have to realize that you are taking a huge hit every time you traverse the list if you choose a linked list (Memory lookups, memory lookups everywhere). So where does that leave the best place for a linked list? It has to be a list that is on the order of 125k+ elements. You have to do a lot of front insertion (even at 125k+ elements end insertion on an arraylist is comparable to a linked list). And you have to rarely, if ever, iterate over it. Where is that a good place? Pretty much only when you are using the linked list as a queue. And even then, an array based queue can often be faster if the number of elements are low. ( See https://commons.apache.org/proper/commons-collections/apidocs/org/apache/commons/collections4/queue/CircularFifoQueue.html for an example of a queue that will almost always be faster than a linked list based queue). Middle insertion operations almost always favor Arraylists. The overhead of traversing to the location and then inserting is way larger than the overhead of a occasionally resizing. The only exception here is where you are middle inserting while iterating over the collection. However, I've never actually seen legitimate code do something like that (it doesn't often come up). &gt; as for the loops, declaring non-changing variables outside of them are surely important, but certainly not always enough when it comes to code optimization. It isn't always enough, but it is really one of the most common performance no-nos that I've seen.
Join the dark side. You said you are in UK? Go work in finance related IT in the City :) You'll see this and worse :)
To be clear, I wasn't the one who downvoted you. In answer to your question, if you are ever working on anything performance-critical, yes you absolutely need to understand things at a low level, including cache and other hardware concerns. With Java specifically, you better also have a strong understanding of the JVM and its garbage collector(s) when dealing with anything non-trivial where performance matters. For an extremely simple example, consider the following code snippets: for (i = 0; i &lt; 100000; i++) { for (j = 0; j &lt; 100000; j++) { arr[i][j] += 1; } } for (i = 0; i &lt; 100000; i++) { for (j = 0; j &lt; 100000; j++) { arr[j][i] += 1; } } They're almost exactly the same. I changed one thing. Do you know the difference? Do you know that, due to caching behavior, one is vastly more efficient than the other?
thanks. if i was a web developer, why would i learn Java? :)
None of those examples you listed have anything to do with assembly, except maybe the part about CPU cache.
No. You can make a fully informed decision about this without ever having seen or written assembly in your life. 
this is what i thought...
Kind of weird that all of the examples just return "Optional" instead of "Optional&lt;SomeType&gt;". Bad practice.
It doesn't sound like well stated advice to me. One of the main reason embedded and HPC folks shy away from Java is because they can't control their code at the assembly level predictably. You don't even know what the JVM is going to compile to actual machine code until the program is running, and command line parameters can modify what and when things are compiled. And beyond that you don't know what optimizations the JVM will apply to your code. It's useful if you want to disassemble code with a Debug JVM at runtime to see what the compiler did -- but your ability to write Java code to get specific assembly is extremely limited. 
fair enough
Thanks for feedback. It was wordpress stripping off greater and less than symbols. I have fixed it.
okay...will watch this vid, too...if i find the time for that. you guys send me the whole youtube/vimeo etc. :D
No, your code is not equivalent. The way you write it you'll get a triangular access pattern (skipping half the array) instead of accessing the entire square of the array. Your access pattern will look like this (x's are hit, o's aren't): oxxxx ooxxx oooxx oooox ooooo Here's some actual code for you instead of the snippets above. Go ahead and run this on your machine. public class Main { final private static int NUM = 10000; public static void main(String[] args) { int i = 0, j = 0; int arr[][] = new int[NUM][NUM]; long end = 0; long start = System.currentTimeMillis(); for (i = 0; i &lt; NUM; i++) { for (j = 0; j &lt; NUM; j++) { arr[i][j] += 1; } } end = System.currentTimeMillis(); System.out.println("First test. Time: " + (end - start)); start = System.currentTimeMillis(); for (i = 0; i &lt; NUM; i++) { for (j = 0; j &lt; NUM; j++) { arr[j][i] += 1; } } end = System.currentTimeMillis(); System.out.println("Second test. Time: " + (end - start)); } } On my machine I get this output: First test. Time: 177 Second test. Time: 5730 Yep, that's more than 32 times faster to use the first version of the loop instead of the second. It's that drastic. And if you know nothing about cache, you have no idea why this happens, or possibly even that it happens at all. That's why this shit matters. 
I challenge you to find assembly mentioned once in my post. I'm talking about a low level understanding of the hardware.
If you're curious I can give you a short explanation of why this happens. And remember, this is just one very simple example. There are low level gotchas everywhere that you need to be aware of when writing performant code. Not all of them matter in everyday, efficiency not an issue coding, but when it's as simple as the order of array traversal I would say that's something everyone should know about.
Realistically knowledge of C is very useful in Java, and knowledge of assembly is very useful in C, but it's fairly rare to need to go down two layers of abstraction from Java to assembly. Though sometimes it happens, e.g. http://shipilev.net/blog/2014/java-scala-divided-we-fail/#_modeling_the_effect 
I think there was some truth in that - the big difference is being able to understand how a system works in its entirety. Memorizing assembly commands is not useful as a java dev, but understanding how the JVM can allocate on/off heap memory, its effect on GC, memory paging/caching etc. are much more understandable if you've been exposed to the low level code that actually accomplishes those things.
Java bytecode is almost assembly. In my short career I've had to deal with bytecode in several occasions, and having some understanding about assembly programming made it much easier to learn enough about the Java bytecode to get by. The hardest problems in Java are (arguably) related to threading, synchronization, etc. You need a very thorough understanding of how threads work, how CAS instructions work, what guarantees provides the Java memory model, etc. If you need JNI or deal with libraries that use it, you'll most definitely need to know how to use a debugger and other system tools. If you need pure, raw performance, you need to take into account a lot of low level stuff (memory padding, false sharing between CPUs, etc.) This is only needed if you are developing a high performance library for X, but some people need it. The point is, if you go deep enough into any technology, you'll need some lowlevel knowledge. 
thanks. it's nice to see how experienced programmers have different opinions on the importance of Assembly depending primarily on the field they work in. :)
No problem. It's also worth noting that other people on my team do have that low level knowledge e.g. of compute clusters and memory efficiency. They are vital to our teams survival. Hopefully I can learn enough to get to their stage in the future.
What? You mean Takipi wasn't built in a day?
good luck for that :)
Good read. One thing to note is that since Optional doesn't implement Serializable you may experience issues using Optional for class fields. See [this StackOverflow post](http://stackoverflow.com/a/24564612).
Optionals are great, the guava library also has an implementation of them. 
I thought IB required a 10k account before you had access to their Java api? edit: the project looks very cool though, I've been prioritizing reading about Rx anything lately.
No problem at all :) So when you have a multi-dimensional array, we as humans often think of it as a geometric shape. In the case of a 2d array, as a rectangle. Like this: 00 01 02 03 10 11 12 13 20 21 22 23 30 31 32 33 However, computer memory has only one dimension. So it gets serialized into a line. This can be done in two ways. Row-major: 00 01 02 03 10 11 12 13 20 21 22 23 30 31 32 33 or Column-major: 00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33 Famously, FORTRAN was column-major, while C was row-major in how they stored their arrays. As Java is a descendant from C if you go back far enough, it is also row-major. When you couple these storage patterns with cache (generally an order of magnitude or two faster to access than main memory) and you end up with some fairly profound performance effects on your array traversals if you traverse an array stored row-major in a column-major order, and vice versa. Here's why. Your cache assumes something called locality of reference. This is a fancy way of saying that it assumes if you access a particular location in memory, you will probably also access other nearby locations soon thereafter. This has been proven true for many workloads in a number of studies (and it is absolutely true for the memory storing your program instructions, with the exception of jump and branch instructions (there's that nasty assembly rearing its head :P )). To exploit this, cache designers will load not just the memory location you're accessing into the cache, but they'll load a whole block of subsequent address from main memory into cache at the same time in the hopes that you'll use them. Let's do a simple example. Say for simplicity's sake that our cache blocks are large enough to go hold one full row of that array I drew out above, e.g. 4 integers. Assume also that our cache only holds 2 blocks at a time (this isn't realistic, but neither is a 4x4 array). This means that when you access the first element with the first (row-major traversal) implementation, you'll load the whole first line of the array 00 01 02 03 This is the only cache miss you'll have for the next row because the inner (j) loop will then only access things you already have in cache. However, with the second (column-major) implementation, you will load the same cache block as you access 00 first. But the inner loop will then access 10 and that row will be loaded into cache, 20 loading that row into cache and evicting the 00 row (because we only can store two blocks at a time), and 30 loading that row and evicting the 10 row. Now when you return to the outer (i) loop, you'll access 01, which will be a cache miss as it was evicted from cache earlier. This will proceed on, never actually getting a cache hit and always having to go to main memory. In a real system, it won't be quite as bad as that example, but as you can see from that demo code, the difference is still rather nasty. Hopefully this clears up what's going on under the hood here. Feel free to ask if you have more questions about this or anything else.
&gt;you could take...operating systems,...compilers, languages,... or... security Good luck with these without any assembly background. And those are just the ones where assembly knowledge has direct benefits (and possibly cannot be done without assembly). There are less obvious benefits in many other areas. I think assembly may not be the most important thing, but you need at least a good understanding of the machine for a number of fields. And assembly helps build that. It may not be fun for many people, but it's good for you.
A high-level understanding of how the machinery works is valuable for general Java programmers. As a developer you need to understand the machine you are writing to, whether its the physical model (x86) or a virtual one (JVM). This makes it easier to understand the performance of different operations. An example of understanding the virtual machine is garbage collection. One design might prefetch significant amounts of data to keep it in memory, while another caches only a subset and fetches on demand. Which is better? The former might abuse the old generation and result in major collections, whereas the latter has low pause times but needs to try to hide the network latencies. Understanding the physical model is especially useful for concurrency. A traditional misunderstanding is whether `i++` is an atomic operation. It may be a single Java statement, but in hardware it is a load, add, and store instruction. To perform an increment atomically you would need to use an abstraction like AtomicInteger, which may either use a hardware compare-and-swap or fetch-and-add instruction.
I think my curriculum was way different than yours because the courses I took on compilers and operating systems had zero assembly. You got that side of things if you were in ee, ce, or micro E. 
Knowledge helps, however more important is a the aim and will to get the most efficient solution. I wrote the fastest version of my somewhat popular serialization https://github.com/RuedigerMoeller/fast-serialization at a point where i did not even knew about CPU caches just by experimenting and gut feeling ..
I think you are looking for [orElseGet](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#orElseGet-java.util.function.Supplier-) ? &gt; Return the value if present, otherwise invoke other and return the result of that invocation. 
The only times you should ever peel back layers of abstraction is when you have a performance issue, or an implementation bug (make sure to read the documentation first). The purpose of each layer of abstraction is to provide a set of guarantees that you may program against. As long as these guarantees are properly implemented and you understand the extend of these guarantees, your code will be functionally correct (assuming the same can be said about your own guarantees). Implementation bugs are fairly rare, but they do happen. Most of the time, lower level code is looked at for performance reasons. After profiling and determining *where* a performance problem is, you must understand *why* it is happening. What's going on with gc and the memory? Are you making blocking network requests? Is an algorithm improperly designed for a certain data set? In order to answer these questions you must understand lower levels of code. Knowledge of how the Java memory system works helps fix memory related performance issues. [Knowledge of language and system semantics can speed up many operations, without changing their correctness](http://stackoverflow.com/questions/11227809/why-is-processing-a-sorted-array-faster-than-an-unsorted-array). Recently, I was working on a tool that gathered data from a database elsewhere on the network. At first the tool took about 30 minutes to run. After analyzing the program, I found that it was making thousands of network requests, so I batched them up. After making the change, the running time of my program was 30 *seconds*. This change did not affect the inputs or outputs of my program in any way, but by changing *how* I processed my data allowed me to drastically improve the performance of my program. As for knowing assembly, knowing how processors are built is much more helpful. Being able to answer the question, What are branch predictors/caches/super scalar architectures and how do they affect performance? is a huge help. Java compiles to bytecode, but learning how the JVM works is more important in the same way.
... in the same way that running affects your basketball play.
Almost none because the JIT can optimize shit on the fly. 
Josh Bloch would tell you to not use arrays but what does he know. 
I've been a Java developer since 2000 and have yet to use my knowledge of assembly in Java. Unless you're writing a compiler, knowledge of assembly is unnecessary. Your time is valuable and time spent learning assembly could be spent learning other skills that are far more practical.
I could have chosen to do a project where I wrote a compiler from scratch. I think everyone did scheme to C to scheme. I wrote a compiler for a subset of C++ in C/C++ given a C compiler.
thanks
so you are saying it is very important. thanks
Two words: Native Libraries
Come to Croatia on holiday :) a lot of Poles do our coastline is stunning. But yeah unemployment rate here is the worst in the EU (except Spain and Greece) so the people are happy if you can find a job for any salary.
It is simpler, because you don't have to switch files back and forth. New features in languages often make the code more difficult to read at the beginning, but after some time it becomes easier. In the synonym example, the IDE would suggest you that BuyingPrice is just a synonym of BigDecimal. I have read (and refactored) a lot of code written by other people! :-)
To answer your first question, you can have multiple public classes in the same source file. What you can't have is multiple top-level classes; you can have as many nested classes as you like. These classes be associated with a particulate instance of the outer class &gt; As with instance methods and variables, an inner class is associated with an instance of its enclosing class and has direct access to that object's methods and fields. Also, because an inner class is associated with an instance, it cannot define any static members itself or they can be static classes that are not linked to a particular instance of the enclosing class. In effect, these static inner classes behave exactly as if they were in a separate source file. &gt; As with class methods and variables, a static nested class is associated with its outer class. And like static class methods, a static nested class cannot refer directly to instance variables or methods defined in its enclosing class: it can use them only through an object reference. &gt; &gt; Note: A static nested class interacts with the instance members of its outer class (and other classes) just like any other top-level class. In effect, a static nested class is behaviorally a top-level class that has been nested in another top-level class for packaging convenience. https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html # Instance Class public class Outer { int field; public class Inner { public int getField(){ // this is allowed because Inner is // associated with a particular // instance of outer return field; } } } # Static Inner Class public class Outer { public static class Inner { public static void main(String[] args){ System.out.println("Static methods can exists but, his class cannot access instance variables of outer"); } } } Notice that `Inner` has a main method. This is to demonstrate how Inner behaves exactly as if it were in it's own file. At the command line run `javac Outer.java` then examine the contents of that directory. It should contain `Outer.class` and `Outer$Inner.class`. Now run `java Outer$Inner.class`. The main method will execute as normal. To use inner from within a program, refer to it as `Outer.Inner`. An example of Inner classes being used in the Java API is `Point2D` and `Point2D.Double` or `Point2D.Float`. You can examine these class if you want to see how static inner classes are used in actual programs.
You are right. What I meant is top-level public classes. I have updated my post. Static inner classes are somewhat similar to what it should be, but are more complicated to use than top-level classes.
What would be gained by having multiple top level public classes over having static inner classes? They behave in exactly the same way except in how you access them.
In mu opinion, static inner classes are somewhat clumsy. In my example you see Point, Segment and Triangle. They should be static inner classes of something. But what should they be inner classes of? Geometry? Euclidean Space?
&gt; But instead you now have to scroll up and down in a MUCH larger file instead of switching between files. That depends on how the software is written. More freedom is given to the programmer. It is up to him to structure well her/his source code. &gt; Again you're not telling us what problem that would solve. It provides more loose coupling in case in future you want to use a different class than BigDecimal to represent money. For example, at some point you would like to use [JSR 354](https://jcp.org/en/jsr/detail?id=354).
Right. That does not solve a particular problem, but allows you to create a more powerful type hierarchy.
Yes, that would break the convention. But your IDE would help you to find your class anyway. And it would be in the same package, which means the same folder on the filesystem.
To have all related classes in the same file, if they are short. Not having to jump too much from one file to another.
Well, in my everyday work, I have to extract a lot of methods from giant classes. But it is not a language fault if the language is used in a bad way. Giant classes are always been possible and will always be. But that's not a language fault.
Yes, that was more than a little annoying.
I am very happy about that. A shell is a great learning tool and as a programmer, you never stop learning. You could try some objects of a new library with a shell.
I'd like to see this expanded to groovy style scripting. In the end it could be an advantage to have cross platform scripting without having to install an additional kit (e.g. groovy).
You could use [Java 8 Nashorn](http://www.oracle.com/technetwork/articles/java/jf14-nashorn-2126515.html) for that.
My answer was more global. Pointers are used when using objects as parameters. You can eg modify the object without returning it. Otherwise you're right. The pointer technology is pretty good hidden in Java (as intended).
Now I need a Square which uses Points and Segments. Where the hell does it go? In the same file as the Triangle class? This kind of organization will be disastrous for any project that gets remotely complex.
http://socket.chat/r/-.- 404 ;)
Do you want feedback on the system or on the code? If the former, I suggest developing a system around existing efforts. I personally like the effort behind matrix.org
Your commands command seems to be off Server: Unrecognised command: commands. Please type /commands for a list of commands. :P
Care to share the source?
&gt; no more getter/setter nonsense would be nice too, if they are making a wish list Lombok and Google AutoValue 
The system primarily, because I intend to completely re write the client and server. But here is the repo if you'd like to see the code: https://github.com/final60/websocket-chat
Interesting, I'm considering frameworks after this 'alpha' stage but I don't think its necessary for server side at the moment. All the heavy lifting is done on the client side.
&gt; Freedom of Speech is your freedom to say anything you want. It does not include forcing others to listen. I agree. People choose to visit Reddit, they aren't forced to, and if they don't like what they see they can downvote it. &gt; This means we (mods) "censor" things that do not belong here, given your definition of censorship. &gt; And you folks should be grateful for it, because otherwise /r/java[1] would have been overrun by trolls and spammers long ago. Actually in my 9 years on this website I've probably seen more harm come from over-zealous moderators than benefit, people can downvote trolls and spammers, and they do a pretty good job of it from what I've seen. Or don't you have any faith in the readership of this subreddit?
that is what boggles my mind. I can start to understand how the NSA's systems can literally slurp up every single phone conversation's meta-data and store &amp; analyze it. There are only 1.5 million emails sent every second. If there were 1 Billion "things" that happened per second on the internet, that is still easy enough to scale up to process and log all of that meta-data.
or 2.5M emails / sec if you go by this site's numbers: http://www.internetlivestats.com/one-second/#email-band
Thanks, I took a look at your server code. I intend to re-write it using more OOP and less procedural approach.
More freedom isn't always a good thing. When working on a project with a lot of people with varying skill and experience it is beneficial to have a language that restricts creative solutions.
Let me understand that correctly. You want Java to have less features only because you don't trust your coworkers?
live demo included ..
Yes but it is more than that too. I want the code to be obvious and for people to be able to successfully interact with with a minimal amount of gotchas per time spent learning about it. For this reason I am also glad java doesn't have operator overloading or a templating mechanism. 
ok I went through both application calls and now I am getting the opposite results. non-zipped is faster than zipped. gotta figure out what is different....
Learn to reddit
&gt;Possibly unknown fact: arraylist has an internal counter for the number of times it has been modified. Going over that count (Integer.Max_Value) results in a null pointer exception iirc. No. The modification count is used to detect concurrent modifications. The actual count isn't really important, so wrapping due to overflow isn't important. 
What's a reactive getter
It's a getter that you can subscribe to, so that you can react to changes.
How is this any different from any other callback/listener pattern? 
It's glue between the RxJava paradigm, the ListenableFuture paradigm, and the plain-old getter paradigm. I wanted to make a [git client that animated between branches](https://youtu.be/X4UQpGk1Ry8?t=47s) so you could tell what was going on, so I tried using RxJava. But I found that often I'd need to subscribe to a value in one place (RxJava was great!) but somewhere else I'd need just a plain-old get(), and there wasn't a good way to do that with RxJava. So I made an [abstraction for that](https://diffplug.github.io/durian-rx/javadoc/1.0.1/). Also, I found that handling errors from ListenableFuture and RxJava was exactly the same problem, but I had to write completely different code for each. So I made an [abstraction for that](https://diffplug.github.io/durian-rx/javadoc/1.0.1/com/diffplug/common/rx/Rx.html). Once I had those abstractions, a bunch of stuff naturally fell out, and that's what DurianRx is. One example of an interesting that fell out: reactive programming has a lot of map(). RxGetters support map(), which has turned out to be really useful even when they're just being used as plain-old getters.
Well the link you've posted just links to itself, not to any sort of survey or results. I don't think you can fix it up after you've posted so the only thing would be to make a second post with the right URL and delete this one.
I've modified an ArrayList instance many billions of times. Whatever problem you had, it was not because of the modification count (unless it was a concurrent modification error, which is by design). The source code for ArrayList comes with the JDK. Post the version and line number where the modification count overflowing caused an NPE.
Thanks for your clarification. Would you please kindly give me another help? I am not very good at reddit's format. I included my original message below. After posing it, I have tested each of the hyper-links. But I may have made other mistakes. If possible, would you please identify the areas needed improvement? I will then fix it and post again. Thank you very much. ---------- Dear programmers, To aide programmers in producing power efficient applications, we need to understand what programmers generally know or do not know about software power consumption. By understanding the mental environment of programmers, we can better design tools and solutions that address their needs to reduce software power consumption. On 2013-08-29, we invited this group to participate in our [Green Programmer Survey](http://green-programmer-survey.softwareprocess.es/). Thank you to all who contributed to the research. Through the survey we try to answer four research questions: **[RQ1]** Are programmers aware of software energy consumption? **[RQ2]** What do programmers know about reducing the energy consumption of software? **[RQ3]** What is the level of knowledge that programmers possess about energy consumption? **[RQ4]** What do programmers think causes spikes in software energy consumption? The research results will be published in [IEEE Software](http://www.computer.org/web/computingnow/software) in the near future. If you are interested, the raw data summary can be found [online](http://webdocs.cs.ualberta.ca/~hindle1/2014/green-programmers/). A [preprint version of the paper](https://peerj.com/preprints/886) for peer review can be found in [PeerJ](https://peerj.com/). If you have subscription to [IEEE Xplore](http://ieeexplore.ieee.org), the IEEE early access version of [What do programmers know about software energy consumption?](http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=7155416) is also available. Once again, thank you very much for your help. Best regards, Green Programming Team 
Maybe your anomalous results are being caused by file IO caching. That is, on following runs your file is either partially or fully cached in memory. 
Seems strange that they wouldn't use a Long instead (although if Integer wrapping isn't a problem I guess there's no need for incurring the extra memory overhead, however slight)
That seems fine, all the links seem to work as intended. Reddit markdown basics can be found here: https://www.reddit.com/wiki/commenting 
&gt; I was pretty surprised how fast the File input is, but then again, this laptop has an SSD so that is possibly why. Whats more likely is that the OS put the file into a RAM cache the first time you accessed it and then just loaded the entire file from RAM each subsequent run.
I second that. Imgur please, OP!
under no circumstances learning more is detrimental, still, my question is how this aiding Java programming. As far as the rest concerned, you are certainly right. :) thanks
I agree; these are good ways *around* the problem, but the problems should go away. I.e. Lombok is handy for a relatively nice toString method, but this Lombok toString with introspection could have been thrown in the Object class, to avoid this `com.what.ever.SomeClass@12345` semi useless default implementation; and if Java insists on this nonsense idea of public variables that are private in name only (getters and setters), then they should provide these getters and setters as a language feature to avoid using Lomboks `@Data` decorator. Ideally Java should move away from that idiotic idea of creating "private" variables which anyone can modify and read, which really makes the word **private** completely void though :-)
When reading the above I do wonder why this was implemented in Java in the first place. Especially with trying to totally avoid to allocate objects one of the major advantages of the language (very efficient allocation and disposal of short lived objects) goes away.
&gt; compromise? had a very quick look at it, didn't seem any easier than Assembly, thanks though :) Well, I think it has less instructions than a modern CPU's instruction set and it has the added benefit that it is directly related to your Java program. So I'd say it's easier to learn and helps you understand the low level "mechanics" of your Java application.
alright then, will examine them a bit more thoroughly in the future.
What is UserSession in the server for? I would recommend you get rid of it. And, never use it!
This. I have been dealing with this the last few weeks and it is wearing me down like a thousand paper cuts. I manage one project where 2-5 people are involved and some smaller ones where only I am active. A few telcos and issues in production and I can completely forget my productivity for the whole week. There's a larger database refactoring that I am putting off for weeks because I need to focus for at least half a day on it to get anywhere. A call with an issue in production? Forget it, not getting anything done today. The awareness is there in the company that it's a bad situation when you have developer and manager hats on, but we're not staffed well enough at the moment.
Which OS are you using? What disk drive? No matter. If you repeatedly access the same file, OS will cache it in RAM. So gzip will lose its performance advantage. You must throttle your read speeds to estimate what would the performance if your disk/network is capable of reading file at X megabytes per second. On Linux, you could do that using a named pipe and a "pv" command. On Windows, maybe there is a way to flush disk cache and force the file to be read from the disk. On top of that, uncompressing gzip is quite CPU intensive. If you want pure performance you might want to use compression algorithms like LZ4 (https://github.com/jpountz/lz4-java) or Snappy (https://code.google.com/p/snappy/) which are built for less compression but much higher compression/decompression throughput. On top of that, if you create a small ArrayList (use defaut constructor) and keep adding records to it, it will have to reallocate its internal array and copy data across, which is expensive when the list is big. Try allocating ArrayList of the right size at the start to improve performance. On top of that, primitive types and arrays are much faster/memory efficient in Java than objects and collections. So if you use int[] or long[], that's much faster than ArrayList&lt;Integer&gt;.
I wonder why these conversations are always so focused on programmers. Like we're such special snowflakes. Is it really not generalizable to everyone at the office?
Having been on both sides of this issue, I can understand the authors point of view; the groove *feels* awesome, and it does yield productivity. That point where the world falls away is sublime. On the other hand, I've had development staff who have "gone dark" while working on a project and pursued an irrelevant problem down a rabbit hole that cost nearly a full day of work. If a developer is super-disciplined and completely understands all parts of the project (not just the software), I am comfortable leaving them to "groove" all they like... but I have yet to meet such a developer.
"green" programming? like, "environmentally friendly" programming with a "neutral carbon footprint" ? what's next, "organically grown" programming?
I messed around with a proof of concept using Apache as a front-end proxy in front of a Glassfish server. Apache has way more authentication and authorization modules available. I was able to do an "if available" client auth and pass through the SSL params (one of which is the complete client cert) to the app running on the Java Application Server to use or fallback to username/pass if no client cert was presented. Some idea of proxy setup here: https://www.manorrock.com/blog/2015/07/12/apache_2_4_x_ssl_mod_proxy_and_glassfish_4_1.html On the Glassfish side you access the SSL params that Apache set through the ServletRequest which you can cast to a HttpServletRequest. For instance, here's the cert chain of the authenticated user: X509Certificate[] chain = (X509Certificate[]) request.getAttribute("javax.servlet.request.X509Certificate");
Pandora's box has been opened... public void setFullname(String fullname) { this.fullname = Optional.of(fullname); } public Optional&lt;String&gt; getFullname() { return fullname; } Both `Optional&lt;String&gt;` and `String` types are... optional.
"Don't interrupt me when I come in" k "Or at the end of the day" k "Or after lunch" k "Or while I'm the middle of something" k "In fact just never talk to me ever, send an email" ok? Has this guy ever worked in a team? Meetings can be disruptive if there's too many of them but if you disappear into an ivory tower you'll do silly things. It just sounds like he needs a day or two of sanctuary each week.
Why would you post the dzone link? Seems like original article is here: http://www.oracle.com/technetwork/articles/java/enterprise-html5-2227136.html
I should also note that G1 is much more idiot proof when it comes to setting things up. There are 3 flags that you have to care about, the min memory size, the max memory size, and the desired pause time. Once you set those things up G1 will figure out pretty much everything else (it does have a lot of knobs to turn, but most people don't need them). CMS, on the other hand, requires a ton of tuning if you are targeting a specific pause time. And even after that, CMS will pretty much always end up doing a full GC every so often due to the fact that it fragments the old gen (no compacting). G1, on the other hand, will defragment the old gen and collect old gen as it does minor GCs all in an effort to reduce the number of full GCs that need to occur. But even when a full GC occurs in G1, it does a lot of work to make sure that takes as little time as possible by piggy backing on minor GCs to collect information to keep the full GC short. There are very few things that CMS does better than G1, so if you are currently using CMS (and haven't already evaluated using G1) you should definitely look into it.
"Green" programming for mobile devices makes sense, but in desktop applications it doesn't. What difference in energy consumption can be made optimizing things that aren't bottleneck? Equivalent of one car trip to shop per 10 years? 
Refactor your damn code. SOLID principles says you never have a single routine be that complicated. I'm in a lead role usually but still code as much as I can. Distractions are part of my job. Client meetings, vendor management, status reports, resource planning. Have to do them. So I only code in short bursts. The key is to break down the problem into bits and code the bits as you go. That way you never hold the whole problem in your head at once.
I agree with you. I was thinking about battery life, otherwise I should also admit that desktop optimization makes sense, since differences in energy consumption would be higher. 
I was reading up on the Kafka implementation the other day and they mentioned that, contrary to what one might expect, they do not attempt to cache data in their application and instead read/write from/to disk. The argument for this is that the reads and writes are very linear, so the OS will already be optimizing and caching them. Adding another cache only wastes memory and complicates the process. They also linked to [This Article](http://queue.acm.org/detail.cfm?id=1563874) which shows that sequential access from disk (not even SSD!) can outperform random access from memory!
Very good comments. Thank you.
sorry bout that, imgur is blocked at work so I used one that wasn't blocked. figures that someoen else would have the opposite problem. :-)
It’s pretty amazing how even a few seconds here or there can really break your concentration. Microsoft did a survey regarding loss of productivity due to email and IM, they found that the average employee (not even just programmers) took something crazy like 9 mins to start being productive again after a 30 second interruption. Disruptions don’t even have to come from coworkers, think about our own tools when working with Java, build processes and app server redeploys definitely take me out of the zone. Look at something like [JRebel](http://zeroturnaround.com/software/jrebel/), keeps you in the flow so you don’t sabotage yourself when you’re trying to be productive.
that was the most surprising find for me. System.out is sloooooooow. huh.
You might just need to update - it was supposedly fixed quite a while ago: https://java.net/jira/browse/VISUALVM-580
&gt; HAVE TO BE FIXED RIGHT NOW BECAUSE THE SKY IS FALLING AND OUR DEPARTMENT CAN'T DO ANY OTHER WORK UNTIL THIS IS FIXED FIX IT NOW BUT HEY WHAT ARE YOU DOING FOR LUNCH, WANT TO GO GET A BITE TO EAT? http://i.imgur.com/feDcxmD.gif
I feel your pain. My predecessor, financial consultant, taught himself how to bubblegum and duct tape PHP together which set a new precedent at the firm. They pull me in because I have a background in software dev, I nearly die when I see the three years of shit he hobbled together. He quits after he sees me come in and basically burn all of his code, all his bullshit gets dumped on me, now I'm basically doing the jobs of 3 people along with expectations of enterprise-quality software dev for less than half of what any random code monkey gets paid. Meanwhile boss is talking about flirting with $150k cars, co-workers are buying houses, and I can't even fucking afford health insurance when literally half my take-home goes toward rent and student loans. Hope this is just one of those weeks because this shit has to stop before I develop a heart condition.
Java certification great, says Java certifier.
Starting editing isn't the same as reachieving flow.
Yes, that is true bud www.indeed.com actually shows that the words "Java Certification" appear many times on most job description. According to a recent Foote Partners report, pay for Sun Certified Java Programmers rose 13.5%. 
&gt; Is it really not generalizable to everyone at the office? Not really. If your focus is administrative or managerial, you can go through your task list and write up the emails, place the calls, plan the resources, etc. You may even have processes in place to tell you what to do next. If you're a developer or architect coping with a larger code base, then you have often have situations when even smaller changes may have large effects. You're dealing with complex systems. 
Thanks for taking the time to reply. Would you happen to have any of the source code to share with the smart card logic? Unfortunately, good references for JASPIC are few and far between. I'm still trying to figure out how to get it working on WildFly.
Ok, I have a bit more complete screen captures of the NetBeans profile of my code. I ran the tests 10 times: * Read in GZipped, sort * Read in Plain Text, sort As expected the sorting steps are virtually identical, since the output of the file ingest is the same, an `ArrayList&lt;Integer&gt;` http://learningrealworldjava.blogspot.com/2015/07/how-long-does-it-take-jdk851-on-2ghz-i5.html
please keep in mind, I'm not a researcher or even a proficient developer. I'm learning / teaching myself Java.
No other solution. This industry is of enough that I am looking for a new job just because I want something new. I am happy enough where I am, but change is exciting and it usually comes with a pay jump.
***Note to programmers that haven't been programming long enough to pay off their student loans: "burning" existing production code, no matter how messy, is very rarely the right thing to do. Edit: Because I know that I sound like a condecending prick and that you probably want some reasoning, read this article: http://www.joelonsoftware.com/articles/fog0000000069.html. IMHO this article is required reading for all programmers. 
Just because I can go down to the store and buy all the milk it does not mean I should. You're going against java standards. If you what to freely do what you want when you want, then hopefully you're working on a project by yourself because I would hate to work with you. 
Aside from it taking 10+ years to pay off loans, the code had no tests, had no architecture, had no anything. It wasn't "battle tested" or "tried and true," it didn't even have package management. It was a 3-year shit-heap of global functions and variables crammed into the asshole of a Wordpress theme. Half the time a screen full of errors meant the code did what it was supposed to do. Burning it was absolutely necessary.
I think programmers have a larger minimum work block, but other knowledge workers likely suffer similar issues. (Doctors and Lawyers both come to mind.)
I'm studying for these exams right now as our company requires it to get rid of the Junior title. I find them absolutely a pain in the ass and wish I could spend my time on other more useful stuff.
I bet your company required you to get a Reddit Certification in order to qualify for hyping their shit here.
I have a guy at work, who actually makes fun of scaring me while im deeply concentrated which mostly interrupts me on such a deep point I have to do something else afterwards. It's like he is flipping the table I ordered all that shit on. 
Try Arrays.sort. It's a variation of quicksort 
That makes no difference in what I said. Apache can front-end any Java application server. 2 seconds on google: https://wiki.bitnami.com/Components/Wildfly#How_is_Apache_server_connected_with_WildFly.3f
So... I tried in vain to get plugin updates through a proxy server using the settings in the VisualVM UI, even after clearing settings etc. I eventually succeeded by passing them on the command line as follows: jvisualvm.exe -J-Dhttp.proxyHost=x.x.x.x -J-Dhttps.proxyHost=x.x.x.x -J-Dhttp.proxyPort=8080 -J-Dhttps.proxyPort=8080 Hope this helps anyone having the same issue.
Sooo, let me get this straight: * You – /u/recallz – keep spamming Reddit with your video "tutorials" * After getting called out, you deleted all of them so they won't show up on your posting history (e.g. [here](https://www.reddit.com/r/java/comments/3dr6nt/java_ee_tutorial_14_jdni_resources/), [here](https://www.reddit.com/r/learnjava/comments/3ejh2a/java_ee_tutorial_161_jsf_faces_flow/) or this one from [yesterday/today](https://www.reddit.com/r/programming/comments/3fb2f4/java_ee_tutorial_17_jsf_file_upload/)) * After [you've been banned from this Subreddit](https://www.reddit.com/r/java/comments/3c0mo6/advanced_java_tutorial_8_find_out_the_java/), you created this alternate account to keep on spamming * And now you're doing the same [delete-old-video](https://www.reddit.com/r/java/comments/3ene5c/java_ee_tutorial_161_jsf_faces_flow/)-and-[post-new-one](https://www.reddit.com/r/java/comments/3fehw6/java_ee_tutorial_17_jsf_file_upload/) with this acccount, too?!! 
Hmm, HashMap to Stanford Generics and Stanford Generics back to HashMap, yes this is quite interesting. Oh and wait, java.util.List and java.io.Exception are really popular, I shall consider using them..
Its the hip thing to do and has been since the dotCom boom. The new folks in the industry like to think whatever is the "latest" is so much better and completely replaces whatever it is they think is "old". The most amusing part of this stance is the ignorance that shows from it. Computing and it's technologies are cumulative. Very rarely do you see something completely supplant a core concept; rather than augment it.
Nice tutorial. I don't always like video tutorials but this one is well done.
Cut it out with the spam
You can actually view the migrations, the HashMap thing makes more sense now :)
1) Use Maven 2) Use the shade plugin to create an uber-jar 3) Make sure the same version of Java is installed on the Pi 4) java -jar my-project-1.0.jar 5) Collect paycheck IntelliJ supports Maven extremely well... you should not be dealing with cross-compilation or OS-level package control for a simple project like this
Use maven to create the uber-jar. scp it to the target host. java -jar and you win.
This sounds as simple as I originally thought it would be, but when I first created a Jar and sent it over to the Pi, I was getting errors about it not finding the Main class, also errors about a Launcher. These errors are what I searched and the answers seems to point to me needing to package everything together.
Well, the classpath/classloading thing *is* a fickle beast. And also why almost everyone is using a buildsystem instead of specifiying everything on the commandline. But the buildsystem's goal should be to get a `jar`, not an installer for the OS. Still: massive kudos for your relentless to give up. Installing a VM to install linux to install git to get sourcecode to compile natively? Waaay more effort then I would have put up with :D 
Thank you so much! This one liner is all I needed about 2 days ago! I was trying to run the file with Java -Jar myApp.jar, it was this line that would complain about Classes and Launchers. Your line above is all I needed. I now have my application running on the Pi. :)
I feel your pain! Switched from .NET myself some years ago. Compared to .NET - simple things are very hard in Java. But the worst part is that everyone is OK with this in Java community. My only guess is that developers just got used to dealing with crap like this... You'll probbably have to use Maven and something like "maven-assembly-plugin": http://www.petrikainulainen.net/programming/tips-and-tricks/creating-a-runnable-binary-distribution-with-maven-assembly-plugin/ But if you're .NET guy, this answer of mine can basically sound like "Go F***", but its Java, there are no easy answers. 
Glad it's running now :) &gt; it was this line that would complain about Classes and Launchers. You can't use `-jar` and `-cp` together (which you probably did to get the SQL driver in there), they're mutually exclusive (see e.g. [this SO post](http://stackoverflow.com/questions/15930782/call-java-jar-myfile-jar-with-additional-classpath-option)). On a sidenote: did you look into running a .NET application on the Pi using Mono? I have no idea what the state of that is, but I guess for a simple application it should be working, no?
Frankly, you're overthinking it. You are using a sledgehammer to squat a fly. Java, for example, will, as will .NET, have a (relatively) high footprint for such a simple application, especially if you're going to run it on PI. I've been doing Java for years and wouldn't use on in this case - I'd probably just script it in Python. Regarding comparison between .NET and Java: yes, it's true. Some things are simpler in .NET. But this stems from the fact that one company controls everything - from the IDE, through the language up to the platform on which it's executing. Java offers you flexibility and with that comes, unfortunately, additional complexity. 
Nah I wouldn't like to use Mono, I never have as I always think there would be huge limitations. Now .NET is open source we might hopefully get something better than Mono in the future.
You know Python never even crossed my mind. I've never written anything in Python before so I am sure it would of been a bit of a learning curve but so has this. Looking back I think I would have given Python a chance.
The best IDE is the one that works for you and not against you. I like IntelliJ but I have to use eclipse at work. Both get the job done.
In terms of guides/reading, Effective Java (2nd edition) is a great book to get the concepts right. 
If you are just starting out intellij will be just fine. We have a big code base at work with a lot of classes having over 40k lines, Eclipse is much better there. 
Do you know any specific instances of this?
This is horrible advice. Learning the standard language with help from an IDE should absolutely be a starting point, not poking around in a pure text editor and hoping you're calling the right thing. Try Eclipse or Netbeans. I personally feel like Netbeans is a bit simpler to learn. If you want the best IDE, spend a few bucks on IntelliJ or see if the Community Edition will fit your needs. 
Huh? IntelliJ IDEA is much better performing with large codebases (and better performing, in general, in my experience). 
i would walk the fuck out if i couldn't use command line + vim
If you spend a couple hours most of the time you can find a workaround for that. And I'd have serious reservations about using something other than git or svn. I've never had a good time with any of those commercial solutions, they're generally shittier less functional clones.
&gt; Most jobs have version control integrated into a specific ide I've never heard of this ever.
Personally I like eclipse the most. A lot of people seem to like Intellij Idea. I find eclipse a bit more Java aware but use Idea at work and it does the job.
The whole advantage of languages like java is easy programmatic static analysis in the ide. It's what allows things like the autofill, those red this won't compile lines, being able to read javadoc in the editor, and procedural written code to be done easily. vim can do that, and it is far far more efficient at editing large sections of text, but it takes some random arcane plugins that are insane to find and configure to emulate that functionality. I wouldn't put that solution up without pointing at a list of those; for instance a quick easy one is there's an eclipse vim plugin that lets you use it's build tools and highlighting in vim if I remember right. Unless your just being a crufty academic bastard who thinks there is any benefit at all in programming in something like notepad. I don't know why that kind of thinking is so pervasive in colleges, it only teaches you to smack your dick with a hammer and name every variable things like x.
I like Eclipse and IntelliJ.
Idea&gt;Netbeans&gt;Eclipse
I have java a classes with 68000 lines of code and round about 4 million lines of code in total in libraries with no lag issues.
If they have a site license or no license and you ask for $600 or whatever for IDEA, they could say no. 
I really wish this was open-source, I'd fork it to run against my companies internal GHE repositories and add features like ability to track by organization etc. (And filter out jdk built-in libraries) (And of course if I forked it I'd send pull requests with changes)
What kind of performance numbers are you looking for? From what I've seen, the thread-sharing frameworks and servers start showing a slight performance increase once you are handling more than a 100 concurrent requests (assuming some simple CRUD I/O in the backend), and becomes a necessity past the 1000 request mark because of the context-switching overhead of the OS threads. If you have no constraints of this order, I believe it boils down to what API you prefer. FWIW, I think Spring Boot rocks, and I kinda like Vert.x too.
Others may disagree, but when I am interviewing candidates I--at the very least--will ignore such exams. If the rest of your resume is not compelling, I will probably actually hold the exam against you. Why? Because wasting your time and energy on exams that don't demonstrate your ability to actually do real world programming tells me that you fundamentally do not understand what is important in the industry. If I were hiring for a Java shop, I would choose someone with zero Java experience, but actual demonstrated ability to develop software over someone with little more than a bunch of certifications **without hesitation**. EDIT: There are, of course, certificate fetishists in the industry who will throw your resume in the garbage if you don't have any, but in my opinion these people are not people you want to work for anyway, for a similar reason to what I wrote above: if you are basing hiring decisions on a test that demonstrates no real world competence, you are bad at hiring people. So, I would consider this to be a good way to weed out terrible employers. 
The best thing to do for your career is actually program. Try to learn best practices and apply them to your code. 
Exams like this have no value. As a college freshman the three things you can do to promote your future as a software developer are: complete your degree successfully with a major relating to computers, develop a personal portfolio of useful working software, and obtain employment as a summer student/intern/co-op (whatever your school supports) doing software development work.
Forget the exams unless you are looking at working in the federal government. Spend time reading and writing code. A lot of code. Get a github account and start writing some code. Fix bugs and start giving and accepting pull requests. Learn and become expert with the tools of the trade. Eclipse, Maven, Git, Jenkins, Linux, Tomcat, etc.. Learn JUnit and a mocking framework and write lots of unit tests. Learn the debugger inside and out. Understand exactly how the JVM works. These and a long history of work compiled on github will get you the furthest. Finally get your computer science and math knowledge down pat by the time you graduate. Personally, I would learn Assembly and C as well.
haha. with IDEA the only thing a developer can do is say "WTF were they thinking" every 2 minutes. 
Definitely this. I'm in the exact same boat as you. Mostly Websphere, forced into RAD (Eclipse with Websphere support built in). Work for a huge company that gives me very little choice in tools, but it isn't that bad. Eclipse is a solid IDE. Lots of versatility. 
Have a look at sonar. It has all this info and more. 
Java is a language designed to be simple to write and maintain, and as such it has quite a few opinionated design decisions to make it as "unsurprising" as possible. As it is if you have a class you immediately know in which file it is defined, you don't have to guess or use a specific tool to search for it. Most Java programs will be organized similarly and won't depend on the style of the original author, which helps to get up to speed quickly when a new developer arrives on the project. I agree that occasionally this can feel clunky but cases such as your example are rare and the advantage goes away as soon as you have more than a few pages of code. I'm not sure what you mean by "synonyms", if you mean simple aliases then it would only introduce confusion if several names designate the same thing, however if you mean type-safe aliases, then absolutely, I wish that feature was present in the language, maybe in the form of type tags. That would have went against the simplicity goal, probably.
I'm just testing out Vert.x to learn more about it. I think it's a cool piece of technology, but you'd take a big hit to developer productivity since it's so new. I trying to understand the performance hit you'd take using Vert.x fronted with Spring MVC vs using raw Vert.x for request handling.
When I saw that title my mind couldn't decide if this was in /r/java or /r/hockey 
I don't really have any experience with Python buy the set up should be quite minimal as it would always be run on the same device, the Raspberry Pi.
Because it demonstrates good knowledge of Java language, meaning less occasional fuck-ups which can cost the business a lot of money, just because someone didn't know some quirks of Java.
Having a certificate may say nothing about real world experience or skill, but it does show that you take your profession seriously.
&gt; it does somewhat help you stand out from the crowd Maybe. However, the opportunity cost is the issue. If the same amount of time were spent doing other things like developing open source software or developing a portfolio in some other you would stand out *even more*. Simply having a certificate will only make you stand out compared to people who have done *nothing*.
&gt; are not the things that developers learn and use daily. So, why do I care if you know it? &gt; They are mostly just corner-cases which most people just try to avoid even dealing with, because they feel unconfident about their knowledge. So I'm going to hire you because you have mastered corner cases? Corner cases that any competent dev could learn quickly *if the need were to arise*?
This reasoning is exactly why I would hold the exam against you. If you believe that "occasional fuck ups" are a major factor in cost of development, then I am going to assume that you don't really understand the process very well. Sure, it would be nice if every dev knew every quirk, but if your list of accomplishments is so thin that you have to rely on that to stand out, then I am simply not interested in hiring you. ...unless, of course, you really impress me in other ways. In that case, though, knowing the "quirks of Java" will not factor into the situation at all. I.e., either your resume/interview/etc are enough to get the job, or a certificate is not going to save you.
&gt; Corner cases that could send your business under the truck because people in your team were just "good enough" to glue some code together from different libraries and some big mistake slipped in. Now wait just a minute. No one said anything about hiring devs who were "good enough." I think it's absolutely imperative to hire *extremely good* developers. The point is that being a Java expert does not make one an *extremely good* developer. Indeed, such exams don't even demonstrate that a developer is "good enough." &gt; Have you ever passed the OCP exam? Or maybe even OCA one? Of course not. Why would I? 
&gt; but something is even better than nothing. It's more about the false dichotomy that you are presenting. The options are not certification or nothing. The options are certification, nothing, or any of a number of other things that are much more beneficial than either certification or nothing: like a portfolio of work, real world experience, etc.
&gt; it was not 100% useless but my time could have been used more efficiently... That's a Bingo!
I did not say it is better than the options you listed. I said it is better than nothing.
Yes.
http://www.amazon.co.uk/Objects-First-Java-Practical-Introduction/dp/0132835541 It comes with it's own IDE which displays your project as a class diagram, which is great way to conceptualise what's going on. Once you finish the book you'd have outgrown it, but a great place to start. 
Nice.
The related Subs in the sidebar, and *their* sidebars.
/r/javahelp has a wiki with plenty books and tutorials listed. If you are looking for a solid tutorial, check out the MOOC "Object Oriented Programming with Java" from the University of Helsinki. Good groups are /r/learnjava, /r/javahelp, /r/java, and /r/learnprogramming, /r/javaexamples, /r/javatil.
Go on Amazon and buy a used, not-newest-edition of the Deitel and Deitel "Java: How to Program" for 1 cent and then read it while typing yourself every example in the chapter into an editor such as Textpad in the simplest case or Eclipse if you're up for a slightly larger challenge. Then, most importantly, do every single problem at the ends of the chapter. Getting each of those progressively-harder problems done will teach you Java and affix it in your brain. Then, supplement with youtube videos etc. 
"Opportunity cost"? The guy seems to be 18-years old, and hasn't even STARTED college yet. Free time is not the scarce commodity that it will become years later when he has a family. Certification exam prep involves about a 100 hours, maybe 200 tops (if it takes longer, then you're pursuing the wrong certification). That is a tiny drop in the bucket for a young guy's free time, and means that one shouldn't have to "choose between" exam prep or open-source tinkering (open-source tinkering IS good exam prep). If anything, it means that one merely has to shave off a little porn or video game time. Besides, just as there is a limit to how much certifications can help an entry-level beginner, there is also a ceiling on the "Your-GitHub-Is-Your-Resume" concept. Once you have created or contributed to enough repositories to fill up both columns on your profile page, I really don't believe anything beyond that helps you in terms of resume development. Not that you *shouldn't* write code in a trillion repos if you draw personal pleasure from doing so. I'm just saying that one you get past 5 to 10, you should be doing so for personal reasons rather than career development reasons. When I'm interviewing a candidate with an absurd level of GitHub "portfolio" activity, I start looking more carefully at commit logs to see what time of day the activity happens. I start to assume that you're doing a lot of your personal tinkering during business hours on your employer's time.
Not theNewBoston. His videos are [discouraged resources](https://www.reddit.com/r/learnprogramming/wiki/index#wiki_discouraged_resources) in the programming community. He has horrible variable naming, teaches frowned upon practices, and generally does not adhere to commonly acknowledged standards. Basically, his videos are prime examples on how not to program. It especially important for beginners to learn the proper practices and standards to avoid bad habits from the start. 
In systems like this, the format and content of the message becomes the contract, instead of say, a method signature or service definition. It's obviously not going to make dependencies go away - it's just a different way of achieving abstraction.
Exactly.
&gt; "Opportunity cost"? Yes. Opportunity cost. Even at his age there is an opportunity cost involved. &gt; Once you have created or contributed to enough repositories to fill up both columns on your profile page, I really don't believe anything beyond that helps you in terms of resume development. Who said anything about the *number* of repositories? I couldn't care less about how many repos someone has contributed to. I want to see that they have written quality software. 
That's great, but in reality these questions are next to impossible to solve in an interview while being trivial to solve if you've read the same source as the interviewer on "what interview questions to ask, and their answers". Even if you assume what you wrote above is true, the overwhelming majority of people who pass your test do not do so because they're good problem solvers, they do so because they read the interview question online beforehand and memorized it. It's a "do you read the same sources for interview questions that I do" test.
&gt; Want to know how a programmer writes code? Knows about code/java/etc.? Make him program something. Give him a project, over a week and make him explain it during the interview. That sounds really great in theory, in practice (I just went through this personally) because it costs them nothing to ask candidates to do reading and exercises, they will throw them out expect you to invest time then not even bring it up during the interview. It's just easy for hr to abuse your time with.
Events do a great job of hiding dependencies.
I have never wrote that I wanted to put the whole project in one source file.
Starting to learn with JavaScript may have worked for you, but it will not work for everybody. We have already linked plenty of good tutorials tailored for beginners. Starting with JavaScript also bears some dangers as JavaScript is dynamically typed where Java is statically typed.
I've been using events in my android apps to limit the chance of having a memory leak by passing the activity around ( the activity implementing some kind of interface callback ). Outside of this concrete use case I agree with the points you've made. 
I'm not sure I understand - are there people who use the 'event' based approach for some other reason than passing data between threads? Why else would the queue be necessary?
Teach yourself java in X days/hours always served me well. I hate hate hate books that assume you know this or that, but those ones really start from square one.
Stop trying to make no dependencies happen. It's not going to happen.
You should give Mission Control a chance.
Also, the [checker framework](http://types.cs.washington.edu/checker-framework/current/checker-framework-manual.html) has some concurrency checkers. Haven't used it yet though. I wish these worked at the byte-code level, so that they could be used with any JVM language (Java / Kotlin / Scala).
Getting into a build system without a whole lot of context can be super confusing, I agree... but what you want to do is really quite straight forward (as you note)... a lot of other people here recommend maven which is fine... but can I suggest gradle which is a lot terser and easier to get started with. First create a build.gradle file in your project root directory, put the following in: apply plugin: 'java' apply plugin: 'application' version = '1.0' sourceCompatibility = 1.8 mainClassName = 'package.MainClass' repositories { jcenter() mavenLocal() mavenCentral() } dependencies { compile 'mysql:mysql-connector-java:5.1.36' } Also make sure your source files are moved into src/main/java (within the project) as well Since you're on OS X, get a simple gradle install happening by going here: http://gvmtool.net/ and running this from the command line: curl -s get.gvmtool.net | bash Then re-open your shell so GVM is initialised and run gvm install gradle Now you can build an app bundle with a startup shell script by cd your/project gradle distTar gradle distZip These will build a .tar or .zip archive in build/distributions which you can scp to the Pi, unpack and run using the included bin/project shell script. Bonus, you can import the gradle project into IntelliJ (probably remove your .iml and .idea dirs first?) and have it automatically add dependencies based on your dependency block...
Free online book: Introduction to Programming Using Java - http://math.hws.edu/javanotes/
Well absolute phrases like "I would hold the exam against you" and your persistence about it during those discussions makes me think its stubborn/limited/too-much-projections/... view. Basically this view assumes something which might not be true (person who puts certificate on CV has secret intentions - which is somewhat laughable in my mind) and it assumes it with big certainty and self-righteous attitude - to me sign of potential conflicts in future. Again, its not necessary about you, its just my limited impression of this very short conversation which if I had to make value judgement, first thought would be - better avoid.