I just use immutables.io and get all that without a completely new language that all my tools no longer support...
This isn't a recent thing. Java reinventions have been a thing for well over a decade. Generally these languages use the same general reasons for why they are doing it. All of these either never really took off, or they did, but their userbases are shrinking (as in, they aren't going to be the next big thing either). Fads that came and mostly went: * Groovy * Scala * Fan/Fantom * Ceylon * Xtend * Excitement about getting rid of java-the-language without java-the-VM via JRuby and Jython * A flareup in 'you should all be using LISP' (not a VM language) instead. * Clojure * Microsoft's first attempt to embrace-and-extend java * SPECIAL MENTION: Microsoft's second attempt, C#, which really is seeing some use * Pizza * Flow Java * SPECIAL MENTION: Kotlin; so far hasn't started on the seemingly inevitable downward trend yet. NB: Perhaps 'fad' is an unfair characterisation of many of these attempts. Some were married with a rather aggressive community and built a lot of their momentum on slagging off java, so the term seems to apply well (looking at you, scala, LISP flareups, JRuby/Jython, and to a lesser extent fantom), some weren't designed to replace java at all and merely were trying something new (clojure, flow java), or to exist together with java (groovy). Some never really got off the ground (Ceylon, Xtend, fantom), and many of these did at least bring some very interesting technology to the table (JRuby/Jython/Scala for example). Java isn't going anywhere. 
Don't you like to have options? 
Immutables are such a pain to refactor. Lombok is way better for this, although it has a smaller feature set. 
Agree regarding data classes. Brain also agrees with you, that is why records are in works for Java
Of all the attempts, only Kotlin seemed interesting to me because of how easy it was to use with Java and the features it had. I started using it and every time I use plain old Java again I feel hampered. Like my running shoes were traded for worker boots. The way it works, you can use it as a drop in replacement for Java which is awesome. What especially made Kotlin not work for you?
&gt; Brain also agrees with you Thought for a moment you were referring to your brain in the 3rd person, but I guess you mean Brian (Goetz).
Kotlin with Spring is also taking off.
I didnt like the feel. Well we tried Kotlin when developing a small prove of concept app for neural networks mobile devices. Although Kotlin itself enables you to write null free code, together with Android you had to do even more annoying null handling everywhere. There were many little things we did not like. In the end we abandoned the idea of using Kotlin and went back to Java. One major reason might have been the small amount of time we had to get used to Kotlin. 
In before all the people who are too afraid/threatened/intimidated by new things that force them out of their comfort zones bash a bunch of languages they don't really know anything about.
&gt; Scala Steadily growing. &gt; Pizza Given that Sun took its generics and the compiler, and that everything else ended in Scala, it looks like a very successful project to me.
Start being a professional - you are complaining about YOUR tools. Of course business don't care about YOUR tools. It is your responsibility to make sure your tools/machines are in order and if you need to replace them then it is your job to justify it for business. Bureaucracy - is a lot if it asking about if you can do your job well? (i.e doing it properly vs cutting corners and introducing tech debt that never gets attention later?)
Fuschia got 0.00% marketshare and no one have any idea when will it reach beta stage. And they probably will need some compatibility.
That is just one of many examples though
Those languages can also have some much different design principles and purposes. Groovy isn’t a “java killer” - it’s a great scripting language to use when you want to interact directly with other JVM libraries. Clojure is a great tool when the task at hand is stream processing, etc. It’s a great thing to have tools in the toolbox.
&gt;Although Kotlin itself enables you to write null free code, together with Android you had to do even more annoying null handling everywhere. I'm sorry, what? One of the main points of Kotlin is \*not\* handle nulls anywhere. Rather than needing to do something like this: if (x == null) { throw new NullPointerException("x is null"); } var y = x.getY(); if (y == null) { throw new NullPointerException("y is null"); } // so on You can simply express it like this: val y: TypeOfY? = x?.getY() There is no way null handling in Android (or normal Java development for that matter) was more annoying in Kotlin than Java unless you were just doing it insanely wrong which, by this statement: &gt; One major reason might have been the small amount of time we had to get used to Kotlin. Is that was the case. It's a new language, yes, you *actually* have to spend *some* time to learn it. But the amount of productivity you can achieve with it is vastly superior to the literal day you need to spend needing to learn it. Another major point is that it can be used as a *literal* drop in replacement. You can swap huge codebases with Kotlin one-by-one because its interop out of any Java ""clone"" is far superior so the investment of replacement is not high at all besides the need to learn it which takes at most a day because of how similar the syntax is to Java.
Groovy has not went anywhere. If you use grails it is still used and it is used as a scripting language. 
In fact there's a [dedicated project for it now](https://github.com/spring-projects/spring-fu) to immensely speed up startup and reduce memory consumption and make it compatible with GraalVM's AOT. Unlike other Java alternatives, Kotlin actually has gotten itself a market share and there's no fear of it becoming inactive because it is being pushed and used by the largest/best IDE maker in the Java space. &amp;#x200B; Java isn't going anywhere, but Kotlin is going to hang around with it. I feel Kotlin's explosion of market share has passed, but there was an article in this very subreddit that expected its growth to continue growing steadily. I believe that will also be the case.
I'm looking forward to seeing a report from /u/jodastephen after a year or so because I can't figure out if this platform can provide a significant revenue stream. Both of my [FlexyPool and `hibernate-types`](https://github.com/vladmihalcea) projects require little maintenance, but even so, I sometimes feel it's hard to find a time slot for them. I've been having an idea of building a new small framework that can bring a lot of value to many companies using JPA and Hibernate , but I don't think I'll do it as an open-source project. If I do it, it will have to be a commercial product right from the start, as otherwise, I don't see how I could justify the time I invest into building it.
tsk tsk, if you work for a big business, then the business decides and put the platform. I repeat, it is not our call (unless we are the architect or CTO). And sometimes, we can't even pick the IDE, for example, some companies work exclusively with Eclipse. And some companies don't bring a proper tool. For example, Nike Inc. got caught using a pirate copy of Toad. I'm not saying that it is right or not but how most companies (that use JAVA) works. It is one of the reasons why it's cool to work for a small business/ startup. So, is it a problem with MY tool?. Haha, it is funny. 
I agree that this short hand should be an option, but for some things, like Hibernate or J2EE support, you need to write the boiler plate code to correctly place annotations.
I am pretty sure that back-compatibily was their first objective! Java and Kotlin are way too hard to code. Web Languages are way easier and fun! Samsung have tried more than once to create a non-java Mobile System, I bet they are on that with Google. I would not bet on Mobile Apps using JVM languages! I would not be surprised Apple goes that way too! 
I feel like Kotlin brings too little too late to the table. There are going to be features coming to Java that will close the gap even more. IMO not worth the hassle and investment of time.
I think the point he was trying to make is that when utilizing a library made in Java, there may be functions that you are overriding or that you are calling that have nullable parameters or nullable return types that you would have to check for null in Java. In these cases it is a good idea to throw an exception when you don't expect null but in kotlin you have to be a little more verbose about that. If course, you can use !! or ? In certain cases but sometimes it just feels wrong when you really aren't expecting null. 
I could also just use Javas Optional API using ifPresent for example. I'm aware that you need to invest time to learn something. Someday maybe i'll take another look at Kotlin. I just dont have the need to at the moment. No serious projects at work that would benefit from it. I didnt want to do any Kotlin bashing but just say that I'm totally fine with vanilla Java.
IMO Kotlin brings almost nothing new... not worth the hassle to introduce another language into my personal ecosystem!
No one wants to "invent a new Java". I think there are two types of Java programers: * Those who are aware of how bad Java is, but use it as a means to an end. * Those who are blissfully unaware (they tend to only know Java)
About Scala [https://www.itjobswatch.co.uk/jobs/uk/scala.do](https://www.itjobswatch.co.uk/jobs/uk/scala.do) jobs vacancy trend is not confirming your words
besides less boilerplate, less platform dependence, coroutines, nonnullable types, functional features, not being weighed down by legacy compatibility, and more modern syntax, it is after all just a general purpose programming language. 
Maybe Hibernate and J2EE are also bad.
Huu, in Java you'd do `val y = x.getY();` and automatically get an NPE if x is null. You might have some point, but your sample definitely does not illustrate it.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
The "I haven't learned anything new in 20 years and don't know what this is, but I can can assure you it is worthless" crowd.
I think people don't realize that you don't have to write verbose java classes. Yes, it's still longer than one line, but it's not "86 lines". With public final variables, there is no reason to have getters and setters. Here's what I do for my immutable data classes: &amp;#x200B; public class Movie { public final String name; public final String studio; public final Float rating; public Movie(String name, String studio, Float rating) { this.name = name; this.studio = studio; this.rating = rating; } } &amp;#x200B;
It's where Java goes to play with new ideas. Kotlin does something everyone likes, and it works, a d a few versions later you see they're adding it to Java proper. Programmers are, almost by definition, neophiles. They love the shiney new thing. JVM compatible toys to play with are fun, and give Java a healthy playground to teat new ideas with. It's all good, it's part of what makes Java worthwhile.
Optional is still more boilerplate and is not a type-safe guarantee (Optional itself can be null, though in practice I've never seen this happen admittedly). But there are a myriad of other features Kotlin has that reduces Java boilerplate and adds features to greatly enhance resources the JVM provides (coroutines). I don't hate Java, but I definitely feel slowed down and restricted using it. That's just my overall conclusion I guess.
You must be used to a very old version of Kotlin. Types coming from Kotlin that aren't annotated by JSR-305 compatible annotations will simply have a `!` platform type, which means ["don't know"](https://kotlinlang.org/docs/reference/java-interop.html#notation-for-platform-types). A type of `!` can mean it can be null, or not. Kotlin can't know. It won't force you to use null handling like `!!` or `?`, that's up to you to decide. If you make the wrong assumption and it's null when you didn't expect it to be, at least it'll give you a useful NPE message telling you which part of it is null.
Kotlin is gaining some serious momentum and is a joy to use. I honestly think you'd be doing yourself a disservice to not use and learn it.
Don't forget inline functions, reified generics, extension functions, top-level declarations, sealed classes, pattern matching (to an extent), inline classes (new addition, admittedly), unsigned types (new addition, admittedly), operator overloading, custom DSL support, safe casting, actual lambda support, deconstructors, type aliases, delegates, tail recursion support, and probably more things I can't remember off the top of my head. All while being nicely compatible with Java so you don't get a fragmentation of the ecosystem.
But this example class is not immutable. The public instance variables can be changed by anyone...
Good luck using Optional on Android, API =&gt; 24.
Class delegation, data classes, type inference, lack of semicolon, more natural declaration(right: String instead of String wrong) only make it miles ahead of Java.
&gt; You don't lose precision, you don't introduce ambiguity. Try to debug a Lombok class, Lombok is for those who favor a few saved editing seconds over efficient debugging. 
Error:(17, 14) java: cannot assign a value to final variable name
what is final :S
Brian Goetz plays to whatever make him look like a star with the rah rah fan crowd. He's not a hero of those who deliver software every day.
I haven't used Java in a long time, but that final keyword means they can't be changed after they're set in the constructor, right?
That's kind of a moot point. I mean I prefer to use immutable data classes as well, but a) the ratio is still 1:10 b) you are still missing a hash code and equals method to compare those types. If you look at the example I referred to, you will see that those have a considerable size. c) that is a completely different use-case. If you want to use this class in combination with some libraries like hibernate that demand that you supply a bean-type, this does not work at all d) that is not idiomatic Java code. I'm not exactly a fan of the idiomatic way, but public variables are frowned upon by many devs and styleguides. I know that Robert C Martin (God bless this man) has a different opinion on this topic, but that doesn't change the fact that e.g. I can't use this approach at work because it would violate my company's coding conventions e) that's just one example of many features that languages like Kotlin have that makes your code more concise without (necessarily) sacrificing precision
Yeah, I tried Kotlin, seriously, didn't like it. Same with IntelliJ.
Because old Java is withering on the vine.
If Google doesn't abandon Kotlin and Android Studio and anything else that JetBrains makes, Android and Google should go down the tubes.
I love Kotlin but I don't get why variable declarations are inverted (right : String). Do you know why it's done this way?
Available through Guava thought
Why?
&gt; There were many little things we did not like Like what? &gt; Although Kotlin itself enables you to write null free code, together with Android you had to do even more annoying null handling everywhere Kotlin forces you to make a choice about when interacting with unknown nullabillity (platform types). How is that worse than Java, where you are usually interacting with unknown nullabillity? 
Why can't you just use `Optional&lt;T&gt;` in Kotlin then? &gt; Someday maybe i'll take another look at Kotlin. IMO, check it out `sealed classes`. It completely changes how you program. I'd never use a language that doesn't support them now
&gt; With public final variables, there is no reason to have getters and setters I can think of a few reasons: * Say you later want to lazily calculate the rating somehow in this class, or you change it to be its own Rating class instead. Since you've exposed your state, refactoring will be more difficult. With a getter you could remain compatible with existing code. * If you have a field of a mutable type, you can no longer create a defensive copy/wrap it in an immutable view. For mutable classes like the one in the parent comment, there are even more issues with having just fields: * You could put logging, validation, compatibility, etc. code in the setter. * You might want to search for just setter invocations and not reads, i.e. find out who sets this value. * You might want to put in a conditional breakpoint that triggers only when the property is changed to a certain value. 
Like what? The latest version of Java is still miles behind Kotlin in terms of features &gt; IMO not worth the hassle and investment of time. Learning Kotlin is pretty trivial, imo. You still can leverage all the same frameworks. Took me a few days
I've heard someone saying it's like that to make it easier to use type inference, like: val name: String = "Your Name" val name = "Your Name" though I'm not shure if that's the reason really.
Check out this answer: https://softwareengineering.stackexchange.com/questions/316217/why-does-the-type-go-after-the-variable-name-in-modern-programming-languages
I don't like Kotlin and that's one reason why.
&gt;sealed classes I haven't done extensive reading on this, but wouldn't a final class in Java behave the same way?
You don't throw NullPointerExceptions. Trying to invoke a method on a null object will throw a NPE.
It's an algebraic Data type. Think like a non-static enum (one that you can store instance based values in). It's akin to enums with associated values.
Hopefully no one tries to invent a new Java. If you are doing *pure* object-oriented programming, Java is fine as it is. The problem is, you won't and that's where people are becoming increasingly aware of the pitfalls and problems with object-oriented programming. 
&gt; ecosystem Google's ecosystem, handed to them by the Russians, JetBrains.
I so wish IBM had bought Sun, even Microsoft would have made a better steward of Java (never in a million years could have imagined thinking that).
&gt; Kotlin does something everyone likes No. It doesn't. It has backwards types. Fail. First fail of many.
Of coarse they don't try to invent the same as Java. They are trying to invent something better, but offer nothing new in principal.
I don't know what you're using lombok for but it's never made it harder for me to debug
My point was it gives us a place to try things, and realize they're good or bad. 
Have you even tried any language other then Java? What so great that Java brought to the table? Because its playing serious catch-up other languages, I mean Java is still debating multi line string! And let's not forget Null Pointer Exception, you know the billion $ mistake
Agreed and the smarter developers are either migrated or in the process of migration to another language, but developers form a spectrum of skill, sadly the at the lower end, many are blissfully unaware :(
Because java is too much to write....
I use Clojure when I can, but otherwise just plain Java rather than some almost-java just to get some syntactic sugar but essentially the same language. Clojure is pretty amazing though.
Brain gotta poop. Don't neglect the Brain.
what members are used for hashCode and equals here? if the answer is "all" that's the wrong answer. can you customize it?
[Relevant xkcd](https://xkcd.com/927/)
After I wasted half a day debugging some lombok build shit, I was done with that crap. It's totally not worth the 3 seconds of choosing right click, generate etc.
Standards and programming languages are not the same. We need several programming languages because different situations need different things. A single programming language is not a good idea.
Mixed in with the "I just barely scraped my way into basic competency with Java, and I will fight tooth and nail against anything I perceive as threatening the viability of my new found expertise" crowd.
[Project Amber](http://openjdk.java.net/projects/amber/) is addressing some of the ceremony required in Java.
I agree. It takes a while before the obvious problems with OOP in the context of building modern applications become apparent. I'm not sure how the situation in colleges is at the moment. I hope they are teaching a mix of different languages and approaches: Functional, Logical, object-oriented and imperative languages all need to be taught and their ideas validated. 
Java isn’t always going to be the first mover. There are billions and billions of lines of code out there, and keeping that code working while integrating new features takes time. Other platform don’t care about compatibility, but Java does.
[Records](https://cr.openjdk.java.net/~briangoetz/amber/datum.html) are in the works for Java.
&gt; Kotlin; so far hasn't started on the seemingly inevitable downward trend yet. Kotlin is the real deal: * official Gradle support * official Spring support * official Android support 
Algebraic data types are in the works for Java. See [here](https://www.youtube.com/watch?v=qul2B8iPC-o&amp;t=27m56s).
Is kotlin going to evolve in parallel with Java's new features ? Let's say Java introduces some new language features or paradigms, will kotlin have it's own way of doing same in a shorter and concise way ? I guess what I am trying to ask is, how much will be the lag of kotlin catching up to Java new things ? Also is there any chance kotlin may not be active in future ? From the perspective of investing in learning kotlin 
Of course, because all the smart people share **your** opinon. /s 
He said he’s also including getters and setters for everything too. That probably runs about 50 lines at most. Still verbose though 
Or a static block, yes. 
Yeah, old things can be a bit boring. A bit like that "In before" expression that was hip 10 years ago. ;-)
I will admit that when you first try Kotlin, you will have the tendency to write Java code with Kotlin syntax. And then you struggle because it's all awkward and painful and doesn't seem beneficial. Once you get past that, and this does take a bit of effort, Kotlin is bliss. It has incredibly powerful constructs like the let-family, functions as types, extension functions etc which really amp up the productiveness. But if all you're doing is trying to write the same code in a different language, it's not for you. A good starting point to learn it are the Kotlin koans, they introduce the concepts step by step.
To be honest, most newly invented languages are pretty pointless to learn, "killers" of old languages pop up often. Most of them never gets popular, of course. So statistically, those unwilling to learn new languages are right. I can understand how someone working as a programmer for 40 years will see new languages popping up as uninteresting, because they will have seen so many that did not succeed.
a. ok sure, but having a ten line class file is fine by me b. I'm not "missing" them. Most of the time I don't even need them. c. Funny how you are trying to compare this to a primary "use case" when the OP didn't even say a real use case to begin with. d. I really don't give a shit about idiomatic java code. Idiomatic java code is ugly. Don't be a sheep. e. I'm not saying that Java is superior than Kotlin, I'm just saying people don't have to be so negative about java when there are ways to not have your code be a pile of boilerplate trash.
To clarify, I meant that there is no reason to put getters and setters in by default in every single data class. Yes, there are times when adding a getter or a setter is appropriate, but I'd say stick to "public final" fields and only add methods to your class when necessary / at the time that you need them.
correct. With reflection, you still change it, but using normal syntax, you can't change it after the object has been constructed.
Goetz, JetBrains and Oracle have ruined Java. Long live Java.
Which language that is in the top 20 of, lets say tiobe's list, would you say have no real faults? My point is, the languages used by a lot of people in the industry, have some real problems. So switching from one language to another will mena you switch from some problems to other problems. You will not switch and arrive at the perfect language.
It sounds like al post for IntelliJ masquerading as something else.
Ceylon is the best Java 
I see the JVM languages as options. More power to the programmer to pick and choose what lang fits their project or coding style best. Ink pens didn't replace pencils, paintbrushes, markers, or crayons. A teacher wouldn't use a pencil to grade a student's paper. Basically each tool has their own niche and purpose.
Java will continue devolving at a rapid pace, from where it started in Java 8 and then accelerated in Java 9. It's almost like Oracle has been incentivized to destroy Java.
Those newer languages are what Java SHOULD HAVE BEEN.
[](/cadencewat) I'm a kotlin dev, and I didn't know what you were on about until I went to the second page of google results. That's your problem? Man, you must hate dynamic types if you can't stand inferred types.
I think Java/JVM’s ability to support such an extended set of additional languages, some of which don’t even look like java at all, is the reason why jvm is still relevant in the industry, and not just used to maintain piles of old enterprise software. If anything, more languages should be encouraged to be created, not arguing why they shouldn’t.
I've heard companies search for Java programmers then train them in Scala after hiring because its easier to find competent Java programmers than just Scala programmers.
&gt;Is kotlin going to evolve in parallel with Java's new features ? Let's say Java introduces some new language features or paradigms, will kotlin have it's own way of doing same in a shorter and concise way ? I don't see what Java can add that Kotlin doesn't have. The only feature I can think of is true pattern matching, but that is in the planned stages for Kotlin afaik. Kotlin for example can do lambdas under Java 6 bytecode, so even if Java adds something wildly radical (unlikely, because backwards compatibility), Kotlin can make it work even on older bytecode. &gt;I guess what I am trying to ask is, how much will be the lag of kotlin catching up to Java new things ? Also is there any chance kotlin may not be active in future ? From the perspective of investing in learning kotlin Very little if any. Java maintains backwards compatibility (and so does Kotlin) so any changes done in Java can be as easily reflected in Kotlin. As for it being supported in the future, definitely. It is made by Jetbrains after all, the creators of IntelliJ and other extremely fantastic IDEs, and they developed it to solve their own internal problems, so I imagine they have a significant investment they would not let go easily. Probably the same chance as Java would receive 0 support from Oracle. Though in that respect I say it is *less* likely.
I feel like Java is *steadily* being replaced by Go in its primary domain (web backends).
I always find it funny when I always see a certain group of developers specifically PHP, Go and Java, that will defend their language and maintain that its brilliant, I have far more respect for Java,Go,PHP devs that are fully aware of weakness of their language and don't jump to defend it, because ultimately poor language is poor language design, and no amount of sarcasm will change that. I'm not saying that Java, Go or PHP are not useful, they clearly are, but what they are not is a good language. The are ok, they get the job done and are mainstream, and have hordes of developers to work on them (that is both good and horrendous , if you have ever had to work on legacy code-base from some out-sourced team..)
no language is perfect, I totally agree with that, that's not what I was saying, but if you read the OP question, that is pure 100% fanboyism, I guess I shoudn't be surprised, I am in a Java subreddit.
they're pretty easy to generate. then if you do need them refactoring is a breeze
Groovy != gradle. I despise gradle and it’s dls. Groovy is what java should be. 
&gt; I'm a kotlin dev, and I didn't know what you were on about until I went to the second page of google results. I don't quite get what you mean? What were you searching for in Google?
Yes, you can, but the point is that most of the time you don't need to, because comparing all fields is correct much more often than not.
Sure; as I said in my addendum, many of these weren't even created as "Java replacements". But for every single last one of these, a significant amount of hype popped up trying to paint them as an alternative. Without further context from OP, I assumed OP sort of grouped all that together.
Well, with a username like that, I somehow doubt trying to delve a little deeper is worthwhile :)
Technically it's not equivalent, but in a good way. The Kotlin version doesn't allow the string fields to be null, and it enforces that restriction at compile time. To be fully equivalent, the type of the string fields should be `String?`.
I thought "reverse types" was something special about inheritance conversions.
That's kind of unfair, though. It's like saying every CLR language is trying to copy C#, or every language that targets native code is trying to copy C.
Kotlin is also the first JVM language that I can comfortably say is strictly better than Java for all purposes. (Well, unless your purpose is to to have near-absolute control over the JVM bytecode that gets generated, but if you really need that level of control, you most likely need to generate the bytecode directly, since even Java doesn't given you total control, and there are JVM instructions that can't be represented directly in Java code.)
Scala and Pizza are both academic projects. Pizza achieved its goal of demonstrating how to make generics work in a Java-like language. Scala has also been pretty successful as a testbed for features that were later adopted by other Java-like languages.
Not sure, I'm not a language designer, just a coder, making a buck to buy dinner with. In C, C++, Java and C#, "type varname" works fine. Switching it, "varname: type" isn't an improvement over what works and is maintainable. 
The equivalent Java code is `val y = x == null ? null : x.getY()`.
If you think Java is bad, you should try C++
Nothing prevents you from using `Optional&lt;T&gt;` in Kotlin, but there's no reason to do it unless you're interfacing with Java code. Kotlin's type system gives you the same benefits with simpler syntax, no runtime overhead, and real type safety (i.e. there's no equivalent of `(Optional&lt;T&gt;)null`).
Not really a problem as long as data class definition arguments can have those annotations.
You can use any Java type in Kotlin, including `Optional&lt;T&gt;`; there's just no advantage over `T?` unless you're interfacing with Java code that uses `Optional`. It's really solving a different problem, though. And reference-type variable in Java can potentially be null, but in Kotlin a variable is only allowed to be null if you specifically declare it as `T?`, and the restriction is enforced mostly at compile time. There's no equivalent in Java. Conversely, using `T?` in Kotlin gives you all the benefits of `Optional` in a way that's much easier to use and doesn't have the overhead of generating a bunch of `Optional` instances at runtime.
Java moves so slowly it won't be hard to Kotlin to keep pace. There's something very ironic about worry that Kotlin falling behind Java when Kotlin is currently so far ahead.
Except some of them *will* kill off today's languages, just as today's popular languages have mostly killed off their predecessors.
&gt; Programmers are, almost by definition, neophiles. *Some* programmes are noephiles. And we're constantly fighting with the luddites, who are more often in senior positions that let them pick which tools the rest of us are allowed to use.
No, but I feel the very frequent usage of `val` is quite nice. The prevalence of immutability in the language helps a lot in a lot of my simulation work when I have to worry about thread management. And the threading in Kotlin is beautiful! So much less to keep track of. 
The EAR plugins has no skinny war support. This is truly a deal-breaker if you use multiple WARs with the same .jar inside and use CDI.
I agree with the other two comments... though since "die-hard Java developers" has a bit of a negative connotation, I'll add that even if you're comfortable with Javascript development there might be good reasons to take a look at Vaadin. Obviously if you're a total Javascript shop it probably doesn't make as much sense (though you should look at their Web Components). But, essentially being able to code the front end in Java brings a lot of advantages. Type safety and code reuse being two big ones. &amp;#x200B; Being server-driven can also make some security problems easier since server is (more easily) in control of the model. Obviously these problems can be addressed with client-side development but some issues are handled for you. &amp;#x200B; Being able to go full-stack with a single language is a big thing for team flexibility and allows for easier hiring. It's why you're seeing more back-end Kotlin technologies targeted to Android devs.
"all" for eq/hc is almost the *right* answer, or you shouldn't be using eq/hc in the first place.
So what happens when Java comes up with it's own way of making things concise? Almost same like kotlin ? People using kotlin will use Java's way or kotlins ?
Public fields should be bannable
You can have close to the same thing with Lombok and validation annotations. https://www.baeldung.com/intro-to-project-lombok I'm not being argumentative, just showing that Java does have support to do the things these other languages provide. 
Being rude doesn't make your arguments any less frothy 
U have a good point why be rude?
I am facing the same situation and have the same question.
That's not a recent thing. 
GitHub open source projects &gt; Certificate. Certificate are great if you live in a state with lots of governmental contracts! 
C++ build tools is a very sore point, but is a system levels programming language, you can't really compare Java which has a runtime and runs on top a VM with GC to an binary compiled to native code. Lets not forget that the JVM (HotSpot) is written in C++.
I am not too sure how governmental contracts work. Can you do those freelance or are those picked up by companies? Also how much do you have to contribute to an open source for it to look good? I always thought personal projects in relevant field looked better than donating a couple commits to a project. Sorry for all the questions I just really am trying to pick a direction
Well if you come across some useful info I'd love to hear it
Yes, Java is very slow at interacting with hardware and system-level things but it's good at almost everything else. While C++ is a one trick pony. It's a domain-specific language now.
It seems to me that rx is more useful on apps (desktop, mobile) than backend. Trying to use on the backend is just someone trying to be hipster.
I’d take some Udemy courses on Spring Boot. There’s one with React and redux included
https://immutables.github.io
you can do anything in your own personal projects, you'll get killed if you try do this in a team. 
C++ a "one trick pony" ? really? C++ is far far more advanced then Java, and its used in multiple industries. Java was made to be simpler then writing C++, and increase productivity via automatic memory management. For LOB and CRUD applications, then Java is fine, in fact almost any GC language is fine for this. But the software landscape is much wider then just LOB and CRUD. If anything Java is the "one trick pony"
I've heard some bad things about udemy, what makes you suggest them specifically over an oracle cert?
When you use it for a while it feels natural and going back to doing it the java way is awkward and weird.
Yes, a one-trick pony. No one in the right mind would do anything with it outside of low-level system programming unless legacy concerns forced their hand. Whereas Java is generally a reasonable choice for anything from massively parallel number crunching to garage door openers to high-end phones and tablets
How is it a pain to refactor?
I could not agree more.
What bad things? Udemy is an online learning platform. If you find a course with hundreds of thousands of students and it's average rating is above 4.3 it's a pretty good indication that the course is great. I took some highly rates courses with many students on React, Unity and Photography and they were a huge help.
Companies. Both, relevant personal projects and committing to famous projects! 
&gt; With reflection, you can still change it yes and no. The JIT compiler can assume a final field never changes so it inlines the value/reference. After the method is compiled changes via reflection don't work(not that it was easy to begin with, have to reflectively remove final from Field object first).
Well the thing is, I am not at the stage currently where learning is a huge benefit to me. If I were to take a udemy course or get a cert then it wouldn't be for the purpose of bettering my knowledge. That's why I made this post because I am in the process of getting my CS degree so all I'm looking for is resume boosters more than anything. Would udemy courses look good when trying to land some freelance work is my real question
Introducing a new language which makes it unclear what exactly that line is doing is not an optical solution Imo. Use code generators and tools instead
So committing at all looks good, or are you saying I should get fully involved? Like my real question is would committing slightly to a large open source project really look better than getting a cert? 
There is no world where an Udemy course would carry more weight than an Oracle cert. 
ok some things are factually inaccurate here: &gt; Whereas Java is generally a reasonable choice for anything from massively parallel number crunching to garage door openers to high-end phones and tablets to web apps to standalone desktop apps * (massively parallel number crunching): you probably alluding to Hadoop et al, while Hadoop does FinTech based "Big Data" crunching, real number crunching is actually done on massive super computer aka HPC, here its Fortran and C++, Java simply can not compete in this space * (garage door openers): if you mean microcontrollers, sorry these devices are so restricted usually a few kb or RAM, and are exclusively programmed in C/C++ or hand written assembly * (high-end phones): Only on Android, where JVM bytecode is translated via DEX to the Dalvik VM. On iOS its Swift/Object-C. Even then C++ is used via NDK for games. * (web apps): Yes Java is used in web applications, but so are huge number of other languages, in fact PHP dominates here with nearly 70-80% of web applications on the internet. * (desktop apps): I think this is in decline in general, most desktop applications are native, so .NET, Cocoa, yes there are Java desktops but once again not exclusive to Java 
It is not about good looking. Udemy curses, and learning generaly gives you knowledge, that you can present in interviews. I made an Oracle Sertificate, and the biggest benefit from that = i understood how java works internaly. The exam was pretty mean for me back then (it was Java7 ) Now i learned from Udemy and i got knowledge about Docker, Mockito, Angular, Node e.t.c Bouth helped me to get new Jobs as there allways was a "testing day" where i had to show my skills, not only papers.
Groovy dead? Are you dumb? Millions of platforms (Liferay, Hybris, Oracle Fusion Middleware, etc) have just began supporting it
Maybe. The "not much of a resume" is the key phrase here. That's going to make it a bit tougher to break into free lancing at all, certification or no certification. You also don't have a CS degree yet, so that's another thing that will make it harder. If you had a deep resume (CS degree or no), I'd say you're wasting your time with a certification. What are you trying to accomplish with your freelancing? If you need cash, that's fine, then maybe you can land something, and maybe you can charge a bit more, or land a gig slightly easier with a certification. But without a lot of "real" experience and a CS degree, you probably won't be offered a high hourly rate, which may not fulfill the "need cash" angle for you. If you're looking to build experience, I'd certainly try open-source projects, or look into some internships (paid or unpaid) with bigger companies. I have been a freelancer for 18 years now. I started with a regular full time job at a large consulting firm, then, once I had 5 years of solid coding experience, I made the jump to a freelancer. Thus no real need for certifications. I've helped with FTE interviewing/hiring with some of my clients, and most were of the mind that certifications were not worth much. I tend to agree. I've worked with many engineers that are Java certified, and I've never seen it as a predictor of them being a good developer.
Don't forget that committing to famous projects all the people in charge of it can recommend you to companies! 
Getting java certified is fine for personal growth, but I wouldn't count on it mattering that much to potential employers.
I don't think it's accurate to say that Lombok means Java has support for this stuff. To be sure, I've been a satisfied Lombok user for many years, and will continue to use it for new Java code going forward, but there's a world of difference between a first-class, officially-supported language feature and (in the words of Lombok's creator) a ["total hack"](http://jnb.ociweb.com/jnb/jnbJan2010.html#controversy) that relies on non-public compiler APIs and has broken without warning on new JDK versions on multiple occasions.
right, but these alternative languages have been out or years, meanwhile project amber delivers one trivial thing (like var) once every 2 years...
It looks like in your [submission](https://www.reddit.com/r/java/comments/afdk4f/what_approach_should_i_take_when_generated/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Have you heard about the new release cadence? We get a new release every six months. 12 will deliver [switch expressions](https://openjdk.java.net/jeps/325).
Assuming you mean the Oracle Java Certifications, I don't think it'll necessarily help you pick up freelance work. Although I don't have a certification, I've looked at some of the material and I think the knowledge would be pretty helpful to a college grad looking to pass java language-specific portions of an interview for an internship or entry level position.
Also learn spring framework without spring boot, so many people doesn't know how spring really works and think spring boot is magic and this would give some headaches in the future.
Nowadays no one will hire you if you only know Java. Not even for junior positions. Taking Udemy courses with Spring framework / Spring Boot give you the knowledge of how typical enterprise sysytems are constructed. I’d recommend getting Spring 5 certified for $200 over Java certified. If you know Spring it’s already assumed you know Java. At your stage, absorbing the most popular stuff around Java is your best bet. 
Only if you're strictly optimizing for performance would you blacklist Java from massively parallel number crunching applications. Java is all over not just FinTech but business servers generally. &gt;these devices are so restricted usually a few kb or RAM How much money do you save per device by giving them ultra shitty specs? Probably nothing because there are economies of scale for devices with reasonable specs. Same reason why low capacity (~128GB) consumer storage devices are no cheaper than mainstream capacity ones (~500GB) Android has ~85% market share. And Java runs on iOS. Java is a generally a reasonable choice for web apps, you agree. Java is a generally a reasonable choice for desktop apps, you agree. C++ is for poking hardware devices (and even then only when maximum performance is essential). Otherwise it's a pretty unreasonable choice.
Actually reading effective Java and maybe taking a udemy or Udacity class about a Java technology could help. But top thing would be, get an internship! Tech companies are always looking for interns! Interview at a bunch of places for a paid internship. Read "cracking the coding interview". Lastly GitHub projects whether personal or open source established projects is good but can be hard to do when you are learning. Lots of tech companies are hiring!
Thank you very much Stuart. 
If you have work experience, then no one's interested. The exams is not very hard. Certification may be good to get your first job. I know a freelancer who got all of the Sun/Oracle certifications. When you have all of them, it actually becomes impressive. 
Also, Gradle has a Kotlin DSL now.
I look for more than just having a few commits in random projects when hiring. I'd want to see that you actually know how to use various tools. Start your own personal pet project and keep the source in a public git repo. You will be exposed to a lot of open source tools in the process and you will probably come across some opportunities to contribute small improvements. Over time you may even become a maintainer on an OS project if you contribute a lot.
The point is simply about timelines, I like that java is speeding up. Still, way more is already available since 2008 at least. Say you would have invented the cellphone, only 11 years after the the first iphone was released. That's how it feels. 
It looks like in your [submission](https://www.reddit.com/r/java/comments/afe5jd/secure_serialization_for_java_cracking_challenge/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Update: Atomic Serialization source code: [https://github.com/pfirmstone/JGDMS/tree/trunk/JGDMS/jgdms-platform/src/main/java/org/apache/river/api/io](https://github.com/pfirmstone/JGDMS/tree/trunk/JGDMS/jgdms-platform/src/main/java/org/apache/river/api/io)
No. A project portfolio is far more convincing than a certificate. Java certs especially are next to worthless as an indicator of how good of a developer you are. 
Nope, doesn't really mean anything. If you want to do stuff whilst studying for your CS degree, do some projects. Doesn't even need to be anything big or anything open source, but saying something like "hey look I made an Android app once just for fun" is a big boon to employers because they care about passion.
They do not help in a way you expect. Think about who would benefit from such a certification. It isn't you. It is a (particularly lazy) hiring manager that has a load of resumes to go thru and needs a filter. This manager also needs to be insulated from getting fired for hiring people that suck ass. Therefore this managers superior can't blame him because he hired 'certified people'. That boss can also use this excuse and so forth on up the chain of command. So if you fancy a soul sucking corporate job, then get your certification. The fact you pay for a cert that only benefits someone else, who likely doesn't deserve it, is the real rub. Meanwhile, those managers that know what's really going on and represent cool places to work, will tend to exclude people with certs because of this whole dynamic. So the conventional wisdom is that you take a gamble putting them on your resume the more experience you get under your belt. If the certs were actually tough to acquire then things would be different but Amazon sells an amazing study book that mirrors the test you'll be taking for just about every cert imaginable. This is the inherent fucked up nature of the cert industry. Imagine getting a face tattoo, it doesn't matter what it is, just the fact it is a face tattoo will send warning signals to the people that you should really be wanting to work with. Certs are face tattoos.
Agreed. However, if everyone put their energy into making less hackish extensions to Java, we wouldn't be reinventing a new language every year. I hope it does well, but Kotlin is the flavor of the month. Honestly, I save most of my hate for Scala.
If you're already using Spring Boot, I would definitely recommend using Spring Data as well. Staying within the Spring ecosystem will help to streamline development and give your code a more consistent feel. On the other hand, if you don't want to be tied to a single ecosystem, creating your own JDBC ORM isn't actually that difficult.
&gt;Certificate are great if you live in a state with lots of governmental contracts! This guy knows public sector :)
Thanks, definitely makes sense. Would you estimate it being a fairly quick process to get up to speed with Spring Data? Is that typically the "best practice" approach to database connectivity with Spring Boot (vs. MyBatis or Hibernate etc)?
Yeah. Spring strives to be kind of an all in one offering - provided you have all the right add ons, that is - and at this point it's almost completely annotation driven, so there's way less black magic going on. The hardest part you'll run into will be that most of the help you'll find online will talk about configuring your XML configuration because the annotations are relatively new compared to how long Spring has been around, but you'll get the hang of it before too long. 
Yeah. Spring strives to be kind of an all in one offering - provided you have all the right add ons, that is - and at this point it's almost completely annotation driven, so there's way less black magic going on. The hardest part you'll run into will be that most of the help you'll find online will talk about configuring your XML configuration because the annotations are relatively new compared to how long Spring has been around, but you'll get the hang of it before too long. 
I get what you’re saying. It’s just that the principles of the language usually means it won’t be the first mover, and that’s alright. Language evolution is a hard, long game, and there are many different paths — some more liberal than others.
jesus. no.
? that's insane. i think in the last 20 years i had a Pojo where i compared all the fields less than 10 times. 
I've been working as a Java programmer for 23 years and have never heard of anyone having a Java qualification. As other people mentioned, Github code is better.
…and get off your lawn?
I don’t know about freelance but certs don’t mean anything at my company (fortune 100). That may not answer your question, just wanted to share a perspective from the other side 
&gt; Since I have about 2 months or less from start to finish on this, That's your answer right there. If you know that you can finish on time using JDBC and you don't know for certain using an ORM, you have a duty to use JDBC. 
Which database will you be using?
So you’re in college but you’re not at a place where you should be learning?
I would recommend looking at JDBI3. I think it's a nice balance between straight SQL and a full on ORM
Can I ask for your experience to back this? I'm a computer engineering student who did small projects/contributions in GitHub for a long time but never a proper course. It makes me happy to hear that it was not the wrong path as I thought it was.
MS SQL Server 2016
Very true, I think you're confirming what I was thinking. 
Thanks again for this, I'll take a look at Spring Data. If it's a fairly quick thing to pick up and learn/use at the basic level I need. I'll go with that. Otherwise, I may just stick to JDBC for right now to get me through this project.
Because Oracle won’t deprecate semicolons, getters, setters, inheritance, requiring one public class per source file, and allow qualified imports
I fully agree. My answer is more aligned to OP's inquiry.
Well that's my point, I'm in college so I don't really need another source of learning more compsci when I could be trying to get my foot in the door
long id String username PasswordHashBobble password List&lt;SecurityTokens&gt; permissions id long username String password PasswordHashBobble permissions List&lt;SecurityTokens&gt; If you want to scan through the list looking for your variable by it's name, it's easier to read if the var name comes first. 
If you already know how to program pick up head first java. It'll take you a day to pick it up
I don’t agree. Apply for internships. Do hackathons, tutorials whatever. Build yourself a portfolio alongside your college degree. I think this’ll be much more effective than an official certification. 
Awesome. Best of luck
&gt; Is it heavily frowned upon these days to use JDBC statements directly or is an ORM / mapper a must with Spring Boot? Definitely not a must. For small apps I don't bother with ORMs either, Spring JDBC works just fine. But for bigger apps, or if I feel they'll grow, ORMs will save you a lot of time and headaches. 
I took this course about a year and a half ago. It was generally pretty good, but there were some rough spots. At one point he started to introduce algorithms and data structures and one of the first assignments in that section was to implement a binary search tree (it might have been balancing one, my memory is a bit fuzzy) but without any explanation of the concepts and almost no lead up or similar kinds of assignments. Thankfully I already knew how to solve it due to prior programming experience, but judging by the comments, pretty much everyone else was lost. Most videos had 1 or 2 comments, but that one had about a hundred, very confused comments. Aside that, there's a lot of good content, and he covers a lot of ground. Doesn't touch on j2ee or any frameworks like Spring, but he has a course for that. Overall, I feel it was worth the time and money.
Yeah lombok is mostly just getteers/setters/contructors for me, not exactly the places id tend to be debugging. Plus theres delombok. Judging by the comment below that guy aint got time to read the docs, easier to be pissed off I guess lol.
If I'm going to learn Kotlin, isn't just better to learn C#? I mean it has much better design and features, and jobs too, although it has worse source-closed ecosystem which is kind of annoying.
&gt; Is getting java certified worth it No.
There are two types of Spring Data: Spring Data JPA (on top of Hibernate ORM) and Spring Data JDBC (new component). So even in Spring you can choose between ORM and JDBC! 
It sounds like you're looking for an excuse to not use an ORM. You _never_ need an excuse to not use an ORM.
What do you mean by can't facilitate this? Your sport will need some kind of central API that is tracking each player's stats, otherwise I don't think it's possible. If you can find an API that does track stats, then all you need is to pull from it every couple of minutes and display it on your front end. You'll need to write your own logic for the competition side of it though (matching against people, setting up the schedules, drafting, scores, ext). It is possible, but it's not a small project by any means.
jOOQ
Oracle java certificates are not worth it. The only thing they demonstrate is that you can memorize the test material, most of what you learn is irrelevant for actual development. I've heard from some people that they will be *less* likely to accept an applicant with an oracle cert - both because buying such a cert is bad judgement and because when the cert is the most important thing you have to show for yourself there probably isn't much else to show. This isn't the norm, but it does go to show that the oracle certs are not worth the money.
Try Yank. You can learn it in 10 minutes.
Genuinely. As someone with the certifications and no degree as a high school dropout. I attribute my employment as a java and SQL developer to the certifications. It's all I really had other than a few github sample projects. I say it's worth it to some smaller company applications to at least get you in the door for their "interview email questions" where you can actually demonstrate your skills. Larger companies probably dont give a shit. Although I'd say being certified makes you worth 5,000$ more. There's better investments for your time, but it's not a negative and I'd say worth it if you're familiar to the point you're not investing significant time to study.
Do you have any experience in programming? If there's no other apps for it there's likely no API for player stats. Creating one is definitely possible but it would be a huge undertaking for even the most experienced programmers. There are loads of resources for learning development online but again if you need to create it from scratch it could take years to even gain the knowledge necessary just to start. If youre truly determined, learn PHP, specifically get requests to build an API &amp; learn general webdev &amp; maybe JavaScript &amp; the react native library or if you're really determined Java &amp; Swift. A simple Google search for learning each will yield hundreds of resources but I'll list a few good ones I know of: PHP: https://www.w3schools.com/php/ https://phptherightway.com/ Webdev: www.w3schools.com React Native: https://www.edx.org/course/cs50s-mobile-app-development-with-react-native
It will teach you a great basis into some fundamental bits that you may have overlooked
Use the jdbc one and stay happy ;-)
I always used either JDBC or myBatis. Use whatever is more productive for you, specially due to time constraints.
&gt; official Android support Which might be replaced by Dart if Fuchsia actually does replace Android.
Only by devs that are stuck with Java 1.4.
Fuchsia, Flutter and Dart.
Kotlin's future is pretty much dependent on what Google decides to do with Android, it thrives on the lack of proper Java support, while the outside world is getting ready to receive Java 12. Then there is Fuchsia with Dart and Flutter on the horizon.
&gt; hey, guys, we've released our little OS that lacks most features and UI toolkit that can't even properly save instance state, so take your battle-tested, working OS that we've spent billions on and get out I'm sure that's how it's going to be in Google.
I disagree completely actually. It might be because I'm in a little bubble, but I'm a back end developer, I do zero android development. Everything new that we write at work is now in Kotlin, no questions asked. I also get a load of recruiter spam, pretty much all the java roles now also say must have an interest in learning Kotlin. So this momentum is completely independent of Google and whatever is happening in Android land. 
It's so weird that such a good product is getting so little attention on /r/java. 
Do you consider marshaling result sets into domain objects part of ORM?
App developers will do the Google dance no matter what.
&gt; hey, remember our Enterprise legacy app with millions loc? Well, we need to rewrite it in Dart and Flutter because Google said so, jk lol, it will support Android SDK Stop fearmongering, big players won't migrate any soon, just because some team inside of Google decided to push their agenda. When will you learn, that Google is not a homogeneous entity. Android SDK will live, they just have to swap Linux with Zircon and voila we have Android on Fuchsia.
In all my years of back end development in Java since 2006, all alternative languages have come and gone, and to this day we still do Java. Beanshell was going to be big on scripting, gone. Groovy was going to be Java's sister language for JEE bean development and easier JSF components, rescued from death by Google's decision to adopt Gradle for Android. Scala was going to take over the Java world. Nowadays Typesafe also does Java consulting and the language is confined to big data projects that make use of Spark, Akka or Hadoop in production. XTend and Ceylon, never took off beyond a couple of talks on Java conferences. Kotlin was supposed to be the next Scala, then they got ambitious with Kotlin/Native, Kotlin/JS, and only having graphical debuggers on CLion, requiring additional licenses. There is no support on Netbeans and meh support on Eclipse, the Java IDE that everyone around me actually uses. So yeah, Kotlin is pretty much an Android thing on my bubble, and we aren't even considering it, given PWAs, React Native, Qt and Xamarin. Lets see in 5 years time, which is huge in tech, how relevant would Kotlin be for greenfield projects. A very good lesson I learned, was that platform languages always win in the end. 
I don't mind more lightweight ORM's. I liked using SpringData for mongo. But ever since I got my first job and had to support hibernate i'd rather do it myself.
Believe what you will. [The Google Cemetery](https://gcemetery.co/) Brillo lost to Android and got reborn as Android Things, on ChromeOS it is still open how Android and Crostini will evolve, on hardware that is pretty much irrelevant outside North America's school system. So lets what the future holds for Fuchsia.
I think the difference with Kotlin compared to those is the interoperability with Java. That means adoption is A LOT easier than it is with all the others, as you don't have to fully commit an entire project to it (straight away). However yeah again, it may just be our bubbles. No one I know uses Netbeans or Eclipse anymore, literally everyone uses Intellij. I am curious to see the future of it though, as I really do love working with it.
Fuchsia has much more chances to die than Android, you know, right? 
&gt; Kotlin is the flavor of the month You mean the flavor of 35 months? :) Kotlin 1.0 was released in February 2016.
Sure, but then again they are ramping up their Rust and Go teams. So lets see how it goes, and how internal politics fare.
For the record, I 100% agree with your statement "Java isn't going anywhere". It works good enough for the majority of programmers, and "technical superiority" of newer programming languages simply isn't compelling enough for large corporations to leave Java behind. Is Kotlin a language for startups?
&gt; If you are doing *pure* object-oriented programming, Java is fine as it is. How do you define *pure* OOP?
This
Things you learn in college are usually different from the things you need to know on the job. Making some small programs in college which resolve around one technology doesn't require the same amount of knowledge as making a real world project which has to make few different pieces work together. Good udemy courses are teaching you how to make a somewhat real project - how to make you backend and frontend talk, how to secure your APIs, what are some good libraries, how to organize your code etc. I don't know where you live and how is the career situation in you area, but recruiters usually look for practical knowledge and projects you have in your portfolio. So they're not looking for what courses did you take, they care about what are you able to make. I got my first job just for having some projects on my github. Take into consideration that i was on my third tear of college and I was the one who got the job, not the people who already finished it. I didn't have any certificate and I didn't even finish college, yet they chose me over the others just because I had something to show. This was the case with other companies as well, out of people who applied for jobs, only those with some projects under their belt got a job. Look at it this way: if you are a recruiter and you got 200 job applications, all of which are from people who have oracle cert, how are you going to decide which ones seem worth your time? You would look at the projects they made. Someone who made a few apps, no matter how small, seems more knowledgeable, more experienced and more motivated than someone who didn't even try. 
C++ simply not just for "poking hardware. Even the JVM HotSpot is written in C++, I've listed where it's used, and there are far more desktop applications in C++ then Java * Microsoft Office * PhotoShop * Google Chrome * Firefox (but now mixed with Rust) * Most AAA+ games. * And many many more Please don't put out such patently false statements. Sure Java is ok for web apps (as are other languages which you seem to ignore), web apps is not a good choice for C++, BUT for pretty much everything else C++ is mainstream as it gets
I'm not really sure what to make out of this post: + It is programming related, so it should be posted in /r/javahelp + It is not clearly Java related as basically any backend language in combination with HTML, CSS, and JavaScript, and a database would be suitable. **Removed**
**Sidebar** -&gt; NO programming help, NO learning Java related questions!
This. The hiring manager at my previous place used to swear by "Hire on attitude, not aptitude".
We will totally hire anyone who knows just core Java very well. Sure knowing Spring stuff is very nice, but for us, knowledge about concurrency, IO, security/encryption and mathematics is much more important. Also project management and working with vcs and build tools. 
I am already enjoying my easier to use interop with native code, value types, slices, and AOT compilation across all supported deployment targets. Lets see if Valhalla and Panama actually deliver.
IMO it's better if a language is more verbose and easy to read. The developer writes the code once, but then it could be million times someone reading it...
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt;I'm fairly comfortable with SQL statements and there will be nothing crazy going on here. Then no doubt JDBC. &gt;is an ORM / mapper a must with Spring Boot? Not at all. IMO the opposite. Spring Boot explicitly supports JDBC with its JDBC templates. JPA gets you started really quickly but in the long term I prefer the control and transparency of writing SQL.
Definitely you are right ,but so does python is easy too read 
&gt;If you're already using Spring Boot, I would definitely recommend using Spring Data as well. Staying within the Spring ecosystem will help to streamline development and give your code a more consistent feel. I disagree. JDBC Templates is a first class citizen of Spring. I know of many projects using Spring and JDBC Templates. JOOQ is also very popular. [https://spring.io/guides/gs/relational-data-access/](https://spring.io/guides/gs/relational-data-access/)
It's only unclear if you don't know the language 
The correct answer is because the JVM is highly successful and other new languages want to ride that success. Most haven't succeeded. Still waiting on Kotlin.
thanks! and looks like the MOD directed me to /r/javahelp too. my bad
sweet thank you!
You’d have to pay for jOOQ then, otherwise I’d recommend using it if you were using an open source database. But if 399 € isn’t a deal breaker, I’d strongly recommend jOOQ.
[https://github.com/knowm/Yank](https://github.com/knowm/Yank)
Spring data and hibernate ...
As someone who recruits developers I don't care what degree , certifications or any other academic accolade you may have. I only care about your skill, personality and experience. I have developers with no academic background at all, but I understand not everyone is like me. Anyone with half a brain can distinguish a good developer from a bad one regardless of certifications.
You're acting like you're writing an API for 3rd party developers. Depending on your team size, the public final fields could make a lot of sense or could not make sense. If you have 5 developers on a project, it is pretty simple to change things -- if you are making some code that is used by thousands of other developers, yes, then you want to keep a very tight API. But, to just make a blanket statement that public fields are bad without knowing the scenario is pretty silly.
What would you say is a flaw of OOP? I do loads of stuff, not only OOP but especially for bigger applications I think it's great in terms of maintainability etc.
It depends how your organization is set up and what you are working on. If you did this on a team of 3 people, I think it would be perfectly fine. If you did this on a team of 1000 people, but the code you were writing was inside of a small microservice that only has 2 people ever working on it at a time, it's probably still fine.
Actually, reflection is, by definition, always after compile-time. When I reflectively remove the final modifier and set the value, that is after it is compiled.
Java certificates make me LESS likely to hire you. They are honestly correlated with being a worse developer. Just stick to actually getting better through experience working on projects.
Please don't call it a record. Call it a data class.
As someone else mentioned, JOOQ is a great option to check out. If you're looking for something incredibly light-weight and simple, you could try out the library which I use in all my projects called EZDB. It's literally only 3 class files. [https://github.com/mirraj2/EZDB](https://github.com/mirraj2/EZDB)
Make sure you spend a lot of time actually coding things. That will deepen your experience a lot more than just reading the books.
I have Oracle Java certificate. No one looks on it, but it helps you personally a lot. If you'll pass it 90+ that would make you a rock star in the eyes of someone who passed it and it actually means that you do know Java language basics pretty damn well. Also 90+ means that you mastered concurrency part, which is also impressive. But since it doesn't include spring or any other real-life libs it is just half of your qualification. 
the only thing i like in kotlin/swift... is the null safety at compile time. Java can incorporate. Verbosity is good. I prefer my IDE tool to write code for me instead of code behind hidden
exactly.. lombok sucks ass. failed to build a lombok project in IntelliJ because of a stupid plugin issue.
ms would have killed it plain and simple. 
what so great about Clojure? Java 8 has lambdas anyways.
&gt; val y: TypeOfY? = x?.getY() that's cryptic and not readable!!! i prefer the verbose version
Don't make things more complicated unless you have to. If you can get the job done using raw SQL queries, then do it.
Can I know what is the use of this plugin
The moment you have to do non object-oriented stuff, like converting a sub graph of objects into JSON and back on a rest endpoint. Or trying to squeeze an object into a DB table or five. Almost any I/O. In those cases you don’t send messages between objects anymore. And you have more or less given up on encapsulation. And that’s when things become tricky. It all has to do with state and how it can change over time. OOP is not a good choice if you need well-defined transformation of values over time. 
It's perfectly readable, you're the first person to actually complain about this syntax in this thread even among the Kotlin skeptics. If anything is slightly different than how it's done in Java I guess it's just all cryptic and not readable. You know what else is cryptic and not readable? ```java var y = x.getY(); ``` Perfectly valid Java 10+ syntax right here. Or even this: ```java TypeOfY y = x.getY(); ``` For either case I won't know till runtime that either `x` is `null` or `y` is `null` and heaven forbid that I do chaining: ```java x.getY().getZ().getA(); ``` That I'll know which of these can throw null or not and when it does which one was the culprit.
You seem to be under the impression that your CS degree will teach you everything you need. It will only teach you the basics concepts and you will need to constantly learn through your career. Might as well start now.
JDBC is a first class citizen in any framework because it's core Java EE, and a JdbcTemplate is Spring's way of simplifying its use. That's not a bad idea for someone in a time crunch more familiar with JDBC, but it doesn't provide the ORM side of the equation, and Spring data is really intuitive after setting up just a single entity.
what's more readable private Optional&lt;USB&gt; usb; private var usb: USB?
For me that would probably be the immutable data types that are the default and you will almost never write a function that mutates state. Makes everything so much easier to reason about. But the language is completely different, coming from a completely different family or languages, with its own strengths and weaknesses. It is not like Java at all, unlike many languages that just try to be almost-Java but fixing some minor things or adding some syntactic sugar.
I used to think that way too but I recently changed my mind on this. 1. Complexity is paralyzing: Yes - doing code archeology on a large Java codebase is easier because of static typing. You can - unless magic was used (i.e. annotation processors) - find which code is calling this one method you like to change. However, that often is not enough. Java OOP says nothing about concurrency which complicates analysis of code significantly. Often, if you pick up a single object and look at its graph, it's often the complete state of the app you are holding up, i.e. dependencies upon dependencies. Good luck making meaningful changes that go beyond adding a method. Refactoring tools do help, but they have well-known limits. Adding a completely new sub-graph is still a daunting adventure. I've just joined a Java dev team working on an 18 year old codebase (millions of lines of code). They suffer from paralysis quite heavily and will admit that they have no idea what consequences certain changes have. It's all tightly connected due to the very nature of object references. An object graph under concurrency has state changes that are very hard to predict which makes it hard to analyze the runtime behaviour of an OOP system. Subtle bugs will creep in that have directly to do with unexpected state. Even worse: In many popular Java frameworks, we need to deal with partial object-graphs being re-created with each transaction from scratch, handling any update conflicts in the database (optimistic locking etc.) because we simply can't hold all the state in memory and we can't reliably freeze an object-graph in time to then snapshot it in a consistent state. Thus the immense memory needs of Java application servers and the enormous amounts of garbage created, thus the analysis of bugs involving hunting it all the way down to the DB and back (leaving the cozy 'message passing between objects' world) 2. Classes are not enough: Modeling the world as mostly 'nouns' doing 'verb' things to each other only using inheritance and interfaces is clumsy. It encourages a top-down design approach with lots of design patterns that are all obfuscating the job at hand: Doing stuff with data. Here's a great video that highlights the differences between an OOP vs a FP approach. https://www.youtube.com/watch?v=Tb823aqgX_0 
And Teams makes up for Skype
Not an excuse really, just pointing out some potential limitations / time constraints and getting others feedback. My only exposure using an ORM is with MyBatis and that was only on 3 or 4 (albeit medium to high complexity) SQL statements on one particular Spring Boot project. The other projects (much larger projects overall and not Spring Boot, just Spring MVC) were pure SQL statement via JDBC.
 Eclipse and IntelliJ are the two competing IDEs in the industry. There are lot of passionate discussion going in the social media, forums to declare the winner in this race. [https://blog.heaphero.io/2018/11/05/memory-efficient-eclipse-or-intellij/](https://blog.heaphero.io/2018/11/05/memory-efficient-eclipse-or-intellij/)
I'd add, do not take unpaid internships unless absolutely necessary. 
i am for verbosity.. x?. was not included in Java 7 for a reason. Optionals are more readable. i prefer the if let statements in Swift... much more readable.
Huh, I guess that's why rust describes itself as data oriented rather than oo. I personally don't have experience with codebases as large as the ones you're working on, but it seems like you have a point, though I'd imagine a big non-object-oriented structure to be really tedious to write and handle - I'll look into watching the video this week ;)
I agree, having a very large JavaScript code base with similar complexity would be a nightmare. If you have no tool support other than regexp search. Dynamically typed language require greater discipline in that regard for sure. Often, those codebases are smaller since the code tends to be more terse. And - here's the caveat - experienced teams will try to de-couple and modularize the code so that changes only affect those modules. That's why in functional programming, you'd like to keep your functions pure i.e. keep them referentially transparent which simplifies things a lot. I.e. a pure function call can always be replaced by its result. i.e. no side-effects. A meaningful program needs side-effects, so those are either pushed to the boundaries of a module or are treated as special types (Monads and such). OOP was invented for simulation and graphics-oriented programming. If the problem you need to solve is not a simluation, OOP might not be the best tool to use. BTW: I still *love* the JVM. It's great. I still can bang out Java code quicker than anything else, but all my next projects will be in Clojure (which interops very nicely with Java) 
"and very few organizations will ever adopt Java 11 or beyond" - Tell that to the company that I work for (that brings in 2.5 billion GBP annually) who's already adopted it ¯\_(ツ)_/¯
Every single one of these applications requires maximum performance and most of them are old as hell.
Oooh, what is that framework you're about to build?
What are you missing? More posts about how to use jOOQ? Or posts about how jOOQ is made (e.g. API design decisions, algorithms, performance, etc.)? Or experience reports about using jOOQ? Or something else?
That's anecdotal. Various statistics tell a different story. Most companies stay on Java 8 and have no immediate plans to switch to a newer release.
I didn't saying anything about not being willing to learn new languages.
This isn't even equivalent to the code they wrote above lol If the movie's rating changes, what happens? Create a new movie?
It looks like in your [submission](https://www.reddit.com/r/java/comments/afnjks/rxjava_flattening_multiple_of_singeliststring_to/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt; no amount of sarcasm will change that. Since you added this I assume you suggest that I am one of those who jump to defend Java meaning that it is brilliant. I didn't do that at all. Everyone has a right to their opinion about programmig languages but posting yours and then claiming all the smarter devs do according to your opinion is so very naive it deserves sarcasm. Are you really that full of yourself? All languages has flaws, good developers learn to live with those flaws. I think there are a couple of classic quotes fro mBjarne S that fits this situation: &gt; Anybody who comes to you and says he has a perfect language is either naïve or a salesman. &gt; and &gt; There are only two kinds of languages: the ones people complain about and the ones nobody uses. I don't think any quote is correct simply because an experienced guy makes them but I think these are pretty good hints to how it works. I don't think Java is perfect at all. I actually like Python much more even if I would like for it to be different in some important aspect. Languages with a large collection of libraries and tools will be "better" than a language which has better syntax etc but has very little tooling and libraries.
The odd thing is that her reasoning is based on the cost of paying Oracle for support: &gt; Many of my clients anticipate that the annual subscription cost is greater than $1 million Despite noting before that that there are alternative distributions. &gt; or find an alternate distribution, such as AdoptOpenJDK, Amazon, Azul, IBM, or Red Hat. I would imagine most rational people will switch instead of paying Oracle. If you have RedHat Linux servers, for example, then support for their JDK distribution is most likely included in your support contact.
&gt;and very few organizations will ever adopt Java 11 or beyond Anecdotal, but at my company, we have adopted Java 11, in a 100 Maven modules big project.
That's my point. Most people know java not these other obscure/specialize use case based languages
As an experiment, I recently tried my hand at using JDBC template and JOOQ as I really hate hibernate. Some things I struggled with - How do you model your domain entities? You're sort of just making DTO's that have the same structure as your db tables so there is less mapping to do. Anyone have advice on this? - Table joins are painful to manually map back to java entities. Need custom DTO's representing the final payload of the join result. - Fair amount of boilerplate but atleast you know whats going on. JOOQ is amazing though really. The creator of it is a genius to get all of that code gen working the way it does. I'd prefer to use this over raw strings due to having some compile time safety should any refactoring occur. There is nice integration into spring boot for it too which was a bonus. Summary - spring data with hibernate sure makes it easy and its hard to avoid not using it for the bulk of the crud operations. I just really hate the "generate a query by method name". Of course there are alternatives but yeah it just seems like tradeoffs everywhere so nothing is perfect.
This article makes it sound pretty sad IMO... &gt; The past year saw another surge in the evolution of Java but then the article mostly just continues to talk about a bunch of lawsuits, how bleak the future adoption looks, how everyone is afraid of oracle reps, and then a bit of talk about some generic cloud stuff like lambdas and containers. Don't we have anything to look forward to?
You are likely referring to the usage of JDBC. Until Oracle R2DBC is ready, there is [rxjava2-jdbc](https://github.com/davidmoten/rxjava2-jdbc). Reactive data stores like Cassandra, Redis, and Mongo are already supported under Spring Data, for example.
I'm afraid that's not even a point. None of the languages I listed are anywhere near being a domain specific language (or "use case based" as you put it) and the only point you raised for those languages to be "obscure" is that you don't understand them. And the grand point that most people use the older, more established variant is so inherently dumb that I'm really questioning how you acquired your honorable opinion. I'd really love to have a discussion here, but how about you bring up some actual arguments instead of acting ridiculously conservative? 
Nah... I noticed that almost any mention of jooq is getting downvoted, but people so excited about JPA and Hibernate.
&gt; "Oracle will no longer distribute free bug fixes and security patches except for the latest version of OpenJDK, and Oracle will be releasing new versions every 6 months" I have said it many times here, but I will repeat it as many times as it takes: the biggest change is that the concept of a "version" means something very different now than it did before, therefore using old terminology with new concepts doesn't make any sense. First, Oracle has released new versions of Java every 6 months for many years now. The ability to upgrade your Java runtimes at least every six months is as important now as it has ever been, regardless of your support situation. Similarly, security patches weren't released for old versions of Java even under the old model. JDK 8u20 stopped being supported when 8u40 came up. The change now is that 9u20 is called 10 and 9u40 is called 11, as JDK version names have adopted "Chrome versioning." You may say that while only the latest Java version was supported, old *major* versions were still freely supported, but here's the thing: JDK 9 was the last *ever* major Java version (or, at least for however many years the new release model is followed). If there are no more major versions, and there aren't any, then the very concept of supporting an old major version is meaningless. JDK 10 us no longer supported in the same way JDK 8u20 is no longer supported. True, the new feature releases are not quite the same as update release, but with about 1/6-1/10th of the JEPs going into the old major releases, no one can reasonably think of them as major versions, either. So this is the real question: Given that a runtime upgrade every 3-6 months is and always has been necessary to keep your environment secure, how costly is it to upgrade to a new feature version as opposed to a new patch? I don't think anyone has a good definitive answer to that question yet, but the good news is that you don't have to decide. You can give the feature releases a try, and if it turns out to be more of a hassle than the old update releases, you can always go back to an LTS version. 
VSCode is brilliant for scripting. Even as a heavy IntelliJ user, I drop to VSCode to write Ansible roles. It's a fast, clean, responsive interface. I'd never use it for a full Java project though - but popping open the odd class for reference here and there is often easier in VSCode than anything else. 
I second this as someone who helped start a large Spring Boot/Spring Data JPA app, and looking back on it would prefer to have just written SQL. I think Spring Data JDBC is also a good option to save some mapping and automatically generating basic CRUD type queries. The only bad thing is that it has a ways to go in terms of features, but might be worth starting for simple CRUD.
If the rating changes, you are most likely doing a SQL query to update a row. In the case where you need to update an in-memory version of the model, just don't make the field final.
Upgrading to Java 8 was a huge ordeal at my company, but we were also running on a traditional application server. Since we've moved to a modern containerized workflow, the pain of shipping Java 11 is significantly reduced.
Take a look at JOOQ and QueryDSL instead of ORMs or JDBC
Sure but that's not the reason I made this post mate
This x infinity
We just did as well! My boss decided to do it 2 days before a major demo.
C++ is the industry standard for game development and it is well used in many other industries also. It’s not going anywhere soon and since C++17 it’s only gotten better. It’s far from unreasonable 
Yes, now a domain-specific lang. Very useful for games
Bring headphones. Often hackathons are busy places with lots of people. Take breaks too. Tunnel vision can present itself if you're faced with pressure. Make a little bare-bones skeleton so you don't have to do project setup there. No actual code, just running like "rails new ..." - or setting up Webpack, messing about with that can take a lot of time. Prepare your workstation, you'll be leaning on it and having to do an install on the spot can be time consuming. Don't forget to talk and meet people and, mostly, to have fun!
Your boss was simply introducing self-inflicted chaos into the system as a sort of offering to the Demo Gods. They take note of such good-faith gestures and will eventually release their reigns of terror once they trust the company to perform these duties on their own accord.
A bad team. My team doesn't kill me for writing such data classes.
The problem is the bigger effort needed to update from Java 8 to Java 11 (skipping 9 and 10 here). Together with having to switch to OpenJDK, it's quite something to do. Also some libraries don't support Java 11 - are even broken or slow. From a developer view point there's also not much "wow". There's `var` but that's not in the same category as lambda's and Stream's were when switching from 7 to 8. So not much incentive there from that side aswell. I'm not against the new release cadence, just trying to see why the Java 11 adaption is so low.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
The example given used a data keyword which is most likely means it is for a more specific use case. I don't believe at all you are interested in having a discussion since you are insulting and arguing against a self evident point. There wouldn't be these other languages if java solved every problem equally. 
- If you’re planning on building a web app, be aware of how to setup/consume a REST service in Java + basics of how to connect to data services like MySQL. - Make sure your workstation is setup with tools you’ll think you’ll need, like IDE, git, docker, maven (or use mvn wrapper), etc. - I like to bring a notepad + paper to sketch out ideas or jot down little notes. Personal preference. - use something like Flux to dim your screen so your eyes don’t burn out of their head. I also like to wear a hat to keep overhead lights out of my eyes. - DO NOT drink too many energy drinks, soda, or coffee. Moderate it. - bring a backpack to carry all your crap. - Bring a water bottle + drink lots of water. It’ll help you stay mentally sharp &amp; physically awake as the hours go on. - take frequent breaks to stand up/move around. - bring a few healthy-ish snacks like granola bars or a banana. don’t fill up on pizza or you’ll feel like shit and crash. - Bring earplugs. - Bring ibuprofen. - Bring a sweater in case you get cold. - Bring a phone charger. - Bring deodorant and a toothbrush.
So even now you are arguing without knowing what that keyword even means and you still have the audacity to call any of your claims "self-evident"?
As an another anecdote, my company switched to openjdk 8 and has no plans to use the official Oracle JDK ever again. We might go to 11 if there is a stable openjdk for it.
You had the audacity to say you'd love to have a discussion first 😉 and now I'm 100% sure you're just some typical nerdy asshole whos probably somewhere on the spectrum
Not OP but nice advice, thanks
Looking at the 3 companies I deal with we have two 6's and an 8.
Great, now explain it to my boss. The public version numbers are a marketing tool to help to sell a product. But this one actually just confuses the hell out of the decision making people, who will instead opt to not adopt them. So, this was a **bad idea** and the person who came up with it should be ~~flagged~~ fired. You literally just spent three paragraphs to explain it for us, a bunch of technical people, which proves my point: a non-tech people would lost the attention after the first paragraph. Think with me, how easier our collective lives would be if instead they just announced they would start to implement some (additive) API changes on minor version. They would be able keep the version schema the core users are comfortable with, they would be also deliver new features that developers like me love to work with, and they could even make a shinny marketing piece saying that they now were following SEMVER and add many pretty buzzwords to it. It would been WIN-WIN-WIN situation. 
We still have 8, but architects added 11 adoption to the 2019 roadmap so ill be in the cool club too soon yay
thanks a lot!!
thanks so much!!
Right, except that a different versioning number scheme [was the original plan](https://mreinhold.org/blog/forward-faster) but as OpenJDK is an open source project, and such things are discussed in the open (on the appropriate channels; not Reddit), it turned out the [people in the community hated this](https://mail.openjdk.java.net/pipermail/discuss/2017-September/thread.html) and preferred Chrome versioning. Whatever version naming scheme had been adopted, some people wouldn't have been happy about it (they certainly wouldn't have been happy with semantic versioning, as, being the worst of all possible worlds, it is a particularly bad way to name versions).
If it's not explicitly forbidden to do so, prepare ahead of time. If you'll need to implement a generic web app, have a Spring Boot skeleton app ready to go with the db integration working (don't be like me and my team on our last competition and spend 2 hours unfucking Initializr's buggy MongoDB plugin) If it's a game you need to write AI for, have a working Dijkstra's Algorithm implementation ready. That stuff can be applied 99% of the time. Above all, have fun!
Where did you get that url? Couldnt find where it was happening myself. And ya know, considering this post's theme n all, you should open an issue on the repo or for bonus points add a pull request
there is a stable openjdk for it. no if about it
My experience on /r/java is the opposite. Can you point me to a positive Hibernate thread in the past year?
&gt;I have said it many times here, but I will repeat it as many times as it takes Ok, but you would think it would be very efficient to do so on the comment section of a subreddit?
That's a completely separate issue from the quote I responded to.
Seems like a nice API, but since I'm using MS SQL Server, there's a fee for it.
Lol thanks, I appreciate you pointing out the obvious.
I'll look into it for future use for sure, but may need to pass on it for this project. Also, I always stress quite a bit when I learn something new or introducing a previously unknown element, right before a new project, lol.
Good to hear actually, I was worried that Spring Boot would force me away from straight SQL / JDBC, and push me towards an ORM or Hibernate etc.
Sage advice, most likely this is what I'll end up doing. Though I'm taking 2 Spring courses on Udemy now. One teaches Hibernate quite heavily.
JOOQ I've heard charge, but pretty sure QueryDSL is free and works with SQL Server
Have fun and get involved in all aspects, from tech to non tech like presenting - its all great practice and experience. I can not recommend hackathons enough! Its not only a great way to learn but also to meet people and network :)
Setup your development environment before hand. This includes a database. I have won several hackathons. What slowed me down the most was having to download packages on a congested network. 
no evolution without concurrency and variation
What do you mean with recently? Groovy was started in 2003, Scala in 2001 or so.
&gt; First, Oracle has released new versions of Java every 6 months for some years. ...if by "some years" you mean ["announced in September 2017 and started in March of last year"](https://en.wikipedia.org/wiki/Java_version_history). I agree that even smaller companies should have learned by now, but let's not be revisionist about it. 
just wow 
I see. Indeed, I've noticed some immediate downvotes for posts of the jooq.org domain myself, perhaps automated. Especially on /r/programming. But any posts do seem to go beyond some "downvoter threshold"... ¯\_(ツ)_/¯
Learn git before.
You could take a look at [CDI](http://cdi-spec.org/) and the MicroProfile [Config API](https://github.com/eclipse/microprofile-config) based on top of it. The former gives you a general purpose container for DI and context management (and events, if you need them), the latter lets you configure your beans via DI based on different kinds of config sources.
That would probably depend on the job?
SQL is handy to know. I would recommend the Microsoft Office suite. Especially Excel and PowerPoint. 
Surprise!
Meh
Well, let's see: - [9 High-Performance Tips when using PostgreSQL with JPA and Hibernate - 49 Upvotes](https://www.reddit.com/r/java/comments/a0gxa5/9_highperformance_tips_when_using_postgresql_with/) - [Hibernate performance tuning tips - 62 Upvotes](https://www.reddit.com/r/java/comments/9hf8z3/hibernate_performance_tuning_tips_vlad_mihalcea/) - [Hibernate ORM 5.4.0.Final released - 33 Upvotes](https://www.reddit.com/r/java/comments/a5th1o/hibernate_orm_540final_released/) - [Spring 5.1 read-only transaction optimization for Hibernate - 52 upvotes](https://www.reddit.com/r/java/comments/9jl13n/spring_51_readonly_transaction_optimization_for/) And those are just some posts in past 3 month. If you want more, check out this /r/java [search query](https://www.reddit.com/r/java/search?q=hibernate&amp;restrict_sr=1&amp;t=year).
&gt; I've heard a lot about Hibernate, but never used it yet. u/JehovahsNutsac I'm a developer of the Hibernate project, so I can surely help you get the most out of it. The [Hibernate User Guide](http://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html) is a good place to start getting to know more about JPA and Hibernate. What people didn't tell you on this thread is that Hibernate is immensely popular even 18 years after it was first launched. According to this [2018 technology report](https://snyk.io/blog/jvm-ecosystem-report-2018-platform-application/), "More than 1 in every 2 developers use Hibernate in their applications." Now, as long as you read the documentation, you will be fine with it. For more details about how to get the most out of JPA and Hibernate, I wrote [over 200 articles on my blog](https://vladmihalcea.com/tutorials/) which show you that you can benefit from Hibernate convenience while being as efficient as if you wrote your application using plain-old JDBC. 
Maybe another frameworks. For example Spring MVC, Thymeleaf template engines, Java 11
QueryDSL with entities annotated with JPA annotations works pretty smooth.
To add to the other answers, don't overestimate what you can do. Start with a working prototype ASAP, use workarounds when stuck. Refactor and add extra features only if you still have time left, do not focus on anything except for the core idea.
to map table joins with jdbc template and jOOQ you can use[https://simpleflatmapper.org/0104-getting-started-springjdbc.html](https://simpleflatmapper.org/0104-getting-started-springjdbc.html), see for join mapping [https://arnaudroger.github.io/blog/2017/06/13/jdbc-template-one-to-many.html](https://arnaudroger.github.io/blog/2017/06/13/jdbc-template-one-to-many.html) it deals with all the pain.
&gt; It's an algebraic Data type. More specifically, it's a _sum type_. ADTs are more general than that, since they also encompas _product types_. That is, regular classe or tuples are algebraic data type as well since they are product types. 
&gt; Java is a generally a reasonable choice for desktop apps Said no desktop app user ever
+1 to ibuprofen
There are a few technologies I would keep an eye out for in a candidate (I work on Enterprise projects) Unit Testing (TestNG, JUnit, Mockito, etc) ORM (JPA, Hibernate, etc) Transports (REST, Soap, JMS, etc) Typically you could learn everything else on the job, but these will at least get me more interested. &amp;#x200B;
You are going to need more than a month. Thanks for posting though. I have one study guide, I would be interested to hear what others have to say about other books, and other resources.
Focus on delivering things.
To second this, start from the presentation and work backwards. Don't build things you won't show in your presentation.
Mala Guptas (hope I didnt confuse her name) mannings OCA preparation guide is great. I passed exam with that and enthuware mock exams on 99%. However as said, one month is not enough time unless you are ready to spend 10h each day practicing everything.
&gt; now a domain-specific lang No it's not. No matter how many times you post this, it's simply not true.
I used this and passed OCA at first attempt. OCA/OCP Java SE 8 Programmer Certification Kit: Exam 1Z0-808 and Exam 1Z0-809 https://www.amazon.it/dp/1119272092/ref=cm_sw_r_cp_apa_i_xhipCbSEF3C3K
I second this 
What's the price for taking the exam these days? I passed it years ago, and I'm curious how well I'd do after forgetting all the unimportant stuff.
I'm not sure since my company paid it for me, but I think it was around 200$. I had to pay the book myself, because Oracle preparation material is mostly premium...
It looks like in your [submission](https://www.reddit.com/r/java/comments/afvq5o/keytool_cert_chain_signing/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
No, this has actually been going on for [over 5 years](https://java.com/en/download/faq/release_dates.xml); the "limited update" releases had some [pretty big changes](https://www.oracle.com/technetwork/java/javase/8u-relnotes-2225394.html). What's changed recently is the *name* given to those versions (i.e. instead of 9u20 we got 10), and the kind of changes allowed, but not so much the size of the changes.(e.g. see [JDK 9](https://openjdk.java.net/projects/jdk9/) vs [10](https://openjdk.java.net/projects/jdk/10/) or [11](https://openjdk.java.net/projects/jdk/11/)).
If I was interviewing someone with 2 years experience I'd mostly be looking for good core Java and anything else is a bonus. What I care about most is someone showing they can write good code and turn their hand to things.
Since you want to be fast, then pick MongoDB and/or Redis. 
Wrong subreddit. Get help elsewhere. 
Search for OCA dumps, they are good for practice
I have been freelancing now as a java dev pretty solidly for approx the last 10 years, before this I was a photonics engineer building fiber networks. 10 years ago there was a lot of work and not so many people, now today there is still a lot of work, the main difference today is there are a lot more people chasing that work. For example I completed a contract with a US agency a while back, they managed a pool of developers from the Ukraine, they had a couple of full time Ukrainian translators and a bunch of project managers, they actively chase contracts underbidding rival agencies based on their ability to use Ukrainian devs at a fraction of the cost. As someone who has traveled extensively I have nothing but the highest respect for the Ukrainian devs, many of them are simply formidable when it comes to skills. Needless to say this agency is very successful. What this means for western developers to stay competitive, is 1) we have to lift or game, 2) leverage our natural advantages. This means getting off our butts and proactively chasing the work at the source. How this would work out for the OP is rather than waste money on useless and meaningless cert factories. Use the money to get out there and communicate face to face with companies. This means money for travel and if there is some left over get some basic business nous, understand the language game for business(MBA), ie SME for example. Set up a system to invoice and get some understanding of contract law and how to apply it.
Not the upvotes but more the comments "The best performance tip for JPA is don’t use JPA" https://www.reddit.com/r/java/comments/a0gxa5/9_highperformance_tips_when_using_postgresql_with/eahnj9q?utm_source=reddit-android For the record I use JPA via Hibernate in a application with over 100 tables and I'm extremely happy. 
This is like Test-driven development but better. I like this approach!
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
That is because it is non-free.
For a greenfield project I would never use Hibernate. Just use a JDBC helper library. You will be much happier.
I have those two books. The first one OCP its prettt good. The second one, the part about concurrency it's pretty bad but the rest is good. Going to take OCA in a month
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt; According to this 2018 technology report, "More than 1 in every 2 developers use Hibernate in their applications.". I would be genuinely curious what the percentage of yes answers would be to a follow-up question, "If you had a choice about using hibernate in your app would you still choose it?" 
This is surely a blocker to using Yank for anything beyond a very simple app? "No multi-statement transaction service (This may be just fine for small to medium projects or to back a REST web application's API: POST, GET, PUT, and DELETE. These correspond to create, read, update, and delete (or CRUD) operations, respectively.)"
Is there? I’m not worried about 8, but I’m worried about 11 or 12 or whatever comes a year from now. I imagine red hat will cover REHL, and Amazon will probably cover AWS based stuff. But I develop on a Mac, where would I get openjdk for that? Oracle will provide it for a while, but every six months they are going to make me upgrade and judging by past experience there is no way I will be able to upgrade that quickly. We will probably end up with adoptoopenjdk but they don’t validate against TCK yet. That’s probably fine for dev but who knows. There is a lot of confusion about where to get java from and that’s bad, no if about it.
Here are some of my notes, hope you find it useful: https://github.com/sake92/notes/blob/master/java/OCA%20-%20Java%20SE%208%20Programmer%20I.md
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You *always* had to upgrade every 6 months to get the latest security patches. The main thing that has changed now is the version *names*, i.e. instead of JDK 9u20 it's called 10. The feature releases are by no means major versions. The last major Java release *ever* was 9.
The "official" JDK by Oracle is now OpenJDK, too. "Oracle JDK" can now only be used by those who buy support from Oracle.
But if so many developers don't want to use it, who is it that keeps on choosing JPA and Hibernate for them? And, how come it's still so popular after all these years? There have been alternatives for decades (e.g. JdbcTemplate, MyBatis, QueryDSL, jOOQ), and yet, Hibernate is still the de-facto Java data access technology. My 2 cents: - it's open-source - it's actively maintained - it has very good documentation - the [forum](https://discourse.hibernate.org/) is active and questions get answered very quickly - there are tons of books and courses available to deepen your knowledge - there are millions of developers that use it on a daily basis and got to know it, hence you can always hire a middle or senior Java developer that will instantly understand the Hibernate-related code. 
I thought that upvotes were a measure of how interesting an article was. Do you think that people write negative comments and then they upvote the Hibernate-related articles? That would not make much sense. And, there will always be developers complaining about anything. They don't just complain about Hibernate. Usually, they complain about Oracle, MySQL, SQL Server, Vim, Emacs, Eclipse, Java EE, Spring, Javascript frameworks, etc. It's easy to complain. It's more difficult to contribute to making all these open-source frameworks better.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
think of a class with a dozen fields. Then think of all the code for getters and setters. forget the fact that you can auto-generate them, that's just a LOT of noise in that file when you're looking for code that actually does stuff.
I agree with Spring, Spring (boot) is quite popular so it is safe bet. So then Maven is required. I don't like Gradle but it is another alternative. 
Umm, may I ask why you aren't upgrading to 2.1.x? (Latest as of this writing would be 2.1.2). It doesn't look like OP is the author of the article, but it might be good to test to verify the steps still work with 2.1.2, and then just do some updates to the article. Choosing 2.0.5 is a bit arbitrary as it's not the most recent release on the 2.0.x branch either and I'm pretty sure the 2.0 branch is going to be EoL pretty soon, so it wouldn't make a lot of since to migrate to it now (as opposed to 2.1). 
I just installed homebrew and installed java through that, it's a lot easier as it does everything for you. Their website is just brew.sh It basically just allows you to install everything through the command line. Like brew install java
I’ll let a MacOS user correct me if I’m wrong, but you should be able to just download from the website and install. The number you asked is just the update number. So - 8u192 is newer. But you should be able to choose Java JDK for Mac and just install. When you need to set the version in IntelliJ, you will point to the JDK folder(where it installed). I’d suggest Googling that part - IntelliJ has good documentation on how to set up any languages, plugins, etc.
This kind of posts go to [/r/javahelp](https://www.reddit.com/r/javahelp) On mac OS you probably want to use Homebrew and get a good distribution of OpenJDK, such as the ones from AdoptOpenJDK: [https://github.com/AdoptOpenJDK/homebrew-openjdk](https://github.com/AdoptOpenJDK/homebrew-openjdk) Since you're a beginner you can start with Java 8, I assume most course materials out there don't cover newer versions yet. You can install Java 11 too if needed, IntelliJ can handle multiple SDKs. But then your default Java runtime might not be the one you want. Java 9 and 10 were short lived versions, you can skip them.
Try to aim pretty small for what you are trying to demonstrate, and don't try to write something that is too data heavy, unless you have ready access to the data you are going to use. Limit the number of new technologies you are going to work with and try to keep the same toolset in regards to your workflow. That is a hackathon wouldn't be the time to test out a new build management, version control, or IDE. 
To add to this: Check the terms/contract who owns the created intellectual property after the fact. 
They probably negativity comment and then down-vote. Within a post I rarely look at the vote count. It's the vocal minority for sure and I people get tired arguing the same points over and over again so the negativity often is all that remains.
Writing a few blog articles about how you put something together using "technology x" (e.g. "Here's How I Used Spring Data, MVC, Security to Write a Full Feature REST API in an Hour!") and then sharing the code would do more to boost your resume in a shorter time than a Java cert would. A blog article shows: 1. more initiative 2. provides a concrete example of what you can do 3. "builds your brand" That said, don't feel overwhelmed about building your resume. It's something people just entering the industry are a bit overly-concerned with. It can lead to burnout/bewilderment as you try to match the accomplishments/resumes of people who have been in industry for years. That is on top of that resumes often exaggerate a person's accomplishments (and for that matter job posting often exaggerate the technologies you will be working with). 
All three approaches are fine depending on what you need. Hibernate is fine if you have full control over the DB and have some experience with it (there's a number of quirks you have to be aware of, especially with lazy loading enabled). MyBatis is fine if you have limited control over the db, queries and/or want something that will just run the query (which might include db-specific voodoo) and map it to some objects without any black query generation magic. Direct JDBC is fine if you have specific performance requirements. In general you want to decrease the cognitive load as much as possible, so you want something simple enough to make it easy to think and reason about. 
[removed]
just use JPA. It will help you create your application very fast. With spring repositories you will have your CRUD out of box, only thing you need to do is create object model, which in the end is reflection of your DB tables and references. The only disadvantage of JPA against plain JDBC is performance. Its much harder to improve query performance if JPA is used, however if this application needs to be developed fast JPA is the way to go.
Install Homebrew than sdkman than Java.
Sdkman.io is the best answer
You can actually use java en a device with only a few Kb ram (not the latest version however). I have done this. The java-version occupied 2 Kb extra flash. The java-code occupied the same amount of flash as similar code written in C. Check out: https://github.com/ivmai/JCGO You can deploy java-code to IOS as well (there are many translators). I actally think you can use Java in all your examples above.
The latest jvm from Oracle (with even higher performance) is written in java. It is even included in the latest jvm. It can run multiple languages (even C++). See: https://www.graalvm.org/
OpenJDK 11 is a stable release. Or do you mean the ecosystem as a whole?
&gt; however if this application needs to be developed fast JPA is the way to go I think there's a lot of cargo cult in this claim. With sufficient proficiency in any of JPA/SQL, an application can be developed equally fast
&gt; But if so many developers don't want to use it, who is it that keeps on choosing JPA and Hibernate for them? And, how come it's still so popular after all these years? https://yourlogicalfallacyis.com/bandwagon Hope this helps ;-)
You didn't answer the question, so I assume you agree with my reasons why Hibernate is so popular.
&gt; You didn't answer the question Oh, I thought they were rhetorical &gt; so I assume you agree with my reasons why Hibernate is so popular. https://yourlogicalfallacyis.com/tu-quoque (I love this website ;-) )
adoptopenjdk or azul's zulu are both free openjdk builds available for mac
Right, but that is only available until OpenJDK 12 or 13 or whatever comes out, then 11 will be just like 8 is today. I don't want to have to chase whatever Oracle pushes out immediately, because they have a terrible track record of releasing usable Java versions. 
9 and 10 aren't even real releases, right? The "supported" version went from 8 to 11, if I understand right. Which I probably don't, honestly. If someone had a goal to make versions as confusing as possible, I don't know if they could have done a better job than this. (Other languages do this as well, of course; how are you supposed to know that Ruby 1.9.1 isn't "real", but 1.9.2 is? To Ruby's credit at least things are more sensible now. Compare that to Java which had one of the most stable upgrade paths I've ever seen, up until Java 8)
Specifically we switched to the java-1.8.0-openjdk RHEL package, instead of installing the Oracle JDK. AFAIK the java-1.8.0-openjdk package is compiled by RHEL and will be maintained as long as the current long term release of RHEL is available. That's what I meant by "switching", we won't go to Oracle and download anything again.
9, 10 and 12 are just as real as 11, and are treated exactly the same by the OpenJDK developers. The only difference is that 11 is arbitrarily designated as an LTS release, which means that Oracle provides paid support for it for a number of years. It is also likely that the LTS versions (although not necessarily, and not necessarily only them) woul have "update" OpenJDK projects, which will see backports of security patcues (although the backports won't be done by Oracle engineers).
I've used this book and the tests from whizlabs.com... I got through with one month and a half. But I was dilligent and even studying on the weekends. I scored 98% I believe it was due the testing from whizlabs too so I recommend it. (Look for a coupon online for some discount before buying)
There is no way you didn't like IntelliJ.
You can use both. I find that using Hibernate to query and manipulate Java objects is very handy for handling interactive web browser requests, or even web service requests. It is very convenient. The query brings back a list of objects that are the type of row from the query. Iterate over, and manipulate the objects, and they are persisted into the database. It makes the validation and business logic read very nicely. Pure SQL is a better fit for reports. Just pass a ResultSet into the JasperReports library. Use what you think works best for every task. &amp;#x200B;
i like typing set CTRL_Space get + CTRL space lombok sucks.. its often used for classes with 3 or 4 fields. and you need to deal with dumbass dependencies.
It's not uncommon to migrate a few versions behind really, basically the last stable version as the latest code usually hast the latest bugs too. (In fact, I had a look at springs repo and 2.1.x is currently broken) 2.0.x, 2.1.x, etc are only minor releases with nothing major in differences worth the additional risk added to your migration. But I get where your coming from, its not wrong to think this should be the correct approach either, but after a few disasters you learn to be wary with any change like this lol
Not a problem because Java will bury them all and still be there in 2050, alive and kicking.
I recently migrated my spring-boot application from 1.5 to 2.1. https://github.com/javadev/pt-backend/pull/2
So am I missing something, did nobody use javaFX javapackager?
I played with fibonacci and other series and fun things in Clojure a few years ago. Suppose you don't want to use `BigInteger` and just want to limit your results to a `long`, what is a super fast implementation of factorial in Java? /** * Factorial function. * @param n * @return factorial of n, where n is &gt;= 0 and &lt;= 20. */ static public long factorial( int n ) { switch( n ) { case 0: case 1: return 1L; case 2: return 2L; case 3: return 6L; case 4: return 24L; case 5: return 120L; case 6: return 720L; case 7: return 5_040L; case 8: return 40_320L; case 9: return 362_880L; case 10: return 3_628_800L; case 11: return 39_916_800L; case 12: return 479_001_600L; case 13: return 6_227_020_800L; case 14: return 87_178_291_200L; case 15: return 1_307_674_368_000L; case 16: return 20_922_789_888_000L; case 17: return 355_687_428_096_000L; case 18: return 6_402_373_705_728_000L; case 19: return 121_645_100_408_832_000L; case 20: return 2_432_902_008_176_640_000L; } return 0L; } Taking the factorial of 21 or higher gives a result which is not expressible as a `long`. Therefore `BigInteger`s are used for many digits. I strongly suspect that a similar function using a `switch` statement could handle all of the fibonacci numbers that fit into a `long` result. &amp;#x200B; Suppose you wanted a faster fibonacci function. You could have a helper function that has hardcoded `BigInteger` results for fibonacci numbers that are mod 100, and one greater. That is the `switch` statement would have results for numbers 100, 101, 200, 201, 300, 301, etc . . . up to some limit. Maybe then go by 1000's up to 10,000. Want the 315th fibonacci number? Start with the helper function returning the result of `fib1( 300 )`, and `fib1( 301 )` then by iteration calculate the 315th fibonacci number. Only 14 iterations needed. You could optimize your function to memorize in an array the intermediate fibonacci numbers (or only some subset of them) as you calculate them. For example, if calculating fib( 395 ), then start with 300 and 301, but memorize 320,321 and 340,341, then 360,361, and 380,381 along the way.
IntelliJ, Burp Suite, FindBugs... If you're an art snob then, sure, go with something that reflects your spirit animal, but Java doesn't at all inhibit intuitive high-performance functional design
It's true for new projects unburdened by legacy concerns, or at least should be.
&gt; The change now is that 9u20 is called 10 and 9u40 is called 11, as JDK version names have adopted "Chrome versioning." I just don't see how that's true. In the previous scheme (up to JDK 8), an update such as 1.8.0_191 would never have * introduced substantial new APIs * introduced new language features * incremented the source level and class file format version * removed APIs and entire modules (JAXB comes to mind) Note that I'm not saying that I dislike the new scheme (on the contrary, I like how we get new features more quickly), but neglecting the evident differences to the old versioning is misleading IMO. 
I really think this counts as as per the readme: &gt; JCGO (pronounced as "j-c-go") is a software application which translates (converts) programs written in Java into platform-independent C code Sure its certainly an interesting project though
Yes! And don’t spend a huge amount of time on logic / functionality that can’t be Demo’d well if you can just mock it up instead.
8u191 and 8u192, I don't know exactly what the differences are, but its something with ending in even and odd numbers. I would just get 192 since it is the one with more fixes. I think they get released at the same time though, but still not sure why they have two lol. All that said, I think you should get the version 11, not 8! 11 is the latest and is also long term support meaning it's going to be around for a while. 8 is almost at end of life. The only big difference (apart from programming features) is that in 9 and up they changed the way the folders are structured. All future releases are going to he like the 9 and up ones, not 8 and lower ones, so it might help to get familiar with it. Again, for an absolute beginner this probably won't matter.
Same here. Our software will be updated to use JDK11/12 before the official JDK12 release. We've been using 8 since 2014 and been delaying the update for years now.. It's actually a good that this one is kind of forced.
I am not saying that the new feature releases are identical to the old update releases -- they are not -- but they are closer to those than to the old major releases. The main point is that treating the new feature releases as if they were major ones and making decisions based on that is wrong. The best thing to do is to wait and see what their actual impact is and decide based on actual data rather than based on an irrelevant history.
Did it in a month with this book and enthuware and I considered myself an average java developer. I put in a lot of time that month but I would say an average of 20 hr/ week. 
I looked into GraalVM when I was trying to AOT my Clojure projects, but then realised that Graal is a long way from being production ready. But other then using Graal for AOT and perhaps a faster/lighter JVM, I don't buy the use case as a universal VM, WHY on earth would I want to run my C++ or any other native code in a JVM??
Awesome!
Righ, so I don't know anything about the RHEL OpenJDK and its support model (and Red Hat are long-term, high quality contributors to OpenJDK), and I should mention that I work on OpenJDK at Oracle, but it is important to know that not all OpenJDK builds are born equal. For example, if you hit a bug in a non-Oracle build of OpenJDK (I am not sure whether this applies to all of them), you cannot file a bug against OpenJDK because we don't know how that distribution was built. The bug must be reproduced against a sanctioned build before it can be filed. Second, some JDK distributions don't even run the TCK. For example, AdoptOpenJDK does not currently run it, I don't know why (it cannot run the TCK on the OpenJ9 JDK because the TCK must be licensed for non-OpenJDK JDKs, but I believe it no longer runs the TCK even for OpenJDK builds).
&gt; If you could be fresh out of college with infinite money and were going to do open source by yourself or with a group of your clones, the calculation would not favor C++ They would pick modern and exciting languages such as Clojure, Haskell, Elixir, Rust, Swift, F#, C#, perhaps even Kotlin, and C++ when the projects demands it (e.g libraries). What the wouldn't pick is Java, I know because I was that graduate, and absolutely no one liked Java, ever.
Top 10 tech CA company - we’re switching to Java 11 runtime as we speak, compilation will follow soon
I'm sorry but, with the exception of X.0.0 and maybe X.0.1 releases, this mentality is totally wrong. Obviously with a new major release there is a general acceptance that there might be breaking changes, so it might make a rollback or forward a non-trivial change. With the exception of perhaps waiting 24-48 hours in the cases of a FUBARed build which occasionally happens; both with Spring libs and other libraries, your organization should always be working to be on the latest patch version of whatever dependencies you are on and moving to the latest minor version in a reasonable timeframe as well (again sometimes breaking changes can occur). Staying with an arbitrary version of dependencies leaves you exposed to security vulnerabilities and is frankly symptomatic of a larger problem in your organization namely a lack of maturity around dev-ops/test automation. If you feel you cannot depend upon your automated test suite to catch bugs in underlying dependencies (that affect the behavior of your applications) and failing that, because obviously no automated test suite is perfect, have the ability to quickly rollback to a previous stable build (or roll forward) then *that* is the problem you need to work on fixing. You're not reviewing the changes logs of every release of every dependent library your organization brings in, because you're not insane and don't have the 40 hours a day necessary to do that. People only review change logs/commit diffs post-hoc to determine what caused something to break or to see if a feature has been added/bug fixed that has been impacting their work. 
True, its “wow” until you take a JFR of 11 runtime and then realize you have no tool to analyze the recording on, because Oracle discontinued support of JMC as it was moved to Eclipse
JMC works fine, and Oracle developers still contribute code to it (as they do to NetBeans).
Ex-Oracle developers do so; whole team was fired. Secondly, have you had the pleasure to build you own JMC 7.x? 
Current Oracle developers, too. And, no, I haven't built JMC in the past 6 months or so.
&gt; and see what their actual impact is Sure, that's my recommended strategy, too. And so far upgrading after 8 has been quite a different experience than "they are closer to [old update releases]" would suggest (with the exception of 10). Esp. the removal of the EE modules was tough (JAXB, the half-baked transaction module, @Generated, etc.). I'm still optimistic that things will get smoother going forward, assuming we're right now seeing the removal of some cruft (which is good) and this will be done at some point. I'm just a bit allergic to the suggestion that upgrading from 8 to 9 to 10 to 11 is a complete walk in the park :) 
JDK 9 was very much a major release (and the last of those), so upgrading from 8 to 9+ certainly may require work.
I would disagree. With JPA you develop 1 layer less, you don't need query to object mapping layer. You basically avoid writing persistence layer, which is already written for you. I'm not a fan of JPA, specially when it comes to its limitations regarding performance, but it helps a lot to code less.
If anything, the development of Guava and everything that has been written in Java are endorsements of Java.
Lot of stuff is not ready for java 11; OP, if you’re looking for simple stuff and sound tutorials then go with 8. Once you feel comfy, switch to 11. Honestly the only tangible advantage for beginners is var
You seem to insist on layers. Not every application needs all those layers you probably have in mind. Sometimes, just querying the data and transforming the output into whatever format directly is going the best solution, and most certainly the fastest one to implement.
Thanks for this tip I have been considering doing more writing on my medium.com profile but I wasn't sure if that was something worth focusing on.
Also where are you getting that the 2.1.x build is broken? 2.1.2 was released three days ago, there are no blocker issues in their github, and nothing in the twitter feeds for all the prominent spring boot committers; Phil Webb, Andy Wilkinson, Stephan Nicoll would suggest there is any major issue with 2.1.2. I guess the most recent commit build failed, but like, that means literally nothing about the stability of the most recent release. 
8u191: Only contains security fixes 8u192: Contains both security fixes and general bug fixes Odd number = security only Even number = security + bug fixes Generally you'd always want the even numbered version.
OCA Java SE 8 Programmer I Exam Guide (Exams 1Z0-808) Book by Bert Bates and Kathy Sierra Probably the only book you need. As others said you need more time to be ready to take the exam.
good core java, in particular collections. Would be nice to be familiar with streams API. Spring boot is a nice bonus. And some sql basics. Shall be enough for junior position, given that analytical skills are good.
Thank you for agreeing that C++ is a domain-specific language. I love anecdotal evidence. I knew a guy who got AIDS from C++
I would definitely put it above getting a Java cert. I'm certain there are fabulous Java engineers out there that have a Java cert, but I know quite a number of really great java engineers/software developers and I doubt any of them have a Java cert and if they do, I'm willing to bet none of them would say it was worth the price/time. It isn't to say that java certs are bad, but that there is A LOT more to being a good software developer than what can be tested. Ok so you can write a binary search, does that tell you when it should be implemented? Does that tell you what libraries might already have a binary search implemented? Writing blog articles has always been very helpful to me for learning because I always have to do a lot of research to make sure not only what I am saying is correct, but also a reasonable way of doing things. However I just want you to keep in mind don't feel like you have to throw out X number of articles or something. I know a lot of excellent developers who either don't blog, or only rarely blog (or blog only in exclusive relation to their job). So if you only write one or two blog articles this year that totally fine. Also being a good/great blogger is somewhat orthogonal to being a good/great developer. There are certainly some skills that can transfer; communication, research, secondary skills needed to demonstrate the main thesis of your article (e.g. I want to make this code available, alright, guess I need to learn git so I can upload to github), but if you find blogging difficult/unrewarding *that doesn't have any relationship to your potential as a developer*. 
&gt; How much money do you save per device by giving them ultra shitty specs? Real life example from a previous job a couple of years ago: We were stuck with a Cortex-M0 with just 16 kB of ram. That was the largest M0 the manufacturer had and going to M3 or M4 would have increased the module cost enough that our customers would have selected our competitors’ modules instead. There are many many applications where literally a 20 cent parts cost difference can make or break a product.
Yes, cost is everything. Are you saying that economies of scale in the general case are overcome by the cost savings of uncommonly shitty specs? Or that ultra shitty spec devices outnumber very shitty spec ones?
How is this different than a Java Properties file?
If I remember right, oracle's recommendation is that everyone should use u191 unless they specifically need u192 for one of its fixes
I guess it could be useful in polyglot projects (your environment config look the same in ruby, python, java, whatever)
When it comes to appliances and particularly to third party submodules in them, "ultra shitty" spec ones dominate. RAM uses up a lot of die area and in many cases the job simply doesn't inherently need much ram - unless you try to do it in a language that has 100x higher memory requirements than C or C++. Think something like the timer in a typical cheap microwave oven or the IC that controls the wipers of your car.
This is the only correct answer.
That may still be true, but as I said before, the industry has been moving away from dumb devices.
I wouldn't call a module incorporating Bluetooth stack and user scripting particularly "dumb".
I hear you - thanks for good response. I guess need to become architect or CTO then ;) [https://www.samuelthomasdavies.com/book-summaries/self-help/the-success-principles/](https://www.samuelthomasdavies.com/book-summaries/self-help/the-success-principles/) &amp;#x200B; Stay happy. &amp;#x200B; &amp;#x200B;
Yeah, all of that stuff worries me. I’ve been a Java programmer since the 1.1 days and this is the first time I’ve been worried about recommending Java for a project. The fragmentation caused by this decision is mind boggling.
Neither would I. But how many devices can support BT but not Java ME? I really just don't buy it
According to [this page](https://www.infoq.com/news/2014/10/java-me-8.1-256kb-ram) , Java ME requires 256 kB RAM. In embedded world that's definitely a large system (just below actual application processors running a real OS). Compare to the 16 kB required for the Bluetooth stack + simple onboard application. A more relevant question is _why would you want to run Java in the first place_? What does Java bring that justifies increasing the memory requirements between 2x to 20x (and increasing cost significantly) on a device where going to full fledged application processor is not justified? If the device does something extremely simple (garage door opener, microwave oven timer), you have no need for dynamic memory allocation at all and C/C++ memory unsafety is a non-issue. If it needs to do realtime stuff with tight timing requirements, you're again forced to use C/C++. That just doesn't leave much room unless you're talking about devices that are really just computers in a custom case.
I'm not sure I'd call it fragmentation, but here are the reasons as I see it: As of JDK 11, the JDK is now, for the first time, completely open source -- this is what the community wanted. However, as a result of open sourcing the entire JDK and because -- unlike MS with .NET, Apple with Swift and Google with Android -- Oracle doesn't control an ecosystem around the platform that makes it billions, Oracle had to find some other way to fund its development of Java. The combination of the two led to both the ability and the motivation for others to provide OpenJDK builds. I don't think that the faster release cadence is related to this in any way, but it, too, was what the community wanted in order to make Java even more competitive.
(it's not)
I totally get you. From all of the replies it seems that in general doing projects and more tangible work seems to definitely outweigh certs. To be honest that almost annoys me, because all I hear from my parents is how much I need to have a degree yet it's becoming almost worthless these days, so of course a certification, which is basically just another test score, wouldn't count for shit. But at least on the bright side I can always be improving my portfolio just by working on things that interest me. Thanks for the thought out replies
I mean, wikipedia says CLDC designed for [160KB+](https://en.wikipedia.org/wiki/Connected_Limited_Device_Configuration), Embedded Java minimum ["less than 2KB"](https://en.wikipedia.org/wiki/Embedded_Java). Maybe it's wrong. Just saying that it would be reasonable to use Java for a new garage door opener (imagine one that was controlled wirelessly by an app on your phone). Yeah, maybe you would lose a few cents per device. But you might save on development costs by only dealing with Java and Objective-C (Android and iOS) and not also C++. Could be $400,000 a year in highly skilled labor costs. It's not always as simple as buying the cheapest possible shit
I think I'll definitely get it at some point. Like if I find some Java developer jobs that I actually want to go for, maybe I'll take the associates test and study up for it just to keep myself sharp for interviews and more obscure concepts that they may ask about. Thanks for your input
Thanks for all of the replies, this information was very helpful even though I didn't feel the need to reply to everyone I appreciate all input. Cheers
The short answer, as already stated, is that it’s not. The longer answer is that it’s slightly easier to use in the simplest case compared to something like commons configuration when reading props files. I can also see a potential gain by having a standard naming convention (.env vs xyz.properties) that gives a better cue that this is a file that should not be committed. Dotenv has also been ported to a load of other languages so it may be more familiar to those who are just coming to java. It also bridges the gap between loading a props file and also reading in system envars. At the end of the day I’ll likely just continue using props files because that’s well understood by java programmers, but I like that there are options. 
I would say it's worth it to get your college degree. Not so much as it relates to your career (though it does help), but you'll probably look back years from now and be happier that graduated college than if you didn't. Obviously though that is a personal decision. Also one thing I would recommend is participating in the developer community in your area. There are probably developer meetups in your area. Along with helping to keep current with current trends in tech, more importantly it will help expand your network, which can lead to learning and career opportunities, as well as of course friendships. 
Are you asking to understand the language or pass an exam?
Definitely makes sense, thanks. :). The BIRT reports will be straight SQL of course. I'll look at Hibernate and JDBC for accessing data. I won't need to paginate anything really, maybe "users" and things like that in the admin page etc. But since that won't be very large, I'll just pass a JSON object via AJAX to fetch the users, and paginate from m memory, as an example. Anything requiring datatables etc., I'll just throw into a report.
It looks like in your [submission](https://www.reddit.com/r/java/comments/ag3g1q/spring_boot_help_me/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Use of dotenv is convenient when following the 12-factor-app methodology in that it promotes tenant III; "Config: Store config in the environment" The methodology is typical in cloud native environments, Kubernetes, and its ilk
For those who are unfamiliar: [12-Factor App, Config](https://12factor.net/config) Which I think is a good goal. Frequently this is brought up as something that dotenv easily solves (versus setting up envars in e.g. bash_profile), but I've always found that somewhat questionable. So my honest question to you is: what is the actual difference in storing configurations in a *file* that is read into envars, versus reading in a configuration file into the application? Both can be located outside of the classpath or in another portion of the file tree. Both are files that can be put in e.g. .gitignore. My take has been that dotenv is kind of cheating on that and ignoring the spirit of 12-factor, specifically, &gt; "The twelve-factor app stores config in *environment variables* (often shortened to env vars or env). Env vars are easy to change between deploys without changing any code; *unlike config files*, there is little chance of them being checked into the code repo accidentally; and unlike custom config files, or other config mechanisms such as Java System Properties, they are a language- and OS-agnostic standard." (emphasis mine) Granted, the 12FA calls out props files specifically, but for a tangential reason (language independence). Using a .env file versus xyz.properties just seems like window-dressing to me. With all of this being said, I will admit that I regularly use dotenv in my frontend javascript projects, so I don't wish to sound like I'm coming down against it. 
What do you mean stuff isn't ready? It's not backwards incompatible as far as a novice is concerned.
It's always good that there are options, but whenever I see a library I evaluate it from the perspective of what problem is it solving. If there isn't a convincing case or it's already solved by something considered "standard" and understood by other Java developers, I doubt I will ever use it, especially in my day to day work.
The configuration should be set in the environment. In production, one will likely never encounter a .env file. dotenv is super useful in e.g a local development environment. It enables a developer to manage the environment via a file which is more convenient. dotenv would be cheating if it were used in a e.g. production environment . This type of usage, however is an anti-pattern.
Thanks! One thing I *rarely* see is a warning not to use dotenv in production, only in dev, which I think should kind of be noted front-and-center for folks who are wandering into this process on their own.
Install Java 11 On Windows https://java.tutorials24x7.com/blog/how-to-install-java-11-on-windows
I've used it successfully on more than one project but mainly use Eclipse. I really don't get why those who hype IntelliJ do so. Perhaps they never got to the grok point with Eclipse.
Just generate the getters and setters. It’s a couple keystrokes and it doesn’t require all of my dev shop to download a plugin so the “red squiggly lines” go away. Here some solid Java logic boolean pluginRequired = true; while(pluginRequired) { alwaysExplainWhyToPeole(“But it sounds cool.”); terribleCodePracticeContinues(); forceSelfToBelievePositiveIntentions(); } Method definition you can infer like the getters and setters via Lombok.
I actually made a couple posts asking how to find a decent community in my area, and I have spent multiple hours looking to find some meetups but it's harder than I realized. Do you have any suggestions on how to find these kind of groups? 
You can't upgrade to 2.1 if relying on a stable release of spring cloud. They're still working through those without a release yet afaik.
Sorry I don’t do windows xD
&gt; Java certificates make me LESS likely to hire you. They are honestly correlated with being a worse developer. Even if that were true; any idiot knows correlation != causation. 
Just curious: most frameworks already have support for reading environment variables. What would this add there?
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Who cares? I like yup use what works best now, not what might someday work better. If Java somehow becomes a letter language than Kotlin, I can go back to Java. Picking a new favorite language isn't like getting married to it.
Pammy, you are one deluded individual. C++ is a general purpose mainstream systems level programming language with many modern features which are constantly evolving. Calling its a DSL which based on the evidence from this conversation you don't actually know what this means. It has gone from defending Java to calling C++ a DSL which no sane developer in the world would call C++. I think you need help, seek professional help, have a good day. 
I'd have to politely disagree. It's true Java has made some changes that make migration more involved going to JDK 9 or later with modules but this was something that has been long overdue. The more recent changes are showing continued investment and interest from Oracle. The big change is obviously the licensing of the Oracle JDK and access to free updates. The good news is that Oracle are not the only place to get these so I would expect Java usage to continue to thrive.
I have no idea.
Both
As a german, I feel the german formats are quite strange. I probably won't touch this class, not even with a ten foot pole.
&gt; It's true for new projects unburdened by legacy concerns No it's not. Just because C++ has gained popularity in a very specific domain doesn't mean it loses the rest of its capabilities. C++ is still being used to develop a huge variety of apps (desktop, low level, networking, gaming, high performance, and many others); it's not a coincidence that this so-called "domain-specific lang" is still in the top 5 and was in the top 3 for a long time. Also, legacy concerns and the permanence of Windows XP have no relation with the "C++ is a domain-specific lang" argument. You have no idea what you're talking about. Well, to be honest, it was obvious from the moment you said C++ was good for "poking hardware devices" (embedded being the ONE application where C beats C++ hands down).
There's always a balance between abstraction and ease of use on one side and the complexity and room for case-specific fine-tuning on the other. Velvetdb just offers something on the Easy side.
This seems utterly useless, when 1500 is shown as 2K instead of 1.5K. Suddenly you have a builtin formatter that will distort your numbers with no warning and no configuration of rounding methods. If you try with 1499, will it then say 1K instead of 1.499K or just return 1499 ? (since it wont be compacted by adding a . and \`K\`) &amp;#x200B;
It amazes me how these `Locale`-related blog posts always include examples for German and Italian which are only used in, well... Germany and Italy, but fail to include examples for Spanish.
Just too used to `.` as a decimal separator now :D
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
That is not it. An example: Demonstrating Compact Number Formatting on '1500': Default: 2K DE/Short: 1.500 DE/Long: 2 Tausend I am wondering what this should accomplish.
Yea, okay, that comparison is a bit odd. Though I doubt many people will care, because they usually don't have different representations right next to each other 
My point is that this doesn't accomplish anything. Its not shorter, its not consistent, and it is not what people I know would use to abbreviate numbers. Things like 2k are easily and readily understood in german, because the "kilo" suffix is an SI suffix and known.
Right, but you shouldn't be encouraging users to ignore the database internals. They should just be handling it at the SQL side during migrations and ignoring it inside the java code. That's petty much what jOOQ does you add all indexes and everything in the SQL migrations and you don't really see them in the java code.
Thanks for all the useful links. Also looking to learn and take the cert.
Why Spanish and not Chinese or Arabic?
Very cool. I like it. 
Great point. I've taken your advice and added a note about this in the [FAQ](https://github.com/cdimascio/java-dotenv/blob/master/README.md#faq)
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt;Item 1: Strive for Meaningful Local Variables Names &gt;Example 1 Wow, you mean you either make the type explicit or you make the name explicit. [Hmm...](https://www.reddit.com/r/java/comments/9ytzui/why_var_hurts_readability_not_helps_it/ea4dvpa/?st=jqxw7a0s&amp;sh=3e936c78) &gt;Item 1: Strive for Meaningful Local Variables Names &gt;Example 3 Oh, never mind. We can just give them completely generic and non descriptive variable names and then ponder as to which sub class it belongs to. (Yes in this example its declared on the right but it won't always be) &gt;In Certain Cases, Var and Implicit Type Casting May Sustain Maintainability It can go both ways. &gt;But whenvar, in combination with the called names, leads to the loss of information, then it is better to avoid the usage of var So anything but: var myObjectInstance = new MyObject(); is invalid use. Man, the usefulness of var sure it limited. Makes any sane person wonder if it was even worth adding to Java. 
We are at the moment considering different choices as well. We were using zuul v1 before, but have some problems with it. So looking into what to use instead. So far I can't find any reason to choose any spring based solution over Traefik(or Kong or [fabio](https://github.com/fabiolb/fabio)). That's just a load-balancer, it should not be too heavy and should not carry a lot of business logic and should integrate with your service discovery. All mentioned load-balancers can do that. They consume less resources and probably offer better performance. Then why should I use full-blown spring-boot application just to route the traffic really?... And when you think about maintenance: haproxy, traefik, fabio, etc. - they can be maintained by operations(if your company is lucky to have those). But spring-boot based solution? It will be maintained by developers for sure. Does not see this as advantage as well...
I appreciate that it has no dependencies. 
What do you mean ? You write your code in java. It can then be automatically translated into c and then to assembly. The translate-step is just something you put in your Makefile. The final code only includes the parts of java:s runtime which are used. It can even run eclipse which is a large application. Your java-code ends up in an .exe-file and needs no jvm.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt; // [...] UTF-8 is the default. UTF-8 is not a valid property file encoding in Java 8. That was added in... Java 10?
9 https://docs.oracle.com/javase/9/intl/internationalization-enhancements-jdk-9.htm#JSINT-GUID-974CF488-23E8-4963-A322-82006A7A14C7
it only supports Java 1.4 which is ancient, and extended support stopped in 2013. Also this requires that any libraries that are in .class have to be fully de-compiled to Java source as this is a source-to-source compiler. While its possible, even with all these restrictions that you could compile down your project via C to native code, micro-controllers have very very limited memory resources, don't expect that you'll be running Eclipse on ESP8266 any time soon. And if you think its possible, then please do compile eclipse and upload the firmware onto an ESP8266 and show me, I'd love to see that.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I did not say you can run eclipse on that cpu (wont fit in flash/ram). I just mentioned it to show that JCGO can run complex software (it is mature). I have used it to run my own java-code (no libraries) on an SAMR21D (32 K ram, 256 Kflash). Embedded code is often optimized for size. The java-code ended up occupying only 600 bytes flash. Very similar to the size when doing the same thing in C. Using Java 1.4 is much easier to use than writing embedded C-code.
Why propertyFile.appendEntry(new BasicEntry("# A new key-value pair follows")); propertyFile.appendEntry(new PropertyEntry("a new \\\nkey", "a new \\\nvalue")); instead of propertyFile.appendEntry("# A new key-value pair follows"); propertyFile.appendEntry("a new \\\nkey", "a new \\\nvalue"); ?
Thanks! 
AFAIK this only apply to resource bundles which [also can be workarounded](https://stackoverflow.com/questions/4659929/how-to-use-utf-8-in-resource-properties-with-resourcebundle)
You're welcome! BTW what do you prefer?
You're welcome! BTW what do you prefer?
I dont know, i have to try them out! 
If you will try them all you will be able to write your own report with comparizon :)
Maybe :) 
All fine and good, but why would you replace `int` with `var`?
&gt; So anything but: var myObjectInstance = new MyObject(); is invalid use. I'd say this can also hurts readability because now your eyes need to jump to the jagged right-hand side. Before you could just follow the types in line on the left side from top to bottom and you got a gist of what is happening. &gt; Makes any sane person wonder if it was even worth adding to Java. It's trendy. JavaScripters can just slap a `var` on everything and FP'ers don't have to type `BiConsumer&lt;Map&lt;String, Integer&gt;, Function&lt;Integer, String&gt;&gt;`
IMHO Spring RESTDocs is currently the best API documentation framework. It's test-driven, doesn't clutter your code and produces static, nice looking docs.
Being developer owned is the biggest reason for us to adopt. We have a centralized infra/operations team that is constantly overwhelmed and often becomes the bottleneck. Adding in a layer of routing infrastructure that our developers own allowed us to bypass that bottleneck, and then it definitely becomes an advantage that gateway is just a spring boot application.
TIL
You are right that ISO-8859-1 was the default encoding for .properties file up to Java 8, but UTF-8 was not invalid. Still you need to do some work like reading a .properties file by providing a Reader for UTF-8 to the (https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html#load-java.io.Reader-)[Properties#load] or by using a custom (http://docs.oracle.com/javase/7/docs/api/java/util/ResourceBundle.Control.html)[ResourceBundle#Control] when accessing i18n resource bundles. Since Java 9 the default is UTF-8 (as it should have been since the beginning of time). It doesn't make sense for a library that wants to provide a "saner alternative" to java.util.Properties to inherit the same insane requirements. Especially since it is still compatible, since Java &lt;9 also allowed UTF-8 encoded .properties files.
`appendEntry(Entry) expects an implementation of `Entry` which is either `BasicEntry` or `PropertyEntry`. But you are right, a convenience overload `appendEntry(String)` could be provided as an alternative way to provide a `BasicEntry`.
Nice to hear! :-) It would also be nice to know if someone is using the Apron library in some project. So if you do, please tell me.
Yes, it doesn't make sense to depend on external libraries for that small functionality. I also always dislike introducing transitive dependencies with a library when they are not really necessary.
RemindMe! 4 Hours
I will be messaging you on [**2019-01-15 23:59:31 UTC**](http://www.wolframalpha.com/input/?i=2019-01-15 23:59:31 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/java/comments/ag8nl1/26_items_for_dissecting_java_local_variable_type/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/java/comments/ag8nl1/26_items_for_dissecting_java_local_variable_type/]%0A%0ARemindMe! 4 Hours) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
Java is still free to use in production, as long as you use [OpenJDK builds](jdk.java.net). If you want to use Oracle JDK builds, then you have to purchase a license.
Here's an easy way to understand it. Use openjdk instead of Oracle's jdk. Every copy is free. If you chose to use Oracle's version, you can call an Oracle salesperson and they would be happy to calculate the amount of money you should give them. 
Plus, you will need to pay when you want extended support. They will end the free support to Java 8 and everything has to be moved to Java 11. 
Correct.
So I guess it’s all about updates and security? And if I wanted to choose the Oracle’s one, just to be sure, jdk runs only on developer’s machine, so the costumer’s would not be paying?
So: Oracle JDK = Security updates, support, paid OpenJDK = Open source, free for comm. use with no plans to make it paid Correct?
That is correct. OpenJDK will still get two quarterly updates, though. Other vendors are also offering free support. Build wise, both are identical. Oracle JDK used to contain commercial features, but those have been open sourced.
The thing is that "normal" load-balancers like Traefik/Haproxy can be owned both by operations and developers. There is not any problem for a developer to learn those things. But spring-boot application can be owned only be developers. And I see it as a disadvantage.
Alright, thank you!
No problem!
I can't speak on Oracle's behalf. I could but you would be mad at me when I was wrong. Talk to Oracle about pricing if you want to buy an Oracle product. 
I understand... thanks!
&gt;C++ is a general purpose mainstream [domain-specific] programming language This is a logical contradiction. Not sure that sane people assert contradictions
It didn't lose non-system-level capabilities absolutely but relatively. It has been left behind. I'm sure you code code a web app in Brainfuck, but sane people don't. &gt;embedded being the ONE application where C beats C++ hands down I never said it was the best in its domain.
For your development machine : * [Oracle’s JDK](https://www.oracle.com/technetwork/java/javase/downloads/jdk11-downloads-5066655.html) (commercial) – you can use this in development and testing for free, but if you use it in production you have to pay for it * [Oracle’s OpenJDK](http://jdk.java.net/11) (open source) – you can use this for free in any environment, like any open source library (From Jetbrains blog) &amp;#x200B; But I thought until now that it was still free for Desktop user. Gosh I will never undersand the new pricing system.
More clear now... thank you!
https://hackaday.com/2012/10/09/bringing-java-to-the-world-of-microcontrollers/
Almost. OpenJDK will also get security updates from the new OpenJDK Vulnerability group. Your OpenJDK provider will ship new binaries with security fixes, for as long as they choose to continue supporting it. Red Hat and AdoptOpenJDK have committed to at least four more years, Azul and Amazon will probably do the same or similar. So, the real question is which OpenJDK supplier do you want to standardise on? 
IMO, the most important value add is that it enables a convenient and consistent workflow for developers to manage environment variables in a 12-factor compatible manner. No need for bash scripts to do this. Another benefit is that it plays nicely with cloud native tooling where the 12 factor methodology resonates well. It's also been ported to most languages, hence its often familiar to folks. In my group, we have a system composed of a a couple dozen microservices. The services are written in variety of languages and frameworks. We use dotenv with all of them. I'm certainly not advocating for standarizing on it everywhere, but its been beneficial for us.
How do I choose? Amazon looks best to me (as a company, never used their software)
You should look at their roadmaps/support options and choose which one best fits your needs. Also consider what operating systems you need to run it on. Azul, for example, has packages for Windows, Mac, and Linux that are ready to use. AdoptOpenJDK will probably have similar coverage. Not sure about Amazon. Azul has a paid support option and they even post their pricing publicly (at least last time I looked at it). Amazon would provide support if you use it on AWS probably. AdoptOpenJDK may not have the ability to provide support in the way that others can, but I don't know that with any certainty. At the end of the day they should all be (roughly) the exact same JVM under the hood.
Well then... much more clear now. Thank you!
You can call `setMinimumFractionDigits(1)` to achieve that 1,500 is rendered as 1.5K. This also renders 1,000 as 1.0K, though. I wished there was a way to end up with 1.5K and 1K for these values.
Having a Spring boot based gateway offers more flexibility! For example we added a filter to read the public jwt token and see if it's valid, then generate b internal jwt for other services adding more isolation between the internet and our internal services! This flexibility cannot be done with traditional solution like nginx or traefik!
You are not sane, you keep repeating a lie that C++ is "domain specific", when its used in multiple domains, that is a real contradiction and not one you cooked up in your own head. Let me repeat it, C++ is NOT domain specific since its used in multiple domains, in fact its C++ template metaprograming can be used to create embedded or eDSL, how can a language be "Domain Specific" when it can be used to create "Domain Specific Language"? Again, repeating an ignorant lie over and over again Pammy doesn't change facts.
ok that's interesting regarding the final size output, I thought the Java to C source to source translation would produce horrible code gen, but clearly a lot of optimisations is going on. Thanks I'll have to have another closer look. I didn't find writing C for embedded bad at all, but I have to be honest Rust for embedded is a very interesting approach since its linear/affine type system maps very well to embedded electronics that are RTOS in nature and can not allow for race conditions etc. Have a look at this presentation: https://www.youtube.com/watch?v=xBRFtlT5Pfs 
swagger is very nice. Also its easily portable into many other languages.
coolio!!, maybe next release will include pretty print for date/time. =P
They will end no. It has ended already since January 2019. Java 8 oracle [builds](https://www.oracle.com/technetwork/java/javase/overview/index.html) are not longer supported. 
You are paying for Oracle's VM not the JDK. If you run Oracle's JVM in production then that costs money.
These answers here are not complete. You have more choices. First there is the adoptopenjdk project. They offer free lts versions. And there are other vendors that offer jdk builds like ret hat and amazon. But for today the easy choice is to use adoptopenjdk.
It looks like in your [submission](https://www.reddit.com/r/java/comments/agf376/maxalternating_function/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
having a bad day?
&gt; OpenJDK will also get security updates from the new OpenJDK Vulnerability group OpenJDK always gets security fixes. Where did you see any announcement about the Vulnerability group committing to *backporting* those fixes in OpenJDK?
Driving your car into a lake doesn't make it amphibious.
My Windows computer notified me that I had a Java update so I clicked on it and got this message. I think this is the first time I've ever seen a program just flat out suggest uninstalling it. Why are they taking this angle? Why would they recommend uninstalling it?
My Windows computer notified me that I had a Java update so I clicked on it and got this message. I think this is the first time I've ever seen a program just flat out suggest uninstalling it. Why are they taking this angle? Why would they recommend uninstalling it?
JavaFX 11 is effectively broken for beginners. Too hard to set up, and much buggier than Swing.
So in theory one couls still use oracles jdk 1.8.181 for free in production? If true, are the updates / support worth the money? I have never heard of exploitable security issues at jvm level..anyone have an example?
Red Hat are taking leadership of OpenJDK 8 and will be backporting any relevant security fixes from 11 to 8, as well as participating in patching any 8-only vulnerabilities.
The fact that var has so many *gotcha* conditions suggest to me that this will end in tears.
Weird. IME if a class had fields that should be ignored by the `equals` method, it probably shouldn't have an `equals` method at all.
No, how about: // PREFER MemoryCacheImageInputStream mciis = new MemoryCacheImageInputStream(...);
Figure out something you want to build and do it. I had written a server in C and decided to write it in Java back when 1.5 had just been released. AFAIK that server is still in production at a major corporation.
The difficulty for a lot of people is, they dont learn by making dumb shit like calculators all day. It's only when you take on your first few projects that you make something practical and used by someone other than you where you stop and have to think "oh fuck how do I actually make that though". So me, it's when I made minecraft plugins for servers. Bugs and code quality become very apparent when kids scream at you.
Oracle uses enterprise pricing, also known as ”how much do you have” or ”the cost is going to be juuust a hair under the cost of switching”
Oracle uses enterprise pricing, also known as ”how much do you have” or ”the cost is going to be juuust a hair under the cost of switching”
Just think of something you want to build, and use Java to build it.
what? since when ? in what universe are you living in? are you even thinking about your objects? if you have a user class, with id, email, address, name, whatever, what would make a user unique? how can you distinguish between 2 users? what would you make a primary key in the database if you'd have to persist that thing? all fields? all members? if you say yes ... jesus, please stop programming, take up farming or something.
I got a job using java :)
You can pick up a copy of *Effective Java*. It helped establish many best practices for the language and is pretty practical to boot.
Get a sample. Try to understand roughly how it works. Start making a few changes and see the results. Copy and paste snippets into you own code.
Really depends on the nature of the job you are looking for. If it is enterprise applications or something like an e-commerce back end then you are very likely to be using MVC frameworks like Spring so I would familiarize myself with that.
The hard bit for me is getting people to use my stuff. I make mostly little tools to help my day to day and nobody seems interested. I did the simplest thing : it trims everything you copy/paste because the ERP I work with doesn't... I can't imagine living without it but nobody picked it up around me... they delete extra spaces all day. I just finished an xml visualisation tool with search, hide, rename etc... it's especially made to aid working with said ERP interface files, I'm super proud but nobody seems interested although it saves me a lot of time... So I'm back to the pixel art editor my kids want... at least THEY will use it !
You've added more complexity, but have you added more security though?
I’m sorry but I laughed really hard at the ending. Thanking you for sharing haha :^)!
love this topic, as I am rekindling my passion for java programming and getting my beginner's mind to learn more about everything java and sql. I am wondering too how I get myself further into it.
I agree with the other people. Make something. Build something. Choose an application you like, and make a copy of it. And if its open source, dont look at the code while making the copy. Replicating features will teach you more if you dont know how the original was implemented. You can always go back and compare your solution to theirs, once you done. 
https://en.m.wikipedia.org/wiki/Argumentum_ad_populum
Java is a tool. No, it’s a tool set. Any programming language is a set of tools. And like all tools, you have to *do something* with them in order to actually learn. You can sit there drilling holes in the demo 2x4 at Home Depot all day, but until you actually *use* a drill to put holes in something for a purpose you won’t have a solid grasp of how to hold it, the angle, how deep to drill, etc. Same goes for Java.
It’s a subtle but important aspect that I think is often overlooked: making the leap to building things that other people will use. School projects or tinkering for yourself can teach you a lot but there’s a ceiling to break through where you need someone else to use it. Beyond pure coding there’s many dimensions to professional software around robustness and usability that always takes a back seat on your personal projects but need to be top priority when coding for others :)
Projects
&gt;The hard bit for me is getting people to use my stuff. That's not really a requirement. Often it's enough to develop something that you want to use and find useful and if it works and you get it to a proper state, you can still show it to other people. One thing that really helps to get into programming are games. While java isn't the most popular language for games, you will still find a lot of games for android written in java and then there's also minecraft. Now I don't recommend starting your own game, but maybe you find an open source game you like that you might want to improve. Or write a mod or external tool for minecraft. For example I've written a server tool to for minecraft that renders a map of the world to png files and displays them on a website. 
&gt; IMO, the most important value add is that it enables a convenient and consistent workflow for developers to manage environment variables in a 12-factor compatible manner. No need for bash scripts to do this. You're missing the point. There's nothing your app does that isn't also handled by existing frameworks. And for most devs using whatever is available in the existing framework is the most convenient and consistent way. &gt; In my group, we have a system composed of a a couple dozen microservices. The services are written in variety of languages and frameworks. That in itself is a huge problem.
Most companies, if they use java, use maven/gradle for dependency management, Spring for dependency injection, any ORM like Mybatis to converse with the database, and something like spring boot for exposing their APIs, and other tools like jenkins for continuous integration, continuous testing. Create a small project of yours to get the hang of these things and find some open source projects in Java of your choice to get practical. Best of luck!
There are few such vulnerabilities, but if they happen they are a pain in the a** because almost every library and application is vulnerable now too. Because of that, they also might be difficult to patch. And tough luck if you're stuck on an old version that doesn't get updates.
Yes, you can continue to use oracle jdk 1.8 in production. However they will end free updates soon. You can view the security issues here: https://www.cvedetails.com/vulnerability-list/vendor_id-93/product_id-19117/Oracle-JRE.html As far as I can see, there's nothing super major, but that doesn't mean that nobody finds an issue next month. 
Yup.
I've spent a lot of effort using java.lang.invoke for the last few weeks and can give you a quick rundown. The basics: 1. For many patterns it is not faster to use a MethodHandle or a VarHandle over reflection because java.lang.reflect can just use them (or equivalents) under the hood anyway. 2. For many patterns it is not faster to use MethodHandles over functional interfaces and lambda expressions. Under the hood, lambda expressions use MethodHandles internally (with LambdaMetafactory.) Moreover, interfaces give the JVM class hierarchy data allowing it to better optimise. 3. For many patterns it is not faster to use MethodHandle over generating code at runtime with a tool such as ByteBuddy. Why do they have these performance problems?: For a start, VarHandle suffers from the problem that under the hood it uses Unsafe to directly write to an offset from an object reference and Unsafe is "invisible" to the JVM and so inhibits many useful optimization. It is not necessarily faster to pass a VarHandle around over a setter closure such as `(myobj, val) -&gt; { myobj.field = val; }`. This closure may appear to be wasteful but because of a specific hack in the JVM final fields in closure anonymous classes are trusted to be better inlinable than user objects are (see https://shipilev.net/jvm-anatomy-park/17-trust-nonstatic-final-fields/ for a blog with some info on this.) Moreover, direct use of MethodHandle does not give class hierarchy data to the JVM. In particular, you should never really use `MethodHandles::exactInvoker` except as a fallback case. Because of this MethodHandles aren't really inlineable unless they are static final or bound to a callsite because they can do anything. And MethodHandles can't really be faster than just generating byte code at runtime because under the hood they JIT code after they are run enough times (before hand they use an interpreter based around the Lambda calculus.) Why these are good things: However, you don't want to wantonly jit bytecode at runtime because that wastes lots of metaspace which is hard to garbage collect. So, offering the intermediary of the MethodHandle which is jitted only some of the time if needed is important. It's quite similar to how some old FORTH systems were quite fast even though they were interpreted because they made really efficient use of the cache or how a moving garbage collector can better make use of cache. Sometimes -funroll-loops is a pessimisation and not an optimisation. And in practise the inlining problem for nonstatic final MethodHandles isn't a big deal as you can manually implement such inlining yourself with a MutableCallSite or by using/abusing the already existing JVM interface methods system. Suppose you have a callsite where you dynamically invoke MethodHandles. mymethodhandle.invokeExact(a, b, c, d); There is no reason a language implementer could not manually implement a sort of inline cache themselves with MutableCallSite (or VolatileCallSite.) MYCALLSITE_METHOD_HANDLE.invokeExact(mymethodhandle, a, b, c, d); And then in the MutableCallSite have it forward to a fallback method something like: private static final MutableCallSite MYCALLSITE = new MutableCallSite(foldArguments(exactInvoker(methodType(....)), FALLBACK_MH)); private static MethodHandle fallback(MethodHandle mh) { MYCALLSITE.setTarget(guardWithTest(EQUALS_MH.bindTo(mh), mh, foldArguments(exactInvoker(methodType(....)), FALLBACK_MH)); return mh; } That manually implements a monomorphic check. If you're lazy you can just generate a stub class that uses invokedynamic to link to the methodhandle and dispatch over interfaces. But the point is that inline caching is something you have to manually implement yourself.
Learning Java related questions should go in /r/learnjava. There, the *sidebar* (old reddit) lists: &gt; &gt;**Free Tutorials** &gt; &gt; * MOOC [Object Oriented Programming with Java](http://mooc.fi/english.html) from the University of Helsinki &gt; * [Java for Complete Beginners](https://www.udemy.com/java-tutorial) &gt; * accompanying site [CaveOfProgramming](http://caveofprogramming.com) &gt; * [Derek Banas' Java Playlist](https://www.youtube.com/playlist?list=PLE7E8B7F4856C9B19) &gt; * accompanying site [NewThinkTank](http://newthinktank.com/) As book: *Head First Java* **Removed** - please address learning related questions to /r/learnjava, programming help to /r/javahelp
Thanks for list! 
My experience with writing a plugin for Eclipse (8 years ago) were a lot better than with writing a plugin for IntelliJ (one year ago).
It's probably the only usable documentation framework nowadays. You can write actual documentation for your service with text, formatting, images and diagrams. I personally don't consider swagger as a documentation framework. It can be used to generate clients, but not for writing documentation.
and making random unrelated statements doesn't change the fact that C++ is not a DSL, and that fact that you don't even know what a DSL is, the fact that you call C++ a DSL proves that for all to see. 
&gt;However they will end free updates soon. Ok, but one can still use 1.8.181 forever for free, if they choose, in production ? You made me think it will not be free anymore
It looks like in your [submission](https://www.reddit.com/r/java/comments/agjme3/new_jdk_1102_just_released/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You can use that version for free forever, but you won't get free updates (or support).
https://en.oxforddictionaries.com/definition/analogy
Learning while doing - I learnt Java while working on a university project. Not a class, but a project funded by the university to develop some software to support teaching and research activities.
Contribute to a well-known open-source project, like something the Apache Software Foundation hosts. There are dozens (or even hundreds) of trivial or less complex bugs out there, sitting unresolved for ages, due to lack of human resources to fix them. Take care of those bugs. Your work will be appreciated, you will learn how to contribute quality code, and the software will be used.
Effective Java, Clean Code, Refactoring, Working Effectively with Legacy Code are the absolute minimum every Java (or .NET) business software developer shall read.
A Minecraft Mod
Thanks :)
One of the hardest truths (for me) is developing something no one wants -- no matter how good it is or how much you think it would improve their efficiency or quality of life -- isn't going to accomplish anything. Someone comes to me with a change request and I look at the feature and say, "this is all backwards. If we go about this in this different way it will be much easier for you and I don't mind doing a little extra work to make it *right*" and I get nowhere. They don't want a better work flow, and your suggestion makes them question whether you really understand their job (which, to be fair, is sometimes the case). Just implement the stupid change they want. The things you are proud of will almost never be things users see, and the things that make users happiest will often be full of things you aren't proud of at all.
TL;DR: Build 7 fixes 59 errors, 5 of which are critical security vulnerabilities that "may be remotely exploitable without authentication, i.e., may be exploited over a network without requiring user credentials. "
Since you're experienced with programming, I recommend Josh Bloch's Effective Java. Both the rules themselves and the explanations will teach a ton about Java language design and applying good software principles in Java. To learn their standard libraries, it really depends what they are. If they use Spring, for example, then it's worth a day to go through a SpringBoot example to see how configuration, injection, beans, and security work. That framework provides a lot of functionality. You should also pick up Maven for building it. 
I'm sure you're well aware that built-in formatters may already "distort" numbers by rounding them. This isn't a qualitative change, it's just a setting with fewer significant figures. If you want to configure the formatter I'm sure you can produce variations using the existing formatter API.
Because in Java you cannot do operator overriding. In C++ you can override operators. In Scala, operators are just methods and you can override them easily.
BigDecimal has pow() and sqrt(), at the very least, are you asking why Math.pow(bd, n) doesn't work? Just use BigDecimal's pow and sort instead. One good reason why this is the case is that doubles have a certain maximum precision in the results, and these operations have a well specified answer, generally speaking the result is the closest representable value that double is capable of. However, the BigDecimal versions could theoretically have an infinite number of decimal digits if the result happens to be irrational, such as might happen if you had code doing new BigDecimal(2).sqrt().
This. Also: I wasn't big into Java in before my job. I'd had a couple classes in highschool and college using it, but I much preferred C#, Ruby, and C++. I remember sitting there during the first week of my job and trying to remember how to add a jar to my class path in eclipse.
One answer could be: Because BD is not a magical "get out of jail free" card that gets rid of the pain and problems of binary floating point numbers. It removes the most obvious sources of problems, but the underlying theoretical defectiveness of binary floating point remains. The question is, how deep do you want to have to dig before you are confronted with the problems?
0.) Check which Java version they are using. It's probably 8 (might be 11; 7 or below is a warning sign. Very unlikely to be 9 or 10 as those are "feature releases", i.e. Technology Previews). 1.) Pick an IDE. Use whatever your colleagues are using (so they can help you while you're learning the IDE). If there's no consensus about which IDE to use, pick IntelliJ. Watch some YouTube videos about it, to learn how its projects and modules work. Do not be tempted to muddle through without an IDE. A text editor is not suitable for Java coding - VS.Code at absolute bare minimum. 2.) Buy some books. You need a copy of Effective Java (3rd Ed), and at least one other - e.g. Head First Java or Java in a Nutshell (7th Ed) 3.) The standard libraries are good, but by no means enough for a modern enterprise / professional project. You will also need to get to grips with whatever build tool (&amp; version control system) your team are using. This is likely to be Maven or Gradle (or possibly Ant, but that is antiquated now). 4.) Start by doing TDD right from the start - so learn JUnit (are they using version 4 or 5?, it makes a big difference)
It looks like in your [submission](https://www.reddit.com/r/java/comments/agksho/how_to_breaktransform_monolith_with_spring/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
ethnocentrism/jingoism 
Thanks! You actually read my mind... I just wanted to update my questions about Versions/IDEs/build tools. But yeah, it actually makes sense, I will ask them outright.
From what I can see, this is the default behaviour, rendering 1500 as 2K. I wouldn't expect it to distort the value so much, unless I have called something like `setMaximumFractionDigits(0)` as opposed to setting the minimum. I would much rather have the utility show me a more precise value if I don't tell it how precise or imprecise I want the output, than to shorten it to the shortest possible value, and distorting. I mean, look at the french and german example: FR/Short: 2 k FR/Long: 2 millier DE/Short: 1.500 DE/Long: 2 Tausend Why would one locale shorten 1500 to 2k and the other locale add a thousand separator?
I am aware of that, I just think it is too big of a distortion when this formatter has no configuration for minimum or maximum digits.
Wow!
German is also the main language in Austria and Switzerland.
They've been around for a very, very long time. I've used them for some handy hacks in the past lol.
My bug report is listed in the [Bug Fixes page](https://www.oracle.com/technetwork/java/javase/2col/11-0-2-bugfixes-5209269.html). I'm famous ;)
Got a job. I knew how to program Java in college but it wasn't until I was actually working in an enterprise environment that I realized Java is so much more than just the language. It's a platform encompassing so much more than just a few classes compiled together.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Learn different technologies. The syntax just describes a process. You can do a lot with a little syntax, you just need to know what libraries to use and how they work. 
Get a java developer job.
sqrt was introduced in Java 9 😥
wait did you write dynmap?
I remember as an 11 year old thats what got me into programming. using the bukkit api for making plugins. Now I work with finance in java and have written some amazing APIs that deal with data for derivatives. 
Ouch. That says a lot about the intellij APIs.
&gt; those are "feature releases", i.e. Technology Previews BTW, 11 is also a feature release as all future Java releases will be; Java 9 was the last (ever) major release. The difference between 11 and 10 (or 12) is that 11 is a feature released labeled as "LTS," which means that companies that, for whatever reason, don't wish to upgrade to new feature releases could buy support from Oracle, or possibly obtain paid or free support from other vendors, for JDK 11 for some years. In any event, non-LTS versions are no different in terms of the effort or care put into them than those designated LTS (it's an arbitrary designation every given every 3 years to the current feature release). They are certainly not "technology previews" and are as appropriate for use in production as LTS versions.
If you don’t mind me asking, how did you get a job in Java without knowing much Java?
If you don’t mind me asking, how did you get a job in Java without knowing much Java?
No, but something similar. It's not widely known and that was years ago, and I never bothered to update it to the more recent Minecraft versions with their new world format (and better alternatives existed). I basically took some simple library like [this](https://github.com/Hugobros3/Enklume) and convert each chunk to an image and then stack the images in the right position to display multiple chunks at the same time. Not sure if that was the exact library I used, but you just need something vary basic which allows you to query which blocks are at a specific position.
Oh man this. Prior to my current job I'd only ever done C# and ASP .Net and I had only ever written a couple simple programs in Java but errantly believed that since java looks a lot like C# syntax-wise it would be no big thing. Hah. Wrong. I knew fuck all about Eclipse, Classpaths, Jars, Wars, JSF, Hibernate, Maven, Ant, Gradle, servlet containers, beans, etc. I mean that's just my short list. So it took me the better part of like 3 months before I had even entered the realm of productive. Then a few months after that we went from JSF to Spring Boot and I had to get up to speed on that but I'm glad that's where we went because Spring Boot is an awesome framework, the build tool plugins are awesome, IDE support is first rate, their documentation is superb and the whole Spring Framework brings together all of the things in one place to let you put together solid web apps and apis. I have a fledgling side gig and I only ever used C# for my projects but after getting cozy with Spring Boot I would seriously consider doing new work in that if it was for web stuff. 
Same. Had two internships, once where I did mostly Java and one where I did mostly C# (which is incredibly similar). The rest is history.
&gt; But why is BigDecimal not supported natively for these mathematical operations like primitives? Depends on what you mean by "natively". The integral and floating point primitives are natively implemented by the processor. Many of the operations in the `Math` class are *intrinsic*, which means when the JVM compiles the Java bytecode to assembly, calls to the `Math` methods will be replaced by the equivalent processor instruction. BigDecimal is purely implemented in Java, with a completely different implementation than the primitive types, allowing for arbitrary size and precision. I think it was a later addition to the language, and since Java doesn't have operator overloading, there isn't any sugar available to turn `+` into an `add` method call.
LOL. Congrats dude！
Just migrated some old personal projects from jdk8 to jdk11 and it's smooth. And today would get to upgrade from 11.0.1 to 11.0.2. Dude you made me sad.
&gt; I would much rather have the utility show me a more precise value Dunno, seems hard to find a default number of digits that'd make commonly sense? &gt; I mean, look at the french and german example Yeah, the German one doesn't make too much sense to me, too.
I didn’t have time for that. Dove straight into a big project (in year 2001) with virtually no help except a book or two. 
By solving my own problems, Automating stuff that I need to use developing apps for my own need, that's how you make the transition, at least that's how it was for me
The main benefit of Spring Cloud Gateway is that it's relatively easy to plugin in your own "weird stuff". We used it in a project where our gateway exposed our microservice architecture to a mobile application. It had two pieces of functionality; whitelisting API calls and assembling a user context. The user context meant that the gateway would access two microservices on every call (the context was cached for performance reasons) so the called microservices would have a used context (sent as a JWT) available to them so they would not have to check what the user could access or what features were enabled for a user. For this kind of custom code Spring Cloud Gateway is really nice; it's all logic that is best expressed as code and what was also maintained by the back-end engineers. If you on the otherhand just need a reverse proxy; by all means go for Traefik. It's awesome and there is IMHO very little point in using Spring Cloud Gateway if you don't need to implement the type of stuff we had to implement.
Sorry, that's just not correct - Java 9 and 10 contained preview versions of the HTTP/2 API, and Java 12 contains a preview version of Switch Expressions. Note that "Incubator" and "Preview" have very specific meanings (&amp; are \*not\* the same as "Experimental") in this context. They contain technology which is not ready for prime time and which should not be relied upon in production. Look at the definition of the class file format version for preview features (such as switch expressions) if you don't believe me. For all practical purposes, they fill the niche of Tech Previews, they are only supported for 6 months and are not appropriate for production use, except as an emergency stop-gap measure where a feature is desperately needed and no other workaround is available. &amp;#x200B;
Every feature version can contain preview/incubating features. That 11 didn't was sheer coincidence. (I work on OpenJDK at Oracle)
[OpenJDK Release notes](https://jdk.java.net/11/release-notes)
Any feature release may contain preview/incubating/experimental features, whether or not it's tagged as LTS (which, again, is *arbitrary*). JDK 11 also contains an experimental feature -- ZGC. Non LTS versions are very much appropriate for production use -- as appropriate as LTS versions, and are not treated any differently by OpenJDK developers. Officially the difference between LTS and non-LTS is Oracle-only, and refers only to paid support. Any OpenJDK release may be supported for as long as the community is willing and able, and every OpenJDK version is only supported by Oracle developers for 6 months. It's just that other companies decided to try and contribute backports to OpenJDK only for those versions that Oracle also designates as LTS, but it's not an official policy. (I work on OpenJDK at Oracle)
I'll just leave this here: https://aws.amazon.com/corretto/
But it *does* have configuration, as has already been pointed out to you.
We use API gateways between load-balancer and services. Those do "weird stuff", jwt validation and etc. So yep, we need just reverse proxy. And Traefik is the first on the list btw :)
Right, makes sense. Yes: I agree that this is entirely the Oracle party line. One factual point, however: It is a little disingenuous to claim that Incubating and Preview mean anything close to what Experimental does. Once again, the contortions over class file formats and versioning immediately show that they are very different.
/thread
It is good to see that java swing bugs are still fixed: https://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8206392 Thumbs up!
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Probably had a job previously with development experience. I knew a woman who worked with Redis, then took a Web Development bootcamp that taught Javascript and Ruby on Rails, and afterwards got a job that used C#. As long as you understand the core principals and applications of programming, learning the syntax of a new language comes a lot easier.
Do you guys recommend to use modules in all new projects? I see that is possible to program projects without the use of the module system. I recently migrate a spring boot application and it works nicely in java 11.
I think that, to be sure that the developer knows what he's doing, it should only reduce the significant zeroes, unless a max of digits has been specified. 2000 -&gt; 2K 1500 -&gt; 1.5K 1470 -&gt; 1.47K 1475 -&gt; 1.475K or just return original 1475 since it's not shorter 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
BigDecimal is not binary floating point, but yes it still doesn't solve everything
It's not a question of a party line or not. There is just no difference between OpenJDK releases that Oracle arbitrarily designates as LTS and offers paid support for and those that it does not. It is primarily Oracle developers who develop OpenJDK (Oracle contributes ~90% of the work/funding for OpenJDK), and the releases are treated the same. Anyone is free to make their own decisions and interpret things as they see them, but it is factually false that OpenJDK versions for which Oracle offers long-term paid support are somehow intrinsically more stable or production-ready than others. As OpenJDK is developed in the open, this is easy to verify.
It's not a question of a party line. It is primarily Oracle developers who develop OpenJDK (Oracle contributes ~90% of the work/funding for OpenJDK), and the releases are treated the same. Anyone is free to make their own decisions and interpret things as they see them, but it is factually false that OpenJDK versions for which Oracle offers long-term paid support are somehow intrinsically more stable or production-ready than others. As OpenJDK is developed in the open, this is easy to verify. Furthermore, even if you decide to only use LTS releases in production, it is a very, very bad idea to ignore the other releases: 1. The entire deprecation model is built around OpenJDK releases (for which there is no such thing as "LTS"), and 2. an important reason for the new release model is to make upgrades easier by doing away with major releases and making changes more gradual; if you skip too many versions, you'll miss out on this important benefit. So whichever version you use in production, your code should be tested on the current JDK release.
Here is a longer list: &amp;#x200B; [https://aws.amazon.com/fr/corretto/](https://aws.amazon.com/fr/corretto/) [https://github.com/corretto](https://github.com/corretto) &amp;#x200B; [https://adoptopenjdk.net/](https://adoptopenjdk.net/) [https://github.com/AdoptOpenJDK](https://github.com/AdoptOpenJDK) &amp;#x200B; [https://github.com/ojdkbuild/ojdkbuild](https://github.com/ojdkbuild/ojdkbuild) &amp;#x200B; [http://www.azul.com/downloads/zulu/](http://www.azul.com/downloads/zulu/) &amp;#x200B; [https://jdk.java.net/11/](https://jdk.java.net/11/) &amp;#x200B; [https://developers.redhat.com/products/openjdk/download/](https://developers.redhat.com/products/openjdk/download/) &amp;#x200B; [https://github.com/SAP/SapMachine](https://github.com/SAP/SapMachine) &amp;#x200B; [https://bell-sw.com/java.html](https://bell-sw.com/java.html) &amp;#x200B;
I got a job in Java fresh out of college, so being strong in Java wasn't a requirement. Looking back on many years of hirings after me, it seems like having a pulse was the real requirement for fresh-out-of-college hiring, and being able to come up to speed or find a niche not doing java within a couple years was the requirement for remaining. If you've got N professional years in $NotJava, but the job you're applying to wants experience in Java, this becomes harder. What you'll want is to be able to show a competency in Java, probably through public github projects by building working, semi-professional-looking side projects, or through contributions to Java based OSS projects. So even if you don't have the required years of experience in the Java specifically, being able to show you're able to translate your years of experience in other languages to Java can help. Proving that you're motivated to learn can bridge the gap. A lot will depend on the company's hiring process and how strict they are on checking boxes on the job requirements.
I second this.
&gt; I have a fledgling side gig and I only ever used C# for my projects Is your side gig in Java or C#?
Why movie fields are public? You need encapsulation. Private fields are better.
&gt; I don't see what Java can add that Kotlin doesn't have. Java is going go get support for fibers at some point .Kotlin has its own coroutine implementation, so I don't know how those will play along together.
They are already planning to have the implementation of coroutines to be fiber based. Since the implementation of coroutines is added at compile-time, this is a non-issue.
Sounds interesting. Where can I read up more on that? Also, with true pattern matching (I assume you mean destructuring), do you have any sources I can check out?
But doing projects. Taking it from zero to hero. There's no magic bullet, no fairy sprinkle. Just plain work.
It looks like in your [submission](https://www.reddit.com/r/java/comments/agot8n/javascala_validation_library/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
https://en.m.wikipedia.org/wiki/Conventional_wisdom
Desktop link: https://en.wikipedia.org/wiki/Conventional_wisdom *** ^^/r/HelperBot_ ^^Downvote ^^to ^^remove. ^^Counter: ^^232223
**Conventional wisdom** Conventional wisdom is the body of ideas or explanations generally accepted as true by the public and/or by experts in a field. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
In high school our final project was open ended. It could be anything, and at first I was intimidated and worried because I didn't know what to do and had no guidance. So I googled a lot, and eventually settled on making a music player using the Java standard library. After reading through tens of Javadocs and method calls, everything clicked for the first time; with coding you can do anything. Libraries weren't just for boring stuff like Collections&lt;T&gt; or BigDecimal. It was for fun stuff, interesting stuff like music players, internet connections, real life web apps that look all professional and are very important. To use these api pages and libraries to do something cool -- build a music player that could load midi files, store a playlist, and skip or fast forward tracks -- I realized that I had the potential and power to do anything I wanted, all it would take is reading the same Javadocs I already knew how to read, and writing code using the lessons I had already been taught. 
Why do you need an equals method on a class like that? I could see a class generated by an ORM having an equals method based on the primary key, but 99% of the time if I had a hand-written user class, it wouldn't need an equals method because there would never be more than one instance per user. If I needed a unique identifier for users that more than just a string, I'd put the ID in something very much like a Kotlin data class: something with no hidden state, all fields final and initialized from separate constructor parameters, and equals and hashCode methods that consider all fields. As for your quip about how I should take up farming: it's pretty likely you've used code I've written. Until you can say the same thing, ditch the attitude because it just makes you look like a victim of the Dunning-Kruger effect.
[removed]
Nice one. 
Yeah, but 1.1 is almost as ancient as 1.0. I inherited a JDK 1.1 sun micro shirt and it's pretty baller
C# right now. My primary project is a middleware app I wrote as a C# service project that takes data from a teamcenter DB and maps it into some EDI database tables in SQL Server so engineers can export mfg info into an ERP system so it can be priced/sourced/built and finally sold. It's old and dumb but it runs like a champ. Right now I'm trying to convert it into a web app so I can provide my own interfaces for working with the data rather than relying on GUIs Jerry rigged on both systems. So I've been toying with ASP .net web api but I'm seriously considering starting over with Spring Boot.
Like many others wrote, I made the transition from beginner to professional with my first paid project. My advantage was that it was a student job at my university and it wasn't expected of me to know much. I liked the job, stayed with it for most of my studies and learned a ton. I'd even say I surpassed everyone else's Java skill there. I started my first actual full-time job a year ago and while my colleagues have decades of experience as software engineers (not necessarily with a focus on Java though), I'm often considered 'the Java expert'. 
Depends on if you have a need for it. I haven't yet. Basically the advantage is greater encapsulation of internal code. If you create a library and only want to expose the user facing API and not other public helper methods, this is a great tool. If you don't care... Then no big deal. I will point out that it's probably easier to adopt early in the project as opposed to later on though.
Thanks for the link.
&gt; So I've been toying with ASP .net web api but I'm seriously considering starting over with Spring Boot. What do you find that Spring Boot gives you over ASP.NET? I played around with both very slightly, and I really didn't like how slow Spring Boot took to "boot" :P (about 5-8 seconds depending on what I imported), and I felt there was a lot of magic going on. Just adding a dependency changes what the app might do.
You're right, it's not. Now, I didn't actually say that it was, but I definitely could have been clearer on that point.
What are the problems you need to solve. What needs to be accomplished to consider the initiative a success?
Just wondering, what's the difference between the closed source JavaFX and the open source implementation? 
&gt; Why do you need an equals method on a class like that? have you ever wrote code? like ... you know, ever? Used structures in your code? Like Map&lt;User,Shmoozer&gt; ? Or are you just stupid?
In Java 9 and 10? Just proprietary media stuff as far as I'm aware.
3 days?
There are actually a number of ways to approach this... So I will list a bit about me :-D * First and foremost I had several classes where we specifically used java. For example my object oriented programming 1 and 2 were both in java. My design patterns class used java and I had a hand full of other classes that used java. So that worked out to `experience`. * My internship uses Java, html, javascript. I learned a lot! I used that opportunity to work my my mentors on the internship... * After my internship I went to grad school unrelated to programming, first job was unrelated to programming * My first non school, non internship I applied for a Junior position... I was open and honest about my experience and they were fine with it. Many Junior level jobs pay as such but they are looking for candidates that they can mold... Someone that does not have a lot of bad habits built in that they have to break. * My next, current job, was actually not a programming job per say... With it I got in the door and two years later doing non programming things they came into our daily meeting and asked if anyone knew Java, HTML, CSS, javascript... Again I was open and honest about my experience. They asked me to join one of the core development teams that was behind. When that task was done they asked me to do more and more advanced things... I am still not back to my original team ;-) If you want a job doing java be willing to take a lower paying job to either gain experience OR just have your foot in the door for advancement. Also don't be a language snob... On any given day I could end up writing in or debugging in Java, HTML/CSS/javascript, actionscript, perl, python, ruby, pascal &lt;- Yes pascal..., c, c++, bash...
yeah its funny how many languages you pick up on the job too...
Martin Fowler has [an article](https://martinfowler.com/articles/break-monolith-into-microservices.html) on his blog about breaking a monolith into microservices. He has [many more articles](https://martinfowler.com/tags/microservices.html) on the topic of microservices architectures.
hm, the amount of work here looks like almost 0, mostly version bumps in a build file, and fixes in the build system for things that weren't building on other compilers.
The first tip, stay away from Martin Fowler articles. The second tip, read and consider what /u/Old_computer asked.
Modern web development sucks, that would be my first answer.
&gt; Kotlin does something everyone likes No, any language that can't get the variable/type order correct has started off on the wrong foot and it goes downhill from there.
And that's a very poor one at that. Off hand generalization meant as a what, an insult? 
Sending messages in OOP lets the objects decide how to manage their state. Calling a REST endpoint is part of OOP. The REST client has an object which proxies for the REST endpoint on the server. It's still OOP.
So first and foremost my current solution interfaces with the actual physical DB but the ERP system itself is an Oracle product that has a custom SQL interface that does a buncha data massaging before supplying a bunch of additional apps and processes that (at the time) had no interface I could hook into so I basically reverse engineered their DB driver and the import program and while that was a Herculean effort back then I've had to make almost no updates since the original version. But recently I got some Oracle support fellas to document the procedure for using a Java interface to allow me to have access and interoperability with most of the shit I reverse engineered and while there is a secondary COM interface available that I can consume from C# but it's a unreliable cluster fuck that I have no interest in trying to handle so there's that. But as far as why I like Spring Boot itself, out of the box you get embedded tomcat, in memory h2, you get JPA/Hibernate support with only a few additional dependencies and hibernate is light years more simple than Entity Framework. The test utilities are first rate and dev tools gives you auto restart and live reload for static resources. Springs documentation is superb you get solid JSON interop with Jackson. And I was actually going to list a 6 sec start up or restart time as a big plus. Before now our non embedded servlet containers would take upwards of a minute to start and or publish JSF apps. By comparison Tomcat is like light speed.
Insult? No, lol, not at all. Insult?!?! It's a statement of fact, modern web development is far too complex for what it delivers. Google modern web development sucks.
A REST endpoint needs to serialize a representation of the sub-graph of objects to some format, like JSON. It also usually needs to read some JSON and then either create or update objects. This is where you break away from being OOP, since you are opening up your data to some other systems (like a web client). The point is: your carefully designed objects are being broken open and you need some extra magic (usually some annotation processors) to decide which part of the object graph you should convert or not. These objects then are usually not able to decide how to manage their state. And objects, in general, have no idea how a caller might want it to treat state passed into it. Should it make a copy? Should it just hold a reference? What about state being returned from objects? Am I free to change that? If a `Person` object gives me a `List&lt;Person&gt; getFriends()`: Can I change that list? Should `Person` create a copy? What about he `Person` objects in that list? Can I just change those? None of those questions can be answered by looking at the interface. Especially not with Java collection classes. Here's an example of the problem: https://www.reddit.com/r/javahelp/comments/abjcvi/create_a_constructor_for_class_a_that_accepts/?st=JQEJ8WF9&amp;sh=bd092cfe The problems go deeper: Looking at an object, how do I know I can use it from multiple threads? That aspect simply can't be expressed in code. It might or might not be mentioned in the documentation. From the thousands of classes a project usually has, which of those are re-entrant? All these lead to subtle bugs that go way beyond fear of an NPE. 
Let me rephrase 'If one of these offshoots does something everyone likes... ' was more to my point.
For a domain expert who is also expected to program in Java, I think you should strive for getting really good at object-oriented analysis design. The question that will be on your mind almost always is how to express the application domain in the OO paradigm with its classes, objects, associations, e.g., inheritance. It is not always obvious how to do this well in new domains. It will take experience. Reading up on OO design will help. Good programming advice give the books *Clean Code*, by Bob Martin, and *Effective Java b*y Bloch. Familiarity with *Design Patterns* is helpful too. 
This sits on my desk at work. I read it now and again and reference it in code reviews ;)
Okay, so I know I already made a comment but I want this seen too ;) find a job with a mentor. Not just a boss and coworkers but someone that can mentor you. Listen to what they say, research what they say and ask questions. In my last job I would read nearly every line of code checked in the previous day and ask about design decisions. I still ask about design decisions from time to time to learn.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I just want to transform my project which is written in old architecture &amp; style to something more modern. This eventually will lead me to be able to add features, improve existing code, make the software for quick and responsive. &amp;#x200B; Success = Aquire knoladge on microservices world with first hand practice. Avoiding bad practices and usage of good practices to make the microservices fast and responsive (avoid the case when you wait 15 seconds for your request, which doesnt occure at the current old project). Knowladge on transferring code from ASP to Java..
&gt; stay away from Martin Fowler articles Why is that? And I answered. Thanks
Thank you, ill check them out
Agree. We used Swagger + SpringFox in our previous project and it was a mess. The amount of information you can give in these annotations is way too limiting and you can't use the same DTO's for input and output.
BigDecimal pow is limited to only Integers, which cuts out a whole subset of numbers as well, and although it does have sqrt, it's lacking root of n
That is fair, though extending the BigDecimal class to support other mathematical operations in the default Java libs would be very helpful and to some extent logical given the reason behind having them
Don't fix if it ain't broke. If your using ASP try solving your problems first with ASP or related tech. Going to java will require a rewrite, depending on the size of your code base this will likely be time consuming and introduce bugs.
&gt; Going to java will require a rewrite, depending on the size of your code base this will likely be time consuming and introduce bugs. Thats exactly what I plan to do. I wasnt asking for advice whether I should or shouldn't do this. What I do ask is, how.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
 *Oracle assigns a transaction identifier only if it needs to assign an undo segment, which implies that an INSERT, UPDATE or DELETE DML statement has been executed.* *So, read-only transactions will not have a transaction identifier assigned. For more details about the undo log, check out* [*this article*](https://vladmihalcea.com/how-does-a-relational-database-work/)*.*
This is the topic of a talk / workshop I gave at various conferences: \- Slides: [https://speakerdeck.com/olivergierke/refactoring-to-a-system-of-systems](https://speakerdeck.com/olivergierke/refactoring-to-a-system-of-systems) \- Video: [https://www.youtube.com/watch?v=VWefNT8Lb74](https://www.youtube.com/watch?v=VWefNT8Lb74&amp;t=11s) (other, longer versions also available, just search for the title) \- Sample code: [https://github.com/odrotbohm/sos](https://github.com/odrotbohm/sos) &amp;#x200B; Key points: \- Don't premature split up the system \- Make sure you have a modular structure of the codebase. Logical bounded contexts are clearly expressed in the codebase (packages, artifacts etc.) \- Make sure domain types are properly structured, you have modeled aggregates, not arbitrary nets of entities. Make sure aggregate references are represented via to-id relationships, not to-root entity. Make sure transactions do not span bounded contexts or more advanced multiple aggregates. \- Evaluate cross-bounded-context invocations and try to avoid them or refactor to event based notification (Spring application events come in handy) and event listeners (all in process). Those invocations would need to RPCish communication in a distributed system design alternative and introduce a lot of drawbacks: latency, the need to guard against the downstream system failing, more complex testing and bootstrap, limited business value add of a single system. \- Selectively externalize important events either via messaging or REST (feeds, pub-sub). &amp;#x200B; Interesting Spring technology to look at, especially if you're coming from a traditional Spring app and are not keen to introduce a lot of new technology: \- Spring application events ([docs](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#context-functionality-events)) \- Spring Data's support to publish events from aggregates ([docs](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#core.domain-events), [example](https://github.com/odrotbohm/spring-restbucks/blob/85ce832553a1e15cde6b6035d464f3e3b9601926/src/main/java/org/springsource/restbucks/order/Order.java#L101-L112)) \- Transactional event listeners (docs) \- Experimental: a registry using your transactional datastore for reliable even publication ([GitHub](https://github.com/odrotbohm/spring-domain-events)) &amp;#x200B; This stuff should already help you to get your monolith in shape so that it's suitable for split ups. More advanced tech can get useful if you're using event publishing between systems as a first class citizen, but introduce a larger footprint: \- Axon ([website](https://axoniq.io/product-overview/axon)) \- Spring Cloud Data Flow ([website](https://cloud.spring.io/spring-cloud-dataflow/)) &amp;#x200B; Further reads: \- Self-Contained Systems Architecture ([website](https://scs-architecture.org/))
Nice work! Do you have a public repo about it? 
Amazing! thank you Oliver. I'll definitely dive deep into those great links in upcoming weeks Thanks again
Following for my own interest.
Make something
download random desktop applications from google and remake the part of UI with Javafx Like makes a clone app for GitHub desktop client using JavaFX
There a books etc. And I like this guys channel. https://www.youtube.com/feed/subscriptions/UCmjXvUa36DjqCJ1zktXVbUA Short quick tutorials. 
The link just leads me to my subscriptions
If you already have a good understanding of the java language check out this book: [https://www.amazon.com/Introducing-JavaFX-Programming-Oracle-Press/dp/0071842551/ref=sr\_1\_6?ie=UTF8&amp;qid=1547727484&amp;sr=8-6&amp;keywords=javafx](https://www.amazon.com/Introducing-JavaFX-Programming-Oracle-Press/dp/0071842551/ref=sr_1_6?ie=UTF8&amp;qid=1547727484&amp;sr=8-6&amp;keywords=javafx) &amp;#x200B; &amp;#x200B;
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Sorry, fixed the link
Start your own project.
*tenet
I think the best way to learn JavaFX is to embrace it besides FXML part (FXML is my opinion; you might disagree). Really take advantage of what the library has to offer. Don't try to do things exactly like you typically done in other GUI libraries. You'll just end up with a head ache. Check out source code of projects made with JavaFX and also what libraries/frameworks are out there currently. Try to understand why such library/framework exist. You'll learn what JavaFX is missing or learn what problems others ran into. I would also highly recommend looking at the source code of such projects. Just note not all projects are coded well though so gotta watch out. One last thing I would also recommend to subscribe to subreddits that help with JavaFX such as /r/javahelp /r/javafx and try to help others with JavaFX. Typically you'll run into questions that you might not even know the best way to go about it, and you'll have to spend sometime learning or whatever to try to answer the question or help the person. It's a great way of learning imo. Or even just make posts yourself with questions. Majority of the time others will have already asked the question but down the line when you get into specifics types of problems then I would highly suggest making a post.
As mentioned before it's just a pointless insult. At least bring some arguments and point out when it was great. Word *modern* implies you had a positive experience. I'm in web dev since 2007, used to work with the following web techs: * JSP/JSF/Seam * jQuery/VanillaJS * XML/XSLT rendering * GWT/Vaadin * Backbone, Ember, Angular * Polymer/WebComponents Right now I'm on React/TypeScript (on FE side) and I am happy to use it for creating dynamic user interfaces. It's not ideal, it will be succeeded by something better AND for some projects using Vaadin or anything else is more reasonable (just matter of right choice). Any stack/ecosystem has its own issues and drawbacks. Simply saying "it sucks" means that you did not put enough effort to learn or do not have enough experience to say something meaningful.
You will want to talk to the **reddit admins** - your account is banned reddit wide.
[Mike Pfeiffer](https://twitter.com/mike_pfeiffer?lang=en) has a pretty good Pluralsight course on getting started with Spring Boot. I hadn't touched Java in over 15 years and was able to follow while picking up the new concepts.
Dope thanks, thats a good resource!
Sounds like our SAP project. The ERP world is a mess.
Maybe not perfectly fitting to your description, but I find myself often times reading articles on https://www.baeldung.com/ Everytime I visit the blog I get to learn something new about java/spring. Happy coding.
\&gt; It is a true API, not an SDK. Both API (application programming interface) and SDK ( software development kit ) have a well defined meaning. I don't understand why you need to give your own definitions. &amp;#x200B;
I'm not sure there is an elaborate definition of the difference between them. To me, the difference is in the level of encapsulation and number of flows, or fluency. &amp;#x200B; This library I call an API because it's 100% encapsulated behind Java interfaces and there are only 2 entry points (public classes that you can instantiate): LocalDocker and RemoteDocker. Everything else comes after that. &amp;#x200B; If it were an SDK, this encapsulation would be lighter and you would probably be able to instantiate a Container directly by providing all sorts of input data and "context" objects. See the other 2 implementations on the market: they are SDKs because you need to know how to configure those objects in order for them to work :) &amp;#x200B; Another example, Apache HttpClient is an SDK -- many public classes, which are the tools that you need to learn and put together yourself in order to make HTTP calls. Whereas jcabi-http ([https://http.jcabi.com/](https://http.jcabi.com/)) is an API, you don't need wire together or configure any objects -- you just need to know the entry point the entry point :) &amp;#x200B; In this blog post I illustrated the idea of docker-java-api: [https://www.amihaiemil.com/2018/03/10/java-api-for-docker.html](https://www.amihaiemil.com/2018/03/10/java-api-for-docker.html)
Learning the Java programming language is not difficult. Java and C# share a lot of similarities. The harder part is learning all the tools that come with the Java eco-system, as these are things that you will have to learn from scratch. (e.g. Maven/Gradle, Spring, JUnit, Mockito, etc)
Find an open source Java FX project and update its documentation or work on an open issue.
&gt;This library I call an API because it's 100% encapsulated behind Java interfaces and there are only 2 entry points APIs have nothing to do with Java interfaces or encapsulation or Object Orientation in general. You can have an API in C, Python, Haskell, Perl and any other programming language. It doesn't have to be OOP &amp;#x200B; &amp;#x200B;
API = Interfaces (Not necessarily OO) Library = Implementation SDK = APIs, Libraries, Tools, etc.
Doing.
I'm sorry but that's not at all what an API and SDK means.
And sdk is much more than that. Apache HC is not an sdk.
\&gt;In order for it to work, you need to have an implementation of JSON-P (JSR 374) in your classpath (it doesn't come transitively since most people are using Java EE APIs so, chances are it is already provided!). why not just change the `provided` scope in the project's pom to make sure it's included at compile time? just curious, might save somebody a little time
looks really good!. extensive test code as well. the java interfaces are pretty easy to follow, but you might want to include a quick-start type of introduction with code snippets in the README
That makes a lot of sense :) I personally don't use hibernate as I am not a fan of magic happening behind the scenes. There are some good libraries out there that allow you to write type safe SQL like syntax in Java/Kotlin (similar to SQL being generated from LINQ in .NET). The rest of the points make sense. But 6 seconds compared to less than a second with ASP.NET, Vertx and Ktor (at least on the small projects I played around with) is still something I have issues with :P
The c-code is very similar to the java-code (if you: disable reflection, threading, do not use java:s standard-library, disable GC). The biggest difference is the null-checks and range-checks. You might be able to disable that as well. That way you can use java:s great tooling and still run it on small devices. I agree that RUST seems like a really nice way for embedded development (and for most places where c/c++ is used). However it takes some time to get used to the borrow-checker... The compiler might not be available on all platforms yet. One problem with embedded c is reliability. It is very easy to make a mistake and introduce security-problems. It also lacks high-level features (many lines of code for doing very little).
I've made command line Java software, and GUI stuff with JavaFX too. For a command line program, you might accept command line arguments, which correspond to function calls. GUI stuff is event-driven, where there's an event listener (or lambda expression) on every button object, which is sort of like a replacement for command line args. You can still technically make a JavaFX program that accepts command line args, but you know what I mean. How I learned JavaFX, aside from college classes, is by making simple single-purpose programs. Don't make the program overly complicated in its idea. You want something simple to make it so you're concentrating more on learning JavaFX rather than debugging or the logic behind your program. You might even want to make a dummy program that is educational yet useless, where you play with UI elements, like text fields, labels, password fields, radio buttons and groups, panes (and different kinds, like borderpane, stackpane, etc), nested panes, image and imageview objects, buttons, sliders, filechoosers, etc. There's a program called JavaFX Scene Builder, which lets you make JavaFX GUIs graphically, but I actually make my GUIs in a regular IDE instead (IntelliJ IDEA). Some people prefer the graphical way of making them though. Some simple projects I made in JavaFX recently were a file steganography tool and a file encryption tool, both of which are on GitHub. Also wrote a 2D game engine, but it's kind of broken at the moment. Reading the source code of other people's projects can help you learn more about the thing you're trying to learn. See how other people use it to get some inspiration. Udemy courses are really good. They cost a small amount of money, but there is significantly better quality control than Youtube tutorials. But no books or video tutorials will replace learning through experience.
Regarding 8u202, AdoptOpenJDK needs to add the binary to their release for JDK. For some reason, it's missing and the only one there is the JRE. https://github.com/AdoptOpenJDK/openjdk8-binaries/releases/tag/jdk8u202-ga 
I guess people might already be using different implementations of JSON-P and it is just left to the users to include whatever/ use the one they already have instead of forcing a compile time dependency on a specific implementation.
https://spring.io/guides
Use Gluon SceneBuilder to design your GUI that will be ported to FXML on your project. There's a few good videos on YouTube for showing how to do various things. Scene builder will let you add a CSS style sheet too, as well as assign IDs to objects and define action events. 
I had the same question this morning, but didn't find much on google. But i did stumble at a interesting article: Comparing JVM performance; Zulu OpenJDK, OpenJDK, Oracle JDK, GraalVM CE https://technology.amis.nl/2018/11/23/comparing-jvm-performance-zulu-openjdk-openjdk-oracle-jdk-graalvm-ce/ But with a even more interesting comment: https://technology.amis.nl/2018/11/23/comparing-jvm-performance-zulu-openjdk-openjdk-oracle-jdk-graalvm-ce/#comment-9847 It explains the difficulty of benchmarking.
I use a mindmapping program and a PDF editing program, both freeware running on Java, on my Windows 10 work computer in my job as a file clerk/admin assistant. We do no programming/development, and use the programs as-is, rarely (if ever) updating them. Does the Java SE licensing conundrum affect us in any way? Will we have to switch to an OpenJRE build/distribution to keep from having to pay Oracle for the platform to run these programs? Will the little Java icon in the system tray remain freeware?
Step 1: Figure out which is the correct subreddit to post for help. Hint: it’s not this one. Also, You’re asking a stupidly simple question. Do you think you’re the first person who wants to learn this? It’s been asked before. Search first. If you can’t figure out how to Google, you’re going to fail. 
Go to /r/learnjava. 
What's the best way to learn anything?
I would like some stats too. Just upgraded here and everything seems fine so far. If you use Eclipse and / or Tomcat those will also need to be upgraded as well as only the latest versions run on Java 11.
anything to do with spring you have to read 50 different articles which either show you the same hello world which tells you nothing, or has 50 different ways of doing it using different annotations / classes due to old versions. Along the journey of reading said 50 articles you will probably gradually pick things up without any 1 resource being great. 
But only if I do not use @Transactional right?
Seconded. I just began an internship at a spring/java house and damn that site is packed full of useful stuff. Who is that guy/gal? 
We use jre11 on tc8.5 just fine 
Good to know. The version I was using was older.
Would be interesting to see the ZGC results on Java11.
https://i.imgur.com/FkW3zE0.jpg
This is awesome and you should definitely continue. I just want to point out something similar Spotify created https://github.com/spotify/docker-client
Yea that's been the consensus of the folks I've spoken too who've worked on ERP installs and maintenance. 
Oh yea I was looking into jOOQ a few weeks back and I thought that was really neat and I was working through a Ktor tutorial 2 days ago and that is truly cool. I love Kotlin, I fell in love with it as soon as I discovered it, it's like someone took all of my gripes about Java and the Java SE/EE frameworks and addressed them. And then did about another 30 awesome things. At my day job I've been working on this monolithic Spring Boot + Angular application and the Spring Service side is pretty much finished (or as finished as I'm gonna get for the first go around.) I'm slowly getting through Angular side now but one of the things I've planned on doing after we deploy it is going back and redoing the whole Spring Java project using Kotlin to try and show some coworkers a real application of Kotlin and the things like how much smaller the source, it's full interop with Java and all that good stuff. A sister team has incorporated Scala into one of their Spring Boot/Angular projects and I'd really like to show Kotlin vs Scala and see if I can't get someone to let me build a production app with it. It probably won't fly but I can dream lol.
Is tail recursions optimization support by java11 implementation?
those graphs are awfully labelled. luckily he explains the gist of them.
One faster. — Nigel, probably.
Tail-Call Optimisation is a misnomer. It is about semantics and not "optimising" tail calls into loops (of which this is not always an optimisation.) To answer your question Java 11 does not promise such semantics reliably. There is [Project Loom](https://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html) but I have no idea how far along it is. You are probably better off hacking it in with exceptions something like: interface TailCall&lt;T&gt; { public T doSome() throws TailCallRestart; } public TailCall&lt;T&gt; box(T value) { return () -&gt; value; } public TailCall&lt;T&gt; tailCall(Supplier&lt;T&gt; value) { boolean flag = new boolean[1]; Object[] valueBox = new Object[1]; return () -&gt; { // You might want to check stack depth here or something... if (!flag[0]) throw TailCallRestart.SINGLETON; var x = valueBox[0]; if (x != null) { return x; } x = value.get(); valueBox[0] = x; return x; }; } public &lt;T&gt; T execute(TailCall&lt;T&gt; call) { for (;;) { try { return call.doSome(); } catch (TailCallRestart r) { // nothing here deliberately, this better allows optimisations of exceptions } } } public IntTailCall fib(int n) { if (0 == n) return box(1); if (1 == n) return box(1); return tailCall(() -&gt; fib(n - 1) + fib(n - 2)); } The precise details of how to get this working fast are really, really hard though.
Very cool stuff! :)
This has been my experience as well with almost every framework that I'm trying to learn.
Or, you could just write it iteratively in the first place and save yourself all the hassle.
Hi, You may learn spring-boot with real project. — spring-boot 2.1.2 (hibernate 5.3.7) — java 11 — heroku ready (19 seconds start time) — flyway — unit + integration tests (code coverage 96%) — travis + sonarcloud integration (1 min 36 secs full build with unit tests) — facebook integration — JavaScript frontend https://github.com/javadev/pt-backend
Places I have worked typically provide Windows computers, or Mac on special request. Seems as time progresses, there's more flexibility to choose Mac in some places. I then have had access to create or run VMs that are in various flavors of Linux. I think this is because in general, you're right, mid-sized or larger corporations purchase Windows because it is more cost-effective, or easier for them to manage, or if the company is not only developers, easier to understand for less technical coworkers. And yeah - progress to newer versions of Windows is very slow.
When I started I was given a winders desktop. First thing I did was boot it up to download a linux ISO and burn a disk :) Over the last 4.5 years I have been given and returned a hand full of winders laptops. I turned my official laptop in for a MacBook pro. Because the company issued laptops, winders one, sucks our department bought us all beefed up winders boxes. I use my desktop on a daily basis. If I work from home I do so from my MacBook. The Windows machine sits on my desk still unpacked :$ My corp does not support linux and as such requires me to do whatever needs to be done. When I worked for Intel they had an official supported linux image.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
This almost certainly won’t help you because throwing an exception to manage control flow is not something the JIT likes- at all.
Why do you keep saying winders like it's a thing? 
Well you said it too so now it's a thing
Because that me ;)
Old\_Computer and Cozy are right to ask the question "why", before giving you the "how". This is a well known common pitfall that many developers succumb to.
Code snippets are in the wiki. But yes, maybe I should put them in the README too :) 
&gt; it doesn't come transitively since most people are using Java EE APIs so, chances are it is already provided! well, the explanation is just that: the JSON-P is the standard in the Java world since Java EE 7, so there are big chances that they alreade have it in the classpath. And it's easier to add it yourself if you see ClassNotFoundException, then to run mvn dependency:tree and exclude the dependencies that you already have in your project, I think -- few people pay attention to the dependency graph.
What would be an SDK from your point of view, then? I simply base my understanding on the word "Kit" == "a set of tools that you need to know and work with yourself".
I agree, I also see APIs as a "specialization" of SDKs. They are basically SDKs with simpler, intuitive and configuration free interfaces. Hence the word "Interface" -- which I know doesn't necessarily mean OOP, but I do OOP so I think it's only natural that I understand and explain the concept from that light, no? 
But the font rendering in Linux sucks and is superior in Windows because they patented it, you know that right? Oh, you don't. 
&gt; APIs have nothing to do with Java interfaces or encapsulation or fluency or Object Orientation in general. Sure it doesn't have to be OOP, it's an abstract term. I just do OOP and, from an object-oriented perspective, I believe that is the difference between API and SDK. 
I know about it. It's one of the reasons I started docker-java-api -- I tried using docker-client and had problems with it (not to mention, I didn't like its design at all). :) 
Only worked at Google for Java developer, we use linux mostly.
I understand we have different points of view, but "not at all"? Then what would be their meaning to you? :P 
Okay while you start you OS holy war and think of more words to put in my mouth I am going to do something a little more entertaining like watch the paint dry on the walls of my 4 year old house :) Someone asked my opinion, I gave it. I have no desire to debate you on your topic over something I did not say ;)
Your font rendering still sucks on your linux
Okay, I will let you know when it's never been an issue in the 20+ years that I have used it ;)
You don't know what you're missing. I use linux longer than you btw. Stop trying to be l33t. 
No. That's how Oracle transactions work. The @Transactional annotation is for redefining the transaction boundaries in the application. If you set it to \`read only=true\`, Oracle will not assign a transaction id.
In my experience, as the company got bigger, they provided more choice of platforms. For example, a small company of ~50 people forced everyone to use Windows, while a company of ~500 allowed you to choose between Mac and Windows. My current workplace (~3000 people) allows you to pick any hardware/software you are comfortable with. The is a strong majority of Linux users, followed closely by Mac, while Windows is nearly non-existent asking engineering people.
I call it winDOS
The public repository url: [https://github.com/dribbleware1/TinyFerdinand.git](https://github.com/dribbleware1/TinyFerdinand.git) To build use ant command. &amp;#x200B;
Sweet! 
Nice! 
thanks for info, I agree about the tooling, I can see some future opportunities. Regarding Rust, I would highly highly recommend it, you are correct there is a slight initial learning curve, however I believe the gains far out weigh that initial pain. What I like about Rust is that is both low level but also high level at the same time, but with all the added safety. I would say it hits the three sweet spots of performance/safety/expressiveness, as an analogy its like taking the best of C++ and Haskell with a dash of Lisp. And finally the tooling is brilliant, cargo is really cool!
My experience as a Dutch Java dev; most devs prefer Mac or Linux. Windows is like 10% tops. I don't get why you think Windows would be mandatory? Windows has zero to do with Java.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I work on a dual boot machine with Windows/Ubuntu. For some projects I feel more comfortable working with Windows simply because there are some softwares with nice working GUI that Ubuntu is missing (MobaXTerm or Docker for example). For other projects I prefer Ubuntu, maybe because there are some useful command line tools involved etc. I really have no preferences, I think we are at a point in which developing is multiplatform in general (except maybe those constrained languages and IDEs like Switft and XCode that are bound to MacOS) and I usually adapt to what is given to me for work. Also I write many documents and sheets for technical analysis and I would never give up Microsoft Office at all, I think it's still the best suite out there, more than LibreOffice and Google Web Apps.
Ownly downside, the distroless base image for java doesn‘t support java 11. It is still on java 8, so there are some container flags missing.
The implementation was graciously provided by two community members. If you're interested in contributing, please head on over to https://github.com/tipsy/javalin
Scala and Groovy support TCO via annotations, Kotlin via the tailrec keyword.
Not very big company but w can choose. Most of us run Linux.
Thank you for grabbing that for me :) 
ah didn't see the wiki, thanks
[adoptopenjdk.net](https://adoptopenjdk.net/) provides JDK and JRE builds that you can use without paying a license fee. You can download the Java 11 JDK and JRE for Linux, Windows, and Mac [here](https://github.com/AdoptOpenJDK/openjdk11-binaries/releases); scroll down for the JRE builds. Those builds include either [HotSpot](https://en.wikipedia.org/wiki/HotSpot) or [OpenJ9](https://en.wikipedia.org/wiki/OpenJ9) Java virtual machine. 
SSE, sweet!
&gt; Javalin is just a few thousand lines of code on top of Jetty, which means its performance is almost equivalent to pure Jetty. I'm not sure that's how performance works. ;) I haven't used Javalin, but I'm going to give it a try!
Linux, by far. 
Fair point, I'll replace the "which means" by "and"!
My last job used a combination of Windows and Linux. A few Macs could be found, but only in specific cases. It all depended on your project and you didn't have a say. Officially, Windows was the corporate-supported OS, so at times there was friction and incompatibilities with the corporate tools. My current job gave us our choice between Linux and Mac. Every Java dev picked Linux. Most Javascript devs picked Mac. We also have the freedom to pick our distribution. Most of us are Debian based, but as long as you're able to do your job, it's unimportant because we use Vagrant or Minikube to test locally so the runtime environment is standardized and better-mimics the dev/test/prod environments
I'm a little confused - the article implicitly says that CMS is the default GC in Java 8. It's not. The default is the Parallel collector (also known as the Throughput collector). Oh, and I'd very much like to see G1 in Java 8 vs G1 in Java 11. Here, again, the article is not exactly clear whether the G1 test was run on 8 or 11. It's a big difference because the GC team made a lot improvements to G1 in 9, 10 and 11.
This is probably at least partially due to the [JDK's Locale class](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Locale.html) providing a "useful constant for country" for [Germany](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Locale.html#GERMANY) and [Italy](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Locale.html#ITALY), but not doing so for Spain. When writing a simple demonstration in cases where representative examples are desired rather than any specific example, what's easiest to write for a quick demonstration often wins.
Seems like you are right about the CMS. My mistake. All tests were run on 8, except for ZGC. If you say it's worth trying the G1 there, I will. Regarding the command line: isn't my case exactly the purpose of this command line option to exist? We indicate that want to avoid pauses longer than this, and are even prepared to sacrifice total throughput for that. This seems to be very valid GC tuning parameter - perhaps the most valid of them all.
&gt; isn't my case exactly the purpose of this command line option to exist? It is, you're right. I trained myself not to trust any extra JVM args by default because from my experience too many people get them wrong, they get seldom updated etc. A professional deformation :)
Yep there are all kinds of fitting names.
I have never really have the chance to pick hardware... It was always choose this big screen or small screen... I went back to IT and said I work on bugs in the UI so I need a Mac book because everyone else is using Windows and Linux. I need to be able to test in the Mac browser :)
" we will share all of the interesting results, findings, and insights, along with all the anonymized raw data, afterward with the world. " That makes it worth filling out the questionnaire, you get something relevant back, this is often not the case.
Yep! [Here](https://www.jetbrains.com/research/devecosystem-2018/) are the results from last year.
&gt;APIs as a "specialization" of SDKs I'm sorry, but this is just nonsense. I think what you mean by SDK is usually referred to as a *lilbrary*. If you really wanted to work "specialization" into a phrase... you'd say something like "a library is a specialization of an API". But even then, it would be better if you didn't.
But *I'm not talking about Spain. I'm talking about Spanish*: 2nd most talked language worldwide, 4th in native speakers. It also uses different characters for thousands and decimals separator, and a different date format. Perfect for an i18n example. If you ever need to localize your app because you _actually_ have non-English-speaking users, it's waaaaay more likely they speak Spanish, or some Eastern language, rather than German or Italian. Given than Chinese and Hindi do not use the occidental character set, I'd understand picking Spanish over those for an easy to grasp example, but Italian? German? I don't get it.
You should go to /r/javahelp. But you can use for example `String.format("%1.2f", yourNumber);`
I'm in the 2% group of "I work full time on open-source code but do not get paid for it". It's not easy to gey paid for it. I wonder what the group of people who live off it do to make a decent income.
4 books for advanced Java programmers, the rest beginner material. Low quality article. I think that this time you really hit a new low.
Redhat and similar?
That is what `provided` scope is for. 
I doubt their devs are not paid. Also their case is an exception and not the rule. Very few companies get far creating open source software alone and I don't believe you can easily [replicate Redhat's succes story](https://techcrunch.com/2014/02/13/please-dont-tell-me-you-want-to-be-the-next-red-hat/).
&gt; How long have you been working in *the* IT? How long have you been working in the JetBrains?
Completely random selection of programming books.
Been a very happy JetBrains customer for over a year. Very satisfied with every product.
Here I agree. I get scared when I see in production code command lines like "-XX:MaxNewSize=32m -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly" and usually wonder how long ago was this command line drawn and whether it still works. However, MaxGCPauseMillis is of different nature and seems reasonable.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Linux or Mac almost everywhere I've worked. When you're deploying to *nix, developing in the same environment is useful. 
I get reasonably similar performance on the following benchmark: import java.util.function.IntSupplier; public class BenchmarkExceptions { @State(Scope.Thread) public static class Baseline { public IntSupplier flag = () -&gt; { return 4; }; public int a = 0; public int b = 1; } @Benchmark public int baseline(Baseline state) { if (state.flag.getAsInt() &gt; 0) { return state.a; } else { return state.b; } } @State(Scope.Thread) public static class Exceptions { public Action flag = () -&gt; { throw ControlFlow.SINGLETON; }; public int a = 0; public int b = 1; } @Benchmark public int exceptions(Exceptions state) { try { state.flag.get(); return state.a; } catch (ControlFlow e) { } return state.b; } private static interface Action { public void get() throws ControlFlow; } private static final class ControlFlow extends Throwable { public static final ControlFlow SINGLETON = new ControlFlow(); private ControlFlow() { super(null, null, false, false); } } } 
People at companies like Confluence Pivotal develop their system (Kafka and Spring, respectively) and make money providing associated consultant service. 
In France here, I see mainly Windows for workstations, Linux for servers, and some Mac in creative depts.
I think that is pretty typical in most places. 
Why would java backend demand windows? Thats probably the least likely combination. We have Mac laptops but all development is done on a shared linux box that we all VM into. 
I never have heard about development being done by a team on a shared Linux box. 
Dont forget the wrong spring in action edition
There are quite a few companies that make internal tools open-source, or hire open-source devs whose tools they use and let them continue developing. Projects like eclipse-collections, lmax disruptor come to mind
It's a private company with huge stakes in making their products look good and sought after. I wouldn't touch it with a stick.
Take your most powerful enterprise server, and repurpose it for development. Blazing fast, tons of cores, 200gb or RAM, server grade SSDs (I literally don't know the stats anymore since they upgrade it all the time), running rhel. Now everyone (about 25 devs) just VNCs into it and does all their development on it. We call our laptops our five thousand dollar email machines. Company loves it because it saves them a ton of money because we never really feel the need to upgrade our personal machines, so it prolongs refresh cycles.
May I know what kind of rendering strategy you are using first? If you are just doing some exercise project using Java AWT or Swing stuff, you would just simply detect the x, y of the ball (up, right, down, left) to see if any of them interacts with the paddles(maybe can treat as a cricle plus a rectange). &amp;#x200B; Or if you are doing serious gaming programming, you would probably introduce some physics library for detecting.
Check out /r/javahelp (and post some code!).
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
If you are that new, maybe try some of the easy/medium practice puzzles at codingame.com?
Whats that mean?
When asked about feedback of the survey, I replied: **Very good. Very long. And where is my IPAD pro?** Yes, I finished the survey, only because I love using IDEA.
Why make getters and setters for no reason? I make fields I'd like other classes to modify public, and when I wanna do a check I just right click on the field -&gt; refactor -&gt; encapsulate, now everything uses the getters/setters of that field and I can do the checking part inside them.
I had exactly the same feeling when I tried Kotlin's data classes. It's like.. the code is there, but I just can't see it!
i very much dislike IDEA, but i gave them my 2 cents. a drop in the ocean.
Just out of curiosity, what don’t you like about IDEA?
pretty much everything. the main beef is, however, with the ... marketing and the management of the product. you see, the product provides nothing over other IDEs . Said IDEs are free (beer and speech) while this one is not, all while marketing the shit out of it to make the plebs feel good for paying $100/year for it. Paying for shit is not a problem. Getting nothing for it, however, is. Personally, i view this as a scam. And before the hordes of jetbrains fanboys downvote me to oblivion: I am talking about enterprise features here. Not the community crap. That Community IDE is free, that's true. You're probably better off with VS Code with the right plugins though. Or, you know, a proper IDE like eclipse and/or netbeans.
&gt;JetBrains Surprise Gift Pack hmmm
If you are using public final fields, that's completely fine. Otherwise, letting other classes to modify other classes' fields is not acceptable and it does not follow encapsulation.
If you aren't doing any checking, then what's the benefit of having a getter/setter? I get that having them already solves the problem of having to change every single line that used the field to use the getter/setter instead, but since the IDE can do this for you in 2 clicks, what's the benefit of having a bare getter/setter that does basically what directly modifying a field does?
There's a benefit when you don't type "public final" on fields. That's all...
&gt; Here’s a plan. We’ll move these buffers off heap and make the heap smaller. We allocate them in native memory using direct byte buffers. Then we try our approaches, with one important difference. Allocation of direct byte buffers is rather expensive (among other things, it invokes System.gc()), and It's a small difference but why not have indices into one big byte[] array instead of using native buffers? You don't really have to reimplement a full malloc if you can find a safe point to invalidate all the pointers such as is common in game loops. Basically, void calculationsLoop() { for (;;) { // game loop // do stuff like int buf = alloc(); } // end of loop we can clear all the temporaries bufTop = 0; } private static int alloc(int size) { var old = bufTop; bufTop = old + size; return old; } private static int bufTop = 0; private static byte[] buf = new byte[8 * 4096]; MethodHandles.byteArrayViewVarHandle​ can make this significantly less painful.
Not really seeing a valid complaint. NetBeans IDE 8.2 Released on October 3, 2016. Enjoy riding that dinosaur. IntelliJ can't have a 25% user base majority without a minority of Eclipse(18.9%) and Netbeans(8.2%) users. 
This is impressive dude.
I use Windows most of the time, also use Ubuntu. Never play with MAC.
netbeans is 10.0 . welcome to the modern world. valid complaint? i guess it depends on the point of view. if you wanna pay to get what everyone else gets for free, sure then, by all means. 
I'm very interested in this too. I was looking at Okta and Auth0.
I have never heard of any of these.
Loved Eclipse, but changed to IntelliJ and love it.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Documentation, docstrings. and tests. Anyone that can pass our interviews (they're not grueling but require that you actually know basic coding) can learn the rest when they start. But I definitely give a leg up to anyone that shows that they follow good practices. When I look at people's githubs I don't look that closely - it's just quick glace to see how they structure their projects.
Honestly for a Junior position we don't really care about the technical skills as much as you would think. Instead I like to focus on: how well spoken is the candidate, what hobbies do they have, is it a good fit for the team, are they easy to talk to. Things like that. For the projects, we usually just want the candidate to talk about their past school projects and to show passion for programming. There is nothing much more to it.if you want me to go over your resume shoot me a PM and I can maybe give you some pointers. Good luck.
Hobbies? Like if the hobbies are programming-related? :/
Haven’t hired entry level in awhile but when I did I didn’t look for technical skills as much as communication and ability to learn. Can you describe challenges that you have overcome and can you fit well into different group dynamics. Java specific: spring boot is a great start. I would also look into different build tools like maven or gradle as well. 
They want to know if you're a 'cultural fit' i.e. do you have the same politics as them
This is all it boils down to
Cultural fit is not the same as having the same politics. At least in Finland.
Glad to hear that diversity and inclusion hasn't reached there yet
In my experience it's less that your hobbies are programming related and more that you have hobbies that you're passionate about. I think they're looking for drive and they want to see what gets YOU going. There are tons and tons of people who have programming experience but you are the best you. That's what they want to know about.
Oh it has, but I think we just think very differently about politics over here, partially, I think, because of how politically stable Finland is. This is the wrong subreddit for this though, my bad :P
i'm learning java &amp; android together. learned a lot over the past 4 months but don't think of my self mature yet. would you mind if i PM you about the idea and how/what to add in my cv to attract hiring manager? would be a huge help.
Homogenenous societies are almost by definition stable
From the list of technologies, it sounds like pretty much what you can expect from a junior candidate. Maybe you want to revisit your overall application format if it doesn't trigger interview invitations. 
Why is this even legal? It's illegal to ask about army, pregnancy, sexual preference, political views etc. but it's fine to favor applicants based on their unrelated hobbies? That sounds so random
An employer seeing if you're a well rounded person seems like a reasonable thing to me. 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
This is more or less true to some extent I believe. Too bad you're downvoted.
[removed]
I got My first programming position at Age 31 without Any projects to show but they tested me with basic problems and talked alot about me and My hobbies/life and i think they saw My passion for code and that i Would fit the team. So spot on! 
I never hired a junior, so no comments on that question. I can answer your second question though, i would look at java programs first, or at least look at them after looking at libraries. Libraries and programs are most of the time to different beasts and require a different style of programming. Libraries for example tend to be reusable and program/application usually not. Writing a good library requires more thought (and experience) than a program, and is more difficult because of that. 
I'll live
Yeah but people won't learn. Oh well
In this case, you seriously should give "Clean Code: A Handbook of Agile Software Craftsmanship" a read. This is probably the most valuable book of the list.
Swift also has structs. But like people are obsessed with as concise code as possible, they also obsess about optimization to the detriment of good design. But people are stupid. They made Array as a struct in Swift. But the bloody thing is backed with reference types. That completely destroys the purpose of a struct.. Its not immutable anymore and not thread safe. So when i program in Swift, I have to change my way of thinking. Its annoying and I don't see any benefit. 
I mean, yeah, just that he's refuting something I didn't say. Finland has in near history been significantly more politically stable and less fluctuating in stability in general. I never said USA is politically unstable (even though, currently it is *relatively* unstable if you take the last 10 years as a sample).
What everyone else said -- PLUS -- 50+ on your github page? I'm not wading through 50 projects when looking at someone's project. I would pick one, maybe two that are the your "showcases". Mention the 50, but promote the showcases.
That is the most ridiculous thing I have ever heard. Complete BS way of work. 
Eagerness. If you are eager to learn and have enthusiasm for coding I’d basically hiring you in the spot as a junior dev.
That’s very relatable to me, I’m in the middle of the same story. Very satisfying, isn’t it?
When hiring juniors I've always started with "FizzBuzz" or equivalent. For those who actually knew anything this was to make them feel good and be more relaxed during the rest of the interview (and thus perform better). I usually checked only the stuff they stated in their CV, especially if they boasted at good knowledge of given subject (I prefer honesty over "poor marketing"). The remaining parts of my interviews were less technical and more about attitude / personal traits which in my opinion matter for someone who is to become a software developer: - using common sense - approaching a problem methodically - reading and understanding spec (as simple as some ID validation algorithm from Wikipedia) - communication skills 
Not a hiring manager, but I did my share of interviews and looked at many GitHub accounts. The best kind of project is a "production ready" application. Doesn't matter what language / framework you use, but: - keep the code you're showing as clean as you can - build a CI pipeline for your repo (Travis is super simple to use and free for open source) - add a static code analysis (I recommend code climate) - write a README with building and running instructions - extra points if it's dockerized If you would come to me with this, you bet your ass the interview is just a formality. If you need any help setting this stuff up, send me a DM, I'll be happy to help
&gt; Can you describe challenges that you have overcome I was asked this in an interview and I was not expecting it at all. After this question there was complete silence for 10 seconds. No doubt I didn't receive an offer.
Depends on what you mean by entry level, if you are a university graduate I’d interview you based on basic understanding of programming and algorithms, I’d maybe ask you about a uni project, or if you’ve got an internship under your belt about what you did there and what value you provided. At entry level I’m looking for someone who understands the basics of code and problem solving, anything else is a bonus. So many grads have never done any Java, but they can be turned to the dark side if need be. I you have projects, that’s nice, I might skim one of them, I’m looking for a complete solution, a good description of what it does and if it was done for learning the Learning outcomes that were achieved, unit tests and clean code are a good thing. Demonstration of dependency injection is good too, but if I’m honest I’m not going to look into your projects I. Too much detail, I have a day job and I have 100 other candidates to sift through, you are lucky if you get a few minutes of my time to look over one of your projects at random, unless it looks really interesting. And by interesting I don’t mean you are implementing interesting algorithms or using cool frameworks, I mean it’s doing something that’s actually interesting: Did you develop a system to monitor your hydroponics system and make sure that the water had a the correct quantities of nutrients? Cool! Did you write a program to keep track of progress in a board game? Neat! Did you develop a website to allow your guests to RSVP to parties? Awesome! End to end solutions that solve actual problems, even if they don’t use cool tech are better than implementing ever sorting algorithm under the sun, they show that you are product focused and not coding for the sake of code. I can ask you in an interview why you chose library x over library y, why you structured your code the way you did, I can’t ask you why you implemented quick sort the same way everyone implements quick sort. Having a spring boot application is okay, but all that shows is that you can follow a tutorial, what the application does and how it does it is what matters. I’m going to caveat this with the fact that I’m 15 years into my career and I’ve never had a side project of any note, it’s never mattered. No one has asked me about my GitHub, they’ve asked me about stuff I’ve worked on professionally, stuff I completed and delivered, or failed to deliver (it happens) and why I failed to deliver them.
&gt;what hobbies do they have I absolutely despise this attitude. It's none of my employers business what my hobbies are.
Where r u located?
Your test is correct. Your explanation is correct only in case of this test. Nowadays, the virtual machine tries to turn string concat into string builder automatically. It just doesn't work that well in loops, because you that structure is harder to inspect. Also, you can use the built in `String.join` instead of `apache.commons.StringUtils.join` to collapse a collection. As well as `Collectors.joining`, when you already have a stream. So really, your article is quite outdated.
I'll ask candidates what hobbies they have in an interview. Honestly, I'm mostly looking that they have something they do and can be social about whatever it is and explain it. Explaining is important in what we do.
You choose what you do in your free time. The other things are considered less mutable. 
Lol, that is not at all what that's about. I can't ask about politics. I don't ask about politics, and I don't give a shit about your politics as long as you behave like a professional and keep it out of the work place. And although we try to keep it out of the workplace I can tell you 1 of my guys is apathetic, 2 are trump guys, 2 are liberal, and I'm liberal. 
So tell your future employers it's none of their business so that they can have a more realistic understanding of your personality. Maybe you'll find a match that way. Who knows? 
Look at your resume and your introductory emails. For an entry level person it's probably not your portfolio. 
I do in a nicer way. I have a pretty serious passion for building software and gaming. Most of my hobbies are just doing types of programming I suck at like trying to build a game. It's just irritating because I don't want other hobbies and they shouldn't matter if I'm lefitinately passionate about my profession. I guess shitposting on social media is a hobby, but I probably shouldn't mention that.
It doesn't matter though. If you say you like gaming that's a legitimate answer. Just be prepared to say what you play and whether it's PC or console... I have a guy who likes gaming. It's fine. It's just a question to get you talking to see whether you can have a normal conversation. 
It's more it makes me feel less than for not having interesting hobbies from most peoples' perspective. Idk it just rubs me the wrong way. Professional and personal lives should never touch imo. I recognize that's just my opinion though. &gt;whether it's PC or console This is how fights get started haha
I mean there is a huge variety of coding topics that may divert from your job tasks, if you are passionate about coding and explain them that you find joy in coding as a hobby as well, there is nothing to be ashamed of. Don't think of it as espionage if they ask you for hobbies ,I think of it as a chance to speak more freely about myself with less formal ties. It is a way to get to know a person. If you had a casual conversation with someone that could be a nice person you wanna spend more time with you would ask them what they like to do. Jobs can be very stressful it makes live and work so much more fun if you can have a laugh with colleagues and or have inspiring talks over coffee.
Communication skills - well spoken, can fit into team, confident drive/passion - projects, exploration, interest in tech breadth of tech knowledge - databases, front end, back end, aws,
You should look at it more as an opportunity to stand out. I'm in all the interviews for my team, and topics like these have the ability to really divulge into less stuffy, fun conversations. That can really make an impression. Also hobbies are much preferred to workaholics. Most of our team is into gaming and programming.
The article you linked to is factually incorrect in about 5 different ways. The biggest error, though, is assuming that it's possible to provide a meaningful performance benchmark like this. Spoiler: It isn't.
In the strict meaning: Rewriting the stack frame to replace the currently executing function with a new one (possibly the same function but with different call arguments) without growing the stack - No. At a JVM level this is because bytecode has no way to express that semantics to a JVM implementation, and in the Java language it is because when javac compiles .java files it does not elide method calls. Non-Java JVM languages (such as Scala) may have a source code compiler than can automatically detect when a recursive piece of code can be replaced by an iterative equivalent (and by doing so avoid some cases where a stack overflow would occur) but this is not the way that Java's language philosophy works. 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Dream on. About 15% of the clients I see are still on 6 or 7, and no-one I've spoken to has \*any\* post-8 Java release blessed for their production applications yet. It's also incredibly naive to think that people will upgrade their JVM every 6 months to a new major version. They just won't. Maybe you would have some uptake if 12 was called 11.1, and 13 was called 11.2, etc. Maybe. But in the calculus of most project managers, it's better to take the pain of a full retest every 3+ years than the uncertainty (&amp; perceived make-work aspect) of a new Java version every 6 months - there is just too much else to get done, and no-one trusts that things won't break on a major version update. Unfortunately for the "upgrade every 6 months" POV, the migration from 8 to 8+ is \*so\* painful (not a single one that I've seen has gone well, which is why no-one is actually prepared to trust it in production yet) that the case for the viewpoint of "LTS only, full retest every 3 years" has only been strengthened...
Use of design patterns, good overall knowledge, e.g a end to end full stack web project although it is very simple 
You are exactly the type of guy turn a simple stackoverflow answer into a book..... it’s a graduate role, a degree passion for the job is all it takes. 
Well said, good degree, 1st is a big plus, nice personality, enjoys the work. That’s it.
Getting a job is not only about the technical skills. Its also about knowing that they will want and like working with you 5 days a week. Someone with no hobbies at all says a lot about someone.
Umm ok? What’s ridiculous about it? 
While that may be impressive for hiring managers it's not what's expected. Most of my colleagues don't develop in their free time and many have only learned "proper" developing on the job. 
Sure no problem. I can look over it when I get some free time
I don't see any relation between your comment and mine. I don't know what companies will or won't do after a pretty big shift in what versions mean, but I do know these simple facts: 1. The six-monthly releases are by no means major Java versions; and there is simply no way one could compare them to major Java versions. 2. Regardless of whether you deploy on current versions or not, ignoring the feature versions is a very bad idea, even if you do a "full retest" every 3 years. 3. There is no difference in the effort or quality put into different OpenJDK versions based on whether Oracle offers LTS support for them or not. Again, I know this because my full-time job is as an OpenJDK developer.
&gt; Whether I play guitar or go skydiving has no bearing on my professional competence Except when it does. As you get more experience, the technical details become less important, and what becomes more important is working as a team with your colleagues, gaining their respect, building relationships, making friends, having something other than work to talk about at lunch/at the water cooler. Having an outdoors or physical hobby will also improve your mood and health, as will a social hobby. For example, if everyone is doing things wrong at work, and you figure it out and have the golden nugget of wisdom to solve the problem, there is a good chance people won't listen if they don't know you/like you or trust you. Just like you probably won't be prepared to listen to me, because you don't know me.
I would worry that it would led to unconscious discriminate based on race and gender because you are not a "cultural fit"
Also something to talk about when the conversation didnt stick or the candidate went into some rabbit hole with the previous question 
&gt;Having an outdoors or physical hobby will also improve your mood and health, as will a social hobby. I work out a lot I just detest every single moment of it lol &gt;As you get more experience, the technical details become less important I'm at something like a decade of experience now, and if anything the finer details become far more important as expectstions change. &gt;gaining their respect, building relationships, making friends, having something other than work to talk about at lunch/at the water cooler. My hobbies have no bearing on my interpersonal skills. I know plenty of shitty people with cool hobbies.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You seem like a fun dude at parties.
Have you considered JQuery?