&gt; I think from the point of view of having a single expected happy path of execution for a request, arguably they *are*. Sometimes you just want an immediate exit from a request when you discover an unrecoverable condition, and an exception works even from a few layers deep. This! Especially if you can pack the exception with the right information that allows the top level exception handeling system do the right thing, e.g. send a response detailing exactly what the sender did wrong in his message. Exceptions arent just a way to step out, they can be used to notify another level of abstraction that things have gone wrong and should be dealt.
&gt; where relational databases don't really map to objects at all when you get down to it. this is a sign of bad data model. like, its the number 1 sign.
Hardly. How do you model inheritance in a relational database?
How so?
I was wondering if there are any enhancements to JavaFX!!
 I have tried to force myself to use ORMs in the past and failed to stick with it. I hated the way it looked and behaved. I have used spring data sources when using spring batch, but when making a DAO I write an explicit stored procedure for the operation in need. For this, raw JDBC is all I've used. So my question is: would JdbcTemplate offer me something above and beyond a standard try-with-resources conn/callable statement/ result set loop? I read the Javadoc and nothing stood out as obviously better.
Slf4j is NOT a logging framework. From their own page: &gt;&gt; Simple Logging **Facade** for Java (SLF4J). The Simple Logging Facade for Java (SLF4J) **serves as a simple facade or abstractions** for various logging frameworks It works essentially as the wrapper you mentioned. I also allows you to use any library with dependencies to any logger and redirect to the one you are happier with. For example, if you are happier using Log4J2 as the logger for everything, even if your dependencies use other logger implementations, use [this](https://logging.apache.org/log4j/2.0/log4j-slf4j-impl/index.html).
Check the Object-Relational Structural Patterns [here](https://www.martinfowler.com/eaaCatalog/index.html). Specifically, [Single Table Inheritance](https://www.martinfowler.com/eaaCatalog/singleTableInheritance.html), [Class Table Inheritance](https://www.martinfowler.com/eaaCatalog/classTableInheritance.html), [Concrete Table Inheritance](https://www.martinfowler.com/eaaCatalog/concreteTableInheritance.html), and [Inheritance Mappers](https://www.martinfowler.com/eaaCatalog/inheritanceMappers.html). 
&gt; How is this a hibernate problem though? Once you reach a certain complexity in your data model you will only ever want to fetch the parts you need. The bit of the code that fetches the data always has to know how it will be used. "How it will be used" should be reflected in its type. Consider in GraphQL, for example, you define a very specific projection of your data, and it comes back as a type that precisely contains what you asked for. There's no such thing as "lazily loaded relationships". Either you know what you want, or you don't have it. This is how it's Hibernate's fault, because it tries to be "normal in-memory objects, but with persistence", but then those objects behave nothing like normal in-memory objects, and instead you have stones waiting to turn your cart at every turn. The "you have to know how it'll be used" part doesn't stand to scrutiny when you pass data from one layer to another. Again, the only correct way to "know" is if the type reflects it. If the type says "I have these relationships", then you can't blame the object that sees this type might decide to reach into those relationships. And if you have to know the *implementation* of one component from another component, then the leaky abstraction of Hibernate becomes the leaky abstraction of your own code. Every component has to know every other component's implementation. Doesn't sound sane.
Yes, indeed. The [JLS](http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.27.1) is a bit vague on this: &gt; It is a compile-time error if a lambda parameter has the name _ (that is, a single underscore character). &gt; &gt; *The use of the variable name _ in any context is discouraged. Future versions of the Java programming language may reserve this name as a keyword and/or give it special semantics.*
Corba, swing, javafx, crypto... probably I have never use classes from these modules while programming server side.
You can surely use JPA and Hibernate for high-performance data access. Check out these [14 High-Performance Java Persistence Tips](https://vladmihalcea.com/2016/06/28/14-high-performance-java-persistence-tips/). Also, this [High-Performance Hibernate](https://vimeo.com/190275665) presentation from JavaZone offers a very interesting insights as well: - automatic batch updates - database connection monitoring - [how you can prevent lost updates across multiple web requests](https://vladmihalcea.com/2014/09/22/preventing-lost-updates-in-long-conversations/) - strongly consistent caching which is ideal for Master nodes in a typical Master-Slave replication scheme - and more
I write all my 'entities' using immutables.io, where every single field is mandatory and the builder will fail with a useful error if anything is missing. If I need a different projection, that's a new entity. It's impossible for any of my code to be passed an entity with missing info, guaranteed by the builder and the type system. 
Wtf are you even talking about. You make 0 sense
Most newer projects I've worked on don't use any Java based templating at all. Pure HTML/CSS/Javascript front end invoking RESTful web services written in Java. Total separation between the front end code and the server side code.
Glad you like it :) Yeah, I've been to 9 in one month, so I've met many different recruiters. Some of them liked to dig deep into the subject until I couldn't answer. For example, on the interview for my current job, after several easy / moderate questions on databases / hibernate I was asked about more db admin-ish stuff like details of troubleshooting performance problem after db migration.
It's still an external dependency. Why is that difficult to understand?
JMustache
&gt; What’s new in Java 8 / Java 7? What’s coming in Java 9? I actually like questions like that since this shows how much "reading" they are doing. It is like reading newspaper for politics, stay up to date
http://stackoverflow.com/questions/1619662/how-can-i-get-the-latest-jre-jdk-as-a-zip-file-rather-than-exe-or-msi-installe
When I give an interview, I like to start with basic discussion that cover conceptual understanding and then i sort of level up the interview as high as the person will go. I sometimes go way passed what I consider a pass, just to see how far knowledge goes. I usually don't like asking direct questions but rather having a discussion.
&gt; Port to node+angular LOL,now I understand your first comment.
Ah, but then you accept the bit that fetches your code needs to know how it will be used and enforce this dependency through the type system. I haven't used immutables.io but for non trivial graphs/database models, doesn't this lead to a large number of duplicate entities? I suppose you could reuse entities through generics but then the complexity shifts from hibernate into your type system. Also how do you get around without optional values? A relation may not have a current address after all. Beyond that thanks for the pointer. Regardless of its use in this specific usecase immutables.io looks interesting. 
&gt; &gt; A TL;DR for this would amount to, "commenting" I think you're misunderstanding. The fact that the compiler will break things in an organized way is much better than comments.
Thanks for sharing!
They are mixed. I applied for a position with 5+ years of experience, but recruiters often start with something on junior level to ramp up the difficulty later. Also, good recruiters ask open ended questions, so you can start simple, and go deeper and deeper into the topic, and they will steer you in some direction to see how much you know.
Yeah, it's a good approach. I also did a lot of interviews myself in the past, usually in tandem with my team leader, and it often ended up in me asking 15 different questions in 30 min and him asking 1 in another 30 min and following up. I guess, we balanced ourselves out well somehow ;)
Really appreciate for the sharing this link. However, I wouldn't consider these questions rather difficult. During my several interviews on the position of "middle Java developer", I've got the vast majority of them. As the result -- 4 out 6 interviews were passed (got the job offers)
&gt; Write a code that: […] does a Fizz Buzz OTH no memory model question. I definetly remember once a question asking me to fix a broken Double-checked locking.
I don't do subtypes. A company relation and a person are two separate entities. If they have a small number of common fields (up to, say, 5 or so) I'll just duplicate them. More than that and I'll factor them out into an aggregated object. I don't really like building large object graphs with entities - that happens a layer up, in the domain model. Entities are just data. Database updates are something which require a great deal of care, and one of the things I most hate about hibernate is how it tries to make it look easy. Generally speaking, I completely avoid the load-modify-save model hibernate uses - that loop is pushed into the client. Any direct update request from the client must specify an entity version (optimistic lock) and an error is returned if it doesn't match. Retry logic is up to the client. Internal updates are under my control and therefore I know in advance what updates are possible - I'll usually write specific methods for this that take changed fields as parameters, rather than persisting an entity. Then there's no calculation to figure out what's changed. It's a small amount of up-front work for (what I believe to be) a huge improvement in clarity and simplicity. Also, a lot of the time, I'll avoid updates entirely in favour of inserts. I won't put a 'last_logged_in' field on a user that needs frequent updates; instead I'll record each login as a new row in a login history table. You'd be surprised how often you can do without updates and it fits in thematically with the idea of immutable entities. 
Those are management questions. I don't balance the budget (or get a bonus for hitting it). I don't care about your technical debt, told you it wasn't ready for production. Fizzbuzz is a waste of time, I'll review your git repo. Unfortunately management has final say on hiring.
Very cool... I've been meaning to add something like this in for our product. We currently just use a PROPERTY table to handle feature on/off situations, but that's limited so you end up with: if(property("featureName") == true &amp;&amp; user.hasGroup("X")) littered throughout your code, OR you get smart and add an abstraction where you write once and call elsewhere (this is what we do, mostly) FeatureService.isEnabled(User)... however, NONE of that handles some of the more interesting strategies, A/B testing, for example. My only concern is that your library packs everything into one. As a consumer, I'd be more interested in something that provided that stuff through a Java API. I don't care about REST or your servlet implementation -- but if I was starting an app from scratch, I'd probably use some of that. I'd consider splitting up the dependencies so you had: * ff4j-core (JavaAPIs) * ff4j-rest * ff4j-servlet * ff4j-jmx * etc...
The problem of Java language is purely syntactic, no library/code generator can fix this: Java language is pretty old and requires a update. Unfortunately ready to production Java application isn't three lines long, then in my experience an extensive use of Optional is difficult to manage. For example every Map.get method may return a value, then a coorect way to manage this maybe: &gt; Optional.ofNullable(map.get(key)) but in my opinion the code become fastly hard to read. C# has a good null-handling, if you know Java I suggest you to see Kotlin.
Please, see the **sidebar** in **/r/learnjava** - especially the **Free Resources** section for excellent free tutorials.
It's full of languages where such information is either inferred or dynamic, and we're doing just fine using them. So I don't know why when we have the chance to improve legibility here (because it's obvious with the naked eye that the "var" example is far more readable), and this syntax is *OPTIONAL*, why should we scream in opposition "no things are just fine the way they are, let's keep Java the same forever and ever"? If one personally prefers explicit types, I don't think anyone will take this away from them. And maybe in some situations writing out the type might be beneficial. **In some situations** though. The JEP is not about **forbidding** writing the type, it's about **giving us the option to choose**. So give us the option...
I've come across most of that stuff but I couldn't recall it. Unless I'm directly working on some Hibernate code, for example, the chance of me remembering the annotations are slim to none.
I'm not sure how I could have clarified it more? The taglibs part of this app are the worst to maintain by far, coming in cold. It does the same thing with way more complexity, ceremony and less type safety and readability. Maybe I'm just crazy in that I hate XSLT though, and think it is the stupidest most unreadable idea ever, and this is similar.
The library is multi-module (+ with ff4j-core there are no dependency). A capability you expect from the feature toggle is to enable/disable at runtime and the servlet is useful for that. The rest API can be used in the UI (javascript).
Google is your friend. Also youtube ;) "install java ide"
I'm doing interviews. This list has a lot of core questions for our interviews, too. I particularly find the first and last section's questions the ones with most usefulness in finding good devs...
Each type declares a default. Numerics are 0, Booleans are false, object references are null.
'God servlet' - I lol'd
I understand perfectly but I guess I can't imagine a workflow where the compiler is 'breaking things' is beneficial when a task is time sensitive. If it weren't, you wouldn't be introducing so much technical debt. Furthermore, most large code bases will have automated linters and style guide checkers which could perform this same task, but in a language agnostic way and by a tool that would actually make sense ie. why is technical debt the responsibility of your compiler? Why doesn't the VCS reject commits with 'technical debt' after warnings from linters? Nice work, glad you shared it but IMO this is definitely not the responsibility of the compiler and existing tools can be easily extended to perform this task without clobbering code with superfluous library code. This actually looks like more, unnecessary technical debt and my point remains that the title is misleading and disingenuous, particularly considering its self promotion 
The point of that being in the job description is to say "we want to hire someone who's motivated to write basic sql, and not argue or try to trick object relational mapping frameworks into our project". If you aren't willing to do this, don't apply for the job. There was a rather long and meandering article a while back on "leaky abstractions" - https://en.wikipedia.org/wiki/Leaky_abstraction With a perfect abstraction, you never ever need to know what's behind the abstraction. With a good abstraction, there might be a few leaks where someone needs to know what's going on behind the scenes, but it's minor, or rare, or it doesn't matter that much. With a bad leaky abstraction, you need to learn all of the "abstraction", plus all of what's behind the abstraction. An example of a nearly perfect abstraction is programming languages. You never need know how many registers the cpu has, or whether the cpu is implemented with xor gates or whatever. You can never know how it works and your code works great. An example of a good abstraction is garbage collection. Most of the time you don't need to know or care how it works, it just works. Sometimes there are a few leaks - where you might need to know not to write millisecond critical software with it, or you might need to change with garbage collection algorithm is used. But those are more likely to be fringe cases. An example of a poor, leaky abstraction is Hibernate. When your tasks are relatively easy you don't need to understand the database layout, how to write sql, etc. When your project becomes large, you do. Now you have to completely learn both hibernate, and the system it's supposed to be abstracting away. Now you have to learn both sql and hibernate, which brings up the question - why don't I save a ton of time and brainpower by only learning sql in the first place? An abstraction that requires you to understand the ins and outs of the layer below is usually a failure, unless that abstraction provides a different huge benefit - like being much faster to write, much more secure, much more reliable, etc. Hibernate doesn't provide any of these things, it's marginally faster for writing simple objects, but then adds in a whole lot of overhead for learning curve, complexity, poor efficiency, etc. If you became an expert at hibernate you can get it to work nearly as well as writing sql directly, but not without investing more energy and time than it would have taken to just use sql directly. Which is what makes many people - myself included - say that it's pointless to use hibernate. I see little to be gained by using hibernate vs writing sql directly, and the little there is to gain could be done with a far simpler framework (copying result sets into objects, standard for how to get the db connection).
Thanks for posting this. I'm surprised this one is still being asked a lot: What's the difference between final, finalize, and finally..
IDEA Community is great.
It is an annoying bug/change/whatever it is in Eclipse Neon (and possibly Mars?). The best workaround I've been able to find is to change the Line Wrapping Policy at the bottom from "Do Not Wrap" to "Wrap where necessary" for all options (select all -&gt; set that value: it should be 27 of 27). while still having "Never join already wrapped lines" checked.
You need to be less explicit about 'when' given that the code the compiler generates is not necessarily the code that is executed - byte-code is usually natively compiled and optimised before execution and the time that allocation occurs could be completely different, including never making it to memory at all (register operations only). Even the Field example might be optimised away from object allocation if the object identity is never observed and never escapes from the scope of the optimisation - field x might again just become some register operations or an extra slot in the stack. The most important detail is the rules of the language and the virtual machine - that you can never read a field before it's initialised (to the default which is different from an initialisation expression) or read a local variable at all until it has been assigned. Unsafe tricks can no doubt break these rules of course...
Thanks for the suggestion. It seems to be working. Strange!
I reply myself to ask OP. Is it posible to make a slf4j 1.8 backwads compatible with all this "garbage-free" api? with interface default methods this should be posible. If not, why? If not, is there a way forward that it does not involves "just replace slf4j all over the place" ? Thank you.
If you want to log without any external dependency, your only option, sadly, is JUL. Sadly because it sucks big time. So anyway you need a external dependency, and slf4j is small, does not force a backend, is well documented, is widely used and supported. 
Also: * Stuff appearing in the Thoughtworks Radar is the hype they can get more cash from. 
That's perhaps why they're called "interview" questions. that's where they really matters.
Seems like a good easy question. 
If this is your first job, they don't expect you to know anything. Knowing that you don't know anything would be a plus.
This page will walk through Spring boot getting started using maven and gradle with eclipse. Using Spring boot we can create standalone and production grade spring applications and that will be ready to run. Many spring configurations and JAR dependencies are auto configured.
Are you OP of the site? If so... Look into Google domains. For $12 a year you can have a dynamic DNS provider. You can direct your TLD or any user named sub-domain to a dynamic address. 
I will have to take a closer look at streams! 
Uh i assumed that collectors were introduced because of the Stream API? Do you use them in other contexts than that? Would be interesting to learn.
That it's nearly outdated 
Java 9 has a better API for null comparison: WOW! In your opinion the optional version is "much cleaner and better", really? import static java.util.Objects.* Student student = getStudentByIdNo(studentIdNo); if (nonNull(student)) displayStudentInfo(student); else displayStudentNotFound(); getStudentByIdNo(studentIdNo). ifPresent(this::displayStudentInfo). orElseGet(()-&gt; displayStudentNotFound()); Aside from that: "ifEmpty" doesn't exists, you need to implement a Supplier for orElseGet method. Please share your experience. Edit: see konrad's comment
[Why not file a bug?](https://bugs.eclipse.org/bugs/enter_bug.cgi)
r/javahelp 
It's to make the language less verbose and redundant. When inferring a type, the compiler doesn't imagine the type, it's right there. There are only two real reasons you have to type it every time you assign it to a variable: - The compiler is not sophisticated enough to infer it from the type you're assigning. - The type doesn't match the inferred type (i.e. you may choose a supertype or an interface). The first reason is being resolved. The second reason remains, so now you have flexibility to choose. But if you're paid by the keyboard clicks, please, you're welcome to be as redundant as you please.
Wait until you SQL "clicks" in your mind!
Your example above, skipping braces, is generally considered a bad practice. So I personally don't think that's a really fair comparison. Aside from that; you're using a utility function (nonNull) here. So basically you're replacing one API call with another one. So I think this is more a matter of familiarity than readability. I have heard the complaint about streams code being less 'readable' than nested for loops but these complaints tended to dry up when people actually started using them.
Criteria API is hardly something for Java Beginners who can't install the JDK properly.
If I'm writing a library then No. I don't want the external dependencies. 
If your method names reflect the returned type (and in most well designed code bases/libraries they will), I see no reason to not use LVTI. Kotlin has it and I never had a moment of "what's this variables type?". I completely agree with /u/CitrusMurder here, as long as the language still gives you the option of specifying the type explicity, there is no reason to not add this.
Hibernate implements JPA which is part of JEE. Also there were questions about comparing Spring beans to EJB beans. I guess, it depends on the project (or how legacy it is...) But in general, JEE is less popular in job interviews nowadays. Spring is more and more common.
Thing I hate most about thymeleaf is that you cannot have if statements outside of an HTML tag. I just want to be able to do if x do some stuff else do some different things. Instead I have to do put the if inside every div tag and then the contradiction if for the others. That and thymeleafs syntax for macros or embedded thymeleaf templates is awful
&lt;sigh&gt; read the original post. 
Why hover and wait when you could see it instantly? There will not be 5 Million lines in between. Maximum 30 or so atleast where I work (for enterprise software btw.). What do you do if no IDE is at hand. Like during a pull request review, where quick reading is key. Allignment of initialized variables isn't much help much there either. Because the method call, the type and `somethingHandleList.clear();` are the interesting parts.
Quickly tell me what type the two variables are? var readabilityBeDamnedOne = Boolean.valueOf(Boolean.TRUE.toString()); var readabilityBeDamnedTwo = Boolean.parseBoolean(Boolean.TRUE.toString()); ... not quick enough. Must be bad API design /s &amp;nbsp; Aswell in non of the initial examples the method return type are clear or reflected in the name correctly. Yet Brian Goetz uses it as a showcase for good, readability enhancing _var_ use... [C# Coding Conventions (C# Programming Guide)](https://msdn.microsoft.com/en-us/library/ff926074.aspx) &gt; - Do not use var when the type is not apparent from the right side of the assignment. &gt; - Do not rely on the variable name to specify the type of the variable. It might not be correct. 
 List&lt;User&gt; users = db.getUsers(); Where is the redundancy or verbosity **for the reader** here?
&gt; With LVTI, you now have a wrapper Boolean and might actually spot the error. With LVTI you (and the IDE checkstyle) may think boxing doesn't matter. While with boolean there you (and the IDE checkstyle) will think twice about the issue. Anyway the example was about the right side and APi design, which do not reflect the return type in a clear manner. &gt; While C# and Java are syntactically related, you shouldn't cite C# coding conventions when talking about Java (imo). Why not? I think the same conventions apply. More so than Kotlin.
Why do you want to discuss, if your opinion is set in stone already? :) My initial reply simply states: It never mattered that much to me. YMMV. With a bit of inevitable sarcasm, as always.
I don't understand this code example. What is User? Also in which package it is? What about List, no idea which package that is from. It's not like there's a single List out there. A properly written code would be this: java.util.List&lt;com.example.entities.User&gt; javaUtilList_of_comExampleEntitiesUser = db.get_javaUtilList_of_comExampleEntitiesUser(); I took the liberty to also use a more descriptive variable name, because you declare a variable just once, but then **the reader** will be confused on every next occurrence what it is, because the reader has apparently no IDE and a very constrained memory or ability to infer from conventional method and variable names. Unfortunately java.util.List and com.example.entities.User still refer types whose definition we don't see, so the reader will be confused, yet. But I've been convinced. We should remove "import" from Java. And probably move to structural types, so we can redeclare all methods we'll use inline for best clarity.
I think that's exactly what I'm criticizing. The industry has developed this fake standard that developers must meet in order to be considered "good" and we ended up with a process that is somewhat disconnected from the reality of our day to day tasks. Sometimes interviewers take advantage of the interviews, not to evaluate the interviewees, but to validate their own knowledge. If I'm interviewing someone, I'm not interested on their very specific knowledge about a language, I'm more interested in their ability to design solutions and identify the right tools for the problem. I'm more of a pseudo-code-on-the-whiteboard kind of guy. Show me how you think, not what you know. 
default implementations in interfaces offers up a lot of possibilities. Probably an underrated new feature. All the rest is great, lambdas, streams, date/time etc. I just wished they added a general "toList()" method on Streams, that's actually 99% of my cases and it feels clumsy to always write .collect(Collectors.toList())
Someone I work with swapped our json protocol with msgpack and was surprised to find json smaller (I assume it's similar to avro and protobuf but I have no experience with them). That definitely wasn't a scientific examination, but it was a real world application passing a ton of data over the wire. My guess for the savings is that if most of your numbers are whole and less than 255, json only needs a single byte. If your strings are ascii, json only needs two bytes for the quotes, not a length header which I would guess is 4 bytes in those protocols. Unrelated, but if your web server is doing compression, it seems logical that json compresses a lot more than any binary protocol.
Why do not drop Guava's Optional?
&gt; That's true, you sometimes don't use stuff people ask in interview very often or even Then we need to stop treating interviews as puzzle solving time, jump through the hoop little doggie. 
&gt; I've spent hours trying to do very simple things in Hibernate when joins are involved Have an up vote!
ifPresent returns void so it's impossible to chain method calls like this...
&gt; I'm lucky enough to work in an environment where I get to actually mash together the database and the ORM. I can manipulate the database (using views, procedures and other database tools) to extract what I need quickly and efficiently with very simple annotations and queries in JPQL. I know not everyone has the opportunity to manage how the two pieces meet up, and even I have been constrained some times by what I had put in place before (effectively legacy code). Love the phrase "mash together", it's what ORM's do, good or bad. 
&gt; this is a sign of bad data model. Wrong.
&gt; An example of a poor, leaky abstraction is Hibernate. Spot on.
&gt; as awful as Java is for templates My recommendation would be to hire a pro-Java biased developer. Edit: And stick with JSP and JSTL. JavaFaces bogs down and fights with Spring if you are using it. JSP and JSTL rock.
&gt; Is reactive programming and NIO being over hyped? Yes.
MatrixRow reads like a vector which is extracted from a row of a existing matrix, definitely don't like it, and would be misleading to most users of code. Is it necessary to specify storage order so explicitly and to suffix all identifiers? To me the new names are worse than the old names. As I see it, no need to specify F for floats as that is nearly always the case (are there fixed point or integer types?). As the storage order is the least interesting qualifier to users, I wouldn't like it as part of the main name. I think the primary name should be closest to how users would classify the mathematical and algorithmic context in common scientist language, and using conventions already commonly known. For instance, assume dense is the common case and sparse requires a particular callout. Similarly for real vs complex. Also Single vs Double for precision is well understood, though I guess for Java 32 and 64 is OK, though it is possible a few might think it refers to a fixed dimension. Programmers of mathematical methods use a number of tools and languages, so least surprise and least technical obfuscation of the core mathematical idea is desirable. For instance, DoubleMatrix, for the usual dense case, SIngleSparseComplexMatrix for a more unusual one. Nobody would be surprised or confused by these, and are close to how they would be communicated in natural language to another human. I would take Matrix64 and SparseComplexMatrix32, which likely would be understood too. I would put any further lower level qualifications of storage order in a suffix separated with and underscore, and as much as possible, have the common case not need it, and interfaces be indifferent or appropriately overloaded so the user needs to worry about it less. I am a current user of ejml, and appreciate the package though I find the Eigen (C++) API to be more ergonomic. Also looking at ND4J. Like it or not, modern Fortran (90 and later) is still far more comfortable, clear and natural for many scientists in array use.
Well I guess the first thing I do will be installing an IDE plugin that replaces or hovers all visible var's with type information during a shortcut press. For code reviews will probably become constant alt+tab between diff page and IDE...
You're not supposed to uses java.util.Optional as field type. That's why it's not Serializable. It's only supposed to be used as return type but you're not supposed to "store" it anywhere. This was a conscious decision. You might not agree with it (there are a few design decisions in Java that I don't agree with) but going against it and using it as field type will only bring you pain. java.util.Optional was designed in such a way that it might be converted to a value type in the future which should improve performance. It might become Serializable then. 
^Hi! ^Here's ^a ^summary ^of ^the ^term ^"Ad ^Hominem": ---- [^^Argumentum ^^ad ^^hominem](http://rationalwiki.org/wiki/Argumentum_ad_hominem) ^^\(from ^^the ^^Latin, ^^"to ^^the ^^person") ^^is ^^an ^^informal ^^logical ^^fallacy ^^that ^^occurs ^^when ^^someone ^^attempts ^^to ^^refute ^^an ^^argument ^^by ^^attacking ^^the ^^source ^^making ^^it ^^rather ^^than ^^the ^^argument ^^itself. ^^The ^^fallacy ^^is ^^a ^^subset ^^of ^^the [^^genetic ^^fallacy](http://rationalwiki.org/wiki/Genetic_fallacy) ^^as ^^it ^^attacks ^^the ^^source ^^of ^^the ^^argument, ^^which ^^is ^^irrelevant ^^to ^^to ^^the ^^truth ^^or ^^falsity ^^of ^^the ^^argument. ^^An ^^ad ^^hominem ^^should ^^not ^^be ^^confused ^^with ^^an ^^insult, ^^which ^^attacks ^^the ^^person ^^but ^^does ^^not ^^seek ^^to ^^rebut ^^the ^^person's ^^argument. ^^Of ^^note: ^^if ^^the ^^subject ^^of ^^discussion ^^is ^^whether ^^somebody ^^is ^^credible ^^-- ^^eg, ^^"believe ^^X ^^because ^^I ^^am ^^Y" ^^-- ^^then ^^it ^^is ^^not ^^an ^^ad ^^hominem ^^to ^^criticize ^^their ^^qualifications.
By the time 'var' becomes available, IDEs such as Eclipse and Netbeans will have support for this feature, so why do you need to install a plugin unless you are using an outdated version? And for Code Review, why do you need to use alt+tab this often? I already told you, in most circumstances you dont even need to know the type of the variable. If you need explicit typing so much, its a sign that you have poor naming for your method/variable, or that your team lacks convention/consistency. This is your own problem, cant blame it on 'var'. Again, there are many programming languages that support local type inference, and there are dynamic typed languages. If these programmers are fine or even happy without explicit typing, I dont see why its so difficult for you to accept this. 
In the beginning this is sufficient, but then you need X, Y, Z or you have conflicts in the dependencies etc. At some point you do not want to deal with that anymore and let the vendors take care of that. There was also https://github.com/networknt/light-java 
Although I disagree I can't say you are wrong. My issue is with all the large frameworks you pull in tons of dependencies and often times you don't know what they are and don't use most of them. As you add more and more dependencies there is a very high chance of getting version conflicts. I'd rather keep as few dependencies as possible and strictly manage the versions. (EDIT: if you check my gradle file I have strict version checking on by default) My whole approach is tailored towards developer productivity and is not ideal for very large teams. I have looked at light-java and think its cool (we both use the same underlying web server). However I still prefer using libraries directly. In my personal experience a large portion of performance issues comes from people not configuring their libraries correctly. Hiding them behind abstractions makes it less likely for someone to dig and find / correct the issues. Instead people jump right to work arounds such as adding more caches. Also as micro services get more popular you really don't need all the features the large frameworks give you and you want the footprint to be very light.
For certain applications, this is the only option. Doing it to avoid dependencies only is foolhardy though. If you must go this route, prepare to learn A LOT about HTTP. During year one and most of year two, you'll get caching, compression, content negotiation, client expectations, and other such details wrong. If your project is still around after that and you've manged to get routing of sync and async requests right after rewiring it 5 times, you'll know enough about HTTP to fix those things and add support for 100 continue, chunking, pieplining, and SSL session sharing across clustered nodes. After all this, you'll need H2 support but you won't get that from Java, so you'll need to use OpenSSL some how. Your web server won't do it for ya (unless the year is 2019 or GPL is an acceptable license for dependencies), so you'll spend year 4 writing a Web server (which will still suck by year's end). The saga will continue like this year after year, but you'll have a product like no other. Good luck! 
Thanks for that too. :-)
So you support gzip, Accept-Language, Accept, do you handle Vary correctly, do you send a 417 when the client has expectations you can't fulfill, can you route async and sync, do you reply with a 406 if the client won't accept any media type you will, are you caching responses (with Expires which is clock sensitive or max-age), what about 503 with a retry-after header? Not trying to be a know it all or a wet blanket. In my experience heading down this path for a few years, the web server doesn't do that much. It's the frameworks on top that do these things. Without em, you code. If you must, you must, but don't if you don't have to. 
The thing is that REST is a solved problem in Java. It even has its own JavaEE standard (JAX-RS). Of course, JAX-RS uses those nasty "annotations and lots of magic" that you dislike.
Yeah but basic rest is sending some bytes, a header, and a status code. Do you really need a framework for that? I don't think the frameworks are wrong or bad, I use them at work. Personally I think its easier to use lower level libraries with a little custom code. I find it a bit annoying when you have to Google how to do X in Spring / JAX-RS when you can create the request with cURL but can't figure it out in your frameworks preferred way. HTTP isn't very hard but as /u/spencer205 pointed out there is a lot to it. However if you are only doing a few simple things why pull in a huge framework. Not trying to argue, just explaining my opinion. I know I'm on the losing side.
dsl-json is at least 5 times faster than Jackson, even with the afterburner. The rich feature set is not free.
Starting with stating the obvious: You abstract the data tier in the application precisely so the app doesn't need to know the details about the data store itself. It doesn't know if you wrote data to SQLite, oracle, a data file...or not at all. Given you've already decided not to use an ORM, the cost of rewriting the sql dialect within a data tier is not, in my opinion, more or less work than rewriting the stored procedures to their new dialect. The stored procedure route will result in the least amount of code changes within the application due to a database change, as the syntax for stored procedure execution in JDBC is already abstracted. Therefore, a new database could theoretically result in no application code changes between database vendors, other than a single JDBC driver change.
You can do something similar with the java.util version maybe.map(text -&gt; ...)
Another naming scheme being considered Matrix Name Op-Suffice Data Type ------------------------------------------------------------------------ Matrix64 _R64 Dense Row-Major real double Matrix64C _R64C Dense Row-Major complex double MatrixBlock64 _B64 Dense Block Real double MatrixBlock64C _B64C MatrixSparse64 _S64 Sparse Compact Column real double MatrixSparse64C _S64C MatrixTriplet64 _T64 Sparse Triplet real double MatrixTriplet64C _T64C MatrixSkyline64 _K64 Sparse Skyline real double 
Oh, got it, I should have checked the context, thanks, I see.
Coming from the JavaEE world there is http://microprofile.io/ nowadays. What is the difference? Since the vendors use the same plattform, all specs defined in JavaEE 7 (and later on 8) can be easily added upon need. Imo my job is to generate business value. I can hardly justify doing something like at work. This would be totally something for my free time though :)
If something is so big that it needs to be tested and isnt accessible via a public or package private method you should consider outsourcing that part into its own class and test it there.
And this is kinda what happens in the last part of the article.
What problem does your solution solve?
No, OSGi is a dynamic component system. This is a static code analyzer akin to SonarQube for example.
Depends on what you want to do. Java is good for web applications, c/c++ for game dev and embedded stuff. Just try different things and see what suits you.
[removed]
var is less readable and really not essential, why overload the language with lots and lots of stuff, how much has C changed... still works.... 
Oops. Usually Reddit checks that and complains if the link was already posted - strange. I've hidden it.
It feels like Java is slowly getting there but it's taking soooooo long. At this rate I'll have to try and persuade work to use Kotlin.
&gt; how much has C changed... still works.... C doesn't have objects at all, so I guess that whole OOP thing is kinda pointless, huh? C sees evolution, but it's the "backwards compatible" complement to C++, which has something like hundred independent compiler implementations and what not. It can't move quickly because of its ecosystem, not because of a blazé attitude towards progress. So maybe we should compare Java to C++, the modern counterpart to C. And C++ added type inference years ago: http://www.cprogramming.com/c++11/c++11-auto-decltype-return-value-after-function.html Believe it or not even the old school languages evolve. But there are always those who feel as if it's their duty to whine about progress, because they can't bear the thought of having to spend a few minutes with a new feature to learn it and get used to it. Java is already one of the most conservative programming languages in the world. But this is the computer industry. Things evolve or die. Not just languages, but programmers, as well. So learn how to learn, or get left behind. 
Why is it hacky? I love doing that with PL/SQL, too: FOR rec IN (SELECT x FROM t WHERE id = :id) LOOP ... END LOOP; The query returns 0 or 1 rows. This approach is much simpler than any if/else based approach.
There is also https://www.togglz.org/ as an alternative.
Java language is pretty conservative, Java 9 haven't any language considerable change. If you require a different language then you don't have to wait Java 9.
I agree, but imho you should mention some problems for the readers here. First and obvious one is the *decorated, not thread safe* inner class. You could of corse call ``increment`` on it from another thread than used for the *thread safe* decorator: Position notSafePosition = new Position(); Position ostensiblySafePosition = new SyncPosition(notSafePosition); // now call one from Thread 1: ostensiblySafePosition.increment(); // call other from Thread 2: notSafePosition.increment(); Other problems arise of course for classes that exposes mutable member objects via some getters. You cannot rely on thread safety for not immutable classes, if you do not protect their members; ``synchronized`` nor ``volatile`` are *automagically* sufficient; you always have to see the big picture! (Not to forget potential dead locks, escaping during construction or stuff like that, if you use the described technique...)
I wish with Java 10 they would remove some of the older, bloated API that was added. And freshen up the look of the documentation and language websites. It all looks like it's stuck in the 90's in comparison to other JVM languages (Scala, Kotlin, ...) It really turns off a lot of developers from using Java and gives it kind of a bad reputation :(
The goal is to build a dropwizard like seed project. If you follow node there are almost no large frameworks and you just clone a seed project with X, Y, and Z libraries. If one of the ones they used isn't to your liking you just replace it with your own. Advantages * Much less total code. Pulling in Spring pulls in tons of external libraries which can cause version conflicts and mainly more code is harder to debug / learn wether you wrote it or not. * By pushing the libraries you use in your face to tend to pay attention more. This means strict thread pool management, learning proper configurations. * Easier to learn / ramp up on for a new dev (Personal opinion) - If you know HTTP well its much easier to use a low level web server than learn a large framework that abstracts simple concepts away from you. * Performance - Less abstractions means you can get more performance (Not that this is a good reason, never over optimize) * Stack size management - I made a post on how my default undertow servers stack depth is about 15 lines while a simple spring boot is 55 lines. * start up time - my side project servers start almost instantly * code style - I'm not a fan of how overused annotations have become and find the newer web sever approaches much more appealing. Undertow / Spark Java use builder type methods for routes. * Function composition vs AOP - AOP solved a problem years ago but now its very easy to solve the same issues with function composition. Ultimately they do the same but function composition is easier / cleaner to write and debug. Disadvantages * Much less documentation - (part of my goal is to just add documentation of how to do things with lower level web servers) * Reinventing the wheel - for instance Spring security is widely used. I might need to handle my own authentication. At the same time though when I previously used Spring security it took me 2-3 days to figure out what I needed to. Writing my own took a few hours :(. * Higher chance of security issues * probably a bunch more As I have said repeatedly I'm just trying to share a way to write services with much lower overhead. In a way I find much more productive. As micro services become more mainstream I find it funny to watch people spin up Spring running in Tomcat and a service spins up 200+ threads on a two core AWS instance. The lower you go the better use of resources you have. Of course you can configure Spring / Tomcat but in my experience people are lazy and just assume its done for them. The technical problem I am solving is already solved but we would never get anywhere if people didn't try new things :).
The biggest difference is honestly personal preference. There are a few advantages I have listed in various comments / the website but at the end of the day they all do the same thing. I prefer lower level less total code solutions. If I can write a curl command in a few minutes to make my request it should be equally as simple on the server side. Yet with large abstractions sometimes you need to google a while to find the blog post that explains how to properly set the headers you need using your framework. That can irritate me on occasion. Its kind of like when I can write a performant SQL query in a few minutes and it takes a few hours to translate it to Hibernate correctly. Admittedly I haven't used Spring all that much one of my first jobs wrote and maintained their own web server over top of servlets (yikes I know). My previous job was Scala where most of the web servers work this way. Scala, Go, Node all pretty much work this way low level servers just learn HTTP and move on. At the Scala job we pretty much had to write all of our own custom framework code and it took maybe a month all in. That was with multiple variations and resolving arguments between team members. A month is a long time but if its a one time up front cost and small maintenance cost I find it negligible. Also every dev on our team then knew the framework inside and out and could debug issues very quickly.
If you'll bother to record and post a video, you guys might've bothered to put a microphone on the speaker, so we can hear what he's talking about. Or even have the courtesy to clear that background noise a bit, which is trivial.
I'm a big fan of reading source code to find out how something works. @RequestMapping("/greeting") public String greeting(@RequestParam(value="name", required=false, defaultValue="World") String name, Model model) { model.addAttribute("name", name); return "greeting"; } Reading this example I have no idea what is actually happening under the hood. To me it looks like its adding something to model but is never used then we are returning a string "greeting". Now after you read a few blog posts you realize "greeting" is the name of the template and the model gets passed to it. What status code gets sent? what content type? How does a String translate to a template. These are all questions I would ask myself and its not apparent from the code. Also there is no code to jump into because all of this happens behind the scenes. VS private static void greeting(HttpServerExchange exchange) { String greeting = Exchange.queryParams().queryParam(exchange, "greeting").orElse("World"); Model model = new Model(); model.addAttribute("greeting", greeting); Exchange.body().sendHtml(exchange, Templates.render("greeting", model)); } This to me is very explicit. And if I don't know what the method does you just jump into it. In this way I think its easier to learn by doing especially if you know HTTP already. Just a small example. EDIT: Also doing things things this way allows you to have different response types in a single route. For example handling 404's inline without the need to throw / handle an exception.
I was just making a joke to try and spark conversation. I agree I was a little trigger happy with launching a new site so I will reduce posting. However a large portion of the posts had positive feedback.
&gt; To me it looks like its adding something to model but is never used Well that has nothing to do with the implementation. &gt; then we are returning a string "greeting". &gt; What status code gets sent? You could use Spring's ResponseEntity to add a meaningful response. Your implementation doesn't have anything more meaningful than a String nonetheless. &gt; what content type? You can declare it as a header in RequestMapping. &gt; Also there is no code to jump into because all of this happens behind the scenes. All in all, this looks much more like a distate for Annotations. If you really don't like it I suggest moving to another language, because Java is not getting rid of it anytime soon and reinventing the wheel doesn't seem a plausible option to anyone.
Most IT companies here do not even hire if you are not at a certain level. Note that English is taught atleast 3 years in public school and additionally there are mandatory courses while studying Computer Science (minimum 2). Some lessons are completely in English too. Other than that I probably could ask my company to pay me English lesson should I need to refresh my language skills.
Yes I do have a dislike of annotations because they make it difficult to track down where the code that is actually executing lives. My point was not that returning a string was bad, but not knowing where / how the headers get set can be frustrating. If you jump into one or two method calls in my example you see the headers getting set. In Spring / JAX-RS you need to find the proxy classes that handle the annotations. Annotations are great in some scenarios. I don't think this is one of them anymore. In the past it was a good solution but in my opinion there are better ways to handle this now. Now using Spring with the Request / Response model would fit all of my needs and would be much more explicit. But once again why do I need a framework to set a few headers for me if thats all I need. &gt; Java is not getting rid of it anytime soon and reinventing the wheel doesn't seem a plausible option to anyone. * https://www.playframework.com/ * https://github.com/networknt/light-java/ * http://www.ninjaframework.org/ * http://sparkjava.com/ * http://undertow.io/ Spark and undertow are both lower level servers but still have clean routing models. 
If using semantic versioning you cannot drop something from the old API. Java 10 is actually java 1.10 which means that in theory java code written in 1.0 needs to be compatible with 1.10 (which is positive thinking but you catch my meaning). In regards of javadoc, isn't that just style in a broader sense? I could write my own "javadoc" compiler which compiles it into more beautiful HTML(5) + CSS(3) ?
Microsoft was actually sued because they broke the terms of the licensing agreement with Sun and still marketed the end result "Java" (a Sun trademark). Sun didn't sue them for "re-packaging" Microsoft-only Java as "J++" and for using Java concepts in C# after the suit. Google isn't marketing the Android VM as "Java" - they acknowledge it's a different platform. You can't write a regular "Java" program and have it run directly on an Android - you write Java source code targeting a specific set/subset of Android specific libraries, compile it to a class using the JDK, and then run an Android compiler to re-build the Java classes to Android specific compiled code. If anything it's a cross-compiler. Android/Google isn't doing anything underhanded here at all. 
SLF4J is at 1.7.22 which means about 7.22 versions floating around out there with different bugs/features. You think that solves anything? The lib itself is 4.5 megs of junk. That's better than a single class compiled to 2k? 
Not sure this is the appropriate sub... At least, the article should talk about [Codename One](https://www.codenameone.com/).
You're orders of magnitude out on the size of SLF4J. It's 52k -rw-rw-r-- 1 david david 41K Jan 13 11:10 /home/david/.m2/repository/org/slf4j/slf4j-api/1.7.22/slf4j-api-1.7.22.jar -rw-r--r-- 1 david david 9.8K Apr 20 2016 /home/david/.m2/repository/org/slf4j/slf4j-log4j12/1.7.21/slf4j-log4j12-1.7.21.jar (I don't seem to have 1.7.22 of the log2j driver, so you'll have to deal with 1.7.21) -rw-r--r-- 1 david david 479K Apr 19 2016 log4j-1.2.17.jar Log4j is ten times the size of slf4j. 
jOOQ is great for more complex queries and queries with lots of optional params. Here is an example from one of my code bases. public int affiliatesProducingClicks(ReportRequest request) { Condition condition = trueCondition(); if (null != request.getNetwork()) { condition = condition.and(Tables.CLICK_DATA.AFFILIATE_NETWORK.eq(request.getNetwork())); } if (null != request.getGroupId()) { condition = condition.and(Tables.CLICK_DATA.GROUP_ID.eq(request.getGroupId())); } if (null != request.getStart()) { condition = condition.and(Tables.CLICK_DATA.DAY.greaterOrEqual(request.getStart())); } if (null != request.getEnd()) { condition = condition.and(Tables.CLICK_DATA.DAY.lessOrEqual(request.getEnd())); } if (null != request.getMerchants() &amp;&amp; request.getMerchants().size() &gt; 0) { List&lt;Long&gt; ids = Seq.seq(request.getMerchants()).map(m -&gt; m.getMerchantId()).toList(); condition = condition.and(Tables.CLICK_DATA.MERCHANT_ID.in(ids)); } return Daos.create() .select(countDistinct(Tables.CLICK_DATA.AFFILIATE_ID)) .from(Tables.CLICK_DATA) .where(condition) .fetchOne(0, Integer.class); }
yes, that is fine if you can coordinate it well. This can be done if everything is highly automated. I have seen people trying to do that while deploying **manually** (┛◉Д◉)┛彡┻━┻ There is always a trade off and you can choose what you prefer. There is no silver bullet :-)
&gt; Making class functionality both rich and thread-safe is, in my opinion, a violation of that famous single responsibility principle. Yes, it's increasingly famous for being referenced where it doesn't belong, though. Being thread-safe is not a separate responsibility unless you decide it has to be. It's not an absolute. And thank god, because it means it restricts your thread safety solutions to the most crude ones.
I'm ok with manual deploys if you use something Like ansible or salt stack and you have a very simple infrastructure (example of a single service with only a few servers). Anything more yeah there is no reason not to automate testing / builds / deployment its not that much work these days. 
Aside from that having some "X" contributor go and claim "more enterprise is going to use X" because "Big Company uses X" is just incredibly annoying. If anything in this case more and more companies are discovering that building a back-end in a yolo-typed language like JavaScript using libraries from an ecosystem where 'unit tests' are far from the norm might not be the best idea. Rather hilarious is that in the next section a point is being made that "Y is taking over from the X" mentioned in the previous section. It's all just senseless speculation without any critical thinking. 
Java 9's module system and deprecation of stuff like sun.misc.Unsafe is already breaking a lot of legacy code. A lot of stuff will need to be migrated between 8 and 9. If there is a good moment to actually remove things it's now. 
Nothing even vaguely Java related - removed.
well if you see different application servers running in production and in dev :P why? because the dev guy has no access to deployment due to ops guy. Welcome to DevOps NOT :D
Sorry, but there is nothing even vaguely Java related in that post. Maybe this would fit in /r/programming, but I doubt that it will be well received there either. The fact that you're a Java developer (as you mentioned in another comment) does not change the content that you submitted. "clean code" is not only about Java (as you claim in that other comment), but about best programming practices. The author only uses Java to illustrate these concepts. (If you haven't understood that, you haven't understood "Clean Code" by Uncle Bob.) **Removed** not Java related at all
It's arguable on how much of language is its library and how much the language syntax/compiler itself. Microsoft didn't extend Java language itself, they added MS specific APIs/libraries. Judging by that, Android java has lots of Android specific APIs/libraries that are not available in standard OpenJDK/Oracle JDK.
IMO the best way to get into the job market is to build a portfolio of open source projects to allow you to showcase your programming skills to potential employers. Create a simple application or two hosted on a public repository such as GitHub, etc.
That's a really great improvement. As an API designer, I've found this limitation *very* limiting, knowing that I cannot overload methods like these: m(Predicate&lt;String&gt; p); m(Function&lt;String, String&gt; f); Let's just hope this doesn't completely kill off compiler performance (Java 8's [generalised target type inference](http://openjdk.java.net/jeps/101) still leaves its traces in the latest version)
I like your optimism.
Keeping names short does make it easier to read too. Don't need to scan a large area and all the verbosity can make it a cluttered mess. See Python vs Java. I also personally find printf() easier to understand once you get use to it than any of the object oriented approaches I've seen in any language. Trying to strike a balance between LAPACK style names (e.g. DGEQRF) and extremely verbose but easy to understand and visually distinctive names. As the library has grown that's required more thought. With the procedural API in EJML it's basically impossible to use without RTFM. Can't tab complete to see all the functions that you can use on a matrix. This is done to keep code complexity down and to give the user complete control. I've tried to design it so that once you learn a few rules you can guess the function's name and where it's located. For those who don't want to RTFM there's SimpleMatrix. Thanks again for all the comments. You've definitely affected the final design. I've been trying to get feedback from my user community, but I'm a bit disappointed at the lack of response. I can tell it's still one of the most popular Java libraries through various metrics, but just can't seem to get people to engage except for an occasional bug report. 
&gt;I've decided to use jOOQ Didn't see that coming...
You are right I am mistaken. Not sure why I thought that.
aha. english is my 4th language. if you prefer to actually "shove" things there, that's fine with me. your justification is: "off topic - which clearly means that it has no place here". the rest of your message about removal, was fluff and also condescending -- i called you out on your tone. otherwise, i am ok with your decision.
surprise! :D
I know, it's such an obvious choice
well, one reason is that Oracle's approach would ruin all our careers. Sun and Microsoft didn't introduce that risk.
I think the key difference is that Google could have made the APIs completely different and maintained functionality. There was no intention of cross compatibility between android and PC. Google simply followed Oracle's APIs to make it more familiar to Java devs and make porting easier. 
Because for many Google is a Silicon Valley darling and whatever they do is ok. I side with Oracle on this one even if their approach isn't the best one. Google forked Java there isn't any way a real Java developer, that has to daily face the quirks of Android Java, the half supported Java 7 and 8, with the possibility of Android never supporting the features of Java 9 and 10 roadmaps can say otherwise. Eventually one will need to start writing Android specific versions of Java libraries, that could have been written without changes, had Google not forked Java.
ok. // (c) i_ate_god 2017 public int add(int a, int b); now please avoid creating the same method signature, for next century. But I'll happily license this method signature to you for $500,000,000. edit: oh, while on the subject, let's throw in software patents too: // (c) i_ate_god 2016 public int add(int a, int b) { return a + b; // US Patent 00135819058 } there, now give me all your money.
[This article](https://www.linuxjournal.com/article/3482) says that Microsoft added the `delegate` and `multicast` keywords to the language, which breaks compatibility at the compiler level. The Android source code is available under the Apache License. You can run Android pretty much anywhere free of charge without violating its license. I would assume that the Java API extensions made by Microsoft in the 90's were not released under such a generous license.
No, because now hardware OEMs get the free beer fork Android Java instead of licensing Java ™ for their devices, thus increasing the onus om those trying to write portable Java libraries. Which is one of the original goals of Java in first place.
These articles remind me of the ones I read about C++17. Expectations went through the roof, reality only took three steps up.
I can't instantly summon a few dozen relevant quotes, but I can tell you what courts in the U.S. and abroad have ruled can't be copyrighted: - Titles of articles, books. - Names, personal and other. - Content which is not original, is popular vernacular. - Works which don't represent substantial creative original effort, i.e. for example a telephone book is not copyrightable. - A map, however is original creative effort, despite it represent a real piece of land. So maps can be copyrighted, but it's *important to note*, that someone creating a map of, say, Boston, doesn't mean *another party* can't create *another map of Boston*, as long as they do so on their own, instead of copying the first one (there are many stories of intentional mistakes to prove infringement here btw). So, anyway, I don't feel like writing a PhD thesis on the topic here, but the above examples should show you that copyright law judgments tend to match common sense, instead of being the exaggerated parody you're trying to pull off in your above comment. Just like there's a difference between copying *one word* and copying the entirety of *War and Peace*, there's a difference between copying *one method* and *4000 classes*. And the judgment should be according to the size of the copied work. Unfortunately the decision of the courts in this case is based on the ignorant idea that all those 4000 classes are more like a telephone book, rather than a map or a novel. What the courts are saying is that APIs are not designed, they're not original, and they're not creative effort. You just sit down, and type an API out, the way you'd assemble a phone book... Now...If you feel this opinion represents your interests as a developer... I mean, be my guest. As an API developer myself, I beg to differ, as I know how much blood, sweat and tears I've put into designing good APIs. And I've seen people with less skills and experience botch API design in countless ways.
Is there a roadmap / overview of the most important improvements for v3?
I would say that that's slightly different though. Unsafe was never part of the public API, and therefore there was never a commitment not to break it. In theory, people shouldn't have used it, and in fact the compiler threw warnings when they did, but it was so useful that people went for it anyway. However, even though there was never a commitment around Unsafe, they're trying to break that particular bit in an [orderly fashion](https://www.infoq.com/news/2015/07/oracle-plan-remove-unsafe), which sort of reflects the ethos of the Java language: stability before innovation.
At this point, why don't Oracle and google simply shake hands and trade a couple million bucks. Instead of wasting it on lawyers. Then work together on improving Java. 
[removed]
I'm sure Google would be fine with working together. I'm pretty sure the point is that they don't owe Oracle a penny, but Oracle feels they're owed millions or more and are not at all interested in cooperation
Even though MVC frameworks are loosing their steam due to the new microservices architecture. I still feel there are use cases were MVC frameworks are still the right choice. Glad to see this spec's life continued.
Did you ever implement a specification? Did you ever implement parts of an SDK to replace functionality and create tests?
And meanwhile there could be more people who are familiar with Java, because they started Android development than the other way around.
It's also been curious to me, but for reasons that differ with your own. How can you accuse Google of Embrace, Extend and Extinguish when all they did was use the API **signatures** from 37 Java packages that were open sourced and under the GPL? Also, Google doesn't use the JVM nor do they use any IP from the JVM. They also don't use or violate any Java trademarks by using the Java logo anywhere in their marketing. This is in contrast to what Microsoft did when they actually did extend the Java language by adding Microsoft specific API's while still calling it Java. There's really no comparison between what Google did and what Microsoft did and that's probably why Microsoft ended up paying Sun a Billion dollars. Also, this article is from Sep, 2016. 
You could start a blog about it. I'd follow that!
https://blog.codinghorror.com/fear-of-writing/ I'm also bad at it. That shouldn't stop you though. I would be interested in your blog. I'm fairly new to java as well. I had a very dry run through on the course that just applied object oriented concepts. 
That's a great source, it's almost like an advertisement directed directly towards me. Maybe i'll look into it further as something that might improve my writing and vocabulary. Bookmarked regardless! EDIT - Now that I think about it, it might improve my attention span as i scour through other tech blogs for ideas. I might learn something haha.
Start by using a different language for a small feature to show them the benefits. Kotlin would be great bc you can just plug it in with your existing Java code.
nso sune sgives a fuiki
During the case, Oracle vetoed the only jury member with programming experience. I wonder why they would do that.
A live version: http://download.java.net/java/jdk9/docs/api/java/lang/Cloneable.html
Do you think that is what Oracle and Google are thinking about when they are picking jurors? Also, having programming experience doesn't make you an expert. It just so happens that in this case, parts of oracle's copyright claim were so stupid that someone with an elementary understanding of programming would see it is bullshit.
I think this class will be pretty slow, and I'll be honest and say I've never really had the drive to learn programming on my own. I'm interested to see where this bootcamp will take me. I've always been more interested in wireless, cloud, and networking technologies. I haven't taken that very far either, aside from spinning up VM's and barely breaking the surface.
&gt; in May I will be starting a coding bootcamp for Java that runs 14 weeks. Curious. Why? Assuming you're already going for a BS in CS?
Instead of 'inheriting' from a base Java image you can make a tomcat image that includes most dependencies. Let your Spring Boot image inherit from it and deploy it as a war in the underlying tomcat. 
First ask yourself, is it really worth going through the hassle to do this optimization? If the answer is yes: * https://midgetontoes.com/tips-for-using-proguard-with-spring-framework/ * do a mvn dependency:tree and make sure that transient depenencies are all the same version * make sure you're not including libraries that you don't need * Tell your developers to stop building monolithic apps and more smaller services, preferably with a message bus between them
My team at work uses this as well, been liking it great so far 
&gt; I agree, but imho you should mention some problems for the readers here. I left a comment on the article. ;)
Thank you
The degree I'm going for is a BS in computer science and engineering, and every class I'm taking is pretty much required to be in a certain order. This semester I'm taking java programming 1 which will be extremely basic. The next programming class will be intro to C++ and I won't be able to take that for about 2 years. It's a little convoluted but it's because I'm not going down a developer track. I am required to specialize though, choices are software engineering, AI, and network security (the ones I'm interested in) and I'll probably end up choosing network security. I'm hoping this bootcamp will give me a more concrete and real world taste of programming and land me a job as a developer so I can continue to hone those skills. It's more schooling which is fine with me. I'd really like to be a pioneer in InfoSec by the time I'm 40 though.
&gt; for about 2 years That is approximately 2.791098% of the average human life.
Since this is help with *Java programming*, it should be, as the many hints on the page indicate, posted in **/r/javahelp** and not here. Before posting there, make sure to read the [**Posting Guidelines**](https://redd.it/48eykt) **Post removed:** programming help.
Can you present a real-case scenario in which this kind of thing would be useful and which couldn't be easily substituted with a reduce/collect/loop operation? I have a feeling you're referring to a nice-to-have functionality, but I can't see the value that it would give in a practical sense. And, whilst I agree that it's great that new languages play with this kind of thing, an established and widely-used language like Java can't afford spending the time and effort to support things that don't add value in a practical sense.
You probably have a point, but forgot to include it in your comment.
&gt; During the case, Oracle vetoed the only jury member with programming experience. I wonder why they would do that. He wasn't a programmer, he was a networking manager. And also Google vetoed several who weren't in favor of "free software". So what's your point?
Yeah, it does get a little murky... Oracle does own the Java language, but at the same time they have decided to make it open source and license the source code as GPL. This open source version of Java is what is called [OpenJDK](http://openjdk.java.net). Now, because it's open source, everyone is encouraged to contribute to it. But, because Java is so widely used, there needs to be a process to regulate how such contributions are performed to prevent chaos. This is what is called the [Java Community Process](https://jcp.org/en/home/index), which establishes the process to modify Java. The JCP is a little too formal at times, so [JEPs](http://openjdk.java.net/jeps/1) are a previous, slightly less formal step designed to kick the ball rolling. On the other hand, all this applies to the source code only. When people do download Java, they typically download a binary distribution, and this follows a different set of rules. The [typical package provide by Oracle](https://java.com/en/download/) is basically the source code compiled and packaged *together with some extra things that aren't part of OpenJDK*. Here Oracle has absolute control of what they package together and how they license it (and their license is significantly more stringent than OpenJDK's). I hope that helps :)
Implement a sample program that has the same functionality with both and see which you prefer.
Majority NPE's (if not all) come from local code bases unless you're using a sub-standard library. So IMHO, checkers might be useful beyond toy examples. The other option is to rely on `Optional` which adds similar verbosity and has allocation overhead.
Pretty much every organization I have worked for used one of two values for SQL connection pool max sizes 50 or 100. Add this with the influx of micro services and you have hundreds to thousands of open connections to a single database. This article and video do a great job explaining how lowering your connection pool sizes can increase performance. This is for high throughput low latency transactions. If you have a requirement for longer running SQL such as reporting or any OLAP a good approach is to make more than one connection pool per database. You can have a small pool dedicated to high throughput OLTP connections and a larger pool for OLAP connections. If the OLAP pool begins to get backed up it does not impede the OLTP transactions as much.
A reasoned, non-polarized, accepting of choice opinion in /r/java? You must be new here...
&gt; .net ahead of Java .Net is a platform, Java is a language. If you meant &gt; .net is ahead of Java platform Then: lol, you have no idea what you're talking about.
Doesn't [Akka](http://akka.io/) also implement "rx"?
Cool thanks for the article was a good read.
I don't think I understand your question, though it looks like others in this thread do, so it must be me. &gt; Why do you still see NPEs? What would you expect the JVM to do if you set a variable to null and tried to reference it? The behavior cannot be defined, can it? I have only dabbled with JSR308, but it was my understanding that the annotations could be used by other, non-JVM frameworks to help you test and error-check. I did not have the impression that the JVM did anything with the 308 annotations.
Semicolons has nothing to do with why Java is or is not verbose, or at least very little.
We really shouldn't have to worry about concat speed in 2017.
Take a look at [CompletableFutures](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html). What specific features do you need? By combining CompleteableFutures and with Executors you can cover quite a few use cases. Ideally your logic should mostly be decoupled from the rx framework you choose so like /u/dstutz said pick what you like. If you need to change later it shouldn't be all that much code if structured correctly. 
Seriously dude! 
In my experience, NPEs are most common in the local code base, where you made a wrong assumption about how an external library works. I don't see how it can help with those. Even if the library uses Optional, the tool still can't distinguish between `optional.get` and `optional.getOrElse'.
Please remember to read the caveat at the bottom of the page if you have particularly lengthy database transactions. Your mileage may vary!
OK, so I think we agree that JSR308 is for non-JVM testing frameworks, yes? As for NPEs, you meant, "why do we still have NPEs when developers have access to this nifty feature", rather than, literally, "why are NPEs not automatically corrected somehow by the JVM"? If yes to all, then I totally missed the point of your post and will now slink away.
How does that work with, e.g. `Map.get()`, which can still return `null` on a `Map&lt;@NonNull Key, @NonNull Value&gt;` type?
/r/titlegore 
That is why I said "programming experience" and not "programmer." My point is that it is very telling on which of the two companies is probably in the right when one of the companies vetos the only person who knows what is up. &gt;And also Google vetoed several who weren't in favor of "free software". Do you have a source on that? Even so, it doesn't matter. The other people don't have programming experience.
Agreed! Once you've been around for a while you'll realize you spend a lot more time *reading* and modifying code than starting new stuff from scratch. Here, verbosity and readability are a much bigger time saver than having to type in fewer lines of code. 
&gt; My point is that it is very telling on which of the two companies is probably in the right when one of the companies vetos the only person who knows what is up. And yet here I am, programmer, and prefer the court sides with Oracle. Maybe you don't know the whole story behind this veto.
&gt; Pretty much every organization I have worked for used one of two values for SQL connection pool max sizes 50 or 100. Add this with the influx of micro services and you have hundreds to thousands of open connections to a single database. I don't mean to be the wise guy and nit-pick your terminology, but microservices and services in general are supposed to have their own private storage, so only one microservice should be connecting to a given database. It's the same as encapsulating state in an object. You don't let an object's internal fields be accessed directly from many external objects. Of course you may host many databases on one server, if your microservices are small enough that they all fit in one server.
If only it was that simple! A new language in some production code would need some level of wider agreement. If nothing else the build in people's IDEs would start failing without the Kotlin plugin installed so there'd be a lot of distressed developers around. The current plan is to break out some functionality, which just my team works on, into a separate service and then we can have a bit more freedom around technology choices.
This article, [Applying Queueing Theory to Dynamic Connection Pool Sizing with FlexyPool](https://blog.jooq.org/2016/11/02/applying-queueing-theory-to-dynamic-connection-pool-sizing-with-flexypool/) is also worth mentioning. 
I have started learning java in September and have been using "Big Java Late Objects". It's going alright I guess, not too sure on how good the book is but it feels alright.
I'm afraid I'm just confusing things and not adding to the conversation. When I say, "non-JVM", I mean, "things that are not built in to the JVM". An example of a non-JVM framework is Spring, for example. So, AFAIK, and I may be completely wrong, while Java8 now includes support for the JSR308 annotations, it does not actually do anything with them. I don't think the JVM can correct NPEs, just to clear that up. I can't see how it would be possible and I don't think it would be a good idea.
&gt; This power drives all kinds of frameworks – starting with JPA providers like Hibernate, coming by testing libraries like JUnit and TestNG, to dependency injectors like Guice, and ending with obsessed class path scanners like Spring – which reflect over our application or test code to work their magic. So all in all, things which abuse reflection. Except for JUnit / TestNG, but I doubt you'd be testing someone else's module, so we should be fine here. Ideally "opens" wouldn't be a thing, but I've lived with a compromise in encapsulation until now, and I'll keep living with another fine.
It's only 40-page long almost finished spec, can't Oracle really include it into JavaEE? :/ A lot of people complain about JSF, why not to give them a choice?
[removed]
I took a deeper look, the search function takes in BiFunction, which has 3 generic types, two parameter types and a return type. This allows you to do something weird, like return a third type that is not being held in the map. So for example, using the previous example, you could look up using the Person with age &gt; 85 and not return that person, but return his Dog object instead. ConcurrentHashMap&lt;String, Human&gt; map = new ConcurrentHashMap&lt;&gt;(); fillMap(map); // I didn't use lambda here for clarity Dog dog = map.search(0, new BiFunction&lt;String, Human, Dog&gt;() { @Override public Dog apply(String s, Human human) { if (human.age &gt; 85) { return findDogFor(human); } return null; } }); I guess this can come handy, when you need to pass that BiFunction to another class, which perhaps doesn't know how to find a dog for human. Otherwise you could always look up the dog after you've acquired the human object..
Except that doesn't work if the value is null (assuming Map supports null values, which HashMap and TreeMap do). Sure, you can argue that letting values be null is a bad design choice, but it's too late to change that now really.
From his posting history, I would say: /u/dartalley Mr. /u/stefan_reich, /u/stefan_reich_ai - more self promotion under another alt?
How is the state of IDE support?
PMed you my email. It's not very difficult to find. Not sure what all the fuss is about. I was asked to stop linking to my own site, to which I complied because I didn't know the rules. I have primarily commented in /r/java, /r/javahelp, /r/mysql prior to recently. Instead of doing a writeup and providing examples on my site. I linked to one of my favorite connection pools and their excellent resource on configuring connection pools. I do intend to provide examples on my site but I won't be linking them on reddit. There is no feedback on the site because it's written from scratch. You know, MVP release with minimal features. Feel free to email me if you have any issues / concerns. If you are looking for some kind of conspiracy with /u/throwaway_for_cause I'd be happy to entertain. 
http://www.oracle.com/technetwork/java/javase/8u121-relnotes-3315208.html http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html
I thought they had switched to OpenJDK now anyway.
Kotlin troll alert.
tl;dw of the main points? Does this obviate `StringBuilder` for concat (probably not but that is what another comment in this thread implies)?
&gt; I've looked at some Perl that looks one step above line noise and then it's in some sort of module file that didn't take separation of concerns very seriously. I've seen Java close to base64-encoded strings, too. Java's verbosity is not automatically bad, but neither does Perl's (or Python's, or Ruby's) terser syntax automatically lead to badly written code. In my opionion, Java's biggest shortcoming is not verbosity but excessive reliance on IDE features and Java-specific "design patterns" as workarounds to missing or inelegant parts of the language. I'm open to that being partially due to not being up to speed on the absolute Java cutting edge.
Why do people complain about JSF?
If you prefer reading over watching: I wrote this [article on performance improvements in Java 9](https://www.sitepoint.com/inside-java-9-part-ii/) and compact strings and indified concatenation play a big role in it. Regarding your question re `StringBuilder`, I'd have to guess a lot (maybe the Performance Tsar himself can jump in and answer). A sufficiently "dense" set of concatenations could be optimized to use the new path - with or without `StringBuilder`. "Dense" meaning "a couple of commands close enough together to be shuffled into one concat chain". But if you're in a loop, I'd guess that optimization would not generally work across all iterations, thus still resulting in the quadratic case. So for "long-lasting concatenations", `StringBuilder` should still be the way to go.
I love Jackson, but it is "magical" isasmuch as I have no idea how it works, but it works well and my business isn't JSON parsing. Even so, the speed here is attractive so I'm going to give it a whirl.
Thanks, that was my thought too. Just didn't like returning null 
I like the adoption of Lapack char codes. The current formulation I'm experimenting with is something like DMatrixRMaj for the matrix and _DDRM for ops class suffice ZMatrixRMaj _ZDRM DMatrixSparseCSC _DSCC I think that might be less scary for first time people and still concise. Plus no more 64/32 or underscores in matrix names. If you got any more comments would you mind moving it over to the [ejml message board](https://groups.google.com/forum/#!forum/efficient-java-matrix-library-discuss)? Easier to keep the discussion going plus maybe someone will see it and chime in. 
Seems to me that opening and closing connections dynamically would be better, because of this problem.
You probably mean JDK rather than JVM?
I just got done (sort of) learning ScalaZ...
There also is the *great site* [**Java Design Patterns**](http://java-design-patterns.com/) with lots of sample code.
I will add one more- https://sourcemaking.com/design_patterns 
I think you're conflating different concepts here. Reactor 3, RxJava 2, Akka, all **implement** [reactive-streams](https://github.com/reactive-streams/reactive-streams-jvm), which is the reason those libs are interoperable. java.util.concurrent.Flow is the equivalent of reactive-streams in the JDK (it still eludes me why they chose to rename everything, though). Now [reactivex](http://reactivex.io/), or reactive API - are different. They define sets of operators you can use to transform and compose those streams, in a functional way. Each library has its own flavor of operators and programming style. Flow does not provide such operators, and CompleteableFuture has its limitations. You can read more about this in [this blog post on reactive types](https://spring.io/blog/2016/04/19/understanding-reactive-types).
Thanks. :)
Those videos aren't good, especially if you're trying to learn new (for you) patterns through them. The author simply scrolls through some sample code and highlights fragments of the code and doesn't talk when is a pattern used, why is it used, when is it harmful, typical use cases and so on. And because a video is not a great media to inspect a code sample, you won't understand a thing from the code samples either.
It's just complex and hard to debug. Developers have to shift their minds all the time between client-side front-end development and server-side front-end development.
This cake is... a trademark violation.
If only the colours and exact shaping was correct :P
I'm wondering why application servers aren't prone to the same issue - why is it that an app server can easily (I assume?) serve thousands of users at once, while a database is limited to a handful? Is it solely because application servers are (mostly) stateless, so no connections are kept, or are kept for a very short time? Or is there something else I am missing? 
I wish Lombok was just built into Java.
Checker-framework hooks into the compiler, so it does its analysis when you build your code. It can definitely be made to work with maven; basically you add the checker-framework artifacts as dependencies and then enable them with `annotationProcessor` settings in the maven-compiler-plugin. That said, it can have a *substantial* impact on your compile times, e.g. I think it increases the build time on one of my projects from 2 minutes to 14 minutes. So I usually put the settings in a separate maven profile and only run it occasionally (I still use some faster compiler hooks such as google's error-prone on every build, though). The other issue is that *fixing* the things it reports can get complicated. Arrays for example can get messy because a `new Foo[10]` is always filled with nulls by the JVM, so if you want an array of `@NonNull Foo` you have to do some extra work to get one, such as first creating an array of `@MonotonicNonNull Foo` and then filling it and then doing an unchecked cast (which the checker cannot verify) to an array of `@NonNull Foo` once you're *sure* it doesn't have any nulls left in it. In one project I ended up creating helper methods to hide all that stuff, such as `newArrayOfNonNull` which takes a `Class&lt;T&gt;`, a length, and either an initial non-null fill value of T or some generator method that takes a slot index and guarantees to return a non-null T. The notation can also get messy with arrays and inner classes, since the type annotation belongs in a weird spot such as `@NonNull Foo @Nonnull []` or `Map . @NonNull Entry`. The Java 8 compiler understands these but a lot of other tools don't handle them well, especially things like auto-formatters and some other static analyzers. Checker lets you comment them out in a way that it can still see them, but it gets even uglier such as `Map . /*@NonNull*/ Entry`.
So true, the last time I was interviewed, I remeber, the interviewer simply asked me a few questions about language specifics(E.g., what function to extract a specified part from a varchar in Oracle, How the garbage collector works in Java), even not a word about how I would sort things out.
Ain't nobody want to watch a YouTube video for something I could read in 3 seconds
That doesn't really explain why it's cheaper than multiple connections - what resources is an idle connection taking up on a database that aren't taken on a web server? Put another way - if I choose to solve such a problem by making a web server which has a modest connection pool, but has clients making thousands of concurrent calls, won't the web server stall in a similar fashion? If not - why? What's the difference? If the web server can idle while it waits for the DB to return the result (thus freeing it to handle other requests), why can't the DB put aside one connection as it is waiting for disk I/O while in the meanwhile parsing etc. other connection requests? I feel like I'm missing some key piece, but I'm not sure what it is. Is it solely the statlessness of the web server? Or just a matter of different optimization priorities (web servers are optimized for a large amount of concurrent intermittent "sessions" while DBs are optimized for a small amount of highly-active sessions?)
I shared a couple of posts here before that generated some interest under a different account, hopefully someone can find this useful, otherwise feel free to downvote to oblivion!
As long as you don't sell the cake or monetize this reddit post, you're OK. Just be wary of undercover Oracle lawyers trying to buy a slice from you!
Those are the bigger ones. How much does it currently impact or hurt you that these are there? But even if you take a package like Java.util, do you use each and every class from it?
Nom Nom, happy to bake them a cake if they want a slice! Good advertising for them, I say! So much love I chose to bake a cake for them rather than another language I know! ;) 
😍
This is great. There needs to be more videos like this. 
This looks pretty cool, any comparison to Apache Ignite based on the overlapping features?
That's a pretty neat demo and a great-looking UI. But if I understand correctly, that builds a Swing-based application for desktop use, correct? The reason I ask is, it's been a very long time since I've been paid to build a desktop application (in Swing, VB, C#, or anything else). For at least the last ten years, it's been all web UIs. Are desktop applications (in Swing) something that people/companies are still building regularly? I think this drag-and-drop UI building tool would be more useful to me if it produced a web-application ... for example, if it was JSF widgets instead of Swing. Or if there was some alternate next-gen Swing rendering engine that produced a pure Javascript UI. 
Fairly different tech. While the article talks about building a distributed datastore with Copycat as an example, the main takeaway is you can use Copycat to build any type of distributed system: messaging, workflow, service discovery, etc, or you can use it as a basis for distributed coordination primitives such as Atomix [1] does. Copycat can also be used for in-memory things, similar to Ignite, or with durable, on-disk storage. Most importantly, Copycat (and Atomix) allow you to extend strong-consistency and fault tolerance guarantees into your application by allowing you to plug your own state machine into Copycat, as opposed to a typical system like Ignite which you interact with externally. Nothing else quite like it. 1: http://atomix.io/atomix/
I kinda veered off the main link, and was looking at Atomix, :D
Because, chances are, those books will be pretty crappy and only cover the fundamentals, not much. The main big difference that I can think of are generics, lambdas, and JavaFX. But most intro books barely touch on those, or explain them poorly. What will really matter is the next 10 - 25 books they pick up. You will never learn all of anything from one book. I would say any old, used book by Cay Horstman would be better than any new book by anyone else. Especially for your first book.
From my experience it is mostly used for behind the scene software that your employees are using e.g. in areas where you have no access to internet. These are rarely software that a enduser will see.
i would love to eat this
 package food.interfaces; public interface ICake { public void slice(int slices) throws NoFoodException, SlicedException; public void slice(int slices, double ratio) throws NoFoodException, SlicedException; public CakeSlice eat(); } EDIT: prettied up the code and fixed a typo. EDIT II: prettied up the code after failing miserably to pretty it up the first time.
Not sure what school of thought you're aiming with, but I've experienced the opposite with my own coding and from what I've read from the blog-o-sphere.... IIRC facebook uses this technique when developing and releasing new stuff.
The mobile link is *a lot* easier to read even on desktop browsers.
You've brought up really good point.
The Java 8 version won't be written by me unless I'm absolutely forced to. I want to iterate a list, not deal with a stream and some weird suggestive syntax that just looks more complicated. If I want to deal with a stream I'll deal with a stream. Iterating a list doesn't and should never, ever have required something as non-intuitive and non-industry standard as dealing with a stream that isn't actually a stream of data coming directly from a physical resource like a socket, a file, etc. That's a stream, not iterating an item list.
That’s how I was taught to do interfaces, and I learned Java before C#.
I think the Java 8 version is actually much more intuitive Just because you are not used to it, doesn't mean it is bad. 
ICake? You lost boy? *cocks shotgun*
You still have the option of doing it the old way. But take the time to learn streams and you won't look back. Take a look at java.util.function package. It complements streams very nicely
[FNV_32](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) is very good at that, while being fast and very simple. Here's a my version to hash strings (produces way less collisions than `String.hashcode()`, and from what I read only Murmur beats it, but it's trickier to implement) public static final int FNV_32_INIT = 0x811c9dc5; public static final int FNV_32_PRIME = 0x01000193; public static int hash(String string) { int hash = FNV_32_INIT; for (int i = 0; i &lt; string.length(); i++) { hash ^= string.charAt(i); hash *= FNV_32_PRIME; } return hash; } Hope it helps
1 word - youtube Type in what topic you want to learn like - "java constructors" and watch a few videos until you find someone who makes sense to you. This will help it "click for you" then go back to whatever convoluted way they are "presenting the course content" and do enough to pass it. IMO - from first hand experience any uni / college / school / whatever wont teach you anything due to terrible teaching methods and general lack of caring. Often the course content is very rushed due to strict time constraints so if you can watch a basic java series on youtube that covers OOP with constructors/inheritance that should make it 'easier' to absorb the content as most of the time it is just about finding a way for you to visualize what is happening within your own mind rather than the syntax. Plus watching videos x2 speed helps you cover more content in less time :) 
It's better? Write a one line iteration escape from a stream's tight grasp.
Any videos/ channels you'd recommend?
Ah for the good old days of Java 1.0 and Component.action().
IIRC, interface functions can be package-private in Java, so a public modifier would be needed. I get the feeling I’ve been made the fool with that one, though, so I’m not so sure about it.
Murmur3 is pretty good.
Verry Cool I really like that focus on the algorithmic way of thinking and not in teh actuall command of a particular language
&gt; Verry Cool I really like that focus on the algorithmic way of thinking and not in teh actuall command of a particular language I like how you, /u/JohnRed32, created an account just to praise this video. Just like /u/JohnHall2 himself created an account 9 days ago to [praise a youtube video](https://www.reddit.com/r/programming_tutorials/comments/5n8g79/improve_your_algorithmic_way_of_thinking_im_sure/dc9gyyz/): &gt; Thank you! Very good video. Please send more videos like that And [a day later](https://www.reddit.com/r/coding/comments/5ne5b3/improve_your_algorithmic_way_of_thinking_with_an/dcaqzkg/): &gt; his is very helpfull Thank you! &gt; Please upload more videos like this one Both of these videos were posted by /u/ProgrammerForLife64, itself a new 11 day old account, having submitted 70% of his posts to that channel. Both his and this video here point to the same youtube channel "Philosophy Behind Coding". Tell me, is it all a big coincidence? 
The notion of the Tower of Babel of programming languages is not new. Perhaps the earliest reference is the cover illustration of Communications of the ACM, Vol. 4 No. 1, January 1961: http://thecomputerboys.com/?p=566 This page mentions an earlier paper by Betty Jo Ellis whose title is taken from the bible verse: *Therefore is the name of it called Babel; because the LORD did there confound the language of all the earth* (Genesis 11:9). Unfortunately the Ellis bibliography linked from there http://special.lib.umn.edu/findaid/xml/cbi00106.xml describes this paper only as "a presentation on jargon of computing" and the paper itself is apparently not available online. I don't know whether it refers to Babel elsewhere in the paper, or whether the biblical verse is merely a foil for discussion of jargon. A recapitulation of the illustration of the Tower of Babel of programming languages appeared on the cover of the first edition (and possibly later editions) of Jean Sammet's *Programming Languages: History and Fundamentals,* Prentice-Hall, 1969. Cover images are viewable from this AbeBooks search link: https://www.abebooks.com/servlet/SearchResults?kn=sammet+programming+languages&amp;sts=t 
Python, r and rust are "junkfood"? Fuck I'm glad I don't work with you.
&gt; get off my lawn!
 ".....we want it to be fully replicated, durable, strongly consistent, and able to handle failures. " CAP theory will have something to say about this.
General comment, not specifically about this project in general. Has anyone else found that this model of building microservices with hard coded ports (rather than docker containers), and rabbitMQ between them (rather than ESB, or rest), is bloody complicated, slow, and possibly not living up to its promises? 
There is more coming.
You better had posted this in **/r/learnjava** as the **sidebar** here indicates. /r/learnjava has very good and free resources listed in the **sidebar** in the section **Free Tutorials**. **Post removed:** should be in /r/learnjava
I remember using early java programs. If that situation had not changed, Java would have died, then and there. It was completely useless to an end user. If you say changes are made for no real reason and use Rust as an example you are just allergic to change and do not know what it is about. Rust is an example of a language that has a really valuable difference. I hope you enjoy making your web pages in assembler.
[removed]
&gt; anadea.info blog First paragraph: &gt; I interviewed Alexander Mikhalchenko, a Java developer in Anadea Tells you all you need to know.
They indeed brought good points, but they're overselling the differences quite a bit. If you pick a good book about Java, then learning everything that happened in the last decade or so, will only take you a day or two of browsing and trying the "what's new" for each subsequent Java release. Many of the enhancements are simply a slightly shorter way to write what you could always do. The most important thing about a language is to learn to "think" in it, to know how to *architect your applications* in it. And the enhancements don't change anything about doing fundamental architecture in Java. They only improve a few small details around how you spell out the implementation (and all the "old ways" continue to work). 
Because the senior developer who does the interview demands we instantly rewrite everything to the latest shiny, regardless of benefits? Streams are great in Java 8, but I see them abused more often than I see them used to their strengths. Turning everything into streams is just as immature as refusing to use a new feature. Neither are the traits of a great developer. Streams for example, when used as a blank replacement of loops, can be up to 15 times slower (on average they're about 2x to 5x slower). Often this doesn't matter, but sometimes, especially for hotspots in your code, it does. The Java compiler does absolutely nothing to optimize stream performance, the way functional languages, or some newer efforts like Rust, would. So if you don't use streams to their strengths, all you did was make your code slower. Do you think your employer would be proud? Give you a raise maybe? And the situation with readability is also not as clean cut as stream proponents like to demonstrate with their toy examples. Sometimes, the stream factoring is more clear. Sometimes, the loop factoring is more clear. This is a *very* contextual decision to make, based on many factors, the biggest ones being: (1) do you need to dynamically configure or replace parts of your loop logic? Then those parts can be method references or lambdas which are passed in, and assembled in a stream pipeline. And (2), do you need the to computation to be lazy? If so, streams can do that. But more often that's not the case for either of these two points, and a loop would be a way more straightforward (and better performing) solution.
The table of Docker terms and comparisons was nice.
They're implicitly public (but the interface itself can be package private). From [the docs](http://docs.oracle.com/javase/tutorial/java/IandI/interfaceDef.html): &gt; All abstract, default, and static methods in an interface are implicitly public, so you can omit the public modifier. Which are the only types of methods you can define on an interface.
yeah I agree with this. those other dudes are trippin
I'm also jumping on the configuration control boat. In my/our world, being able to have the exact configuration that was used to run an experiment is invaluable in terms of reproducability.
[removed]
Saying "any type of distributed system" is a bit misleading, because there's a bit more variety in distributed systems nowadays, other than Raft + custom business logic. Distributed systems are also often designed for availability, i.e. servers or specialized clusters, which can operate autonomously until a partition is resoled, even if they're not the majority. 
Take a look at vaadin they have a WYSIWYG editor and creating a ui with it is really simple. 
Good call - nearly any type of system where strong consistency is needed (which implies sacrificing at least some availability.)
Ok. Perhaps I need to do my homework better. I will fix my article if that is the case. But can you clarify what you mean by "Docker on Windows"? Because the one I use (Docker toolbox) has certainly a VM inside...
This subreddit is: 1. not a place to ask programming related questions as the plenty hints on the page indicate 2. not a second opinion for *Stackoverflow* (and neither are the other, Java related, subreddits) **Post removed:** programming help/second opinion for SO
Thanks. I spent a great deal of thought on this.
I'm using the Windows 10 version. Its pretty cool and works well. The containers are run in Linux.
Good to know... Not sure I get the note at the bottom then. Thanks for sharing the rest!
What happens when user changes system's font size or DPI? You just set everything to fixed values. That is no modern UI, it should be scalable and obey system settings.
You still can! Its just the next stage. Docker allows you to host each microservice on the same port...well, you dont need to worry about the port, just host it. Then each different microservice is accessed by a different IP. This way, you can scale your microservices by starting a new container....and, not have to worry about configuring ports, etc., in theory things just work
The Docker Toolbox and Docker for Windows are two different technologies. From [Docker's website](https://www.docker.com/products/docker#/windows): &gt; DOCKER FOR WINDOWS &gt; &gt; An integrated, easy-to-deploy environment for building, assembling, and shipping applications from a Windows PC, Docker for Windows is a native Windows application with a native user interface and auto-update capability, deeply integrated with Windows native virtualization, Hyper-V, networking and file system, making it faster and more reliable than previous ways of getting Docker on a Windows PC. &gt; &gt; Requires Microsoft Windows 10 Professional or Enterprise 64-bit &gt; &gt; For previous versions get Docker Toolbox Docker Toolbox does use Virtualbox. You should really update your article, as you have several paragraphs in your "Target audience" that make a big deal of this: "Compared to the JVM which is OS agnostic, Docker is a step backwards", "a major Docker disadvantage that nobody talks about is that Docker is OS specific", etc.
That's a good question, and I am no expert, so please find out :-). I only just learned this myself, having never used Docker. Thanks for writing this article, I'm learning a lot. p.s. I edited my first comment to delete the part that made it sound like I knew what I was talking about, "... This is all simply not true..." Sorry for writing it, I was in a hurry.
I suggest you to watch this talk: http://www.infoq.com/presentations/Are-We-There-Yet-Rich-Hickey
No. Martin Fowler has some interesting ideas but just like any human sometimes he's full of shit.
Yes, with Docker Compose you can run all of your external services and give your java container access to them without opening them up to your CI host or any other jobs running on the CI host. You can even support concurrent tests of your same project by making the project name unique (including the build ID in the project name, for example). This will prevent concurrent docker-compose commands using different copies of the same project from stepping on eachother's toes.
Interviews are a two way street.
You're making a good choice and I think you will find it worth it. You'll code more in that bootcamp than maybe your entire college career.
Sounds kludgy to me. Like an anti-pattern. [Hey, check out this great way to do what already works great, it's called a stream, even though it's not really a stream wink wink. To customize it just blah blah blah. Even though that's not intuitive and probably not performant, hey it's modern and it will probably change to something better (read newer) in 2 or 3 years anyway!]
You are correct of course. I actually hint about this in the article but did not want to go into too many details as this was a "big picture" article. However war files are typically smaller, so with a careful Docker layer strategy you just reach the level where WARs are already.
Thanks Actually we are saying the same thing. The article is not about "don't use Docker for Java". The main point is "use Docker if you need it but it is not as revolutionary as people around will tell you". 
Here's my take on Docker. As another poster mentioned, it's awesome to be able to run "git clone" then "docker-compose up" and have a fully functioning environment with Java app, web proxy, database, elasticsearch instance, and selenium server. Depending on the Docker Compose file that was used I am passing in various environment-specific properties for dev and integration testing profiles. This is helpful because development and build environments can use the same container setup and when finished they can be easily torn down. For your dynamic hostnames in addresses you can simply specify the name given to your Docker container and because they're all under the same Docker network you don't have to worry about how they'll talk to each other. There's probably some things I'm forgetting but feel free to ask any other questions about the setup. It's very helpful for me and my team!
Is there any part of your code that assumes an order wont change its lineitems while they're being worked with? Is there any expectation WITHIN an order that if a lineitem is added or changes that anything else about the order should change? If not, do whatever you want. If so, the purpose of addLineItem is to ensure that your objects cant end up in wierd semi-valid states you dont expect.
There's MVC in the tradition sense, then there's MVC in the REST sense. hibernate / ORM allows for chaining of Objects / Tables that make it easy to reference through classical means via Struts, JSP, etc. REST, I've always viewed as light-weight, essential only data. REST has broken our ORM structure and really cannot use our ORM structure because the nested mappings to objects / other tables cannot be converted to JSON through the given means. Instead we're writing more specialized questions to deliver data to customized DTOs. Many of the REST calls we have only need 1/4 of one table but also maybe a column or two of another table for everything to deliver. These queries outperform classical Hibernate, even with the Transform class being applied. This probably doesn't work the best for everyone, but it's what's working for us. It's also helped us in designing better tables for NoSQL (Cassandra) to make sure we're getting exactly what we need and creating that data from the multitude of data sources that we have.
Same here
 I'm trying to suggest your default be docker and to deviate when required. You're saying somewhat the reverse, which is don't use docker unless you need it. I don't think anyone "needs" docker, it's just a better pattern that doesn't tie you to a specific technology (other than docker itself, but it's a higher level abstraction than the JVM.) The second your infrastructure is 20 websphere installations cause it's all you needed is the day it's too big to change your mind. Node, go, ruby, python they're all going to have to fight against the momentum of not only your culture, but the massive investment in existing infrastructure and deployment of the java EE ecosystem. By infrastructure, I don't mean EC2 instances, I mean all the devops pipelines required to build test cover and deploy. This is why, in my opinion, you just build a container and deploy to a homogenous cluster that just runs containers. Doesn't matter what those containers are running, nobody cares. Source: java / C# / go engineer in a 40,000 person company. That all being said, docker does create some new problems (as you mentioned) but those problems are better problems to have than the alternatives. 
In my experience, the people who are happy deploying wars to big existing tomcat or websphere installations haven't, in general, seen docker favorably. It's been true, in my experience, in the .net land as well. The people who really love building websites and putting them in big fat IIS webservers have been mostly ambivalent towards containers. I disagree, but they do have their upsides. 
[removed]
[removed]
[removed]
Този thread е за въпроси и коментари към уводните курсове за Java и C# на SoftUni. Чувствайте се свободни да използвате псевдоними, целта ни е платформа за задаване на въпроси без притеснение. C# специфичните въпроси които не са полезни и за Java курсистите, моля пренесете в съответен subreddit за C#.
To save anyone else the effort, Google thinks this is Bulgarian: &gt; This thread is for questions and comments to introductory courses for Java and C# to SoftUni. Feel free to use aliases, our goal is a platform for asking questions without embarrassment. C# specific questions that are not useful for Java students, please bring in appropriate subreddit for C#. Given the almost complete lack of other activity on the account, I'm going to assume spam unless proved otherwise.
Pretty much. There are so many other things you can do with Java as well :).
Good, thanks :)
Rather than approaching it from an object oriented DDD aggregates and entities style - sometimes you can use a more procedural/functional style where the data model is pretty dumb, but there are domain services that ensure the model is updated in a way that maintains consistency. Your web controllers then just convert HTTP requests to method calls on your domain service objects. So your OrderService could have a method: addLineItem(orderId, LineItemDto) which would run any validations then directly insert a LineItem into the database without necessarily needing to load the Order. I don't consider this anaemic domain model, but rather a separation of the data model from business rules. It may be a little more procedural and a little less encapsulated, but it makes working with persistence tools much simpler. 
Some libraries (MyBatis) have ability to keep the actual SQL queries in a separate XML file. If you keep the SQL syntax in a CDATA tag, you can keep your pwetty formatting too
Even if it wasn't, Java is a good base. It can help you learn many other programming languages quickly 
Thank you guys for the suggestions! I will look into the books!
Why would you want to use webstart at all? 
Really? No one you know uses AWS, or Heroku, or whatever? Because those are containers. Most hosting services have virtualized the hosts they give you one way or another, a great many with containerization. Many developers are Luddites, so it doesn't surprise me that there are still people installing stand-alone servers with 20 year old web servers on them, but to say most Java developers are working this way --- that's just not credible. 
See if you can find some tutorials on libgdx, slick2d or jmonkeyengine
The idea of domain modelling is to couple data with the rules for handling that data. That allows you to enforce data integrity. That is the definition of domain modelling. Separating them is the definition of anemic domains. It can be convenient, and some say even say a bear practice, but let's not mix terms. You are explicitly talking about anemic domains. 
Not my choice and I have zero experience from troubleshooting java-related issues. The jnlp-files looks however to be a set of links, would it normally work if I manually download all the jar-files which the jnlp-files references and place them locally on the client and then run the first jar file listed through java directly such as: java -jar file.jar Is the above normally a valid workaround if javaws is missing or do I have to continue to dig for javaws explicitly in order to make these apps to work?
Oracle themselfs are killing the java plugins aka applets within webbrowsers: https://blogs.oracle.com/java-platform-group/entry/moving_to_a_plugin_free
By your question, did you mean whether Chrome no longer supports Java applets? If so, the answer seems to be yes: https://java.com/en/download/faq/chrome.xml Besides, all the major browsers are trying to ditch applets if they haven't already. As for a workaround, maybe GWT might do it?
So will they replace it with something else and why are they killing it off? There's no substitute for Java applets in webpages. 
&gt; There's no substitute for Java applets in webpages. What are you doing with applets that cannot be done with Javascript?
I think you assumed lot more from what I wrote, that I didn't actually write. I didn't write, or imply, how many people I did or didn't know who liked the big EE installations. I can tell you. Ow that it was the minority. I didn't suggest a majority of java engineers behaving one way or another, either. My focus was very narrowly defined to the above. Did you mean to reply to someone else?
The jnlp file itself contains all the file names, but I don't remember whether it's a plain SE environment or it needs applet functionality. on the other hand, if there's any native libraries in there, you can kiss portability goodbye. Also, if there are many Jars, they probably need to be on the class path. 
They are probably using something like Nashorn or Rhino, what is Javascript runtime, but will full access to Java libraries and packages, with abstractions to create instances of Java objects, extend them and everything else, so if provided functionality in PhoneGap or similar software is not enough, I am sure that you will be still able to do whatever you want. Of course, it will be probably slower than just writing it in Java, but unless you want to write games for Android then it should not matter at all. 
Perhaps you disagreed with those iis and tomcat users. Read that way I would apologize for the confusion. 
Yeah. It's bullshit. Packaged as an icon != native.
&gt; This seriously impacts what I will be able to do with the language if a major browser has discontinued applet support. Applets have been stagnant for a decade and officially deprecated for over a year, you should inform yourself a bit more often about key technologies relevant to your business. Not just applets, but [browser plugins in general](https://blogs.oracle.com/java-platform-group/entry/moving_to_a_plugin_free). Didn't you notice back in 2007 when the iPhone didn't support browser plugins? What about the iPad in 2010? What about the Android platform also dropping plugins in the next few years? And when Windows 10 came out, Microsoft Edge also dropped support for plugins. You've had 10 years to pivot from what seriously impacts you. Anyway, it's never too late (I hope). Time to move to one of these: - JavaScript based browser apps. - Desktop / mobile apps.
This. I'm 100% in agreement with you, read my other comments here. I was only trying to elaborate on your original comment, not disagree.
My fault. 
It depends. If you want to develop a single cross platform app or a poc, there are many alternatives. If you want to create very high performance apps, NDK with c++ may be better in some cases. But if you want/need to have solid bases to create general purpose high quality Android apps, java is the recommended tool at the moment. As a professional Android developper, this is what I use. Kotlin is also quite interresting, but it is just a "shortcut" language that uses the same concepts as java and runs on the JVM. Anyway, if you learn java, you will get some high abstraction concepts that are also present in many other languages. Stay curious ;)
java sucks, php bro
cache?
I don't know why you got downvoted for providing perfectly valid information. Personally, I don't care for PhoneGap because I prefer to go pure native for the control you have over everything. Plus, it's faster. But that's no reason to downvote a helpful comment. 
have my upvote for lulz. But this is 2k17, PHP is old, now it's time for Visual Basic 6 to shime!
cash?
I don't know what Crockford's view about javascript being a functional language is, but it's certainly not. REAL functional programming languages are LISP and Haskell.
There are first class functions. There are monads. As far as I am concerned that hits enough of the check boxes to say thats a functional language.
To be fair JPro isn't fully "in the browser" it's in the server with sessions. It's not in production yet and has no pricing information even. It improved by leaps and bounds in recent versions but it's still not what you'd call "fast". If we are talking browser based and performant I'd mention http://teavm.org/ which runs in the browser, is small and stable.
&gt; Instead there are a set of service objects which capture all the domain logic. These services live on top of the domain model and use the domain model for data. Yes you're right. According to Fowler's definition this is exactly the anaemic model. I guess my issue is with Fowler (a self described object bigot) dismissing this as an anti-pattern. It's incredibly practical, and pretty much the only way to implement systems when not using OO languages. 
Applets in web pages is a monumentally bad idea. They are unnatural and unnecessary in the modern web. Forget such things ever existed. You do not need it. Anything you could do with JavaFX, you can do in modern JavaScript and HTML, SVG.
Well that does make it an OO anti-pattern. Also, you can bolt on a OO layer onto any language. 
I fully agree. Performance and control wise, using Java is best. But, if you are forced to make Android application in really short time (what is, unfortunately, my case right now) then using things like PhoneGap is real life saver. Not saying that I am using it yet, but learning it, because I need to use it. And yeah, I am not sure why I got downvoted, and also, it is funny that the least useful answer got most upvotes.
/r/lolphp
**Here's a sneak peek of /r/lolphp using the [top posts](https://np.reddit.com/r/lolphp/top/?sort=top&amp;t=all) of the year!** \#1: [sleep() returns 0 on success, FALSE on error, or when interrupted by a signal returns number of remaining seconds except on Windows where it returns 192](http://php.net/manual/en/function.sleep.php) | [24 comments](https://np.reddit.com/r/lolphp/comments/4em0f9/sleep_returns_0_on_success_false_on_error_or_when/) \#2: [PHP and ISO 8601 (from php.net, link in comments)](http://i.imgur.com/ASxdrrF.png) | [11 comments](https://np.reddit.com/r/lolphp/comments/4oacnc/php_and_iso_8601_from_phpnet_link_in_comments/) \#3: [The default PHP session lifetime is 24 minutes, or 1440 seconds, because if it were 1440 minutes, then that would be exactly a day](http://stackoverflow.com/a/37176824) | [11 comments](https://np.reddit.com/r/lolphp/comments/4jhpv0/the_default_php_session_lifetime_is_24_minutes_or/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/5lveo6/blacklist/)
So if the content of the jnlp-file is something like this (parts which I assume would matter): &lt;resources&gt; &lt;j2se version="1.2+"/&gt; &lt;jar href="lib/1.jar"/&gt; &lt;jar href="lib/2.jar"/&gt; &lt;jar href="lib/3.jar"/&gt; &lt;/resources&gt; &lt;application-desc main-class="com.example.app"&gt; &lt;/application-desc&gt; The syntax would become this? java -classpath 1.jar com.example.app Also should I assume that the jar listed first within the jnlp-file is the "main" one? And how do I find out which directory on the local client the jar's should be placed in, is there some environmental variable readable through "export" (on a linux system) I can look at or should it be in the user home-directory (or does it matter)? Like if I download 1.jar, 2.jar, 3.jar and place it in /opt/app then this "should" work? java -classpath /opt/app/1.jar com.example.app
JavaFX does not use a browser plugin. It uses an entirely different mechanism to run apps **from** a browser. (Note: I didn't say "in.") When you click the link the app is downloaded and then run on your desktop like any other Java application. It is cached on your desktop so it can also be run when not connected to the Internet. Look up "JavaFX web start."
I tried to use spring once and I found that it has no real purpose. on top of that, it's bloated, and over complicates very simple things. personally, I don't think I'll find myself using spring for anything, ever.
There are other ways to accomplish loose coupling than DI. Specifically, message passing. 
Use Java with Vaadin or GWT.
There are a number of ways: Rx, Vert.x, etc...
Vlad is back! 
I would think the test is to find your problem solving skills. If you are good with core Java, you should be fine.
What's a case study and how is it different from other technical interviews you can see on geeksforgeeks or careercup.com? Usually Java means you don't need to worry about memory so it should be fairly simple unless they ask you a difficult algorithmic question. 
I am actually a developer at vanguard. The case study is a software engineering case study. You are given a fake "request" from a manager for a piece of functionality. Then you explain your line of thinking in where you would go from there. Its really not that bad as long as you have learned the basics of software engineering, software quality, requirements testing, things like that. I don't want to give to specific of an example. But it would be something like "You are asked to design a feature that meets requirements x,y,z". There is no actual coding in the case study, all problem solving. Other than that it is fairly standard Java and software engineering focused questions I think. Not nearly to the level of something like Google or Facebook. More similar to something like Lockheed Martins or other large enterprise corporations.
How is this related to java?
stackoverflow.com
I would re-evaluate that position. I have found that since I started using message passing, the need for DI in my code has disappeared. 
Not at all, I appreciate both vanilla Java EE and Spring technologies.
Docker itself might not seem useful, but docker composer and things like kubernetes are very useful no matter what your perform is. Docker composer allows you to bring up multiple containers, so alongside your project you can start a database, an Apache front-end, an MQ broker, a nosql service etc. Useful for individual developers to have their own environment based on a small yaml file that will be consistent every time. Kubernetes allows you to deploy to live and staging without worrying about how that's done. It allows you to stop worrying about individual servers as any faults are autohealed and services migrated. It allows you to scale quickly and easily. It allows you to do rolling deployments with ease. 
Great! As a junior dev this was nice! Added a few Them to follow!:) actually Read a few java books that I reslly likes! A few of The authors are in this list! Many thanks
Or maybe everything gets downvoted.
they say you can only actively keep up with the happenings of 100. why spend 40% on one thing
lmao I know the headline is just a little weird
Isn't it the same idea as a list of recommended authors or film directors or artists? "These people have done some worthwhile stuff before in an area you're interested in. You might want to keep an eye on what they say or do next." Nothing particularly "now" about that; it's just more efficient to keep tabs on their latest work than it used to be pre-Facebook/Twitter.
Yes, there's (ex?) Java EE-evangelist armies here. /u/henk53 is one of their general, he will always comment/post on how great EE is no matter what the reality.
The Java programming language is just the starting place. You have so many Java-related frameworks that you need to use, so it makes sense to follow the leaders of some of these projects.
Are you able to give examples to back up your claims?
There's the @omnifaces handle to follow on twitter ;)
Why not do both? The open-jdk mailing list is a great source of information. Some people on that techbeacon list are a great source of information and/or opinions. This subreddit is a good source of information and/or opinions. Aggregators like DZone are a great source of information and/or opinions. *"better"* - sure, that's your opinion. *"just"* - I disagree, you won't get the full picture...
I must say, I have had some of the best interactions on Twitter. YMMV (or you haven't tried)
Yeah, definitely. His libraries are a great example of clean, easy-to-use code that doesn't assume the developer's use-case (which I think is very important). Lots of the stuff he maintains are useful for non-Android devs too, like OkHttp, Retrofit, and Gson.
this reminds me of those tv segments where people say they dislike obamacare but like the affordable care act.
I have heard that swing is inferior to other languages in building a UI. What is your opinion on this?
Build HTML with thymeleaf or some other templating library, then use the wkhtmltopdf binary to convert it to a PDF. 
I've used both, but I prefer PDFbox for some reason... I'm not exactly sure why, probably just familiarity.
Huh?
Pdfbox is the only way. Don't waste your time with itext or icepdf, been using pdfbox for years it's the only choice
I don't see a problem with iText and its licence. You actually want to modify iText ITSELF?? because only then the licence kicks in.. Also does PDFbox has a licence limitation? Can you expand a bit on this?
Care to comment why it is the only choice?
This is only good for some needs. It is difficult to have fine control over the output of wkhtmltopdf. I found it unusable for reports because I just couldn't control the tables and they kept getting cut off or paging weirdly. It is just too many layers.
Haha thank you for pointing out where the actual library is lol
Because itext is no longer GPL and the last GPL version of it has not been maintained for 5 years. If you have money for the license then fine.
Being a developer just outside of college, the biggest thing that my mentor has taught me is how to design and develop software. I learned plenty of tricks throughout college whether it was at my internship, by myself or in class. However, we were never encouraged to follow any engineering processes when we did out homework -- we were on our own after getting each assignment. I've found that there are some issues with the mentors themselves also. I've heard of coworkers being given really simple, small projects and it makes them seem like they were code monkeys in the eyes of their mentors. If you lack trust by not giving out challenging assignments and don't talk about the big picture to newer developers, then they will not grow into a capable engineer. Anyone can poke fun at Java and say that it's slow because of its garbage collection, but I can guarantee that those people have never tried to replace the garbage collection with a C-based memory manager -- I don't think Java is necessarily slow with garbage collection, but it's a constant concern of developers. My internship was great. I learned a bunch of design tricks from my mentor and was given tasks that were almost overwhelming at times. Now I'm a full time software engineer in the same team and I get to design and write major components for our application. Also, attention to detail and overall consistency is a huge problem that I see in a lot of developers with way more experience than me. My team is having a hard time solving a consistency problem with the devices that our company produces. The devices do not have standard means for accessing the same, exact data -- the devices have inconsistent firmware versions and the devices themselves aren't consistent with the other types of devices. That inconsistency is not the fault of junior developers and hostetcl is kind of full of it. I'm more concerned with developers that no longer care about their jobs when it comes to attention to detail and consistency.
Interesting read.
Not unusual, we have tonnes of old mainframe (especially for batch processing of transactions) at my old work (Banking as a service company) - They mostly ran Informix/DB2 and speak to the core systems, with a java interface between them and the rest of our stack (90s SOA Java style apps with lots of EJB, service buses, and SOAP/XML)
Same here. But at least they run DB2. 
We've used extensively both PDFBox and iText to process literally million of pdfs. PDFBox crashed randomly in the past, while iText has been very stable. For some operations one or another have a better API, but in the end you can just write a wrapper layer which does what you need.
Make sure they don't ask you something they could have asked Google.
I've always used XSL-FO. Not because Apache Fop rocks (it's more than dead), but because I really like using XSLT for generating all sorts of documentation output rendering.
I'm actually part of the Java EE Guardians mailing list, but I still use Spring in my current project. A lot of hatred is based on confusion. Java EE: The application server / container infrastructure is not exactly the same as Java EE: The specs / libraries, such as JAXB, JAX-WS, JAX-RS, JPA, etc. My current project uses Spring (Boot) with Apache CXF for Java EE JAX-WS integration.
Spring Boot + Angular project generator with lots of security/db/configuration options: https://jhipster.github.io/ Note, you'll get plain spring-web-spring-data backend that is fully-customizable, but at least you'll have user management out of the box: https://jhipster.github.io/screenshots/
Recently I was working on a project that needs to generate a PDF with many charts and tables... We tried lot of open source PDF generators, but the best that worked for us is phantomJS. It's a powerful tool to generate a pixel perfect report.
Consumer motherboards usually have virtualization extensions disabled by default. Run CPUID and check. 
&gt; Used internally, this department had upgraded to a machine that, unfortunately, couldn’t connect to their IMS database. To give you some idea of the age of this technology, IMS databases are hierarchical, not relational. Hello Mongo. Seriously though, my roommate lives in IMS databases. They're trying to convert to relational, but it's slow going. Whenever I want to hurt his brain I start talking about MongoDB design patterns. Having dealt with 20 year old hierarchical databases, he can't imagine why anyone would voluntarily go back to that. 
I agree that has been the case lately. Hopefully things will get back to normal once the "novelty" of the election wears off.
JSF ;) There's a kickoff example application that does registration, roles, password etc here: https://github.com/javaeekickoff/java-ee-kickoff-app It's a good start to build your own application on or to see how those things are implemented.
We are currently using Spring Boot + Angular 2 (with Webpack and TypeScript), this is pretty decent. 
Good to know... Thanks for sharing this information...
Nice information..
Fop2 also uses pdfbox under the hood afaik. It's great for PDF reports.
[removed]
Sorry was a few beers deep last night and didn't feel like going into more detail. A lot of my work as been pattern matching and finding exact coordinates of words and sequences in a PDF. I started using iText as it has a lot of this functionality built in. Although it looked promising, it was hugely inaccurate, inconsistent, and couldn't handle a lot of the cases that pdfs can throw at it. In the end I scrapped iText and rewrote everything in PDFBox and life was MUCH better. It required more work as PDFBox doesn't have the feature set iText does but it is consistent and accurate, which is what I needed. 
So how affordable is it to maintain a solution that is several decades old? What happens if there's a change in business logic, or a piece of hardware fails? Isn't using the service of increasingly niche experts, and increasingly niche hardware more expensive over several decades? What will happen in the next decade or two, unless you migrate away?
The thing is that these mainframes are handling billions of dollars a day I'm transactions. It's safer to maintain than to rewrite, which will take years and cost tens of millions of dollars. And the risk is way to high.
Anemic Domain Model, as used by Martin Fowler, mainly means data-only, usually with ye olde getters/setters, but without any other methods that provide derived or calculated things like order.getTotal().
The old 60s mainframes are built like tanks and are user serviceable. The logic cards are literally discrete components the components of which can rewrapped/resoldered. Integrated circuits were still kind of a novelty item and we're not in common use until early 70s. Their biggest problem is with the power bill, real estate costs, and finding people who understand them. I've heard of mainframe rooms just being locked up and never opened again when people no longer use them, is easier to lose the key and pay the real estate costs than find someone who can understand them enough to disassemble them. Some of the old ones should be classified as toxic waste....
I asked a serious question and I'm expecting serious answers, instead of non-sequiturs and low-effort comparisons to web frameworks. No offense.
&gt; A team working on a service that deals with other companies making trades through us had an issue one elevation. It was down for about 2 hours. We lost somewhere around $200 million, or for effect $200,000,000. I understand the stakes, and that's precisely why the explanation that you'd rather keep going with archaic hardware and software, without gradually doing a no downtime transition doesn't make sense to me. Are those mainframes even redundant? What happens if one crashes and burns. What happens if the entire room crashes and burns? Modern redundant globally distributed architectures are ready to stay up even if someone drops a nuke on one of your data centers. &gt; There is a slow but steady shift towards unix, and java and getting off of db2/cobol into oracle/microsoft sql, etc. But it is way way way to risky to jeapordize the entire business. spending a a few ten million a year on maintenance is nothing. You might think its crazy expensive. But when we are talking about trillions of dollars, its really not. You keep bringing the talk back to big numbers, but the big numbers are not at all what I'm questioning, but the lack of transition. Which you just made a mention of, for the first time. &gt; My company has multiple trillions of dollars in assets. That is a hell of a lot of risk to replace something that has worked for several decades just fine. "We shouldn't risk what once worked" is precisely how corporate giants grow obsolete and fall. You probably wouldn't implement the same concept with your management structure. What happens if your CEO gets a heart attack and passes away? Do you have a succession plan? Is the person to succeed the CEO receiving training and getting growing responsibilities in the meantime, so the transition can be smooth? It only makes sense all of this is happening, rather than dropping someone from another company with zero clue to reign chaos, once that heart attack happens, correct? Once again, it's just change management 101. And change management becomes crucial *precisely when millions, billions, trillions of dollars are at stake*.
That could become 30,000 lines in Java.
In that case, I would take a look at HexPDF, which is a wrapper around PDFbox: https://github.com/heksemann/HexPDF &gt; HexPDF is a simple Java class making it easier to use Apache PDFBox for creating pdf documents from your Java application or web-service. HexPDF adds stuff like automatic page adding, word-wrap, newline awareness, left/right/center text alignment, table creation and image insertion. It isn't very powerful, but lightweight and much easier to use than PDFbox directly.
I wouldn't say it's like *that* the whole way, but I would say it's a terrible book. I kind of get the impression that the author was struggling with the limitations of what Wiley put on him, but that's conjecture. One of the biggest problems I had was that he presupposed that the reader uses Eclipse, which is a terrible IDE. Unfortunately, I don't really have a better suggestion. I took the basics from that book and used Stack Overflow to fill in the gaps.
I've tried with the Java for Dummies book and failed. I think that it is horrible. It is absolutely inefficient and doesn't go deep enough in anything. I don't agree to /u/anorman728's stance on Eclipse, because I think that while not being the best it is still a pretty solid IDE and quite often the standard IDE in companies (which is currently and hopefully changing towards IntelliJ). I would suggest the free online MOOC [Object Oriented Programming with Java](https://mooc.fi/english.html) from the University of Helsinki as a learning resource. It is very thorough, covers a wide range of topics, goes even into some more advanced concepts like data structures, is text based, and has graded exercises.
Personally, I think that if you are a true beginner wanting to learn the basics of programming, find an online class offered at your local community college. That way you have a formal learning process and plenty of help if you need it, plus you get credit! Something like 'Programming Fundamentals 1' is the one you want.
Cheers, I'll take a look :)
&gt; What's a good alternative to eclipse? [IntelliJ](https://www.jetbrains.com/idea) - the Community Edition is free.
Not who you responded to but I feel like I can add to their response as when I graduated college 5 years ago, I wondered the same thing. My time at the company has taught me this. The main outlets of mainframes continue to be within the financial industry. Interfacing with a front end can be done however you want, but the back end batch processing power of a mainframe is still very capable of handling today's data set sizes and for the foreseeable future. The business logic in the financial world is extremely complex and as a result is extremely difficult to replicate should you have to rewrite an entire system. To add on top of that, at least at my shop, we have 60+ systems working together to get to our end result, most of which would require a major change in pipeline programming just to get to speak to a new system should we decide to write a new one. Now say we finally decide to do all of this an have a plan to perfectly execute it. We then have to get approval from the c-suite to put in something this big. It's going to crash and burn there unless there is some circumstance to where the system literally cannot go on the way it is. I still remember asking my boss these questions when I first started and what he said, "We're a financial company, not an IT company. To the business, IT is an expense." The CEO doesn't care how the system works or what language it's in, they just care that it works. When they go to board meetings and are laying out the financials, they can say we're spending 10 million this year to keep our systems up to business practices, or they can say we're going to spend X amount of years to get a system where it was X amount of years ago (read as today) and spend X amount of dollars. Like to original commentor said, it all comes down to what the business wants and since they really only care about getting the results, changes are highly unlikely in our world. Now all of that being said, I would love it if we started modernizing our systems as I know we could cut back on so much wasteful maintenance spending and time required to develop and deploy. But since our system is still very capable of handling our load, it's very unlikely I'll see that day come because of the reasons stated above. Edit: changed last sentence in third paragraph to be more readable
The answer, I think, depends on what you're trying to optimize. For me, I normally focus on decreasing GC pause.
The problem with Eclipse is it has a bunch of irritating popup messages, autocomplete, autoreformat, etc. They end up being much more distracting than anything else. I find plaintext editors to be much more efficient. I use Vim, which has a high learning curve, but is really smooth when you get used to it.
&gt; It just holds little dumplets of information which happen to be small unindexed trees, but as a whole, it's a bunch of flat dumplet sets. Yep, that's how my roommate describes the database he's working on.
Converting between DTOs and domain objects is almost always a good idea. DTOs are used to pass data between system boundaries, which a REST API certainly is. They have no behavior and expose only certain bits of data. The mapping between domain objects and DTOs allows you to control just how much data from the domain object is exposed to the REST endpoint (output DTO), or control what the domain object consumes to initialize or change state (input DTO). Otherwise, you risk leaking implementation details which makes it difficult to [protect internal state from external input](https://www.owasp.org/index.php/Top_10_2010-A4-Insecure_Direct_Object_References), or [expose data you shouldn't be](https://www.owasp.org/index.php/Top_10_2007-Information_Leakage_and_Improper_Error_Handling) for the user's access level. There might be mapping overhead, but the overhead pays for increased API security. This has nothing to do with ORMs, which manage persistence of domain objects. How you interact with the ORM is controlled by the methods available on a [Repository interface](https://msdn.microsoft.com/en-us/library/ff649690.aspx), in which you define the expected data access patterns of the application. This will allow more efficient usages not only of ORMs, but other data access technologies, like Cassandra (a badly specified query can take down a database node!). You get the best performance from any data store by predicting the kinds of queries you expect to run and designing your access and storage strategies accordingly. In any case, you should not be directly exposing the ORM to the REST API layer! Although [Spring Data REST](https://spring.io/guides/gs/accessing-data-rest/) disagrees with this premise. Check out [Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html)
Not to throw a wrench, but checkout Aurelia.
So do bugs that "outta be fixed" include making sure modules don't cause tools like Maven to explode?
There's such a thing as inertia in information systems. The more work product that relies on a given set of business logic rules, the riskier it is to convert that logic going forward. It's one reason why smaller businesses are often described as "nimbler" then larger ones. Billions of dollars and years of transactions aren't trivial to migrate across any systems- any project with that big an upside (to outweigh the massive risk) would be much bigger than just getting some POs and scheduling a transition window.
I'll be telling my children how in the past we used to have various kinds of data structures, but in the future everyone said "screw it, make everything a **string key -&gt; JSON value** store".
Ridiculous, suggesting Vim or any texteditors to beginners learning programming. Especially Java. Autocomplete and autoreformat will only bother you when you unknowingly hit a shortcut or need to change settings. This applies to any IDE and any texteditor to some degree. Your whole argument just sounds like IDE-hate and Vim-fanboyism.
I should probably clarify something because I accidentally made this get off-track (sorry about that-- responding via mobile, so I didn't put a lot of thought into it). The problem isn't that he chose the wrong IDE, because, as you can see, plenty of people love Eclipse. The problem is that he chose to require the reader to use a particular IDE, and a lot of the material required you use Eclipse-specific features without explaining how to do it in pure Java. The book is supposed to be about Java, but it's instead about Java+Eclipse. Using databases without Eclipse, for example, is not even addressed in the book.
Okay, that's asinine and not worth responding to.
Seems like he's making a (somewhat reasonable) case against ORM in general, not just ORM coupled with REST. I've recently moved from ORM to MyBatis, which has the "benefit" of writing custom/optimized SQL queries, while still making it easy to map back to domain objects.
Thanks for your answer, but you and most of the people that respond seem to understand my question as "why aren't you jumping to the latest hype/fad framework and tech at your decades old banking institution" and that's not the question I asked. Precisely because "to the business, IT is an expense", you need to maintain these systems and take advantage of technology that lets you reduce said expense, instead of settling with dealing with increasingly hard to maintain dinosaurs. And in fact, you do contradict a bit yourself, because while you say mainframes are around because anything else would be too expensive, you say "if we started modernizing our systems as I know we could cut back on so much wasteful maintenance spending and time required to develop and deploy". So where are we exactly at the end of this discussion? I'm afraid at square 1.
People won't even acknowledge that climate change is real. The U.S. government can't take action on hundreds of bridges that are at risk of structural failure, or deal with unsafe water lead levels in thousands of municipalities. And you're expecting private businesspeople to take risks and make sacrifices to update a computer system? Where is that push going to come from? Will it come from the engineers, who are handsomely paid and near retirement? Why would they want the risks of retraining or finding replacement work? Will it come from management and executives, who cycle in and out of companies every 5 years in search of advancement? There's nothing sexy or career-enhancing about major projects that only re-implement legacy, yet there is career-ending risk of a high-profile project failure. Even if such a project succeeded, it would probably take longer than the typical executive's 5-year window. You're getting into some real game theory stuff here. There can be every logical motivation for an *abstract group* of people to do something. But that's meaningless without motivation for *individuals* within the group.
My question wasn't whether it's "trivial to migrate". And yet if you don't migrate, at some point you'll be driven out of the market by your skyrocketing costs of maintaining this legacy and the outdated capabilities and safety they provide. As I said, a modern globally distributed architecture can withstand a nuke dropping on one of your data centers. Nothing can bring it down. A 60s mainframe is *essentially* like an oversized desktop Dell, but with parts that cost arm and leg, as they're nowhere to be found, and the power consumption of a small factory. The kind of excuses people have provided in response to my questions have answered only one mystery: why old companies are driven out of business by newer competition. And it's precisely due to poor change management like this.
The benefit of ORMs are abstracting away DB implementation. If you have to support a bunch of different database implementations, you might appreciate not having to write custom SQL for each one. It makes other DB-related tasks easier, too. Need a new table? It's an annotation or two away. The opposing argument is that ORM will probably always be slower than writing native SQL. It does make your app more brittle, since you'll end up being tied to a particular database implementation once you move past very simple cases. I usually end up doing both, with a strong bias towards ORM and straight SQL only when I'm doing something funky with stored procedures or really needs to be performant, particularly around inserts. ORM to REST is not a problem per se, and I would go that route without concern unless performance became an issue.
ORM entities are for the ORM and shouldn't be exposed anywhere outside the data layer. Use Immutables or something similar in all other layers of the app. QueryDSL SQL (ie not QueryDSL JPA) or JOOQ are better than ORMs in my opinion. They're very powerful and much better than JDBC but unlike ORMs also very transparent and simple.
According to the replies [here](https://www.reddit.com/r/java/comments/5pmczr/what_happens_when_you_mix_java_with_a_1960_ibm/dcsm08k/), those 1960s mainframes are actually the beez kneez, so emulating them or migrating away is some sort of newbie nonsense talk. I mean, I realize once someone gets into an organization, they unwillingly drink some of their kool aid, but that's something.
I didn't contradict myself, I was making the point that from an IT perspective it sometimes makes perfect sense to transition to newer technology, but when you are not an IT based company, the IT department doesn't make the decisions. That's why I made the point that the business side doesn't care how it works, just that it works. To them, it makes more sense to maintain than upgrade, that's all there is to it. 
Java is way behind the times now
But you also made the specific point that "to a business, IT is just an expense". So what's your point, that when told "you can reduce this expense", your boss wouldn't care anyway? Everything becomes obsolete and has to be replaced. Computers are not unique here at all. So it doesn't say as much as IT is distant from your bosses, rather than your bosses prefer to avoid short-term risk, by dooming the company in the long term, because they probably won't even be in the company by that time. And that's a really wrong and sad lesson to learn 5 years after finishing college. 
Yeah, I know dalvik (and now ART) as the VM of choice in Android. I didn't get where the "no" came from. If you want to wire up click listeners you're going to need some java. I've never seen an app that was just static content. Also, Xamarin isn't a cross compiler, it uses its own runtime. The app, written in C#, talks to the Mono runtime, and the Mono runtime talks to dalvik. It's not compiling C# into Java bytecode or dexcode.
Fair enough, and good point. I was trying for an ELI5 answer, but yours is more accurate. Also, I personally hate static apps because they're usually a waste of space, but they're there- usually just wrappers for somebody's home page to show off they "can make apps." I could see a use if you have important info you want available without eating up a data plan, but that's about it. 
It's not dropped, but it's going to be an 'incubator module' [1], meaning the API isn't fixed for Java 9. Which may be a good thing. [1] http://openjdk.java.net/jeps/110
You missed my point. I acknowledge there's a break even point, but my point is that it moves with the volume of data- which is more valuable than the processing power to collect it. Billions of dollars on the line means a SNAFU in the migration is *risking* billions of dollars. At that point, you need to *spend* millions on mitigating the risk with backups, redundancy, etc.- that's the break-even point, not just the cost of the future hardware.
&gt; Billions of dollars on the line means a SNAFU in the migration is risking billions of dollars. I'm sorry but that's just silly. You should maybe read a book on change management. You deploy the new system parallel to the old one and monitor it for a time. Aside from passing QA and test procedures, it should produce identical responses to the live production system. And if it does for a significant time, eventually you can migrate to it. There no situation whatsoever at which "billions of dollars are at risk". You may fail to go to production with the new system, but that won't do anything to your billions. &gt; At that point, you need to spend millions on mitigating the risk with backups, redundancy, etc.- that's the break-even point, not just the cost of the future hardware. Yes, you need backups and redundancy... I'm not sure why are you telling me this? This would be the case whether the system is old or new.
Whoever told you that has no idea about software design.
NetBeans is far less popular then two others actually.
If you are beginner, there is a nice Java book from Head First series. If you want something more concise, book preparing for oracle certification is good. I'm not saying that the certification itself is that useful though.
Anything significant that was dropped?
&gt; The fact that everything becomes obsolete is not a reason to replace anything. With that logic there's no point in implementing anything because it'll be obsolete some time down the road. Do you actually feel like there's "logic" in what you said? &gt; And as for looking for off the shelf products, a lot of the systems out there (including the four my group maintains), don't have an off the shelf option. I don't think I said anything about finding an exact off-the-shelf match for any of your systems. You're misinterpreting something I've said, but I don't know which part.
Okay, I have more time, so I may as well explain why you shouldn't make assumptions about people. When I first started learning Java (with this book), the only coding experience I had had was VBA with Excel and Access. I didn't even know what OOP was. I was very much a beginner. Not knowing anything about coding beyond for loops, I downloaded Eclipse, like this book said to do. It was a nightmare. Eclipse's autocomplete, autocorrect, constant flashing of messages etc. was extremely counterintuitive and distracting to me. Not to mention the information overload. Learning the weird behavior of Eclipse *while* learning Java and everything that I needed to know about OOP was too much. I tried other IDEs without much luck. I wasn't able to make any progress with Java until I dumped the IDEs and went with a plaintext editor. (Not Vim at the time-- That came later.) So, yeah, you can make the ad hominem arguments that you did, but there's a good chance I would have given up Java if someone had told me that I needed to use Eclipse as a beginner.
Do you know if LVTI is going to ship? It says its status is “Candidate”. http://openjdk.java.net/jeps/286
The partial solution is kind of disappointing indeed, but it's better than nothing and with Servlet 3 you can programmatically add your mappings. With OmniFaces it's really easy to add full support. The page does mention somewhere that JSF had a severe lack of people working on it, and that's probably to do with Oracle's blackout period. 
It's impossible for something like this to make a *company close* unless they were already near bankruptcy to start with, or there's extraordinary incompetence in their IT team. Most companies die due to *inaction* rather than *premature action*. And your reasoning shows why. Because inaction always seems more convenient. Until the very last moment, when it's too late.
Yea why I put the qualifier "true" in there. Effectively though they are dropping it from Java 9 as it would be ill-advised to write production code that depends upon such a provisional API.
You've been given about two dozen good answers and have ignored them all.
Why even doing that? Why not wait http2 and make a significant release
You don't need jview. Replace 'jview /cp' with 'java -jar ' and remove the second 'docsdiag' and it'll work. java -jar docsdiag.jar -vv | more pause 
Java for dummies was written for people who have never written a program before, and probably never should. In terms of programming an interface, I don't think it went beyond Sytem.out.println(). If you already know how to program in another language, Java for dummies us painfully slow and never gets to anything useful. I give Java for dummies zero rubber chickens.
&gt; The extra layer of converting between domain to DTO is not worth the effort [dozer](http://dozer.sourceforge.net/) or [orika](https://orika-mapper.github.io/orika-docs/) make that pretty easy.
Try Head First Java, Java A Beginner's Guide Sixth Edition, and then Effective Java. I have heard good things about all three of them and have used them personally while learning, although I did not go front to back on any of them.
The actual presentation cleared some of my questions up. Basically they are running the 7470 under an emulator that they wrote for the IBM system 360. So the emulator is actually running the code on a modern mainframe. 
It won't ship with Java 9 for sure. Hopefully Java 10. 
&gt; and I think C is much more widely used and adapted? Sorry, but here you're wrong. Yes, C is very widely used, but mainly on *system level programming* close to hardware, such as drivers, etc. Java is currently the most used programming language (and has been that for several years). If you want some language for desktop applications, you could move to C#. Still, the main point is to learn *actual programming* in *one language* first, program and practice a lot to get proficient, then moving on becomes very easy. In IT circles there is a saying: "Learn Java (or C#) and get C# (or Java) for free." While this is not *entirely correct* it holds to a certain degree because both languages are extremely similar (to the point where you can't tell which language a single snippet of code is from).
So, why are only Eclipse (current #1) and IntelliJ (currently #2 - but will soon overtake Eclipse) used in professional environments and the "oh so great" Netbeans isn't? Seriously, there is nothing wrong with Eclipse at all. I think (and the usage statistics prove it) that it is by far the better IDE than Netbeans. Don't come with the argument of the GUI designer of Netbeans now. This is a horrible abomination that does nothing but add unnecessary complexity to programs.
Awesome news, I'll use this right now in a project hat needs ldap auth on top of spring security.
*Head First Java* is a bit dated, but pretty good.
Have them read some of the classics. Pragmatic Programmer. GoF Design Patterns. Effective Java. Clean Code. Make them discuss some tasks they've done in light of this reading or similar things like that to bring the ideas into practice. Have their code be reviewed. Good code reviews for junior devs can be brutal. Be careful to not ruin morale. Make sure they have some tasks or projects that are sufficient enough in size they can own them and be proud of their work. Have them learn a scripting language that complements java in practice (Bash, javascript, batch, ant/maven, etc). Make them write some documentation about things--setting up a dev environment, guide to java packages in the project or things like that.
:(
I do more or less agree with him. REST interfaces often present views on data that are rather different from the underlying relational model. So there is often a stronger coupling between the view and the data than between a canonical 'model' and the data. When 'reading' from an API the mapping from a query result to objects is typically fairly straightforward when you tailor your SQL query to that view (rowmappers tend to work well by default). Often you can more or less directly pass the repository results into your controller. When you use JPA you tend to move the mapping 'logic' from your projection in your SQL statement to some 'glue' layer, often found in the 'business' layer somewhere. You can use HQL for this to get close but then you're building another layer of complexity into your application that you actually don't really need. I have used both JPA and 'plain' SQL (using Springs JdbcTemplate) in REST projects and I feel I'm more productive just writing the SQL myself. 
Is there a good list of what is coming?
There are a few people here who feel the need to make "Spring and JEE" into "Spring versus JEE". They are all tools, pick which ever one suits the project best. Creating such an adversarial tone is IMHO completely against what the great Java OS ecosystem is about; growing stronger together. 
It would be interesting to know how another strategy performs here. You could first read the CSV data into a list that supports efficient splitting (knows its size, supports random access. e.g. ArrayList) and then stream process this list. The workload would be split evenely in as many chunks as you have CPUs. So CPU utilization should be perfect. The downside is that processing can only start after the I/O operation is complete. The upside is that you don't have to figure out the optimal perfect batch size for every task.
how can it change a lot? It is just about a standardized way to represent money and work with it. Especially integration in existing frameworks is not existent. As with the latest date and time API we received a lot of support for it and deprecated `Calendar`. 
This seems unlikely; Youtube doesn't use Java at all. In fact, it's likely your browser no longer supports Java applets whatsoever (though you didn't post what browser you are using.)
I can't think of anything else that changed recently. I'm using Firefox and Chrome. It lags on both. Do you know what might cause this tho? It annoys the hell out of me, videos stutter, sound glitches out etc.
This submission has been randomly featured in /r/serendipity, a bot-driven subreddit discovery engine. More here: https://www.reddit.com/r/Serendipity/comments/5pvj1x/jdk_9_is_feature_complete_now_its_time_to_ramp/
I've been given 2 answers from people with experience in this (despite being at the lower levels and guessing a lot) and then around two dozen low-effort knee jerk reactions from people who haven't been in a 10 mile range of a mainframe.
&gt; just a facebook script for like button. That's how Facebook tracks you. &gt; can you please send me a screenshot ? Too much work and there's no point either: the button simply doesn't activate (stays greyed out and doesn't let me click it). 
You need to click to select answer and submit the question before continue to the next one. Regarding ads, Disqus loads their ads by default, I just tried to disable ads from my site, it may take sometime before the ads got removed. We added Disqus as comment service yesterday and they begin showing ads few hours ago. Anyway, thanks for your feedback.
Why not? Do you think a new Collections library wouldn't be useful?
Why would you need that in Java SE?
Why is the `java.util.Currency` existing? Or do you mean that everything related to money/financial should be in an EE spec? 
&gt; Recently Nada Amin and I discovered that Java and Scala are unsound. We submitted the finding and related discussion to OOPSLA, an academic conference on object-oriented programming. It has been great to see the paper making rounds in industrial circles, but there also seems to be a lot of confusion and I think that’s our fault. Anyone have a link to the paper?
&gt; Why exactly is Netbeans vastly superior? Because that's most likely the IDE that he has learned to program with. - Stockholm syndrome. People are scared of change. 
I'm not sure a new library would be necessary in either case. Generics over primitives will not need a new collections library to take advantage, they've been careful in the design so far to make sure existing libraries will be able to leverage the changes. It's one of the primary goals of Valhalla and having followed fairly closely so far I see no reason to expect they won't achieve it. As for this feature, we don't even need immutable collections to take advantage of the extra variance in element types, only immutable *views* of the collections, as demonstrated by the static `Collections.unmodifiableCollection` methods. Possibly it would be considered too complex a change to introduce a load of unmodifiable super-interfaces to the collection interfaces with more permissive type parameter variance ... but it would certainly be a less intrusive solution than a whole new collections library.
The author makes the following argument: &gt;No, your compiler isn’t catching the bug. In fact, your compiler itself has a bug. Your compiler is broken. The Java specification says this example should type check and compile. Your compiler is supposed to implement that specification, and it’s failing here. I'm having a hard time following the argument in the bug fix... This seems to be their reasoning: &gt;Going back to the connection to 'null': yes we may 'assume' that 'T &lt;: Z' and 'Z &lt;: U', but for most instantiations of T an U this will make Z an uninhabitable type. So without any constraints on T and U, there cannot be a legal value of 'Constraint&lt;T, ? super U&gt;' other than: null. And since we can't invoke any methods on null, type Z will never appear in any signature thus creating no conflict, thus far. Yet another way to describe the error: The invocation of 'upcast' would finally force 't' to have type 'Z', but since 'Z' may (for certain 'T', 'U') be uninhabitable by any value, and since 't' *is* a value, we have a contradiction, forcing us to reject the program. Why does t *have* to be a value? 
[removed]
Really, really hoping this makes it into the spec. As I commented on the mailing list when this was first proposed a few years ago, this could also allow relaxing of the rules about reimplementation of generic interfaces with different parametrisations. For example: interface Getter&lt;covariant T&gt; { T get(); } interface NumberGetter extends Getter&lt;Number&gt; {} interface DoubleGetter extends NumberGetter, Getter&lt;Double&gt; {} Putting aside the invented syntax for declaration site variance, `DoubleGetter` would also currently not compile since it implements `Getter` twice with different type arguments. Given the new variance rules, though, the compiler could understand that `Getter&lt;Double&gt;` is a valid subtype of `Getter&lt;Number&gt;`and permit the type. There are some issues with bridge methods and stuff in corner cases, but nothing insurmountable imo. This might seem like a pretty useless edge case, but it simplifies a lot of situations which currently require awkward self-bounding generics and stuff. It would also provide the rules and plumbing to allow us to have an implied covariant `THIS` type parameter, representing the type of the receiver, which is useful for designing e.g. type hierarchies of builders which have methods returning references to themselves.
Hahaha! On a related note, Chandler Carruth's talk on undefined behaviour was hilarious... and frankly pointless. C++ is beautiful for small snippets of code that you can twist to your heart's desire. For big projects, it's a veritable nightmare.
I used Eclipse for 7 years and switched to Intellij half year ago ;) Still can't do some stuff that were obvious in Eclipse, but hey, fun!
Finally the academics have weighed in. When will you all get the message and switch to node?
We discuss this in the comment section.
Some of us look forward to Maven exploding.
Me: Doctor, when I do *this* it hurts. Doctor: Have you tried not doing it? (yes I know, soundness in types systems is important...) 
/r/programmingcirclejerk
R is Dead. Coffee Script and Rust is the preferred language. Stop what you're doing and learn that instead.
Just to be sure: * OCA = Oracle Certified Associate and * OCP = Oracle Certified Professional? Might depend on the country, in Germany it is a non-factor. 
Now that’s a name I haven’t heard in a long time.
Who did you hear it from? Java should work fine on any machine.
Yes, that is correct. I'm taking them in the US.
&gt; I've heard the java on Win10 messes up your computer and uses up a lot of cpu and memory Should I download It or no? [citation needed]
Upvoted. You clearly forgot an "/s" in this message :)
I would have added the \s, but there's no time. R is dead. Apex is the preferred language. Stop what you're doing and learn that instead.
Also, you are a bit wrong in this statement: &gt; whenever get is called on a List&lt;String&gt;, the runtime checks if the returned value is actually a String in case a raw type was misused, throwing a ClassCastException otherwise. If you did not assign you return value to a String variable, you would not have an exception. The check is NOT happening on `get()` call. You can easily check it. For example, with my code just above this will work: System.out.println("To string is everywhere " + list.get(0)); if (list.get(0) != null) { System.out.println("Prooving you wrong"); } With your code it takes a little differrent form: System.out.println("That works: " + (Object)strs.get(0)); It is not a big deal, the main message of your article is still true. Just be more careful with the minor side statements you make. (I deleted and restored this message to make it more correct. Sorry for the confusion)
I tried that with the most recent build of OpenJDK (just grabbed from today's mercurial) and it compiles just fine. Both the author's snippets and the ones that I posted in this thread. jdk9dev$ hg summary parent: 2450:8d26916eaa21 tip 8172527: Rename jdk.crypto.token to jdk.crypto.cryptoki branch: default commit: (clean) update: (current) Perhaps I am not on the same page, but could you clarify which behaviour is no longer correct in Java9, please?
Some (but not all) of the undefined and platform-defined behaviours of C and C++ are *fundamentally required* in order for them to truly be languages that are "low level" and "native". For example, in both C and C++, the remainder of the modulo operation ("A % B") is platform-defined when either of the operands is negative. This is because different CPUs have different behaviours for their native modulo instruction. It would be contrary to the fundamental purpose of C and C++ to compile the modulo operator into anything more complicated than the native modulo instruction of the target CPU.
I have used Java on Windows 10 with no issues, including running executable Jar files.
Because `t` is a witness to the *un*inhabitability of its own type, hence the contradiction. Remember that "unsound" in logic means that your theory (type systems are logic theories via Curry-Howard) can prove that "false" is true, or in this case that an empty set (uninhabited type) has an element, namely `null` (always `null`!)
Who needs Quicksort anyway?
I do appreciate the addition of functional features in Java and the article is great, I'm just saying: &gt; Functional programming in Java 8... Oh, cool &gt; ...Functions as Objects (ಠ⌣ಠ) public static Integer compute(Function&lt;Integer, Integer&gt; function, Integer value) { return function.apply(value); } Syntax like this makes me want to switch to Haskell instead of torturing Java into functional programming.
Any thoughts on the performance of this as opposed to, say, simply looping over it?
Great, so you've stopped spamming your site, and started spamming your YouTube channel instead. It's still spam, please read up on Reddit rules to see what an acceptable self-promotion to other post ratio is.
 .section .text .global _start _start: mov 0x80, 0x42a int ; Prettied snippet up.
Using an ORM does not mean you don't have to know SQL or use native SQL statements. Otherwise, why would JPA offer the `EntityManager#createNativeQuery` which is a [Magic Wand](https://vladmihalcea.com/2017/01/18/the-jpa-entitymanager-createnativequery-is-a-magic-wand/)? There are some benefits of using an ORM as depicted in this chapter of [High-Performance Java Persistence](https://leanpub.com/high-performance-java-persistence/read#leanpub-auto-why-jpa-and-hibernate-matter): - extended identifier generators (hi/lo, pooled, pooled-lo) - transparent prepared statement batching - immutable entities (e.g. `@Immutable`) - querying the second-level cache by the natural key of a given entity - entity-level cache concurrency strategies (e.g. `Cache(usage = CacheConcurrencyStrategy.READ_WRITE)`) - versioned bulk updates through HQL - exclude fields from optimistic locking check (e.g. `@OptimisticLock(excluded = true)`) - versionless optimistic locking (e.g. `OptimisticLockType.ALL`, `OptimisticLockType.DIRTY`) - support for skipping (without waiting) pessimistic lock requests - support for Java 8 Date and Time and stream() - support for multitenancy 
I have to admit I don't fully understand what happens there, but it seems to depend on a null value. Then the idea is that you could easily have the convoluted type code by accident (I've written some pretty convoluted code myself to get generics to work in a tricky situation), and then all it takes is for an attacker to supply input that was deliberately crafted to provoke an unexpected null value in the wrong place. 
It's not the same. The OP produces the class cast exception without an explicit cast of raw types.
RTFA.
New account to push your book(s) and blog, Vlad?
With sql, you need to know sql and jdbc (or some lightweight framework to automate the tedious parts of jdbc). With ORM's, you need to know what I just wrote, the ORM-specific stuff. That list is a mix of things I don't need or care about, and things that are actually drawbacks of hibernate. It's second level cache does not help webapps, but does introduce a series of new hard to track bugs that silently corrupt your data behind the scenes if you don't understand how it works - something I found from unfortunate on the job experience. There's nothing in there you "cant'" do with sql and jdbc, and most of those with experience you don't want to do anyways. It's just a list of "sounds cool" things.
A ``map`` is **not** a tree - it just uses a tree under the hood for storing the mapping data. Since C++11 there is also ``unordered_map`` that is a hash based implementation of mapping. Using a tree is quite common for relational databases btw. Would you consider a database table with some index as a tree? 
Ever since I started to use Swing, I realized how limited GUI designers actually are and how bloated the code they generate is. Don't get me wrong, I am not completely against GUI designers, but they do have their limitations. Take a simple example: I want to build a calculator similar to an old [HP 12C](http://www.hpmuseum.org/12c.jpg). This calculator has loads of buttons. Hand-coding, I can use a list to store the buttons, I can use loops to generate quite a few of the buttons (especially the numeric ones), I can use methods to set some default properties (a bit like a very simplified "builder pattern"), and so on. When properly written, the code will become very clean and quite short. A GUI designer would build the complete code for each button from scratch. It would create lots and lots of variables and lots of nearly identical code. I dare say that the complete code would be at least 5 times longer than the optimized code from hand-coding. When working in other languages I thought that GUI designers are the bread and butter and the greatest thing ever invented. Only with Swing I realized what plain code can achieve. Again, since I don't have experience with JavaFX all the above is to be taken with a grain of salt, but I think that SceneBuilder won't be much different in that matter. I really have to spend some time to get into JavaFX. 
Interesting... There is a twitter snippet on that page that is not part of the article. On a hinch I opened an article in a different browser and it makes more sense now. Well, I guess this thread should remain unchanged now as an example of misunderstanding that may arise from a sloppy publishing.
I have discovered (sic!) two hidden twitter snippets on this page unblocking which made it more sane. Also, the parts you quoted is exactly the part that has a minor mistake in it.
Since this is help with Java **programming**, it should, as the many hints on the site indicate, be posted in **/r/javahelp** and not here. Kindly repost there. **Post removed:** programming help
Yup. They're almost like Lisp macros.
[removed]
&gt; This use case is also known, it's due to "type erasure" in the language. Most editors would warn the programmer about the practice. No, you're wrong. In a spec-compliant compiler the code will not even generate a warning, it's basically a bug in the language spec. And if Java generics were *not* based on type erasure it would in fact be much worse - then the bug would actually be exploitable.
No, it's not the *coffee* sub. It's the **News, Technical discussions, research papers and assorted things of interest related to the Java programming language** sub, but not the **programming help** sub.
Note that it does not have to be null. It is anything that can tell compiler that such type may exist. For example, an unsafe cast: Constrain&lt;U, ? super T&gt; constrain = (Constrain&lt;U, ? super T&gt;)(new Constrain&lt;String, String&gt;()); Or even more subtle Constrain&lt;U, ? super T&gt; constrain = new Constrain() {};
Hows Vaadin doing recently? I tried it a bit 2.5 years ago since I'm a GWT fan, but abandoned it later.
Very true. Thanks for pointing that out. It's a bit sad that the stream API is only intended and really useful for processing data that is already in memory. I haven't quite studied reactive streams yet. Maybe the upcoming Java 9 Flow API or RxJava are better suited. http://download.java.net/java/jdk9/docs/api/java/util/concurrent/Flow.html https://github.com/ReactiveX/RxJava
&gt; "Discovered" is sort of a strong word for something that is well known in the field. &gt; Even I, not being in the CS forefront, have this code in reddit history: But that's a different case, this is intentional, whereas the discovered unsoundess is not. At least as far as I understand it. 
What mistake did you point out?
Of course, but that's more about the lack of replacements than the merits of the language itself. Rust may be a viable candidate, but it will be an uphill battle to fight against the inertia that C++ has. &gt;While the two are solving different problems, the amount of bugs we produce is not that different. That sounds about right. The difference is that a C# crash will hardly ever do anything nastier than throw a runtime exception. A C++ crash could, depending on the circumstances, be infinitely more insidious. I mean, don't get me wrong. C++ is a great language precisely because no other language can currently do what it does equally well, but that's certainly no excuse for the many failings of the language itself. That's why the maturity requirement, as you put it, is so much higher for professional C++ programmers - only practical experience can lead to sane C++ code, not like safer and newer languages where the spec more or less balances the scale for the most part.
&gt; Also while in some cases an ORM might detect the relationship between rows (as in the parent-child example here), in any complex denormalized scenario, the ORM is helpless to detect the relationship, so then you're back to having to think about it yourself. ORMs are suitable for OLTP applications. Denormalization comes as a trade-off. Either you're scaling Facebook or Twitter, or you are running an OLAP workload. &gt; Because the moment you start mixing SQL and 2nd level cache in ORMs, those "strong consistency" guarantees fly out the window. But you can run the read-only projections on the Slave nodes which are asynchronously replicated anyway, therefore you bypass the Master and the 2nd-level cache entirely. It's just a matter of good old architecting. You can benefit from an ORM while still taking advantage of database-specific features when running native SQL queries.
&gt; The problem with mainstream ORMs is that they're providing an interface to concurrently accessed, remote objects, which interface pretends the objects are in a single thread at a time, and in local memory. This is true for any SQL client. Once you're loading a `ResultSet`, a concurrent transaction can still modify what you loaded (that's the norm in MVCC anyway). &gt; When you stop pretending, and design an abstraction that uniquely fits the problem, most of the issues with ORMs go away. Too late for Hibernate, I guess, we'll need to run the cycle one more time. I beg to differ. In fact, after 16 years of development and 11 years of JPA competition, [Hibernate still has a market share of 70%](https://vladmihalcea.com/2016/08/18/jpa-providers-market-share-in-2016/). And I've been told that Hibernate 6 is going to be even more awesome.
&gt; ORMs are suitable for OLTP applications. Denormalization comes as a trade-off. Either you're scaling Facebook or Twitter, or you are running an OLAP workload. Or you're doing both, and whatever else you feel like, through event sourcing. :-) &gt; But you can run the read-only projections on the Slave nodes which are asynchronously replicated anyway, therefore you bypass the Master and the 2nd-level cache entirely. You're thinking about reading via SQL for building reports as a separate concern, and when it's a separate concern, obviously talking about "strong consistency" with a completely different application makes no sense. But your friends, again, don't stop there. We're talking about projections and modifications done in SQL in your main app, to overcome deficiencies of reading and hydrating a large number of ORM objects, full of information that we don't need for the most part. We can forget this use case and stick to ORMs in our main app, but then again the ORM use case narrows significantly, as does its performance range when it hits edges like these. And it will hit edges like these. &gt; It's just a matter of good old architecting. You can benefit from an ORM while still taking advantage of database-specific features when running native SQL queries. Yeah. Unless you need consistency, that is. 
Clearly by my writing &gt;&gt; **or in this case** that an empty set (uninhabited type) has an element (emphasis added) I intended an instance of the particular and not just a general conclusion of the sort you derive: &gt; By the definition you give Haskell is unsound (every type is inhabited by bottom) (Googling "Haskell is unsound," by the by, gives a lot of hilariously tragic ways in which the various extensions interact to give you more than you'd ever expect, so I don't think that Haskell is quite the soundness poster child you'd like it to be.) In this case Haskell doesn't have the kind of subtyping relation required for this example to work: you need to let the typechecker see that the type `T` where `U &lt;: T &lt;: U` must be uninhabited rather than simply say: type Void let v = undefined :: Void (I don't do Haskell so take it as pseudocode.)
&gt; We're talking about projections and modifications done in SQL in your main app, to overcome deficiencies of reading and hydrating a large number of ORM objects, full of information that we don't need for the most part. Even the official [blog of Hibernate](http://in.relation.to/2016/09/28/performance-tuning-and-best-practices/) says that you should never fetch more than you need: Hibernate supports both entity queries (JPQL/HQL and Criteria API) and native SQL statements. Entity queries are useful only if you need to modify the fetched entities, therefore benefiting from the automatic dirty checking mechanism. &gt; For read-only transactions, you should fetch DTO projections because they allow you to select just as many columns as you need to fulfill a certain business use case. This has many benefits like reducing the load on the currently running Persistence Context because DTO projections don’t need to be managed. 
&gt; At no moment you're under the illusion that editing the rows in the result set somehow affects your database, are you? I've no idea what you're talking about here. &gt; "It's popular" is not a technical argument. WordPress is also 1/3 of the web. Would you argue it's a marvel of engineering? Think about it. The tech industry is a jungle. If you have a terrible-flawed technology, there's no way it will become mainstream. I keep on seeing this argument against PHP or MySQL. While far from perfect, it seems that PHP and MySQL have just worked for many web-based applications, some of them being quite famous, like [Facebook](http://www.makeuseof.com/tag/facebook-work-nuts-bolts-technology-explained/).
I'm not sure what you're implying here, so I'll just say "Rust".
It's a bad, contrived, example - you would not generally need to call another function in order to apply a function to a value, not in Java nor in any FP language. The rest of the page doesn't make much sense either. This: public static Integer invertTheNumber() { Integer toInvert = 5; return compute((a) -&gt; -a, toInvert); } could be far more concisely written as: public static Integer invertTheNumber() { Integer toInvert = 5; return -toInvert; } or even: public static Integer invertTheNumber() { return -5; } There are better tutorials out there than this, starting with [Oracle's docs](https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html).
My point is exactly the opposite. All of those issues stem from poor attention to detail. 
&gt; Does your ResultSet invisibly fetch associations eagerly? Lazily? Neither. It returns precisely what you asked for. False. [The entity can lazily fetch associations, even attributes if you like](https://vladmihalcea.com/2016/09/20/the-best-way-to-lazy-load-entity-attributes-using-jpa-and-hibernate/). &gt; Can changes to your ResultSet be "saved" back to the database? No. You issue a direct command with the precise effect you want to see, instead of inferring it from local changesets. Of course, they can be saved. [That's how dirty checking mechanism works](https://vladmihalcea.com/2014/08/21/the-anatomy-of-hibernate-dirty-checking/). If you're calling `merge` after you modified an already attached entity, then [you're doing it all wrong](https://vladmihalcea.com/2016/07/19/jpa-persist-and-merge/). &gt; I have no issue with SQL, but what Hibernate and co. do is just put a layer of fog between you and what happens at the database. The fog can be easily lifted by the [new User Guide](http://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html). &gt; You're telling me to think about it, but you only thought enough to pull out a tired Kim Kardashian "it's popular, therefore it's good" fallacy on me. Just because you don't like it, it doesn't make it less useful for the vast majority of its users.
Well, I don't know if a new Collections library will happen, but if so I'm pretty sure that, based on past experiences, they will follow one of these two strategies: * Create a completely separate Collections library, so libraries/code that uses the old one continues to work. This is pretty much the approach of the new time or nio libraries. * Modify the existing Collections library in a backwards-compatible manner. This is that approach that was taken to introduce streams and lambdas, and required the addition of default methods in interfaces. Either way, they'll take however long they need, but they'll make sure to prevent as many issues as possible.
I personally think that plain SQL is the perfect way to express what I want my database to fetch for me. There really isn't a 'more efficient' way for me to construct a few of my dataset. The JPA way of having a single canonical model also acting as your view might work well for desktop apps; it doesn't really work when you're working on REST API's most of your time. So with a clear and expressive declarative language that can explain what data I want from my database all that's left is an automated way to map that resultset to POJO's. Spring's JDBCTemplate's [rowmappers](http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/core/RowMapper.html) work very well there. I hardly ever need to configure my own, typically the default [BeanPropertyRowMapper](http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/core/BeanPropertyRowMapper.html) handles this very well. So for me it's: 1. Big ORMs stink 2. Use JDBCTemplate / Rowmappers 3. Profit
&gt; Native queries are always executed against the DB, so they bypass the 2nd-level cache entirely. Yes, that's precisely the problem... If you write, you risk your cache remaining behind. If you read, you risk your cache being *ahead*. Bypassing the cache sometimes (native queries) and not bypassing it sometimes (entities) is *bad news*. &gt; The 2nd level cache can be synchronized with the current DB transaction too. As long as you use READ_WRITE concurrency strategy, you should be fine. "You *should* be fine" sounds so reassuring about my business critical data, thanks! /s Read/write is less strict than "transactional" and doesn't work in a cluster with the built-in providers, because they don't support locks. Even with the correct caching providers it allows phantom reads. There are so many underwater stones here, the last thing I'd say is "you should be fine". It's kind of damning you're also linking to *some blog* instead of the official documentation, which is very sparse on *such critical settings, and how they operate under the hood*. That's Hibernate, basically. A million ways to configure it, and most of them are wrong, but you wouldn't know until it's too late. &gt; Again, that's not true. Native queries go to the DB where the transaction isolation level dictates the level of consistency. The Persistence Context is flushed prior to every query, so the 2nd-level entity cache plays no role in this scenario. You don't seem to understand that the fact the 2^nd level cache plays no role *is the actual damn problem*. You see, depending on your settings, the 2^nd level cache can be configured to provide write-behind caching, which means that the *cache may be more up-to-date than the database itself*. So do you realize what happens then, if 2^nd level cache plays no role in native queries? A consistency mess. Likewise, the 2^nd level can't participate in the database's MVCC implementation, so as you open transactions against the cache, against the database, you'll be seeing edge cases with different results, as they implement their concurrency independently and differently. I mean, just the fact alone Hibernate has so many poorly explained settings should be a reason to be terrified. People sigh when they're explained how complicated ACID is, with its different levels of isolation, MVCC and so on, but it's honestly a child's play compared to the mess Hibernate is.
No, it was an answer to the last question! &gt; Is there a C++ linter that "removes" the legacy cruft? Rust.
I know no now…
&gt; It's kind of damning you're also linking to some blog instead of the official documentation The official User Guide has around 300 pages now. To provide all the details of every use case, you need probably 1000 pages. The thing about open source is that resources are scarce, so you need to prioritize work. If you'd like to contribute to the missing documentation sections, you are very welcome. &gt; You don't seem to understand that the fact the 2nd level cache plays no role is the actual damn problem. You see, depending on your settings, the 2nd level cache can be configured to provide write-behind caching, which means that the cache may be more up-to-date than the database itself. There's not point in discussing this any further if you don't read what I provided you. Again, any query goes against the DB, not the 2nd level cache. The 2nd level cache is used only if you read entities by their id which is useful for writing back data. In case of stale data, you get an optimistic locking. &gt; Likewise, the 2nd level can't participate in the database's MVCC implementation, so as you open transactions against the cache, against the database, you'll be seeing edge cases with different results, as they implement their concurrency independently and differently. Nevertheless, the READ_WRITE concurrency strategy achieves a READ_COMMITED isolation guarantee using soft locks. Would you provide this guarantee with any other application-level cache? The only cache that provides stronger consistency guarantees is the database cache itself. &gt; I mean, just the fact alone Hibernate has so many poorly explained settings should be a reason to be terrified. People sigh when they're explained how complicated ACID is, with its different levels of isolation, MVCC and so on, but it's honestly a child's play compared to the mess Hibernate is. For me, ACID, MVCC, phenomena, and Hibernate internals don't seem complicated at all. After all, it's not rocket science.
Yeah I don't have time to maintain it. It's small so if you find any issues fix it yourself. Yeah and sourceforge &gt; github. 
Or you can just get the source dork.
What does 'realtime' mean in this context? People always see their shopping cart update within some fixed time limit? Why would you need that? And how can it achieve that over a network as unreliable as the internet?
You can design your conversation as a collection of event that can be merge to the datastore. Instead of merging your view of the state you have update action to the share state. That's assuming that you can't generate conflicting event but you can do that by design. Then you don't even have optimistic locking issues to recover from. 
The transaction log is an a log of events, and it manages to detect anomaly conflict on your behalf so that you don;t have to deal with these issues. Now, if you have an event log that accepts anything and then you decide you'll resolve the conflicts later, you will have to emulate exactly what you take for granted from an MVCC engine. But providing anomaly detection is not very easy. In the end, you'll come up with a home-made transaction engine, which is even more complicated than a home-made ORM.
&gt; The official User Guide has around 300 pages now. To provide all the details of every use case, you need probably 1000 pages. Oh I see. So basically the solution to "Hibernate has plenty of obscure settings that affect performance and data consistency" is "let's gloss over them in docs". Are you serious? &gt; If you'd like to contribute to the missing documentation sections, you are very welcome. So basically you're saying the documentation is bad and needs work. We're... on the same page. &gt; There's not point in discussing this any further if you don't read what I provided you. I've read it and it's a clusterfuck. I'm not sure which part is supposed to convince me my data is safe. The more I read the worse it becomes, say, like modeling consistency rules around comparing wall clock timestamps. That's a rookie mistake. &gt; Nevertheless, the READ_WRITE concurrency strategy achieves a READ_COMMITED isolation guarantee using soft locks. Would you provide this guarantee with any other application-level cache? The only cache that provides stronger consistency guarantees is the database cache itself. I don't understand why you keep defeating your own point about "strong consistency" by giving me facts that Hibernate's consistency is not as strong as possible, and then you want me to be impressed by that. In SQL, READ_COMMITED affords for plenty of consistency violations, and should be used carefully, by manually applying locks (SELECT ... FOR UPDATE / LOCK IN SHARE MODE), and having a perfect grasp of what the isolation level entails. If not, you must absolutely go SERIALIZABLE. Without this fine control, and with poor documentation, READ_COMMITTED emulation in Hibernate spells only one thing: a disaster. And what exactly point are you arguing here? Is it "do you know how hard it is to do what Hibernate does, never mind it doesn't do it very well"? If so, ok, we agree. It's very hard to evolve and maintain Hibernate, I'm sure. And it's a result of starting with a poor leaky abstraction, and then trying to solve the issues by scattershot adding half-documented options to address various edge cases. Doesn't sound easy at all. Bad design always ends up like that. &gt; For me, ACID, MVCC, phenomena, and Hibernate internals don't seem complicated at all. It's not rocket science, after all. You say Hibernate internals are not complicated to you, but I have to either disagree, based on our conversation so far, or maybe suspect you keep losing track of the conversation. You started by saying Hibernate provides strong data consistency, and we ended up with "it's a constrained open source project, with poor documentation, and doesn't provide as strong consistency as the database".
&gt; So basically you're saying the documentation is bad and needs work. We're... on the same page. No. That's not what I said. That's what you think of it. I said that if you think that there are missing documentation sections, feel free to add them yourself. &gt; Hibernate has plenty of obscure settings that affect performance and data consistency You obviously haven't checked the [5.x User Guide](http://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#configurations). All the configs are documented and explained. &gt; I've read it and it's a clusterfuck. I'm not sure which part is supposed to convince me my data is safe. The more I read the worse it becomes, say, like modeling consistency rules around comparing wall clock timestamps. That's a rookie mistake. There's a [monotonical time resolution mechanism](http://grepcode.com/file/repo1.maven.org/maven2/net.sf.ehcache/ehcache-core/2.4.6/net/sf/ehcache/util/Timestamper.java#Timestamper.next%28%29). If you think you can provide a better implementation, feel free to enhance Ehcache as well. That timestamp values is not what you read from currentTimeMillis like [Apache Cassandra does, for instance](https://aphyr.com/posts/299-the-trouble-with-timestamps). &gt; You started by saying Hibernate provides strong data consistency, and we ended up with "it's a constrained open source project, with poor documentation, and doesn't provide as strong consistency as the database". Yes, it does provide strong consistency. Prove me I'm wrong. It's a constrained open source project, but is this out of the ordinary? The documentation is great, and there are plenty of other resources available, like blogs, books, and the source code if you want the finest grained level of precision. And it does provide strong consistency. You just have to know how to use it. That's all.
&gt; No. That's not what I said. That's what you think of it. I said that if you think that there are missing documentation sections, feel free to add them yourself. If you thought differently, you'd link to documentation, and not to a blog. &gt; You obviously haven't checked the 5.x User Guide. All the configs are documented and explained. I went and checked what it says about READ_WRITE. It says it's a "good default" and some other generic statements, and it then fails to explain *precisely* what guarantees about consistency it provides, and doesn't provide. Your bar for "well explained" is very low. &gt; Yes, it does provide strong consistency. Prove me I'm wrong. I don't have to, because you proved yourself wrong in this thread, like half a dozen times. Maybe you don't know what [strong consistency](https://en.wikipedia.org/wiki/Strong_consistency) means? Dunno why you contradict yourself, but I have nothing left to prove. 
&gt; If you thought differently, you'd link to documentation, and not to a blog. I find that blog very useful. It's complementing the official User Guide. In future, there might be official Topical Guides to cover these topics. Meanwhile, there's a lot of documentation even outside of the official User Guide, like [60K Q&amp;A](http://stackoverflow.com/questions/tagged/hibernate) on StackOverflow. &gt; I don't have to, because you proved yourself wrong in this thread, like half a dozen times. Maybe you don't know what strong consistency means? Dunno why you contradict yourself, but I have nothing left to prove. Thanks for providing me the Wiki link. It's a great example of what "well explained" is supposed to look like.
Wikipedia is an open-source project, its resources are constrained. You're welcome to read more about strong consistency, and then improve that page. /s
On a side note, there is also a related web framework cycle
Hibernate seems [quite active to me](https://github.com/hibernate/hibernate-orm/graphs/contributors), especially since 2015.
Let's not forget the JavaScript framework cycle.
Check the [OWASP site](https://www.owasp.org/index.php/Category:Attack) for a list of common attack patterns, in particular [XPath Injection](https://www.owasp.org/index.php/XPATH_Injection). If you are dynamically constructing XPath queries by concatenating external, untrusted data, an attacker can circumvent security controls just like SQL injection.
Seems interesting! I know the source is included at the bottom, but it would have been nice to include some in-context code examples throughout the article.
Is JSF still a thing? I was under the impression that there's been a big move towards rest apis + javascript frontend.
My understanding: since Go.
Clarifying this one. The code that no longer works with the latest JDK9 build is basically this one: static &lt;T,U&gt; U coerce(T t) { Constrain&lt;U, ? super T&gt; constrain = null; Bind&lt;U&gt; bind = new Bind&lt;U&gt;(); return bind.upcast(constrain, t); } Do not celebrate just yet though. It does prevent `String zero = Test.&lt;Integer, String&gt;coerce(0);` from working, but it also prevents those from working (which compiles and executes fine on Java8): Integer zero = Test.&lt;Integer, Integer&gt;coerce(0); Integer zero = Test.&lt;Number, Integer&gt;coerce((Number)Integer.valueOf(0)); (the rest of the code is unchanged from the Twitter snippet). Well, we traded a situation with incorrect code that compiles to one with correct code which does not compile.
Too late for any changes now. The shortcomings of Jigsaw were clear early on but all proposals fell on deaf ears. See the endless list of flaws dissected here: https://www.infoq.com/articles/java9-osgi-future-modularity https://www.infoq.com/articles/java9-osgi-future-modularity-part-2 Concluding that the module system is entirely **useless** for any application (JDK modularisation is another matter). e.g.: &gt; Additionally It is forbidden for more than one module to export the same package, or even to have overlapping private packages. Therefore whatever tooling is used to construct valid sets of modules will have to find a solution to conflicting transitive dependencies. In many cases the "solution" will simply be that certain modules cannot be usable in combination with other modules. Good night. This is just Jar / classpath hell on another level if not worse. It's a pity, because they have waisted precious time instead of working on hard pressing issues that could make it for Java 10 the earliest, if the the dependencies have not all become a hairy ball of incompatability by then. 
Because Pusher
Yeah, and you could always use jdbc directly anyway.
&gt; static code analysis tools generally do not offer an incremental execution Actually, that's **exactly** what [Teamscale](https://teamscale.com) does. It only analyzes the actual changes in each commit and can match new and old findings reliably even in the face of big moves and repo restructurings and across branches as well. It has most of not all the PMD checks built in. Edit: fix phone autocorrect
Java, unsound, total disaster. uninstall. sad. Edit: /s . Been working with and loving Java since 1995. 
Yea, check out PrimeFaces there's a lot of good stuff in JSF, and you pair it with Spring or whatever. Works great for internal apps.
I would strongly recommend you use an embedded web server for micro services. Look into - https://projects.spring.io/spring-boot/ - embedded web framework - http://undertow.io/ - Low level web server. Not too hard to do REST with if you add a JSON library - https://www.playframework.com/ - framework - http://sparkjava.com/ - micro framework - http://www.dropwizard.io/1.0.5/docs/ - lightweight framework - https://github.com/networknt/light-java - lightweight framework built on top of undertow. - http://vertx.io/ - Event driven non blocking framework - http://jooby.org/ - micro web framework - http://www.ninjaframework.org/ - Full stack web framework EDIT: Added more frameworks
I don't know if you will see this but thanks and I will be more diligent in checking!
Can you elaborate why you recommend embedded web server service? My practical environment will be a Maven project deployed onto Weblogic 12c running RHEL 5+
Yes, JSF is still a thing ;)
You also forgot Vert.x 
Use r/javahelp for help, and also put more details in your title so you can lead people with the right knowledge to your post. Also post things you already tried. Your post is very vague, are you trying to make a game bot? Well anyways, the `java.awt.Robot` class can do most of the things you want - it can take screenshots and thus detect that pixel color change, and it can also click. On windows you can configure a keyboard shortcut to start a program.
Sure -- I'd look at Lagom (disclaimer: I work for the company that makes Lagom), which takes a good hard look at the problem underpinning microservices: you own your own persistence, and you're going to be talking to other microservices, which could be flaky. Pat Helland had a great paper on this called [Data on the Inside vs Data on the Outside](https://blog.acolyer.org/2016/09/13/data-on-the-outside-versus-data-on-the-inside/) which goes into more detail on the problems with external data, with repeated data, out of order data, and data that is obsolete on arrival. Here's the best page for Lagom, talking about the persistence and service discovery APIs: http://www.lagomframework.com/documentation/1.2.x/java/WhatIsLagom.html And for an overview, it's probably best to poke at the sample project: https://github.com/lagom/activator-lagom-java-chirper
Thank you for the links, I will check them out. I totally agree on the state of how the application will use data. Right now I am struggling on if a micro service would even be beneficial since the amount of data I have access to is millions and each piece is unique and has a short lifetime of a couple days and once processed is seldom re-used (so no real caching will be done). The more I think about the situations a typical rest service may be the solution instead of complicating with multiple micro services.
I've used Vaadin as a the front end. It's also mostly Java. Great for Java backend
Super easy, i just set someone else up on it today. download netbeans with tomcat. Create new maven webapp. Create new servlet. hit the play button and you have a web app
In that case I recommend Play: https://www.youtube.com/watch?v=vRs7RYWaBjY Although I would download the Java starter project from https://playframework.com/download#starters and then try the examples...
What kind of webapp? Spring Boot is a pretty easy way to go: https://spring.io/guides/gs/spring-boot/ There's the old school server-side application, with no fancy Javascript: https://spring.io/guides/gs/serving-web-content/ There's the modern way, using fancy Javascript frameworks like AngularJS: https://spring.io/guides/tutorials/spring-security-and-angular-js/ Once you do that, hooking up to a database is pretty easy: https://spring.io/guides/gs/relational-data-access/
&gt; My main reason for hating ORM, is that it hides the complexity and number SQLs that are thrown at your database.... which will lead to a slower system.... you've abstracted away the pain, rather than delt with it using a better RDBMS design. There are multiple ORM fraemworks, so this statement does not necessarily apply to all of them. Hibernate, which is [the most popular ORM and JPA implementation in Java](https://vladmihalcea.com/2016/08/18/jpa-providers-market-share-in-2016/), allows you to [customize everything you want about data access](https://vladmihalcea.com/2016/06/28/14-high-performance-java-persistence-tips/).
&gt; Hibernate can only do things that you can already do with sql and jdbc, it's entirely limited to that. But it's an abstraction that's so full of leaks and gotcha's that you're better off doing it with sql and jdbc. That's not true. Hibernate offers [a lot of add-ons on top of JDBC as explained in this free chapter of High-performance Java Persistence](https://leanpub.com/high-performance-java-persistence/read#leanpub-auto-why-jpa-and-hibernate-matter): - a way less-verbose API compared to JDBC - transparent and configurable batch updates so that you can switch from non-batching to using batching for all your application insert, update and deletes with just one configuration. Imagine what's the effort for switching from non-batching to batching with JDBC. - built-in support for explicit locking and optimistic concurrency control. With JDBC, you have to figure out the best way to do it based on the underlying DB capabilities. - unified transaction API. With JDBC, you are limited to local transactions. For JTA, you need to switch to the JTA API. Hence, the transaction logic is mixed with data access code, which is undesirable. - fetching joined relations requires additional processing to transform the ResultSet into Domain Models or DTO (Data Transfer Object) graphs. Now, you might have parent-child associations, and, with JDBC, you have to transform the flat structure to a hierarchical model on a per query basis. Hibernate simplifies this so that you can benefit from this transformation even for native SQL queries (e.g. `ResultTransformer`). So, just because you can do the same stuff in Assembly language, there is a very good reason why you're programming in Java instead.
Can you first explain what exactly it is you're building? A microservice architecture isn't a goal by itself; it's just one way to design a system. 
&gt; No way I would waste the extra time and unpredictability on Hibernate in a project again, if I had a choice. What framework are you going to use instead?
Very nice. Always disliked how big the JDK was with all that outdated crap.
Sam Newmans' Building Microservices is a very good book, here is my review of it - https://howtotrainyourjava.com/2016/10/20/building-microservices/ If you want to know particularly more about REST api design, grab this one: http://shop.oreilly.com/product/0636920028468.do 
cool! :)
How does it work with REST and JPA? &gt; 1. I request a Actor /actor/{id} for editing im my webapp - i fetch the entity from DB by ID &gt; 2. I change his name and the assigned projects &gt; 3. I HTTP PUT back the Actor /actor/{id} to the server. &gt; 4. In my Java controller i have to fetch **again** the entity by id, set the fields i want and save to DB. Is this second fetch *normal* in REST architecture? If i would use plain SQL i would in step 4 do just an SQL UPDATE. In JPA it seems i would need a SELECT before an UPDATE.
Yes indeed i did :)
The removal of `endorsed` is actually going to be a big problem for some situations, but those situations are sufficiently rare that Oracle aren't concerned by them. As an example, we have a Java Applet and Application that our customers use to do POS Printing from our webapp. (The applet version runs in the browser, the application version runs locally and is communicated with over websockets). In order to do POS Printing, you need the JPOS drivers installed on your system, and these are a native component and a Java component - which is installed in the `endorsed` directory. It has to be, because different manufacturers drivers are different and so you can't just bundle them with the code calling them. Currently we haven't got a decent solution for this, and I'm not even sure that there is one.
Overall, the article matches common sense, but I don't agree with a couple of rules: &gt; 3\. Never pass null as an argument I get that purity feels neat, but "null to indicate that there’s no value" is what null exists for. Ideally we'd have overloads for all possible combinations, but then what would these overloads do to communicate, say, "no log" to the core implementation? Typically pass null. Sometimes using Null Object Pattern instead of null is preferable. Sometimes, though. &gt; 8\. Use exceptions over nulls The description of this rule is not wrong, it says "always throw an exception instead of returning null if something went wrong", and I agree. But this is different than what the title suggests. Sometimes when the result is *not a collection* and your have a fetch/find/getter method for finding an entity or value in a collection, then returning null on no match is preferable to throwing exceptions, as "no match" is not an error, it's just a valid result for the operation.
But what if that is their goal? Learn how to build a microservice.
It doesn't matter if that's what nulls are designed for. Passing null as an argument bloats code with null-checks or gives painful bugs.
I guess you will have to or are already using outdated browser if you have Applets. Then why not stick to jdk8 the same way?
The Application version was built because of browsers desupporting Applets. The Sticking with Java 8 is the only solution we've got so far, but we can't always control what JVMs our customers will use - especially when Java 8 stops getting updates they might insist on updating for security reasons...
You're not arguing against null here, you seem to be arguing against optional dependencies as a whole. Because if you're not checking for null, you'd possibly be doing some other sort of branching for optional dependencies, either way. Unless you can assign a default value, which means you have exactly one null check to make, exactly at the point of contract that permits null, say: public SomeClass(..., ..., @Nullable Cache cache, ...) { if (cache == null) cache = new BuiltInCache(); ... } This doesn't seem very complicated, does it? Whether you use null or some other method for providing an optional dependency (i.e. setter method, Optional&lt;Cache&gt; etc.) doesn't matter much about the logic here. 
The responsibility is always on the receiver to test for nulls, not the sender to promise to never send nulls. For external apis, you should always religiously null check your arguments if your goal is to write a good application. If your goal is to write good code, which is something completely different, expect to get called in at night to fix bugs.
The direct check for null is clearer, better code.
Sometimes you need a guard, sometimes you need a branch. Neither is "better", they serve different purposes. But calling nonNull() directly is advised against in the *actual Java manual*. Not only it requires more code (either the static import, or spelling out Object.nonNull) but it's also slower, and gives you absolutely nothing over using the == operator.
I disagree, using the [Apache methods](https://commons.apache.org/proper/commons-lang/javadocs/api-2.6/org/apache/commons/lang/StringUtils.html) for instance in StringUtils.isBlank you can use a static import and just if(isBlank(foo)){ //Do Things and Stuff } Which is pretty clear, isBlank checks null &amp; blank; isEmpty checks null [it is all about naming.](http://www.itiseezee.com/?p=83) the naming is consistent through the utils as well, for Collections/Strings/Maps/etc
I thought isBlank and isEmpty both checked for nulls and empty strings, but isBlank also ignores whitespace?
I'd like to make sure I'm still employable in 5 years.
&gt;I never said I'm not doing null-check. I said that they bloat the code. Robust code is always going to be bloated by data-integrity checks. That's what makes it robust. 
I'm so grateful that Hibernate is saving me all this time mapping relations to objects. Now I can spend it watching videos like these and performance tuning Hibernate.
Blank will check for more white space then isEmpty: So for IsEmpty: StringUtils.isEmpty(null) = true StringUtils.isEmpty("") = true StringUtils.isEmpty(" ") = false StringUtils.isEmpty("bob") = false StringUtils.isEmpty(" bob ") = false Where as isBlank: StringUtils.isBlank(null) = true StringUtils.isBlank("") = true StringUtils.isBlank(" ") = true StringUtils.isBlank("bob") = false StringUtils.isBlank(" bob ") = false So the third case is the difference 
Sure but if I have a chain of ifs then I want to conserve space then I don't think it is a good answer, and a "good java programmer" will be able to tell either way, so this is largely a matter of opinion and not dogma. And considering that the Apache and Guava utils are pretty standard usage including by the big 4 and have several thousands of users; I'd say that it is a widely shared opinion.
Best performance tip. Please don't use things like hibernate. 
Are you worried about forgetting how to write Java because you learned Kotlin? Reminds me of this Homer Simpson quote: "But every time I learn something new, it pushes out something old. Remember that time I took a home wine-making course and forgot how to drive?"
Yup. That's reasonable. 
What a coincidence that you're linking Vlad Mihalcea's stuff. Just like in about every other comment.
This is a disguised ad for pusher. All of /u/jmcunha [-1]'s posts are from the same website and this post requires you signing up for pusher
&gt; "Empty" implies a collection I beg to differ: "empty" can be applied to a String. &gt; and we communicate this with an empty collection, not null (as the article itself says). Again, the problem is that someone else might decide that `null` fits the concept. This is circular reasoning. &gt; "Unknown" seems like a very nebulous concept Exactly. `null` can mean a lot of things. Using non-nullable types with agreed-upon semantics is the only solution to that. 
Love the /u/
+1 for JDBI - especially for simpler stuff. I'm not sure a full-blown enterprise app should use JDBI (or JDBC directly for that matter), but there's no requirement for the "thing" to be JOOQ or Hibernate either...
&gt; But I've always really been a stickler for clarity over cleverness in coding. The problem with relying on 3rd-party jars to clean up your code is that you've created an additional dependency that other programmers have to anticipate. How many times have we all seen solutions to problems on Stack Overflow that required 3rd-party utilities to work? If there is a simple solution to a problem that can be easily written in native Java, you should ALWAYS prefer that approach because it will always compile and doesn't require non-Java knowledge to grasp. 
Inlining is not a reason to make expressions more complicated than they have to be.
I can't disagree with you there at all and that is a strong enough point to beat out my statement that having a commons function be the default solution is acceptable. My point for the clarity over cleverness was more a long the lines of using code that relies on rules that might make an obfuscation contest work vs just breaking it up into a few more lines to be obvious for yourself if you've forgotten or someone not as familiar with the language. I've especially worked in a lot of places where I didn't have 'the internet' at my disposal to get dependencies for solutions or that it was even my call to add it to a larger code base. 
Unless I wanted a null and blank string check then that is exactly what I would want to use. 
It seems I've trouble making my point. The point is not about "you" or "I", but about "we". If I use a word with a definite semantics behind it, and when you hear it, you apply a different semantic, this is bound to create a communication problem: on the surface, we seem to talk about the same but it's not the same. That's the biggest issue when I deal with business: I've to ask them the tiniest little detail of concept I don't know about (and sometime even worse, of those I know but in different context). That's great that you are clear what `null` means for you, but it may mean something completely different for the next guy who will maintain your code, be it me or someone else. Hence, no `null`, no assumption, no space (less space) for different semantics.
&gt; Just like using Apache Commons for String checking methods, Optionals provide a cleaner and more holistic way of getting down the intended code path. I guess it all depends on whether your primary goal is to develop an application or to write code.
The last thing I want is ad enhancements...
When you speak for "we don't know what null means" this is not at all any more representative of an industry than what I am saying. You don't speak for anybody else other than yourself. The objective meaning of setting something to null is just one: a variable/field/arg is either set to an object instance, or null if there's no object instance. Everything else is a product of someone's imagination, and not a problem of what null *is*. Your attempts to describe how null is confusing are rookie mistakes that a newbie would also make with any other primitive, like returning Optional instead if an empty collection. Is this a proof we should not use Optionals? Or maybe it's a proof we shouldn't return empty collections? Let's eliminate everything that *someone somewhere might be misinformed about*. Let's see how that language looks. Your examples have been forced and unconvincing. You're trying to drive a point across not based on the merit of the point, but by manufacturing issues where there is no evidence they exist. I've never had someone tell me their mind is blown by what getting a null might mean, when the interface says it might return null in certain situations. Can you produce **a single** example where a well documented method takes or returns null according to its purpose and this is confusing? Also would using something else *not* be confusing in the same situation? Let's see... 
What is this *actual Java manual* you speak of
What do you disagree with?#isBlank does something different than the direct check for null.
What both? There is no second thing, just a check for null. isBlank is not the same thing.
IsEmpty: StringUtils.isEmpty(null) = true StringUtils.isEmpty("") = true StringUtils.isEmpty(" ") = false StringUtils.isEmpty("bob") = false StringUtils.isEmpty(" bob ") = false isBlank: StringUtils.isBlank(null) = true StringUtils.isBlank("") = true StringUtils.isBlank(" ") = true StringUtils.isBlank("bob") = false StringUtils.isBlank(" bob ") = false 1 test case difference and isBlank encompasses an null check FFS.
Who deploys the same application on different implementations?
I think it's a reasonable assumption. If a method returns null instead of an optional, that's a straight-up error and I want it to throw. No need to write endless if statements to protect against it. 
 &gt;Are you serious right now? If you want to return an empty string, you will return an empty string, not null. And what do you do when some code you're using *doesn't* return an empty string, but null instead? What about null instead of an empty collection? It's all very well saying that's not how null should be used, but it *is* used like that, in millions of codebases. 
Doesn't have to bloat your *own* code though, e.g. if I'm using a library like immutables I can dispense with null checks, since if I have an instance of an immutable object it cannot possibly contain any null values by default. Sure there are null checks happening somewhere, but not in my code and not where I need to see them every day. 
The discussion here isn't "can null be used poorly", because **everything** can be used poorly. The discussion is "should null use be 100% eliminated, or it has proper uses". And yes, it does have proper uses. It'd be great of Java's types weren't nullable *by default*, but that's another discussion entirely.
Sure it does. But not everyone agrees what they are, and there are superior alternatives. 
I disagree. Apart from the fact that Optional makes a clear and unambiguous distinction between fields/parameters/whatever than can be missing and those that can't, it is by now very different to a quick wrapper you cobble together yourself. For example, most of my preferred frameworks have support for it out of the box. If I try to select a row that doesn't exist, jdbi can return it as an Optional. If I return an absent Optional from a jersey resource, it gets translated into a 404. Most of all, it's just nice to code in such a way where any NPE anywhere is always an actual bug and not just a misunderstanding or a missing code path. 
JasperReports &amp;nbsp; JODReports -&gt; ODT -&gt; PDF 
He recently created a new user name iirc
THANK YOU!!!!
Man that article for sure was what the title said. It felt just like random thoughts. 
 &gt;If you're using it to mark up with fields/vars are always set, and which might not be, adding another heap memory allocation and an extra level of indirection to reach your field value is not pragmatic approach. There are *annotations* for that. It's pragmatic for 99.9% of software. Critical path on a Google search or an HFT transaction? Sure, it would be a bad idea. For almost all other software, however, allocating a small short-lived object is not going to cause a noticeable issue. I've worked on services handling 100,000 uncached requests a second using this approach, and the GC was no kind of issue. &gt;On top of that, your "optional" fields and so on might still be null, and in fact *they're always null* before the constructor runs, anyway. I'm not accessing anything before the constructor runs, so that's not a problem. An optional field set to null is a *bug*, not a program state to be coded around. &gt;I'm talking about its implementation, not about whether it has a status of a common convention. Internally Optional is just a pedestrian object on the heap. There's *nothing* special about it. It doesn't need to be 'special' (from a JVM perspective) to be useful and superior to null. And it *is* special from a library/framework perspective, since it is known and supported, unlike a homegrown version. &gt;Yes, and if jdbi would have selected to return null, what then, would it blow your mind? No, it would just irritate the shit out of me because I wouldn't be able to tell at a glance whether receiving no result from a query is an error or simply another condition to handle. &gt;Because NPE is much worse than NoSuchElementException? Because that's what happens when you try to grab an optional without a guard. It's not different than a null. Yes, NPE is significantly worse. It's common to have a single line of code that uses 2, 3, maybe 4 object references. An NPE tells you which line hit a null, but not which reference is actually null. They are terrible for diagnosing issues. Accessing an Optional without a guard is a very noticeable code smell. Hell, there's talk of deprecating the get method so that the compiler will complain if you write such lousy code, rather than accessing it in a safer way. 
https://blog.pusher.com/realtime-shopping-cart-with-java-and-react/?utm_source=social&amp;utm_campaign=blog-realtime-shopping-cart-with-java-and-react&amp;utm_medium=reddit look at all those Params for metric guys.... Maybe if we change the medium to pornhub someone will notice? https://blog.pusher.com/realtime-shopping-cart-with-java-and-react/?utm_source=social&amp;utm_campaign=blog-realtime-shopping-cart-with-java-and-react&amp;utm_medium=pornhub
Thx, now I don't have to load a webpage for a single line of information. 
Why not using EntityManager.createNativeQuery for those complex queries? Also, Hibernate Session offers the doWork method and you can pass it a lambda and get access to the underlying JDBC Connection. So, how does Hibernate prevent you from using JDBC or plain SQL?
Omg has this baeldung person really ran out of stuff? Up next, stream() vs parallelStream() 
Enterprise legacy code can live a long time. 
I hear you...my reaction was more like "omg I forgot applets were still a thing". Maybe it's just memory loss as I'm old enough to remember applets being all the rage. 
What do you mean "feed the installer"?
That was interesting, thank you. I guess the view at Oracle is that Ubuntu is a home or desktop user's distro, that if people want Oracle they have a big project and need the stability and support of something like a RHEL.
That is exactly correct. I could only ever see Oracle certifying their software against Ubuntu LTS. Otherwise the lifecycles are just way too short. Some Oracle product lifecycles like the Ebusiness suite can be measured in decades. Databases are often used for years and years. So Oracle wants to make sure that the OS that they are running on has a similar lifecycle and Red Hat has that kind of commitment to their operating system.
The downside of nulls isn't npes, it's a bunch of inconsistentcies between what people use null to represent, and inconsistentcies on handling nulls.
Today I learnt that there are people who still use applets.
Yes, you will have much better luck on CentOS. Oracle maintains pretty extensive compatibility matrixes for Fusion Middleware at http://www.oracle.com/technetwork/middleware/ias/downloads/fusion-certification-100350.html I highly recommend taking a look at those to make sure your setup will work. They won't specifically list CentOS as supported, but in my experience I have never had a problem with it as long as I match the CentOS version with the Red Hat version they list. Of course if this is supposed to be a supported configuration you will want to use an OS that they list as certified.
Also just wanted to point out that Oracle does provide some ready built VMs for development purposes with some of their software installed already. Check it out here: http://www.oracle.com/technetwork/community/developer-vm/index.html 
Preach to the congregation, not the choir!
Do you even sarcasm, bro?
My one tip to handling null effectively if you can't use Kotlin (which is the true ideal solution): Annotate all method parameters and return types with `@NotNull` or `@Nullable`. Your IDE will run static analysis and warn you if you're violating any contracts.
Nothing in that comment had any kind of tone to it that would imply you were joking, and I'm pretty sure a lot of people are upvoting simply because "lol Kotlin, that's definitely a passing fad".
Because removing things causes everyone a lot of pain. I redocumented it to say you should probably switch to ju.Optional, but if you're not in a hurry to do that, fine with us.
I think that the idea that a popular JDK class can change in-place to become a value type is a fantasy so farfetched as to not be worth worrying about. There's really no good reason to keep using our `Optional` class now.
Thanks!
It doesn't. This is the process I typically take.. JPA with hibernate gives me the flexibility to use ORM, hql, criteria, or native SQL depending on my needs.
Why do you think there are so many data acess technologies: (Hibernate, EclipseLink, QueryDSQL, jOOQ, JDBI, JDO) when you can just take JDBC and write a very efficient data access code? Could it be because JDBC is a very verbose API which makes it very laborious to write even a trivial use case? What do you think? Could all these frameworks have no reason to exist? Check out [this presentation from Lukas Eder](https://www.youtube.com/watch?v=knTwEqv2OXI&amp;t=133) and let me know if you can spot all errors in that typical JDBC code. What could go wrong with plain JDBC after all, right?
Oh look, you're spamming a link to your YouTube again. I am so surprised.
I love it, it's one of those simple tools that makes everything so easier. The integration with Spring Boot it's great.
I have only used Flyway in a hobby project, but I have used Liquibase in a real project with great success, the two are largely alike, but some minor differences. My preferred usage however, is to run the migrations during the startup of the server/program, instead of doing it manually with maven. This way, any new scripts added are run automatically, for example after fetching the latest changes from version control.
This page will walk through Spring boot automatic restart using developer tools with maven. When our application uses spring boot developer tools then it will automatically restart the server and refresh the page on browser whenever a file within classpath is modified in development mode. We run our exploded form of the project using spring boot maven command mvn spring-boot:run .
I was curious so I wrote a quick JMH test and these were my results: Benchmark Mode Samples Score Score error Units c.k.j.NullTestBenchmark.test_Objects_nonNull_isNull sample 150982 11.191 0.865 ns/op c.k.j.NullTestBenchmark.test_Objects_nonNull_notNull sample 151241 10.283 0.766 ns/op c.k.j.NullTestBenchmark.test_direct_comparison_isNull sample 151370 10.363 0.870 ns/op c.k.j.NullTestBenchmark.test_direct_comparison_notNull sample 150522 10.763 0.847 ns/op The source can be found at [http://pastebin.com/wb5gpsiP](http://pastebin.com/wb5gpsiP). I've never played around with JMH before but I think this is testing what I expect. Edit: Here are the single shot numbers: Benchmark Mode Samples Score Score error Units c.k.j.NullTestBenchmark.test_Objects_nonNull_isNull ss 10 1170.900 361.481 ns c.k.j.NullTestBenchmark.test_Objects_nonNull_notNull ss 10 1259.000 910.255 ns c.k.j.NullTestBenchmark.test_direct_comparison_isNull ss 10 1463.800 4361.691 ns c.k.j.NullTestBenchmark.test_direct_comparison_notNull ss 10 673.100 298.587 ns
&gt; I think that the idea that a popular JDK class can change in-place to become a value type is a fantasy so farfetched as to not be worth worrying about. But that's exactly what Brian Goetz said at one of his talks.
Something seems off, because your "not null" and "nonNull" tests, you forgot to negate them (in the posted source, at least), but still... "isNull" and "notNull" have a different score, and one which doesn't seem right logically.
&gt; nice-looking code is secondary to such attributes as performance, compiled size and **maintainability** (by future Java developers). All the things you're arguing against is not just to produce "nice looking code" in some kind of artistic sense... "nice looking code" directly impacts maintainability of your project. 
Useful and easy to use!
Shouldn't we be using FXML? Java FX? 
Sure! But I'm giving a person hope he/she can still use Swing and achieve good UI's
Right. So if I understand correctly, you would have some sort of pre compiled jar that you would then copy into the local directory and access through your maven / gradle build system? Which is then turned into a zip and uploaded?
The creators would be good to create a user guide or some other documentation to learn from. Its tough to learn with what is available.
 String x = Helper.functionOne(); if (x != null) { x = Helper.functionTwo(x); x = Helper.functionThree(x); if (x != null) { } } vs Optional&lt;String&gt; x = Helper.functionOne() .map(Helper::functionTwo) .flatMap(Helper::functionThree); Does someone have a short explanation for why he picked `map` for the first call and `flatMap` for the second. I've never understood the difference between the two frankly.
It all goes back to math theory. You first have to understand Monads and Functors... Just kidding, it's actually very basic, look at the signature of the callables for each method, more specifically the return type: // Return type for map's callback: &lt;? extends R&gt; // Return type for flatMap's callback: &lt;? extends Stream&lt;? extends R&gt;&gt; This means the callback of map() always takes **one input item** and returns **one output item**. But flatMap()'s callback is more flexible, it takes **one input item**, but can return **zero, one or more output items** (as a stream). The stream you return from flatMap()'s callback is merged into the final stream (which sort of explains the "flat" in the name: it doesn't produce a stream of streams, it's flattened, instead).
Map unwraps the value (if it exists), and wraps the return value of the function in an Optional. FlatMap takes a function that returns and Optional, and doesn't wrap it again. Basically use FlatMap to chain a bunch of functions from A -&gt; Optional&lt;B&gt;, map to use functions from A -&gt; B inside an Optional. 
So in this case it's because functionThree could return null?
&gt; You first have to understand Monads and Functors... I will be honest, these are terrible names. Part of me is convinced induction into functional programming involves accepting cryptic names as a barrier to entry to ensure elitism. (This was a conspiracy theory esque comment. I don't really believe this - but you have to agree 'Monad' is not a good name.)
In those case functionThree would return Optional&lt;String&gt;, but yes. 
That's possible, but quite cumbersome. Maven allows you to have dependencies between modules in a project, so that any changes made to *common* module would be automatically picked up when building the main module and bundled up in the output jar. No need for pre-compiling or copying anything, just a plain old *mvn clean package* will do everything for you :) Heck, you can even make maven deploy it automatically to AWS when you're at it but that requires some configuration
Well yeah. Also, when I think about it now, you can call another lambda from within a lambda (sync or async), although when I last used it, the overhead involved in this was too big to be worth it.
Makes sense, but definitely doesn't help.
What is your preferred technique?
Almost thought I was in /r/haskell for a minute 
I mean your scripts hay you check in to source control have no relation to the structure of your database. And you shouldn't need to connect to prod to figure out what is actually running in pros. Your source control should define prod.
I wrote a blog post about my thoughts on the matter. https://www.hidefsoftware.co.uk/2016/12/24/can-we-do-better-than-database-migrations/
Me, obviously. 
What if I'd like to return three types from a method? Four? Five? `Either&lt;String,Exception,Boolean,Integer,Optional&lt;Int&gt;&gt;` ? Whereas I get the idea behind this construct, it is really tempting to abuse it. I am seeing improper uses of optionals in our codebase almost every day. I bet that introducing more monads into Java world will not improve the situation, but make it worse and harder to control.
I'm sure the IF statements are still there at a bytecode level.
It does define prod. You run the scripts, you get prod. My test suite builds a database from scratch all the way up to prod for every single test run. I can even tag the schema at any point and roll back and forward from that point however I please to reproduce any environment we've ever deployed. No need to connect to prod ever - in fact I can't, for regulatory reasons. 
That's a Coproduct5. Probably don't want that but it's your code. We typically have 2 cases in a API handler, the left side (errors) are immediately coerced into HttpResponse objects representing various response codes. The right side carries the parsed data through business logic, serialization, etc. The big deal is that there are two outcomes at *most* (but not all) points, success and failure. If json parsing succeeds I get a JsonNode, otherwise I get an exception (or error message, etc.). We end up never having more than one of two states at a time. If you have up to five states at a given moment, I'm a bit confused on how you got there, but you probably do not want an Either or similar. 
DDD has nothing to do with ORMs or JDBC. Like you say, in DDD, you would create classes representing domain objects which hold the business logic of the domain. How these objects come into being is in a separate service layer. You don't have to use injection for this. In fact the original DDD book by Evans uses singletons. This is not considered good style these days, and dependency injection is the more preferred approach because it is easier to write tests for and makes dependencies more obvious. You should use Repositories, because this maintains the integrity of the Bounded Context by limiting access through the Context Root. An Order would be a context root in this context, and Line Items and Shipments should not be directly exposed to ensure integrity of the Order. You don't have to load the entire graph to do this, but somehow allow the Order to make queries through the service layer. &gt; Is it good practice to have Spring inject Spring managed objects &gt; (repositories) into unmanaged domain objects? Yes. In general, this is called Dependency Inversion (not Injection). The domain object should expose requirements for external services through interfaces, and Spring simply arranges for concrete implementations of providers of these services to be provided at runtime. &gt; Issuing multiple queries? Obviously issuing multiple queries has a &gt; cost, which may vary depending on the amount of queries being &gt; executed. That is an implementation detail of the Repository. The Repository should only define access methods in an way indicating the application's requirements, and the repository arranges the queries in the most reasonable way to meet performance requirements. &gt; How would once approach DDD when not using an ORM Approach DDD by first forgetting about ORMs or JDBC (since these have nothing to do with the domain). Instead, focus on the domain, and design a classes catering to the use cases, behaviors and language of the domain. Any time you find yourself wanting to reach out to a database, create an interface describing what you want. This is how you separate the business layer from the service layer. The database and how you access it (ORM, JDBC) then becomes an implementation detail.
Yes, I'm aware. I should be more clear that this is only my own personal prediction: it will never work.
everything is basically "jeq" or "jne" anyway at the lowest level. Its all just syntactic sugar.
Generally speaking... &gt;Is it good practice to have Spring inject Spring managed objects (repositories) into unmanaged domain objects? No. Logic inside domain objects should be all about the business. Persistence is part of infrastructure. &gt;In order to accomplish this you would need to either load the entire graph, or inject the repository / dao into the domain object so it could fetch data as needed. I'd load the entire aggregate (which should be a relatively small graph). &gt;How would once approach DDD when not using an ORM like Hibernate, lets say SpringJDBC Template, JOOQ, JDBI, or something along those lines? It would just be a different repository implementation.
&gt; I am seeing improper uses of optionals in our codebase almost every day. Yup, people blame the *concept of null* on all the null abuses we see, but introduce a new concept, and we take our null abuse and turn it into Optional abuse just the same. Except null is still around, so now we have to deal with both.
Did you use haskell books or articles to understand ideas used in ScalaZ ? (I suppose there's a lot of shared ideas there)
As someone who has used them I'd say yes. I get a lint warning for accessing an optional without checking for its presence. Checking for presence protects against NPEs
'More efficient' means e.g. without having to learn SQL in the first place. Or being able to switch between a SQL and several NoSQL databases, without having to rewrite every query into the respective NoSQL language. 
I still haven't heard a compelling argument for why it's better. All I hear is subjective opinion that it's more readable or that it's best because that's the way it's always been done. I disagree that obj == null is more readable and I absolutely detest the argument that something is better simply because it's always been that way. Many projects that I've worked on have had some utility class for checking/enforcing nulls so the Objects class seems like it must be scratching a common itch. I understand that Objects#isNull and Objects#nonNull were added specifically for streams, but I personally think it makes sense to go ahead and use them elsewhere if for no other reason than consistency (although I find that to be a weak argument), but specifically I find them more readable. 
* [libGDX](https://libgdx.badlogicgames.com/) * [jMonkeyEngine](http://jmonkeyengine.org/) * [lwjgl](https://www.lwjgl.org/)
Optional is implemented with conditionals, so he is abstracting out the ifs and making the code more complex than it needs to be.
Monad is when you only have one testicle. /j
Uh I'm pretty sure optional is using 'if' under the hood. You're just using 'if' with syntax sugar as far as I can tell. Or am I missing something?
To be fair, lwjgl isn't a game engine. Let's not confuse any beginners that may come across it.
What's the most popular game in the world? 
That would be Minecraft.
When you say Vlad Mihalcea, you're referring to the [professional football player](https://en.wikipedia.org/wiki/Vlad_Mihalcea) that plays for Steaua București?
&gt; 'More efficient' means e.g. without having to learn SQL in the first place. I really don't think you can skip learning SQL. This is how we end up with so many badly implemented projects in the first place. For non-trivial queries you should always go and check what Hibernate does.
Yes, I would say it is generally an improvement and sometimes a substantial improvement. Using monadic functions like Optional#flatMap can be a huge improvement over the equivalent non functional code.
They really should add that to the documentation for Spring Boot. I created a Spike that did this a while ago and it was quite a bit of work trying to figure out how to do it without Stomp. 
&gt; How do you 'share' code between lambdas? Same way you do it with (for example) microservices; include a library that contains the code and assemble it with the other dependencies in a fat jar. There really isn't a difference between dependencies you create (internal 'helper' libraries) or external dependencies.
&gt; That being said, you can simply create create a common module for your project where you put the common code that is shared between lambdas and make sure it is deployed with every lambda function. We actually have a separate 'libraries' project with a bunch of different helper libraries (cassandra, serilization, test support, etc.). Our microservices all live in separate projects (which I'm glad of, you'd get a monorepo of monstrous size otherwise) so we can't simply have a shared module. I also worked on a microservice project where we had a monorepo and I really prefer our current approach. Yes you need to make a change to the 'library' project and then "install" it but that's just a few seconds work. But since the library is versioned you can easily make changes without breaking every dependant service. 
&gt; Right. So if I understand correctly, you would have some sort of pre compiled jar that you would then copy into the local directory and access through your maven / gradle build system? You use that dependency the exact same way you use external dependencies. These all (typically) get assembled into a fat jar.
Per Wikipedia, across all platforms, Minecraft has sold over 100M copies. https://en.m.wikipedia.org/wiki/List_of_best-selling_video_games Only thing that's sold more is Tetris.
I recommend mini2Dx, I recently wrote a 2D game in it for a project and it's very easy to use and well-documented. It's specifically made for 2D and built on top of libGDX.
If you end up using some NoSQL solution, you can skip SQL. Those projects that were bad because of abuse of ORMs, you think the very same people who made that bad decision would do much better using SQL?
depends how you define game engine and I know I'm pushing it a bit here, but about the only thing lwjgl doesn't give you now a days is 2/3d collision / dynamics - seriously the range of libs if covers now is amazing... lwjgl2 is *sure* isn't!
Two games about building blocks....
But it's not at all unnecessary. It's leveraging the type system to ensure that client code is correct. When I return Either or Optional from a method, it forces the caller to write separate code for each case that can happen (assuming you ignore the existence of nonsense like Optional.get()). This is in contrast to forcing the use of an if-else construct, where the compiler has no way of enforcing that you wrote *both* the if and the else. This all probably seems trivial if you are looking at a small example. But if you have a lot of people working on a large codebase, these little things add up to help you write code faster and with less errors.
To be fair, libgdx isn't a game engine either. It's a framework.
Technically correct but not the point.
That quote and code snippet are not from the same sections of the article. 
Yeah not on PC. Our network has a full GTA clone and dead island clone for example. Models, sounds,behavior, all that shit
Yeah the Spring ecosystem is really good for building web apps. I already build some enterprise applications with spring. Also Thymeleaf is a good web framework.
While Hibernate is good, it may be better to learn the JPA standard, of which Hibernate is an implementation.
I like Slick2d also. Just made a simple space invaders clone that can be used as a reference. https://github.com/itaiag/space-invaders
I would vote for Spring too. for web development and microservices, I would suggest looking at groovy and grails. it's built on top of spring boot with lots of nice add-ons
Let's break it down: Helper.functionOne() This will return `Optional&lt;T&gt;` which has the `map` and `flatMap` methods. .map(Helper::functionTwo) `functionTwo` accepts whatever `T` is and returns `U` (which may or may not still be `T` -- the point is that it *could* be different). `map` will handle creating `Optional&lt;U&gt;` .flatMap(Helper::functionThree); `functionThree` is similar to `functionTwo` in that it accepts `T` but instead of producing `U` it produces `Optional&lt;U&gt;`. `flatMap` is smart enough to not double wrap this. In this particular case, `functionThree` produces `Optional&lt;String&gt;`. Imagine if you had accidentally pass `functionThree` to `map` -- you'd end up with `Optional&lt;Optional&lt;U&gt;&gt;` whoops! Compilation error, your IDE starts yelling, etc. But there is a benefit in being able to return a new optional when needed, but only if you have a way to *flatten* nested Optionals together. That's exactly what `flatMap` does (or rather, leaves you to handle). Let's say you have a use case to upgrade a customer to premium status. You go to the database looking for customer 12345. Maybe you find them, maybe you don't, so you're dealing with `Optional&lt;Customer&gt;`. And then you have a method that takes in a customer, looks at some attributes about them, and will upgrade the customer returning `Optional&lt;Customer&gt;` or if it cannot, it will bail out and return `Optional&lt;Customer&gt;.empty()`. You can model this as: CustomerRepo.fetch(id).flatMap(Customer::upgradeToPremium); Sure, this isn't a super compelling example *but* it shows the real value of `Optional&lt;T&gt;` (and similar abstractions such as Either), `map` and `flatMap` will only run when a value is present in the Optional. If the optional is empty, then the methods short circuit and you just get an empty optional. If the initial fetch fails, we never run `Customer::upgradeToPremium`, if we do run that but the upgrade failed, we'll never run any further operations on it. If the upgrade succeeded, but a future operation fails, we short circuit there (maybe we only want to persist upgrades if you're name is Jeff or it's the first Tuesday of the month).
The best way to do this is to use CloudFormation to automate the deployment of your application. That way, you can your lambdas get their code from the same S3 bucket.
You can download the example projects listed in the tutorials from https://playframework.com/download -- they include a packaged "sbt" build tool with them.
"Let's add as many dependencies and abstractions to our objects as possible so that new guys need to spend more time learning the codebase before they can meaningfully contribute"
Spring, Play and other things are all nice and I have nothing against them. They all do have a learning curve associated with it. My advice would be to start with the standards and grow from there as and when needed (case of new job or standards not able to fulfill your needs any more and you need something more cutting edge for e.x.) The stack i would recommend is: 1. Java EE 7 2. Java 8 3. Wildfly application server (It comes with Hibernate) Java EE 7 and Java 8 are very productive and are perfectly fine for all scales of projects, I know of many companies running a pure java stack and are happy. There are many benefits of starting from standards. You can move on to other frameworks, but can carry on the concepts you learnt. Standards also bring in their own accompanying modules and projects, for e.x. frameworks for testing, builds, packaging etc. You can also focus on gaining the knowledge when you need it, no need to side track. You do not need to start with learning the entire stack, for e.x. start with JAX-RS and once comfortable move on to JPA or whatever your next challenge is. Regarding ORM, We have many vendors in java ecosystem, but all of them support the standard specification (JPA), so as long as you follow the specification you should be good. Also, following the specs does not "limit" your options, they are broad enough to meet many of your usual use cases. Regarding where to start, Official documentation, Adam Bien's blog/Youtube channel can help you start with it.
I would pick up the Java EE framework. Look specifically at JSF and add PrimeFaces and OmniFaces.
Great advice. To add to it, learn Thymeleaf for the templating engine.
&gt; This is in contrast to forcing the use of an if-else construct, where the compiler has no way of enforcing that you wrote both the if and the else. Checked exceptions *are enforced by the compiler*, and what's author's reaction to this type safety feature? This: &gt; they are extremely annoying Ok. Well? Turning all code into Streams to which we should pass static method references and lambdas looks even *more* annoying. So to each their own. If you want type safety, we have checked exceptions. We also can use Either-like Result objects without map/flatMap/match/etc. This is far less disrupting than turning your code into poor man's Haskell.
Well I mean I hate to argue semantics, but the most popular game in the world is probably [Crossfire](https://en.wikipedia.org/wiki/CrossFire_\(video_game\)). League of Legends is also high up there. Those games are technically free to play which is why they don't show up in that list.
But checked exceptions ARE annoying because they are handled poorly in the Java 8 Stream libraries. Think about what checked exceptions are: They're just a special case of sum types, except with horrible performance penalties. What the author does is properly implement real sum types that can be used for exceptions or any other case where you need a sum type.
Where? Not in the bytecode compiled from their source, other than the dozen or so they mention. Why would there be? Inlining is the only thing I can think of which could feasibly increase the number of if statements between source and bytecode levels, but it's performed by the JIT, not by the compiler afaiu. (Or the ternary operator I suppose, but I doubt they've been replacing all their ifs with those since it basically suffers from all the same problems they have with if.) I'm not saying I think it's wise, but clearly they've eliminated most of them by factoring branching behaviour out into library code, so there really will be far fewer if statements. They won't be evaluated any less frequently at runtime (or have magically disappeared from the standard library), but that's not what they're claiming. The article is about "writing Java without if" not "executing code on the JVM without if".
You probably want to have a look at http://actframework.org There are 5mins video on how to code a hello world in Act from scratch There are sample projects on how to have db access on both SQL and MongoDB
There is this framework not related to your question I have learned and have emotional investment in. You should totally learn that. Everything else is total garbage. Don't waste your time, your chances of reproducing will drop immensely. 
Culture flag? Come on. 
Js frameworks such as angular are large and complex enough to deserve to be treated as a separate app, decouple. 
Yeah, but at least it still hast a lot of important features
I disagree. Better to get used to doing things the Spring Boot way than get used to a not as good way.
Akka is just for reactive streams.
Is this the same [Reactive Client API](https://jersey.java.net/documentation/latest/rx-client.html) introduced in Jersey 2.18?
Oracle certainly makes not much effort to get it's software installed on Linux. Neither technically, nor from the license point of view. As an example it does not provide Java packages. Maybe it is too difficult to install a browser toolbar along with other software on linux.
Some aggressive dropping of support of other framworks is going on, compared to Spring 4 release. Those decisions are usually tough, leaving some users behind, but reducing the maintenance drag. 
It also sounds like maybe the teacher isn't teaching about the *problems* that a specific design pattern is used to solve, which is kind of the reason for their existence. Knowing a grab bag of design patterns is kind of pointless if you don't know how to recognize when applying a specific pattern would be useful.
Starting with vanilla Java is a great way to get bogged down in re-inventing the wheel. This is one of the reasons I suggest Dropwizard, it's more a collection of "best in class" libraries than it is a framework.
You won't see much new development that's for sure.
It's an OOP course, so it seems reasonable to teach OO solutions. Of course OO isn't the only way, though, and it would be good to not give that impression.
The NotJava™ framework is best for Java Web dev.
Who said anything about OOP? Of course it's an OOP course. It's Java. Granted, OOP is the one "design" pattern it is hard to avoid in Java, but that is a complete red herring. If the teacher is merely giving out a list of specific classes and interfaces to use for a given design pattern then that is wrong. However, I suspected that is what the teacher is doing because the OP mistakenly believes a "design pattern" is merely a collection of classes and interfaces one is supposed to use for a given problem. Also because far too many teachers these days have devolved their curriculum to be nothing but a list of things to memorize, because that makes it easier for students to get better grades.
I misread your comment as teaching classes and interfaces rather than specific ones. Whereas implementing design patterns with classes and interfaces is normal in OOP, teaching specific ones as the one true way is really messed up. 
looks good but how would you implement sending a message to a user and not all users ? 
I gave up at the the 3 minute mark. There's a clear lack of preparation or consideration of context. There's a definite value in the topic but I have other resources that hooked me. YouTube is a wonderful medium for conveying a lesson but these long rambles drive me nuts. Start with a rough list. Try to prepare as much material ahead of time. Capture a session and edit it down to only the interesting parts. IDE of choice and whether or not the paid version is worth it is outside the scope. Time is money. If you want to hook me for a half an hour, you have to provide something I consider woth that. Perhaps consider a series of incremental videos, easier to digest and limited in time and subject, rather than a demonstrational lecture. There are way too many of those as it is. I'd rather read a book than sit through an hour long ramble-nar recorded on a tinny sounding mic.
Can JHipster generate React + Redux front-end instead of Angular? 
They are mostly useless except for selling books.
+1 to the question by /u/MassiveDiarrhea regarding react. I see a react extension project on github, but it has been inactive for over a year. Could the OP please elaborate... -- Edit: @/u/julien_dubois, 1 more question, are there plans for generating an (Spring) application that is packato be deployed to a OSGI container like Apache Karaf?
Apache is broad description, mmhmmm.0 .. Who dis?!
I don't think they're useless at all. Some general problems come up frequently. Patterns can provide a commonly understood way to efficiently solve the problem in a way that other people can recognize. 
It appears to be a [work-in-progress](https://github.com/hipster-labs/generator-jhipster-react)
&gt; I have a good experience in programming, been doing so for the last 6 years Sorry, creating his own JSON parser or request router is not going to help him be productive quickly. I would agree with you maybe if he were fresh out of college.
Thanks! I will definitely try to improve upon it if I do more.
On this page we will provide spring boot custom banner example. On the application startup, spring boot prints a default banner. We can change default banner using banner.txt file in classpath. We can also change default banner programmatically using spring boot Banner interface. If we want to show image as banner then put the image file in classpath named as banner.jpg, banner.gif or banner.png .
https://youtu.be/9Di_mwsL6zI?t=28m30s
&gt;[**The Bootiful Application (Josh Long, USA) [50:53]**](http://youtu.be/9Di_mwsL6zI) &gt;&gt;Alright, so maybe “bootiful” won’t ever work, but I tried, and it was worth it too because you’re reading this. Spring Boot, the new convention-over-configuration centric framework from the Spring team at Pivotal, marries Spring’s flexibility with conventional, common sense defaults to make application development not just fly, but pleasant! Spring Boot aims to make address the common functional and non-functional requirements that gate quickly moving to production. &gt; [*^jeeconf*](https://www.youtube.com/channel/UCaGHGAZiSwb8if6yfBF4NLA) ^in ^People ^&amp; ^Blogs &gt;*^1,225 ^views ^since ^Jul ^2016* [^bot ^info](/r/youtubefactsbot/wiki/index)
&gt; Mind you don't use spring boot That's just bad advice. There really isn't any magic going on, @SpringBootApplication just enables @Configuration, @EnableAutoConfiguration and @ComponentScan (which you probably want anyway) and the starters are just pre-packaged sets of dependencies. 
I would suggest keeping a somewhat more open mind when you're being taught stuff. Rejecting stuff that's new because you don't understand it yet is how senior developer with 10+ years of experience end up rejecting lambda's because they're "pointless". If you're not careful this is really going to damage your career. 
Try JHipster. Spring as backend combined with Angular as frontend, cobbled together with an easy init generator should give you a jump start.
Nothing that you learn will ever be pointless/useless. You need to open your mind. Take a look at [Java Design Patterns](http://java-design-patterns.com/) as this site will give you detailed explanations of the Design Patterns, their use cases, and sample implementations.
Funny how a "This windows isn't Genuine" message pops up in the first minute. Aside from that you're making nonsensical claims. For example about a 3-tier architecture requiring "3 cross functional teams" to work on it, SOA being tied to using a service bus or that a microservice automatically means that it's REST based. Heck; you can have microservices that communicate via a bus just fine. You also managed to not mention the largest problem you run into with microservices; the lack of transactionality. So frankly I most seriously doubt you even have experience with a MS architecture. TL;DR: typical Indian blog spam but read in a YT vid. Nothing to see here. 
Do what those weight-loss adverts do: Start of with a great body, put on a lot of weight (the "before") and then loose all that weight again (the "after"). Start with well optimised, clean code, make it dirty and buggy (the "before") and then work your way back to the start (the "after").
So, a copy paste from documentation now counts as an article?
You can also do the same thing with Nginx if you prefer that. 
&gt; 1.4.3.RELEASE is current It was until [3 days ago](https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web/1.4.4.RELEASE) ;)
To summarise OP: Learn Spring and Hibernate and definitely not Spring Boot so you learn all the concepts. Or just learn Spring Boot as it gets you up to speed faster. Then tack on Thymeleaf for templating...actually it's not that great so just use Handlebars or Mustache instead. Also maybe scrap Hibernate and just learn the JPA standard instead. Actually Spring is a culture flag so check out Dropwizard, Spark, Play, Vaadin or Jooby instead. But while those frameworks are all great, why not just start with the base standards using JavaEE, Java 8, Wildfly and JPA instead? Simples :) ----------------------------------------------- PS: Not criticising anyone. I'm in a similar position to OP, trying to figure out the Java webdev landscape, and while I like all the choices available, I get choice paralysis reading so many strong opinions in different directions. Even with Javascript, there's at least some consensus that learning vanilla JS is preferable to learning the frameworks but here, it's not so clear...
Yes, I did this and it doesn't work. In /etc/apache2/sites-available/000-default.conf. My Spring-boot application works on localhost:8080/vuln/. Should I add addictionaly configuration in my spring-boot application? I don't use TLS in my app.
The Thought Works [Tech Radar](https://www.thoughtworks.com/radar) is often worth a look when deciding what technologies to look at. 
Hilarious. Thanks for the laugh.
I agree with the feedback given so far - it felt off the cuff and therefore slow and unprepared. I gave up after about 5 minutes. I suggest writing yourself a script or making an outline of what you want to go over to make sure you hit on the points you want to make. Maybe re-try this video with a script and shorter format? Perhaps Just focus on variable/method renaming for clearer intention? That would also give your videos a descriptive title so I know what I'm getting into. Some editing would help as well. For example: cut out the part where you look for the Code Inspection rules and then just give up on it. You might also want to be kinder to people who are creating open source software. Telling them their code is terrible and that you're better than them is a great way to have them just stop listening to you altogether.
Thanks for the feedback, just to answer your points in order: 1. Yes JHipster is made for people who know what they are doing. Then, if you have no idea how to use Spring or Angular, starting a project from scratch is not really an option either! 2. Angular 2 support is already on our master branch, and already thousands of projects have been generated with it. We'll release it next week, hopefully. 3. We have fun with the branding, then of course that depends on the person. 4. In the next release we'll move to Yarn + Webpack 5. The "war" is in fact a "jar" file, which is doing exactly what you ask for. We just kept the "war" suffix so it works also on app servers. 6. There will be less in the next release, as we have a client and a server side library now.
Hi. Thank you for replying @julien_dubois. Pardon for making a slight diversion from OP's question but I was fascinated by the integration with spring boot. It is possible to make a spring security project with JWT and angularjs as frontend?
Yes we support JWT with Spring Boot (and Spring Security) on the back, and Angular on the front. In fact, that's our more popular option for security.
&gt; What if I'd like to return three types from a method? Four? Five? I'd say go back to the drawing board and reconsider is this what you really want out of your code? I would wager no.
Thanks, you too.
&gt; you could replace spring with literally any single other thing in the world Sure, and maybe I would if I ever saw that, but Spring is one of the very few technologies I see this phenomenon with so... &gt; Also you're saying, when you hire according to your prejudices, you only work with people who share your opinions? I like to hire people who have done many things, especially things I have not done. I find that that leads to more diverse problem solving. I think you're trying to bend my words to mean something I don't intend. &gt;I think that using a single framework at their last job is not a good indicator of this. I specifically indicated people who have spent careers / decades / multiple jobs using this tech stack. Again you're implying I said something something I didn't. If someone used Spring at their last job and otherwise had a diverse resume I wouldn't hold it against them. If a junior engineer had one job on their resume and it was Spring I wouldn't hold it against them. If someone moves from Spring job to Spring job then yeah, my experiences and those of my peers generally point at that person being difficult to work with and I don't see that with any other tech. 
Why should this be a special security problem? If some external malicious entity sends you Java source code that you then compile and execute, then you didn't sanitize your input properly. It's the same as with deserialization and SQL etc. injection. If they are in your system already, well using this would be rather roundabout and pointless. Oh and you can also compile and execute JavaScript, Ruby, Python and others in Java.
If you need help with your own starters or autoconfigurers, feel free to ping me. I write quite a few for work to reduce boilerplate across projects :)
Great, thanks!!
Quite right. Be declarative rather than imperative. If hibernate is suggesting that it's database transformation tool is not up to the job, that's just another reason to separate your database project from your application code. I mentioned a few tools for different platforms that are more than capable And if you're still not confident, you can review the generated scripts before running them. The point I'm making is about the way you write your code, not the tools you use to implement it (you don't have to use hibernate)
It's only a security problem in the sense that it may significantly increase the attack surface, if you somehow were able to execute ad-hoc Java source code. I'll also point out that Tools.jar must be explicitly included as a dependency in Java 9.
That guy apparently didn't get the memo that the Java compiler just produces .class files; if your code loads unverified .class files, you have a more serious problem.
Java actually has its own Javascript interpreter. I once wrote an automatic test framework that injected variables into Javascript code and executed it, making the creation of new tests as simple as creating a Javascript that used the available variables, allowing for some somewhat complex test cases. The loops he jumps through just for this example seem fun, but impractical (and the allowing of executing the produced classes seems to me like a big no-no). 
Thanks for the feedback. I added a section on `CompletableFuture`. The reason that `future.get()` is called is to verify whether the database calls were successful or not as to return the appropriate HTTP code to the client. 
The purpose of the asynchronous operations in regards to the test scenario is to perform four db writes concurrently and then return either 2xx or 4xx response depending on if their execution was successful. 
Listen, don't get disillusioned....the world of programmers is full of assholes and idiots who will critique anyone. Being on the spot and just winging it will make you look unprofessional, but being able to turn garbage non-readable gobbledy-gook into something elegant is exactly what we need. You're right, we need more code craftsmen out there. Someone judging you for slowly moving through it, they clearly don't deal with shitty libraries. Saying "Uh" a thousand times....yeah...because you are pausing to think about this library that makes sense to few people...let alone the creator a year from now. The fact you had the guts to flip on the camera and just go off into the forest, that's professional enough for me. You're Steve Irwin marching off into a swamp full of gators...."Here be Dragons". Sure if you rehearse and cut your videos and take out all the ums and show only patterns.....yeah man, we know that's not how it works in the real world. This isn't Hollywood where two people ham out on a keyboard to hack the gibson....it's just casually working through a library and cleaning it up. Really hope you finish what you started and clean this library up. Make all of your edits at the end for these assholes and feed them the short and sweet if they have the attention span of goldfish... As for me, I pair program exclusively and it felt like you were right there next to me having an honest conversation. I followed it and enjoyed it. You and I both know there will be some opportunities to come across great patterns and implement them. You'll make mistakes, and you'll fix those mistakes. We'll laugh....we'll cry.....blah blah blah. Keep it up and don't get discouraged. 
Are you being serious? Are you even a programmer? That is not how this works....smh
Agreed. The plugin you might be interested in is called [Presentation Assistant](https://plugins.jetbrains.com/idea/plugin/7345-presentation-assistant) It pops up a little green banner on the bottom any time you fire off a shortcut with the Mac/Windows equivalents. Great tool we use in pairing environments. Really hope this guy keeps it up, looking forward to seeing what comes of this. Looks like he could use a little motivation. &gt;Thank you for the very constructive feedback. I created this first video on as a spur-of-the-moment thing to see how it went. I will incorporate your feedback if I produce more.
Yeah, Java lets you put the brackets on either the type or the variable. **Do not do this in new code**. As the [Java guide for arrays](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html) says: // this form is discouraged float anArrayOfFloats[]; On a side note, `String...` also works for the main method because it also creates an array.
the bgfx wrapper gives you basically most of that...
This is by far the best explanation I've ever seen of both. Would filtering be expressible as a flatmap operation? (As each value can either return the same value or none?)
Interesting idea. What is the benefit of that? It seems like that would introduce a fair amount of complexity in managing four callbacks to generate one response and that there would be no performance gain.
There is a reason for those variables to be named in a way not consistent with SunStyle. It's because the other implementations of the protocol use those names. That way, when someone comes up with an exploit, and a fix to that exploit, and the protocol is updated in other implementations, you can more easily verify that you got the fix right. Algorithm port maintenance is one of the valid reasons to break rules which are usually reasonable.
ParallelStream also blocks until all tasks are done.
Yeah, kind of. Filtering is a special type of flatMap that's 0-to-1, rather than N.
That's true. It will hold the request Thread from request until response. In the use case I defined, the system could process 20 requests simultaneously before max CPU utilization. Tomcat by default maxes out at 200. If more than 200 requests were expected so that that Tomcat's pool became the bottleneck , then using something like a `DeferredResult` and `CompletableFutures` could help out, or just increasing Tomcat's `maxThreads` property.
Like someone has said, take a simple idea of yours and bring it to fruition even if it's just for practice. Core wise, try concurrency. Also, you can use embedded versions of some popular tools like Elasticsearch, H2(RDBMS), and Cassandra (iirc). You can implement a bootstrap routine using a CommandLineRunner to populate any of those embedded tools. Try Liquibase, see a JHipster app for an example, as it populates an embedded H2 instance. Get going with Spring-Data and Hibernate Entities. Things like Named Queries, JPQL, and Native Queries are useful. Also for core, I've been having fun using hackerrank, or any other tool, and choosing Java 8 for a bunch of the questions. Edit: Since you're familiar with JS and Angular, you might like JHipster since half the battle is over for you.
Thanks for your reply. I think a pet project is definitely the way to go. Also, my proficiency in Java is not that great I know the OOP concepts, classes, inheritance, but that's as much Java as I know. When it comes to keywords like 'interfaces' or concepts like multithreading, I don't know much. Should I focus on learning Java first or should I keep going into building stuff?
Thanks for your reply. 
[removed]
Since this is *programming help*, it should be, as the plenty hints on the page indicate, posted in **/r/javahelp**. Be sure to read the [**Posting Guidelines**](https://redd.it/48eykt) there before posting. **Post removed:** Programming help --- Maybe [this pdf](http://www.fas.harvard.edu/~cscie119/lectures/intro.pdf) can help.
I agree with everything you've said, but I think you're missing the point. Yes, a lot of people abuse them, trying one after the other until something sticks. Yes, there are problems that no existing design pattern solves. However, certain types of problem do crop up a lot in day-to-day coding. Where multiple people over the years have reinvented the same solution to the same type of problem, it is useful to a) publish that solution to save other people reinventing it, and b) give it a name so you can talk about it easily. 
While i agree with most of tips here, I think some of them are a little overkill if you are a beginner! Adding Cassandra + ActiveMQ + Stormpath + redis + Heroku [...] to your learning curve is ihmo not a good idea. Spring is a beast in itself. It is important to start simple and step by step. You said you don't feel very comfortable with Java. I think you should start here. Oracle has [official JAVA tutorials](https://docs.oracle.com/javase/tutorial/). Maybe they are not the best java resources but they helped me to get my hands on by the time. I agree with that having a concrete and not too ambitious project is very important to get motivated to learn by discovering and trying to resolve issues. One important thing ihmo with Spring is not to dive too deeply on the documentation first but to try to get the big picture of what the differents pieces (spring projects and third party libraries) do and how they are fitted together. This last point is important with Spring BOOT because there is a lot going on under the hood (convention and opinion over configuration). Once understund it will be very quicker to know where to search information and how to dig into the documentation. Spring BOOT has it's own documentation but keep in mind this is just a starter and the real work horse is done by Spring Framework and others projects. In my search for information flow i usually start by searching on spring boot doc to see if the topic is covered. If not covered, or not deeply enough, i go to the documentation of specifics projects depending on the topic. One last thing, Spring, like others projects in the Java world, use a lot "stereotypes", conventions and abstractions to name theirs classes. This is even sometimes too much like [this famous](https://www.quora.com/What-are-the-most-ridiculous-Java-class-names-from-real-code) "SimpleBeanFactoryAwareAspectInstanceFactory" class. Theses "stereotype" words add meanings about the role of the class and it really helps to understand what they means. It helped me to create my own small "lexicon" as i learnt thems. Sometime the documentation does not helps in itself. Hope it helps 
Too bad there's no standard deviation in there as well.
&gt; max CPU utilization I think you mean thread starvation not max CPU utilization. The CPU isn't really doing much when threads are blocking on IO in this case network or SQL disk IO. `CompletableFutures` won't help in this situation unless you use custom thread pools. If `DeferredResult`is Tomcats version of async HTTP that might help. If you want many concurrent connections you need to look into async HTTP or non blocking. The thread per connection model doesn't work well for lots of concurrent connections.
It may be the new emerging hammer for every nail!
I think you can kill two birds with one stone, you'll learn a lot of Java by building, so might as well get right to it! Also interfaces are really at their core just contracts, you make an interface that has 3 methods and any class that implements that interface must implement those 3 methods with the signature described in the interface. It's like having a common API. And there are many a tutorial on setting up multi-threading with spring and Java. Just make sure if you're going to multithread certain processes that you understand the concept and design before you dive into the code because it can be tricky to reformat a complex single threaded process into a multithreaded process.
I run most of my software as microservices on AWS EC2 nano or micro instances; opening and closing TCP/IP connections when calling other APIs adds up fairly quickly in terms of CPU utilization when dealing with such little horsepower.
Learn how to [deploy](https://carlmartensen.svbtle.com/step-by-step-guide-to-building-and-deploying-a-database-backed-spring-boot-web-application-in-aws) the applications into the cloud.
Yes, but like I said before the patterns are all fairly simple and straightforward. You're not reinventing the wheel; you're reinventing the rock -- something that anyone can simply stumble across with little effort.
Well, Fowler actually says something similar. He says SOA is a big umbrella and Microservices is one way of doing SOA. But I tend to agree with him and Eric Evans, in that SOA and Microservices are not the same thing. SOA is more about segregating the functional parts of an application into different applications, like a core application API, an Admin site, and a Customers site. While Microservices is about segregating the bounded contexts into independent web services.
Not really :D I think most conference speakers are already saying for a year that it is really, REALLY, not a silver bullet. Although 3 years ago that's how they were speaking about Microservices...
Kinda already is, at least at my company. So we had this giant stateful old mofo of a business information system with large SQL db underneath and one day the decision was made to MICROSERVICE ALL THE THINGS and also TRANSACTIONS ARE EVIL AND SHOULDNT BE USED UNDER ANY CIRCUMSTANCES, EVENTUAL-CONSISTENCY ALL THE THINGS. Yeah.. and then it was discovered that shit was broken down way past domain level (for sake of having multiple apps) and those several apps now have consistency issues because they heavily rely on data of other apps and since some persistent messaging hasnt been fleshed out yet, everything runs on HTTP/rest synchronous apis which because of experimentation with hybrid cloud are unreliable as all hell and retry barrages with no circuit breakers run amok. Also monitoring of all the apps is not working as intended, and log centralisation+analysis ended up being a total joke which doesnt help at all when one usecase spans multiple calls though a number of apps. So now there is ton of inconsistent data and our take at eventual consistency so far has been "welp, shit's broken and somebody has to fix it... eventually". I'm partly to blame for some of the designs, so.. a lesson has been learned but fixing this is still gonna be an uphill battle of defending usage of some of the older patterns where applicable.
Not what he asked for.
Spring has so many modules. Try them out. Spring security, spring data, spring rest etc
Well, if we have a core application API, a frontend application "Admin" and another frontend application "Consumers", that connect to the core via its HTTP REST API, then we have SOA. However, are you gonna call it microservices? All the domain bounded contexts are in one REST API monolithic core, and I see nothing micro about it, so I would not call it a Microservices Architecture, but I would agree to say that it is one way of doing SOA... So I don't agree that they are 100% the same thing. :)
Since .get() is a blocking call you end up having a thread stuck waiting for another thread to finish. You can add abstraction around it all to make the callbacks less confusing if you need to, but since threads are a finite resource, having one stuck per request means you're at best wasting resources/through-put and at worst leaving yourself open to a DoS attack.
We have so many developers (all in one openspace), that we got split into 2 scrum teams, currently developing one small component - you could call it a microservice, both touching the same classes... Yet half of the developers are writing regression tests anyway (in abysmal quality needless to say) because we don't have enough of testers. Our traffic is so small that anything would work just fine. RabbitMQ might have some benefits, but the reason for choosing it was only to have some new toy... We have nice clear logs (in new components at least), but our new OPS team probably does not monitor them. I just found out that we have badly configured backend call, which results in hundreds of SocketTimeoutExceptions each day, and nobody noticed it for more than a year. The old OPS team based in the UK would have problems even with one WARN in logs, but they were outsourced, and now there are many useless ERROR stacktraces due to incorrect error handling and nobody cares... I had a career break for a year, at that time all good devs left, and now I can see what was done to the code, it is quite sad indeed.
What's next, a server per MS?
Yeah, I didn't see an apology for being a jackass in any of that.
Well I mean they literally told us: "Study design patterns for exams." So I didnt even really know what they are.
What's the point here ? This is wrapper to org.bouncycastle.crypto.* ?
I used apache james for a specific product that could receive and process xml payloads via email. It works, but documentation is scarce. Most releases didn't work OOB. In the ended we ended up switching it to just receiving the email files to a global Maildir, and having cron script that read the email message files and sent them to the web service.
old trick I learned by mistake, way more screen real-estate for code!
The JDK? http://www.oracle.com/technetwork/java/javase/downloads/index.html
[JDK](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html) / [OpenJDK](http://openjdk.java.net/) and [Eclipse](https://eclipse.org/) / [BlueJ](http://www.bluej.org/) / [IntelliJ](https://www.jetbrains.com/idea/)
If none of these comments were it... Netbeans?
jGrasp? Do CS classes still use that?
maybe not directly but using its intended API https://google.github.io/guava/releases/21.0/api/docs/src-html/com/google/common/base/Optional.html#line.259
That's really cool! I was toying with the idea of making something like this for a while, but never got around to it. It's super useful in an IT context where I have lots of sites, directories, and files that I need quick access to repeatedly. I'll check it out!
My first Java class used Microsoft Visual J++ Yeah...
You could always ask anyone else in the class, or the teacher. Why start a guessfest? 
Oh you mean like bad jokes and shitty sarcasm....fortunately yes those things do.
He summarizes the thoughts of several respected developers. You have a poor attitude towards learning.
I am going to live the same life. I joined a new project recently, which is to break the big old system into small micro services. we are told, to break away from the traditional transactional model and embrace eventual consistency. Any advice on how would you do this differently from your experience. I don't have say in micro services. but anything to not screw up?
It's either Eclipse or IntelliJ community, though you can get Ultimate with a student email account. 
One important difference is that in SOA, the conduit (generally an ESB) was smart and the endpoints dumb. In microservices, the endpoints are smart and the conduits are dumb. If you ever had to program an ESB, you'll appreciate how significant this distinction is.
I would say not having hands on experience and then writing a blog makes no sense. Dedicating a year when these respected devs (and many of us devs) have dedicated their career to understanding this. If you can understand the mechanics of a watch from looking at it...more power to you. I am of the belief that some things you must build. Build it right, build it wrong, but build it....in order to truly understand. How can you teach if you have not done.
Disagree completely, learning a bunch of unused crap when you could be learning useful info is a waste of time that will hurt your career far more. Taking that time to get experience with Spring Mvc, or Angular, or anything that's actually used is a far better use of your time. One place will like you more because you reject Lamba's because they're "pointless", another will like you less, it's a roll of the dice. But all places will like you less because you know less of the tools they use.
There is another tool with a similar purpose that has been around for a long time: http://smarden.org/runit/ https://en.wikipedia.org/wiki/Runit etc. 
In my experience, web sites are rarely as thorough as a good book. If possible, find books which were written as textbooks. They are both more thorough and more thoroughly vetted. Better a slightly old textbook than a new book that goes over to much.
Well the one we were recommended to use was called Thinking in JAVA by Eckel. Are you by aby chance familiar with that one?
Yep, this one is pretty good. I am using in my project. I would recommend it over Netflix Servo for ease of use and better documentation. 
Exactly, this smacks of more Fowler crap.
God... Thanks for saving me from 1000 pages of ads I guess.
JVisualVM?
Fair comment, perhaps, but `@RabbitListener` is not mandatory, it's just a convenience for those who want to use it; the other solution (`ClassMapper` in the message converter) available in earlier releases is still available; there is no need to tie user code to framework classes at all. But I have no real ax to grind, if you want to use the native client and roll all your own code, have at it. Plus, there is no "vending" going on; this is open source; it's your choice whether or not to use it.
Ist just feels like the more I get into Spring the more it feels like molasses, not in terms of speed but in terms of every growing complexity. Spring Boot looked promising but now instead of XML jail it's Annotation jail.
http://pastebin.com/76f4Wf7A
 Benchmark Mode Cnt Score Error Units NullTestBenchmark.test_1direct_comparison_notNull sample 309943 38.344 ± 1.091 ns/op NullTestBenchmark.test_2direct_comparison_isNull sample 335153 61.536 ± 1.247 ns/op NullTestBenchmark.test_3Objects_nonNull_notNull sample 291255 64.330 ± 1.384 ns/op NullTestBenchmark.test_4Objects_nonNull_isNull sample 287899 38.468 ± 1.178 ns/op
Yep! I'm using jGrasp in my Java class now. 
with warmup 10: Benchmark Mode Cnt Score Error Units NullTestBenchmark.test_1direct_comparison_notNull sample 315628 36.610 ± 0.543 ns/op NullTestBenchmark.test_2direct_comparison_isNull sample 331840 37.606 ± 0.955 ns/op NullTestBenchmark.test_3Objects_nonNull_notNull sample 296114 35.851 ± 0.557 ns/op NullTestBenchmark.test_4Objects_nonNull_isNull sample 286380 36.038 ± 0.558 ns/op
It's not that people want eventual consistency, but rather at certain scales it becomes a given.
Swing is still fine but JavaFX is now the standard.
&gt; Disagree completely, learning a bunch of unused crap Design patterns are unused?
&gt; Support for Javaslang Awesome :) I've been playing around with it (probably won't get all developers on our team on board to using it in production just yet) but it's great that you support it!
&gt; EVENTUAL-CONSISTENCY ALL THE THINGS. This one is painful. Splitting up a monolith into microservices doesn't achieve "eventual consistency" at all; you'll simply end up with inconsistencies unless you write the "eventual consistency" bit yourself. We see that in our project as well. While I fully support the choice for microservices in our case there has been given very little attention to the problem of consistency. Basically people said "we're using Cassandra so we'll eventually be consistent" and 'forgot about it'. Fortunately the mess is at this moment still manageable but it basically involves us writing our own journalling system to detect and solve inconsistencies. 
&gt; Fortunately, I am leaving. Personally I think it's not that fortunate. Microservices are an architecture that's not going anywhere. It's quite a big paradigm shift. Many of the problems that you see in these kinds of projects are caused by developers that don't know the trade off in complexity you make between going from a monolith to microservices. Experience in this regard is worth money, simple as. 
 JDK 1.8.0_112 (Win x64) i7-6700K. It just shows that benchmarking is hard, of these fast methods especially. It would be probably best to disable turbo...
[removed]
I would probably still consider Java for small scale projects if worked by more than 2 people. For example, a project where you split responsibilities and you don't want to find out at runtime that you all understood different things at the API boundaries. Another good use of Java for small scale projects would be libraries that could be used by different teams or protects using different languages but all running on the JVM. Another one is when you know the project will be slowly built over a long period of time. Static typing will give you more information about your intents or ideas when you come back to the codebase a few months later and try to resume your work. This could be compensated in other languages by doing TDD and having failing tests, but if it's just a small project that you don't want to bother with that, Java will be easier to resume IMO. Also if you aren't really sure where you are going with your project in terms of code organization, Java projects can be more easily and safely refactored by your favorite IDE.
The biggest thing we fucked up was not giving enough thought to db model. If you're moving to document DB like mongoDB, you are going to get atomicity only on one document so make sure that the most crucial usecases work with the least amount of documents possible and pile all the changes in one update (though dont make giant god-document blobs). Also if you're using document db, use operations like increment, updating only the necessary fields etc. I know it sounds like something you'd do automatically but we had many devs who did just stupid shit like: I have to increment a revision or something on this doc. Lemme load it from db, increment that one number in memory and then save the whole thing again (without implementing any sort of concurrency control to prevent this from creating race-conditions). Also don't desing your model in a way that data of one app relies on success of api call of another app to not be immediately broken on fail and if you do, include some mini lifecycle for the object that relies on the call. Like: ok - pending - failed+retrying - failed+waiting for recovery job - failed+fucked, requires attention. Retrying is going to happen a lot (timeouts on infrastructure failures or heavy load) so make sure your apis are idempotent. And I'd recommend messaging for these kinda situations as it gives much more guarantees if configured for reliability. Also dont underestimate logging. Back when we had the giant monolith, it had a few files it dumped everything into and every UC had a transaction so you didnt have to scour for errors through multiple logs. With multiple apps, tag your requests with ids, so you can track them through the logs of X apps, ideally use something like graylog to make looking up logs easy. Also pay big attention to your HTTP client/server configs. If your apps are going to communicate great deal between eachother, it is advisable to have a pool of keep-alive connections on the client side and have the connectors on servers configured appropriately, also some http clients have a low limit on open connections per domain so check that as it can bottleneck your microsvc blob quite a lot.
[Top 10 Java Programming Blogs To Follow](http://codecondo.com/10-best-java-programming-blogs-to-follow/)
http://www.javaspecialists.eu/
At first, I thought this is another unit testing framework :D
I would say its not the way the gurus say microservices should be set up... And personally, I think it doesn't sound like a very good approach... :D :D
Ha, me too. Run it, not R unit.
My purpose is not to teach anyone about it, that's why I start by explaining that I have no hands on experience with it, and these are the NOTES I took from what the gurus say about it. I also gave a few of my own opinions but I clearly state that they are my opinions and they are worth just what the reader wants. Moreover, I did my best to accurately point to all references so who ever reads it doesn't need to believe what Im saying, anyone can easily check what the source actually said. This sentence "I would say not having hands on experience and then writing a blog makes no sense." is what makes no sense to me. I can write a blog post with my opinion about something (which is what I did there, for the most part) and ppl can agree with the contents or not. Free speech remember?
It's pretty nonsensical to do this on the back-end. Both mobile emulators as well as modern browsers have options to throttle speeds to for example 3G or Edge. Also there is a big difference between a delay and low bandwidth. Your solution, a simple Thread.sleep, doesn't really simulate a low bandwitdh at all. 
"Java for everything", might have few good points too. https://www.teamten.com/lawrence/writings/java-for-everything.html
Check out OpenKeeper (https://github.com/tonihele/OpenKeeper) for an example of a real project using JMonkeyEngine, it's an open source implementation of a Dungeon Keeper 2 written in Java. There are some videos of it as well: https://youtu.be/bpJ6KGttJhM
It's good to know there's only one slow network connection in the universe. 
I think you accidentally guessed op's first name. :)
Check out this extremely well placed website, SEO wise, when you google for "top java blogs": https://www.topjavablogs.com
[removed]
I agree, it is awesome. I have been using it for years. It used to be called codahale.
if there's any chance that the side-project code is going to be useful for a future project, the refactoring that java allows is gold for an example of how expressive java can be, look at [the example at the top of my readme](https://github.com/db4j/db4j) - it's a single file microservice (database included). assuming that you're doing most of your UI in javascript on the client side, java is great for the server side 
Indeed, I started studying it because I had an interest in it, but also because the company where I was at the time had plans to move in that direction. But I also didnt spend a year on this, it doesnt take a year to go through those articles and conference talks :D I studied this a year ago, but only wrapped it up and made it available now. "It boggles my mind how someone can understand something by just studying what the texture looks like and not what it feels like." I have an opinion close to yours, I think someone can understand something by studying alone, but to be an expert or even proficient with it its indeed not possible without having hands on experience. Anyway, I do appreciate your comments, although they did look a bit negative/destructive at first :)
Yes. It's generally my goto platform (I actually use Kotlin, but it's still JVM). It can do almost anything. The only thing I've not seen done is AAA games, and that's because they generally need very low level hardware access. The real question is the other way around though. What do you want to do? Once you know that you'll know if Java is the best fit, or if something might be better.
Depends on what I'm doing -- "side project" is way too general. I just did a "side project" website, I used .js to serve the backend. I usually use PHP -- why? cause it's fast and it works and I know how to do it. The last point is the most important one. If I need to get it done quickly, I use tools that I know how to use. Desktop or console app? Almost always Java. Again, the why is easy, I program in Java all day for a JEE/Spring monolithic enterprise app. I know that shit really well. I can get a Java desktop app going in no time at all even though I never do Swing/JFX on a regular basis just because of language familiarity. If I had done more Ruby in my experiences, I'd probably choose Ruby more often...
Groovy works like this, you have Elvis operator and no nullable/non-null types. I would even say it suits well for Groovy. Working with all the Kotlin null safety is a bit tiresome, while Groovy feels fun and hacky especially with Groovy dynamic typing. Definitely agree with author that Elvis is not for Java. 
What I'm saying is, when doing a side project, always do what you're familiar with unless you're doing it specifically to learn something new. Ruby will always be a poor choice for me because I've only done one Ruby project in my life (RhoMobile -- and I still have nightmares).
2 Blogs Garbage Collection and Threads https://blog.gceasy.io/ and https://blog.fastthread.io/
The main issue with java is the multitude of competeing framworks, all trying to get you to write your stuff their way. Really, bog standard java is wickedly quick, and its type-safe nature makes refactoring and code completion a breeze. it will outperform easily the competition... in any project. 
That's a nice blog post. I can feel my attitudes shifting...
Trying to express vastly different concerns with the same thing, and an error-prone one at that, sounds like bad code to me. But yes, you are right, not all things that occur _in_ bad code necessarily _are_ bad code and maybe I went too far there. &gt; No matter what you do and what language features you add, people who write poor code will continue writing poor code It's not like writing bad code is an immutable character flaw. People can learn but some things make it harder to make the right choice than others.
&gt; Primitives are non-nullable and everything else is nullable. Like I didn't know that... But you can neither get a nullable primitive (I don't mean wrappers) nor a non-nullable reference type so it's not like there's any choice to be made. &gt; and presumably these value types will have nullable versions Not to the extend of my knoweldge. On the contrary, up to JavaOne "word on the street" was that they would never be null.
I frequently write small (2 or 3 file) Java apps to run on AWS Lambda to do simple jobs I need done. I'm familiar with all three available languages for that platform (JavaScript and Python) but I just seem to get things done faster in Java and when I'm done I'm more sure of the lack of bugs.
ok, there are two big problems with Optional: 1) it is clunky to use and makes code harder to read 2) it is inefficient because it creates additional objects The Elvis operator solves both of these problems! The existence of null in code and the need to check for it is not some sort of evil. It's very useful and is necessary for things like lazy initializations. Not every Java problem (in fact, most) are not academic exercises to make perfectly designed OO code. Large applications have to be performant as well, which means you don't create objects until absolutely needed. Thus, the need to check for null references. The Elvis operator would be an awesome addition to Java and to improving code readability.
I'd say some languages are bad for large projects, but Java is fine for both small and large. Java is really good for large / enterprise web applications as compared to dynamically typed languages for example.
The mapping is very flexible, although not well documented. The `DefaultClassMapper` (which can be injected into the converter in the docs I pointed you to) has an additional property `idClassMapping`. It takes a map of `id : Class&lt;?&gt;` - so the sender can set the header to `Foo` and you map it to `com.foo.Foo`. There is a [test case here](https://github.com/spring-projects/spring-amqp/blob/v1.7.0.RELEASE/spring-rabbit/src/test/java/org/springframework/amqp/rabbit/annotation/EnableRabbitIntegrationTests.java#L959) where we use that feature where the sender sends a `Foo1` class and the receiver decodes it to a `Foo2`. The key to the map (id) can be any token. Of course, the receiving class must be compatible with the JSON.
Yes! Knowing the syntax for a language != knowing the language. There are tons of libraries you learn over time that help you become more productive. Even simple things like logging frameworks. Knowing how to use your loggers helps you track down bugs quickly. Switching languages and trudging through without learning the basics will make you much less productive.
Are you taking about VisualVM? It supports Java 1.4+. What are you trying to monitor?
&gt; he will do it and no language feature (or lack thereof) is going to change it I still disagree. Take `Optional::get` for example - do you think there would be fewer `NoSuchElementException`s if it were called `throwIfMissing` (to take an extreme example). I do. I would also be very surprised if Kotlin code bases would encounter the same amount of NPEs as Java code bases. Here, the type system can almost eliminate a whole class of errors. Or let's pick an example, where Java shines over older languages: memory management and garbage collection. You can still screw that up in Java if you accidentally reference large object graphs or even use Unsafe but it is much less likely than in C(++). So, sure errors can still be made, but the language guides its users towards certain practices and those can be more or less error prone. Also, to come back to `Optional`, I think it is much easier to understand how to use it correctly and in accordance with the requirements of the code that I am looking at than `null`.
That's not the case if you set the client response from a callback.
Yes, Java is good for both small &amp; large scale projects. Thanks for asking important questions.
&gt; "primitive obsession"? Is that what the cool kids are calling code that has to be performant? Yeah, what do people like Martin Fowler know about object-oriented design and large applications? I'm sure you're way ahead of them! Go sme06! &gt; Why do you think so many developers are clamoring for Project Valhalla? If you think Project Valhalla makes your point for you, you should listen closely to how its developers talk about the vast majority of people claiming "they need the performanz". &gt; At the end of the day, your end users don't give a shit about your OO design methodology. Oh, I get it, you think design is just a circle-jerk for bored developers. Sure, users only care about features. Development speed, stability, security, nobody cares about those! And even if, there is no problem you can't solve with more nulls and ints. &gt; They need code that runs and runs fast. In particular cases, yes. By and large, no. Unless you are working in a specific field, chances are, 10 % less performance for 10 % less bugs is a huge saving in development cost _and_ user attrition. &gt; Anything else is just your religious views getting in the way of developing. As long as yours don't get in the way of typing, you're good to go.
&gt; Without a null-safe operator your application falls on its face with a NPE and clients are calling and complaining about not receiving their report. With a null-safe operator your application runs on unperturbed. For weeks before clients realize that the reports they got are wrong and they made the wrong business decisions based on them (somehow some expenses were not added up correctly). If a column is nullable, check ASAP (on load?), whether that is the case and see whether you can handle it then and there. If not, consider using a type that reflects the fact that a type can be missing. Or use various @Nullable/@NotNull/... annotations. Don't mindlessly transport an absent value from where it was ok (database entity) to where it's not (adding up expenses). Also, have a look for the "failing fast" practice.
&gt; Yeah, what do people like Martin Fowler know about object-oriented design and large applications? That's a great question! Let's check out his wikipedia page: 1986 - Graduated from college. 1987-1991 - Worked in software development 1992-1996 - editor of IEEE magazine 1996 - writes books and gives talks ok, let's see. There's exactly five years of active software development out of college. Always check sources. 
Generally Java (via the JVM) is known for its speed, stability, and a huge field of competent candidates. The common advise is still to write your startup in a language that lets you go far fast, then retool for performance (perhaps including Java) if you happen to go big. If your friends already know Java, then you can most certainly write code quickly in it. It's just not going to be as terse as other languages
The problem, Gary, is that the spring boot based microservice system I am trying to communicate with, I do not have the ability to change. To add these things you suggest I would need to go recompile some of them, adding in idClassMappings. And this, to make it easily compatible with non-spring clients. But, the point that I am making, is by making it default, that its expects other spring clients to connect, it is putting in a barrier for other platforms to connect.
If you have a value, that although it isn't ideal it is null, but nothing bad happens if it is null there is no reason to fail the entire operation. Obviously if a value is critical to the application (like say in a calculation) you should detect null quite quickly and notify a human that can handle it. However, a blanket statement that ~~elvis~~ null-safe operator has no place in Java is short-sighted. I can think of many scenarios where I don't want an operation to fail if a value is null, even if it would be more ideal if it wasn't null. If you don't want to use ~~elvis~~ null-safe, that is your business. Other people would quite like to have it. It is very handy in Groovy.
You might want to try asking in /r/Javahelp . This sub won't yield great results while asking for help on your homework.
Since this is help with **Java Programming**, it should, as the *many hints* on the page indicate, be posted in **/r/javahelp**. Please, before posting, read the [**Posting Guidelines**](https://redd.it/48eykt) there. Also, since your program consists of several classes, kindly use [**Github gist**](https://gist.github.com) as this allows several classes under a single link. (Hint: just drag &amp; drop all classes into the Gist browser window) **Post removed:** programming help
With those domains, it's either going to be java or python. What you pick depends a bit on how you're going to interface with other stuff (e.g., are you making a microservice that speaks http, or a library that you want to use elsewhere, or a one off script you run manually?)
I like the how, but don't understand the why. Our brains can read the info on each slide of your video in a fraction of the time that it takes the TTS to speak it all out.
The (problem?) with c# is that it doesn't support non-nullable reference types (and arguably the default is wrong). That isn't likely to be fixed soon (it would be another language, and probably also would require a new framework). I kinda just prefer Rust.
&gt; If you have a value, that although it isn't ideal it is null, but nothing bad happens if it is null there is no reason to fail the entire operation. Obviously if a value is critical to the application (like say in a calculation) you should detect null quite quickly and notify a human that can handle it. The problem is that because null can hide in every reference type, it easily crosses from the first kind ("nothing bad happens") to the second ("critical"). I recommend to use types to express that by using something like `Optional` for the former and non-optional types for the latter. Then, `null` is (almost) never legal (if at all only inside a class) and I don't have to make that distinction anymore. Elvis not only does not help with the distinction, it makes it even easier to proliferate `null`. &gt; However, a blanket statement that elvis has no place in Java is short-sighted. No, only focusing on the upsides of a feature you personally want to use, is short-sighted. Listen to talks by the JDK team to understand how many considerations go into deciding on features.
But the problem is the receiving system needs some type information to do the conversion since JSON is not self-describing. The boot application could be configured to receive a simple Map; if it is expecting a strong `Type` then it should be properly configured for conversion to that type from any/all publishers (which is entirely possible with the configuration options provided). If you have any suggestions as to how else we can "magically" infer the type, I am happy to consider adding it.
Unit testing framework for Java is also on my github, and it's called bTester (Basic tester) :D 
Yes, and the best one is Launchy, which I mentioned on github readme. This is only pet project, with simple name and purpose ;) 
I will think about it. I don't know if it will be changeable in settings, but I can consider better shortcut. Any ideas? ;) 
&gt; Always check sources. Lol. Martin Fowler has been consulting companies on object oriented design for about twenty years now. That means he has seen more code bases, made more design decisions, witnessed more consequences of such decisions, and talked to more developers of all skill levels than the vast majority of people in this subreddit. He has poured his experience into a variety of books that are widely recognized as setting industry standards. That does not mean that his opinions should be taken as gospel but it does mean that he has a lot more credibility than you do. So if you want to defend known anti-patterns like primitive obsession, you will have to do more than deriding that as "what the cool kids call it". But since you don't even know concepts that people who produce high-quality software employ for more than a decade, I'd say your chances are slim.
That was the main purpose, to simplify my work when Im programming. Thank you! 
If you already know Java then looking into a framework such as JOGL or LWJGL is the way to go. If you are learning Java then best to do that first.
Nice work. I wrote something similar a while ago: http://niels.nu/blog/2016/spring-async-rest.html
Thanks! Spring Async is used to create Future results from methods without having to directly interact with thread pools. The code I wrote is focused on how combine `CompletableFuture`s.
"Nobody got fired for choosing Java" Java is fine for most things. Maybe other languages might give you a small advantage, but there is a benefit to sticking to just one language too.
The problem with insulting someone on the internet is that you really don't know what their background or experience is. I get that guys like Fowler are popular. But there is a difference between developing applications and talking about developing applications.
C# has several plans to fix it in a backwards compatible way, but we don't know if any will make it out of research.
I work as a consultant too. I know how the bullshit game works. You fly in, drop some canned presentations, then leaves a bunch of overpriced junior devs to do the real work. He's a salesman that knows some basic programming. This is painfully clear from his books and blog posts.
&gt; I thought that C# value types (i.e. the thing we supposedly envy) are non-nullable. Technically they are, but this: int? myVar = null; is a language shortcut for this: System.Nullable&lt;System.Int32&gt; myVar = null; So, I misspoke. It's not a nullable *version* per se so much as it is a language shortcut to convert it into an object that supports automatic boxing and unboxing.
I use Windows and had the problem that visualvm was calibrating forever. Maybe try this parameter when you start visualvm: -J-Dorg.netbeans.profiler.seperateConsole=true
Dammit I hate to be the pedant, but `?.` is the null-safe operator. Elvis is `?:` uhuhuh