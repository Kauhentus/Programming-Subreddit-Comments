First - I believe it's for r/javahelp. Second - it's quite a bit common explanation. You need to provide way more details. What included into "current players"? Do you mean player accounts, player stats, leader board, anything else? Do you need persistent information or it's only live inside the session? Game state is quite easy - you can either use array of arrays and go cells\[x\]\[y\] or create your own coordinate rules and use plain list of game cells. And something like - I have all the rows recorded one by one, so coordinate \[x, y\] will be in position y \* \[number of cells in row\] + x + \[index correction if you use 0 based index in list and 1 based everywhere else\] How do you receive input? JavaFX app, console, JPS web view, API?
Second part of the post is also worth reading - persistence optimization with Jdbc https://medium.com/@jerolba/persisting-fast-in-database-jdbc-76912ec2ef42 And the summary : How different is the performance between JPA and JDBC? The best result of each option, face to face, is: The improvement is around 50% and 25%
What's your motivation? I could understand it about 8 years ago, when Scala was at it's peak of popularity, but nowadays it seems in decline.
Since this is help with *Java programming* it should be posted in /r/javahelp. **Removed**
hallo :) eigentlich habe ich 0 programmiererfahrung. Das sollte ein einfache projekt auf der konsule sein, weil wir in erste Semester sind. bei current player sollte herausstellen, dass welche player gerade spielt..spieler1,spieler2 oder Computer. bei gamestate, sollte "winner" oder "loser" geschrieben werde. bei getinput sollte die spalte gewählt werden.
hi. thanks or helpjava. That should be a simple consular project because we are in first semester. with current player should show which player is currently playing..player1, player2 or computer. at gamestate, "winner" or "loser" should be written. at getinput the column should be chosen.
you'd get tons and tons of calls to scala's stdlib.
There are still some new projects being build with scala, but for enterprise it doesn't makr mcu sense as it is hard to find decent scala developers in larger numbers. 
&gt; The improvement is around 50% and 25% - Cigarettes are good for you - Earth is flat per study by the holy church - 4/5 doctors recommend whatever-my-product is
There is very little things that you cannot translate to Scala in a dumb way. (I can only think of enums - you have to translate them to ADT, perhaps with something like enumeratum if you prefer). IntelliJ even translates Java to Scala for you on on copy-paste. * interface -&gt; trait * void -&gt; Unit * A fun(B: b) -&gt; def fun(b: B): A * Type&lt;A&gt; -&gt; Type[A] * ;(new line) -&gt; (new line) * for (A a : as) -&gt; for (a &lt;- as) // assuming you use Scala collection (you might convert into it) But it's worth noting, that is is just a first step - such translation on its own doesn't give you any benefit. Next things you could do would be: * replace all nullables with Option * replace mutable collections and variables with immutable unless this is a performance critical code (and as I found out - it very rarly is, and usually you can hide the mutability under some purely functional interface) * master case classes and ADTs to model domain objects * replace half the GoF patterns with plain functions * use pure functions where possible - where impossible use some type like `Future`, `Task`, `IO`, etc to express effectfulness on a type level * basically treat the type as a part of the documentation, so anyvals/taggedtypes/newtype are your friends * keep interfaces small and skip them altogether if all you need is one method - after a while mocking becomes a code smell (why this things is so big that I have to resort to mockito and several expect-&gt;return instead of definig the behavior as a simple function in test?) * move away from runtime reflection where possible - it makes you feel productive until you figure out that you moved the validation of your code from compile time (where it can safely fail) to deployment (where it is not a nice thing) Besides, you should be aware what kind of tradeoffs you make when you switch from Java to Scala, so that you have some actual benefits from using it: * when you got from Java to Scala you will trade compilation speed for _possibility to check more things during compilation_. If you don't get familiar with things like: variances, upper/lower bounds, type inference, value classes (AnyVals) and/or tagged types, etc, you will pay for more sophisticated type system, without making use of any of the things that it makes possible. You can easily end up with opinion that besides that "scala is slow" you see no difference to Java, * it's worth getting familiar with implicits and benefits they bring to the table: extension methods, DI of some contexts that are passed everywhere just by their type, type classes, ... - while it is true that implicits are often unintuitive, they make quite a lot of stuff impossible in Java possible - e.g. type classes are a way of abstracting away behavior by putting some set of operations into a stateless object. extension methods using type classes can then take this behavior-bearing objects and give you a clean way of extending a behavior without deep inheritance, adapters, etc. And the best of all, you are often able to generate the implementation based on a set of principles how some basic cases should behave and how you can compose them basing on you your data are defined (type-class derivation). I think you can start by using IntelliJ's converter to convert Java classes to Scala classes one by one (or gradually, as you introduce changes to the codebase). Once you have significant part of the codebase covered you can start refactoring the code to be more idiomatic. Probably migrating tests first would be the best, since it is easier to use Java code from Scala code than the other way round.
&gt;it is hard to find decent scala developers in larger numbers. This is why &amp;#x200B;
Do note that `A fun(B: b)` won’t compile because of the colon. It must be written as `A fun(B b)`.
Thanks for all the pointers but this is in the opposite direction of what I asked. Some could work if applied in the opposite direction but not all, e.g. implicits
There are plenty of opinions about everything in this world. Don't worry about it. If you like the keyword, use it. Haters gonna hate. ;)
This is something people don’t think about often enough. Part of my job is helping retire software that was written decades ago. These systems sometimes only go as a condition of retirement for the team of two that’s maintained them all this time. This is why for my JVM++ code, I prefer Groovy. Not only has it been around since 2004, but the syntax is mostly enhancements to make Java less wordy. Almost all valid Java is valid Groovy. It’s got almost no learning curve in either direction. Graal is going to be both miserable and wonderful for this stuff.
"Better" is an opinion. Someone with your supposed decades of experience and you can't figure that out?
Why miserable?
When I worked in Scala, I was hired as a Java developer that could learn. New hires were brought on the same way. I wound up teacher senior developers at about the same time I was learning.
Because now we’re just going to have more software written in bespoke languages that someone at your company implemented for fun that someone’s going to have to maintain for the next forty years.
I'll bite. :) I down-voted (post-edit, apparently) because of it's tone. It's rude, condescending, and assumptive (even if unintentional), and does not explain anything. I personally don't have a problem with *constructive* criticism, but I suppose it's possible that we don't have the same definition of what that actually is, or are just from differing cultures. I don't know. I would point to /u/dpash's top-level comment as an example of what I would consider to be a more constructive critique of the OP's source code. 
write a webapp with a bundled REST-ish backend ?
One man's trash is another man's treasure.
You screwed up by using Scala. Now you have to pay. ;)
once you've made either of those leaps, it's no longer a getter or setter
Buy a tissue box because you no longer get case classes and pattern matching?
Yes but the problem is that these are rarely the same men in this case.
[Records](https://cr.openjdk.java.net/~briangoetz/amber/datum.html) and [pattern matching](https://openjdk.java.net/jeps/305) are in the works for Java.
Lombok @Data is pretty close.
That's good to know, thank you for heads-up! Personally, I prefer mutability to be explicit. Both mutable and immutable collections have their uses (for example, in a low-memory and single-threaded environment you might prefer a mutable one). Operators overloading, as you just prooved, can make immutability ambiguous. I'm dreaming of the day when there will be a language that abstracts the entire concept and detects when to use which type of collection... or maybe there is one that I'm now aware of?
Maven is a build tool, configured by default to go through a project directory structure and compile all your source files into a target folder (eg. src/...), whereas javac on its own is just the compiler and doesnt care about folders, only the java class and whatever it references, both different things hence the different behaviors. Anyway, yes you can tell maven to ignore certain files by adding an exclude to the pom, simple enough to do. Docs here explain it pretty well so you should be able to follow: https://maven.apache.org/plugins/maven-resources-plugin/examples/include-exclude.html 
It's kinda funny that era of Scala 2.8 is called its peak, while different rankings/amount of organizations that use it/amount of jobs from junior level show it's still growing in popularity. And it's growing not because it is "more convenient Java" or ont olny because of being native language for Apache Spark/Storm/Akka. One more thing. Are you motivated to use Kotlin because it seems to be trendy right now?
I think Kotlin might also be a good choice 
Kotlin has the case classes. 
Well, what you say used to be the only way to make it work at all. My point is, now you have a new option, one that affords shorter programs and possibly less cognitive overhead. Avoiding having to name some thing just so that you can use it once, and not having its definition inline, where it's in context, could also harm readability.
Java evolves. Many things you can do today easier in languages like Kotlin, you'll be able to do in a few years in Java as well. So, no, Java is going nowhere.
These are valid points. I remember dealing with some Map&lt;K, List&lt;V&gt;&gt; at least as result of groupBy. If you have stream mapping to a groupBy collected to a list, you kind of do end up with this kind of crap, I think. Dealing with maps in java tends to be verbose and prone to runtime errors, so I usually have to get rid of Map types sooner or later. And really, something about typing and balancing all those &lt;&gt;&gt;&gt; just annoys me. It is probably a little bit irrational a position.
The issue is that sometimes it goes wrong over time (disclaimer: I do consider idiomatic Scala codebases to be superior to Java), and you and up with a very Java-ish code in Scala, which to be honest is worse to maintain that than if it would be written in Java from the get go - there's a mix of paradigms and approaches which don't really mix all that well.
&gt;I'm dreaming of the day when there will be a language that abstracts the entire concept and detects when to use which type of collection... or maybe there is one that I'm now aware of? Not sure, but IMO the idea is kinda dangerous. You might think that a variable is immutable but in reality it is not - like above. An IDE could probably detect that but even so, I'd rather explicitly control everything than something else assuming things and causing a mess. Like above, the mess could be caused by a change in the language itself.
I've never converted a code base from scala to java but I have done a lot of major migrations that aren't too dissimilar. When approaching something like this I would try to make a Java safe API in the encapsulates the scala code so they can intermingle. Over time, as time and resources allow, try pushing that API back pulling more logic and code form the scala side to the java side. It's generally the approach I try to take with most large refactoring jobs. Setup boundaries around what you want replaced, get the product stable and working so business can continue and slowly work towards your end goal. Depending on what your product is and how it is architected and how tightly coupled it is you might find this approach very difficult or very straightforward. Major refactors are never fun and always cost more than you expect so think long and hard on if its worth the cost and disruption. The most important thing in any refactor or migration is having small incremental steps you can tackle over time without just rewriting the whole dang thing. If you try to do it all at once, you'll get part way through then either an emergency will come up, distract you and cause the fork will bitrot or business-side will rightfully pull the plug over concerns of getting no real work done.
Ah, I misread the title, sorry.
Well, it might see that way if you look at percentage - number of jobs in general grows much faster, than number of jobs in Scala. But _I_ see increasing absolute number of Scala jobs - 3 years ago I could only work through a consulting agency and I would not be able to find a company that was willing to hire me directly, because there weren't many projects that used it. Now, I can easily get a job offer. Actually, while it used to be 1 Scala job offer per 10 C++/Java job offers, not I get almost exclusively Scala job offers. Sure, more Scala exp in my CV contributes to that, but I almost wasn't able to find Scala job posting even when I searched for it, while now I am can be picky about the projects.
Basically what happened. I wrote some code was very force scala to java particularly around mutating collections then later went back and fixed it when there was time for tech debt which was the first Thursday after never .
Yeah, there needs to be a certain mass of dedicated Scala devs to pull off a project with mixed Java-Scala devs. Lack of it was one of the several reasons why I left the project.
Decompilers are... Not good at decompiling non-java languages.
That's MySQL is 50% faster using JDBC vs JPA and PostgreSQL is 25% faster using JDBC directly.
Groovy being a superset of Java was true when Java 7 was king, but since we've gotten lambdas the syntax has diverged. Groovy 3.0 should support those syntax additions though.
Wouldn't you say this is thanks to general growth of the industry? And It would be even easier (and be more picky) about Java jobs? (save from language preference ;) )
&gt; Are you motivated to use Kotlin because it seems to be trendy right now? Why are you assuming I'm motivated to use Kotlin? ;-&gt; To answer your question - I see a couple of interesting features there (data classes without the need to use Lombok or handling nulls) but I think in the end Java would absorbe those. If I were doing android I would be probably more inclined as Google is pushing Kotlin hard...
And we don't have to wait three years to see the results of that effort. We get the bits that are ready now. (Well, in 9 months/3 if you're feeling brave)
Or [right now](https://jdk.java.net/12/) if you’re feeling braver ;)
Almost all Java jobs I saw was about some CRUD application. I don't want to do them ever again. Same as I don't want to do JavaEE, Spring and Hibernate ever again. I know that world doesn't end on these, but if I ever saw a Java job offer that isn't about them then I must have forgotten about it.
I'm assuming this 50% "performance increase" is with the assumption that your JDBC query has been fully optimized. Also, was this assessment used with Hibernate's Query Cache? I'm curious how that would compare. 
Yeah, there’s a small amount of effort to convert Groovy 2.5 to Java 8 and back. I’ve done it - it isn’t much. Lambda object more or less seamlessly convert to closures and the :: syntax has to be find-replaced with .&amp;. That’s about it. I am a bit annoyed with the direction of 3.0, in that it should be possible for Groovy to support Java 8+ syntax without requiring a Java 8 runtime. I’m stuck on JRE 7 for now. I wish they’d stuck with 2.6 instead of abandoning it. Closures don’t convert the other way quite as nicely, but IntelliJ has a Groovy -&gt; Java converter that gets 90% of the way there. In either case, my point was more that the language is intelligible to someone who’s learned Java 8. Scala has more of a learning curve before you can even read the code.
&gt; hard to find decent ~scala~ developers in large numbers ftfy
I agree!
&gt; How different is the performance between JPA and JDBC? I was curious why would he even go for JPA route for simple inserts in single table without any relations… (IMHO JDBC would be simpler instead of playing with Hibernate...)
Yeah, me to, someone playing corporate politics games decided they would base their new framework off spring, which means they wrote a shitty undocumented spring-clone on top of it. It's awful. So I had to wrap it in util methods do I could run a query with one line.
Thanks for pointing that out, fixed.
They're not the same. Scala case classes support recursive deconstruction and pattern matching. Nowhere close.
No problem!
That reminds me: I must set up my Jenkinsfile to build using both maven:3-jdk-11 and maven:3-jdk-12 in parallel. That'll be a fun afternoon :)
Well, in the JPA version, he let Hibernate write the insert query (and let the JDBC driver rewrite it for batched inserts). How much impact would the Hibernate query cache have on inserts? Very little I'd assume.
Read it from cover to cover. Then read it again. Then read it again every six months. The section titles are a good overview of the topic discussed, so you might like to print off the contents page and keep it somewhere near your monitor for easy referral. There are also bolded sentences/paragraphs that might be good to refer to.
Awesome, so it sure is a good book! :D And if I’m right you’re saying just read it - as in don’t try coding along with it? Basically read it and make sure I understand the content? Thanks for the reply! Cheers! 
There's not really much to the code in the book. It's mostly "here's a bad example" and "here's a good example". They're more for reference than anything else. (You'll want to refer to the `.equals()` good example a lot)
Ah that makes more sense in that case. Thanks. 
Awesome, makes sense! Thank you! I should be getting it in the mail on Tuesday, can’t wait. Just curious, if you know, what about a book such as Core Java by Cay Horstmann? Same thing, read along and look at the code examples? (If you’re familiar with that book). Thanks so much again! 
Working on standing it up, but early. We started last Monday and just got our test build up.
Different GCs shine in different workloads; the best thing to do is to test it on yours and see how it compares with the others. The nice thing about modern JVMs is that they have several GCs you can play with to see which one works the best rather than the old one-size-fits-all set up we used to have.
Raw string literals are about as unimportant a feature as type inference is. Grand scheme of things neither are a blip on the radar. 
I've been using it. For my workloads the zgc is a perfect fit, and I'm very happy with the speed. My applications typically produce thousands of very small, very short-lived instances, and just a handful of long-lived ones. This is caused by me insisting on employing mostly immutable objects. Every change to such an object creates a new instance, and discards the old one. Many of my applications run for a max of 15mins before they've completed their tasks. Then they turn off, until a timer invokes them anew. With older JVMs and their GCs I had to manually tune the GC settings to get it to work nicely with those workloads. With the zgc I can use the default settings and it works like a charm. 
After looking over his tutorials I wouldn't even consider buying anything. Okay lets learn this tutorial, oh this tutorial is based on this article over here, okay, oh hey the stuff you're looking for is in this article. ARE YOU F#$KING kidding me????? Absolutely the most confusing garbage tutorial site I've ever seen.
&gt;(You'll want to refer to the `.equals()` good example a lot) You're certainly not wrong that it's a great example, nor that every Java coder should learn and understand the principle. Maybe even by rote. But any IDE worth its salt should be able to generate a "Effective Java"-compatible implementation of `equals()` (and `hashCode()`) with a few keystrokes, so in practice you won't generally need to refer to the book. That said, I keep a copy in my desk, and encourage all the developers I work with to do the same! 
Works great for my workloads. We have ultra low latency SLAs and having a GC with very low pause times for all collections frees us up to not have to keep fucking around trying to tune CMS to never promote things to old gen. We can now have long lived objects mixed in with our short lived objects without worrying. Our 99th percentile request latency is down by orders of magnitude for one application.
Implicits are easy, at least in principle: just convert the implicit parameters to ordinary parameters. Hopefully the rules about visibility of implicits will make it fairly obvious what the value of the parameter should be at any given call site.
I really hate the idea behind term like "Scala developers". It's like someone trying to cast a production of _Halmet_ saying they're having a hard time finding _Hamlet_ actors.
Oh man, ```Optional``` as a method parameter... That one gets me every time. After my project upgraded to 8 I did a lot of code reviews and saw a lot of that. It's like people all of the sudden forgot about overloading. The other kicker was 80% of the time somewhere in the method they'd call ```if(optional.get() != null)...```... Wtf? Your null check is going to throw an npe? What's wing with you people? Sorry, PTSD from a couple of years ago.
 Everyone learns differently. Some people go through the book step by step, reading and trying the exercises, looking at the samples. They find a problem, try to learn enogh to solve the problem, and build on that iteratively. Maybe, by the time they solve the fifth problem, they have learned a good way to have better solved the first problem. Some people read the whole book and then think about it. Then go back and try the examples. I think this approach is better, really. It's a good idea to learn how things work, then get the whole big picture. If you don't know everything that your tool can do, and what it does well, and wat doesn't do so well, then how well do you really know the tool? But maybe different people like to learn differently than I do.
This is a Java class? Definitely look into classes. They are integral to the foundation of Java. I like Oracle's tutorial [here](https://docs.oracle.com/javase/tutorial/java/javaOO/classes.html). Also look into [interfaces/inheritance](https://docs.oracle.com/javase/tutorial/java/IandI/index.html) and [generics](https://docs.oracle.com/javase/tutorial/java/generics/index.html).
If you're reading a primer on a language like, Java: A Beginner's Guide, then I would recommend reading through the chapter. Then going back through the chapter and working through the code examples. If an example seema simple, just typing out the solution and playing with methods will help you answer questions on topics that might be lightly touched on in the book. For timing I usually set aside 90mins a night. I do this because a chapter should be about a 20 minute read at most, and then 40 to 100 minutes to reread and code through. When I learn a new language (say for a new job) I'll usually have a strong grasp of a lot of the flavors and some of the state level implementation within 6 weeks.
Yeah you are right. How would you handle implicit conversions, I’m curious 
Taking into account current state of java usage you can consider building echo service based on REST API with persistence layer. You can read docs and howtos as you going through as far as you need it. I would recommend something like get message through web service, save it into database, select this message from database, reverse message(abc -&gt; cba), return it back. I would recommend to use Spring([https://spring.io/](https://spring.io/)) as core framework, but without Spring Boot. Spring Boot is good thing, but you'll miss pretty much basic stuff about how work with dependencies, configure, build and deploy project and it's crucial, because you trying to learn how things work. If you want note about tech stack - use PostgreSQL(or MySQL, just personally prefer PostgreSQL) as database, liquibase to see how usually work with DB schema organized in real life projects, Maven as dependency management and build system, Hibernate as persistence provider, Spring data(JPA + persistence API), Spring MVC(REST API), Spring Core(DI and other useful stuff) and deploy all that in Tomcat or Jetty as WAR. As a result of such thing you'll know how to work with database and persistence, how to build services, expose it to web, deploy app to web server. As a note - try to use Linux in Amazon as a hosting OS, there is a free tier VM's. Linux is widely used to deploy java apps, so having basic experience with it also big plus. It's more\\less how Java used nowadays(get data, validate, process, update database, compose result, return it) and you'll cover most of the aspects.
I can't give you an informed answer because it's been too long since I used Scala.
It'll either be Perl 7, Python 4, or Half Life 3.
Could you share about the number of the 99th percentile of before and after? Thanks.
 &gt;But any IDE worth its salt should be able to generate a "Effective Java"-compatible implementation of `equals()` (and `hashCode()`) with a few keystrokes, so in practice you won't generally need to refer to the book. You need to know and understand the concept and contract to even know that you should tell your IDE to generate a new hashCode() function every time you override equals() though. Also, there may be cases where you override equals() in a complicated enough way (read: doing something more than comparing a few member variables) that hashCode() can't be autogenerated. And some people don't use IDEs anyway. I code in vim a good portion of the time.
&gt; override equals() in a complicated enough way (read: doing something more than comparing a few member variables) that hashCode() can't be autogenerated. Sure, but then referring back to the canonical implementation in _Effective Java_ won't help either. But yes I agree (and wrote) that a foundational understanding is required, and the book will help a ton there; I consider it essential reading. 
&gt; With the zgc I can use the default settings Zgc has just two tuning parameters overall (-Xmx, -XX:ConcGcThreads), out of that -Xmx is the regular help size setting. Check this https://youtu.be/7cWiwu7kYkE?t=1265 
 &gt;Sure, but then referring back to the canonical implementation in _Effective Java_ won't help either. Sure it would. Example: suppose you have a Triangle class, which internally stores 3 points (in x y coordinates) as well as a color (which can be mapped to a number, e.g. with hex encoding.) You would like to say that two triangles are equal iff they have the same area and color. You can easily implement a hash function that will work with that equals method using a slightly modified form of the implementation in EJ - but I don't believe that IDEs will autogenerate such a method.
I think this is waay to complex for someone who hasn't even learned classes yet.
Isn't that basically the definition of the generational assumption most gcs are based on? What makes zgc especially good for your use case, the low latency?
You can do whatever you want for your own personal projects but in a professional setting, especially companies that make software as a product they'll have their own standards you'll have to comply with. Those standards will inevitably be a variation of the standard [Java Language Specification](https://docs.oracle.com/javase/specs/jls/se11/html/index.html) outlined by Oracle. I'd read up on the specs so that you're more prepared for programming in the professional world. 
static vs non-static contexts through me for a loop because I didn't learn about it in class (or I was absent that day, hehe)
At first I did browse the toc to see which items I should read immediately. Then cover to cover. But not to fast or it won't really stick. Like one item every other day. Some time later review the toc and see what you still remember and what to read again. However this is my approach and everybody has another preferred way to learn stuff.
[Var hurts readability, not helps it](https://medium.com/@youngty1997/why-var-hurts-readability-not-helps-it-376c7832a8dd). It hides important and critical details such as generic types and what is actually being referenced(on the surface anyway). Either the variable name or the get method has to be extremely explicit otherwise details are lost. To add fuel to the fire, if you wanted to base your code solely on an implemented interface and not the whole object then you're out of luck with var because it references the whole object which may result in you using a method not part of the interface.
just to chime into this "read a book every 6 months again and again" why do you recommend that? do you have 5 books or whatever, that you read again and again throughout the year? wouldn't it make much more sense to learn that stuff effectively, and just relearning a packed version done by you? i get that you think this book is the pinnacle of books, that's okay. but I guess there are many good books. Therefore I'm not quite sure what the best way is to hold down the knowledge of these books.. I don't say you shouldn't, as I don't found the best way yet to learn in the most efficient way. More like a question.
The problem is, so does this code, which has been legal java since the 1.0 days: someMethod.getFoo().getBar() You have no idea what getFoo() returns; hopefully the name 'foo' is a sufficient hint to figure it out. Trying to mow down 'var' as: "Should rarely be used" should imply you also aggressively preach against doing anything with the result of a method invocation, except storing it in a variable, in order to establish its type independently. I've _NEVER_ seen that advised in any style guide. Which makes 'var hurts!' claims a bit disingenuous. As with many things programming, it does not boil down nicely to a rule. `expr.invoke1().invoke2()` can be unreadable, but usually it is not. Using `var` can make really hard to read code, but usually it does not. How to differentiate? By having a non-idiot at the keyboard typing the code. In the end, having a readable codebase requires a decently skilled programmer. A mix of style guides and linting commit hooks will never get you there. Once you accept that programmers are mostly responsible for making readable code, and style guides are just that (guides, not rules), any tool which can help readability, even if there are times (but not 'virtually always') where it leads to hard to read code – should be made available. Making readable code is hard enough; no need to start eliminating tools until actual use shows programmers just cannot help themselves and will abuse it. 
Do you really need SQL as an interface for this "quick persistence"?
Because you forget things. You can't memorise an entire book.
The JLS is the language spec. It's not a style guide or code standards reference.
Other languages that support var and local variable type inference have seen its widespread adoption and practice in almost all contexts where it is permitted. The programmers whinging about \`var\` hurting readability are short sighted and I seriously question the breadth of their programming experience outside of Java.
Generic enums are badly needed.
Is the first edition any different from 2nd and 3rd ?
I think this is a poor comparison. Better comparison would be someone is trying to cast a theater actor out of a market where you only find tv series actors. &amp;#x200B; The point is: Scala is so much more powerful and most of all different from Java, that Scala projects get a completely different overall structure, as well as in details. While your average Java developer throws around a lot of Spring and mutability-hiding modules, your average scala programmer does everything with flatmap and implicits. Those are two worlds - both of them complex enough that the difference between "i can learn everything" and "I'm working with Spring for 3 years/I/m doing Scala for 3 years" makes a project "crap" or "maintainable.
I'm surprised no one has mentioned hints. [https://i.gyazo.com/4255288ba582709c234024326dfbc4d3.png](https://i.gyazo.com/4255288ba582709c234024326dfbc4d3.png) Although the number of people I still have to tell not to use notepad &amp; .bat compiler is surprisingly high.
Get a glimpse of what the book is all about - know the contents. Then read some parts, but do not read it as a novel. It is not a novel, it is a reference work of best practices. When you think, there should be an elegant solution for a problem, and you feel your code is dirty, but you could not remember, what is the solution, turn to the book for reference. Also, use the book in p2p code reviews as reference.
Yep. The newer editions contain better best practices, as both our experience with the platform grew larger, and the platform itself, evolved. For example, the 3rd edition covers lambdas.
Skim it then tell interviewers you’ve read it and then look at it periodically.
Having used languages like Rust, Kotlin and Scala for me it's a no brainer. I'm mainly disappointed they didn't just adopt both var and val. 
The 1st edition covers only up to Java 1.4, I believe. The 2nd edition includes items for several new characteristics introduced in Java 5, 6 and 7: generics, enums, annotations, enhanced for loop, auto(un)boxing, varargs... and updates items from 1st edition, correcting or removing them as necessary. The 3rd edition includes items for characteristics introduced in Java 8 and 9: streams, Optional, lambdas... and updates or removes items from prior versions. "Editions" of programming books are not like editions (i.e. reprints) of a best-seller novel, but more like "versions" as used in software.
Sorry for being 'that guy' but if you're moving from Scala to Java because it's hard to find Scala devs, did you consider Kotlin? It's more a Java dialect than a separate language and in my experience pretty much all the Java devs I had in my Kotlin sessions are really enthusiastic about it. It's not as powerful as Scala, but also doesn't let you shoot yourself in the foot as much. 
[This MOOC](http://moocfi.github.io/courses/2013/programming-part-1/) gives a great introduction to OO programming with Java. Also, the /r/javahelp and /r/learnjava subs are more suitable for questions like these :)
Swing is still part of the Java SE specification and therefore included in the OpenJDK source code of the JDK. Any build of OpenJDK (like AdoptOpenJDK) will include it. The only way it doesn't get included is if you use jlink and build a runtime for your application without the java.desktop module.
I bought it recently, and I keep it on my desk at my workplace. I try to read one item every day. I do that while the computer, the IDE and the several services I run on startup get started. I already know most of the advice given, but it doesn't harm to read it once again, nicely formatted and with proper examples. I also use it as reference during code reviews, or to validate some ideas when working with language constructions that I've not explored as much as others.
The post wasn't intended to be a history of graphical Java development. Since we were releasing our Zulu builds with JavaFX I thought it would be interesting to look back at where JavaFX originated from (especially since I was working for Sun when this all happened).
Thank you all for your clarification.
We thought people would be happier if we tested the builds before releasing them :-). There's also work needed to set up the build environments, etc.
I think it's open to abuse like other language tools (hello reflection). It certainly saves typing time and allows for more concise code, but IDEs have removed a large amount of effort in writing code over the last few years. Readability is certainly better in cases where you have generics in generics: var whatever = new ArrayList&lt;Consumer&lt;Function&lt;A,B&gt;&gt;&gt;(); but in my experience the above isn't a common occurrence.
Their reasoning for not including `val` is that we already have `final var`. It's a few more characters, but matches what we have already. It's not the strongest of arguments, but it's the argument we have.
Dealing with `Map.Entry` can get a little hairy when the value is also a generic class, so it's nice to have `var` in extended for loops. :)
I prefer the use of the var keyword when it comes to initializing stuff because the constructor or factory class already implies which type is returned. However on certain function calls where it is not directly seen what is being returned I would still use the returned type instead of var as it is more explicit to read.
I know. I don't agree with it :) The compiler could easily consider 'final var' invalid or treat 'val' as 'final var'. The main point is that you don't want immutability to give more visual overhead. I notice that in Scala/Kotlin I almost always use 'val' whereas in most Java code we decide against 'final' everywhere because of this overhead.
Which editor is that? I know IntelliJ has hints for streams steps, but I haven't seen them for `var` yet. Unless it's an option I haven't seen.
You mean such heavily nested types? Can happen fast, if you use Streams. And var is great when you first scratch such things. You can go... var whatMightThatBe = source.stream().map(...).filter(...).flatMap(...)... And have the compiler figure out what that is. You SHOULD change your variable name after and you might want to give collegues the explicit type as well. But var is certainly a great tool for a first draft.
&gt; Which makes 'var hurts!' claims a bit disingenuous. That [sums up his general attitude quite well](https://old.reddit.com/r/java/comments/a44xz4/when_will_java_include_annotationskeywords_for/ebbubir/). 
Yeah IntelliJ, admittedly that's a pic from Kotlin not Java, Settings -&gt; Editor -&gt; General -&gt; Appearance -&gt; \`Show parameter name hints\`
This Specialisation is for promising software developers with some programming background in no less than one of the other programming language (e.g., Python, C, JavaScript, etc.) who would like to have the capability to solve more progressively complex issues through objected-oriented structure with Java. In addition to learning Java, you will pick up involvement with two Java improvement situations (BlueJ and Eclipse)), learn how to program with graphical user interfaces, and figure out how to design programs equipped for managing large amounts of data. These software engineering skills are comprehensively relevant crosswise over wide cluster of businesses.
It breaks "find usages" https://youtrack.jetbrains.com/issue/IDEA-188689 It saves me a few keystrokes but then I do alt-enter and replace it.
I don't see why we can't have the java compiler recognize `val` and simply unwind it into `final var`, with no changes to JVM at all. I mean, that's basically how a `for` loop works in java - compiler turns it into a `while` loop bytecode and that's all the JVM sees. It's simply a compiler-level construct. Having `val` work the sam way would be nice.
I am in agreement with you (although I'd prefer more variation than `var` and `val` but now I'm just bike shedding). (I've noticed that recent versions of IntelliJ now underlines any variable that is reassigned anywhere that is used, which is a nice hint about immutability.)
It really helps when using [heavily generic APIs like jOOQ](https://blog.jooq.org/2017/11/20/using-jdk-10s-local-variable-type-inference-with-jooq/). See it like lambda expressions. You have both options: // When it's obvious that "s" is a string s -&gt; s.substring(1, 5) // When it's not obvious that "s" is a string (String s) -&gt; s.substring(1, 5) It's simply good to have both options in the language, that's all.
Buy a bunch of practice exams from http://www.enthuware.com. They're pretty spot-on, and cheap (a lot cheaper than Oracle's). Get the recommended book and read it cover-to-cover too. Drill the questions until you have it down, then you'll be ready for the test. I've done 4 Oracle certs this way. 
Yeah I'd agree with that. Coming from (originally) Java 1.4 and IntelliJ, I pretty much always write the statement - in this case the stream operation - and then introduce a local for the result. IntelliJ then infers the type and boom, done. For this use case var doesn't offer me much, but I can see the value.
It was abysmal on my workload. To be fair, the speed was fine, but heap compaction seemed to never happen. My processes would spin up, lay out some sizable data structures on disk, release those structures, but sit there with a sparse 16GB heap that's about 1% populated. On the serial GC, that same workload hums at about 200MB.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Also they didn't want to make var a reserved keyword, because it would possibly break a lot of stuff where var is used as a variable name. So var is just a type alias which gets resolved during compilation. This means you can do `var var = new Foo()`. It also means you have to do `final var` because val is not added for the same reasons. 
Because Java language features for not just for Christmas. If they add it, they have to support it forever. They can add it in the future, so it's sensible that they're cautious about it.
Excellent news! &gt; Q: When does ZuluFX 11 appear? &gt; A: Soon! Yay!
Having done a fair bit of C# recently, where var already is a thing, I have settled on using 'var' only for non-primitive types. But I definitely like it in that circumstance. Writing Java is getting so pleasant these days.
Okay that's a great price but it's 9€ (9,95$) for 7 mock exams, and has 600 questions, while this one for example: [https://www.dbexam.com/1z0-808-java-se-8-programmer-i](https://www.dbexam.com/1z0-808-java-se-8-programmer-i) is unlimited for 2 months, 1290+ questions and it's 24€ (26,90$). Did you know this site? &amp;#x200B; I don't know about the books honestly, never found books useful when you have internet, but I might be wrong.
Scene graph is the base, just like Java2D is the underlying graphics layer of Swing. When you're making a standard layout with common controls and layout managers, there aren't much difference between JavaFX and Swing. When you need custom controls, drawing, animation and stuff, JavaFX' scene graph starts to make sense.
&gt; C# features are amazing. Properties are not one of them.
Nope, don't know the other one. But it sounds like you're on your way. Good luck with the exam!
# WPF sucks! * Windows-only. * Microsoft abandoned it. * Visual Studio is one of the most bloated spyware ever made. * Slower than Winforms. * You're supposed to write XAML a lot. * ... Like how u/DuncanIdahos8thClone put it elegantly: &gt; JavaFX &gt; WPF in every single conceivable way.
# WPF sucks! * Windows-only. * Microsoft abandoned it. * Visual Studio is one of the most bloated spyware ever made. * Slower than Winforms. * You're supposed to write XAML a lot. * ... Like how u/DuncanIdahos8thClone put it elegantly: &gt; JavaFX &gt; WPF in every single conceivable way.
Use it everywhere and shun the disbelievers!
hokay
Still using Java 8, don't see the point in it. Don't listen to the C# people, it's a trap.
No, it isn't. Older GCs were intended for many long-lived instances, with applications that insisted on fewer, if not no sweeps at all. My applications require many short sweeps. The GC's focus has shifted along with many Java applications from front-end to back-end. And I appreciate that. 
Yep I did. Actually we are dabbling with Spring Boot, but are finding it hard not to let it from entagling all our code with annotation madness!
Still using swing here. Tried fx but now that is its own package it adds more to prepare before start coding and I'm not a fan of it
I feel ya. Development and deployment of JavaFX applications has been a little mess. But with [ZuluFX](https://www.azul.com/downloads/zulu/zulufx/) or [JavaFX Gradle plugin](https://openjfx.io/openjfx-docs/#gradle) the situation gets better, I guess.
Probably applets, if you want to do well on the test
For any reasonably sized project I think it's safe to assume that people will already be using some sort of dependency management. Probably Maven. In this scenario it's not really more to prepare, it's just adding one more dependency to the list. That's a much better and easier way to manage dependencies than to ask users to install it themselves; remember that the OpenJDK JVM has never been shipped with OpenJFX OOTB, so users have to install it separately if they want to run your application.
I wouldn't quite go that far, but I certainly wouldn't feel discouraged from using it. :)
It's only going to get better. I'm looking forward to `instanceof` declaring a variable to the right type, thereby removing nearly all remaining casts in my codebase. Probably in 13 or 14. if(obj instanceof Foo foo) { var bar = foo.getBar(); }
I see you like to live dangerously. Only 6 weeks to go...
A temporary bug is not a valid long term reason.
Nobody can tell, as nobody knows how Oracle will decide tomorrow. I personally like Swing. I can work virtuously with it. I never really got warm with JavaFX and therefore don't use it. Both frameworks have their pros and cons. Therefore use the one us like most at the moment. Some years from now the situation may be different, but no one can foreknow.
I don't have exact numbers on me, but roughly 800ms -&gt; 7ms. This is for an I/O heavy application. Basically no compute.
own package with maven it's even better since it's get update more frequently and doesn't have to be attached to java release cycle. 
&gt; IMHO JDBC would be simpler instead of playing with Hibernate...) How? Persisting with Hibernate is *em.save(new Entity("abc", "xyz"))* - how can it be easier with JDBC? The configuration required for JPA is even lower than JDBC if you use e.g. spring boot
I have seen many times that a seasoned Swing developer stating that they can't or don't want to learn JavaFX. May I ask why?
But as luck would have it, we do have recommendations from OpenJDK regarding the use of local variable type inference https://openjdk.java.net/projects/amber/LVTIstyle.html
Yeah i learned javafx and now it sucks
I tend to avoid using frameworks if they are "cannong to kill the fly". If you have a simple task to process and store data from external source then using Hibernate (and spring boot) feels like overkil. Sure - if you already use them then why not. JDBC configuration can be rather stightforward and simple (you can pass `jdbc://`…). Throwing at it prepared statement doesn't require to much effort…
I tried out JavaFX for the first time ever for my side project. Overall thoughts: a scene-graph is not suitable for general user interface building. Period. They solve a different domain's problem. Also, the API is bad (Menus are not Nodes, why?) SWT/JFace would be very good for general UI programming, however, they have leaky abstractions - the platform differences, and native stuff just shines through the API. Also, AWT is a direct competitor. Swing is good in architecture and capabilities, however, the default PLAFs are bad. Very bad. What I would really love to see is a mix of these technologies: scene-graph subsystem (only used if needed for specific use cases), native look and feel, but no leaky abstractions. 
The clients for which that deadline is relevant will handle that. We're not involved in the DevOps side with most clients. For those where that is the case our DevOps team will handle that, which is also not me. That all is orthogonal to the question which language version features with introduce into our codebase.
Not really? Generational GCs have the goal of keeping relatively few long-lived objects and mostly leaving them be, while having a large space for short-lived objects that is frequently cleared. See http://wiki.c2.com/?GenerationalGarbageCollection : "most objects are discarded shortly after being used". Also see https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/generations.html#sthref16 : 'Efficient collection is made possible by focusing on the fact that a majority of objects "die young."' Most garbage collectors on Hotspot were implemented based on this assumption. This includes the parallel collector, which is basically "as good as it gets" when your goal is throughput, not latency (though it may require more tuning compared to collectors like G1). I am not familiar with ZGC, only having read basic descriptions, but it actually differs from other GCs by the fact that it *isn't* generational. On the other hand, its colored pointer scheme (similar to Zing and Shenandoah) makes very low latencies possible. However, if throughput is the goal, Parallel GC should still be slightly better *especially* for the generational profile you describe (many short-lived objects).
What I really miss is a good declarative UI descriptor for Swing (FXML beats it, however it has a bad syntax, and ConstraintLayout (from Android, and iOS - the cassowary solver based UI). &amp;#x200B; Currently the best UI toolkit (and application model) for Java (in terms of API, tooling and self-consistency) is the Android toolkit, especially with the new Architecture Components, MVC and Lifecycles etc.
This is an argument which is used often when discussing hibernate/jpa, but I do not quite get it. If something is simple, why not choose the simplest way to do it? What's more is that frameworks tend to be easy to use when task is simple - the abstraction created by frameworks break down only when things get really complicated.
ZGC currently doesn't uncommit memory, but a patch do to so exists. See [here](http://mail.openjdk.java.net/pipermail/zgc-dev/2018-October/000489.html) for more information.
Matter of perspective? :-) Sometiems frameworks help, but sometimes they get in the way and people blinded by "let's use x wherever we can" tend to try solving simple task with bending framework. Also - there is performance penalty (as shown).
Long term reason for what? 
It’s been a long time since I’ve had to apply for a job, but specifying the application you’d be working on seems odd for a job posting. Don’t they usually just list general Java skills as required and you get your assignment when you’re hired?
Not using var. 
We were making a new medical software. Used JavaFx. Love'd it. But i do not have years experience with Swing, so ... it was easy to learn and fun to implement. Can't compaire with swing :)
Who says I don't use var? I use it and usually replace it after since it breaks find usages. When I need to refactor things I want to find all usages of the thing I might break. 
Thanks for the answer. May I learn what's the problem with JavaFX' scene graph for building interfaces? JavaFX still has controls and layout managers Swing offers. I'm going to start a project and I'll need custom controls. Although I have JavaFX experience, I'm not sure if I should be using Swing instead. These are the kind of interfaces I need to be building: https://duckduckgo.com/?q=vst&amp;t=ffab&amp;iax=images&amp;ia=images What do you think?
I think the original replier assumed you implied that you didn’t, just because of the bug. 
A windowing UI is not a scene graph, and should not be modelled according to it. Desktop windowing UIs has no camera matrices, 3D rotation options, there is no lighting, the elements of it are not on a stage in theater. That's what scene graph UIs model, however, they are simply too much for a windowing UI.
I'm not sure about FXML. It relies heavily on reflection. The tooling is bad. And it's not an expressive template language; for example, no loops.
&gt; that make it easy to work with (Such as Spring Security and MVC). I can tell, you have never tried to fully understand Spring Security.
yeah u/dpash is retarded. Now go upvote my comment and vote on that bug. 
i think it's a great addition that improves both reading and writing code. I expecially like it when dealing with collections, like "Map&lt;String, List&lt;Integer&gt;&gt;" or things like that that are hard to read. Often when you construct objects, the class is already explicit on the constructor. If i have doubts of what a var is, i just have to hoover with the mouse and the IDE tells me immediately
It rarely hurts to know more things. Even if applets aren't something you'll ever use again, there's something to be said for practicing the art of learning something new. The ability to quickly and effectively learn new (for you) technology will serve you well in a professional environment
It looks like in your [submission](https://www.reddit.com/r/java/comments/a4vshi/java_jdk_download_url/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Ah, basically you're saying a scene graph is overkill for a desktop application interface. But don't you think it's easier to implement custom controls in a scene graph, compared to an immediate-mode drawing API like Java2D which Swing relies on? I'm talking about the interfaces that can be seen in [the link](https://duckduckgo.com/?q=vst&amp;t=ffab&amp;iax=images&amp;ia=images) I posted.
I’m actually gonna downvote because of your attitude. :)
Well go fuck yourself then.
&gt; Also, AWT is a direct competitor. Nah, come on, it's not even close. It appears you haven't even touched SWT or AWT ever, if you can say such a thing.
Shun the disbe.. nah, ok, you get a pass. ;-)
Well, as for UI descriptors: Swing uses LayoutManagers, but all the ones that are provided by default are bad. I always recommend [FormLayout](http://www.jgoodies.com/freeware/libraries/forms/) or [MigLayout](http://www.miglayout.com/). They are about nearly-declarative. Much more readable than the default LayoutManagers, much more maintainable and even more powerful. I would even use MigLayout when using JavaFX. Actually you can use FXML when using MigLayout. However, I have very often the need to build UIs dynamically, based on the actual data to display. I don't think that would be possible with FXML.
I'd also like a vs SWT, with opinions from people that used it. What SWT has for it is almost native looking UI.
Well, it's quite a different approach. It's like learning a new language. Since UI development is a very complex topic, it takes much time to really learn how to use a toolkit. Then I don't like the FXML approach and especially the styling with CSS. And there aren't any good JavaFX themes available at the moment. For Swing I mostly use \[JGoodies Looks\](http://[www.jgoodies.com/freeware/libraries/looks/](https://www.jgoodies.com/freeware/libraries/looks/)), but there are other good Swing LookAndFeels available. This isn't the case for JavaFX. I once tried to port a simple Swing application to JavaFX and had to abort it, because the UI components (TextFields, etc.) are \_much\_ larger than in all Swing LookAndFeels. The whole application frame was getting larger than the screen. Then I would have to resort to CSS fiddling to fix this. May be nice for a web developer, but not for a desktop application developer. The whole hype around JavaFX seems to be about graphical effects. But most real world application don't need any fancy effects, but a clear and usable visual layout.
I have a year experience in Swing about a year in JavaFX. JavaFX is better. Has a better thought out event system, css (there a lot of cool things you can do), properties (this is huge), bindings, you can skin different controls to give them different looks, easy to implement animation, nodes sizes are double so none of that bs integer calculation when calculating to layout the nodes, if you want to have 3D you can... FXML is gimmick but maybe in the future it will be worth it. There are some drawbacks but overall JavaFX is the future. Specially when you use a design pattern that works well with properties and your sharing different model objects across your screens, so nice.
Its just very different. For my own experience one of the driving forces for me was.. I LIKE "programming" my GUIs, where javafx felt like WYSIWYG with the SceneBuilder and FXML. Its also just a different mindset with Swing being more event driven and javafx having the property bindings. Lately I have been learning Kotlin and in that language there is a wrapper around javafx called TornadoFX that I have really enjoyed and think that if I were asked to make a new application in Java that i'd think about using javafx instead of my "beloved" Swing (if not convincing them to use kotlin instead)
I think it's the S, single responsibility principle. The Gender has been overloaded to indicate not just gender but also age.
Where I live programmers with 5+ years of experience learnt not to reply to job offers without any information about the project. ATM about 70(?)% of job offers I get have some details about technology, like libraries or frameworks. Of course I don't count recruiters PM me with "I have an awesome Java/C++/Scala project. Are you interested in relocation? :)".
Thanks for the answer. I agree, properties are great. I don't know how I'd live without them. They also play well with the event system. The API is obviously more consistent. But is CSS really worth all the hassle? Instead of doing setThis, setThat you need to deal with context switching, give up on static type checking and probably forgo some performance. I don't even consider FXML..
I've been using JavaFX "code only". No Scene Builder BS, no FXML, no CSS. I try Swing from time to time, and I agree that it's more concise than JavaFX most of the time. JavaFX revolves around properties and I think it makes it both verbose and consistent. But I think it's worth it.
Are FormLayout and MigLayout enough to replace every sing Swing layout manager? 
Hard to say. The tax rate could be a field in the Individual class (set as an emun much like gender is) which would eliminate the switch in the tax calculator class and avoid the need to add new cases. The method to calculate tax could be something like individual.getTaxRate() * individual.getSalary() Also the Gender emum has become meaningless. SR_CITIZEN_FEMALE is not a gender and should just be female. The tax rate seems linked to the gender emum so you might want to abstract this out further as new tax rates might change on other values rather than gender.
I totally understand why you don't like FXML and CSS. I use JavaFX but I *hate* them and I code everything in Java. However, I need to make custom components like the ones popular in audio software: https://duckduckgo.com/?q=vst&amp;t=ffab&amp;iax=images&amp;ia=images Do you think Swing controls with custom painting would be a better fit than JavaFX scene graph for these type of heavily skinned interfaces?
1. How to write a thread title that will not give people the mistaken impression you are looking for homework help 2. That you ask for Java help at /r/javahelp 3. You should learn everything you mentioned. Applets are dead, but you need to know them for your grade. At the end of the semester in the course evaluation POLITELY suggest that the course no longer teach obsolete Java features.
yup. 
Cool. Does the software feature 2D/3D imaging? I'd like to learn how do JavaFX APIs compare against Java2D and OpenGL bindings.
I've been using JavaFX for like maybe a year, but I still don't 'get' FXML. I mean, the Java API is pretty straightforward already. May I learn why would anyone use FXML and go through constant context switching and forgo performance and static type checking? Scene Builder is also a mess. Font is like 6pt and I can't even change it (without modifying modena.css or what?), and the accordion panels take 90 seconds to roll over. Do you think FXML and SceneBuilder increases productivity and maintainability? What am I missing here? 
Yes. Originally the Swing LayoutManager were meant to be combined. That leads to a huge visual mess. FormLayout and MigLayout could build any layout a needed and there were some very complex ones and most of them even had to be built dynamically.
&gt; I am in agreement with you (although I'd prefer more variation than var and val but now I'm just bike shedding). I totally would've been fine with let and var too, I don't mind that much either way :)
Definitely. Smart type narrowing is one of the nicest features of Typescript that I miss in Java!
I don't know whether JavaFX does help you here, but I don't think it would be easy with Swing. At least with Swing alone. (But I have to admit, that I don't know how you plan operating that controls). But there is also the possibility to provide a JavaFX frame inside a Swing application. I would just avoid mixing them in the same frame as they have separate event dispatching threads.
Thank you. You saved me from wasting a lot of time with stock managers like GridBagLayout.
Actually most of these interfaces use standard controls with custom skins. I know JavaFX lets me change colors and backgrounds of the controls quite easily. But I though maybe starting from scratch using Java2D would be even easier, since immediate-mode drawing seems always easier to me.
Yeah, ZGC only really makes sense if you have huge live datasets (&gt; 10 GB) and you need low latencies. If you want the best throughput ParallelGC will always be the best option.
Not swing and probably a DB2 thing but jt400.jar jdbc driver, seems to use awt to ask for user name/password when it is wrong in the config files. A little window pops up in my linux dev box, and throws headlessExceptions in servers: [https://access.redhat.com/solutions/2074443](https://access.redhat.com/solutions/2074443) &amp;#x200B;
&gt;Using var can make really hard to read code, but usually it does not Inconsistent usage doesn't hurt readability? &gt;By having a non-idiot at the keyboard typing the code. Please. Even if you follow the guidelines to spec you end up with maybe two valid situations where var is valid. Now 1/10 of your local variables use var while literally everything else is explicitly typed. It's not that var can be abused but rather it shouldn't be a thing that could be abused to begin with. It offers no benefit.
If you don't want to use Java then use another language.
Being able to change your GUI on the fly by modifying a CSS file is nice (without having to rerun your program). Since CSS bs gets cached essentially what you can do is have a CSS file that all your screens have but then for each screen you can have an additional CSS file. You can reference constants in the special screen CSS files in your CSS file that all share. For my game each team has a unique color. What I can do is each team follow a certain CSS file but I add a CSS file special to that team on top which each have their unique constant colors which I reference in the CSS file they all share. So say I load a different team all I have to do is remove the previous team CSS path and add the new one, or just bind to it (this is assuming generic css path is added to parent or whatever). But yeah having the statically typed is nice but having to run your program to see the change is a bitch. If it is simple I just do it statically typed but if multiple things need the same thing I'll CSS. Also some nodes have obviously multiple parts. .title or .content as example. Its a lot easier to change these nodes in CSS than having to do the lookup bs imo. Though if someone doesn't take advantage of CSS I don't think it really matters. I don't know the difference between the performance but I haven't noticed any drawbacks.
Now that's awesome.
I use var in C#, I use auto in C++, yes I am totally on board with using var in Java. It can be abused, it can make code unreadable but it can also help. It's a two edge sword and the developer is responsible for its usage.
Okay, so you're a troll.
[Not even people from C# want var](http://janheggernes.net/post/please-stop-with-the-excessive-amount-of-var-usage). Ignoring that important fact... &gt;IMHO the 'less readable' is nonsense. You should always properly name variables. Long and explicit types or long and explicit variables. Take your pick. At least with explicit types you know what generic type is being used. Or are you going to argue that the generic type should be a part of the get method's name? &gt;You don't 'see' the declaration when you're working with a var 10 lines lower. 10 lines is too much for an IDE's viewport or a text editor to display? Are you high? Regardless, you can scroll or use an IDE to go to the declaration. &gt;People who complain about it almost never have production experience with languages that use it. Case in point the troll below. Yes, you are *totally* using Java 11 already in production and are using var extensively. You're talking out of your ass. Who's the troll again? 
It's one feature on the path to pattern matching
Not everyone uses IntelliJ nor does their IDE support that. Regardless, code should be understandable without an IDE. Not using explicit types makes this basically impossible in all but the most basic of situations.
Understandable But as most of the other responses here have stated, code readability is about the developer, not the code. `AclasSthaTdoeSathinG thing = foo.getAClassThatDoesNothing()` Is still valid java, doesn't mean it's readable. You can have well written and badly written code with or without var, so it's not a valid enough reason not too.
Don't limit yourself to swing vs javafx. You can do a HTML/css/JavaScript front end and Java backed. I used swing one upon a Time back o in 2010 and hatred it... Never messed much with fx. 
I love JavaFX because I can easily separate controller (Java), layout (fxml), style (css). It's easier to write clean code in JavaFx than in Swing. The second thing, JavaFx application is definitely more beautiful than Swing. Especially with JFoenix - just look at this: [https://github.com/jfoenixadmin/JFoenix](https://github.com/jfoenixadmin/JFoenix)
Java is what pays the bills for me. But doesn't hurt to learn other languages.
&gt;But as most of the other responses here have stated, code readability is about the developer, not the code. A generalized argument that doesn't take into account how limited the use cases for var actually are. It's not even a feature worth being introduced. Throwing your hands in the air and saying "It's the developers responsibility" is just letting the floor gates open. Also, inconsistent usage itself hurts readability. 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You are confusing the JavaFX scenegraph with a pure 3D scenegraph like in 3D graphics. They are not the same. For building 2D GUIs you do not have to set lights, cameras etc. The scenegraph basically means that rendering is lazy (or delayed) instead of immediate 2D pixelpainting like in Swing. That is the biggest difference internally between Swing &amp; JavaFX.
I find NetBeans gui builder to be just what I need. It's swing, so that's where I'm at. Tried JavaFX a couple times. I find the api to not be a clean match with what I want. I'm bad at cosmetics, and messing with css sucks. 
I agree! This GC is really great. Heap sizes for this app are 4GB by the way. So ZGC works for small heaps too. Don't know why they're touting it as a large-heap-only GC.
Implementing custom controls using Swing components with custom painting and event handling is very doable in Swing. I've written some games that mix custom graphics/controls with desktop components and it was all pretty manageable. I used Java2D for the graphics rendering and I was able to make it do everything I needed to do. I can't speak about JavaFX since I've only investigated but have no programming experience with it. BTW, are you developing an audio app, or perhaps is it a movie editor? I ask because I'm thinking about writing a special purpose video editor and have been contemplating which platform to use (Java Swing, JavaFX, or C# .NET).
Implementing custom controls using Swing components with custom painting and event handling is very doable in Swing. I've written some games that mix custom graphics/controls with desktop components and it was all pretty manageable. I used Java2D for the graphics rendering and I was able to make it do everything I needed to do. I can't speak about JavaFX since I've only investigated but have no programming experience with it. BTW, are you developing an audio app, or perhaps is it a movie editor? I ask because I'm thinking about writing a special purpose video editor and have been contemplating which platform to use (Java Swing, JavaFX, or C# .NET).
&gt; 10 lines is too much for an IDE's viewport or a text editor to display? Are you high? People who have to resort to personal insults to give weight to their arguments tend to do this because the arguments generally don't have enough weight. So I don't know who you're trying to impress with your 'tough guy' image but it's not working. If you feel having to go back 10 lines (or whatever, the amount doesn't matter) to figure out the type of a variable is okay I'm pretty glad I don't have to work with the code you produce. But hey, you're the guy who's advocating against pretty much anything that's not in Java 5 so I'm 100% we'll never be on the same projects anyway. &gt; Yes, you are totally using Java 11 already in production and are using var extensively. Uhm, yes we are. About half a year ago we started moving services to Java 10 and we are now moving to 11 once Spring Cloud is ready. But we're actually moving to Kotlin, so for us the var/val debate is kinda moot. 
Very nice. The last time I tried studying for that test, back in the day, the shortage of practice tests ( and ones the same level of difficulty of the exam ) made things much harder. I might just give it a shot again with this resource.
&gt;limited the use cases for var actually are Care to explain? From how I understand it, it's used for every local variable initialization, which is hardly limited use.
Damn this thread started a complete shit-storm, I knew it would... hehehe
Would it be true that Java FX builds are intended specifically for particular Open JDK builds? Even builds from the same "builder" or "binary build provider" ? &amp;#x200B; More concretely: Would a Zulu OpenJFX work only with a specific OpenJDK version? If so, only that version from Azul, or that same OpenJDK version from other builders? &amp;#x200B;
&gt; Not even people from C# want var. What? One guy's blog post? Look at any modern C# codebase and you will see var pretty much everywhere. There was an outcry when it was introduced (like the one Java is experiencing), before everyone got used to it and realised it's not a big deal. I expect the exact same thing to happen here.
It clearly violates O - the system is not open/closed. You cannot add another tax category, without modifying TaxCalculator as well as Gender. The system shall be extensible by adding new classes without modifying the old one. For example, if Individual would be an abstract class, witht a calculateTax() method, and there would be a subclass for each tax category, it would be O/C. And the TaxCalculator class would simply disappear - it would move to Individual, as it should be. 
It would be much better to call individual.getTax() and there is no need for TaxCalculator anymore. This method hides away all the abstraction, that how the tax calculation shall be - there may be Individual instances (subclasses of course) that contain much more complicated logic of tax calculation, not just rate \* salary.
Not adding \`val\` was such a huge miss. Of course they have their reasons (they had their reasons for erasure, etc.). Still a big miss,
&gt;People who have to resort to personal insults to give weight to their arguments tend to do this because the arguments generally don't have enough weight. So I don't know who you're trying to impress with your 'tough guy' image but it's not working. Man that's funny because I could have sworn you called me a troll... &gt;If you feel having to go back 10 lines (or whatever, the amount doesn't matter) to figure out the type of a variable is okay I'm pretty glad I don't have to work with the code you produce. Right back at you.Typing long variable names over and over again is a PITA. &gt;Uhm, yes we are. About half a year ago we started moving services to Java 10 and we are now moving to 11 once Spring Cloud is ready. &gt;But we're actually moving to Kotlin, so for us the var/val debate is kinda moot. I have to call into question how critical the project you are working on actually is or it's size if you can migrate so fast and switch to a whole other language(JVM or not). Granted, Java 9 is the major hurdle. Probably for the best since you don't seem to want to use Java to begin with.
I can vouch for MigLayout. I've been using both it for years and it does everything very well. I've recently tested it with JavaFX and I think it's works better than anything that comes out of the box. Before Mig, I used FormLayout and it was also better than anything that comes with Swing.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I have experience with both. ** Pros:** #2 Swing: Look and Feels. Yes the default looks and feel are HORRIBLE. But with JTattoo for example, the application looks gorgeous. No need to mess around in CSS files. Skins can be changed live. #2 JavaFX: -CSS is a double edge sword. Still a pro i guess. Didn't try to dynamically load CSS files to "skin" the app. Is this easy? -JavaFX has great media capabilities. Its play Mp3 out of the box. But not OGG! I tend to use OGG files. Also Media does not accept InputStream!! WTF really. But overall Java FX media is good. -Multi touch event support. That's a nice one. ** Cons:** #2 Swing: Old AWT heritage makes the API heavy. #2 JavaFX: The String display size computation is hacky. Frankly it is a big let down that didn't find a way to compute by declaration. You need to draw the String before you may know how many pixels your String will use. Swing computes string width easily. 
&gt; I have to call into question how critical the project you are working on actually is or it's size if you can migrate so fast and switch to a whole other language(JVM or not). It's only the back-end of the largest DIY chain here. The bits that allow people to buy stuff. Nothing special. It's not like it costs thousands of dollars per minute if it's down or anything. 
You can't use it for *every* local variable initialization without details being lost. You aren't supposed to use it with the diamond operator(generics) which basically means that using var with any get method that returns an interface with a generic is violating the guidelines. Even then in the one case that it could be used properly: var myFoo = new Foo(); might not be the best of ideas because Foo could implement an interface and you should always program to the interface.
Should that count as usage? Compare the following: // 1 Something x = getSomething(); x.foo(); // 2 Fooable x = getSomething(); x.foo(); // 3 getSomething().foo(); // 4 var x = getSomething(); x.foo(); In all four examples an object of class Something is used, yet no one cared that #1 was marked as "usage" and #2 and #3 were not. So why should #4 count as usage of Something? 
I gave you reasons. Which one is wrong?
&gt; Have you tried compiling and seeing what JAD, Fernflower, Procyon etc spit out? I tried decompiling Scala many times. The result is either shit that doesn't compile, shit that compiles but does a totally different thing, or the decompiler just gives up completely.
You should. It's doable.
For those who wonder why does it a big deal: * JavaFX 8 is available through Oracle JDK, which is now a commercial JDK. * To run a JavaFX 8 application, the user needs to install OpenJDK with JavaFX support themselves, which is an icky process. Because you can't legally use Oracle JDK anymore. * Even if you're a developer, setting up JavaFX to start development is one additional step that wasn't necessary before. But now Oracle JDK is commercial, you can't even use it for development without Oracle's permission. * You can't even think of deploying your application with Oracle JDK bundled. Azul guys brought a good solution to address all these problems with ZuluFX.
It has gotten easier over time. I've seen Sun, then Oracle take topics off the exam over the course of my several attempts to finish studying for it. There is also now the "associates" certificate before the "programmer", which I understand is a little less hard and could serve as a stepping sotne.
Implicit conversions are just function calls that aren't written down. So where in Scala you have f(x) // x is implicitly converted in Java you'd have f(convert(x)); The special case are implicits that exist only to add syntax to existing types and nothing more, you can usually replace those with static methods in a utility class: implicit class FooOps(val foo: Foo) extends AnyVal { def baz(bar: Bar): Baz = ... } ↓ public class FooUtils { public static Baz baz(Foo foo, Bar bar) { ... } } 
Ya I was wondering if there was a fancier way that’s not just a util class
I work for a large retailer. We are migrating one of our biggest apps to java fx. I worry for the future.
Just want to +1 miglayout. A few years ago I did a lot of swing and I went through every layout manager multiple times because they frustrated me to some extent. Even formlayout, which is fine but it's hard to find documentation. I had settled on spring layout because it was the only one that I could just tell it what to do and have it do it, but when I found miglayout that was the one. Great documentation and examples to the point and you can just get it to do what you want. I stepped away from swing for a few years now though and came back to java FX when I had to do a desktop app. I really liked it a lot and I wouldn't go back to swing. It still had some documentation issues compared to swing and some 'great libraries' people say to use aren't really that great, or just poorly documented so hard to figure out etc. But overall I liked javafx and I felt it was just designed better and felt less obtuse for just getting things done. That also could just be me being 10 years more experienced as a developer too, so who knows. 
Thanks for confirming Java2D's power. AFAIK it's still CPU-drawn, but it's very capable API for almost any 2D visuals. I'll be building an interface with skeuomorphic design, something only found in audio software these days. Drawing custom shapes is easy in Java2D, but you need to implement your own hit detection system to detect, for example, a mouse click on a polygon, right? JavaFX handles that automatically, since every shape is a Node. Also which library you use for animation and tweening in Java2D/Swing? JavaFX comes with one out of the box. I think for video JavaFX is also a winner thanks to its Media API. You'll need to process and preview video clips a lot. If you go Swing route, you'll probably need to implement stuff using OpenGL thtough LWJGL or something.
JFoenix looks beautiful! Can you tell me about your workflow with FXML and CSS? I know JavaFX API very well, but I just couldn't get into FXML at all.
That's just a naming error, rename it to TaxCategory and you're fine. The real violation is the Open/Closed principle, for the reasons /u/persicsb stated.
&gt; AWT is a direct competitor. It's rather the other way round. There are few good reasons to build a frontend with AWT nowadays. JavaFX can definitely be considered its successor.
NetBeans Matisse is a beast. But how do you change the GUI builder's Look &amp; Feel, so *What-You-See* becomes actually *What-You-Get*? I want to customize Metal accurately, but buttons in the GUI builder are just "native" L&amp;F.
It's literally compiled to a util singleton though (like every AnyVal).
Oh, MigLayout is also better than JavaFX's layout panes too? I use VBox/HBox, AnchorPane and StackPane a lot.
It's very handy when writing foreach loops, especially when iterating through maps. Yes, nowadays Streams ought to be used, but as soon as side-effects show up, or there are more than twl or three steps, it becomes unwieldy.
Yup, you should pick a GC algorithm based on what you care about. ZGC is nice if you are doing things like web servers with large heaps and many CPU cores. ZGC is not nice if you on a single core box with limited memory doing batch processing. * On a single core box? Serial collector, every time. * Care about throughput? Parallel collector * Care about response time? ZGC or G1GC depending on how much of a performance hit you want to take or how big your heap is and the overhead you care about. * Have a smallish heap (less that 6gb) - Parallel collector all the way.
How many cores and did you try G1GC or the Parallel collector? What did you use before hand?
I think I was comfortable with fxml because I am doing a lot of android development at the moment. Being used to doing layout xml files over there it felt natural to use fxml. But don't get me started on trying to get scene builder behaving. I'm not even sure why they bother shipping that broken mess in intelliJ and instead they should reference people to the stand alone one. 
I think JavaFX's future is quite bright. Oracle still finance its development, but it's now more independent without being tied to Oracle or JDK release cycle anymore. How do you like the API of JavaFX compared to Swing's, BTW?
I found my productivity to increase when using Gluon scene builder. Building a GUI without some sort of scene builder takes time, and I never found a scene builder for javafx (only swing). Maybe I’m missing something 🤔. 
Yeah, I guess that's fair if you think of Scala as being more comparable to something like Haskell than Java or the other usual OO suspects.
Spring Data JPA here. If you're doing Spring and you're doing JPA, and you're not using Spring Data JPA, then you really should look into it. It makes life so much easier. Repository classes are, 99% of the time, just an interface with `@Query` annotations on the methods.
I'm actually thinking of giving SWT a try for a few tiny projects where I'd like to have native GUIs. But many people don't like it for some reason.
MigLayout just uses a universal MigPane. You define the whole grid-based layout in one place and then you just fill out cells in order, using `MigPane.cc` attribute to skip empty cells and override pane-wide defaults. It's pretty clean and versatile. The layout resizes nicely. I'll admit I don't have much experience with JavaFX, but fiddling with standard layout panes wasn't fun and finding out that Mig was also available for JavaFX was a huge relief.
Yup, exactly right. You'll spend a lot more resources doing GC with ZGC. That is the trade off it is making. At the cost of more cycles on GC, slower application execution, and more heap overhead, ZGC will decrease pause times. If you care about throughput, the parallel or serial collector are the best you can do.
well, google says it does https://www.google.de/search?q=javafx+3d&amp;rlz=1C1GGRV_enDE753DE753&amp;oq=javafx+3d&amp;aqs=chrome..69i57j0l5.2735j0j7&amp;sourceid=chrome&amp;ie=UTF-8 but i do not have any 3d experience with javaFx myself :)
Why would you use ZGC if you were using the serial collector earlier? On a single core box/vm, only the serial collector should be used, everything else will just slow things down with no upside.
Oh, being able to change the look on the fly would really speed up my development. Do you use it with FXML, by the way? I really want to use the Java API directly, even though I moved off my styling to CSS.
We have some swing legacy code that I rarely touch. But it always seems to be easy to read and maintain anytime I need to get in there. Honestly, I would prefer to work with a web front end more than either of these.
Yes, I agree. But I saw some developers decided to use Mybatis. I noticed that if we use Mybastis, we need to work with SQL to create Database Schema. I'm bad at SQL =)))))))))))))
You most definitely don't want to mess with GridBagLayout, avoid it like the plague. However, you also don't need to use any 3rd party layout managers. You can achieve almost all layouts you need by nesting containers using BorderLayout (default top-level container layout) and BoxLayout. The default layout for all non-top level containers is FlowLayout, that is nearly worthless though. Swap it out for BoxLayout.
Thanks for the detailed answer! I didn't even know JTattoo existed. It looks quite good. Multi-touch would be nice too, but I don't think I'll need it soon anyway. Here are the some examples of GUIs I'd like to build: https://duckduckgo.com/?q=vst&amp;t=ffab&amp;iax=images&amp;ia=images As you can see I need to implement new custom controls and modify existing ones. It means a lot of Java2D drawing in Swing. Do you think I'd be better off just using JavaFX, since it's a scene graph, it is quite straightforward to create custom anything with layout panes and modified shapes/controls.
I'd probably make a "Taxable" interface and have individual implement it. I wouldn't try to do this with inheritance as there isn't a good hierarchy for Taxation which really applies to both individuals and corporations. I do sort of feel like pushing tax calculation onto the individual violates the S principle. I also don't think that it really solves the open/close principal problem. Wouldn't adding a new gender STILL require you to also modify individual?
&gt; You can do a HTML/css/JavaScript front end Then you are stuck reinventing the wheel trying to get a stateful rich GUI application with a stateless protocol. Web apps are fine for simple CRUD applications but they are not great for rich client apps. 
I mean the software you're working on. :)
Yeah, nested vertical and horizontal BoxLayouts are actually all I need. A few more objects wouldn't hurt anybody, I guess.
I'm actually running away from web to desktop applications. So one more web job available :)
We didn't profile extensively with G1 or the parallel collector, so can't tell ya, sorry. CMS is great if you can build your application such that nothing ever gets promoted to old gen. If you can't, it becomes bad.
Extending enum would be fine, and adding a case in calculator as well it's simplified code. Business change was when citizen is Female and over SOME age tax would be 17%. Only required change would be in calculator FEMALE case age &gt; SOME ? 0.17: 0.20 * ... Only calculator is required to know tax rate for individual. Changes presented by developer would require changing currently stored data, and update them every day (age is stored instead of day of birth so anyway...) . Female is not any longer female if over SOME age. /u/audioen is right it smells on S
Maybe I should just grab its source and build it with bigger fonts haha.
It looks like in your [submission](https://www.reddit.com/r/java/comments/a4y7pp/i_have_been_asked_to_help_with_recommended_java/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I can't recommend TornadoFX enough. Check it out if you get time. https://github.com/edvin/tornadofx
I don't think so... the ecosystem is vastly superior for JS than for JavaFX in my experience.
[JOOQ](https://www.jooq.org/). Thats [why](https://www.youtube.com/watch?v=wTPGW1PNy_Y).
Wait, what do you mean with can't use for development? Two or three weeks ago I read the license and it was on for non production workloads like dev, test and demo. Jdk8 is still free (like beer) , if you don't install updates, next year. Or am I wrong? 
&gt; I'm bad at SQL That's a skill you should improve. JPA does not insulate you from knowing SQL. If anything it's more important to know it well :)
That was more a business/client management/bills/waiting room management giant monolith but nothing with 3d sadly. 
&gt; but you need to implement your own hit detection system to detect, for example, a mouse click on a polygon, right? That's correct. In Swing you'd need to do your own hit detection, but only within the bounds of that UI component, which is a rectangular extents. &gt; You'll need to process and preview video clips a lot. Yes, precisely. I'm really concerned about scrubbing. I want scrubbing to render smoothly. I'll have to play with the JavaFX Medial API to see if it fits the bill. Thanks! 
&gt; Yes, nowadays Streams ought to be used I find they often do not pull their weight and the imperative loop-if construct is easier to read and write. And indeed, as you said, `var` really helps when working with the `Map.entrySet()`
Just fix the bug and continue comparing the two alternatives. What do you get from denoting the full `Record4&lt;Integer, String, LocalDate, Long&gt;` type twice? Nothing.
I think you're agreeing with me here based on the other comments you've made in this post. I suspect Jetbrains will fix it sooner or later, because it's quite a serious bug in their indexing. The silence on the issue is a little disconcerting.
Ah, I see. Well, everything in JavaFX is 3D accelerated, so nothing stops you to implement some videogame-like effects for buttons and stuff :P
The problem with JavaFX for low-level stuff you don't have access to the underlying OpenGL/DirectX context. I also recommend giving LibGDX a try. It's a game engine, but it abstracts APIs like OpenGL or OpenAL nicely. Some non-game applications, like [Spine](http://esotericsoftware.com/) is built with LibHDX. Actually the author of that software also built LibGDX's Scene2D scene graph.
In FXML file you keep the layout. For example, you design buttons positions relative to other objects. You also can set name of methods for some trigger np. onAction: `&lt;GridPane ...&gt;` `...` `&lt;Button styleClass="animated-option-button" onAction="#removeSomething"&gt;&lt;/Button&gt;` `...` `&lt;/GridPane ...&gt;` &amp;#x200B; In Java you have to create controller for this layout and you can implement method from fxml `@FXML` `public void removeSomething() {` `doSomething();` `}` In css file just put your style: .animated-option-button { \-fx-background-color: #F1F1F1; \-fx-background-radius: 30px; \-fx-pref-height: 30px; \-fx-pref-width: 30px; } &amp;#x200B; That all - you can easily separate business logic from layout and style 
CMS is an old gen collector. If nothing goes to old gen then you aren't using CMS. I'd suggest, for such a small heap, you give the parallel collector a shot. Pull off all your tuning and just let it do it's default actions. I'm not sure if it can get 7ms 99th, but I'd be shocked if it was above 50ms for that small of a heap.
That's a fair point, but can't we have both? A language that allows explicit mutability while defaulting to compiler-determined behavior. It's at least a neat idea for a learning project (;
Oh, so you start with building the GUI in Scene Builder first, then switch to Java to do the business logic? It looks quite straightforward when you put it this way. Thank you.
I don't use FXML at all. Though do some research for yourself. Don't just follow my lead and think things will be ok. I have refactored my code so many times. I actually am converting my game from MVP to MVVM. I took advantage of properties in the View but I found a lot of the time my different Views would want to know about the same data (for instance User object). Having a layer between the Model and the View where the View can bind to the data I have found to be really elegant. You change one spot and if have different screens binding to the same ViewModel they'll all update same time, rather hard coding the changes or passing an event indicating the change. What's nice too is I prefer my View to be dumb as shit and with MVVM it is. MVVM is like a better version of MVP. One last recommendation is take advantage of dependency injection. I'm using SpringBoot currently and it has made life easier. I use SpringBoot for my server side and figured why not use it also client; this later bit me in the ass for android but oh well.
This seems excessive.
case 1 - is correct case 2 - you'd find usage for "Fooable" then. case 3 - the ide should warn that you're not using a return value case 4 - the bug with find usages 
Enh... I maintain a GUI of middling complexity, and have been pretty happy with the bog standard GridBagLayout. I made a simple helper that actually draws the "grid" that the layout manger comes up with, so most of the potential mystery is gone. The grid is off by default and doesn't even get built for releases, so zero overhead for real users. I recognize that GridBagLayout is not easy to get started with, but after playing around with Mig for an abortive attempt, I haven't needed to find a replacement. :-) (Might still need to pull in enough JavaFX to get their updated HTML/CSS support in text components, but I'm not looking forward to that.)
This. And even more: you should also know how ORM framework typically uses SQL for your JPA queries.
It looks like in your [submission](https://www.reddit.com/r/java/comments/a4yxog/im_presenting_a_free_webinar_on_java_se_license/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt; I'm bad at SQL Have you pondered learning/improving it instead of avoiding?
Looking forward to it!
Oops wrong sub... Doh...
Using properties and binding for a game is an unusual choice itself. I mean, it's not very common, is it? Probably because it affects the performance a little since it needs to poll the observed stuff constantly. What do you use for the Android port, BTW. LibGDX?
Not really. Property binds are just so much simpler. 
JavaFX has 10x worse performance than Swing. I don't like the idea of text processing for no particular reason.
We used the serial collector earlier because it had really good heap compaction characteristics, but it causes big juicy stop-the-world pauses. I'd love to find a parallel GC with good heap compaction characteristics.
&gt; There are some drawbacks Care to elaborate? I'm genuinely curious.
I don't do programming professionally anymore, so I can choose whatever I want to do. So my priorities are: * Be runnable on the oldest viable Java language spec possible. Right now that is 1.6. (For the same reason my C code is C89: one never knows what you might want to run your stuff on. It's nice being able to compile on Haiku, IRIX, and Visual C++ 6 for example.) * Be easy to read for those rare people that might want to lift my code into their own projects. Most of my stuff is licensed MIT for that reason. * Not have to be written again. As much as people complain about never having time to fix technical debt at work, it gets 10x worse for home projects. Do I re-write crap, or have a nice dinner with my wife? So I would rather spend the time once to do Javadocs, write out type names, and refactor sooner rather than later, so that I do not confuse myself years later. Obviously 'var' will take quite a while to enter my projects. (It would have been nicer IMHO to call it 'auto' too, since 'var' means so many things to different people.) 
The parallel collector has the same heap compaction characteristics as the serial collector does. Still a stop the world, but will see a speed boost approximately the same size as the number of cores you have. (IG, 4 cores will be ~ 4x faster, little bit less due to threading overhead and certain object graphs). G1GC also does compaction, but has a much higher memory overhead/GC overhead compared to the parallel collector. G1GC compaction isn't quite as good as the parallel collector but is leagues better than CMS. CMS is about the only collector that doesn't really do compaction (CMS sucks).
You have every Java library at your disposal when writing a Java GUI application whether you are using JavaFX or Swing. Are you claiming that the JS ecosystem is vastly superior to the Java ecosystem?
My main worry about JavaFX is its longevity, Will it run as good as it does today in all systems ten, twenty or thirty years from now? There are points both supporting and against this but I haven't yet heard from anyone who could actually talk with any degree of authority about this. At the other hand, Oracle has been deliberately cautious when talking about the future of Swing as well. For all we know, they could be planning to "drop" Swing (similarly to JavaFX) in another major release or two. Unlikely it will happen any time soon but again, I'm thinking about in ten years and forward.
I decided to just scrap the Android port for now. I'm essentially creating like a board game so to speak so I can get a way with binding (its 100% GUI based as in I don't really have a render/update loop), but your right in a normal game wouldn't make much sense to do what I am doing right now. With another game I'm working on (much smaller) I'm planning on using LibGDX which has been fun.
By text processing, you're referring to FXML and CSS?
Yes, it's the DB2 JDBC driver. The compliance tests were probably done on a desktop machine. In practice, another authentication method would be used on a headless application server. Nasty surprises like these are the reason why the module system is so important for the Java platform.
except product owners that see no business value in there :)
myBatis, because we know SQL and want to have proper control over application performance.
man, those framerates are not good. maybe it's just the compression. 
this is the way I do it. create the layout in fxml, and use java/scala for the controller (like, the bindings for buttons, etc). 
Check out /r/marcolinux comment. The DB2 driver seems to try to open a GUI dialog in case wrong credentials are supplied.
I'm not sure if any current GUI toolkit will be around in 2030. Microsoft is infamous for abandoning GUI frameworks. Win32, MFC, Winforms, Silverlight, WPF, UWP. Now they're kinda obsessed with JavaScript. macOS is slowly becoming iOS. Cocoa will be around, I guess. But I doubt if I can build a Mac app today and run it in 2030. I guess people will still be making web apps in desktop software form, but JS frameworks are changing weekly. GTK+ will probably be around and annoying as it is today. Qt is going nowhere, but anything remotely interesting will be licensed under GPLv3. Or GPLv4, or GPLv5... Java... I can't see IntelliJ IDEA, Eclipse, Netbeans, MATLAB, Oracle's own stuff disappear in 10 years. Swing will be around in some form, for sure. Probably SWT too as long as IBM is alive. I think JavaFX will be around too. Many universities switched to it. Some commercial software are being developed with it. Oracle still finances its development. Talented people will still be working on it. I think it doesn't really require a lot of manpower to maintain a stable GUI toolkit.
Personally, I largely let the layout managers do their thing; wanting to be pixel-perfect while still being cross-platform is just a recipe for misery \[and, spoiler alert: You will not succeed\]. I'm just in the habit of doing things in a way that means it'll work fine everywhere, even if it doesn't look *exactly* the same everywhere. But, to answer your question, you can specifically tell Swing to use Metal, if that's what you want; `for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {` `if (info.getName().contains("Metal")) {` `javax.swing.UIManager.setLookAndFeel(info.getClassName());` `break;` `}` `}` Look and feel is set once, Swing-wide, on startup. If you want Matisse to be Metal, you need all of netbeans to be metal, which you can do: [http://wiki.netbeans.org/NBLookAndFeels](http://wiki.netbeans.org/NBLookAndFeels)
JavaFX was relatively easy to get into wrt. 3D, but the API has very few high-level features, and some very basic things were missing (no point or line class, for example).
Turns out that it's just very easy to shoot yourself in the foot performance-wise with Javascript. Things like memory leaks and hogging the event loop are survivable in Java, but deadly on Electron. Seeing the Spotify client spin on 4 CPU cores at 100% has convinced me to uninstall it.
I'm on 8 so take what I say with grain of salt. A ton of the API is "hidden" as in you can't access it directly (probably for the best but can be annoying), there is no standard to certain things like changing the screen, transitioning between screens, or adding audio to node whatever (this point is me just bitching), no easy way to change the native window buttons or even color (right now I believe you just have to hide it and make your own buttons/top), no standard to scale your application (you can with an added dependency, or using right layouts/controls), WebView is a bit crappy, FXML isn't worth it imo, CSS standard is a bit behind, try to scale Font in JavaFX and have fun, some node skins don't scale ideally but its not a huge issue, there isn't something like ImageIO for JavaFX (try to save a image in JavaFX), having a CSS "property" that makes the mouse transparent, being able to set the duration for what it takes to show a tool tip would be great, I know Java 11 just got RobotAPI which is cool, maybe there was a standard to test your application, be cool if JavaFX had its own dependency injection tool or something... That's off the top of my head but I feel like I have ran into more issues than I have listed. I also know a lot of my drawbacks I listed shouldn't really be considered because that's what framework should do and a lot of the problems could be solved with just an added dependency to your project but I digress.
This, 1000x. The problem with code is not how fast you can type, is how long it takes to understand it, and if you have to stop and think about what the variable type is, something is wrong.
Look into Gluon.
Yes. The alternative is building the app with a JavaScript framework. Then 'compile' it into versions for each app store using Cordova / PhoneGap. React Native is another popular solution. However to answer you main question - yes, native apps developed for 1 platform must be re-written for the other. This is a major disadvantage of writing native apps. 
Your impression of JavaFX and Swing seems quite mistaken: - While there are some bugs and shortcomings that were never fixed, Swing is a battle-tested framework and very well documented. For example, the Jetbrains family of IDEs and Netbeans use Swing. - JavaFX is great, but it has had a complicated history and the platform has changed heavily. The major versions of JavaFX are quite different from each other. This fragmentation is not conducive to its adoption. - The features and improvements of JavaFX are not that decisive, and it has no killer feature that justifies porting every Swing app in existence to JavaFX. Thanks to the scene graph architecture it is awesome for multimedia and 2D graphics applications, but for many other use cases Swing can deliver just as well. - JavaFX has historically been part of the Sun/Oracle JVM. This means that its versioning was tied to Java. Now, thanks to Oracle's change in Java policy, OpenJFX has to be bundled like any other library dependency. - Meanwhile, Swing continues to be available on any desktop JavaSE instance. This has created a very low barrier of entrance, and many Java programmers educated in the 2000's were exposed to it.
OK, that's interesting, but it's IBM code not core Java, and in Java 7 which is a while ago now. Does anyone know if the problem is still there in 10 or 11? 
But why would we go back to that when ZGC is so fast? We don't care about throughput for this application. It's all about the latency.
I claim that the UI js ecosystem is vastly superior to the Java ecosystem.
Yes! The way you are describing, you need to do it two times. 
The Scene Builder is way better imo.
&gt;The alternative is building the app with a JavaScript framework. Also, an alternative is to use C++ for your app, in which case you'll have to roll a lot of UI code yourself and use minimal amount of Java for Android and Objective-C(++) / Swift for iOS. Most notably games can be written like this, when OpenGL can be the main rendering engine for your app, and you don't have to deal with UI much.
For the most part all development on the ADBA spec is visible on the list. Yes, I have some changes that haven't been pushed yet, but that's because I'm not yet satisfied or the change is so minor as to not be worth the effort. It is reasonable to assume that the version of ADBA in the OpenJDK sandbox is up to date if not exactly tip of the tree.
I agree. JavaFX's current 3D is basically a toy.
You know that you cannot extend enums in Java? Any enum T implicitly extends Enum&lt;T&gt;, and there is no multiple inheritance. 
With moving tax calculation to Individuals, there is no need for Gender. It simply disappears, it's explicit existence is encoded into the class hierarchy. Let's use and not misuse the type system! 
Haha, you'll never know. Many successful products were started as a joke. :)
The JS UI ecosystem is built entirely on a dirty hack. Unless an app is using the canvas they all work by dynamically changing the text-based DOM and the text-based DOM was never meant to provide support for rich client applications. I can't imagine how anyone could think that a platform that is built entirely on a dirty hack is "vastly superior".
That's what I like about JavaFX. I also have a few board game ideas, and JavaFX is capable of executing them well. Even easier than Swing and Java2D thanks to properties and scene graph. I mean, Flash games dominated the casual gaming world for more than a decade, and it was a similar scene graph API with many features lacking and no GPU acceleration until it's too late. I really liked LibGDX but it was mainly because its JavaFX-like Scene2D. I wanted to give javafxports a try but avoided it because I needed to use Oracle JDK 8. I think I'll try again some day thanks to ZuluFX 8. Glad to see another JavaFX gamedev, though.
There's no polling in javaFX, it just cascades out a change event to all listeners when they happen. Can introduce some issues if you're not aware of this when dealing with UI thread stuff. 
I don't like that there's multiple notations for the exact same thing, where sometimes one notation will make more sense, and other times the other notation will make more sense. I like picking one notation that makes the most sense to me, and sticking to it. For var, I am conflicted and the decision which variety is most sensible will be dependent on context. Ugh.
XML layout is one of the reasons I tried Android development several times and failed miserably. I wish I could code my GUI like I do in JavaFX, but Android API is complete mess. No surprise Android GUI framework was created by one of Swing's creators...
&gt; FXML isn't worth it imo It's cumbersome by design and can't be fixed, unfortunately... &gt; WebView is a bit crappy Haven't tried yet, but I heard they're getting it right in 11. 
I always find this amusing about GridBagLayout. Talk to one dev and you'll be sure it's the most powerful layout manager ever. Talk to another one and you'll believe it's the worst thing since Nickelback. I'm confused. :D
I abandoned JavaFX 8 because of Oracle JDK 8 going commercial, and TornadoFX supports Java 8 only. I'll give it another try thanks to ZuluFX 8.
Oh I make a lot of custom controls. Being able to import them into Scene Builder sounds like a great feature. I wish I could customize Scene Builder too. The font is just too small. :(
Because the parallel collector may be faster both in terms of execution time and pause times. ZGC and G1GC have relatively high overhead (CPU and Memory) to get their pause time guarantees. For small heaps, you can very often have pause times shorter than either simply because the memory set is small enough for the parallel collector to completely traverse. You get the added bonus of higher throughput for free.
Unfortunately the embedded one isn't the same as the standalone. The embedded one crashes and locks up all the time, it's really bad. The standalone one works as you'd expect. It took me about half a day to figure out wtf was going on since I just though the scene builder was garbage so why would I want to download it stand alone? 
Thanks for clarifying. So there isn't much performance penalty?
Interesting. I always tried the external one anyway. You can configure IntelliJ to launch the external Scene Builder. Why do you like it, though? Does it really provide significant productivity compared to going full code?
I keep it on my desk and when I run into a situation that's reflected in the book I go check out the relevant chapter and think on it.
Having worked on the exact sort of system you are proposing (for finance/accounting software no less). I'm just going to have to disagree with using class hierarchies this way. Mainly because the tax code is never this simple. So you are proposing we have a "MaleIndividual" and a "FemaleIndividual". But what happens when we start talking about, say, dependents? Now do you have "MaleIndividualWithKids" and "FemaleIndividualWithKids". And now, what if someone owns a farm? "MaleIndividualWithoutKidsWithFarm"... etc. See how that can get really, REALLY messy, really quick? You might say "Ok, lets just put the tax rate on the Individual"... fine, that might work, but again you have to calculate that somewhere, so you've just shifted the problem to a new location.
Not really making your point linking a 50 minute video. Wanna boil that shit down to the important details? I don't see how Spring would expose code unless you did something batshit crazy.
Spring with Hibernate as a database provider implementation for JPA
I fucking hated var in C# and I fucking hate it in Java. This means I'm going to run into poorly written code with 0 documentation AND I have to hover over each method to see what the fuck it returns to find out what's going on. Mark my words this is the worst thing that has ever happened to Java.
&gt; The programmers whinging about `var` hurting readability are short sighted and I seriously question the breadth of their programming experience outside of Java. What *exactly* is "short sighted" about it? Did you just throw a dart at a book of random criticisms and land on that? What exactly is good about it long term? The fact of the matter is most of the time it's gonna be used badly. It's gonna be used in code with zero documentation that has 200 line methods and poor method naming. I'm gonna have to hover over each one of their terrible methods to look at the return type EVERY SINGLE LINE. It's the worst possible thing that could happen to Java. Java was the one bastion of formality left...
Hehehehe, yeah, it's a polarizing topic. The difference primarily comes down to the context of the work being done, and to a lesser extent the preferences of the people doing the work. The layout mangers themselves are obviously perfectly capable, but not everybody uses them in the same way, and that's fine. We're not Python, we don't need to be limited to One True Way of things. :-)
I like it! Thank you! 
Love it, makes sense. Thanks so much! 
Good ideas! Thank you! 
Seems smart, I’ll start doing this! 
This makes sense and seems like a great way to go about it. Thanks! 
FXML is fine if you like separation of concerns but it only works for layouts. Binding is limited in FXML which I think is actually good in a way. In WPF for example, there are advanced binding options but when you misspell something it just fails silently. So binding in real code at least gives you all the nice type safety. 
Well... NASA seems to be able to use that toy for some cool stuff: [https://jaxenter.com/netbeans/developing-nasas-mission-software-with-java](https://jaxenter.com/netbeans/developing-nasas-mission-software-with-java) I went to a talk at Oracle Code One about this... pretty cool stuff.
Dude, we had a large WPF app and periodically we'd have the "rebranding" and UI uplift meetings. With the styling code scattered around all over the place, style uplifts were big jobs. A couple of years ago we started JavaFX for our project and when this came up again we had it done in a couple of days. We ended up demoing the new styling to the whole company while the other WPF teams were still in scramble mode. 
My dear fellow programmer my heart goes out to you
Lol I know some people will use var properly, but sooo many people won't. 
No one calls their `BufferedInputReader` `bufferedInputReader` when using explicit types. This is a strawman. Obviously it would be called `bir` or `reader`
But, it doesn't integrate with my IDE as cleanly as Matisse does in Netbeans.
Just getting "opened up", but this might be of interest to you: *DriftFX is a JavaFX extension allowing you to embed native rendering engines (eg OpenGL) into the JavaFX-Scenegraph. To embed external rendering engines DriftFX exposes a new Node-Type DriftFXSurface one can put at any place in the SceneGraph and treat it like any other JavaFX-Node – you can apply transformations, effects, … on it like you do with any other JavaFX-Node. In general you can think of it as ImageView on steroids.* https://tomsondev.bestsolution.at/2018/12/04/announcing-efxclipse-driftfx-integrating-native-rendering-pipelines-into-javafx/ https://www.youtube.com/watch?v=3OSgPJghGhM&amp;feature=youtu.be&amp;a= https://github.com/eclipse-efx/efxclipse-drift
Thank you. Of course, you're being ironic by saying "as luck would have it" -- the creation of this document was by design, and its intent was to head off discussions such as this one. Apparently, it has failed.
At the very least every IDE should have a button that replaces all occurances of `var`
Repo - https://github.com/eclipsesource/efxclipse-fxgl
I may have been a little facetious there. That and the FAQ are definitely important documents on the feature. I suspect the issue is that it isn't well publicised. I'm not helping by linking to it on perhaps the very bottom comment in this thread :)
That'd be an interesting button to code. If you have a huge abstraction hierarchy how would it decide how specific you want your type reference to be? 
Swing was brought up during Ask the Java Architects, [here](https://youtu.be/YR7ulGzerMQ?t=2833). As stated, there are no currently plans to deprecate Swing, but of course that could change with time.
It's not. It's required reading for every intermediate to advanced Java developer. I keep discovering things I forgot every time I read the book.
There are software development kits for making cross platform apps such as Flutter (made by google) and React Native.
Have you looked at Spring Data JPA? You can not believe how happy I was the day I discovered that. Threw away so much custom code. Isn't Cloud SQL just a hosted version of MySQL and PostgreSQL. 
Not sure, but IntelliJ has *Replace 'var' with explicit type* for single occurrances. Since `var` itself is the one doing the type inference, reversing it is trivial, I would imagine
Watch a fifty minute video in order to (maybe) get your joke by the end? No, thanks
Spring Data JPA is just the data access layer. The actual database provider implementation behind it is by default hibernate. With spring data JPA you still need an implementation of JPA running behind it known as a "JPA provider." Cloud SQL is a hosted version of them, but it makes scaling things much easier as you don't have to deploy a bunch of servers, and in some use cases deal with sharding. Before Cloud SQL I'd generally run hazelcast for distributed data with some mysql in the mix. Once you start deploying distributed systems shit gets really complicated, but Cloud SQL really makes it simple. Basically you don't have to do replication, distribution, or figure out which route is best to access a given piece of data with multiple databases. Hazelcast is cool for doing all that, but it's still a huge pain in the ass.
Hm interesting that's good to know. I'm an Eclipse user I wonder if it has a similar feature. If not they should get on that
&gt; there are no currently plans to deprecate Swing There are also absolutely no guarantees to its long-term presence in the JRE either. If the projects you work on are OK with a "nobody is planning to dump this entire toolkit for the next six months" then great buddy but I for one require a little bit more stability when it comes to choosing my tech stack. Most serious corporate-level frameworks have a long-term support (LTS) plans and the fact swing lacks one is a huge tell if you care to look at it critically. Sure, certain Java version have LTS plans to it, but not to swing on the long run. Meanwhile, even JavaFX, which is not backed by a billion-dollar corporation like Oracle anymore, has LTS plans to it. If the fact that you can't say the same for Swing doesn't make you even a little bit nervous, you're a whole lot more optimistic than I am.
Oh, I am certainly nervous. I love Swing, and hope that they will keep it in the platform! If others don’t want/need it, they can use jlink and exclude the java.desktop module.
&gt; use jlink At that point you'd have to be a madman to stick with a GUI toolkit from 1996 over JavaFX. Being part of the core platform is the only read advantage here.
That wouldn’t necessarily make someone a madman. Hell, even IntelliJ uses Swing.
It does, you can add exclusions to your pom build phase with exclude
&gt;no need to start eliminating tools until actual use shows programmers just cannot help themselves and will abuse it. Are you implying that it's fine if Java 13 breaks all code that uses `var`? Honestly, I'm fine with that but you know as well as I do that that's not how Java language development works or is supposed to work
I definitely would consider someone starting a brand project in late 2018 using a graphical toolkit from 1996 an irreparable madman. The fact that that particular technology might come bundled with the language would be the only saving grace here. But I repeat myself.
You can do them in tandem.
That's hilarious. It's a joke, right? Now it has var *and* the explicit type (weirdly after the variable name). Now with even more line length!
Whether var was well thought out, that's another issue separate from this one. How java should evolve so that it can undo mistakes is also another issue. var obviously will not be going away nor should it. However, unless your general opinion is that no java feature should ever be used (unless more adventurous dolts appear to prove otherwise, but in the end, it's a community, so you can't really opt out this way) – this is not an argumente against `var` now.
So you're suggesting fix the 'bug' by breaking the semantics of search?
Unless you have 10000 listeners no. 
I have worked professionally with SWT and I don't see any reason to use SWT over JavaFX. Only exception: if you're building OSGI RCP applications, which is a pretty great framework in itself but then you're stuck with SWT regardless;
&gt; 10x worse performance than Swing Source please.
Apache cordova ?
Sadly it doesn't currently flip the type inference for generics using the diamond operator. So it's a two-step process per line in that case
So your argument is to add it to the language, see how it goes, and if it later proves harmful then say, 'hey, it's already in the language, too late to stop using it'. Not psycho at all
Another option is to put resources in your package structure. Nothing prevents you from doing that.
There are options. If you’re writing in java, then you’ll need to write a separate iOS version. Option 1: Go hybrid. Use something like ionic or phone gap to write once and run anywhere. You essentially write a web app that is rendered using a web view. Performance suffers and the app doesn’t feel like it’s built using native components. Option 2: go semi-native Tools like flutter (written in dart), react native (JavaScript) and xamarin (c#) allow you to write logic once and plug into native components (or write your own. Both flutter and react native transpire to vanilla JavaScript, interacting with native components. You’ll need to provide any components that aren’t included out of the box using native languages. Xamarin is similar, but doesn’t compile down to JavaScript. Option 3: maintain separate native apps. 
Yeah it's great digging into systems like that and being able to identify an issue and make massive improvements.
Swing tends to look like a crappy attempt at a native UI. People are more ready to accept non native UIs than ever before, but they don't want crappy imitations of native. They want something that looks nice and isn't pretending. The UIs that people tend to like are built in electron and the new QT. Javafx is really just as good, or arguably better than electron. And no one will say it's a crappy java UI.
I thought Swing was long dead. Used to love writing Swing code. Loved using a plugin framework.. basically my app was a java app with plugin engine, everything else were plugins. From menus, dialogs, and every feature.. all plugins. Easy to build, easy to extend. Worked awesome. Really miss that style of coding!
&gt;You need to draw the String before you may know how many pixels your String will use. Swing computes string width easily. Have fun computing String widths with UTF8 content. JavaFXs approach is the sane way to deal with it IMHO.
Yes. 
https://stackoverflow.com/questions/44136040/performance-of-javafx-gui-vs-swing
Programming help should go in /r/javahelp. **Removed**
I might write an example of how to do it someday
I used to write SQL Query to get information from 5 tables. I used a lot join and nested query, I also wrote function and procedure. But when I write Java Application, I don't know how to map these query with JPA Query... Oh, could you recommend me some place to learn JPA Query? Thanks in advance!
&gt; argument for findusages Which we are &gt; but plain search Which we are not. 
"Short sighted" here literally means "can't see very far ahead." The psychorigid Java devs panicking about \`var\` can't see the inevitable future where usage is widespread and the sky doesn't fall and everyone quietly realizes \`var\` was actually a good idea. The same cycle of panic and acceptance happened in the C# community. It's a standard threat response to change. People with production experience in languages with local variable type inference already understand that the costs are overstated and outweighed by the benefits either way.
Haha, yeah. I was comparing it to 3D game engines with impressive capabilities. But of course JavaFX's is good enough for this type of 3D visualizations. Do you know if that NASA project uses FXyz3D?
I find &gt; Button okBtn = new Button("OK"); more readable than &gt; var okBtn = new Button("OK"); It lets me see what is what quickly.
Oh, man. I still try to erase my experiences with WPF from my brain. How did you approach JavaFX, though? Going full FXML and CSS?
Wow that looks great! It addresses that one big problem with JavaFX. I'm also glad it's backed by e(fx)clipse guys. Thanks for letting us know! 
Hahaha, no! *quickly deleting MMORPG (17) dir* Of course not!
Citation Needed.
But you don't have to use FXML or CSS at all to build applications in JavaFX.
I'd really appreciate that!
Ha. I actually need to use a plugin system. Do you remember which plugin framework you were using? About JS: I have done web development since Altavista was a popular search engine, up until React days. I think Java with JavaFX or Swing is just better than browser engines, JavaScript and those front-end frameworks (I have used React, Angular, Vue, Backbone, Knockout) in every conceivable way. They perform bad, tooling is terrible and they're changing rapidly.
&gt; "Short sighted" here literally means "can't see very far ahead." Well I was a C# developer for 2.5 years...I've had var in a language before. The things I described are EXACTLY THE THINGS that happened. Bad C# card overusing var is fucking absolutely horrible to go through. It's a major part of why I moved to Java. You talk about it like people have never seen var before. We've seen var before, and the ones that are pissed about it have seen it misused a million times. &gt; outweighed by the benefits either way What benefits? Having to type *slightly less*? I run a decent sized team for one of my clients, and I did so with C#. I banned var from our C# code because people could not stop abusing it. You're *vastly* underestimating the costs *even though I've explained them*. A bad developer writes methods that are like 100 lines. They'll have an absurd amount of local variables because they don't care. They'll use var for every one of them. Great now I don't know what type each local variable is. So then I have to go through line by line sometimes 20-30 times and figure out which type is which. I can't remember 20 types associated with 20 variable names, so now I have to add comments for the important ones. It's a crutch C# devs rest on, and it's now going to be a crutch Java devs rest on. &gt; It's a standard threat response to change. &gt; People with production experience in languages with local variable type inference already understand that the costs are overstated and outweighed by the benefits either way. Jesus Christ could you possibly be any more condescending? You just assume people know less than you or have no experience in something just because they disagree? I have a strong feeling you don't run code review or deal with new 150-300k line codebases every couple of months. You'd be singing a very different tune if you didn't spend all your time on one codebase. A client bringing in a contractor isn't doing it because they have a team of rockstars.
I think that's a good point. Users will spend more time with the application than we do. Just like how residents of a building will have much more experience with it than its architect. Not trying to emulate native UI is important, because you can't really succeed, and even if you can, native UI is just boring.
Options: - [CodeNameOne](http://www.codenameone.com) - [Gluon Mobile](https://gluonhq.com/products/mobile/) - [Multi OS Engine](https://multi-os-engine.org)
When I used it, it was somewhat integrated, not much though. Maybe that doesn't matter? Why should a IDE have "design" capabilities?
Also might be worth looking into [Reactive Extensions](https://github.com/ReactiveX/RxJavaFX) for the JavaFX stuff, Reactive adds a whole new fun level.
Sounds good. I'll give it a shot.
Oh, great. It's all Metal now. Thank you! I think Metal is consistent enough to try pixel-perfect alignment and customizations.
Encourage is a big word... Support.. # Version 7 https://confluence.atlassian.com/jirasoftware/jira-software-7-13-x-release-notes-957981568.html &gt; You can now run Jira on OpenJDK 8. More precisely, we’ve tested Jira against AdoptOpenJDK, so if you want to make sure everything works without fuss, pick this one, too. We’re supporting OpenJDK so you have an extra options to choose, however we’ll continue to bundle Jira with Oracle JDK. You can read more about any requirements in our upgrade notes. # Version 8 https://developer.atlassian.com/blog/2018/11/november-update-upcoming-breaking-changes-across-server-products/ &gt; Jira 8.0 will be working with Oracle JDK 8 and OpenJDK 11. This means that Java 11 features will not be supported in the source code (Java 8 compatibility mode). Hence, we will only announce limited Java 11 support without making Jira officially compatible with Java 11 until a future 8.x release. This will give app vendors time to update their products before we announce official compatibility with Java 11. Most likely, this will take place sometime in Q1 2019. After we announce the official compatibility with Java 11, we will also strive to have OpenJDK 11 bundled with the Jira installer. 
That looks nice. I've been wondering about RxJava for a while. Do you think it's worth it if you're going to build desktop applications and not web apps?
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt; The Swing example flattens the image to 6002 = 360,000 pixels. In contrast, the JavaFX example strokes almost 2.4 million overlapping polygons when finally rendered.
You're referring to an IDE bug? That was quite a context switch :)
Yeah, I could have been more condescending. For example. I could've pointed out how amateurish it sounds to compare local type inference to the dynamic typing in JS when the languages have completely different type systems and type annotations on local variables is about the least relevant distinction between them. I do run code review but the people I accept onto my team don't write intractable 200 line methods with dozens of poorly named variables. Sorry to hear that your career experiences have caused you to treat the addition of basic languages features with fear and hostility.
Yeah, if you can fit what you're trying to do in it, there's not much of a downside of using it.. Especially with modules and the packager so you can actually distribute executables freely. 
May I ask why do you still love Swing when JavaFX is already available?
I mean, Cocoa, Qt, GTK+ all started in early 90's with roots date back to 80's.
&gt; I could've pointed out how amateurish it sounds to compare local type inference to the dynamic typing in JS when the languages have completely different type systems and type annotations on local variables is about the least relevant distinction between them. You didn't read what I said properly. I said the language is moving towards "hide the type". I didn't say was damn thing about dynamic vs static typing. I mentioned one specific aspect I was comparing. I used the *pretty obvious* hyperbole of "what do you want to be nodejs?" The point is it's a step in that direction. &gt;I do run code review but the people I accept onto my team don't write intractable 200 line methods with dozens of poorly named variables. I don't pick the teams who wrote the existing codebase with new clients typically. I don't know how you would do this retroactively since that doesn't make physical sense. I can only recommend firing post de facto. It's rare we get to start from scratch. You apparently don't know how contracted consulting works, so I'm guessing you're a 9-5er. Not talking shit just guessing and I'll explain. When a team is performing poorly or is very behind a company like ours is called in with a team of their own. At a pretty big premium. Some very well known companies do this with various companies to fill staff gaps as well. Generally we either get the project on track, provide prof. enrichment/training, or in extreme cases take over development. Sometimes a combination of them. This is where we do the agonizing code reviews. Reviewing my teams stuff is fine. Once we get called typically a massive amount of man hours has been sunk into the project. So they don't generally let us scrap it. So we end up fixing a codebase with problems like I described. So everytime something that can be easily abused is added the bottom of the quality of code we run into sinks a liiittle deeper. I mean it's whatever I just hated it SO much in C#. I guess with the replace var button in IJ it shouldn't be so bad. I did C# pre 2015 VS did not have that. Even now you have to do by clicking a lightbulb line by line. 
Not at all. Using Java EE! (and very happy with it) :D
We were already talking about an IDE bug. What were you talking about?
It's worth noting that if you take code like this: C fA2C(A a) { return fB2C(fA2B(a)); } and split it into multiple lines, then using `var` is closer to the original: C fA2C(A a) { var b = fA2B(a); return fB2C(b); } compared to say: C fA2C(A a) { B b = fA2B(a); return fB2C(b); } To put it another way, any of criticism that might be levelled at `var` could equally well be levelled at function composition since you can't see the intervening types. Since no-one has ever made such a criticism of function composition, I think the criticisms of `var` are equally baseless.
If I remember correctly, I started this thread with an example of how `var` adds value to using jOOQ. You replied to that with a cryptic comment about some bug.
So it's just not a step in the direction of NodeJS because JS's handling of types is completely different from Java's and "hiding the type" is in no way some defining feature of the language's handling of types. More advanced static type systems are characterised by higher degrees of type inference so in that sense adding more type inference to Java is actually a step closer to the more advanced static type systems of e.g. OCaml which are about as far away from JS as you can get. Virtually all modern static languages support local variable type inference. Even golang has it. One of the main motivations for adding it is to improve general readability as well allow the use of complex static types without large amounts of line noise or inappropriate method chaining. The improvements in legibility can be seen in lukaseders example in this thread and in the examples from this style guide ([https://openjdk.java.net/projects/amber/LVTIstyle.html](https://openjdk.java.net/projects/amber/LVTIstyle.html)). If your job is to rehabilitate giant piles of garbage code then you're going to encounter misuse of every language feature. It's no reason to keep Java in the past.
I think you accidentally commented on the wrong thread then :) The original comment was: &gt; It breaks "find usages" https://youtrack.jetbrains.com/issue/IDEA-188689
The Oracle JDK license change only applies to JDK 11 (and later). The Oracle JDK 8 binary was released (and is still covered by) the Oracle Binary Code License for Java SE. This allows free use *in production* for desktop and servers (embedded and single-purpose devices are covered by the field-of-use restriction). Just to be clear, JDK 8 (as well as 7 and 6) can be used without requiring a Java SE subscription *indefinitely*, just without public updates beyond January 2019 (unless you're a non-commercial user, in which case you will still get updates until the end of 2020). Oracle JDK 11 was released under the Oracle Technology Network Agreement, which does impose the restriction of not being able to use it in production unless you sign up for a Java SE Subscription. I checked this with Oracle PM during the Java Champions briefing before Code One.
Either this reddit is super eventually consistent, or I'm going crazy (or you are), but this is what I'm seeing: https://i.imgur.com/EusoukW.png
Oh wow. Just tried this in a different browser where I'm not logged in. You're right! What the hell??
Could this mean that Oracle might lose control of Java? If IBM takes over control over the JDK they could even control the direction that OpenJDK (or a fork of it) takes, since it's open source. Are there any patents preventing this from happening?
Yeah, I'm seeing https://imgur.com/xGddNpX I have no idea how Reddit is showing you my comment as a parent of yours. A browser extension is doing something weird? the worrying thing is if it's consistently doing it on this comment, what else is it breaking for you?
Yeah formal business app we used fxml, css and Java for wiring. 
... and I was victim of a reddit bug. Your comment was displayed to me at the wrong position... Sorry for the confusion
&gt; Because your code shouldn't be visible from space 😂 
9:00 - 9:40
Oh lol I was expecting some exploit glad it was a joke. I'm a spring+lombok guy but holy shit he had so many annotations haha 
What would be the point?
Well, they just bought Red Hat which maintains some huge Java frameworks such as JBoss and Hibernate. It would increase their presence and influence in the Java world, which is huge. I'm just curious if something like that could really happen, somehow similar to what happened with XFree86 --&gt; [X.org](https://X.org) or OpenOffice --&gt; LibreOffice etc...
I'm not sure if forking Java is really worth the additional influence, it seems to be doing okay under oracle. But if they want to commit more programmers to it, why not, but they could probably just reach an agreement with oracle on getting more influence on the jcp committee
Sure there is performance penalty and if this matters I would not advocate to use a framework. Either way, matter of perspective or not - in a project setting you gotta finally come up with a decision whether to use X or Y. I am quite lost when arguments, which I think make sense, are not taken into account and it's up to politicts/preferences of individual people
I bought the e-book version, and I read it from time to time when going to work.
The project that was presented at Oracle Code One is called the Deep Space Trajectory Explorer and it uses www.fxyz3d.org along with a few other open source libraries. I am the creator of the DSTE and one of the main contributors to Fxyz3D.
For me and my JavaFX projects we felt it more powerful to simply upgrade to OpenJDK and OpenJFX 11. There was some pain migrating the build system. (Went with gradle) There were some quirks but now that the migration is complete we can build our JavaFX apps as module based applications with reduced size distributable runtimes. Thats pretty cool. The stuff Gluon is doing to make the JavaFX community is great. They are in business but they really do care about yhe ecosystem and the developer.
I like how JetBrains products look and feel, I don't feel that "crappy imitation" with them. Native UI can also look crappy like someone did "crappy imitation" using just native UI controls. So I believe it is a matter of how good you can cook UI. So I think we should compare "classic desktop UI" vs. "web-like UI". There are applications where modern approach to UX fits better (the most of consumer apps) however classic desktop UI still fits better for complex applications like IDEs (IMHO) where I really don't like web-like UIs.
That's an impressive work! Probably one of the coolest things made with JavaFX. May I ask how did you implement those 3D paths? I mean, I've seen people draw smooth splines and curves in GLSL, but JavaFX doesn't openly provide low level access to OpenGL.
wow let's get on semantics, "extending enum" - adding value to enum, what was done and was wrong. Only required change was in calculate. Cheers 
What do you think about FXML and CSS in JavaFX? I guess your other projects are also complicated with lots of custom components. I'd love to hear your opinion about how should one approach to highly customized user interfaces.
That is one pathetically weak source you got there buddy. Find me someone who knows how to use `jstat` or a study or at least an article and stop embarrassing yourself.
Sure, but even if it's not used, it's still way slower. 
Yes and by this rate in year 2319 will be fully replaced... Kotlin will vanish by 2200... so learn Perl now. Pretty sure Perl will be still in use in 2400...
not worth
Sorry man, when deciding which tech to use, I use the sources I find. I don't have the time to become an expert in everything. That being said, I have no experience in JavaFX. If you can give me a better source on performance, be my guest. 
That's a grand load of nonsense to justify being lazy. Let me know when it comes back to hit you in the face. Goodbye!
IBM has already had a huge influence on Java. From Eclipse to raw source contributions and steering committees, IBM has worked to make Java what they needed. In recent years, it's become about making Java what they believe the developer community needs.
It looks like in your [submission](https://www.reddit.com/r/java/comments/a56hwe/tomcat_deployment_issue/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You can share youtube videos at some specific point in time [https://youtu.be/wTPGW1PNy\_Y?t=9m](https://youtu.be/wTPGW1PNy_Y?t=9m)
Just because you are using Spring Data JPA it does not mean you cannot use any other framework. There are projects using JOOQ and JPA at the same time. There are cases were you just require CRUD and other times very expensive native queries which would be a pain with JPA
&gt; Damn this thread started a complete shit-storm, I knew it would... hehehe There's a pretty vocal incredibly conservative group that acts like this whenever something new is introduced to the language. You saw the exact same discussions when the lambda syntax was introduced with Java 8. That is was 'unclear' or caused a 'maintenance hell' or whatever. By now everyone but the most stuck-in-their-ways devs have adopted and they'll do the same with var. We've been migrating microservices to Java 10 for a while and most devs here switched to using var in places it makes sense. 
Swing runs anywhere jdk does. jfx doesn't have aarch64 or ppc. It isn't "write once run anywhere" 
The whole video is worth watching.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Your talk was great, though I missed it as I went to [DROP DATABASE](https://www.youtube.com/watch?v=QR0hK7rqkGM) :P 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I thought this project was pretty cool, so I wanted to share it. It generates Javalin source-code from annotations, which means you can use Javalin almost like Micronaut. DInject generates source code where Micronaut generates bytecode, so it's pretty easy to debug.
When I was doing swing I hated all the GUI builders I had as they seemed to either crash or explode as you dragged things around. I would be all in code with mig layout and a piece of paper next to me that had a ton of boxes drawn on it until I got something right. Then I would basically compile about a hundred times an hour trying to bump this thing to the left, increase the margin here, and this isn't aligning right, how about if I do this, what about this? With an actual working GUI builder that won't explode when you change things, it's nice to see the results immediately. I really have to look at it to know if its right. A lot of times I end up just editing the XML once I've broadly dragged things out. Though I like also being able to see the results with some accuracy without compiling and bringing the screen up in the program so I can keep tweaking things until it looks good. I guess I've always been frustrated with any java gui building tools I've used over the years. I feel like making a screen is a visual process and the design of it should be mostly visible. I think scene builder stand alone for javafx and the android studio editor (for android) are 'decent' and get the job done pretty well without too much headache. 
Can't blame you. Jarek is great :)
The posted system was in violation of the O/C principle. The suggested system would be in violation of the S principle if the tax rules grow more realistic (but was not as it was posted). Those two are often in conflict with each other and a design being SOLID does not mean that it is good. Personally I think Person should have a calculateTax method which delegates to a separate TaxCalculator. That way all the taxation logic is in one place while Person still gets to hide its implementation details (Person passes whatever data TaxCalculator needs when calling it). I also think gender should be defined statically inside the TaxCalculator to discourage it being reused elsewhere. Person can map between its view of gender and the TaxCalculators, e.g. a person might have identified themself as MtF when signing up for a service but the taxation laws have a different view of what is a valid gender. Defininately agree that the actual tax logic can't be inside Person though. If you need to deal with retroactive payments it gets even hairer as you need to keep old tax tables around and be able to use them.
The SQL guy is handed a hyper-complex, painstakingly designed database tightly coupled to his language and the Java guy is told 'fuck you, make your own'. I never once saw him mention JDBC. Maybe because it's a sales pitch.
'psycho'? That's some colourful verbiage. I'm not oracle. I had zero influence on the 'var' discussion. If you had argued against its inclusion on the appropriate mailing list, more power to you. But that discussion has been held and is now over. If you wanted to hold such discussions I recommend you follow the xxx-dev mailing lists oracle hosts.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
At this point it seems like it's JAX-RS, more or less. Why reinvent?
I'm not the author, but the 'tagline' on the website is: &gt; No reflection, no classpath scanning, no dynamic proxies APT based - generates source code for DI He also expanded on this on the Javalin tracker: &gt; I have used JAX-RS and Spring / Springboot a lot over the years. What I've seen recently is that the techniques used by those frameworks with lots of classpath scanning, reflection, dynamic proxies etc is far too slow and expensive for the world of cloud, kubernetes &amp; microservices etc where fast startup and the ability to run with low resource allocation is important (the same stuff the micronaut folks talk about). There are some comparisons on the main page: https://dinject.io/ For me this is a new approach, and I like it. I'm obviously biased since it's targeting Javalin, but it seems better to generate source code than to generate bytecode.
That's cool. I like the compile time DI, it's probably pretty quick!
I did argue against its inclusion before Java 11 LTS was released (and even before 10, I believe). Why they made primitives replaceable with `var` I'll never understand. If there's a silver lining, it's that retards will now more readily reveals themselves to me by writing nonsense like `for(var i = 0; i &lt; 10; i++)`, and I can avoid them. Retardation can often remain hidden until it's too late and the damage has been done
 &gt; Other languages that support var and local variable type inference have seen its widespread adoption and practice in almost all contexts where it is permitted. Unlike Java which is not used for anything, I guess... &gt; The programmers whinging about `var` hurting readability are short sighted and I seriously question the breadth of their programming experience outside of Java. And I seriously question your ability to judge a language based on maintainability of large projects.
yes, I did not mention it but I was thinking of SWT combined with RCP.
Why should an "integrated" "development" "environment" be able to do all the things I want to do during development? I think that's largely self-evident from the name? Being said, there *is* value to using the right tool for the job, even if it's not integrated. But still... I subjectively don't like Scene builder, and I like netbeans and matisse. *shrug*
I've just never been a fan. I can do all that I need with Swing. It can do more than people often realize.
It still isn't going to work. Every platform has its own font rendering, and there are lots of cases where the different platforms are divergent from one another. Even cases where the same OS will have slightly different rendered font sizes/pixels/etc [eg hidpi vs classic 72dpi on windows, or retina on OSX] In the end, you *can* make sure of a lot of things by programmatically reaching in and using [FontMetrics](https://docs.oracle.com/javase/7/docs/api/java/awt/FontMetrics.html) to adjust stuff to match what you want, but I promise this isn't worth your effort, and you'll still eventually fail. Examples off the top of my head, that you won't/can't test for, that will break your GUI: * when someone runs in VNC on Linux, because it's a *really* old X server. * forwarding X from Linux to Windows * when you're on a machine with JDK7 or 8 and both a highdpi screen and a non-dpi screen [eg a MS Surface plugged into a projector] * someone doesn't have all the fonts installed because it's a minimal Linux server * they've applied [a windows highdpi compatability fix](https://stackoverflow.com/questions/30555401/java-disable-dpi-aware-not-working) * New windows version comes out that your harcoded font no longer exists on, and windows replaces it with ms-future-ariel * Runs your code on the JVM that comes with a "special" LAF in OSX10.4 rather than one from Sun/Oracle In my experience, the best way to do stuff cross-platform is to largely concede defeat on pixel-perfect layout, and just make stuff that looks fine even if any given piece of text/button/etc is plus or minus a handful of pixels. Oh, and don't forget: In the end, your users are going to complain about how archaic the Metal LAF is, or how it doesn't match their platform LAF, or how the tabs are unusuable because they don't have the fine motor control needed to click a tab that's half the size of the tab in their normal desktop environment.
It's also interesting: both talks come are based on the same conclusion that the JPA / ORM approach is not always the right one. The solution is then quite different and cover two usecases: * The flexibility and minimal boilerplate of native queries / JOOQ and similar. The DB knows best on how to optimize performance. * Journals that make change management and recovery transparent, sometimes easier
&gt;Unlike Java which is not used for anything, I guess... .. Give that sentence you quoted another read. The point isn't that Java isn't widely used. It's that the static languages that have had LVTI added have seen it used widely and successfully. Claims of the sky falling from type inference have already been disproven. The debate was over before the JEP was even written. As the JEP itself points out: &gt;Nearly all other popular statically typed "curly-brace" languages, both on the JVM and off, already support some form of local-variable type inference: C++ (auto), C# (var), Scala (var/val), Go (declaration with :=). Java is nearly the only popular statically typed language that has not embraced local-variable type inference; at this point, this should no longer be a controversial feature. Detractors of new and inevitable language features (e.g. lambdas) are constantly ass-pulling about maintainability issues. Guess what: most professional developers are working on large projects. You're not some special snowflake with a unique insight into maintainability. You'll be better off personally and professionally if you adapt to the change and try to understand why it's happening.
&gt; everyone quietly realizes `var` was actually a good idea. It's reason number two why I avoid JavsScript as much as possible.
These arguments are all pretty ill-thought out given that so many other languages have had success with RSL. 
&gt; People who have to resort to personal insults You called him a troll, pot/kettle?
`var` detractors literally think LVTI is like JavaScript. I am begging you guys, please just learn some basic concepts around type systems.
There are other delimiters mentioned in the [JEP](https://openjdk.java.net/jeps/326), so we’ll see what happens.
And guess what system has a really well designed journal? The RDBM-System.
No! I need RSLs! SO BADLY! Doing regexes in Java is an absolute pain... There is nothing wrong with the backtick method. Plenty of other languages use it perfectly well. I highly doubt that there would ever be another use for \` in Java.
this is great news. RSLs will be cool when they're ready, but a half-baked preview (that all impls are required to mirror) is to the detriment of the language this also sets a high bar for future preview classes, which should be reassuring to the ecosystem props to brian for biting the bullet on this. and to oracle as a whole for not abusing the preview mechanism (which has the risk of giving them a lot of leverage over competitors) 
[me thinks](https://memecrunch.com/meme/BZYD6/noooo/image.gif)
Still glad that it's moving forward. I want them in the language bad, and it sucks it's taken this long. Like it says at the end though, at least missing this release train is only a small delay unlike the old days.
My thought as well! He’s always been against adding half-baked features to the language. And as he states, with the new release cadence it will just jump on the next train when it is truly ready.
&gt;There's a pretty vocal incredibly conservative group that acts like this whenever something new is introduced to the language. Worth noting that whenever I actually meet or work with this type of dev they are never particularly smart or capable. They are almost always bitter, mediocre burnouts who have done the same type of grunt work for two decades straight and their modus operandi is to blame everyone and everything around them for their own frustrations and shortcomings.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I love Lombok. Or, well, specific parts of it. I mostly use it for the incredibly convenient `@Getter` and `@Setter` annotations, plus `@FieldDefaults` and the annotations that make default constructors from the fields. Additionally, it provides the `@Value` annotation which seems to be the main purpose for Immutables and Autovalue (tbh I had never heard of either of those before reading your post). I have shied away from using heavily experimental stuff like `@ExtensionMethod` though, as 1) it does not work properly on my IDE and 2) the semantics of which method is being used are a little janky. Overall, I really love Lombok because it saves me from having to write *so much boilerplate.* I only wish it was easier to add your own annotations to it.
Why would Ronaldo like to shoot penalties :)......cause he is great at it........i think you got the reason 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I use var mostly when either the type is a generic and thus is very long to type out, or in initializers when doing something like `var cat = new Cat()`, where the type of `cat` is obvious. I never use var for primitive types though. var is especially useful when doing the for-each syntax, like `for(var element : list)` as I already know what the type of element is.
I would use more than one letter in your example for class names, it looks like you are making a point about generics. I think your point makes sense.
Noob here! How has the adoption of OpenJDK been compared to Oracles JDK ? What are some if any advantages of OpenJDK ?
Do you usually write a performance test in every technology you ever plan to use? It's fine to stand in the shoulders of giants.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Terrific. Maybe there's hope of getting a concise syntax for string interpolation after all.
Seems like a lot of work, given that the reward is a longer way of writing: String result = StringUtils.capitalize(StringUtils.stripAccents(string.toLowerCase())); or with static imports: String result = capitalize(stripAccents(string.toLowerCase())); 
In more expressive language this is called thrush https://codepen.io/Universalist/post/thrush-combinator-in-racket Or am I missing something?
Having professional and hobby experience with RCP, I wouldn't use it again, personally. There's a plethora of technologies that allow you to be vastly more expressive and efficient nowadays, even if those technologies themselves aren't perfect (sadly, nothing ever is).... Anything from Electron to JavaFX can outperform RCP in terms of development time and resulting package. I would only go RCP if you have an intrinsic need for a plugin-based rich-client architecture but that's a very specific use-case and definitely not the general scenario.
I agree with the concerns that Brian shared. A little more time dedicated to making sure we get the absolute best approach is ideal. I am glad we are having a delay.
You can also (ab)use Optional to provide map(Function) String result = Optional.of(string).map(String::toLowerCase).map(StringUtils::stripAccents).map(StringUtils::capitalize).get();
Thanks for sharing your experience.
Honestly from a quick read it seemed like an excessive fix for what is usually a fairly basic problem. And what do you do if you really do want a new line in the middle of a string?
If you want a newline in the middle, you would just go to a newline: ``` String x = `Hello World`; ```
It's important that something be recognizable as a string and also to not excessively limit what can be a legal part of a string. 
Do other languages actually have RSL tho? Heredocs, multiline strings - sure. But RAW strings literals? Which from memory ( haven't read the latest JEP for any changes ) Java's approach is to turn off all unicode interpretation, which is a bit more... well - raw.
&gt; Or am I missing something? Yes, the part where this is a Java forum and we're discussing Java.
It looks like in your [submission](https://www.reddit.com/r/java/comments/a5aw05/how_do_i_format_a_table_of_information_in_java/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Also, I had any old teacher look at this and he told me that my Value (R) was correct but didn't really have time to help me debug. Thank you.
Are they still planning it for a future release? I didn’t see that
The grand kids are going to have to go to the hospital for that burn...
You seem to touch a broader issue, namely whether it's worth to have even `String.transform` at all. IMO it is because of readability (static imports or not, the order of applying the operations is opposite to the order in which they occur in code). I definitely agree with you that a pipe-forward operator or some other mechanism (e.g. Kotlin has the [let](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/let.html) extension function) would be a much better solution. Unfortunately, it doesn't seem Java will have them in the near future, and the code has to get written, so I tried to show what can be done now :)
&gt; the code has to get written Why? This offers nothing that can't be expressed in fewer characters and with fewer function calls.
Seems no less crazy...
Yes, you can, but the main problem with using `Optional` is that the final `get()` earns a warning in IntelliJ (and perhaps other IDEs) that you're calling `get()` without having called `isPresent()`. Besides, the [original motivation](http://mail.openjdk.java.net/pipermail/core-libs-dev/2018-September/055552.html) for `String.transform` was to allow custom manipulation of raw string literals, e.g.: String string = `&lt;table&gt; &lt;tr&gt; &lt;td&gt;Cell&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;`.transform(MyStrings::performMyOperation); So it's all about clear separation of the raw string and the post-processing operation on it. With `Optional.of(` at the beginning, this wouldn't look so nice.
&gt; - We have relatively few unused punctuation characters left, and using backquote for RSLs may be excessively profligate. Further, using another quote character for raw string literals (rather than a prefix, modifier, embedded sequence, or similar mechanism) leaves us in a tight spot if we discover the need for a third kind of string literal. We've not sufficiently explored alternatives that would let us avoid burning one of the few remaining characters we have. Good. This area of the JEP was particularly -- and uncharacteristically -- weak; and I personally think Rust has a _much_ better syntax.
Nice, thanks! I haven't heard about "thrush" before. Yes, that's exactly what this entire ceremony in my post is about :) As I mentioned in an earlier comment, I tried to show what can be done in current Java in order to achieve this "thrush combination"/"pipeline" behavior in a subtype hierarchy.
Yeah just read through it again, towards the bottom. When they said pulling from jdk12, they just meant for that release, and trying to get it in the jdk13 release when some of these issues are taken care of.
Because I believe fewer characters and fewer function calls are not the best metrics when it comes to readability. For me, the "mental price" of reading code in reverse order (for n &gt;= 3 operations) is definitely higher than that of reading longer, well-structured code in natural order.
That sort of thing does get thought about internally a lot, but since there is a six month release cycle it probably won’t come out until after the basic RSLs are done. Also features like string interpolation often don’t provide much on their own without other features also being in place. I’m not sure how much of a benefit you’d see without better compile time constant handling, for example.
You should read his post history.
String escaping can make regular expressions very hard to read. Now I’ll admitJava’s regexp API isn’t nice at the moment, but if you’re starting to add pattern matching to the language then regexps seem like a useful sort of pattern match on strings, so it’s worth picking away at everything that currently makes them painful.
It's free for production use. You have to license Oracle's version.
I actually like the javalin part more as there is quite a bit compile time DI frameworks ( toothpick and other alternatives mentioned at the end of the page: [https://github.com/stephanenicolas/toothpick](https://github.com/stephanenicolas/toothpick))
&gt; Woow, I didn't think there would be so much hate against 'var' in the java community. That's not [what you said earlier](https://www.reddit.com/r/java/comments/a4tjwk/what_is_your_total_and_complete_honest_opinion_of/ebi49g1/).
BTW, preview features, like all projects in development, are in their respective OpenJDK repos, available for anyone to build.
Oh okay 👌🏼 
It's very much a needed feature if you're embedding another language inside Java. SQL is an obvious example.
Regex works fine in IntelliJ. Besides language injection, [you have the regex checker which lets you edit the raw regex.](https://i.imgur.com/P1OwYfH.png) Not such a big inconvenience, and if I'm working with a big regex, I usually use http://regex101.com/ anyways.
You've reimplemented `Comparator`. https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Comparator.html 
&gt; learn some basic concepts around type systems Insult. Welcome to my block list.
 String str = "test"; str = str.toLowerCase(); str = StringUtils.stripAccents(str); str = StringUtils.capitalize(str); ? It's longer and in natural order. Being fancy for the sake of being fancy is probably a bad idea. 
This is off-topic, but I agree with you, the &lt;JS-library&gt;Native only works well (in my experience) on fairly simple things, when you have to edit the wrapper for the native build, strange things can happen. That being said, if you do have to use a JS library, I totally recommend using Hyperapp. So simple it's shocking it works so well.
Not sure what you're trying to say. Java already has pattern matching doesn't it?
i was talking about non-openjdk-based java implementations (my understanding is that preview features are required, though admittedly the license terms are beyond my full grasp)
Youtube and codcademy helped me the most. Checkout thenewboston on youtube and follow his tutorials they're really good. 
It depends what you mean by pattern matching. On regular expressions? Yes. The "test and destructure" definition is coming soon. See [JEP 305](https://openjdk.java.net/jeps/305).
Do not go to thenewboston. It's real bad. You will never learn to code by sitting passively watching videos. You need to write code. A lot. I have had great success with Head First Java. Follow the instruction to the letter. Do all exercises and problems. This will get you crawling. Now read Effective Java. This will get you walking. Now start to write a lot of code. Become expert in your IDE of choice. 
Thank you!
The definitive place to go is [Oracle's own Java tutorials](https://docs.oracle.com/javase/tutorial/). They're excellent. 
www.javapassion.com The best site imho to learn java, jee, spring, etc
mooc.fi is really good. They have their own custom version of Netbeans which downloads and checks exercises with a couple of clicks.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
They already have massive control fromEclipse and now from Red Hat. This is not something to worry about. I hope
Google?
You should seriously try JavaFX instead for building games. Here's an example I wrote initially in 2014: https://github.com/brunoborges/fx2048
Back in 2014 I backported one of the many 2048 game implementations (in javascript) to JavaFX. https://github.com/brunoborges/fx2048 Code has been recently updated to use Java 11 features, although it was working just fine as well without changes in the code. It was originally written to run on Java 8. Check readme and tags for details. Binaries are available for Windows, Mac, and Linux, using custom Java 11 JVMs (jlink). Pretty neat.
Oh... ICYMI: https://www.reddit.com/r/java/comments/a4v63o/javafx_vs_swing_in_2019/ebm0j5q/
I have heard a lot of good things about javaFX, im currently working on something thats already using swing but the next one will definatky be with javaFX!
Nope, you got me there.
Spring
Not applets, but you should try to get an A.
Oracle's tutorials are, by far, the best place to learn. However, it's boring to read dozens of pages without writing anything, and imo, writing is the most effective way to learn. That's why I find codingame interesting too. It's funny and will let you practice Java (or any other language) with increasingly difficult puzzles, that will teach you how to solve the same problems a dev does everyday. Plus : these puzzles are the same kind that those you are likely to be asked to solve for a job interview.
The problem with this code is that it introduces an extra local variable, and a mutable one to that. For me, it's an obstacle in terms of readability. I believe functional programming concepts (like immutability) are gaining traction for a reason. Besides, I'm not sure if you're discussing the point of `String.transform` (as proposed by OpenJDK), or the point of `CharSequence.transformed().by()` (as proposed by me, with a grain of salt to that). If it's the latter, please note the [summary](https://blog.tlinkowski.pl/2018/transformer-pattern/#summary): &gt;I realize that `Transformable` is probably too “extravagant” to actually make it into JDK. Actually, even `Transformer` alone being returned by `CharSequence` and `String` isn’t probably worth it. It’s because unary operations over `CharSequence`s don’t seem so common. In case you thought I'd proposed `String.transformed().by()`, please note [this sentence](https://blog.tlinkowski.pl/2018/transformer-pattern/#usage-in-context): &gt;The usage for `String` would not change because there’s no point in calling `transformed().by()` over `transform()`.
Brian won't let me have my Elvis operator and now I can't have multi-line strings?! :(
You will get raw `String`s, just not in Java 12.
Strings are always immutable, so I'm not seeing how it's an issue. Sure, you can *reassign* the variable, but the caller could also just copy/modify the String. Even if they reassigned it, no other code depends on it since it's the product of a utility function. There isn't really anything lost. &gt;Besides, I'm not sure if you're discussing the point of String.transform (as proposed by OpenJDK), or the point of CharSequence.transformed().by() (as proposed by me, with a grain of salt to that). If it's the latter, please note the summary Both, really. There isn't any point to either, they just add extra complexity where none is needed. It'ls like putting a bow tie on a cheap gift.
Head over to /r/learnjava and look at the sidebar: &gt;**Free Tutorials** * MOOC [Object Oriented Programming with Java](http://mooc.fi/english.html) from the University of Helsinki * [Java for Complete Beginners](https://www.udemy.com/java-tutorial) * accompanying site [CaveOfProgramming](http://caveofprogramming.com) * [Derek Banas' Java Playlist](https://www.youtube.com/playlist?list=PLE7E8B7F4856C9B19) * accompanying site [NewThinkTank](http://newthinktank.com/)
This subreddit is not for programming help. That should go in /r/javahelp. Still, you don't show any effort that you have spent. So you will not get much help over there either.
Thanks for the link. I don't understand the reference to "optional types". To me the Elvis operator is just shorthand for a ternary operator that's already a part of the language.
IBM can fork it and add their own extensions, but they can't call the result Java, which is trademarked by Oracle. Only implementations that pass Oracle's test suite can be called Java. So, Oracle is unlikely to lose control. There is a vehicle for exerting influence, which is the Java Community Process (JCP), where IBM and Red Hat are both active, as are other contributors. The process is collaborative and open--most of the back and forth is done on the mailing lists. 
What do you mean if you really do want a newline in the string? You just put it in, that's how a raw literal works, it includes it.
Yeah, not really, but I see why you would think that :) It was build manly for the scenario where you have 2 collections of different objects and you want to find differences (added, removed, updated...). First you need to match objects together (for that you need `keyExtractor` functions) and then compare matched objects (that's where `equalities` and `equalityPairs` are useful, you can for instance compare objects only by a few fields just by listing them - sort of). I see however that in most cases, Comparator would suffice. Thanks for the feedback though!
Woah, cool. Would you mind to share some data?
Not to be a dick, but to be a dick--can you explain? Heap sizes of terabytes aren't terribly ordinary so if ZGC is that amazing, any kind of tech guide/explanation is hugely helpful with regards to why we should be hyped as well.
The [OpenJDK ZGC](https://wiki.openjdk.java.net/display/zgc/Main) page provides this description: &gt; The **Z Garbage Collector**, also known as **ZGC**, is a scalable low latency garbage collector designed to meet the following goals: &gt; &gt;` `Pause times **do not** exceed **10ms** &gt;` `Pause times **do not** increase with the heap or live-set size &gt;` `Handle heaps ranging from a **few hundred megabytes** to **multi terabytes** in size &gt; &gt;At a glance, ZGC is: &gt; &gt;` `Concurrent &gt;` `Region-based &gt;` `Compacting &gt;` `NUMA-aware &gt;` `Using colored pointers &gt;` `Using load barriers &gt; &gt; At its core, ZGC is a **concurrent** garbage collector, meaning all heavy lifting work is done while **Java threads** continue to execute. This greatly limits the impact garbage collection will have on your application's response time. [This](https://www.opsian.com/blog/javas-new-zgc-is-very-exciting/) article is decent introduction to the ZGC. 
If IBM and Google wanted to take care of Java they could buy Sun. They were just watching Sun dying.
Have you tried shenandoah?
[removed]
ZGC sounds pretty cool, but like, sliced bread is off the damn charts
ZGC is fast, doesn't have any identifiable pause-times, it seems to be seemless. I used to spend a lot of time tuning GCs for our large heaps, but I don't have to. It also has a lot of speed improvements with smaller heaps that have a lot of short-living small objects. All in all, I don't have to worry about the GC anymore.
Will share them after I do some proper tests. This is from the experience over the last few months. We works with a LOT of data, and GC tuning was always a must, but after switching to ZGC, we don't really care about the GC anymore.
Yes, we evaluated shenandoah, but for our very large heaps, ZGC seems to work better. Will post number once I get time to do tests.
Looking great! I always find games made with JavaFX interesting, because it shows JavaFX is such a powerful tool, useful for both games and standard applications. I hope Gluon Mobile will also take off. I'd love to use JavaFX for mobile development too, although I hear good things about Flutter. May I ask which Java 11 features you benefit from, besides jlink and type inference?
Eerrr.... Only those :-)
Note that you trade peak performance for this. The GC barriers are more expensive in ZGC. So for smaller heap sizes g1 is still the best choice.
webrev: http://cr.openjdk.java.net/~afarley/8215217/webrev/
Out of curiosity, how much ram do you have on the machine?
Very true, but for our use cases, which is churning through an enormous amount of data, and having a constantly changing code base, ZGC is ideal.
Our research machines have around 4-8TiB of RAM each.
\`damn\` is considered a \*bad\* swearword? I can (somewhat) understand removing sexual language or unreasonably harsh critique, but \`damn\`? Damn!
Fuck raw string literals. I just want to get rid of those darn swear words.
Hehe. They're more than enough. :) What do you think about Gluon Mobile or javafxports?
OMG. He went full retard here, and fixed somewhat external dependencies, like JQuery, making an update of JavaDoc tooling harder. 
That's great your company found the true path. Most of us aren't that lucky. :) How do you compare the performance of your new JavaFX app to the previous Electron version?
Wait til they start censoring 'blacklist' or 'master-slave'.
\`\` is empty string \`"asdf\`asdf"\` is string containing \` \`""asdf"\`asdf""\` is string containing "\`
ZGC is limited to 4TB and you are already reaching that limit. Is that an issue for you? 
I'm curious about SoftChannel.java, was `// Bitch Bend sensitivity` a typo, or an intentional joke?
Well, that’s a lack of focus.
Some of these are really funny. How do you even misspell "Pitch" as "Bitch"? I also like "Calamity! q is too big."
&gt; hb-private.hh's "Common Region for Access Protection" type, whose acronym is used in several places both inside that file, and other files. (No doubt the author is very pleased with themselves.) Bless this person's heart. I don't know who the person that wrote this is, but they must be gosh darn AWESOME to work with. I mean, shucks, Apache POI is an acronym for _Poor Obfuscation Implementation_. Is that too offensive? Someone needs to grab this guy/gal by the shirt, and smack them on the nose with a rolled up newspaper and say... "_No! Now go to your room and think about what you've done._" Keep your PC culture out of my dev environment. Half the fun of reading code is swearing about how stupid something someone else (usually past me) has written.
Language!
You gotta file a bug for me to fix that.
&gt; damn is considered a bad swearword? I can understand removing sexual language, obscenity, f-bombs, or unreasonably harsh critique, but damn? People whoget upset about swear words are typically religious, and "damn" is a pretty big thing if you take its religious meaning seriously.
We need a swear jar
I'm not sure how to answer this, I was the Sr. developer who killed the JS version but it was due to development costs. &amp;#x200B; for performance, I think the java native build loads and works a lot more smoothly for my team mates, they're using Windows and Mac. On both systems, everything looks exactly the same, loads at the same speed and also auto updates. &amp;#x200B; for development: javafx hands down. layout is dead simple. &amp;#x200B; I have so much I could say, but here's our thoughts for switching: &amp;#x200B; I put some of our pros and cons below: (simple pros/cons for js) Pros for js: We could iterate quickly we had the entirety of npm at our fingertips Cons for js: we had all of npm at our fingertips we had a wrapper to work with html layouts are a pain sometimes. updates area pain installers are a pain &amp;#x200B; With TornadoFx (with fxlauncher): Pros: ease of development, no wrapper, all one language updates are seamless, install once, update forever layouts are set up very well in the javafx api javafx charts are great for basic charts and fully extension able Cons: Compile time Some javafx things are hard to style by css
I'd consider them all unprofessional. My sensibilities aren't offended but I think we can do better as professionals making something that is seen and used by many people. It also sets the tone for what people expect in a large scale project like this. 
Then it shouldn't be an issue if whatever is *damned* is not a person or group of people, or if it is used without a target at all. I'm pretty sure that checked exceptions do not got to hell, and cannot feel offended, even if they should.
Why not put this method on \`Object\`?
„Mom! Get the Camera, i‘m improving open source!“
What kind of applications/contexts need heap sizes of several terabytes ?
I see what you did there
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
If it is, Zing (full disclosure, I work for Azul) scales to 8Tb of heap.
Maybe he should take a stab at the linux kernel source. ;)
Even though I agree when it comes to swear words in code, but I wouldn't support this request. Well, removing swears words in comments can be done at any time while refactoring, but renaming the whole package because it's "crap" is pathetic. Sorry dude who opened that bug, but you should get some work or strengthen your focus.. 
Using the term retard as a pejorative is despicable.
Included herein is my proposed changeset to address this unacceptable situation: &gt; -~~retarded~~ &gt; &gt; +fuckwad
Fuck you! I want my god dam string literals
That's correct. ZGC is currently limited to 4TB of heap. However, it's an artificial limitation. By changing a constant ([ZPlatformAddressOffsetBits](http://hg.openjdk.java.net/jdk/jdk/file/24525070d934/src/hotspot/os_cpu/linux_x86/gc/z/zGlobals_linux_x86.hpp) from 42 to 44) and recompiling the JVM you can go to 16TB. 16TB is the current hard limit. The underlying problem is that we're running out of address space to play with. There are various ways to raise this hard limit, but it requires a bit more work than just changing a constant.
You can never have too many swear words.
&gt;Only a matter of time until `darn` is also considered offensive. and then how will I get my socks fixed?
Why is that? I thought we made up new words to describe that so I though retard was fair play again... It's not like he said the guy was developmentally disabled...
http://cr.openjdk.java.net/~afarley/8215217/webrev/src/java.desktop/macosx/classes/com/apple/laf/AquaLookAndFeel.java.cdiff.html changed from `crappy` to `poor`. Excuse me, what about the poor people? I beg we don't start playing this game....it can only go downhill, literally.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Yes, I understand the problem. For Zing to go beyond 8Tb we need more bits from the object header. It's odd to think that to address an additional 8Tb of heap all we need is a single bit :-)
What the fork?! 
#enumslivesmatter
The point is how does '\n' work if no evaluation happens? Do I have to somehow copy and paste an invisible non-printing character?
Wait . . . so you're saying that getting rid of the naughty words in the source code won't help the end user's experience of products built on Java technologies? ALL LIABILITY IS EXPRESSLY DISCLAIMED FOR PERSONAL INJURY OR DEATH RESULTING FROM READING THE SOURCE CODE. &amp;#x200B;
You just put in a newline, the string can span multiple lines.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
First Church of the SJW?
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Well done, android. The Enrichment Center once again reminds you that android hell is a real place where you will be sent at the first sign of defiance.
Store everything in / because hierarchy is bad.
I know naming things is hard, but: ``` PostgresqlConnectionFactory connFactory = new PostgresqlConnectionFactory(PostgresqlConnectionFactory.builder()...); ``` It's a petty and pedantic critique, but I must... The connection factory constructor accepts a connection factory?
I could see an argument for comments being addressed in code review or pre-release. There are a lot more things legally or professionally damning than `damn`, like “ganked this from stackoverflow.com/...” or “big customer demanded this. It is stupid but don’t remove it.” Cuss words are just easier to `grep` than criticisms or complex risky comments. At the same time, if a module is written by someone in his or her garage while they were doing bong rips, for a personal project and was kind enough to share, doesn’t the language accurately represent the developer? To me, I’m more concerned about unprofessional code masking itself as professional code, so anything that gives me context to the mind and goals of the OD is more helpful than anything.
Should rather be `PostgresqlConnectionConfiguration`. That fixed now.
that makes more sense :)
＞ To me, I’m more concerned about unprofessional code masking itself as professional code, so anything that gives me context to the mind and goals of the OD is more helpful than anything. Completely agree, just don't hide the information into a thick layer of it, and obviously don't abuse it, but anything conveying the creator's mindset and eventual frustration while tackling the issue is good to know (and if it's entertaining on top of it, even better).
&gt; So for smaller heap sizes g1 is still the best choice. What would you use for a "web app"? Say a Spring boot service that is not heavy on computation, running on a 1GB VM, CMS or G1? I ran some simple tests and golang takes up about 8-10 MBs, and ASP.NET core about 150MB. Say I specify `-Xmx500MB`.
"8TB ought to be enough for anybody."
&gt;However, it's an artificial limitation. By changing a constant ( &gt; &gt;ZPlatformAddressOffsetBits &gt; &gt; from 42 to 44) and recompiling t That's the nature of multiplying by two.
It's audio code. [Pitch bend](https://en.wikipedia.org/wiki/Pitch_wheel) is a real thing. It certainly reads like a typo.
Renaming old concepts isn't useful to anyone :P
Looks like a political stunt if I've ever seen one.
What do you mean by chats? Chat applications?
Yes. I guess you do remember all of those Java chat applets that basically used to be all the rage at one point, yes? Gotta say, I had lots of fun chatting back then. But considering all the issues Java has, it's not too surprising really that most chats are on-site now or if they really can't host it themselves, redirect you towards either a dedicated IRC site or Discord. Usually though, that's all what I used Java for as Flash was essentially the king even back then.
Java is still king on the server side. People just transitioned to web interfaces from applets and such. And what do you mean by issues?
either the dropped the /s, or somebody's feelings got hurt. Which is interestingly what everyone is this guy that wrote the defect crap about. Could also just be virtue-signaling. 
rejected: _sticks and stones may break my bones, but words will never hurt me_
Security issues mainly. And yes, I was talking about using Java for applets. Of course I understand the other, possibly useful features it has. But for me, Java was for applets and nothing else.
Yeah, it’s main use today is for server side business logic. It is secure there! You could use Swing to create a desktop application, but applets aren’t found much anymore.
&gt; Care about response time? ZGC or G1GC depending on how much of a performance hit you want to take or how big your heap is and the overhead you care about. &gt; Which results in a larger performance hit? G1 or ZGC? And if you're writing a CRUD web app on a 500MB-1GB VM, would you go with G1/ZGC or Parallel?
Generally, the lower the latency targets, the more overhead. ZGC will have the largest negative impact on throughput with stellar pause times. As for the case you listed, with that small of a heap I'd go with the parallel collector (assuming a multi CPU setup).
`// wretched checked exceptions...`
Why is 16TB (44 bit) the hard limit if ZMQ *only* uses 4 bits for pointer coloring? Shouldn't this leave 60 bits to be used for addressing? Or is the JVM also using some of these bits?
Applets have been deprecated for several years and were removed completely from recent versions of Java, so no they shouldn't.
What a stupid fucking patch. A god damn waste of time.
You asked me this in a different thread, but I'll answer here as well. It depends a lot on the rest of the VM. If you only have 1 core on the VM, the serial collector. Otherwise for this small of a heap the parallel collector will be fastest with the lowest pause time. - CMS should never be used with new java. - G1 should be used for heaps &gt; 6gb approximately. - ZGC should be used for larger heaps or applications that are super sensitive to pause time. It is a good choice for webapps with large heaps.
now-a-days with javascript it would be way easier to write a chat app using that than a java applet
True. As long as you have the skills for it at least.
Depends on your requirements.. as always
So close to a much better email signature: &gt;Adam Farley &gt; &gt;IBM Funtimes
A.I. for example requires tons; image recognition, training, etc
Basic website providing user interaction
Mutability is not only about mutable objects (i.e. mutable fields). It's about mutable state of any kind, including mutable local context (i.e. mutable/reassignable local variables). &gt;There isn't really anything lost. What's lost is: 1. Immutability of the local variable. What if you want to use the original `str` after those operations? You cannot - you lost the original reference. 2. Single-expression result (your code has multiple statements). Why is it a problem? Example: imagine `str` is a private final field. In order to `return` the result using your code, you have to introduce an extra mutable local variable (problem 1): &amp;#8203; String result = str; result = result.toLowerCase(); result = StringUtils.stripAccents(str); result = StringUtils.capitalize(result); return result; Doing it in a single expression, it becomes: return str .toLowerCase() .transform(StringUtils::stripAccents) .transform(StringUtils::capitalize); PS. Did you notice (in the first snippet) how I left `str` instead of `result` as an argument to `stripAccents`? If you did, you're good! If you didn't, you're as most of us (I presume) are - prone to overlook such mistakes (problem 2). Even if you did spot it, I bet there's someone on your team who wouldn't if they were to debug this.
While pointers are 64 bits, current x86-64 processors only have a 48-bit address space.
I was approving of this patch to make the code more professional but now i see you can't use "damn" and "torpedo" in the same sentence. I don't want to live in this world any more.
Can you imagine the havoc it could wreak in terms of backward compatibility? :) I mean, **every class** that defines a no-argument method named `transformed` would break. For example, a class with a boolean field named `transformed`, accessed through a no-prefix getter (= `transformed()`). Perhaps there are not many classes like that, but if you were unlucky and you had one, you'd be **forced** to refactor it. I bet Oracle would **never ever** go for this. I'm actually pretty confident Oracle will never add *any* new method to `Object`. And one more point: if you added this to `Object`, you'd need to provide a base implemention of `transformed()` (probably throwing an `UnsupportedOperationException`). To sum up, an opt-in (through `Transformable` interface or the like) would be the only way to go.
Is there a way to use the upper 16 bits, and mask them prior to dereferencing?
Yes, masking off the metadata bits is an alternative, at the cost of one more instruction the load barrier.
Seems like a small price to pay for a 256TB heap...
You could try Spark
There's also javalin.io which is similar to spark. It was made from scratch by one of the creators of spark and it tries to stay similar while also fixing some of the sparks issues
give me spring or give me death
Please someone tell me this patch was rejected? First word changes over being politically correct, now word changes over curses themselves? Hello 1984 here we come.
You'll have to settle for a DeathFactory.
&gt; Salts are cryptographically random values which are difficult to guess and usually take the form of a long string of hexadecimal values or byte array. Cool, sounds simple enough. &gt; final String salt = "user@example.com"; https://imgur.com/iWKad22
Only after a DeathFactoryBeanPostProcessor
SpringMVC
Well I suppose this is one way to contribute to open source, IBM!
Did you mean to say: &gt; G1 should be used for heaps _[greater than]_ 6gb approximately. From the rest of this thread, I'm guessing you meant _less than_.
Sliced bread is over rated. An unsliced loaf goes stale much more slowly, and really, is slicing your own bread really _that_ hard?
To add to this use ElasticBeanstalk and you can have a public facing functional website in half a day. 
Sensibilities and professionalism aside, curse words aren't good because they might not always translate well across languages/cultures. I also always find this "counter-offense" culture to be a little humorous. If supposedly you have such thick skin and so difficult to offend, surely then such a small thing should slide of your back like water off a duck. 
Yea, I wouldn't put curse words in documentation either. It's no professional and never necessary. If you want to throw curse words in a project only your colleagues will look at, fine but if you are publishing code that is used by MILLIONS of people, accept you are going to have to meet a higher criteria. 
I always find the counter-PC culture crowd rather humorous. The counter-PC people ITT are up in arms because someone took the time to remove swear words from a project I'm willing to bet never they have worked on, or at most submitted one small PR to. First and foremost, grow up. Java is used by millions of people. It's not the closed source project you work on at your company that in its entire life will only be seen by ~20 people. When you are writing documentation that will be used by the public, don't include swear words. They are never necessary and don't ever help. I'm not suggesting I'm perfect I have put snarky things in my code before. Software development can be frustrating, and writing snarky comments can be a way of venting that frustration. It seems childish though to object to removing/editing such comments and an order of magnitude more so when we are talking about code you never even touched! 
Here is a guide of using Vaadin (UI) and Spring Boot (Back-end). Don't have much experience with the former, but a lot with the latter and love it! https://spring.io/guides/gs/crud-with-vaadin/
I meant greater than. The parallel collector is very fast with very low overhead. For smaller heaps, there is no reason not to use it, the pause time will be less than what the more complex algorithms can muster. As an example, in one of our processes we have a 20gb heap using the parallel collector. Major collection times are generally less than 100ms. (Mind you, the VM has 12 cores assigned to it). Now, imagine how fast that would be if the heap were 1/3 the size. G1GCs minimum target pause time is 50ms. After you get above 6gb, it starts to matter what you are targeting and what your latency goals are. If, for example, the occasional 100ms pause doesn't bother you then even for heaps as large as 20gb, the parallel collector isn't a bad option. If throughput is the goal, always use the parallel collector. If Latency is the goal, then ZGC and G1 are where you should look. G1 has a lower impact on general performance while ZGC has much lower pause times. Both have additional memory requirements that the parallel/serial collector (and even CMS) do not have.
&gt; 'blacklist' This just popped into my head, but I'm sure someone's thought of it before: exclusion/inclusion list. It does work better as a descriptive term. Controller/manager/worker &amp; Leader/follower are also usually more descriptive. Being more descriptive should stand on its own though.
heh. Yeah, really no reason not to just do "/dev/random" for 128 bytes and call it good.
&gt; Also features like string interpolation often don’t provide much on their own without other features also being in place. What other features are really needed? String interpolation seems like an ergonomics thing first and foremost. Even the "dumb" solution would be a time saver. I'm also not entirely sure why RSL has precedence (or even relationship to) string interpolation. The two concepts seem orthogonal with the only relation being that they both have to deal with strings.
Awesome. Thanks for clearing that up.
Not on a QWERTY keyword mapping :D
Thanks for the reply. You mention the tradeoff between pause times and throughput. Any idea how golang manages sub ms pause times while still maintaining what seems to be high throughput? Or will Java have the edge here?
It's my understanding that preview features are not formally part of the Java SE APIs and thus not required to be implemented to conform with the JCK for a specific release. It's a reasonable question, though. Reading the JEP (http://openjdk.java.net/jeps/12) I can't tell which interpretation is correct, so I'll ask around to see if it can be clarified.
As of JDK 11, [OpenJDK and the Oracle JDK are essentially the same software](https://blogs.oracle.com/java-platform-group/oracle-jdk-releases-for-java-11-and-later). Oracle JDK is for those who wish to buy support; OpenJDK is under a free, open-source license.
Spring Boot hands down, with a FE in Thymeleaf. 
Who the fuck cares? Did these comments offend anyone in the past 20 years? No? Then why are we all of a sudden paying any attention to this?
I'm not a go expert, but I found these slides about how the go GC works https://blog.golang.org/ismmkeynote From my quick cursory glance, it looks like go is doing what ZGC does. It looks like they don't do relocation, though, which means that they have a higher allocation cost. Which has the edge throughput wise is a little tricky. From a strict GC standpoint, I'd put that on Java. However, go has a few knobs to pull that Java does not (like turning off the GC in critical sections and value types). From a not GC perspective, Go also has green threads, which can be a huge boon to throughput for IO bound applications. Go is also compiled, which means that it doesn't really have the startup and warmup time. This can be both good and bad, but it is certainly results in fairly predictable performance. Lots of words for "It's complicated" :)
To accomplish CSS reloading, I created button visible to devs only that calls: &amp;#x200B; `StyleManager.getInstance().removeUserAgentStylesheet("/theme/styles/Theme.css");` `StyleManager.getInstance().addUserAgentStylesheet("/theme/styles/Theme.css");` &amp;#x200B; The catch being, on in void start(Stage stage) , you have to do: &amp;#x200B; `setUserAgentStylesheet("/theme/styles/blank.css");` `StyleManager.getInstance().setUserAgentStylesheets(Arrays.asList("/theme/styles/Theme.css"));` &amp;#x200B; Where "blank.css" is just an empty file. This works for us because we don't use any of the system styles so with the simple click of a button, its all reloaded. Maybe you can adopt this to your needs
I think Swing is being deprecated so JavaFX is the GUI tool going forward.
Swing is not being deprecated. JavaFX was actually removed from the JDK, and can be downloaded separately.
&gt;Half the fun of reading code is swearing about how stupid something someone else (usually past me) has written. To be fair this is written from the perspective of an Oracle developer, and I'm pretty sure no one who has fun works there.
[someone already wrote a linter for when they do](https://github.com/get-alex/alex)
Ah, I see you too PHP
We do almost exactly this at work. Runs fine.
&gt;Whether your own or someone else’s writing, alex helps you find gender favouring, polarising, race related, religion inconsiderate, or other unequal phrasing in text. &gt; &gt;For example, when We’ve confirmed his identity is given to alex, it will warn you and suggest using their instead of his. I felt a minor stab in my chest followed by a sinking feeling after reading this. 
Please don't refer to them as poor people. The correct term is financially challenged.
I joke, but if this is how dude wants to spend his time then whatever.
We're writing a whatsapp clone in Java as part of our [online course here](https://codenameone.teachable.com/). We can compile it to run within a website which will compile it to JavaScript. Don't know if this is something people want though...
We limit the process to 1TiB heap space, so we haven’t hit that limitation yet. 
Finance. I work for a prop trading firm. 
Java 12?! Good grief.
Oracle(stupidly) removed jPackager from the JDK/JavaFX(not entirely sure which one it was a part of) which allowed for clean native images/installers. While I haven't built a JavaFX app in Windows, Linux is a .sh script with jLink. Once again because of Oracle, you will need to compile for each platform as no JRE/JDK has JavaFX built in. It sucks but that's desktop Java in 2018 for you. P.S. Use Java 9 modules if you can. No one wants to download 250MB files for a desktop GUI app. JLink will get it under 50MB when compressed. 
It's funny really: these kind of people complain about minor shit like this but when human rights are violated they are nowhere to be found. It's almost like they don't actually care about people's feelings or human rights...
Swear jars are old fashioned. [Swear modules](https://www.youtube.com/watch?v=ZmQ1BDkGGDk) are the new hip thing nowadays. 
Of course it's written in JS.
``` final String salt = "/dev/random"; ```
Too many? Is there an optimal number of swear words?
Have you checked [Instrumentation Docs](https://docs.oracle.com/javase/7/docs/api/java/lang/instrument/Instrumentation.html)? there is a **getObjectSize**() method
Compiling for each platform one by one, if I don't have a Mac, are there other ways I can do that?
I did. Instrumentation is an interface which you cannot initialize with InstrumentationImpl because the constructor is private. Tried with reflection but don't know what to supply to "long nativeAgent". Also, I don't like the build a jar thing which is in most tutorials. Trying to make this work from a test / main .
What a tremendous waste of time.
Meh. Bunch of PC nitpicking.
It was part of JavaFX, and there is ongoing work to bring it back in a clean way.
I worked with a nice, friendly, knowledgeable adult man who was genuinely offended by the most minor swearing. Some people have some bizarre ideas about what 'professional' means.
You don't. You buy new socks.
As far as I know, no.
Deleting swear words probably is a fun distraction if you work in that place.
JVisualVM can be used do dump the heap and view the allocated objects. It displays the byte count for every object, and allocated overall size. Also, you can view further data, but better examine it yourself. (Every objects takes up at least 16 bytes for headers and other info (in a 64bit VM), tested on JDK8)
Newspeak has been a thing in corperate environments for a long time. Using 'issue' instead of 'problem' has been going on for many years for example.
Might run into performance issues with that in VMs. Better use `final String salt = /dev/urandom`
&gt; First and foremost, grow up. And that's why the PC crowd are seen as hypocrites. They are fast to resort to abuse. They use personal attacks against anyone that disagrees with them whilst pretending to claim the moral high ground. Is a post about offensive words you are telling people to "grow up"? Get some perspective.
This change blatantly disregards the instructions in the comment. http://cr.openjdk.java.net/~afarley/8215217/webrev/src/java.xml/share/classes/com/sun/org/apache/xalan/internal/xsltc/dom/BitArray.java.cdiff.html
visualvm can also calculate the size of objects that are only referenced from your observed instance and would be garbace collected if your instance is removed. This is _very_ helpful to find less obvious memory hogs or leaks in your application.
Why do you need this? How many elements do you expect to have?
The code example is actually fine, just ignore the text before it - a salt doesn't need to be hard to guess, it only needs to be *unique*, and using another user-unique identifier such as email is fine. However, if you do use such a user id, make sure it's unique to your application as well, for example by prepending an application-specific string. In the end though, you should probably not roll all this crypto on your own - see my other comment.
This is pretty bad advice. As always - do not roll your own crypto! This includes combining cryptographic primitives in ways that may be dangerous. - Do not use PBKDF2WithHmacSHA256 for password hashing. Use a more modern method, such as argon2, scrypt or bcrypt. A good library for these algorithms will also already include salt generation so you do not need to worry about it. - Do not fiddle with AES on your own, it can be very dangerous! The example in the post in particular does not use an authenticated cipher and is thus insecure against certain attacks. Stick to more high-level libraries such as nacl or google's tink (though I am not a fan of the api of the latter). - The asym advice from the post is solid - stick to established protocols like TLS for asymmetric crypto. Here, too, RSA can be very dangerous to use directly if you do not know what you're doing.
Actually, using the username or email as a salt is not _that_ bad. The main reason to use salts is so that, if an attacker gains access to the database with usernames and password hashes, he still has to crack every single password individually. Without a salt, the attacker could simply hash a list of common passwords and look for matching hashes, or google the hash value (this works surprisingly well). To prevent this, the salt should be unique, or at least different for every user. It does not need to be random, very long or hard to guess, as it is usually stored alongside of the password hash in the same database, so an attacker is likely to know the salt anyway.
Vaadin? 
This might not answer your original question, but I highly recommend checking out TornadoFX, self-described as a JavaFX Framework for Kotlin. It's much cleaner than JavaFX/Swing, doesn't have annoying boilerplate, but comes with quality documentation and community. Powerful and extendable but without the pain. Not sure where you stand on Kotlin, but it's worth your time to take a look while you're still in early development. Since Kotlin's a JVM language too, any JRE solutions would apply to it.
(serious) Or increase available entropy with `haveged` or similar userspace tools on VMs.
Anything to avoid taking your fingers out of your ears and learning something.
You are not supposed to use the Instrumentation API directly within your code, but rather build a [Java agent](https://www.google.com/search?q=java+agents) and attach it to the JVM when you run your program. An `InstrumentationImpl` instance will then be provided to your agent by the JVM. If you do not want to go through the hassle of writing an agent, and just want to check the memory use increment after, say, each `put()`, you can probably use [`ManagementFactory`](https://docs.oracle.com/javase/7/docs/api/java/lang/management/ManagementFactory.html) and, more specifically, [`ManagementFactory.getMemoryMXBean()`](https://docs.oracle.com/javase/7/docs/api/java/lang/management/MemoryMXBean.html) to get memory usage data any time you want. This way you can e.g. print out the memory usage diff before/after `put()`.
For Java 8? Sure great idea, provide OpenJFX builds by all means! For Java 11? Ew no please just let the bundled SDK bullshit distribution model die already. People should be using the Maven dependency.
 &gt; Locating PII and sensitive data I understand what you're trying to say here, but if you have to rely on code analyses to know *how* your data is being treated and where it is being send to, something went very wrong quite some time ago. &gt; } catch (Exception e){ &gt; System.out.println("Sad world :("); &gt; } I know it is just example code...but...for the love of whatever deity you believe in, if you don't know what to do with an exception, just put `e.printStacktrace();`. That at least gives you a chance to figure out what went wrong. Also, why is there a random "Hello World" in there? &gt; Hashing is commonly used to produce file checksums or encrypt credentials. Say after me: Hashing is not encryption. &gt; It is a one-way algorithm, computing the hash value from a key is can be accomplished in polynomial time and is considered efficient to compute. Good cyptographic hashers allow you to define how fast they run (for example by increasing rounds of hashing) to make sure that hasing a value is *not* as efficient as possible. &gt; The converse operation, finding a value to produce a given hash, know as a collision, is not efficient and computationally expensive. No, brute-forcing a hash it not the same as a hash collision. A hash collision is when two different values produce the same hash, f.e. allowing you to enter a different password which still gives you access. &gt; Symmetric cryptography is is the backbone of cryptography and is faster than asymmetric. Citation needed...on both accounts. &gt; The default password for this file is . Typo?
Fuck this shit! People should be allowed to express themselves. What is this thought-police bullshit?!
That looks really cool. I'll definitely use it, thanks! I assume you don't use SceneBuilder (or even FXML), since it already handles CSS reloading. Also, which editor you're using for CSS editing that supports JavaFX-prefixed properties?
Well, you could also do some testing. Just fill it in a loop and count how many objects can fit before you get an overflow. 
I used a hack to access `Instrumentation` without explicitly having to build an agent: [https://github.com/nicoulaj/auto-instrument](https://github.com/nicoulaj/auto-instrument) Probably there is a cleaner way now (especially for just measuring objects memory footprint, we have [JOL](https://openjdk.java.net/projects/code-tools/jol/)).
Here are several ways to do it: https://github.com/komesergey/jvm-tricks/blob/master/src/com/company/SizeOf.java
You cannot just count all the objects in your system and multiply by their size to get total heap usage. That's too simplistic a view. * Objects may be virtualised and so not allocated on the heap. * The heap may be non-contiguous. * The heap may be fragmented. * Non-full heap pages may be committed. * Objects may be aligned. * There is non-heap memory as well. And so on, and so on.
If you're planning ahead for the outage, shouldn't you be monitoring your freeMem and heapSize rather than the individual object memory usage? I don't think it's a one-to-one translation of X many objects in a Map = maximum size. It all depends on the state of other events and objects.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
It looks like cross-platform desktop it's still a mess in 2018, not just in Java. The only real options (aside from Java) seem to be C++ / Qt, and Electron (HTML / JS). Qt's programming model looks annoying, and Electron still takes 1+ GB of RAM to run simple apps. Am I missing something?
Do you have to compile it separately on a windows machine, a mac, and a linux one?
What’s wrong with Java 12?
256 bits of entropy should last forever
Wait, OpenJDK is not halal?
Cool library 👍 Thanks for sharing!
&gt; But for me, Java was for applets and nothing else. Applets were never a large percentage of Java code-bases. It was always much stronger on the back-end. Even back when Applets were still used there was almost no reason to use Java for something as simple as a chat interface. 
Yep. Use the JavaFX artifacts for the target platform. So if you want to make a build for mac, use the mac artifcats.
Out of band question, I am a decent java programmer I just wanted to know how to get into Java internals. I always hear that, thread dumps and heap dumps are your friends but I when I look at an actual thread dump I can almost comprehend nothing. I know my question is vague and broad, so you can throw anything at me. 
&gt;thread dumps and heap dumps are your friends They are, when you'd like to debug specific scenarios. I've used thread dumps to determine the causes of deadlock. Where did the threads deadlock, why, which objects were synchronized, and so on. Heap dumps can be useful to locate memory leaks, and determine overall memory performance of your app. If an object is kept alive after you've supposedly released it, then you can look at which objects are still referencing it, and determine how it is still not garbage collected. Good stuff.
Great overview. I do wish that they'd date their articles. 10 years from now, someone (probably me) will come across it again and be like "cool!", but without the context a date would provide to help determine whether these patterns and resources might be the new hotness, or old and busted :/
True.
ehcache [sizeof](https://github.com/ehcache/sizeof) lib ? The main commiter was speaking at a conference few years ago, he explained how his team explored the subject. It was a really good talk.
I think the Java language is becoming too sensitive ... 
Ok that makes more sense - so, as I understand it, I end up with three apps (mac, win, linux) but I can build them all on my machine (no need to have win / mac / linux machines). Is this correct?
* Yes, this is how you're supposed to distribute Java applications today. You bundle JRE with your application JAR. One for each platform. * JavaFX is better than Swing in many ways. Just go with JavaFX without drowning in details and *analysis paralysis*. * Launch4j creates executable launcher for your JAR with specified JRE. * [ZuluFX ](https://www.azul.com/downloads/zulu/zulufx/) is the JRE comes with JavaFX bundled. I'm going to use it for my JavaFX 8 applications. * Alternatively you can use OpenJFX 11 with OpenJDK 11 from AdoptOpenJDK, automate stuff using Gradle. But it can be a daunting process if you're starting out. Here is the roadmap I recommend: 1. Use ZuluFX JDK to build your application with JavaFX 8. [Kishori Sharan's JavaFX 8 book](https://www.amazon.com/Learn-JavaFX-Building-Experience-Interfaces/dp/148421143X/) is a good resource with many examples. 2. Create JAR using your IDE's tooling. 3. Use Launch4j to create an executable launcher for your JAR with ZuluFX's JRE. 4. ??? 5. Profit! Feel free to ask any question that crosses your mind!
Yep. I'm already doing it to package Windows, Mac, and Linux builds from a single Gradle task on a single machine.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I think cross-platform desktop development is in a good shape, whether you're building an application or a game. *Real* desktop application frameworks like Qt, JavaFX, Swing, WPF, Cocoa make great sense once you get used to them. Most companies and individual programmers flooded into web or mobile development. And they won't stop making noise about it: writing blogs, doing meetups, giving talks, etc. This is why it feels like desktop is abandoned. Electron is STD. I'd avoid it at all costs.
Not OP but as a JavaFX user TornadoFX always looked interesting. I just can't get used to Kotlin. Do you think it's worth it?
touche
[ZuluFX](https://www.azul.com/downloads/zulu/zulufx/) addresses all these problems. Its JRE is about 60 MB zipped. Not a show stopper, IMHO. Also ZuluFX 11 will be available soon, according to their FAQ page.
Never, I hope. &amp;#x200B; Getters / Setters should be there. In the face. Explicit. &amp;#x200B; ...and if the idea of having all of this boiler plate code staring you in the face scares you, then try to use them less. &amp;#x200B; Too many getters / setters is an antipattern. Using something like Lombak hides this from the developer.
Makes sense. The JVM should be getting value type at some point, as well as green threads/fibers, and AOT with Graal. It will be interesting to see how things work out.
How does one get comfortable in analyzing them. Are there any resources that you can recommend for a novice? 
Noting especial, particularly given that I haven't read up on it's. I just think their release cycle is madness. It was crazy before to be 2-3 years between language versions. I things we should be able to manage with 5 years. And now they're doing it once a year... I realize they have corporate users, but gosh give people time to move to it get used to it and be able to benefit for a bit before jumping on ten with new years. Or pick a slightly different release system.
Swing does it. Its font based. Now if you have special effects, your special effects should pad the font pixel size. My perso Drawing Lib does exactly that. It just that the way JavaFX was designed. its not possible.
I tried Gluon. Looks ok. but there is huge competition by others
CodenameOne is the only other Java-based one I know of. What do you think about it? What else do you have?
i meant there is competition on the framework level for hybrid mobile app dev. Have you heard of Google's flutter? I didn't know about java based CodenameOne. But my point is about the wide choice Lead Dev have when deciding which framework to use to code hybrid mobile apps.
another example. Niantic was using RoboVM before Microsoft killed it by buying it. Their first game was using RoboVM. With Pokemon GO they use Microsoft C# based framework Unity.
Sadly, I got no notable resources on the topic. Google some. Most importantly, practice helps a lot.
There will actually be a new version twice a year, with an LTS version every three years. You can read more about it [here](https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence). The reasoning is that when features are ready, they can be released and not be held back by the completion of larger features. One example of this is [switch expressions](https://openjdk.java.net/jeps/325).
I have. I don't really do much mobile anymore, but I actually tried Flutter thoroughly a while ago. It wasn't an ice cream back then, but now they hit 1.0 maybe I should give it another go? What's your opinion about Flutter?
Ah, yeah. Ingress. I love LibGDX and I heard it's still viable on iOS. 
I prefer Native Dev. I am pro Java. So I like Gluon. I don't want to learn yet another language. I have enough already with Swift.
I will venture a guess that you don't 'compile' separately, at least your jar. But you probably do have to 'package' separately for each platform. That is, for Mac: * bundle in a Mac version of Java * use a Mac executable launcher or script file that launches your bundled java with your jar file Similarly for Windows, and for Linux. &amp;#x200B;
I understand. I don't trust Google either. And it bugs me that even Flutter comes with "analytics" enabled. I use an Android phone, but I don't plan to develop an Android application either. What about Swift?
There are a lot of good ones. Best will be a matter of opinions.
With all of the discussion I'm confused, if I was: * building a simulation game that runs locally * would have a decent sized heap (probably &gt;6gb) * I don't want any UI pauses at all if possible * Would likely have a lot of short lived (and long lived) objects Would G1 or ZGC be a better option or is the answer still "it depends"?
He may have been referring to something like [this](https://kotlinlang.org/docs/reference/null-safety.html).
Quantum computing would like a word with you
Not "factory-sliced bread", just "sliced bread". Sliced bread is great, even if you're the one slicing it. It's impossible to make sandwiches with whole loaves! It's TOO MUCH. 
Thank you - what if I want to use Oracle's JDK 11 with OpenJFX? It looks like the people at OpenJFX are working on a new jpackager, but I'm not sure when that will be ready. Should I use jlink in the meantime?
Swift looks like Kotlin.. It way better than Objective C and there is not other choices for Native IOS dev. I prefer Java verbosity.
ZGC would probably be the way to go in this case, particularly because it would be more predictable (less jitter). It may even be the way to go for a smaller heap in this case, you'd need to experiment to see what works.
&gt;Security issues mainly. The entire "modern" JS development process encourages [small packages that can be exploited easily.](https://hackernoon.com/im-harvesting-credit-card-numbers-and-passwords-from-your-site-here-s-how-9a8cb347c5b5) Ads on Forbes load malware. Firefox security was so bad, pwn2own 2016 wouldn't even give awards for it anymore. Nevermind all the attacks on NPM that target developers directly like eslint-scope, crossenv, and event-stream. Security isn't language specific. It's a process. The problem with Java applets was expecting end users to stay up to date on Java. Bad process. Just like NPM giving a pinky swear and a SHA1 hash instead of cryptographically signed packages. Bad process.
This is a thorny problem. A fairly accurate calculation for an object's expected size can be obtained using [Java Object Layout](https://openjdk.java.net/projects/code-tools/jol). After instrumentation agent support was added to the JVM, many utility classes helped wrap up that code. The original popular one was [SizeOf](http://sizeof.sourceforge.net/) (not to be confused with Ehcache's clone, piggybacking on the name for SEO purposes). The popularity of `Unsafe` to bypass led to other approaches, as all estimation types are not expected to be entirely accurate. [JAMM](https://github.com/jbellis/jamm) is a well worn library that accumulates much of that knowledge, and probably the most popular. This type of information is useful for back-of-the-envelope calculations. None should be used as strict metrics to be heavily relied upon in production. For large data sets you might consider offheap, etc. as alternatives. But if you want to have rough idea or double checking for mistakes (e.g. accidentally an inner vs nested class), jol and jamm are helpful for sanity checks.
Raw String Literals 😭
Well will still get them at some point, don't worry!
I agree people want that, but that's a whole other ball of wax.
Notch, is that you?
Yeah, I’m not a big fan of that feature.
Definitely! Kotlin is very stable and absolutely worth the switch, even though it might take some time getting used to. Spend some more time with it and you'll see how beautiful it is ;) You can also use JavaFX in Kotlin too of course, since they're completely interoperable. However, you might as well leverage TornadoFX's power. Most guides for JavaFX can also be directly applied, since TornadoFX uses it. The CSS/FXML can all be written in Kotlin smoothly, so you have a lot more flexibility in how you structure your app. Pretty much everything is better on Kotlin. Spring, libgdx, etc. all work and it'll reduce a lot of annoying boilerplate those languages in Java require.
Rule #1: Don't touch anything that says Oracle. :) You don't need javapackager. Launch4j or Packr is all you need. If you want to use JavaFX 11, the easiest combination is Zulu or AdoptOpenJDK's builds and OpenJFX 11 through the Gradle plugin, until ZuluFX 11 becomes a thing. IMHO, it's not worth the trouble. Just grab ZuluFX 8 and start hacking away.
Haha, I get what you mean. In Java you don't try to outsmart your coworkers. You just implement the idea in your mind. In many other languages, you try to come up with clever code, thus wasting more time than hitting a few more keystrokes in Java. 
Comparator has a keyExtractor ?
Well, you're too convincing. :) Another reason I avoided TornadoFX was that it supported only Java 8, and I was too lazy to buildOpenJDK with JavaFX. Now with [ZuluFX](https://www.azul.com/downloads/zulu/zulufx/), we have one less problem. I'm good with JavaFX APIs, but I couldn't get into FXML and CSS. I like the idea of not needing them.
Sorry to ask a newbie question, but what's the difference between JDK and OpenJDK? Last time I used Java it was owned by Sun, so I'm not up to date with this whole Oracle thing :-)
By now, the only difference between OpenJDK and Oracle JDK is their name and license.
Went the way of my dad... here for a preview, now gone forever
See /r/learnjava and the side bar there (old reddit only). Removed from here: &gt; **NO programming help, NO learning Java related questions!**
It's best you learn English first
Where is the list what finally will be available in java 12? Any news about records? 
&gt; I heard javaServer faces is pretty good When I was unemployed and looking for work I passed on a Jsf opening because I don't think there's a future in it. It's all legacy projects. Quick popular suggestion is ctreate a spring boot project, then: - Database: Spring Jdbc - Controller for rest endpoints: Spring Mvc - Java -&gt; Json Converter: Gson - Front End: Angular (I like the looks of Vue as well but I saw saw a lot of Angular mentions when I was job searching) 
You can see the list of features [here](https://openjdk.java.net/projects/jdk/12/). Records will not be in this release, but we do get the preview of [switch expressions](https://openjdk.java.net/jeps/325).
Oh :( I really would like to get rid of Lombok, but I guess I will need to wait. Thank you! :)
In time, in time! A you’re welcome!
There is a [backported](https://mail.openjdk.java.net/pipermail/openjfx-dev/2018-September/022500.html) (from 12) preview of the new jpackager for Java 11. It could help, or not... I'm currently stuck at trying to get an installer that can work with a modular app and some jars that are auto-modules... and it doesn't work. &lt;rant&gt; I really **don't like** the opaque binary crap that get included by the packager instead of just using bash scripts. I just want to start java with a @argument file &lt;/rant&gt;
What has happened suddenly with Java, they are releasing new versions very frequently. I am still learning JDK 8 and they have reached 12. 
I'm pretty sure there are already checked exceptions in hell
Java changed to an every-six-month release cycle: https://www.infoq.com/news/2017/09/Java6Month
&gt; Java -&gt; Json Converter: Gson FYI: Jackson is the de facto standard. It's generally more powerful and faster than other JSON libraries. And it also supports Kotlin. You can tell Spring to swap out Jackson for GSON but frankly I don't see the point. 
with java 9 they decided that to keep up with other languages, they need to bring new features more often than 1x per 4 years
How much does it cost?
Free: https://openjdk.java.net/
Only every 3rd realease really counts. 8,11,14. The ones in between are unsupported and will get very little adoption. 
Jackson has annoying unecessary checked exceptions if you use it directly. We happen to be using gson at my current job do that's what I put. If you're using them with dpring mvc doing the conversion automatically I don't think it matters which one you go with.
Yes, Flutter, using Dart, is rather promising, especially coming from a Java background. Dart syntax is very similar to Java. There are a lot of differences, but I found learning Dart to not be a huge impediment to getting useful things done with Flutter. There's also NativeScript, like React Native. 
Use Kotlin. 
Really? Stop waiting. It’s been 20+ years. Just switch to Kotlin. 
I will check it, but I’m not sure is this is a good idea.
I've really found Udemy to be a great resource for most skills I need/want to improve my own career. &amp;#x200B; This is the course I took for java development. [https://www.udemy.com/java-the-complete-java-developer-course/](https://www.udemy.com/java-the-complete-java-developer-course/) (Personally I took this coupled with a separate Android developement course.) Hope it helps!
what would the pom look like if I want to use it?
I saw oracle.com and assumed it was the commercial JDK and was trying to be sarcastic. Sorry.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Well, more like six or twelves months. :)
Literally everything in that comment is wrong. OpenJDK will release every six months and will have community support for as long as someone is willing to step up to do it. Oracle will support OpenJDK builds for at least six months. Oracle will also have a commercial build of the JDK. Every three years they will deem it to be a LTS release, which they will commercially support for three years starting with 11 and the next will be 17.
Sorry, I didn’t know that was a policy.
Classes and Objects Abstract Classes and Interfaces Exception handling Multithreading Generics
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
The syntax isn't much to swallow. In fact memmerizing syntax is probably my least favorite part of CS. Be sure to focus on concepts. Learn the object oriented style and programming in other object oriented languages will be super easy. Best wishes Java is pretty amazing enjoy it.
If you want to risk your project on a release that has support for 6 months and hope that someone in the community decides to patch that version that's up to you. Until there is a track record large projects would be wise to stick with the LTS releases.
Worked for me! Thanks
Object orientated languages like java i think is a poor choice for a first language. its to confusing. A simple procedural language like C is a better choice. or even PHP which is both.
Daddy’s coming back?
The LTS releases are only relevant to the commercial JDK from Oracle. They are not relevant to OpenJDK builds. Oracle are not supporting OpenJDK for more than six months. 
Check my repo for a cross-platform JavaFX app built with Java 11: https://github.com/brunoborges/fx2048
There is a plugin called [moditect](https://github.com/moditect/moditect) which builds executable apps [Here](https://github.com/florendg/java11-jlink-fx-demo) is an example. I've tried it on Ubuntu/Windows 10 and it's working fine.
I don't think we've had a public build with records in yet, so we're probably a good year away from getting those. It is possibly that they might target 13, but I wouldn't count on it. (We've had several builds of value types, but that's a different feature all together)
I am trying to package a javaFX application for windows from my mac with intellij I can generate dmg, but can't generate msi or exe. I use artifact. Is there any plugin to add or configuration to set to package this application for windows from intellij 2018.3 ? 
[Obligatory](https://i.imgur.com/R54a5mZ.png)
Like you said in 2012: Just switch to Scala?
Do you like meth? If you like meth, you'll love Kotlin...
I've seen both issue and peoblem be used. So I don't have experience with your example. Newspeak is recently new from my perspective, tackling anti-PC and "offensive" terms specifically.
careful about proclaiming your technical preference for a tool as 'de facto standard' ...
Well it is the standard Spring JSON library, so I don't really see how my personal preference comes into play.
I think Grails is a great Java web framework, it is well documented, easy to use and follows a convention. You do not have to be a hard core Java developer to create something. Some basic programming experience is all you need. Grails is also very easy to get started with, all you need is [sdkman](https://sdkman.io/)
The releases are supported for 6 months because after 6 months there's a new release. These are not major versions. The last (ever) major release was JDK 9. As to whether or not you should stick to LTS versions, the wisest thing is to hold off on deciding. There is no rush. You can evaluate how hard it is to keep up with the release train, vs. the cost of the LTS support or the effectiveness of the community LTS support.
Ouch. I’m on a Scala project now, and I’ve been surprised by how much hype there still is in some Scala circles. We tried moving from Java 8 to Java 11, but some of the Gradle plugins we’re using don’t support the latest versions of stuff we need to be on. We have to decide if we’re going to stay on old versions or if we’ll update the plugins ourselves (and stop delivering features while we do).
Its not clear, what this program about. What Santulator do?
Good. I've been playing with some other build of this, and could not make it work for an application with modules that won't get merged to the jvm image (deps that are auto modules not real ones). I hope it can now work ?
By the looks of it: Secret-Santa-Emulator - Basically just pairs a list of names
No cross-platform makes it a no-go for me. The main reason I stuck with Java was the "build once, run anywhere" motto - and I can still largely achieve that with `jlink` so the advantages of the current state of `jpackage` are meaningless to me.
&gt;I can still largely achieve that with jlink How that? I thought JLink would also only create platform specific bundles. &amp;#x200B;
Can it handle code signing for Mac? Always such a pain. 
No offense intended but, no, I would not be interested in that. "compile it to run within a website which will compile it to JavaScript" - dafuq
&gt; I thought JLink would also only create platform specific bundles Yes but I can bundle my linked modules with any system-specific JDKs from Linux and then distribute them. I don't need to run `jlink` once per platform or even bother installing or buying a license to have my stuff run on all OSes.
Right, but jlink can create an image for any platform from any other platform as long as you have a JDK for the target platform downloaded and unzipped on the build system.
Nope. You can create a platform-specific _JAR_ (or even a jlink image) from any platform, but an installer can only be created on the same platform that you want to make an installer for. So if you want a .exe for Windows, a .dmg for Mac, and a .deb/.rpm for Linux, you will need a Windows machine to create the exe, a Mac to create the dmg, and a Linux machine to create the deb or rpm
even if you're not buying commercial support from oracle ahead of time, there are potential advantages of sticking with the LTS * you only have to upgrade every 3 years * even if you're not using the oracle version, your customers can buy support so they'll be able to run your code on a supported jdk * in a bind, you could buy support from oracle * bugs that oracle backports to their LTS version are more likely to be backported by someone else to openjdk * other vendors may designate the same versions as LTS admittedly, the last two aren't guaranteed, but given the almost impossible task of tracking these 6 month releases (for many developers), i suspect that we're going to treat LTS as more than an oracle-specific designation at the least, that's my plan for my less popular open source projects 
&gt; you only have to upgrade every 3 years is predicated on &gt; bugs that oracle backports to their LTS version are more likely to be backported by someone else to openjdk which as you say is not a given. I believe the official solution is to ship your product with a JVM, and to test builds with pre-release builds as early and often as possible.
Authoring of native installer packages on non-target platforms is a crapshoot, so I can't really fault this decision. jlink just creates a output directory, wrapping that up for distribution is your job - and you're still going to need to run Windows to use Wix or similar to build an MSI, an appropriate Linux flavor to build a RPM or DEB, and macOS to create a proper drag-and-drop DMG or PKG file for Installer.app. jlink also has the annoying restriction of ONLY working with fully modular applications, automatic modules aren't good enough. The ability to work with applications regardless of how JPMS-ready they are is a huge benefit over jlink, and will make packaging Java applications for distribution mostly pain-free without relying on clunky tools like Install4J or manually doing it all yourself.
The documentation lists parameters for handling codesigning on macOS, so, yes (assuming it works)?
Eh, just because you could do something doesn't mean you should. And I feel like all of those examples about switch statements can be handled as is with minimal fuss and a little though thought. You can always insert a extra pair of braces (aka a block) without a prefixing keyword around the contents of a case to make it so you can have another local scope and use the same variable name. to do the days of week thing you can just use a class with only fields. (i.e. Days.Thursday is an int with the value 8). And of course almost any switch can be managed as an series of if statements or an if/else. And so on... Imho break with value seems like a terrible idea. Switches were never meant to work that way. And as far as I know regular if statements don't with the exception of the ternary operator, ?.
So, I get your point, but so long as you are doing rough calculations most of this stuff isn't really that important. Like, 10% of actual allocation costs not important. Yes, it is impossible to know exact size, but it is fairly trivial to get a good "size at rest" estimation. Heap dump and look at some examples of your object in question. So long as you use the same GC algorithm it will be fairly accurate.
Interesting - so if you don't create the installer, what is the user supposed to do with your platform-specific jar / jlink image? Say I'm on windows (or mac) and I don't have Java installed (which I guess rules out the JAR) - I download the jlink image, and then what do I do with it? Can I double click on it or do I need to run a command from the terminal?
How would that work? You mean for example, on windows you could build mac/linux installers? 
You can create a launch script as part of the image with the `--launcher` flag. It'll generate a basic `.bat` script (Windows) or shell script (Mac, Linux) that'll run the app. The script can be run from the command line or by double-clicking if the file manager supports running script files. The launch script is placed in `bin/` and is basically `java -m mainmodulename/mainclassname` to launch your application module with the Java executable in the jlink image. But `jlink` does not create a native executable application. The `jpackage` tool (currently scheduled for Java 13 in September 2019) will let you create a native application and/or installer, but only for the platform running the build. Unlike `jlink`, it cannot create cross-platform executables.
i have been introduced to Kotlin at work. I am not a fan. but people who don't have 10 years of experience set in stone in Java like it. Basically Kotlin is lots of syntactic sugar to remove verbosity. They do "natively" what lombok does to setters and getters.. etc.
Got it - so in your answer above, how do you create a platform specific installer if jpackager has not been released yet? (As in, how do I create a .exe installer for my app today, building on a win machine?) Also, if I don't create the installer and ship a script instead, wouldn't the user need to change the permissions and make it executable?
I decided not to use Kotlin. I believe I'm faster in plain Java. I also decided not to use FXML and CSS. Pure JavaFX API is straightforward and flexible.
Java will likely have the throughput edge. But note something that can be misleading regarding GC pause times. Some GCs (like Go's) do throttling, which means they stop a thread (or a goroutine) when it's about to allocate, but these are not considered GC pauses (but they do affect both throughput and latency). So a GC that never collects and "throttles" an allocator when there's no memory left (by stopping the thread forever) is technically pause free, even though it has infinite latency.
**Rules:** + **Do not post tutorials here!** **removed**
You can either try the early access builds of the packager tool, or wait for it to be released. Or you could revert to Java 9 or 10, which include the old packager tool, but I don't know if it supports jlink images or not
I took a look.. had to tweak some code to make my app run on jdk-12, but not too bad. It built a windows .exe installer nicely. &amp;#x200B; But not being able to build all installers from one platform is a deal breaker.. I am not happy about the hefty price tag for install4j, but it does a good job with GUI/CLI and produces a more professional installer -- with splash screen, read-me, uninstaller, "launch after install" checkbox.. and documentation.. &amp;#x200B; A nice free alternative though. &amp;#x200B;
i'm in the process of testing my more popular stuff against 12. it's a lot of work that i'd rather be spending on new development. for everything less popular, i'm just gonna hope that people are willing to keep using 11 for a while 
Thank you!
That's what I would like from `jpackager`, yes, and it's a relatively simple matter of separating the system-dependent parts from the "payload". This way you could just supply your program data and it would bundle it with the respective installation methods. That's how `jlink` works but instead of a neat installer you only get a bunch of files you can deploy to that particular system. There really isn't anything preventing `jpackage` from working that way, except its uses different installers for different system, so it's not easy to just "package" the data and scripts and have it "just work". I understand it's less work to do it this way but then for people like me who have zero interest in building on each and every supported system, then `jpackage` just becomes useless. Perhaps it's just a bit too lazy to be useful.
I don't know if creating a "common" installer would be that much trouble for Oracle (one that works generically from a config file and your app data regardless of system). More than that, I don't know if jpackager is useful without it - as you just said, it should be pretty easy to MSI, DEB or DMG your file if you're in that particular system, so what's the point of `jpackage` other than to serve as a thin layer on top of existing tools and by definition be less useful and more prone to error than using them directly?
The thing is: if you have to be on that particular platform to generate an installer, then why not use the underlying tool instead of going through `jpackager ? All it does it use that tool for you, making it prone to error and hiding tons of settings you could use directly. I mean, if it was absolutely a pain to produce installer, then OK but even though I don't have much experience, I doubt that creating a MSI file on Windows is going to be a major pain in 2018. Considering `jpackager` itself is always using some sort of free/open-source tool to package the installer, I see no reason for people not to do the same and skip the middle man. Sure, it's nice that there is the option to use the middle man for people who want the convenience of it - my question is more, why are the people working on this project going for such a lazy design when arguably a little more work could result in cross-platform packaging? `jlink` gets real close to it already and it "just works", I see no reason why a couple developers couldn't do similarly and generate a basic cross-friendly installer to go with it for each OS.
Packaging isn't an easy task, there's a reason why even tons of open source projects out there don't have proper packages or installers. I can throw together a moderately complex RPM or MSI without breaking a sweat, but unless you have experience with the authoring tools or even know what tools to use it's a minefield of trial, error and reading documentation for the twentieth time. jpackage removes the need for detailed knowledge of how to create platform-specific packages, I think that's a great feature - it even generates native launchers (so users don't see random java processes not knowing what they belong to). It's not overly useful to experienced packagers, but that's not the target of the tool.
jlink doesn't work with legacy classpath applications or those that use automatic-modules. That's a pretty glaring flaw, and a use case that jpackage handles. Even if you make the installer yourself, you can still use it to generate an application image and package that up.
Sidenote: you can use jlink even if your application isn't fully modular. You need to know what JDK modules it uses. It's easier to find out if your application is fully modular, but it doesn't need to be. High chances are that you have a third party library that isn't modular anyway so you need to chase it down with jdeps.
Sorry, but no, you can't - see [JDK-8130047](https://bugs.openjdk.java.net/browse/JDK-8130047); at least not unless you want to go manually injecting module-info.class files into every single JAR in your dependency hierarchy.
It _is_ an absolute pain to build a cross platform installer. Just getting a Java app into the Apple App Store took colossal effort not long ago. The advantage of install4j is you can build all your installers by learning the one tool and it runs from the platform of your choice. The installers all look and behave the same and have a lot of customization options. Jpackage seems good if you’re only releasing one platform or don’t mind a multi-machine build— hacked together with ssh. 
Dumb question did this make the images smaller than the equivalent OpenJDK that uses libc anf alpine as the base image?
Sanitized version is calamities/minute.
For a new project javafx is the way to go. Swing is still in the jdk for comparability. 
Or there is a simpler way - [https://www.youtube.com/watch?v=5kC5k5QBqcc](https://www.youtube.com/watch?v=5kC5k5QBqcc)
You are using bitwise operators there. It's more normal to see Boolean conditions joined using &amp;&amp; instead of a single &amp;. The ^ is the XOR operator. Replacing the &amp;'s with &amp;&amp;'s and the ^ with a || would make it use boolean operators instead of bitwise. https://stackoverflow.com/questions/7101992/why-do-we-usually-use-not-what-is-the-difference Also, this question is better suited for r/javahelp not r/java
Thanks dude really helpful 
Without knowing anything about this particular application: The concept of Secret Santa is that it give you pairwise matching of a set of people to provide gifts for. So if you have a big family, and buying a gift for everyone would drive you into run, while enriching amazon.com, all of your family is going to use a 'Secret Santa' app which tells everyone who to provide a gift for.
Yes, Install4j can build any platform on any platform. It’s just a matter of how much effort the developers want to take building their own set of installer tools. Jpackage uses 3rd party windows utility that won’t run on Mac or Linux and assume they use some Xcode to build the dmg/pkg formats on Mac. 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Expecting to hold 10,000 items in your collection? Great, test it with 100,000 items and check the performance. HashMaps are fast and easy to work with. If it fails because you want to have a hundred million, buy more ram or use a database. It’s easy to tell if you’re running out of java heap space. Use profiling tools and agents if you suspect performance may not be adequate. 
he's not talking about linking your deps into a jlink build with automatic modules. he's talking about using jdeps to create a minimal jvm based on the requirements of the jars you want to use, and then distributing your minimal jvm to run your application. 
First off, the formula given by oracle is correct for your use case. The unit dB is used in two different contexts: [Power and root-power quantities](https://en.wikipedia.org/wiki/Field,_power,_and_root-power_quantities). How you get to a linear scale depends on which one of these contexts you're in. Since you're talking about sound, you're dealing with root-power quantities. That means that the fomula for linear scaling that you found at the oracle site is correct, as a change in amplitude (which is what you care about) by a factor of 10 corresponds to a 20dB change. A bit more background to try and understand the different usages of decibel: dB only expresses a relationship (or rather: a ratio) between two values. Something can be 5dB louder than something else, but it makes no sense to say that something is 20 dB loud without providing some sort of reference value. When you read something like a jet engine is x dB loud, people usually refer to the human threshold for hearing (dB SPL or dB SIL), but that's of course also pretty arbitrary as that threshold can vary a lot from person to person. When talking about volume in the domain of signal processing, you can't even use dB SPL as a reference scale because you don't know anything about what volume the speakers that will play back your signal will be playing at. So (unless you have some sort of calibrated reference setup) you generally use dBFS as the reference. FS stands for full scale and uses the maximum amplitude you can express within your system as reference (i.e. whatever your system outputs when your playback sample is at MAX_VALUE of whatever type you're using). Thus, your scale works from 0 dB (which is as loud as it gets) downwards, which gets you those -x dB values that seem a bit weird at first sight. Another often used scale is dBVU, where VU stands for volume unit, which simply defines some arbitrary value (often times something like -18 dBFS) as the 0 dB point such that you get some headroom to work with - if you're mixing several signals together and they're all at 0 dBFS, you'd immediately get clipping. In that case, dB values above 0 can be expressed again. I haven't done any signal processing in java, but I think I remember that FloatControl.Type.MASTER_GAIN doesn't have to give you the values you got as max and min. They may well vary based on the operating system / audio engine you're using (WASAPI may report different values than ALSA on linux, which may again report different things than pulseaudio on linux and whatever MacOS is using). So make as few assumptions as possible if you want to run on any OS.
**Field, power, and root-power quantities** A power quantity is a power or a quantity directly proportional to power, e.g., energy density, acoustic intensity, and luminous intensity. Energy quantities may also be labelled as power quantities in this context.A root-power quantity is a quantity such as voltage, current, sound pressure, electric field strength, speed, or charge density, the square of which, in linear systems, is proportional to power. The term root-power quantity was introduced in the ISO 80000-1 § Annex C; it replaces and deprecates the term field quantity. It is essential to know which category a measurement belongs to when using decibels (dB) for comparing the levels of such quantities. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Thanks for the answer. I decided to continue with JavaFX. What's your opinion on FXML and CSS in JavaFX, by the way? They seem to complicate things more.
Actually they make things easier by splitting the concerns. You will deal with the structure of your views in the fxml file (using scene builder as a helper), the actions and algorithm are dealt within the controller in java, and anything that is look and feel related (colors, effect...) is dealt with in the css. Maybe what you sense as complexity is the learning curve of learning fxml and css in addition of java, however, I find it simple and intuitive enough. 
I've been a web developer for many years, so I understand the concept. Scene Builder is also very well-thought. I'm amazed by its capabilities. Problems arise when I want to create custom controls or generate some part of the UI dynamically. For example, FXML doesn't have the concept of loops like other template engines. So I'm supposed to go back and forth between Java and FXML to do what I want. It means a lot of presentation logic in the controller class. How would you approach to a situation like this one?
You can jlink any combination of JDK modules. Above only doesn't work if you are not specifing the required JDK modules but have it find things out on its own by pointing it to your application. Just recently there was a guide: [Using jlink to Build Java Runtimes for non-Modular Applications ](https://medium.com/azulsystems/using-jlink-to-build-java-runtimes-for-non-modular-applications-9568c5e70ef4) 
Thank you for this detailed explanation. As a follow-up question, would it ever make sense to have a setup resulting in more than 0 DB? Is there an appropriate formula for this? My main point of confusion is that Java reports a maximum DB value of 6.0206, which is non-zero.
Again, it depends on where you set your reference value - in my example of the dBVU scale, the 0 dBVU reference value is set below the absolute maximum of 0 dBFS, e.g. at -18 dBFS, such that in that reference scale, you could go up to +18 dBVU without clipping, so all values up to 18 dBVU would be reasonable. If all you want to do is scale linearly from 0 (as in lowest possible volume) to 1 (as in highest possible volume), you can simply scale from the minimum java reports to the maximum java reports using the formula from oracle. You don't even need to know what particular numbers java reports as you only really care about the relative position of your current volume between minimum and maximum.
No one ever defined how `switch` *should* work. This is an extension to the conventional statement. It will help reduce boilerplate and will go well with [pattern matching](https://openjdk.java.net/jeps/305).
Awesome
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Is it just me, or is \[Goetz' rationale for dropping this\](https://mail.openjdk.java.net/pipermail/jdk-dev/2018-December/002402.html) super weak? Basically, raw string literals have functionality that traditional literals don't (which is bad, apparently), and backticks are confusing. My favorite objection is that we shouldn't use the backtick because we might want to use it for a future, different kind of string literal lmao
Impressive! Thanks for sharing.
It looks like in your [submission](https://www.reddit.com/r/java/comments/a6gid6/how_to_mock_a_static_method_without_frameworks/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
This is a small project I've been working in the last few weeks, is a calculator with multiple features which could work as a small and fast alternative to other softwares. Any criticism or revision that could be made to the code/program will be highly appreciated, as you can see I'm not a pro coder. Greetings :) 
thanks
Thanks, hope it can be useful
This subreddit is neither for programming help, nor for showing off your programs. + Why is everything `static` in your code? `static` should be the *exception*, not the *rule*. + Why are you hardcoding so many things? You have so much repetition in your code. Especially in Java, there are much better ways to achieve what you want. *Enums* are one example. *Design patterns* are another. Your code looks as if it has been written by someone who just started programming, managed to learn JavaFX before learning to properly program in Java, and decided to make an app without having even the slightest idea on how to start such an endeavor. Your code will need many changes if you decide to add more functions.
Isn't the "future" usage raw strings?
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Wow, this is awesome! I have a Canon so I'll make sure to play with this :)
I didn't make this post asking for programming help in first place, I just said that if anyone want and had some tip about my code it will be well received. Now about my code, I completely understand the problem about static variables/functions, even in the next minutes I'll upload a new commit with that fixed and with almost no static elements. And what do you mean by hardcoded? I mean, I tried to use well defined constants (or variables) as much as I could, without writing it directly in the code, isn't that one part of avoiding hardcoded code? And yes, I accept my negligence about not using a specific design pattern.
Maybe not in Java... but I bet in C it's defined. And even if there isn't a strict definition there is how it has always worked. I have my opinion, you have yours, and they have theirs. It doesn't mean one is better than the other. They are certainly able to do what they like, but it seems somewhat frivolous to me and adds one more place to argue about how something should be done. I don't think we should turn switch statements into mini-functions.
Maybe not in Java... but I bet in C it's defined. And even if there isn't a strict definition there is how it has always worked. I have my opinion, you have yours, and they have theirs. It doesn't mean one is better than the other. They are certainly able to do what they like, but it seems somewhat frivolous to me and adds one more place to argue about how something should be done. I don't think we should turn switch statements into mini-functions.
I can see where you are coming from, but part of the reason they want to extend the feature is because of people’s gripes with it — namely `break` and fall through. With expression `switch`, you will be able to opt out of both.
To me those practically define what a switch is and so I would just say to people *don't use switch statements*.
If people like the way it is, they can just keep using it that way.
Except having alternate ways to use a fundamental part of a programming languages just produces uncertainty about how the code is working and arguments unless everyone does things mostly the same. Just imagine code that works perfectly fine except for quirks because one programmer decided to use a switch the traditional way and made a mistake.
Not really. It’s list like the `if` statement and the ternary expression. One is a statement and one is an expression. The difference in syntax will also help readers determine which it is.
For what it's worth using a ternary IF is substantially more compact than a switch statement and can fit a one or two condition if else onto a single line. It can easily become a real mess and putting any function calls in there could cause lots of fun if that function has side effects...
Yes, and expression switches will be more compact, too. Not one line, but considerably less. I’d rather have this: ``` int numLetters = switch (day) { case MONDAY, FRIDAY, SUNDAY -&gt; 6; case TUESDAY -&gt; 7; case THURSDAY, SATURDAY -&gt; 8; case WEDNESDAY -&gt; 9; }; ``` Than this: ``` int numLetters; switch (day) { case MONDAY: case FRIDAY: case SUNDAY: numLetters = 6; break; case TUESDAY: numLetters = 7; break; case THURSDAY: case SATURDAY: numLetters = 8; break; case WEDNESDAY: numLetters = 9; break; default: throw new IllegalStateException("Wat: " + day); } ```
`switch` expressions will be substantially more compact, just not one line. I'd rather see this: int numLetters = switch (day) { case MONDAY, FRIDAY, SUNDAY -&gt; 6; case TUESDAY -&gt; 7; case THURSDAY, SATURDAY -&gt; 8; case WEDNESDAY -&gt; 9; }; Than this: int numLetters; switch (day) { case MONDAY: case FRIDAY: case SUNDAY: numLetters = 6; break; case TUESDAY: numLetters = 7; break; case THURSDAY: case SATURDAY: numLetters = 8; break; case WEDNESDAY: numLetters = 9; break; default: throw new IllegalStateException("Wat: " + day); }
Oh this is nice, I didn't think of trying that! 
Sure, but that’s not really what we are trying to compare here. jpackage is designed to package a full application image, not just a custom JVM distribution.
Very cool! What the process of getting the EDSDK library from Canon?
This book https://www.oreilly.com/library/view/optimizing-java/9781492039259/ published quite recent by some folks from London Java Community. 
I am not sure if you are being sarcastic or not but stuff like these are just moving the goalpost. The fact of poverty isn't going away just because you renamed the problem. But it gets you political points because you 'cared'
Don't n what's exactly your experience of java but recommend to start your journey in java world from the book: "Thinking of java" and possibly later with "Effective java".
Thanks for those suggestions ill take a look at them!
Joshua Bloch's *Effective Java* is the best book on Java I've ever read, and is a worthwhile read for practically anyone beyond the "total beginner" stage. The third edition came out last year.
I'm not trying to compare anything here (not sure what you are comparing either). I responded to your statement that "jlink only works with fully modular applications", which is not quite true as you don't need to specify any application to get a runtime image. You also don't need to link the application code into the runtime for jpackage either. According to [JEP 343](https://openjdk.java.net/jeps/343) it can handle "legacy" applications on the classpath.
Avoid "Think in Java." It was written 12 years ago and the Java you'll see in the real world will look nothing like the Java you'll find in the book. Core Java, volume 1 or the more abridged "Core Java for the Impatient" are much more relevant introductions. Coverage of the most recent changes is nicely done in the just-released "Modern Java In Action." 
have you heard about Lombok?
Check here: [https://github.com/Blackdread/canon-sdk-java#get-edsdk-library-from-canon](https://github.com/Blackdread/canon-sdk-java#get-edsdk-library-from-canon) &amp;#x200B;
I know it’s not exactly what you’re looking for, but Lombok has some really good features (including builder generation).
RAML &amp; Swagger will both generate Java clients based on y'all. Jhipster &amp; JDL for repositories and spring controllers. If you could provide more specifics around you use cases, maybe someone could point you in a better direction.
IntelliJ IDEA has a couple of plugins to generate Java from JSON, and to generate JSON from a Java bean.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*