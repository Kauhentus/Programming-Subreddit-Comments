I would hire you out of the gate with an MS in Math. I value that degree. Java isn't rocket science (it's pretty straight forward compared to some other languages I've used). Day 1, I'd find a simple bug in the existing code base and have you fix it. I'd do this a few more times, and by the end of the month I'd have a good idea of how you'd play out as a hire. If you pick things up at a reasonable speed, are curious, are personable, and have a good work ethic I'd keep you on my team. That would obvioulsy be a junior role. If you want to walk into a big bank as a senior Java dev with no experience except an open source project...good luck.
[removed]
There are good reasons why Quasar does not expose a continuation class, and good reasons why that will change soon. I don't agree the user on the Quasar mailing list was lied to, and he/she was certainly not flamed, just briefly warned for rude conduct and even then continued to be treated with respect. Anyone interested in and/or knowledgeable about continuations and/or lightweight threads is more than welcome to join the new OpenJDK project, which will be created soon, where their input and help will be much appreciated. OpenJDK projects do not, however, allow hidden identities, and they are even less tolerant of rudeness.
Oh there's no doubt that a Master's in anything would help OP.. but there's also no contest in every job posting where a degree is a requirement, it's for CompSci or Engineering.
For better performance, better user experience (incl. integration w/ debuggers/profilers) and support for all JVM languages. Kotlin coroutines are Kotlin only, and Quasar requires specific support for each language. Neither integrates as well as we want with debuggers or other tools.
Just learning about Comparable &amp; Comparator. From what I read, use Comparable for when your comparing strings, int that are easily compared. And Comparator for when your wanting to create a custom compared.
Could you elaborate on your shudder for Azure?
Disclosure: I find the mere premise of trusting Microsoft with anything server side toxic. And Office365 is simply a pathetic fail... As for Azure specifically: * Was funny to participate in hackaton in London when it was launched where Microsoft bloke apologised: "Oh, btw, we are out of resources in the datacenter we are giving you resources to play with, don't be surprised if instances are shut down randomly" (that was some 5 years ago though) * Verified reports just within last 2 months that actually using &gt; 50% cpu in their instances is considered as abnormal condition and they will shut them down. * Using anything that encourages Microsoft market share should be a capital offence.
Come on man, what's so bad about Microsoft having more money? ;p What do you think of AWS vs GCE?
Like said in the official documentation : "You can use the jlink tool to assemble and optimize a set of modules and their dependencies into a custom runtime image.". So, yes you can use jlink to create your own application with all the modules you need from the JDK to execute it later.
Thanks a lot! I'm currently quite happy in my role, my boss is extremely experienced and knowledgable - I would want to stay here for another 18 months or so. This should also give me time to pick up Java or whatever else I might need - when I start looking I will get in touch! 
This is the Java sub-reddit, not a hipster JVM-language forum.
So? You gotta be open for new things happening on the JVM, it's not only Java. If you're not, please just ignore it 
It is not so much an embedded JVM as it is a custom Java distribution that bundles application modules with only the required system modules. Much like the JDK and JRE are different distributions (without application code, obviously).
re: embedded? No, as mentioned, it is more about trimming the binary distribution. [This link](https://twitter.com/mreinhold/status/882644292036026368) shows that the JDK itself has been sorted into proper modules. That means, in cases where we explicitly state each module dependency, that the JDK runtime distribution can be trimmed of "dead weight". i.e. smaller size, as stated [here](https://twitter.com/mreinhold/status/883401747640664064). [Here](https://youtu.be/eALw4P_0O4k?t=36m6s) is an excellent YouTube video on the subject, and [here](https://github.com/codetojoy/easter_eggs_for_java_9/tree/master/egg_20_JLink) is a modest example of mine on GitHub. A related advantage (in the long term, beyond JDK 9) is an AOT compiler that compiles system modules to native code. JDK 9 has an experimental AOT compiler for Linux x64 (I believe). 
Jlink allows you to build a JVM runtime that only contains the module your application needs. E.g. if you only use java.base you can strip the JVM down drastically to about 15 - [18 MB.](http://mihosoft.eu/?p=1209) You can distribute that JVM alongside your application and run it (aswell as any other application that only needs java.base) and the user doesn't have to install Java themselfs. However the JVM is not "embedded" as in thightly integrated with your application.
Thank you guys for the upvotes. Really appreciate it! ☺️
I meant embedded in the context as embedded Jetty/ embedded SQL. When you deliver your app with Jetty / SQL as part of it without the need to install it separately on the running env.
Thanks. In the presentation I seen a great benefit that was mention is the ability to run java apps on IoT devices because the apps will be now self contained, without the need to have JRE on the env.
Embedded custom-JVM? :)
Hey, thanks! Just going through all the comments and feedback - just wondering, which Oracle cert are you exactly talking about? I had a look on their website and there are sooo many java related ones.
When I did it it was SCJP but it seems that material has split to OCAJP and OCPJP. I'd train for both.
Ok - thank you!
AWS wins for breath of services and reliability. Cripples things on purpose based on pricing tier. Good for business. GCE wins for far friendlier/simpler pricing model, higher performing and simpler underlying infra and far far far more responsive admin interfaces. Network reach is nicer too. Good for fun. My personal sites are spread across AWS for frontends and GCE for hosting API's.
Nice! I hear there's still a small community out there. The ability to save the entire program state to disk and then load it back up again is crazy, as well as the LISPish metaprogramming. I group it with Erlang as "true" OOP (AKA actor model), which I often wish had a chance to develop further.
Then yes. The JVM doesn't need to be separately installed. Though that isn't really new, you could distribute the whole JRE before. What's new is that you can strip off everything that you don't actually need (e.g. Corba).
where you get the embedded from
Your blog post isn't about a "new thing happening on the JVM", it's about your Kotlin library. Anyone already interested in Kotlin is perfectly capable of subscribing to the /r/kotlin where you've also posted it, or /r/programming or /r/coding where again you've also posted it. Anyone not interested in Kotlin is unlikely to be swayed by your blog post.
Kotlin is that "new thing" I was mentioning. My blog post isn't about the library, it's about writing internal DSLs in Kotlin, that lib is just a tool used as an example. In my opinion, this subreddit is suitable, too. Java is more than a programming language, it's a platform and Kotlin is a language for that platform. 
Now, were are the people who are going to fix the whole "no TCO" fiasco?
So, Oracle basically hired a guy who hacked fibers into the JVM to properly include fibers in the JVM? Like when they got Stephen Colebourne to write the java.time package? That sounds great! But, isn't Ron Pressler killing his company?
I seem to be missing something. You say &gt;Take a moment to understand the above code snippet. Since we’re calling future.join() when all the futures are complete, we’re not blocking anywhere :-) But every example ends with a call to someFuture.get(), which blocks. 
https://stackskills.com/ is pretty good and inexpensive. You can grab whole courses for 30ish bucks. And as others have recommended try getting involved with an open source project. Contribs help on the resume. 
Thanks a lot for this. We've been working with CompletableFutures a lot lately, and I think sharing this post will help many of my teammates get a grip on the concept.
&gt; every example ends with a call to someFuture.get(), which blocks It doesn't block if the future is completed.
If the task completed that quickly you wouldn't need a separate thread in the first place.
No it's not about how long the task takes. The code calls `allFutures.thenApply`, passing it a callback. No matter how long the futures take to run, on multiple threads, the callback isn't run until they're all finished. Then the callback runs `future.join` to get the values from each future. The calls to `join` don't block because we don't call them until we know the future is already complete, because `thenApply` has returned. As the comment says: ``` // When all the Futures are completed, call `future.join()` ```
And it also says &gt;The join() method is similar to get() So presumably it blocks as well. What I am trying to understand is how a long running task can update the GUI when it completes (say 10 seconds later). It cannot run on the JavaFX Application Thread, and it cannot update the GUI from the background thread. So it must run from a callback and presumably call Platform.runLater(). No?
Picocli 0.9.8 is now released. It adds annotations and convenience methods for versioning. Also, subcommands can be registered declaratively with annotations now. Good to see many contributions from the growing user community! Next up: command line completion.
Yes! You need to call `Platform.runLater()` from the callback for updating JavaFX GUI. Also, If you're working with JavaFX, it would be more convenient to use a `Service` and update the GUI in `setOnSucceeded()` handler. Check this out for more info on that - https://docs.oracle.com/javase/8/javafx/api/javafx/concurrent/Service.html 
&gt; But every example ends with a call to someFuture.get(), which blocks. The examples are very simple and use `get()` method to retrieve and print the result. However, you wouldn't use `get()` method that often in practice. For example, let's say that you've written a REST API in Spring, and you want to return the response from your controller asynchronously. You can process the request using CompletableFutures and then return a DeferredResult from your controller like so - public DeferredResult&lt;String&gt; asyncAPI() { // 1. Create a CompletableFuture and Process the request // 2. Set the API response DeferredResult&lt;String&gt; deferredResult = new DeferredResult&lt;String&gt;(); future.whenCompleteAsync((result, throwable) -&gt; { if(result != null) { deferredResult.setResult(result); } else { deferredResult.setErrorResult(throwable.getCause()); } return deferredResult; }); } 
Hehe nice!
&gt;A Detailed Guide &gt;The examples are very simple You can't have both.
Yeah! You're right :) But, you need to use simple examples for explaining such topics, otherwise, it'll be too overwhelming for readers.
Nice. Looking forward to having bit of a play after work..
I'm not sure I would call any of your examples simple :) But if you end every example with a blocking call, maybe you should point out that 'this is not how you use it in real life'. Actually, what would be really good is a working, real-life example that people can use. Forget all the calls to sleep() and get() and show something useful. You could even have a warning - 'Now this is a bit complicated, so don't be scared...'
Thanks, I'll look into that.
This is a nice idea. I will write a new post with a real world project (maybe an async rest API, or a multi-threaded web crawler) to demonstrate the usage of CompletableFuture APIs. 
good job man! Without your post I would not know how to use it
As the sidebar says this subreddit is for "News, Technical discussions, research papers and assorted things of interest related to the *Java programming language*". Obviously topics that relate to the JVM specifically will be of interest as well, but your article does not qualify - it's about writing DSLs in Kotlin. I'm assuming that anyone who gives a monkey's ass about Kotlin is actually capable of subscribing to /r/kotlin, but given the level of fuckwittery prevalent in the Kotlin community I'm not sure that's entirely true.
&gt; I've given up waiting for the owner to answer my pull request It's definitly clear you have put a lot of effort in your PR. But sending a pull request with 98 commits and 111 files changed is not easy for the maintainer to review. The PR was opened 26 days ago, that's not too much for the maintainer to give an answer taking into account the size of your PR. Many OSS maintainers have a full time job during the day and a family to take care of outside work, OSS contributors should take this into account. Anyway, this is supposed to be a constructive comment regardless of the content of your PR. 
FWIW I found the simple examples very helpful to understand all of the features presented. Of course, a Real World ™ example (maybe one which makes use of DeferredResult too?) would be really nice for the next post, but that doesn't mean the examples in this one are useless :)
Thank you. Glad that it helped you :)
A specialist is better at the thing he's specialised in than the generalist. Who would've thought... :)
Are you saying a jack of all trades, is a master of none??
But better than a master of one
There exists monoglot technology stack though to lower the overhead of switching layer for full stack developers. For example, * Clojure + ClojureScript * Kotlin * Vaadin Not everyone is using AngularJS.
If you're using something like Spring Boot or Play Framework, you can just wrap the result with CompletionStage. You don't need DeferredResult anymore.
But a specialist is better if he understands the context in which his code will operate.
Thanks for adding this. Yeah! From Spring Boot 1.3 onwards, we can directly return a `CompletableFuture&lt;T&gt;` or `CompletionStage&lt;T&gt;` from the controller.
Very interesting paper. Looking forward to read through the formalisms to see if it matches my more intuitive perception of how to design such APIs. 5 years ago, I've written a less formal piece on "fluent API" (more specifically: internal DSL) design: https://blog.jooq.org/2012/01/05/the-java-fluent-api-designer-crash-course/ It led to Peter Verhas' fluflu library, which generates the API from an annotated implementation: https://github.com/verhas/fluflu Of course, as someone who favours hand-written parsers, I obviously also favour hand-written internal DSLs 😉
No but a full stack developer can build more things. A good fs dev can lead a team of specialist to build something amazing.
Of course. What companies generally are looking for are people with [T-shaped skills](https://en.wikipedia.org/wiki/T-shaped_skills). Most companies that hire for "Full stack" devs specifically typically do so because they don't want to hire multiple specialists.
**T-shaped skills** The concept of T-shaped skills, or T-shaped persons is a metaphor used in job recruitment to describe the abilities of persons in the workforce. The vertical bar on the T represents the depth of related skills and expertise in a single field, whereas the horizontal bar is the ability to collaborate across disciplines with experts in other areas and to apply knowledge in areas of expertise other than one's own. The earliest reference is by David Guest in 1991. Tim Brown, CEO of the IDEO design consultancy defended this approach to résumé assessment as a method to build interdisciplinary work teams for creative processes. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
I'm still confused by what this means. Full stack is a web thing, right? I've just never seen it used i other areas.
Surprised they never contacted you, as jOOQ is one of the first examples they bring up. I just found it reading [Grigore's proof](https://arxiv.org/pdf/1605.05274.pdf) on Generics.
Article is saying what, that it's hard to know all of the layers / stacks in the call chain? No disagreement there. Should developers, and in particular new developers be responsible for the full stack? No, of course not. You start small. Should architects or system designers aspire to learn all of the layers, yes, if they are any good at it they will.
Full-stack is often used when companies require a guy who can do back-end and front-end. It's also used when they need developers with the capacity of **learning** and develop in any language and architecture. It doesn't mean you have to know everything since before, just be open to learn and work in something new to you. In both cases you need a lot of experience.
Honestly, for any kind of non-trivial asynchronous process I find myself using reactive streams instead of CompletableFuture - I find that they provide a higher-level abstraction that works just as well, with some features that CF lacks (major one is having different thread pools for different code paths).
Do the same people really do back end and front end in any area besides web stuff? I'm entirely a back end person working on high perf/low latency complex systems and I've had to do a lot of other things like simple gui work or data munging but I've never heard of "full stack" outside of web kind of work. I usually ignore and job deception that says full stack because i always assumed it was mostly for front end people who can do some glueing together. Not really back end. Maybe i have the wrong idea of it then. :/
Java is used heavily in web apps. Its likely that you will need to have a basic grasp of web fundamentals including Servlets, JSP, HTML, CSS, and Javascript.
[You can](http://www.reactiongifs.com/r/but-why.gif). I think it's funny you're using a huge platform framework like Netbeans RCP (Which is great. I've written a few apps using it) and *this* is what you concentrate on for reducing memory use.
&gt; and this is what you concentrate on for reducing memory use To be fair, not all data sets are the same. I once worked on an application that needed to read a data store that contained approximately 3 terabytes of data, holding huge (gigabytes) of it in memory at a time. We had to be very choosy about heap usage with that application. :)
There might be people NOT YET giving that ass. Sorry but I'm still not getting your problem. 
I found the new [Gradle guide](https://guides.gradle.org/building-java-9-modules/) to be very useful, but I thought I would share an example Java project that uses JDK 9 modules and builds with Gradle 4.1. It has automatic modules (see diagram), the tests pass, and it runs as a Gradle 'application'. I hope it helps others with JDK 9 and Gradle. The app is a simple bidding game, derived from a board-game called Rack-O (but quite different).
It really depends on how you want to access that data. Take a look at https://jankotek.gitbooks.io/mapdb/content/performance/
I need to make it look the same on all platforms, need plugins(also considered Eclipse), portability but also fast in even not so terrible memory constrained computers but somehow slow, QT is also an option but then it's C++ and I'm not sure about plugins (because of ABI compatibility) and QT's way of doing things but I know it will still be less overall ram consuming.
How much work would it take to upgrade Play ? It's currently 2.2, many things have changed. Congratulations on finishing this huge project, I guess this took some time ... Keep up the good work.
This project is a monstrosity. It has a lot of repos and it is hard to understand * what is the generator * what is the template * what is the finished project The README files are essentially a "brain dump" of the developer, without any structure at all. The repos contain jar files (!!!) like we are still in 2003 https://github.com/vangav/vos_backend/tree/master/lib I could go on and on, but I don't think it is worth it. &gt;great templates &gt;template services features db tables code: total code: generated &gt;instagram 7 47 52 67,715 + 190,996 238,465 (92.17%) 240K lines of code for instagram integration? Do I read this correctly?
it looked to me at a quick glance like it was an instagram clone
+ the generator takes a json config file like: https://github.com/vangav/vos_backend/tree/master/vangav_backend_templates/vos_calculate_sum and generates most of the code needed for the backend service (request/response code, param validation, request handling framework, database clients, database scripts, ...) + the built-in utilities (e.g.: push notifications, authentication, graph api, ...) + templates are examples of the json config files used to generate the other projects in the repo (calc, geo, analytics, whatsapp, instagram, ...) -- they are meant to help give better understanding of how to build and use the json configs + a project is finished when the request-to-response logic code is added after the generation step; like in this quick start example --&gt; https://github.com/vangav/vos_backend#quick-start-example-calculate-sum + i'll keep enhancing the README files, please let me know if there's something specific or better an example from github to follow -- that would be awesome + the idea behind including binaries (play, cassandra, third-party libs) is to make it as easy as possible for even novice software engineers to pull off a great backend service in no time -- the same philosophy behind code generation, and so on maybe the instagram is a bit ambiguous - it's NOT an API integration; it's an instagram backend service **features:** - facebook login, email login, oauth 2 - setting/updating/getting user info (name, loc, last active time, facebook info, profile pic, ...) - follow, unfollow, get followers, ... - post photos - like, unlike, comment, delete comment, .... - get posts by feed/user, get likes, comments, ... - explore: get top users/posts (by loc, country, world-wide) - search - periodic jobs to retry failed helper-services processes and to rank users and recent posts - a dash board offering full-analytics, logs, per-user logs , .... - a full-coverage test service - a bots service to simulate usage **services:** - main - dispense - jobs - worker - dash board - test - bots **size:** - 47 api entry points - 52 database tables that's why ~240K lines of code needed to be generated + ~20K lines of code to implement the request-to-response logic for each api entry point I recommend taking 5 min to do the quick start example: https://github.com/vangav/vos_backend#quick-start-example-calculate-sum and I believe that will clarify it :)) many thanks for your feedback, plz msg me whenever you have any questions and till i manage to have better tutorials, i'm offering free consulting as much as u need happy day 
exactly :) or better an example/template of how to develop a photo sharing app's backend services and instagram name/features were used to make it simpler to understand as you go through the tutorials please refer to my comment below for more on that point plz msg me whenever you have any questions; i'm offering free consulting as much as u need happy day
code generators have always been a flashing red light to me.
Upgrading play is on top of the todo list; but no need to wait as it will be done in a way that doesn't impact your work at all. Also play framework's versions' change log has zero conflicts with how it's used in vangav backend. When we started vangav Dec 2013 we searched for an open source backend since it was obvious that millions of developers already did 90+% of the work we were about to do. But we didn't find any so we developed our's. 2016 we had time to add the generators to make it as easy as possible for everyone to use it and open sourced it about a year ago. During that year it has been successfully used by few startups and during that time we kept building and enhancing it, now we hope everyone knows about it and finds it useful :)) Would be awesome if you shared it with your friends who may find it useful. Many thanks Please let me know if you have any questions, free consulting as much as you need happy day
me too :D for vangav backend's; think of it as: + generates all the code you copy and paste over and over for the API and database clients + also altering the database as I develop used to be a pain point as I had to alter 1) client code 2) cql scripts 3) wiki -- but with the cassandra updater https://github.com/vangav/vos_backend/blob/master/README/03_generated_rest_service_structure.md#cassandra_updater you only need to update the json config **also:** + using the code generators is optional, it's just a great time saver + this section shows how to go without code generation ;-) https://github.com/vangav/vos_backend/blob/master/README/00_expanding_calculate_sum_example.md#expand-calculate-sum-to-calculator-without-regenerating-the-service I recommend taking 5 min to do the quick start example: https://github.com/vangav/vos_backend#quick-start-example-calculate-sum and I believe that will clarify what I meant above Many thanks Please let me know if you have any questions, free consulting as much as you need happy day
I would make a suggestion for you to advise people to always pass a thread pool. Using the default global pool is often not what you want when running async tasks. It's a really poor default choice in my opinion.
Yeah! The default thread pool is good for demos and examples. It is not a good idea to use the global pool in real projects. I will incorporate this suggestion in the blog post. Thanks :)
&gt; the idea behind including binaries (play, cassandra, third-party libs) is to make it as easy as possible for even novice software engineers to pull off a great backend service in no time -- the same philosophy behind code generation, and so on You lost me here. Showing novice engineers that having jars in the repo is a good idea is beyond me. &gt;i'm offering free consulting as much as u need Ok that explains a lot for the complexity. Thanks but no thanks.
The problem is people just copy paste the examples into their projects!! 
It's almost always used in the context of web development. Back-end in this case would be Java, while front-end is almost always JavaScript.
@GuyWithLag, I haven't worked with reactive streams. I am exploring it now after reading your comment :) Can you point out any good resources with practical examples for learning about reactive streams?
Oh the days when I would spend 40 hours a week building complex UIs in Swing. I was a world-class Swing expert. I could teach a class on "GridBagLayout as a second language". I did that, and only that, for about four straight years back in the day. I was a proper specialist. But since then, I've done everything in the stack. RESTful web services, ORM with Hibernate and JPA, Java EE apps on WebSphere and GlassFish, Spring "everything" on Tomcat. JUnit tests. And just enough AJAX and Javascript and jQuery to get myself in trouble. Fact is, I'm not nearly as "expert" in any of those things as I was with Swing. But I'm extremely employable because I'm a resource that can be dropped into any aspect of the development cycle, in any component of the application. And I can get up to speed and productive fast, and be ... at worst ... 60% to 80% as productive as the "expert". Each component of the application might be 20% of the entire project. If you can afford to have "experts" in each of the five areas, fine do that. But do you really want those guys sitting on the bench when their part is finished? Or do you want to deploy them to another area.
ScalaCompile build cache \o/
&gt; the generator takes a json config file You're not the first person to make the mistake of moving code to 'configuration' (where you have no type system) and you won't be the last. I hope any newbies that see this at least listen to the advice of actual experienced devs here and understand that this is a bad idea. And you're a complete beginner too, as evidenced by how you handle dependencies. Being a beginner is fine. Not knowing you're a beginner is going to be bad for your career though.
Try to never ever use URL, it's a deprecated class with a lot of wonky behavior, use URI instead. Officially it's not deprecated, because a lot of code still uses it, but it's pretty awful.
Oracle
You might be able to make this work by registering a custom URL stream handler factory: https://stackoverflow.com/a/26409796/250076 Unfortunately this allows for only one custom handler so if you're using a framework like apache CXF you might find one is already registered.
&gt; There is also a Permanent Generation, but we won’t cover it in this post. Well yeah, didn't Java 8 do away with the Permanent Generation?
Not a language problem, but i dislike all the AbstractFactroryProxyBeans in Enterprise
Not specific to Java, but I hate the existence of null :(
One JVM global instance of URLStreamHandlerFactory? No thanks. Just constructing a URL passing it a URLStreamHandler works fine. Except when people assume that converting to string and back again without passing the correct URLStreamHandler works. In my real world problem, I just copied the data behind the URL to a temp file and gave CXF the URL to that temp file.
people complaining verbosity is a disadvantage...
That this question pops up every couple of weeks.
/r/rust
It's an odd API. You would expect it to be possible to register a custom handler for a given protocol, instead we only get a single global handler for all protocols. If you haven't already, consider opening an issue with CXF over their assumption that converting the URL to string and back is safe. You're probably not the only person who has/will try this.
Lack of value/struct types. ([Soon?](http://openjdk.java.net/projects/valhalla/))
r/kotlin
Lack of `&lt;this&gt;` type, specifically as the type of the return value of a method. class A { private int x = 0; public &lt;this&gt; setX(int x){ this.x = x; return this; } } class B extends A { private int y = 0; public &lt;this&gt; setY(int y){ this.y = y; return this; } } new B().setX(1).setY(2);
people thinking it is slow
Lack of multi-line strings: String query = "select distinct p " + "from Post p " + "join fetch p.comments "; [My blog posts code examples](https://vladmihalcea.com/2017/08/02/how-to-optimize-the-merge-operation-using-update-while-batching-with-jpa-and-hibernate/) will look so much nicer with multi-line strings.
checked exceptions
Type erasure.
Is it not? Why?
Wouldn't you rather convey more information than less information? Sure in Java it can get pretty hectic with the huge amount of indirection (cue SupplierProxyFactoryProxy, etc.) but for most cases having something like: int daysSinceSomeTargetDate; is much clearer than: int days; or even: int d; Naming identifiers are for our benefit - we should take advantage of it, shouldn't we?
So much this.
[removed]
When people complain about verbosity I don't consider it to be with regards to long names. I think it's now just a go to answer but originated around things like try-catch-finally blocks, collection initialisation and generics - all of which have been addressed in some way.
you can think of https://github.com/vangav/vos_backend/tree/master/lib as your local maven repo vs what actually becomes a part of the generated service like here https://github.com/vangav/vos_geo_server/tree/master/lib or here https://github.com/vangav/vos_instagram/tree/master/lib depending on your generator's config that's similar to downloading cassandra, play, ... and the downloaded project has its binaries with it maybe that sense of complexity comes from it being new/relatively-big; i didn't start by telling myself "let's make it more complicated" xD it's up to you to give it a shot and reevaluate cheers
Checked exceptions and most coworkers not using post Java 5 features, but I guess that's a different subject
I cannot stand that everything has to be a class. Creating dummy classes with static methods feels like such a hack. When you use languages like Go or Python which allow you to write functions outside of Type/Class definitions, it's so much more flexible and just "feels right".
So what would you replace it with?
your example is wrong, it reduces the amount of information you get from reading the code. Verbosity implies that the information is the same, except in one case you have to read more.
&gt; moving code to 'configuration' not sure if it's "moving" when ~4.5 of simple config generates ~240K code + ~3.5K scripts in the case of instagram --- that makes one at least 54x faster if we assumed they write code as fast as they fill in the simple generator's config &gt; no type system + I guess there's a missunderstanding here; vangav backend's generator has a syntax and logic verifier for the config files that points out a problem if any and explains how to fix it before proceeding with generation. Also config types are very limited as shown here https://github.com/vangav/vos_backend/blob/master/README/04_rest_service_config_structure.md + moreover: although i believe filling the config is much easier than designing/writing code; one would need to make orders of magnitude more errors in the config than they would in code for it to make sense to spend 10x more time writing all that code
OMG yes. My new company have some tests in Groovy def thisString = ''' this is a multiline string woop woop ''' This is by far my favourite thing about Groovy.
Not enough functional programming features.
It seems to compare favorably or equally to almost every language besides C/C++
The existence of primitive types that have to be autoboxed
I like Java a whole lot more since 1.5. I'm actually happy with most of the things people complain about (e.g. type erasure, checked exceptions, everything-is-a-class). Java the language is a solid piece of engineering that will last, and I feel good that the code I write in it will continue to run with minimal modifications 30+ years from now. Given all the other JVM languages providing the rest of the syntax sugar that people want, I don't want many more changes to Java-the-language. About the only significant thing I wish we could have now is AOT native compile. Think how nice it would be if Debian had native i386/amd64/arm for every java package, with near-instant JVM startup/warmup time. 
and of the most popular languages it is much closer to C++.
Having to generate equals/hashcode/tostring for data classes. Obviously the IDE does it, but it's still boilerplate that can get out of sync. 
/u/Tilkin made a good point that I only mentioned names in this case, but when you read critisism of java, a lot of it happens to mention names - that is what I naturally thought to mention when I read the comment. Their answer is more accurate for what you think verbosity means. Although I would argue that my example is not really incorrect, just incomplete. Verbosity - using more words than needed. It doesn't imply anything about what information you gain from those words. In programming languages, you don't *need* to name your variables something meaningful, we just choose to because it makes our lives easier.
Probably something like a nullable type. Kotlin and rust do this and it is awesome
thats not the complaint,its stuff like Long five = new Long(5L); whereas c# is var five = 5L;
It can be handled better,C# for example you must make the decarlation nullable explicity, otherwise that var can never ever be null. Works well. Int i = null; // won'twork Int? i = null; // will work
Many other programming language have been offering multi-line strings for a very long time now. It's time to have them in Java too.
And what is the purpose in the real world scenario? For example, do you define all REST responses as possible NULLs?
Such types don't solve anything, just add another layer of complexity.
 System.out.print("this is just excessive"); Compare to print("this isn't as excessive");
That certainly would be nicer, but in case you're unaware you can kind of do it with something like: public class ABase&lt;T extends ABase&lt;T&gt;&gt; { public T setX(int x) { return (T) this; } } public class A extends ABase&lt;A&gt; {} public class BBase&lt;T extends BBase&lt;T&gt;&gt; extends ABase&lt;T&gt; { public T setY(int y) { return (T) this; } } public class B extends BBase&lt;B&gt; {} .. it feels kind of dirty, but I've done it for the sake of nice APIs, particularly ones generated for me.
Looks like Swift
They do solve something. At any given moment you know whether a value could be null. Before the possibility of a null value is accounted for you cannot use the value. I have been using Kotlin for half a year now and implicit nullability is a very nice thing to have. In Java you either insert lots of null-checks or you hope and pray that you don't get a null value. Ignoring the possibility of a null check is lazy and irresponsible since it could lead to unwanted and undocumented behaviour. Java is a statically-typed language and its type system offers safety, but not in the case of null. If you are going to throw away the safety that a proper type system has you might as well just use a dynamically typed language.
Optional.
Are you still using Java1.4 ? Most IDEs will complain about the useless boxing. You can be needlessly verbose in any programming language...
No, it's actually: Long five = 5L; (in java)
Yes, I have one tool I wrote that generates this type of thing for some stuff I use. `&lt;this&gt;` type would be way easier.
Top level function declarations are what got me hooked on r/kotlin
Constructors. I wish I could name them. It's irritating that `this(...)` or `super(...)` have to be the first call in the constructor when I want to do validation first. The fact that a not-completely-initialized instance can escape a constructor seems like a mistake, not a useful language feature. Same with invoking overridable methods from the constructor given the problems that can cause. It shouldn't be possible to create instances of my classes without going through their constructors, but serialization and cloning both make that possible. Many of my constructors take a bunch of properties and assign them to member variables of the same name and type -- I wish there was shorthand for that (on the class author side) and a way to make that better on the caller's side as well (such as object literal syntax / name+value pairs).
It's close to 30 years old, but I still tend to like Rob Pike's comment on variable naming: &gt; Length is not a virtue in a name; clarity of expression is. -- https://www.lysator.liu.se/c/pikestyle.html Long names can be useful in that they can describe the meaning of a variable, but they can also get so long it's difficult to see and understand the structure of the underlying code. At that point, they can really be harmful. It's also worth pointing out that naming suffers from some of the same issues as comments - there's no enforcement that the name is actually indicative of the meaning.
They don't add a layer of complexity - the complexity is already there! Kotlin's null handling just makes the complexity visible and easy to handle.
Swift actually looks a lot like Kotlin (kotlin predates swift by a little bit): http://nilhcem.com/swift-is-like-kotlin/
To have `Optional` without a performance penalty, Java would need value types (planned in project Valhalla).
A close contest between checked exceptions, the need for semi-colons, and not being able to return multiple values from a method. EDIT: for the life of me I have no idea why this is getting so many down votes. Maybe because I picked 3 instead of 1? In that case, of those three, my absolute least favorite would be checked exceptions
`System.out.println(" ")` &lt;--Too effing long to print to console.
Not sure what you mean by that, but yeah, in Kotlin if an external component (library, remote service, ...) potentially outputs a null value, it will explicitly stated, and you'll be forced to sanitize it before feeding it to your system: the compiler throws an error if you don't do a nullcheck before assigning it to a non nullable variable, or calling method/accessing a field on it. For example, with methods defined this way : fun callExternalWebService(): String? fun processAndStoreResponse(response: String) This code won't compile : val response: String? = callExternalWebService() processAndStoreResponse(response) Forcing you to think about a way to deal with a null response : ignore the response and don't call the function, call it with a default value, throw a (more meaningful than NPE) exception, ... The point is to make you think ahead about potential nullability issues, and limit the spots in your code where you could get a NPE.
@AnnotationsEverywhere I think there are a few good use cases but they are seriously abused. It makes it incredibly difficult to track down the actual code being executed. Stack traces get littered with tons of proxy classes. I think many years ago they were a reasonable option do to some language limitations. There are many better approaches today but everyone just keeps swinging the same hammer.
Being explicit about your variable declaration gives you more visibility to the type of information it holds. Although this works, my preference is actually how Ceylon handles null. It's actually its own type, and is the only type that can be assigned null by default. That in combination with union typing makes for very straight forward method signatures. Foo doSomething(String name) You would know with absolute certainty that this would return a Foo. Foo|Null doSomething(String name) But here, you would know that the method could also return Null, and your caller has to handle that before resolving Foo. Ceylon also implicitly casts your variable in if blocks that you do the is &lt;Type&gt; check on.
Fair criticism. But a strange one to level at an Object Orientated language... Also, Java 8. Not the prettiest of implementations, but the streams api is wonderful (imo)
There have been some strides, but Python and C# are ahead in this regard (and they're object oriented, predominantly) Java will have more in the future thankfully 
Sort of like speed bumps, slows people down and reduces accidents.
* Type erasure * Lack of generic types on enums. See [JEP 301](http://openjdk.java.net/jeps/301) * Lack of union typing
Well, my rule of thumb is that you should do checks ALL THE TIME without any exceptions. Enforcing it at a compile time is a good idea. But people are usually taking about `Optional` which doesn't make any sense to me.
So you end up having |null all over your code, null checks still in place.
Programming dilettantes whining about how it requires more education and work than the scripting languages and small projects they are familiar with. 
And what? Optional doesn't make your code any better, you still have to check for empty values. Nothing changes, just additional complexity for no reason.
I confused nullables with optional, sorry.
No, you actually have less null checks. Only in places where it makes sense to return Null. Otherwise you would know with certainty that it doesn't. In Java, unless you use Optional, you don't know whether your returned object is null, so you technically *always* have to do a null check. This also prevents null pointers at compile time.
heap/gc tuning
but in C# you also have `var guessWhat = lookItUp();`
Dealing with SSL HTTP requests. In say, Python or Ruby you just make the request. In Java it's a convoluted nightmare. 
try sqlite: https://github.com/xerial/sqlite-jdbc
That has honestly never bothered me much, and with static import it doesn't bother me at all. The class is just serving as a namespace, which I'd want anyway.
Serialization.
This is a good one. At least they ARE autoboxed, but it definitely is one of the lingering sources of unintuitive behavior in Java. Also one of the more subtle sources of memory problems.
Do you write C# code with vim ? Because, you simply put you mouse pointer on the variable and Visual Studio will tell you what type is it. Plus if you modify the return type of lookItUp() for example changing a int to a long you don't also have to change it in other 1000 places in the code. 
Especially in combination with lambdas.
Legacy -- things that could be done better if we started over, like getting rid of type erasure, adding primitive collections, and making things immutable that should be, and adding immutable arrays and language-level support or immutables. Some of this has already been addressed like java.time, and hopefully more of this should be fixed by Java 10, but there will still be a lot of stuff laying around that's not quite as they would have designed it from scratch today. Side note: what's with Vector and Hashtable still not being formally marked @deprecated? Who is using these in 2017? Actually, legacy is my second-least favourite thing about Java, but I won't get started on the first.
Correct
Try private static final Logger LOGGER = Logger.getLogger(ClassName.class.getName()); LOGGER.log(Level.FINE, " ");
Yeah not a fan of Optional either, it clarifies the need to nullcheck but it's even more verbose and nothing prevents a dev from potentially triggering a NoSuchElementException... I really hope Kotlin will continue to catch on, it's so much more concise and fun than Java, without cutting you off from the ecosystem.
&gt;Think how nice it would be if Debian had native i386/amd64/arm for every java package That would be a nightmare of dependency conflicts. AFAIK having multiple versions of the same package installed is not recommended in Debian.
No default params..
Well, I don't know about you, but I personally know only two scenarios when I can not have NULL: 1. I'm signing constructor execution result to a variable. 2. I'm using a factory. Everything else, like DB operations, external API calls, network stuff, etc, might return NULL. My non NULL scenarios can be detected by better linting during compilation, everything else should require null checks during compilation. No need to introduce any new types or syntax structures. There can be an exception for libraries which don't know what's incoming in arguments, that can be easily solved by an existing `@NonNull` annotation.
&gt; Do you write C# code with vim ? Because, you simply put you mouse pointer on the variable and Visual Studio will tell you what type is it. People read code more often than they write it, and there are good odds they aren't reading it in a fully operational IDE. (File on disk, github, etc. are all good ways to read code.) &gt; Plus if you modify the return type of lookItUp() for example changing a int to a long you don't also have to change it in other 1000 places in the code. 1. It would concern me if making a change to a return type required changes to that many call sites. (There are places where it's warranted, but not often.) 2. `long` is different enough than `int` that silently ignoring all the places where a variable type changes from one to the other is rather risky.
Verbosity
do you regularly want to return multiple values from a method?
That's not true. Something like that is planned for C# 8, but all reference types are allowed to be null, and value types can be null if boxed in `System.Nullable&lt;T&gt;` (`T?` being a shorthand for that)
No unsigned types, no named method parameters, and parameter default values.
Not everyday but frequently. When I first started to learn Groovy a few years back it is a feature that didn't interest me at first. Then I used it a few times and it really came in handy, now I really miss not having it in Java. Kotlin also allows it.
Like Optional? 
Lombok is a godsend for this.
If I remember right, you can type "sout" and then hit tab for it to shortcut it to that statement.
Installation and class pathing issues. Seriously. It drives me out of my MIND. Stylistically I can't abide the "30 nested levels of abstract factory" horseshit. But that's not the language's fault so much as that of Cargo Cult Design Pattern fetishists. I mean it's not like I have to write code that way. 
Lack of overloaded operators. Doing arithmetic on vectors in libgdx is a lot more cumbersome than in C# game libraries/engines, especially when they can't be value types.
Being the guy that complained about Type erasure—I wholeheartedly agree. It's just something I dislike when using the language, while still understanding the reason why it's there. At some point, Java's going to have to do a bit of a break with the past though.
The Java Platform Group is looking into allowing operator overloading for numeric types. The pain will become even more obvious when Value types arrive on the scene.
I found James Gosling’s reasoning as to why there are no unsigned types in Java to be valid. It is mentioned [here](https://stackoverflow.com/questions/3108297/james-goslings-explanation-of-why-javas-byte-is-signed).
Reification is being added to Java, but it most likely won’t be exposed at the language level. Specialized generics will make classes like `ArrayList&lt;int&gt;` reified, though.
Now if we could just get operator overloading (a la Scala), BigDecimal and BIgInteger might not be such a pain in the ass to work with. Stateful mixins/traits would be nice, too, and would help reduce code duplication since we wouldn't have to spew out quite so many delegate calls. (Again, an "upstream" Scala feature.) Basically I want frigging Scala with full Hibernate/JPA and JAX-RS support. Heh.
I have read this many times, and I don't agree. It is absolutely insane to claim that unsigned makes things confusing, especially when we're talking about a higher-level language like Java where any possibly "confusing" things are hidden from developers. Because of the lack of unsigned types, Java's own API for indexing into an array allows negatives, which then throws an exception. That is ridiculous to me. *edit* What specifically about this makes this argument valid for you? I find the idea of "unsigned is too complex for Java devs" to be insulting more than anything.
The Java Platform Group looked into adding tuples to the language, but they decided in the end that value types will end up being more useful to developers.
Expressivity. Or rather, the lack of.
The Java Platform Group is looking into adding data classes. Brian Goetz talks about it [here](https://m.youtube.com/watch?v=oGll155-vuQ&amp;feature=youtu.be&amp;t=17m7s).
Well you’ll be able to write your own unsigned numerics once value types are released.
Reification is being added to Java, but it is just not going to be exposed at the language level. They are using it to implement specialized generics.
that is some terrible hacks right there. this wouldn't even address the issue of arrays allowing signed values.
well you could statically import System.out :P
That is correct, but we’ll just have to deal with it.
Lack of comprehensive APIs and excessive amounts of optional utilities in the standard library. No graphics API for Java SE, no good standard audio API. Basically you can't make a game in Java without JNI. There are loads of APIs in Java SE that probably make it dificult to implement when most of them arent even remotely required for a vm to function/run java programs. For example, there are so many networking utilities in Java SE when the only necessary ones are Socket and DatagramSocket. Probably makes the jvm harder to maintain and makes java confusing for beginners. Let external libraries add optional functionality!
Presumably that only applies in one IDE.
A part of me wishes IBM had bought Sun instead.
Shoot, you're probably right. Sorry about that
I often ponder what that would be like.
What does your example have to do with Java in particular? You could use that coding style in any language.
And their consistent inability to deliver. 
Curse you, C. A. R. Hoare!
Yes, I always do that too. But it's IDE generated and not a language feature. Here are some comparisons Scala : `println("")`, C#: `Console.printLine("")`, Kotlin : `println("")`
Instead of this, I'd prefer static top level classes. They'd function like you'd expect: a collection of related methods that aren't really type-associated. 
I use System.out.println for debug statements which need to be deleted immediately. and log.trace("") for fine logging. edit: why the down vote guys? do you like `System.out.println` or is it my language? Comparison: Scala : `println("")`, C#: `Console.printLine("")`, Kotlin : `println("")`, c++ : `std::cout`
I'm pretty sure better under their hands than Oracle, considering that IBM was already heavily involved in Java and open-source in general.
No operator overloading or multiple class inheritance. Not necessarily my biggest complaint, but it's one that often isn't mentioned.
It does, because it forces you to check for empty value and it expresses the intention to possibly return no value instead of one. 
It depends on the implementation. In Kotlin, they really do solve everything unless you're calling unwrapped Java code. Java's Optional isn't as helpful because it's a library level feature instead of a language level feature like you see in kotlin and some other languages.
Why exactly do you want multiple inheritance of classes? And they are looking to add operator overloading for numeric types.
yea, but starting VM takes ages. If I write basic code XML and converting to JSON in golang it feels 10000000x faster than java, because system takes time to find JVM, JVM takes time to load. Hopefully Java9 will provide us smaller packages and JVM that feels faster.
Check out the equalsBuilder class in guava and apache commons. Both libraries provide builders for equals, compareTo, hashCode, and toString
Kotlin
Do you routinely find yourself writing DI containers?
Well, as I stated in other comment here, compiler should enforce null checks and infere when it is not needed. Some exceptions to this can be overridden by an annotation. No need to change language syntax or introduce new types.
This right here. At the very least an unsigned byte would be awesome, I get so tired of having to `&amp; 0xff` all over the place.
Certainly. Something simple like this I would (prefer to) write in Python
this (+ the java IDEs slugginesh) is the reason people say it's slow.
No Syntactic sugar for Hash. Instead of `h["key"]` or `h.key` you need to do `h.get("key")`.
The classpath and package name correspondence with file system makes setup, configuration and building too complex. Ant and Maven ultimately make things easier to manage but I spent quite a bit of time learning them.
Ugh. Yes. The hoops we have to jump through to compact the heap are positively silly.
I was going to say "Enterprise software", but I like yours.
https://www.reddit.com/r/java/comments/6scddi/_/dlc0w8k
Here-docs are awesome.
Sounds like you're talking about J2EE, not Java. Some of us have avoided J2EE since just after it was introduced, for various reasons, so it's not mandatory.
Copy and paste man. It's not much worse than Console.WriteLine in C# and you can always do something like the following to reduce repetition. &gt; PrintStream console = System.out; &gt; &gt; console.println("Hello, World!"); Heck you could just write your own function: &gt; private static void println(final Object obj) { &gt; System.out.println( obj ); &gt; }
You can use vavr.io which has tuples along with other functional data types.
I'm used to everyone abandoning the built-in Serialization at least a decade ago. When I want to record or transfer objects, I'd choose my own codec.
I don't think so. Ex-IBMer circa 1999-2004. If you want to see where Java would have been under IBM's hands, just look at DB2. One the BEST SQL databases in the world, relegated to a niche enterprise thing as Oracle, SQL Server, and Postgres eat up the market. The only reason we have Eclipse as open source now is because Microsoft Visual Studio '97 was so good and fast compared to VisualAge. If the early versions of VS.NET had come out a bit earlier and been the dog-slow crapfest they were, IBM would have been trying to sell Eclipse and build a patent warchest to go after NetBeans. As it was, they had this way over budget, way late product that couldn't touch VS 97 and people were starting to hate on Java something fierce. So they released it unto the wild and it took a good 5ish years before enough people on the outside came in to make it what it is now. Today IBM is a good contributor to open source, but it took things like Eclipse, the SCO lawsuit, and AIX 5L to really start changing their upper management's perception of "free software" and NIH. If Sun had survived until today and been on the market, perhaps IBM would be a better steward. 
&gt; Basically you can't make a game in Java without JNI. You can use Swing/JavaFX, it's not that difficult.
Oh, if class path issues are a problem now I suspect you will really be irritated by Java 9 and modularization. (I doubt you'll be alone in that)
That would be nice although it would be inconsistent with an object oriented language.
Yeah, that. What a pain!
Yeah, it seems everyone winds up with something like [this](https://stackoverflow.com/a/30974991). 
Except the intrinsic reality of Java and many other languages is that objects/references/pointers can be null. Returning an object expresses the possibility of null. Primitives can't be null generally. In any case you can always aim for null-free programming and use stuff like ternary if constructs to ensure that you return *something* that isn't null. Heck just use a wrapper class. &gt; class Result&lt;T&gt; { &gt; ---- T result; &gt; &gt; ---- public Result(T _res) { &gt; ---- ---- this.result = _res; &gt; ---- } &gt; &gt; ---- public T getResult() { &gt; ---- ---- return this.result; &gt; ---- } &gt; &gt; ---- public boolean isNull() { &gt; ---- ---- return ( this.result == null ); &gt; ---- } &gt; }
Yes, exactly.
@Nullable?
Forced Exceptions, that's pretty much it.
That takes a lot of discipline though. All it takes is one mistake where you think code further down or up the stack had already done a null check and you have an NPE. Language level nullable/nonnullable types eliminate that concern. You know exactly whether or not any given variable should be checked for null no matter what the caller is or what the implementation of the function you're calling is. The @NonNull and @Null annotations are a step in the right direction, but still not as good as nullable/non-nullable types. There are only two ways to be as null safe in java as you can be in kotlin. 1. You write all of the code yourself 2. You null check every parameter and return value every time. Neither of those are very realistic. Not to mention that it doesn't work since code somewhere could set a class's field or global to null. So you'll have to always make a new variable for each nested field and check each of them every time you use them for being null or not null every time you use them. Then you'd be almost as null safe as if you had used kotlin. 
You as a developer have to define equality, should JVM guess what you want? 
IntelliJ is a hell of a lot more responsive in my eyes than Visual Studio...
is for shmucks
&gt; it's up to you to give it a shot and reevaluate Sure. My evaluation is that it is the software equivalent of a [Rube Goldberg machine](https://en.wikipedia.org/wiki/Rube_Goldberg_machine) and any sane developer should stay away from this (novice or otherwise). I am sorry but that is the truth.
**Rube Goldberg machine** A Rube Goldberg machine is a deliberately complex contraption in which a series of devices that perform simple tasks are linked together to produce a domino effect in which activating one device triggers the next device in the sequence. The expression is named after American cartoonist and inventor of such contraptions, Rube Goldberg (1883–1970). Over the years, the expression has expanded to mean any confusing or complicated system. For example, news headlines include "Is Rep. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
The concept is fine, but the implementation could have been better.
What discipline are talking about? If language is enforcing null checks by default, there's no need for discipline. Then you add inference to the compiler and you can work with factories easily without checks. And then you have single `@NotNull` annotation for method arguments, which will allow your library code to avoid checks while enforcing library user to do them in all cases and that will cover exceptions where compiler can't easily infere behaviour. Problem solved!
_The concept is fine,_ _But the implementation_ _Could have been better._ &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ^- ^lbkulinski ------------------------------ ^^I'm ^^a ^^bot ^^made ^^by ^^/u/Eight1911. ^^I ^^detect ^^haiku.
Both of those would need to be repeated in every class where you want to print things, though. 
yes, I use it too. What I'm saying is java's reputation of being sluggish comes from people comparing the typical (outdated) eclipse environnement and a text editor such as notepad++ for php. They're not comparing it to VS but with text editors. 
Hurray \*\o/\*
If you want to make a 2d game using images and shapes...
if schmucks means intelligent people who can see the benefits of better language constructs while still running on the jvm
This!
* Eliminate the arbitrary distinction between class and interface. This helps simplify and clean up the type system, and reduces cognitive burden. * Eliminate the “interface for every class” anti-pattern. * Eliminate the (remaining) need for `interface Whatever` + `abstract class AbstractWhatever`.
Not core Java but most web related Java. Spring, JAX-RS, Hibernate, JPA. Even some of the HTTP Clients that are now just interfaces with a bunch of annotations on every method, it cuts out a lot of boilerplate but can be annoying to debug. 
Can you not just slash escape the newline?
Yes, Kotlin data classes are a joy to use!
When what we want 99% of the time is exactly the same, then yes, the JVM should "guess" (meaning, implement) what we want. As long as we have a way to override that default behavior for that 1%, then we're golden.
I’d rather not have multiple inheritance of state. It hasn’t worked well in C++.
&gt; Except the intrinsic reality of Java and many other languages is that objects/references/pointers can be null There is no such thing as "intrinsic reality of a programming language". Programming languages can be and can do whatever we want them to do. No need to limit ourselves to some kind of "intrinsic reality".
Annotations are the new XML.
Exactly my point; the language is so awesome but it's still on the (also awesome) JVM with all the libraries and compatibility. Love it.
Good bot
Thanks for your positive feedback! 100 people have voted on haikubot-1911 so far, with 91 positive votes and 9 negative votes, giving haikubot-1911 a popularity of 91.0%. See the [current leaderboard here](/r/botpopularitybot/wiki/bot_popularity). Source [here](https://github.com/Theonefoster/bot_popularity_bot/blob/master/bot_popularity_bot.py).
Then you are doing it wrong. Making SSL HTTP requests in java requires no additional hoops.
Thanks for taking all the time to give me and others feedback.
See, that's where the opinion is coming from. Java is damn fast when it runs on Tomcat with 1_000_000 concurrent users, it can handle it well, but learning programmers have different idea of what fast is.
@Nullable is nice
&gt; Basically I want frigging Scala with full Hibernate/JPA and JAX-RS support. So far the only thing that is irritating about using Hibernate/JPA with Scala is no support for Scala collections. Other than that I haven't seen any issues.
Many of these kids haven't ever worked on production software, so I'm guessing that has a lot to do it.
You seem to contradict yourself, you say "Lack of comprehensive APIs" is a problem but then you say "Let external libraries add optional functionality!". These seem to be mutually exclusive complaints. &gt; excessive amounts of optional utilities in the standard library Can you give an example of what you mean by "optional utilities" &gt; Basically you can't make a game in Java without JNI. https://libgdx.badlogicgames.com &gt; No graphics API for Java SE http://docs.oracle.com/javase/tutorial/2d/ &gt; no good standard audio API https://docs.oracle.com/javase/tutorial/sound/TOC.html &gt; For example, there are so many networking utilities in Java SE when the only necessary ones are Socket and DatagramSocket You rarely want to have to deal with raw bytes, you want higher level functionality that provides conveniences so you don't have reinvent the wheel every time you want to write to or read from a socket. Java IO API's make perfect sense if the developer understands the decorator pattern.
This is why java will fail in the long run. Microsoft is really playing their cards right with .NET core. Just compare the level of effort between the two on how they care about open-source and the comunity. Yes I also hated Microsoft but times have change. A company is an organism that changes shapes over time. 
Another point where [Kotlin](http://kotlinlang.org/docs/reference/basic-types.html#strings) offers a solution. val text = """ |Tell me and I forget. |Teach me and I remember. |Involve me and I learn. |(Benjamin Franklin) """.trimMargin()
JavaFX has 3D capability. Can't speak to the quality of it though.
Ehh large Java applications compare favorably to CPP as well. I often see Java perform faster. There are exceptions where Java is slow, start up and n dimension array being the top of the list. But those are negligible in most Java applications.
I feel like Kotlin is a solution to most of the things listed here. Kotlin doesn't have checked exceptions and it feels right. Especially with functional programming checked exceptions are a pain!
The actual problem is reflection. But is true, that annotations help to make reflection such a powerful and practical tool. I've just used the Java EE web socket API, that is completely reflection driven. And it was a pain to use in my testing scenario. Something brutally simple like the Gorilla web socket implementation would have been much better.
Java SE should contain APIs that require a native interface to the hardware/OS, but not too much functionality that can be implemented easily in software (unless it is a common interface that should be shared between libraries). Graphics APIs are necessary to display graphics and to take advantage of graphics cards. There is no medium/high performance comprehensive graphics API in Java SE. Things like java.compiler, java.sql, java.activation, and java.prefs as a few example modules in Java SE, are domain-specific or do not provide any operating system interfaced functionality, yet any JVM that wants to be Java SE compliant will need to implement them anyways. Module java.corba is now deprecated and will be removed eventually from Java SE. Wouldn't it have been better if it never existed in the first place? Less maintenance, no chance of becoming obsolete.
* Hovering is too slow and not review friendly where no IDE is present. * I'm using refactoring to change method signature, not manually changing the return like in the middle-ages. Even the official [C# Coding Conventions](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/coding-conventions) discourages the use of type inference in situations as I described above: &gt; Use implicit typing for local variables when the type of the variable is obvious from the right side of the assignment, or when the precise type is not important. it repeats: &gt; Do not use var when the type is not apparent from the right side of the assignment. Having type inference for method return leads to many people writing the type in the variable name, e.g. `personToAddressMap`. &gt; Do not rely on the variable name to specify the type of the variable. It might not be correct. &gt; 
It does, but was only designed for CAD-like/medical applications from my understanding.
Oracle Java doesn't support AES-256 or other strong ciphers out of the box. AES-256 is used in SSL frequently. How do you get it to work without extra steps? EDIT: sorry, that sounds adversarial and I didn't mean for it to be. I really want to know the answer. 
Yeah, a list of other things I've avoided, plus Hibernate. I used Hibernate a good deal a decade ago, but it always came down to "someone else used Hibernate as an ORM layer, found it to be too slow, so they asked me to make it faster … so I switched to HQL and wondered how this was better than JDBC". So most of my experience with Hibernate is getting rid of it and getting a much faster implementation. 
So many people downvote based on opinion :P
You could have asked that question in *modmail* (Message the moderators in the sidebar). We generally do allow youtube videos as long as they aren't your only contribution to the subreddit. We don't want people spamming the sub with self-promotion. We don't allow *tutorials* here, because that's what should go in /r/learnjava as is explicitly stated in the **sidebar**. We don't allow *"watch me write app x"* here. Barely anybody wants to see such content. What we do allow are tech talks, conferences, etc. Again, all considering limited self-promotion. If you are not planning to contribute otherwise (participate in discussions without self-promoting, linking other content) you are not welcome here.
Perhaps the word "reality" is a bad choice here. That was how things were decided quite a while ago and it's *perfectly fine*. There are intrinsic limitations though without reinventing the computer. For another thing entirely it is very nearly a complete and total waste time to reinvent the wheel by making yet another programming language when we have a vast array of existing ones that do a good job.
Yea AbstractFactroryProxyBeans hurts my eyes. It should be AbstractFactoryProxyBean.
Why? The diamond problem? That can be solved: * Make virtual inheritance (as C++ calls it) mandatory. Do not allow there to be multiple instances of the same class inside a single object. * If a zero-parameter constructor is called more than once in an inheritance graph, only actually run it the first time it's called. * If a non-zero-parameter constructor is called more than once in an inheritance graph, and it isn't called with the same set of parameters every time, raise an error. * If different constructors on the same class are called at different points in an inheritance graph, raise an error. * If a class is multiply inherited with different, incompatible sets of type parameters, raise an error. * If multiple inheritance results in inheriting different concrete members (methods, fields, etc) with the same name and (if applicable) signature, neither of which is in a position to override the other, and the class at the bottom of this diamond doesn't override them itself to disambiguate, raise an error. Just because C++'s idea of multiple inheritance is completely insane doesn't mean it can't be done sanely. Scala does most of this already for its traits, and it works fine. Multiple inheritance is not scary.
Easiest shortcut would be to add "import static java.lang.System.out" to each file then just call out.println
Just import a single class each time you need it, that's hardly a crisis. There are way more good things that come with the way of doing things that makes this an issue than there are with the few cases in which you can do away with it. In any case very few classes really need to be printing stuff to the console besides the main program and perhaps unit tests. It is bad design/programming for data holding classes to be printing out to the console anyway.
Certainly that is another approach. To each his own.
no properties like in C# getters and setters are so inelegant
"This is why Java will fail in the long run". I'm really not sure how one of the most popular programming languages in use today (I would say THE most popular, but how do you categorically prove that?) can suddenly fail. You might want to look at how much effort Microsoft is putting into Java on Azure. Just sayin'
I guess him posting to /r/GetMoreViewsYT says it all. 
I lived under impression I could say the same about Informix, which was an trully innovative DB at the time IBM bought it, db2 just had triggers at the time... Initially sunk by IBM, it took years for IBM to recognize its value and add techniques from ifmx to db2...
reminds me of this: [Java is Slow](http://thedailywtf.com/articles/Java-is-Slow!)
Oververbose: You don't find the tree in the forrest Overconcise: The tree is the forrest. And everything else.
I am not arguing against that. I just responded to the topic question. Null is a mistake, it never should have made into a high level programming language like Java, it causes insufferable amount of problems. It's not even type safe. I love Java, I love programming languages, but I still believe null is a mistake :)
That's not a problem of Java per se, just the implementation of the GC. Tuning Zing from Azul (yeah, I work for them) is just a case of setting the size of your heap.
`Public Foo (int a, int b, int c, int d) {` this.a = a; this.b = b; this.c = c; this.d = d; } Stolen from r/python
Have you looked at Swing? and swixmlhttps://wolfpaulus.com/software/swixml/
Oh please no. Operator overloading is the work of the Devil in my opinion (with the exception of String concatenation, which actually makes sense).
Word at the time was that IBM bought Informix at the request of Walmart because they were financially on the rocks and Walmart wanted to ensure it would stay supported.
Its not popular because people love it.. its popular because of the vast quantities of good projects an libraries in the community. It is the same as people does not love JavaScript.. They don't have much choice. If i want to write a project today i would rather code in C# but the availability of libraries are poor so i would have to choose Java.. This is something that will change in the future. When i say long run.. i mean loooong run.. but it will happen and things move faster now in tech than they did 5 or 10 years ago.. way faster. 
I'm intrigued. What do you not like about final? Other than the fact that they're not really final? :-)
&gt; Optional doesn't make your code any better, you still have to check &gt; for empty values. With `Optional` implemented properly, no you don't. The beauty of `Optional` (when done right) is that when used in conjunction with something like streams, the presence of an empty value will simply short-circuit the evaluation of the stream, so that an empty `Optional` pops out at the end. Unfortunately, `Optional` isn't a stream in Java 8, and in Java 9 you still have to do `Optional::stream`. This allows you to focus on the happy path without cluttering up the happy path with a bunch of conditional logic.
Have you looked into [jOOQ](https://www.jooq.org/) without question my favorite SQL library by far.
I have never needed an equals method that wasn't equivalent to the autogenerated ones my IDE spits out. I haven't done much complicated stuff, but I bet a lot of people are in the same position.
We are talking about Java in this thread. Read the title. Plus I am getting sick and tired of kotlin shills pushing it left and right, from now on, if I see kotlin mentioned, I will always add 'is for shmucks' to counteract that.
It is never the same. Have you worked professionally with Java? You have to define what it means for 2 objects to be equal and this is highly dependent on your domain and use cases. Guessing desired implementations of equals is impractical. 
Intellij ultimate allows you to have a complete that turns sout into proper System.out.println iirc
At least named method parameters with default values are provided by Kotlin. fun calculate(a: Int = 5, b: Int = 10) = (a + 2) * b calculate() // --&gt; 70 calculate(b = 7) // --&gt; 49
Kotlin offers [operator overloading](http://kotlinlang.org/docs/reference/operator-overloading.html).
Yep, good one. . . Java's pretty damn fast these days.
Once again, possible with Kotlin: val myMap = mapOf("a" to 99, "b" to 22) val a = myMap["a"]
One more reason to give Kotlin a try: println("hello")
`final` is good from the semantic point of view, but can be annoying while typing and reading code. Classes and method parameters are final in Kotlin by default. And final local variable are pretty easy with `val`, too.
At least in some cases, Kotlin offers reified generics (for inlined functions).
 /* Multi . Lined . Quote. . */ This works for me, at least. Edit: Sorry the formatting is stupid. Without characters on the empty lines, Reddit was concotenating them into a single line. 
Yes, I understand that. I also agree that sometimes you do need to define what it means for two objects to be equal. However, I would posit that this is actually quite rare. &gt; Have you worked professionally with Java? It's my most used programming language for the last 20 years. In that time I have noticed that the greater majority of all data classes have needed to define equality in exactly the same way: if all members are the same, then the objects are the same. In all this time, I have seen a *need* for a class to deviate from this pattern a handful of times. &gt; Guessing desired implementations of equals is impractical. I agree. But a default implementation is not a guess.
In that case you are not paying enough attention to your domain entities. Most of the entities I produce, use appropriate subset of fields in equals and hashcode, determined by consultation with domain experts. Do you also include your 'Long id' into hashcode? I am not going to change your mind here. May be read domain driven design book?
&gt; with a lot of wonky behavior Don't hold out here. It's a veritable festival of wonkiness in `equals`: &gt; Two hosts are considered equivalent if both host names can be resolved into the same IP addresses; else if either host name can't be resolved, the host names must be equal without regard to case; or both host names equal to null. Yep, `equals` will resolve the host name. Something that is both expensive and nonsensical. If you're offline the result of equals may even change, because, well, why not? &gt; Since hosts comparison requires name resolution, this operation is a blocking operation. &gt; &gt; Note: The defined behavior for equals is known to be inconsistent with virtual hosting in HTTP. Enjoy the madness. https://docs.oracle.com/javase/8/docs/api/java/net/URL.html#equals-java.lang.Object-
Oh, some down-voters don't want to be disturbed in their echo chamber ...
Fair enough, but it is a problem for 99.9x people on the planet do not have access to zing, so I might as well say it is a problem of java.
You should always focus on negative path so that you can tell your users that dataset is empty instead of showing them blank screen and leaving them wondering wtf just happened. And proper NULL handling is vital in this scenario. Don't be lazy.
Effective Java has some good patterns for dealing with all that
Dear Lord. . . I don't know how many times I've ended up on that SO post. . . 
annotations in every ****ing framework!! it seems too hard to get rid of them, you want to use Hibernate? annotations! do you want to you use a IoC container? annotations! do you want to use a MVC framework? annotations! jeez :'(
 /* Multi Lined Quote. */ - /* Multi Lined Quote. */ This comment: /* Multi Lined Quote. */ - /* Multi Lined Quote. */ Still not a multiline string tho.
I'm can't test it currently, but I do believe this handles multiline strings as well. I might be remembering incorrectly. It might be that asterisks have to prepend each new line until the `*/` to end it. 
Named parameters would be sweet. . . I love them in Python and Ruby.
Looks like this is the related proposal? http://cr.openjdk.java.net/~jrose/values/values.html
Project Coin explored adding properties to Java, but no one could agree on an implementation.
It's updates. 
AES-256 has been supported by Java since Java 1.6. SSL clients and servers negotiate an encryption algorithm they both support and I have never hit an SSL web service were it wasn't able to agree upon an encryption algorithm with my java client. Are you hitting a SSL service that _only_ supports AES-256?
spring
And what about: private int daysSinceSomeTargetDate; public int getDaysSinceSomeTargetDate() { return daysSinceSomeTargetDate; } public void setDaysSinceSomeTargetDate(int daysSinceSomeTargetDate) { this.daysSinceSomeTargetDate = daysSinceSomeTargetDate; } This is the kind of verbosity people mostly complain about.
Now you got metaspace instead! Wooo
Now you got metaspace instead! Wooo
Could you expand on this? I'm curious.
&gt; here is no medium/high performance comprehensive graphics API in Java SE. Name a language with a medium/high performance comprehensive graphics API in its standard library.
You should focus on the happy path, and separate error handling. This makes the code much easier to test and understand, because it decreases cyclomatic complexity. Each NULL check adds a branch. This is what is good about checked exceptions, one way to avoid NULL checking in traditional Java. Checked exceptions allow a method to enumerate error cases. The catch block lets the happy path bail out into an error handling context to allow the system to give the user an appropriate response. However, checked exceptions are incompatible with functional programming, where expressions must always produce values. In functional programming, the error is captured in the return type. If the `Optional` is empty, since the function could not produce a value, and the system can give the appropriate response. `Optional` is somewhat suboptimal in this case because it cannot carry error information, which is why the `Either` type exists. The screen will call a content generating function and will act according to the response type. The system is simplified because you don't need to handle NULL, and the vital function of NULL checking is moved to a more appropriate context. In this case, laziness yields a much better result.
Null is not a mistake at all, it is a fundamental recognition that there is a state necessary to describe. Unless you completely omit references/pointers altogether (not exactly viable if you want to use any memory besides the stack) you have to be able to describe an uninitialized/unassigned? reference somehow. I'm pretty sure making an object called NULL (Object NULL = new Object() ) is a bad plan since it's valid and therefore can hide failed initialization. Even if you replace it with a dummy object you'd still have to check whether the referenced object it was a valid object of the expected sort before using the reference. The best you can, at some level, do is to declare and initialize variables when you need them and dispose of them when you're done so as to avoid ever having unitialized/unallocated/unused references/pointers. I think plenty of people would argue that approach makes for poorly structured code though and initializing stuff way in advance of needing it would be a waste of memory. Programming language constructs do not cause problems, **programmers** cause problems. Also given a google search there seems to be some confusion as to what the following terms mean in relation to each other: static/dynamic typing, strongly typed, type safe, etc. There seem to be strict and loose definitions. https://en.wikipedia.org/wiki/Type_safety I would describe Java as *partially type safe* or as having type safety features in the context of this wikipedia article. From what the article says it sounds as though absolute type safety would be a ridiculous imposition on a general purpose language.
**Type safety** In computer science, type safety is the extent to which a programming language discourages or prevents type errors. A type error is erroneous or undesirable program behaviour caused by a discrepancy between differing data types for the program's constants, variables, and methods (functions), e.g., treating an integer (int) as a floating-point number (float). Type safety is sometimes alternatively considered to be a property of a computer program rather than the language in which that program is written; that is, some languages have type-safe facilities that can be circumvented by programmers who adopt practices that exhibit poor type safety. The formal type-theoretic definition of type safety is considerably stronger than what is understood by most programmers. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
Regarding generic enums, unfortunately: *[enhanced enums] - end of the road?* http://mail.openjdk.java.net/pipermail/amber-spec-experts/2017-May/000041.html http://mail.openjdk.java.net/pipermail/amber-spec-experts/2017-June/000044.html
Java is different. It uses a virtual machine which means the only standard way to interact with os/hardware is through the standard library. Using a language like C, you have dirct os/hardware access since you compile to machine code.
Don't do this to me.
Yeah, I like the concept, but it's a hard call to commit to a nonstandard language extension in a huge codebase that will live for many years. 
Yeah, I've got a java version I wrote of ```Result``` from rust which I stare at fondly and wish I could use.
If only they ever meant ```Optional``` to be used :/ They're very clear about that when they speak of it.
It is the work of the devil when developers overload operators to work with classes like Shoe or Person. For numeric types, like BigInteger, it would be clear what the overloaded operator does.
Eh JavaScript only survives because it is the only language supported by browsers. Wait till we have the next language and people will drop js as soon there are enough libs and tools supporting the new language. 
No, value types are a different thing. A value type could be a data class, though.
There are three parts in his comment. What are you curious about?
&gt; If i want to write a project today i would rather code in C# but the availability of libraries are poor so i would have to choose Java. Exactly. This is the entire point of .NET Core. Well, that and to expose it to more developers. Which is also the point of Visual Studio for Mac and Visual Studio Code.
I've heard of it , but not looked into it because I haven't needed a solution to that for years. I'd be more likely to work with Spark … which winds up looking very similar to jOOQ in its style. 
That reminds me, what is taking Web Assembly so long to arrive?
I don't differentiate between Lombok or another library like e.g. spring. Spring generates also a lot of code for you, think about all the controller code when you use MVC or repository code when you use spring data that it takes care of. 
Having to use equals instead of == Code would be much clearer if you could just do if (str == "a") You rarely really need object comparison, so they could have easily introduced a keyword.
_That reminds me, what_ _Is taking Web Assembly_ _So long to arrive?_ &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ^- ^VGPowerlord ------------------------------ ^^I'm ^^a ^^bot ^^made ^^by ^^/u/Eight1911. ^^I ^^detect ^^haiku.
Primitives without autoboxing would require some sort of template system (like C++). Since Java does not know a generic collections type at runtime this would require quite a bit of change. I totally agree though, autoboxing is a solution, but not a good one. Maybe in the future we will get JVM optimizations for this. Who knows..
You keep skipping the part where you have to install extra JCE files on the machine, which is an extra step. OpenJDK fixed it, but Oracle hasn't. I don't know what version of Java are being used when I'm creating a library. There's info about this all over the internet. Be thankful you haven't run into this issue yet. I mean, it's addressed on Oracle's site: https://blogs.oracle.com/java-platform-group/diagnosing-tls,-ssl,-and-https
If you are wondering about the memory problems: When primitive types are autoboxed into their class counterparts (e.g. int -&gt; Integer) the runtime has to create an instance just to store that value. Now if you constantly work with primitives in collections you will get a lot of garbage that has to be collected, especially since there is no caching for *all* values, but rather only for a small range (IIRC integers are cached from -128 to +128).
You should never be printing in an actual java application. Why bother optimizing it with syntactic sugar?
Deploy times in Eclipse. 
Today it's maven or gradle. Unless your stuck in a project that uses ant.
Although I prefer Kotlin over Java I have to agree with you. If I wanted to read about Kotlin I would go over to r/Kotlin. A lot of technologies are made for Java and a Java codebase and the team maintaining it cannot just switch to another language because it offers some relatively minor improvements compared to the effort involved with migration.
&gt; it is a fundamental recognition that there is a state necessary to describe There is absolutely no need to make the syntax of the programming language accept it though. &gt; you have to be able to describe an uninitialized/unassigned? reference somehow. You can already do that, just type: Long variable; There, uninitialized reference. No need to check if it's uninitialized, the compiler does that for you. &gt; initializing stuff way in advance of needing it would be a waste of memory No need to do that, see above. &gt; programmers cause problems Yes, you are right. That's why we make programming languages, to constrain programmers that would otherwise do stupid things. The only reason programming languages exist is because we need a system within which we can productively work. E.g. the only reason we use types is because we want to enforce that some kind of data is going to be interpreted in the intended way, we could do away with them altogether and have more "intrinsicly realistic" programming experience, but we don't do that because programming would be a mess. It's the same with null, except in this case we chose (arguably) the incorrect approach. Even the inventor of the null reference says it was a mistake: &gt; I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn't resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.
Kotlin could have solved this though. The could have added a hidden parameter in functions that takes the generic type. Then the compiler could automatically insert that parameters value and for Java interop you would have to pass the type manually. But instead they decided to not do that and instead wait until the JVM officially supports generic types (which it probably never will).
Lack of tuples
I have used Kotlin with JPA and JAX-RS and the nice thing is that Kotlin collections are replaced by Java collections at runtime.
Unions would be very nice. Manually implementing them is just a PITA.
I started using Rust lately and the whole `Result` thing is amazing.
Tuples were considered by the Platform Group, but would be just as much work, and generally less useful, than value types.
Most cases of reflection could be replaced with some very simple code generation. But people in the Java world seem to dislike that.
The pain involved with writing two dozen overloads just to fake default params...
Or you could choose Kotlin and have the ecosystem of Java with the language features of C#, plus the amazing language stewardship that Jetbrains provides.
In my opinion, there is a big difference between Lombok and something like spring. Spring does generate a lot of code, but it generates its own classes, which a developer never really needs to know about. Lombok on the other hand generates code in classes that I've written. I think of the code generated by Spring as simply an implementation detail that a developer doesn't really need to know anything about. With Lombok, a developer can write code against methods which do not exist in the source.
I actually prefer composition over inheritance and think that any use of multiple inheritance could be done with composition, which would result in a less complex system.
I don't dislike the concept but rather I dislike the unelegant syntax. I would be happy with a union type like you would see in Rust where you have a `Result` which is either `Ok` or `Err` and you simply check using a switch-like statement.
To add something to your list: the Properties class. It is really useful, but why does it extend Hashtable? It essentially exposes its internal workings which I dislike a lot. Why not just have a key-value properties interface and an implementation for the standard format, XML etc.
Yeah, the metaprogramming is real in Java
For me it is just sout and hit enter
That has little to do with object orientation. It is simply syntactic sugar for a normal method.
The core API should really just be the most essential things. I see why the decision was made though. Back when Java was introduced it was valueable to add as much as possible to the standard library since dependency management was rather hard and you want to minimize download size for user apps.
That is not true. JNI is very much part of the Java standard. Also, Java is undoubtedly a primarily server-side language.
SceneBuilder
Thanks. Can you recommend any good tools for splitting up a PR that was developed in one branch? I think it's mostly just a matter of keeping the class called X in the same PR as the one called XTest, and we have 95% test coverage (slightly lower when run repeatedly outside Travis, because of https://github.com/dwdyer/uncommons-maths/issues/18).
Or named parameters like in Python... they're so useful! Yeah you can get the same sort of thing if you use dictionaries or whatever but the fact you then need to deal with all edge-cases in a per-function basis is really taxing :P
yes but JNI simply cant replace missing functionality in the rest of java perfectly.
It's not as good as Python or Ruby but pretty much on par with any other robust framework like .NET. I'm not disagreeing with you - I wish it could be less verbose myself but that's the way things are right now. There's plenty of JVM-based languages that communicate very well with Java code so maybe we'll see something like a Java-lite syntax some day.
Java has made a lot of progress under Oracle's watch.
Eclipse
I actually wish Google had, they're a far better arbiter of open source (look at their GitHub profile) and there is an aligned interest with the Android developer network to have made the entirety of Java open source/standards Also, it could be argued, that Google libraries like guava and guice have led directly to javax.inject and CompletableFuture 
That's beside the point, because this excessive verbosity is rampant across java. It has it's uses, but when you're used to, say python, it gets tedious
Java.util.Date. I hated working with that class. Glad Java 8 finally made working with dates more tolerable. 
What's that? 
So, basically Scala case classes... http://docs.scala-lang.org/tour/case-classes.html I've no idea why don't they just move all the cool features of scala into Java? They've done so (badly) with the functions, they might as well do the rest...
Legacy
How do you reference the function, filename?
Throws IOException
Some things that come up: 1. Collections of primitives require boxing all input values. For example, you cannot make a Map&lt;int, int&gt;. If you want a Map&lt;Integer, Integer&gt;, you either have to decide at what layer you want to convert int primitives into Integer objects and back. If you're not careful, or multiple developers are working on the same code, you can end up with a call stack where some calls are primitives and some are Integer objects, and the compiler won't help you prevent this because it will simply autobox and unbox in most cases. 2. If you're dealing with loops conditions, or comparisons inside loops, or math inside loops, or any kind of repetitious behavior where you're getting some data in a boxed format, you can end up with a significant runtime overhead of autounboxing without realizing that's going to happen. 3. JVM specifications result in some unintuitive behaviors on comparisons of boxed types. For example, check out [this post](https://stackoverflow.com/questions/3130311/weird-integer-boxing-in-java) about how two Integers both set to 1000 are not equal (different objects) but two Integers both set to 100 are equal (because Integer caches -128 through 127 int values, and so they are in fact the same object). Basically you can be tricked into thinking Integer objects can be compared like primitives, but they are more reliably compared as objects.
That's not a thing in Java
&gt; and you have an NPE You're saying that as if having a NPE is a bad thing. At the end of the day, there will be some error and someone will need to spend time to deal with it. It doesn't matter much if it's a NPE or an OhGoshTheresAFaultyDbConnectionException.
Haha my BSc work used Serialization to save/open the files it created. Needless to say, I can't open any of my old files anymore. It probably only works with java 1.4.2_18 and maybe _19.
Yes. So instead of Foo.bar() we'd just type... oh nevermind.
Command line completion is a new feature in picocli, and I'm looking for feedback. * Autocomplete: do you even care? :-) * Was it easy to get this up and running? * Any issues? * Suggestions? Also feedback about picocli in general is welcome. 
Microsoft hasn't even tried to solve anything hard yet. Yes, core is cross platform. If they bring Visual Studio cross platform with all that it implies, then I can say they did something. 
So something like half of all games ever made? Yeah.
And dictionaries would actually have to be instantiated, which will be slower. Named parameters could do that better (type checking) and at compile time. 
Mainly the memory concerns.
Why not? OpenGL wrappers give you OpenGL functionality for example.
You have multiple inheritance of implementations now, just not state, because interfaces can now define default implementations. 
java.util.Date where January is month 0. 
Having also done golang. Java is by no means slow, but there are definitely faster options out there.
It's more like... FileInputStream fileInputStream; Vs FileInputStream fis; I think the latter is a perfectly valid shorthand. Others have disagreed.
No import alias.
Optional is supposed to be only used for returning from methods. If you use them on fields of classes, the classes are no longer serializable. Optional serves a specific limited purpose. It is not a cure-all.
There are a few basic types of classes that most developers write: value classes, entity classes, service classes and utility classes. For value classes, which are interchangeable and these days likely immutable, the most sensible definition of equality is memberwise equality. This is what C# does with structs, Lombok with `@Data`, Kotlin with data classes, Scala with case classes, etc., etc. Entity classes have object identity and are either best left to default reference equality (don't mess with `equals` or `hashCode`) or define equality by business key. Other types of objects don't have object identity and default reference equality is sufficient. Thus, the most common use case for automatically defining equality is for value types, which is why many languages provide special syntax for these kinds of classes and generate equality and hashcode based on sensible semantics.
There are a few basic types of classes that most developers write, value classes, entity classes, service classes and utility classes. For value classes, which are interchangeable and these days likely immutable, the most sensible definition of equality is memberwise equality. This is what C# does with structs, Lombok with `@Data`, Kotlin with data classes, Scala with case classes, etc., etc. Entity classes have object identity are either best left to default reference equality (don't mess with `equals` or `hashCode`) or by business key. Other types of objects don't have object identity and default reference equality is sufficient. Thus, the most common use case for defining equality is for value types, which is why many languages provide special syntax for these kinds of classes and take care of the boilerplate for you.
Well at least null is better than nothing! ;)
&gt; I don't know what version of Java are being used when I'm creating &gt; a library. Why do you care? It's up to the user to configure SSL correctly. For Python and Ruby, it's not a convoluted mess because they depend on the SSL libraries installed on the operating system. Thus, the convoluted mess for setting up SSL belongs to the operating system. This is not good enough for Java because Java requires consistent behavior across all platforms. You don't have to figure out how to set up SSL on both Windows and Linux, such as making sure all of the required certificates are set up correctly. With Java, all you need is a platform agnostic JKS file. All JREs for all platforms use the same JCE provider interface for installing alternate encryption providers like Bouncycastle. &gt; I mean, it's addressed on Oracle's site This is one of my favorite features of Java's SSL support. You can get detailed information about SSL handshakes straight from the application. Otherwise, I have to crack open `openssl` to try and figure what is going on. 
What's hard about adding a line to Gradle?
Memory usage, slow startup, cpu usage, for simple stuff it feels too bloated
4 things.... Lack of a 'this' return type. public Animal { Animal getMother() {...} } public Cat extends Animal { } I have to reimplement getMother to make it return a Cat or I have to cast it every time.... for DSLs this is a MASSIVE pain in the arse. If I could say... public Animal { public this getMother() {...} } Then I could subclass it, Cat will return a Cat as its mother rather then a generic animal. Not having a good way to init maps.... I end up having this monster in my code more often then not.... public Map&lt;String,T&gt; hashMap(Function&lt;Object,T&gt; es...) { ... } So I can write HashMap&lt;String, Integer&gt; map = hashMap(reads -&gt; 12, writes -&gt; 4, errors -&gt; 2) and lack of good 'data' classes, where the getters / setters / constructors / equals / hashcode / etc methods are made for you. data class Person(String name, int age, int? cats) oh and Julias ability to pass arrays to arrays which in java would look like.... a = [1,3,5] b = [0,2] a[b] // returns [1,5] 
&gt; Eliminate the arbitrary distinction between class and interface. Actually, this is not an arbitrary distinction. Interfaces are contracts that can be implemented by anyone, classes have implementations and state, which carries along with it baggage, such as inheritance hierarchies. &gt; Eliminate the “interface for every class” anti-pattern. This isn't really a problem with interfaces, just an abuse of them. &gt; Eliminate the (remaining) need for interface Whatever + abstract &gt; class AbstractWhatever. This isn't needed unless the abstract class provides some default implementations. Java 8 interfaces now provide stateless default implementations. I think mixins are more cleanly implemented using delegation, such as in [Kotlin](https://kotlinlang.org/docs/reference/delegation.html) or even in Java [with Lombok](https://projectlombok.org/features/Delegate.html). No need to get yourself involved in messy inheritance hierarchies.
/r/haskell?
Autocomplete of filenames at CLI prompts is *absolutely* something I need. I plan to try integrating this tomorrow morning.
&gt; Scala does most of this already for its traits, and it works fine. Traits are not ordinary classes, and eliminate the problem C++ has with multiple inheritance by eliminating constructors.
[How have I never seen this!?](https://media2.giphy.com/media/tlGD7PDy1w8fK/giphy.gif)
Do you know of any articles that describe how no one could agree on an implementation? I have never heard of that as one of the reasons. 
Do you need the pipes? If so, that's horrible. Groovy does it a pot better.
exactly
Maybe I am spoiled by bash, but yes tab auto complete is very good and useful. It would be annoying with out it.
-meekly raises hand- I still prefer Ant. -runs for cover-
Type erasure is not all bad. I suspect they had good reasons for not implementing full reification.
Generics not supporting primitives.
This is just silly. A `Button` doesn't *have* a `Component`. It *is* one.
The type parameters to generics, such as the `Foo` in `List&lt;Foo&gt;`, are only used at compile time. At runtime the `Foo` part is "erased" and a `List&lt;Foo&gt;` is just a raw `List` that contains arbitrary objects. If you try to examine the `List` via reflection, the virtual machine can't tell you that it's really supposed to contain `Foo`. It was done this way in order to retrofit generic parameters onto the existing language/VM/bytecode without having to completely redesign it. If you find some old code from the 90's you'll see that there's no generics - just `List` (or perhaps more likely `Vector`) containing `Object`, and every time the code retrieves an element it has to do an unchecked cast to `Foo`. Under the hood that's basically what still happens, the generics just make the casting implicit and allow the compiler to detect obvious mismatches such as some function trying to retrieve a `Bar` from that list instead. Normally this isn't a big deal and you barely notice the erasure, but when you do run into it it can be a pain to deal with. For example you can't do `if (obj instanceof List&lt;Foo&gt;)` because the JVM can't distinguish it from a `List&lt;Bar&gt;` or any other sort of `List`. Inside a generic class `Foo&lt;T&gt;` you can't [easily] create an array of `T`. You can see this in `List.toArray()` which returns an `Object[]` instead of the much more useful `T[]`. The `toArray` that returns a `T[]` requires you to give it an existing array-of-T as a starting point, which it can then use to figure out the current `T` at runtime, get its `Class&lt;T&gt;` instance, then use that to make a new array. Confusingly you *can* have a field or variable that is a `T[]` within the class, but you can't just do something like `new T[10]` in order to create such an array. You also can't just do a `new Object[10]` and then cast that to `T[]` because arrays *do* know their element type, and the cast will usually fail at runtime. Similarly if you try to use `T...` in a varargs scenario, you can run into cases where it ends up requiring the JVM to implicitly create an array-of-T, which it can't do. If you try to suppress any compiler warnings about this it'll still just blow up at runtime. 
No worries: picocli is on Maven. Latest version is 0.9.8: https://mvnrepository.com/artifact/info.picocli/picocli/0.9.8 Include as source is optional and especially useful for small utilities that you want to release as a single executable jar.
By 'check' I mean you have to be sure it's not null before you 'use' it. The compiler can't do squat about it if it should be initialized and just happens not to be, hence the 'if ( var == null ) checks'. Setting a variable to null is also, at least in theory, a handy way in Java to tip the GC off that you're done with it (since that's one less reference to an in-memory object). You could also be using null to mean that there's nothing there for things that will be initialized later. If it's null then it needs initializing, otherwise not.
You cannot pass a single reference of Integer variable to various methods
Java 9 is coming up. :-P
I have a very nice C# reflection library that leans hard on its very rich meta data. I use it for everything from logging, introspection, networking, config, save/load, automatic editors, and all sorts of other things. I then use the compiler services to generate fast runtime code, so I avoid the cost of reflection. I have a JVM version also, but its much less feature rich. I wish I could bring that library to parity with my C# one. 
it works for one level, but if you have a deep hierarchy it gets hairy 
Yes, holy crap. I run into this all the time
I myself have not seen any articles, but have heard the architects talk about it. They said it is like the blind man and the elephant.
There are too many classes to make the language generally approachable, and we still have Java 1.1 artifacts around from before collections existed. *Nothing* is pruned out of Java as it ages, which will cause it to decline. It gets marked as deprecated, and then is stuck there, what seems like permanently. Hell, even if they just omitted long-deprecated classes from default Javadoc output, that'd lighten it somewhat. Or, said another way? The javadoc waaaaay back in 1.1 and 1.2 used to be useful to skim. With the current load of classes in there - many specialty that most career engineers won't touch - it's no longer skimmable.
The drawback to that is that it doesn't utilize the platform-independent nature of Java because you have to package natives for each supported OS. I believe JNI is good and necessary, but it isn't ideal.
Maybe if the language wasn't such a horrible mishmash of garbage people wouldn't keep asking this question.
I hate on java all the time, but seriously you actually like npm "I wonder which versions of my packages I'm going to get today" better than gradle? At least use yarn.
Unfortunately. I'd much rather see the constructor-diamond problem solved directly, so that the inelegance of different kinds of types can be done away with.
Yeah I agree. If im gonna steal code for source inclusion, it's usually a very small unmaintained node dependency or something that needs some updating, not an activity developed dev tool. I think you can/should do what almost every other apache project does: host the jar on the website for download, and maven. If u want to make a minified version for single file inclusion... well that's on you. However, I probably would not want to work on this due to the way the code is organized in the repo. That's my opinion but I think most people in the java community would agree. I'll play with it some tomorrow, dubious about the tab autocomplete... but I love being proven wrong! Anything to avoid compgen.
This is quite a naive view. Java remains backwards compatible because those on the platform have never wanted to potentially break someone’s mission critical code. And not all code lies in the same maintenance domain.
Definitely Kotlin or Scala. For C# JetBrains has project rider which is good and it also supports F# 
Did... you just thank yourself?
The fact that it's really really verbose 
Curious: how are they as much work as value types?
I had that opinion before. "You're not writing Java anymore, you're writing Lombok". That was until I actually started using it and now I basically use it anywhere. It saves a ton of time.
community edition, too
&gt; Have you worked professionally with Java? Have you? Because the vast majority of my data classes are just data classes. It looks like you're stuck in the past with "domain classes" that contain a ton of logic as opposed to 'dumb' value holders. 
Congratulations to everyone! Will it be integrated into Glassfish soon?
&gt; Do you write C# code with vim ? Do you code-review in your IDE?
Then why not Eta, Frege or Scala?
No you don't, you just never took the time to really use maven. Stuff like that takes time to get used to.
Good bot.
Thanks for your positive feedback! 599 people have voted on bot_popularity_bot so far, with 411 positive votes and 188 negative votes, giving bot_popularity_bot a popularity of 68.6%. See the [current leaderboard here](/r/botpopularitybot/wiki/bot_popularity). Source [here](https://github.com/Theonefoster/bot_popularity_bot/blob/master/bot_popularity_bot.py).
Then don't use it? 
No, the pipes are optional.
Haskell too
Exceptions work just fine with RxJava. Btw, did you know that Java is OOP and NULL is part of OOP?
Did you know about Eta language?
Brian Goetz talks about it [here](https://m.youtube.com/watch?v=Tc9vs_HFHVo&amp;t=15m54s). It would cost less than implementing values, but he makes the argument that values would be more useful to developers right now.
A lot of other languages too, but most of them are not suitable as a drop-in replacement for Java ...
This is where we disagree. I honestly don't give a shit how every HTTP endpoint implements SSL. I just want to make a request for data securely and get a response. That's the promise of SSL HTTP requests. Your favorite feature is my worst, and the point of this thread. 
&gt; Exceptions work just fine with RxJava. I'm sure there are Java libraries that work with exceptions. But exceptions are a side effect, which is what functional programming seeks to avoid. &gt; Btw, did you know that Java is OOP and NULL is part of OOP? What does that have to do with avoiding NULL? NULL is a part of lots of things.
&gt; I just want to make a request for data securely and get a response. Yeah, it's something I do with Java *every day*. It's not that hard, any more than Ruby or Python. Configuring SSL, either at the JRE level or the operating system level, is a different matter altogether. I find SSL configuration of the JRE a lot easier than configuring native SSL on Linux or Windows. &gt; Your favorite feature is my worst You don't like being able to debug SSL handshakes when things go wrong? You must really hate `openssl` then.
What a mess. Configuring SSL before you even make a request, guessing what encryption and cipher the end point implemented. Hoping the cipher isn't one of the unlimited ones blocked. Honestly, if it is so easy, produce pure Java code that will work on every SSL HTTP endpoint. Should be trivial. 
I use Maven all the time. It's our build tool of choice at work. I've got the experience to base an opinion on and I still prefer Ant.
&gt; Configuring SSL before you even make a request Yes, something you have to do for both the JRE and the native OS. I've had native apps break too when a server changes its SSL configuration. &gt; Honestly, if it is so easy, produce pure Java code that will work on &gt; every SSL HTTP endpoint. Java application code? Easy, I've developed a ton of services use that HttpsURLConnection to make HTTPS connections without any issues. 
And you didn't here. Thanks for proving my point. 
Kotlin is very new and awesome
Exceptions are a tool, not a side effect. So is NULL. You should learn your tools and how to use them. Don't be lazy.
Seriously? URL url = new URL("https://www.google.com"); HttpsURLConnection cn = (HttpsURLConnection) url.openConnection(); BufferedReader br = new BufferedReader(new InputStreamReader(cn.getInputStream())); String line = null; while((line = br.readLine()) != null) { System.out.println(line); } That's all there is to HTTPS on the application side in Java.
Yes, exceptions are a tool. And the tool *works* via a side effect. Functional programming is another tool, which *works* by minimizing side effects. NULL is a tool. There are *other tools* besides NULL which are far more effective. For example, nulls in Java do not propagate well *at all* (unlike SQL). &gt; You should learn your tools and how to use them. At the same time, you should also know what *other* tools exist and how to use them. *Especially* when they offer superior results. Don't be lazy. 
Yes, but now we have Microprofile which is a kind of Java EE fork.
I read the name of topic wrong, I skipped the least part :)
I tried Scala and Groovy, but Kotlin is the perfect solution if you want to get the good parts from both worlds. There are some features I would like to get rid of (such as the !! syntax sugar for NPE), but it's a great language anyway. 
Thanks! CR3 of the API and reference implementation is already part of the latest GlassFish. A PR for moving to the Final release is pending, so I'd expect this to be pulled into the GlassFish builds soon, too.
`==` for values and `===` for `equals()` would be nice indeed.
I didn't realize that every SSL endpoint was "https://www.google.com". You promise that the above code works on every SSL HTTP site?
And `soutv` into `System.out.println("myVariable: "+myVariable)`. And `soutm` into `System.out.println("CurrentClass.currentMethod")`. And `soutp` into `System.out.println("methodParameter1 = ["+methodParameter1+"], "+"methodParameter2 = ["+methodParameter2+"]"+....)`. It's a real time saver for debugging.
Side note: https://tozny.com/blog/godaddys-ssl-certs-dont-work-in-java-the-right-solution/ https://dzone.com/articles/how-analyze-java-ssl-errors https://bugs.openjdk.java.net/browse/JDK-8151387 https://stackoverflow.com/questions/33048172/ssl-handshake-failed-java-1-8 https://stackoverflow.com/questions/24132047/java-ssl-client-cant-establish-a-handshake There are thousands of these articles all over the internet. 
Yup, the *application code* should work as it is on every SSL HTTP where: 1. Server is properly configured (certs match server host name, for example). 2. JRE is properly configured (keystore has all intermdiate certs, up to date Java version or JCE providers installed as necessary). This has been a recipe for success with HTTPS for me for quite awhile. However, I've had to modify the formula slightly when: 1. I don't have all the intermediate certs, and I'm too lazy to properly configure my keystore, so I hack HttpsURLConnection to blindly accept all certs. 2. The server hostname doesn't match the certificate, so I hack HttpsURLConnection to blindly accept the hostname.
That's a lot of work. Convoluted, even. Goes right back to my original point: https://www.reddit.com/r/java/comments/6scddi/what_is_your_least_favourite_thing_about_java/dlbzqla/
Nah, it's not a lot of work at all. I've had to configure native SSL, and Java is comparatively a breeze.
You already proved my point. Thanks!
Yes, I've proven that SSL in Java is a breeze compared to native SSL. Glad to help! 
my team finally didn't choose to go for it because of this.
making jokes about it is ok. The problem is when people actually believe it's slow. A bit sad.
lol once you provide that code you will! Still waiting. 
The lack of an `in` operator, a la SQL. So I could do this: if (foo in (Foo.FIRST, Foo.SECOND, Foo.FOURTH) &amp;&amp; bar in (0, 24)) { ... } &amp;nbsp; Instead of this (which can get very convoluted pretty quickly): if ((foo.equals(Foo.FIRST) || foo.equals(Foo.SECOND) || foo.equals(Foo.FOURTH)) &amp;&amp; (bar == 0 || bar == 24)) { ... } &amp;nbsp; Or this (which is terser but creates an array _and_ a list just for a comparison): if (Arrays.asList(Foo.FIRST, Foo.SECOND, Foo.FOURTH).contains(foo) &amp;&amp; Arrays.asList(0, 24).contains(bar)) { ... } 
Please make sure your answer solves these issues: http://blog.spaziodati.eu/en/2014/11/17/the-dark-side-of-ssl-on-java-virtual-machine-jvm/ for *any* SSL HTTP request. 
**Sidebar**: + **Do not post tutorials here!** These should go in **/r/learnjava**.
Write blog??
Kotlin is pretty new and is best of all + Java9 ofc
In the case of composition over inheritance you would say: &gt; A `Button` *has* `ComponentBehavior`
Luckily they fixed it in URI.
You just convinced me to switch from argparse4j :)
If you're checking if an object is the instance of a list, aren't you already in murky waters? 
Yes, and the URL documentation does say: &gt; The recommended way to manage the encoding and decoding of URLs is to use URI but they really ought to put that right at the top, in bold.
Yes, which is why these erasure problems don't come up that often. But it could be a situation where your API for whatever reason returns one of several types of objects and you need to use reflection to figure out which one. For example it might be some sort of parsing code that could have parsed a string, integer, list, table, or whatever. There are some ways around this. For example in the parser case you could wrap all of the possible results with some sort of `ParsedObject` class that knows what type of object it contains, but that adds more overhead and probably more code in order to actually do things with those objects. In the case where you need to distinguish a `Foo&lt;Bar&gt;` from a `Foo&lt;Baz&gt;`, you could create trivial subclasses with the types baked in, such as `FooBar extends Foo&lt;Bar&gt;` and `FooBaz extends Foo&lt;Baz&gt;` and you can then do `instanceof FooBar` -- *but* it only works if whatever is returning the object actualy returns the derived `FooBar` and `FooBaz` types, because `instanceof FooBar` will not be true for an instance of `Foo&lt;Bar&gt;` itself even if the objects are almost the same. This is also harder to do if it's not classes or libraries you control, for example it's a lot harder to add derivative types for `List&lt;T&gt;` instead of `Foo&lt;T&gt;`, especially since even if you declare a trivial `ListFoo extends List&lt;Foo&gt;` you can't then take an `ArrayList&lt;Foo&gt;` from some library method and cast it to a `ListFoo`.
Hmm, you raise a good point. The single source file is less inviting to potential contributors, I can see that now. The use case of small utility apps being able to get picocli functionality with a single executable jar is still a valid one in my opinion. (And one that no other command line parser libraries have considered, it seems to me.) Perhaps there is a way to get the best of both worlds (without shading jars). I need to think about this more.
A place in the Java API where this sort of thing comes up is in `java.util.Properties`, which is just a `Hashtable&lt;Object,Object&gt;` at the API level. It's *usually* just string keys and values but some of this type ugliness still comes through in spots. For example `setProperty` takes string keys and values but it returns any previous value as `Object` because this was all set in stone long before generics came along. 
Why are you bored? Need new toys to play with? ADHD much?
It would have been a disaster. Sun and IBM **hated** each other and you would have had a mass exodus of Sun employees. If you google around (better to use duckduckgo since google sucks now) you'll find out about that drama. 
no
Too bad URL is used internally a lot, such as in URLClassLoader.
https://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html /r/javahelp is a sub more suitable for these types of questions.
You posted [a link to your stuff yesterday](https://www.reddit.com/r/java/comments/6s9d4v/develop_backend_services_10x_faster_backend/). So now you're just spamming. 
&gt; the generator takes a json config file like: https://github.com/vangav/vos_backend/tree/master/vangav_backend_templates/vos_calculate_sum and generates most of the code needed for the backend service (request/response code, param validation, request handling framework, database clients, database scripts, ...) + the built-in utilities (e.g.: push notifications, authentication, graph api, ...) So what happens if I later need to add a parameter to a controller. Will it overwrite the existing controller?
This tutorial's section shows how to extend the API code https://github.com/vangav/vos_backend/blob/master/README/00_expanding_calculate_sum_example.md#expand-calculate-sum-to-calculator-without-regenerating-the-service And this tutorial's section https://github.com/vangav/vos_backend/blob/master/README/03_generated_rest_service_structure.md#cassandra_updater shows how to extend cassandra's code/scripts/wiki which doesn't involve any coding Please let me know if you have any more questions or need help using it :))
This tutorial's section shows how to extend the API code https://github.com/vangav/vos_backend/blob/master/README/00_expanding_calculate_sum_example.md#expand-calculate-sum-to-calculator-without-regenerating-the-service For existing controllers, you can simply open the Request's/Response's classes and edit the params as needed And this tutorial's section https://github.com/vangav/vos_backend/blob/master/README/03_generated_rest_service_structure.md#cassandra_updater shows how to extend cassandra's code/scripts/wiki which doesn't involve any coding Please let me know if you have any more questions or need help using it :))
Ah. And you think that this is somehow 10x less work than adding another parameter to for example a Spring controller? You're delusional. Also that you use Cassandra as if it were a generic relational database shows you have no actual experience putting this in production.
Right. I hope the way it works is to have a static set of numeric overloads pre-defined. The problems of operator overloading come from their arbitrary use. See SmallTalk. 
I was wondering how you did the autocompletion since there is no way around needing a native hook normally. [Well I guess this works too](https://github.com/remkop/picocli/blob/master/src/main/java/picocli/AutoComplete.java#L200). 
static import
What the fuck....https://www.reddit.com/r/GetMoreViewsYT/comments/6skn6f/do_not_bake_a_cake_at_3am_or_youll_get_raped/
The 10x comes from combining the time saved on: + the backend's framework + core functionalities like request-to-response sequence, param validation, after-processing, ... + implementing the controller's code + cassandra's java clients with multiple apis per-query (sync, async, bound, dispatch, ...) + cql scripts (drop, create, update, ...); per-keyspace per-replication-strategy + cassandra's phriction wiki + dispatcher/worker + the built in utilities: auth, twilio, mail, networks, jobs, metrics, ... The 10x is the min based on real services developed using vangav backend -- not a wish Using Cassandra is recommended for most cases but "optional", you can simply generate your service without cassandra then add your own db like you would with any play framework app :)) I recommend spending few minutes generating 1-2 services and u will get a sense :)) even if it happened to be 1.5x for you for some reason?
That is true. However you wouldn't be using Java for high performance applications anyway.
I think they did it for performance and backwards compatability.
Exactly
What if I don't want to use Cassandra but want to use Postgres? 
I've seen full-fledged games made in it. I'm not sure if it supports external 3D models though so you would be limited to basic geometry.
You are talking about multiple inheritance. Single inheritance is (although it is often overused) usually straight forward. However, when you have mutliple inheritance you end up making something act as multiple things as once which is against the principle of single responsibility.
+ vangav backend doens't mandate using any specific db/framework/.. you can take some or all + in case you want to use Postgres, you will just do everything except for cassandra's config when generating a service, then put the Postgres part into the generated service exactly the same way you would with any play framework app + you can even use it as a utilities lib (vos_backend.jar) https://github.com/vangav/vos_backend/tree/master/dist so you can use auth, mail/sms clients, rest client, rest jobs, periodic jobs, push notifications, geo services, ... + going forward we will add more options like Postgres and others -- I highly recommend cassandra for most scenarios: dev started at Facebook, used by Facebook, Instagram, Apple, Netflix, GitHub, ....
If you trust your DB program it's fine. Java isn't running unless you run a Java program. And if untrusted programs are running on your PC, it probably doesn't matter much whether they are running on the JVM or are native.
Agreed.
You don't need a new language when you have Clojure.
Running a java program on your computer isn't any more or less dangerous than running any other program. 
You are currently on your way to be flagged as **spammer** under the [reddit **what constitutes spam**](https://www.reddithelp.com/en/categories/rules-reporting/account-and-community-restrictions/what-constitutes-spam-am-i-spammer) rules. + If your contribution to Reddit consists primarily of submitting links to a business that you run, own or otherwise benefit from, tread carefully. + If you flood a Reddit community with posts or comments, you may be considered a spammer. Instead, post one or two times and see what happens. + If other users in a community historically downvote your posts or ones similar to yours, but you feel the need to continue submitting them anyway, you may be considered a spammer. All three points are copied verbatim from the above mentioned rules and all three rules apply. As reddit states: **tread carefully**.
Finalize sprint duration, set learning goal, spend an hour on learning every day, give session at office or local meetup, and write blog - why are these here? 
This just doesn't need to be a GitHub page. It also has basically nothing to do with Java or angular/react. It's a low effort blog post that has a series of steps you would do in almost any web project, and a series of steps that don't really belong at all.
Sorry, but this subreddit is not *"all about the JVM"*. It is about (sidebar): ## News, Technical discussions, research papers and assorted things of interest related to the Java programming language There is no mentioning of the word *JVM* or of *Java Ecosystem*, or of *JVM languages*. You are, BTW, treading a narrow path in direction of being flagged as a **spammer**. Had the old reddit rules about spamming still been in place, you would already have been banned site-wide. The old rules stated that **one** self promotion in every **ten** other contributions is allowed. Since all you basically do is promoting your blog, you would definitely fall under that category. The [reddit **what constitutes spam**](https://www.reddithelp.com/en/categories/rules-reporting/account-and-community-restrictions/what-constitutes-spam-am-i-spammer) rules, however, still apply. And here you are on the verge of being flagged as spammer.
You could create the next one!
http://eta-lang.org/
I built a [WASM compiler](https://github.com/cretz/asmble) for the JVM, so technically anything that can compile to WASM could run on the JVM (C, Rust, etc). Granted there's some work to be done w/ a standard library and I haven't finished a linker to cross projects, but it does work.
That's what I like to hear
judging by your interests, I'd say a good chance you will have problems. Why don't you post a link to what you are talking about?
Relax, he's just touching up his resume. 
Entities are entities regardless of logic present in them(skinny/fat). Logic location is ortogonal to the issue we are discussing. You know that not all fields go into hashcode and equals, like id for example. This fact alone implies that developer have to decide what fields matter when calculating hashcode and equals. End of story. 
Looks like someone needs to read reddit's rules on self-promotion/spam
Since this is a *learning Java*/*Java programming* related question, it should be, as the *plenty hints* on the subreddit indicate, posted in **/r/javahelp**. Kindly **read** and **follow** the [**Posting Guidelines**](https://redd.it/48eykt) there before posting. Your question would not be acceptable there either because it shows *zero effort* from your side. This question can be answered by a very simple google query for "arrays in java" which doesn't cost any effort. **Post removed**: Programming/learning help &amp; zero effort **Edit:** on second thought it might be that you wanted to link to some blog post/tutorial but failed by creating a *self post* which doesn't link from the title. Either way, were it a tutorial, it would also not be suitable for here as these should go in /r/learnjava. Probably it wouldn't be even material for there because arrays are such extremely basic constructs that they don't need explicit tutorials.
That is an interesting metaphor that the architects gave for the situation. Thanks!
A button is clickable and has a label. These capabilities might be represented with classes.
And, what, `Component` is an interface whose methods are delegated to a `ComponentBehavior`?
I watched about 14 seconds of this video and turned it off when he said "@SpringBootApplication" implements "@EnableAutoConfiguration". This may be a good primer, but if you're looking for advanced SpringBootApplication topics, look elsewhere.
it's about enabling debug logging for spring boot autoconfig, not about actual debugging...
Bad title I suppose. I'm sure it will be useful to someone though.
What about having `Button`implement the `Clickable` and `TextContainer` interface and extend `Component`?
In the JavaFX model, every single property is an object. Interfaces, however, cannot define fields. So, that's going to get ugly in a hurry.
https://www.reddit.com/wiki/selfpromotion Basically, you're just posting your own stuff which is frowned upon.
&gt; The compiler can't do squat about it if it should be initialized and just happens not to be Of course it can, and it does. Try this in Java: Long variable; if (variable == 5) doSth; ^^^^^^^ compilation error, variable not initialized &gt; a handy way in Java to tip the GC off that you're done with it There is no need for that, and no one actually does that. &gt; You could also be using null to mean that there's nothing there for things that will be initialized later. If it's null then it needs initializing, otherwise not. No, you could just not initialize it and initialize it when you need to.
:D
&gt; Constructors. I wish I could name them. It's irritating that this(...) or super(...) have to be the first call in the constructor when I want to do validation first. Factory methods + making the ctor private is the best way to approach this. &gt; Many of my constructors take a bunch of properties and assign them to member variables of the same name and type -- I wish there was shorthand for that (on the class author side) Kotlin's primary constructors are a godsend. :)
I love how you're angry at Kotlin users for constantly pointing out that the language solves some of the most common frustrations in Java. This subreddit is really amazing sometimes. I never see such constant Luddite behavior anywhere more than /r/java.
You’re welcome! I thought so too.
Please stop spamming your channel. https://www.reddit.com/wiki/selfpromotion
&gt; I want to be fully compliant. I find that kind of hard to believe given that you posted another self promotion submission about twenty minutes after /u/dstutz gave you the link detailing what's deemed acceptable for self promotion.
doesn't support shaders either, which makes it pretty much useless for a production game or graphics application.
I have read the link. ty. I have also removed this video. Sorry
1. That's why javac and java have version flags. If you want to run old code, flip the flag. Otherwise, you're blindly using code that hasn't been maintained in a decade or more, and having a reminder of that might be a decent thing. 2. Seriously, just take it outta the standard javadoc if it's been deprecated for 5+ years. 
Depends what kind of game you're making. Shaders didn't always exist and not every game needs them.
90% of games today use shaders. The fixed function pipeline was deprecated from OpenGL many many years ago. Of course, I understand that implementing shaders that are graphics API agnostic would be a huge undertaking by itself. The API could be an object oriented abstraction of an API like Vulkan and plug into JavaFX through a special pane object.
I have two questions about it: &gt;All built-in constraints are marked as repeatable what does it mean? &gt; Parameter names are retrieved using reflection Is there still sense to invest in reflection since Java9 will be making it harder to use?
Graphics do not make a game good. Shaders are not a requirement. There are plenty of games that have large player bases that are extremely minimalist graphics-wise.
That really doesn't have anything to do with what I'm saying.
I'm talking about a more complicated situation than a one line difference where the variable *was* initialized at some point and isn't anymore. Maybe that's avoidable and maybe it isn't. &gt; There is no need for that, and no one actually does that. Where there is or isn't a need isn't proved either way and I would be almost willing to be that some people do that, and that it's non-negligible. &gt; No, you could just not initialize it and initialize it when you need to. And what, pray tell, is the difference between these two? &gt; Long variable; &gt; &gt; Long variable2 = null; 
This is NOT self promotion. I have nothing to do with this channel or person, but I felt it was a pretty cool overview on OAuth, which is something I am researching into now.
You're right, I've deleted my post as I was completely wrong with my statement, and now have to eat humble pie.
Np. I promise I am trying to follow reddiquette
Yes, in -1 week or so
A method in Java 9 is allowed to read its own parameter names. Repeatable means you can apply the same annotation multiple times.
Sure, but what's the practical difference? 
&gt; apply the same annotation multiple times. multiple times on one filed? Why would one do that?
It's not a filed really, but more things like a method or a type. You want to do that if multiple constraints apply to say a certain method. Say @Authorized("goo") and @Authorized("bar")
Don't take it like your content is bad...it's just reddit. Contribute more in other ways and no one will give you shit for posting your own stuff.
You know, you dont have to come here if you dont like it so much
I mean, /r/java is an important subreddit. I'd just like it to stop being so shitty. The attitude here is that of the stereotypical Java developer: a Luddite and a dinosaur who refuses to go outside of their comfort zone. I would love it if there were a place to talk about exciting new things being done in Java without a bunch of dinosaurs calling us shills or saying that we're just riding a trend (especially with Kotlin, which is going to quickly become the largest alternative JVM language, and maybe at some point in the distant future surpass Java itself in usage).
&gt; And what, pray tell, is the difference between these two? One is a potential runtime exception hazard, the other isn't.
You mean as a platform on your PC? No. It's as dangerous as the program you run on it.
Not a big fan of using this technique for debugging purposes. Specifically for generating reports of your beans and autoconfig there are other methods that Spring boot offers, such as the actuator services. IntelliJ 2017.2 now also offers Spring Boot support for stuff like this in their [run dashboard for Spring Boot](https://blog.jetbrains.com/idea/2017/05/intellij-idea-2017-2-eap-run-dashboard-for-spring-boot/). Also, you seem to be skirting the rules of self promotion here...
Oh my! First of all this is a generic tutorial about Cucumber. I don't see how this applies specifically to microservices. But then I found this little gem &gt;Did you notice the thread pausing at some point of our test? That’s because our system is Eventually Consistent: the event will take some time to be consumed by the second microservice, and that one will take its time to complete the operation. Oh yes! I did notice. This is a huge anti-pattern and frankly I am surprised to see this in the code. This a time bomb. The hardcoded timings might be enough in your developer machine, but will soon fail in an overloaded QA environment. Soon developers will see those tests fail without understanding why (It works of my machine but not in QA.) This is the start of many pains (flaky tests) Frankly you should re-write this article. Giving that kind of advice in 2017 is harmful for new developers. &gt;That part can be improved though, to avoid that ugly wait we could implement a retry pattern with a timeout. No! That part of the tests MUST be changed now otherwise your tests are flaky. 
If you're trying to follow reddiquette, then please slow down on the posting frequency. Otherwise you could be considered a *spammer* according to the reddit rules [**"What constitutes spam? Am I a spammer?"**](https://www.reddithelp.com/en/categories/rules-reporting/account-and-community-restrictions/what-constitutes-spam-am-i-spammer): Second bullet point: + If you flood a Reddit community with posts or comments, you may be considered a spammer. Instead, post one or two times and see what happens. You are currently posting too frequently. Slow down. Strive for quality over quantity.
Could you define a reason as to why it is a requirement to package your entire project in a single jar/war? I like to keep frontend and backend as separate artifacts and solve CORS issues by using a reverse proxy.
It's ironic the article ends with a tweet advertising freelance work in web, java, azure, aws, etc... I believe given a relative amount of consistency of the stack you use and a certain amount of experience, full stack developers can perform quite well. And are highly employable, especially in smaller companies.
I'm a bit wary of using third party solutions in this case. I would only consider using such a solution if the project was stable, backed by tests and has a certain popularity. A third party library might not do things exactly as you want them, resulting in spending too much time making changes, or merging certain ways of doing things. You don't have this problem if you brew your own fragments. So I usually find myself creating my own fragments and templates whenever I notice I'm using something multiple times. Using IntelliJ/Webstorm I've found live templates to be useful for this. 
You, me, and a thousand others are doing it. If not already popular there's got to be an up-and-coming library out there.
 public class Test { Long variable; Long variable2 = null; public static void main(final String[] args) { Test t = new Test(); System.out.println("first: " + t.variable); System.out.println("second " + t.variable2); System.out.println("first: " + (2 * t.variable)); System.out.println("second " + (2 * t.variable2)); } } If I do this, printing each of them get us the string "null" and trying to use t.variable2 (not assigned to null) *still* throws a NullPointerException. Can you come up with an example where one would be a problem and the other wouldn't?
 public class Main { public static void main(String[] args) { Long variable; Long variable2 = null; System.out.println("first: " + variable); System.out.println("second " + variable2); System.out.println("first: " + (2 * variable)); System.out.println("second " + (2 * variable2)); } } Object fields are automatically initialized to null, local variables aren't. So in your example, both variable and variable2 are equivalent. In my example, they are not. My first variable is not initialized, hence you get a compilation error. the second variable (variable2) is initialized to null, therefore you don't get a compilation error but a runtime error.
What is the difference between RxJava and Reactive Streams?
To give the same constraint multiple times, using different parameterizations and/or groups: @Size(min=8, groups=Default.class) @Size(min=12, groups=Admin.class) char[] password; Or: @Size(min=3, message="Must be 3 chars long at least") @Size(max=10, message="Must be 10 chars long at most") String name; 
Reactive streams is the specification. RxJava is one implementation of the specification (with added bells and whistles); Spring Reactive is another - and they are interoperabe because they implement the spec.
Oh...Thank. you.
Glassfish is for fags. Use Payara.
Do you realize that Spring is proprietary crap that should NOT be used right? Downvoted.
Is there a JSR for Kotlin? No? Then stop recommending proprietary languages. It is not different from Spring trying to lock-in users.
/r/javahelp
Feels like your requirement for a JSR is also language lock in. It's actually ok for languages to lock you in, you can't trivially port code between languages, it's just that your argument isn't valid.
OMG these comment improvements are AMAZING. Kidding, but we this is a patch release to a standard that by definition can have no changes. Useful: yes. Interesting: debatable.
And Javascript, and Python, and Ruby, and almost any other language. What is the point of your comment?
Yes! What is @istrian talking about? Many Object Oriented Language has that specific feature.
Looks great. Do we have a WASM VM for Java yet? I would prefer the ability to run WASM as WASM, not Java byte code.
So what stack do you recommend?
Yeah I'm usually okay with checked exceptions, but then I try to use the`Appendable` interface in my APIs with the intent of mostly just making strings in memory, and it has that `throws IOException` baked into its methods because it *might* be an output stream and then they end up polluting everything around them. I understand why they did it that way, but I still don't like it. It gets uglier when you then start trying to combine that code with lambdas or static initializers, which aren't allowed to throw checked exceptions and now you have to add more code to discard the `IOException` which you know will never ever happen.
Oracle's Java Magazine just ran an [in-depth tutorial](http://www.javamagazine.mozaicreader.com/MayJune2017/Default/10/0/3632076#&amp;pageSet=10&amp;page=0&amp;contentItem=3632076) on Lombok
Hi, Point taken, just to avoid any harm (devs not understanding what an *ugly wait* is) I made it more explicit: &gt;The sleep() methods are there just to illustrate the eventual consistency, make sure you don’t use those waits in a real CI system: they can become easily the source of many spurious errors (e.g. if you have a congested CI machine that doesn’t respond in time). Instead of this, you should implement a retry mechanism with a longer timeout. About the fact that this is a generic tutorial about Cucumber... not really. If you check the scenarios they're crossing two Spring Boot microservices. I wanted to show how, even having a distributed system, you can test it from a *feature* point of view, using functionalities that live in different pieces in the backend (the *multiplication* and *gamification* microservices in this case). Anyways, thanks for your feedback!
Sure. Here is the relevant manual section: http://picocli.info/#_parsing_subcommands For more details, please take a look at the picocli Demo in the tests: git main command: https://github.com/remkop/picocli/blob/master/src/test/java/picocli/Demo.java#L297 git-status subcommand: https://github.com/remkop/picocli/blob/master/src/test/java/picocli/Demo.java#L313 git-commit subcommand: https://github.com/remkop/picocli/blob/master/src/test/java/picocli/Demo.java#L346 Wiring the subcommands into the main command programmatically: https://github.com/remkop/picocli/blob/master/src/test/java/picocli/Demo.java#L431
Did you just stalk someone that disagreed with you just to nitpick a random line in his codebase and casually mention his employer and realname? That is not how you win a debate, that is just creepy.
The point is, that people here are complaining about *Java* and Kotlin is a perfect drop-in replacement for Java. So instead of fixing these things in Java, one could simply use Kotlin.
I agree with you, edited it out.
but should be? I think that major java destination is in rich business banking application. But.. hey, somewhere on youtube is a movie that guys show java program running on SIM card. 
The Java incarnation of Python's setuptools / distutils. I like it. It's obvious, but worth pointing out, that tools like npm and pip get away with just downloading the source, where as a Java equivalent would need a compile step. There are a few well known binary repo installers, apt-get, brew, choc, etc, which already have Java based projects available, e.g elasticsearch. I like your idea though. Haven't seen anything like it for java yet. Edit: Came back to say that it would be nice to have one binary installer tool for all (most) platforms that interact with the same repo. In other words, I wouldn't have to upload my binary to three different installer repos to be able to have all client's platforms use it. This would be an excellent fit for Java.
I don't think the question is really, why is Java *needed* for IoT? It's more, why is Java a good choice for IoT? For which there are several compelling reasons: 1) It's cross platform, which is much more relevant in IoT 2) Lots of people know how to program in Java 3) There's a library for everything you can think of in Java and almost all of them are open-source 4) When Java was first designed your average desktop PC had 8Mb RAM and a CPU running at a hundred MHz. It still works on that form factor and JDK 9 will eliminate the issue of the weight of the libraries.
The question was "Are there any new JVM languages coming up?", there's no mention of them being standardised. The answer of Kotlin is perfectly valid in this context. Not many programming languages have a formal standard.
It's not? If anything a lot of IoT devices can't even run Java. 
You should probably still separate the general Cucumber tutorial bits from the Spring Boot bits and go a lot more in depth there. We use Cucumber for our System tests on our Spring Boot microservices and there's simply a lot more to it than you're describing. You did get the abstraction bit correct though; kudo's there. I see too many people doing REST calls directly in their step implementation. Secondly these are not E2E tests; they're system tests. An end-to-end test would go through the front-end as well. 
**Sidebar** + **Do not post tutorials here!** 
Nice. I've had HTTP2 working on with Undertow for a while now but you have to go in and manually set your own property and configure the servlet container yourself
Use JavaFX instead which has CSS support. 
**Sidebar** + **Do not post tutorials here!** **Second time**
**Sidebar** + **Do not post tutorials here!** **Third time**
**Sidebar** + **Do not post tutorials here!** **Fourth Time** and **FINAL WARNING** Next time you will be banned. In addition to the **NO TUTORIALS** rule, what you are doing is **SPAMMING** according to the reddit rules [**"What constitutes spam? Am I a spammer?"**](https://www.reddithelp.com/en/categories/rules-reporting/account-and-community-restrictions/what-constitutes-spam-am-i-spammer): + If you flood a Reddit community with posts or comments, you may be considered a spammer. Instead, post one or two times and see what happens. + If other users in a community historically downvote your posts or ones similar to yours, but you feel the need to continue submitting them anyway, you may be considered a spammer.
**Sidebar** + **Do not post tutorials here!** **Second Warning**
Ignore OP. Seems to be a spam poster who hasn't worked out how reddit works. All their posts should obviously be *link posts*, but they are only post *text posts*.
Please, *learn to use reddit*! You are trying to post link posts, but only post text. This makes your posts completely useless.
Servlet 4, to be released with Java EE 8 soon, will include support for HTTP/2. My guess is that Spring will be building upon the Servlet 4 specification. https://blogs.oracle.com/theaquarium/http2-and-servlet-4-in-java-ee-8
Thanks for the advice! You mean going a lot more in depth for Cucumber, for Spring Boot or both? There is more to tell of course but I wanted to keep it like a first approach to it for people who don't know how to use Cucumber. 
Is there any added value if your application is behind an HTTP/2 load balancer / proxy anyway? Does it make sense to go from proxy to servlet over HTTP/2?
Ah, that explains...
I pity anyone who needs to work with that stack.
Separately. And it's not Spring Boot related at all really, you can use this method for any API. On my blog I quite often have separate related posts where I deep-dive in a single topic as opposed to shallowly explaining a few. That's just my preference though.
**Wrong subreddit** This subreddit deals with **Java** exclusively. Java**Script** is an entirely different programming language. Further, if this was a question, you need to provide way more info and the post should be, as is indicated in *many places* on the site, posted in **/r/javahelp**. **I am warning you now.** If you don't stop your meaningless posts, you will be banned without further warning.
Why would one use Spring Reactive instead of RxJava?
Very well explained
I think it’s a great idea and definitely something that is missing. node’s npm is a bliss, Java is definitely late to the game
Thank you. Glad that you like it :)
Depends on the application but you'll still have a performance boost using http2 in the application behind the proxy
Would AJP be better?
If you're deep in the Spring ecosystem, it's easier to use a Spring-sanctioned library and bypass all the impedance mismatch issues that Spring brings with it (they have a serious [Not Invented Here](https://en.wikipedia.org/wiki/Not_invented_here) problem).
I feel like I've just woken up and it's 10 years ago.
If at any point you need to stop using lombok, you can automatically [delombok](https://projectlombok.org/features/delombok) your code.
Oh gosh I so hate spring. This topic sums it up. Spring boot is NOT anything to do with HTTP serving. Thats Spring MVC. Spring boot is about making Spring easier to use and intelligent enough to configure itself based on what is found on classpath. And even Spring MVC has little to do with the underlying HTTP transport - this is handled by the application server that it is running on. .....So for someone to shout 'HTTP/2' support is coming to Spring Boot, is like shouting my Samsung TV will shortly support viewing of latest series of Game of Thrones 
URI is broken in other, less severe ways. It’s too strict for addresses containing `|`, such as those in the [Google Maps API](http://maps.googleapis.com/maps/api/staticmap?center=Brooklyn+Bridge,New+York,NY&amp;zoom=13&amp;size=370x250&amp;maptype=roadmap%20&amp;markers=color:blue|label:S|40.702147,-74.015794&amp;markers=color:green|label:G|40.711614,-74.012318%20&amp;markers=color:red|color:red|label:C|40.718217,-73.998284&amp;sensor=false). URIs can be partial. This is by design but has surprising consequences. For example, the empty string is a valid URI. After fighting both we made [HttpUrl](https://medium.com/square-corner-blog/okhttps-new-url-class-515460eea661) for OkHttp. Its drawback is that it only handles the `http` and `https` schemes: no `mailto:` or `ftp:`or custom schemes here.
About the same. AJP and http2 share a lot of the same techniques.
Why?
That was my first thought too, been there, done that, never again.
So the mods comment on ~~deleted~~ [your post](https://www.reddit.com/r/java/comments/6ss83e/how_to_implement_2_way_authentication_using_ssl/) with a reason (that it breaks the rules) and you post it again?
A while ago I wrote some code that was kinda like this: Map&lt;String, String&gt; foo = ImmutableMap.of("bar", null); Optional&lt;String&gt; bar = foo.containsKey("bar") ? Optional.of(foo.get("bar")) : Optional.empty(); Of course, that code tries to put a `null` into an `Optional` which results in an NPE. How should a case like this be handled? In the end I added another check that just placed an empty string if the value for a given key was `null`, but that is an ugly hack imo.
I'm glad to see that Maven is improving. Somebody should update the Maven archetypes, too.
Why not simply: Optional.ofNullable(foo.get("bar"))
But what if there are still dependency conflicts after rearranging the order? Is there anything you can do to load two separate JARs? Will Java 9 modules solve this?
Because `Optional.ofNullable(null)` returns an empty optional. But the method should only return an empty optional if the _key_ doesn't exist, not if the key exists but its valuehappens to be `null`.
It was deleted by me only. Dont you find it useful? 
Have you had a chance to check out the autocomplete manual? http://picocli.info/1.0.0-SNAPSHOT/autocomplete.html
Correction for the @SneakyThrows part: it does not swallow or ignore the exceptions. It allows the checked exception to be unhandled. It can still be caught further up the call chain. See https://projectlombok.org/features/SneakyThrows
Spring Boot actually does a lot of auto configuration of the underlying servlet container, such as tomcat or undertow. The pull request in the link just proposes an option to enable http 2 without having to configure settings specific to the container you are using.
Honestly, this isn't a very good article. It mentions the enforcer plugin, but not how to actually view your dependency tree. It should mention that you can run: &gt; mvn dependency:tree -Dverbose In addition, you can see your dependencies in IntelliJ, either through the External Libraries dropdown in your Project tab, or via the Dependencies dropdown under your Maven Projects tab.
With things based on RFCs (also with emails for instance), I've found it's often better to make a practical implementation than to strictly stick to the RFC.
No offense, it's not about being useful. This isn't the appropriate subreddit for the material. If you posted it to /r/pics it would be just as inappropriate. It's right in the rules: &gt; Do not post tutorials here! These should go in /r/learnjava.
What's wrong with the global pool?
&gt; the vast majority of my data classes are just data classes Hmmmm. That would be an anti-pattern.
Optional has only two possible states; has value and empty. If you want a third state then you'll need a custom class for that.
If you use the global pool, you won't be able to tune it according to your application's needs. Also, It's statically constructed by the JVM and terminated upon `System.exit()`. If you want the ongoing tasks to complete before termination, you need to call `commonPool().awaitQuiescence()`, before exit. So, basically, you don't have control over it. However, there is another story to it. It may be beneficial if your application is simple and no specific tuning is required. It also prevents developers from creating too many thread pools for every task in the application.
Well, How about this scary piece of code - Optional&lt;String&gt; bar = foo.containsKey("bar") ? Optional.of(Optional.ofNullable(foo.get("bar")).orElse("")) : Optional.empty() :)
That's true, but how well enforced is that rule? At least from their titles, it looks like a lot of posts in /r/java could be considered as *tutorials* (well, one would need to formally define what count as a tutorial though). 
sorry if this is a stupid question, but isn't css for webdev? my game is a desktop application 
Functionally that'd be the same as what I have now, yes :) I guess there is no better way to solve this than to make an optional of an empty string in case the value is `null` then?
JavaFX also supports CSS in a similar way to the web but works with desktop apps. It can be used to "skin" your application. If you're using Swing though the things to check would be the look and feel classes but it's a lot easier with CSS. 
Yes please. Pull down the jars from Maven Central, drop them in `~/.m2/repository`, and set up a command line launcher (with the correct class/module/native-library path, etc). That'd be sweet.
Yes actually I could see many informative posts linking to other sites / blogs. Sorry I am new here so trying to understand Reddit. 
Javaslang/Vavr has an implementation they call `Option` which I think does what you're looking for.
I don't want a third state. I simply want to encapsulate the fact that a particular key might not exist in a `Map` by returning an empty optional but I run into some difficulties because every reference type might have a value of `null`. https://developer.atlassian.com/blog/2015/08/optional-broken/ talks about it a bit as well.
I'm not Bruce Eckel, I don't play him on TV, and I have no financial interest in this book :-). I read the original edition of his "Thinking In Java" back in the 90s and got a lot out of it. It explored how to approach problems from an OO/Java perspective, rather than trying to teach the mechanics of Java and letting the reader apply the mechanics in procedural thinking. Anyway, there are LARGE portions of the book available in the free sample link. Anyway, it looks like an interesting book. I may just get it to read parts, rather than cover to cover. I like that it is electronic. I've been finding it more and more awkward to go back and forth between a paper reference and a computer.
Hmmm weird name. I thought at first glance it would have something to do with caches.
Yep, it just automatically wraps any checked exception in a RuntimeException.
It's more map's fault for being ambiguous.
It doesn't wrap it in a RuntimeException. It throws it ignoring whether it's a checked exception. If you catch it later on you'll find that it hasn't been wrapped. You can do this without lombok with some generic type confusion, but it's a bit more verbose. https://gist.github.com/nallar/2b6fe6cb3b0af06ac5b98b731ca4e86c 
Not the OP, but having dealt with JSF and (WebSphere) portlets in the past I can understand where they're coming from - portlets have their request cycles, JSF has its, and the two work until they don't, at which point it's harder than normal to pinpoint what's gone wrong. 90% of the time it was (unsurprisingly) my code which was at fault, but the other 10% came down to bugs in the JSF-Portlet bridge jar file is meant to marry up the two request cycles. IBM always fixed the bugs, but not after a lot of wasted time and effort tracking them down as the cause. This was all a long time ago though, so hopefully all the wrinkles have now been ironed out. Possibly Stockholm Syndrome, but I do look back on the whole thing with a degree of fondness though, probably because the portlets we were creating were so varied and interesting. And to this day I'm still a fan of JSF with Prime faces et al, just in a more predictable environment.
Well, in this particular case I noticed OP posted the link, [mod commented that it didn't belong here](https://www.reddit.com/r/java/comments/6ss83e/how_to_implement_2_way_authentication_using_ssl/dlf41lj/) and then he just goes and reposts it again right away.
Thanks for the command! I just tested it in a spring boot tutorial project and works.
&gt; How should a case like this be handled? You use a `Map&lt;String, Optional&lt;String&gt;&gt;` type, which communicates better that you have a map of potentially missing values (preventing nasty surprises in receivers who don't know any better). Map&lt;String, Optional&lt;String&gt;&gt; foo = ImmutableMap.of("bar", Optional.empty()); You can also distinguish between missing key and missing value with the `Optional&lt;Optional&lt;String&gt;&gt;` type, which also communicates more than just `null`, and composes better too: Optional.ofNullable(foo.get("bar")).flatMap(v -&gt; v.orElse("missing value")).orElse("missing key"));
Care to explain?
I use (in Linux) a bash script to run Java jars: RunCommonJavaJar --help 'RunCommonJavaJar' is a shell wrapper to run Java '*.jar' files. Normal users should not invoke it directly but through a link to it, with the same name (without extension) as the Java jar file, in '$COMMON_JAVA_JARS_DIR', that it should run. If there is a bash script file, in '$COMMON_JAVA_JARS_DIR', with the same name as the jar file, it will be run first to find out which extra java interpreter options are needed to run the java application. Environment variables exported before launching Java application: 'invokationPath' is set to the invoking link (Same as '$0' in bash). 'DISPLAY' is set to the value of '--display' option (if supplied). Note: Java applications, using a '--display' option, must check the option and 'DISPLAY' environment variable and generate appropriate error messages. When run by root, 'RunCommonJavaJar' will update the links available to run common Java '*.jar' files. Current links to this script: 'ClassifyTextFiles.jar': 'ClassifyTextFiles -&gt; RunCommonJavaJar'. 'DetectCharSet.jar': 'DetectCharSet -&gt; RunCommonJavaJar'. 'Dialog_CheckList.jar': 'Dialog_CheckList -&gt; RunCommonJavaJar'. 'Dialog_DirectorySelection.jar': 'Dialog_DirectorySelection -&gt; RunCommonJavaJar'. 'Dialog_FileSelection.jar': 'Dialog_FileSelection -&gt; RunCommonJavaJar'. 'Dialog_InputText.jar': 'Dialog_InputText -&gt; RunCommonJavaJar'. 'Dialog.jar': 'Dialog -&gt; RunCommonJavaJar'. 'Dialog_Message.jar': 'Dialog_Message -&gt; RunCommonJavaJar'. 'Dialog_MessageTimed.jar': 'Dialog_MessageTimed -&gt; RunCommonJavaJar'. 'Dialog_RadioList.jar': 'Dialog_RadioList -&gt; RunCommonJavaJar'. 'FindTextInDocuments.jar': 'FindTextInDocuments -&gt; RunCommonJavaJar'. 'JavaSources.jar': 'JavaSources -&gt; RunCommonJavaJar'. 'Java_XChartDemo.jar': 'Java_XChartDemo -&gt; RunCommonJavaJar'. 'MainMenuAndNetTraffic.jar': 'MainMenuAndNetTraffic -&gt; RunCommonJavaJar'. 'PickAndRun.jar': 'PickAndRun -&gt; RunCommonJavaJar'. 'PickDirAndRun.jar': 'PickDirAndRun -&gt; RunCommonJavaJar'. 'Reminders.jar': 'Reminders -&gt; RunCommonJavaJar'. 'SearchAndPlayVideoFiles.jar': 'SearchAndPlayVideoFiles -&gt; RunCommonJavaJar'. 'ShowVideoItemInfo.jar': 'ShowVideoItemInfo -&gt; RunCommonJavaJar'. 'XBeep.jar': 'XBeep -&gt; RunCommonJavaJar'.
Ha! I was wrong about this.
Maven or Gradle? Whats the difference to `mvn install` except that Maven is more complete compared to pip and not as flawed as npm. If you think there's something missing, make a Maven and Gradle plugin.
I came here to crap on this idea but this is the right way to do it. As far as I can tell from the jBPM consultants and architects I've worked with this is standard though most would use it in a KIE server with other BPM assets. I don't know enough about jBPM/KIE/BPM Suite to expand on that any more.
Completely fair question. I have no interest in replicating something that is already out there so if Maven can do this already I would be interested to know. However, as far as I know `mvn install` is not necessarily the same thing as `npm install` and is not at all like`gem install`. `mvn install`only works within a directory containing a pom.xml and is for installing the artifact you are writing (along with any dependencies) into your local repository. `npm install` can and does work in a similar way. However, the equivalent in Ruby would be `bundle install`. `npm install` can work in a different way, akin to `gem install`, which is for retrieving a remote package, and installing it on your PC as well as sometimes adding an executable to your path so you have immediate access to some command line tool. As far as I can see, neither Maven nor Gradle provide the ability to do that? Implementing this as a Maven plugin might be a good idea but how do you then distribute the plugin itself, without requiring the user to setup a pom.xml? It also seems a bit verbose. You'll need to run it through Maven, then your plugin will need both a namespace and a goal and then you'll need the name of whatever artifact you are running (and then any commands that it takes) So rather than having some like `spring help` you would have to write `mvn my_plugin:run spring help`. I'm not sure if that is really an improvement? You'll also get a load of output (and overhead) from Maven which isn't helpful.
You are absolutely correct. The recommended way is to have a separate execution server with your BPM assets. This separation provides.. * flexibility for both your application &amp; process servers * a true centralized repo of processes * and you don't run the risk of tightly coupling your process with your application Thanks for reading (and not crapping on the idea!) I think i'll add a disclaimer at the top that there's a better way P.S. - I'm a BPM Suite consultant @ RedHat :) Unfortunately, a lot of our clients end up resisting changing to a separate KIE server
I was initially just thinking of pulling the main artifact and any dependencies directly from Maven central. So a tool author would still have to build and deploy to some Maven repository. I know that with rubygems (well actually bundler) and npm, you can reference dependencies directly from version control e.g. a Github repo. However, that feels like it really should be an extension of the dependency manager i.e. Maven itself. You would want to write an implementation of the Aether API that could use a version control repository as an artifact repository. I could see that being really useful and maybe somebody has already done that?
I also remember reading Spring Reactive is a little more Optimized because it only works with Java 8+, where as RxJava is designed to work with Java 6+(because of Andriod). I may be wrong.
I'm also a consultant at Red Hat. I usually don't have anything to do with jBPM though. I honestly figured you were because, let's be honest, I'm not sure any other company has enough people with real in-depth knowledge of jBPM/BPM Suite. It's _also_ the only way I've heard how to do this from other people doing the work. The way you outline was very clear and simple and can be accomplished with just Maven which is really nice. I suppose there's another benefit too: maybe being able to test in a more isolated fashion without having to bring along a process server. And, what's the deal with that? I see people always wanting to run things in unorthodox ways or in places that you shouldn't. Usually ignoring a consultants advice! What did they pay us to be there for anyway?
RxJava / RxJava2
Oh cool! Platform Consultant, I'm guessing? Yup, quick testing is another benefit. Unfortunately, it's pretty hard to resist the temptation to mingle a few process files in with your application JARs. ...and that's when it becomes a mess. Because now you can't change a process without re-deploying your whole application. I guess it's a case of "We'll do this right later". And then never doing it. Haha I don't know! Sometimes I think "consultant" gets misread as "staff-augmentation". But you probably already know about that..
We've actually used RxJava, but I would argue that it's a pretty heavyweight solution for the problems I was trying to solve with this repo. As per the Reactive Extensions mission statement, RxJava is "a library for composing asynchronous and event-based programs by using observable sequences." I'm not trying to do anything async or event based. Just trying to get better performance out of ordered streams of synchronous data. 
Middleware consultant but more with EAP. At least that's what I was hired as. I've actually done a lot more integration work than strictly platform or middleware stuff. Spent a fair amount of time with SOA-P and Fuse as a result. Then OSEv2. Right now I guess I'm transitioning to "Cloud" consulting or whatever because of my hybrid experience and experience with OCP and now CF. I see a lot of what you're talking about with microservices when people realize they can take all of their microservices and deploy them together as a monolith. Saw it a lot with SOA architecture too. The services themselves are decoupled but the deployment, for whatever reason, becomes a monolith. I've done a lot of long-term staff-augmentation. Sometimes it really depends on how much they treat you like their own staff.
I've been out of the web side of Java for a few years, but ... Nobody has manually coded Servlets for years. Usually new Java web sites are made with the Spring ( or other web framework ) framework, that uses JSPs that are little more than HTML-like tags with custom Java code behind them, and I think that even that kind of JSP is now defunct too. A Java Server Page ( JSP ) *was* written in a way similar to one would write an HTML page and Java would autogenerate a Servlet underneath it.
That makes sense. But why would someone use this over just Lamp Stack?
Java scales better and is more flexible ( meaning more complexity as you have the ability to do/build more things yourself ). The difficult thing for you will be determining if you need that scalability, if you need that flexibility, and if you have access to Java expertise now ( as well as for maintenance ).
&gt; what the main difference between Servlets and a standard web &gt; server running Apache or nginx? Servlets are just a [standard Java EE API](http://docs.oracle.com/javaee/5/tutorial/doc/bnafi.html) for writing web applications. If your application implements the Servlet API, you can install it on a Java EE application server (full app server like JBoss or partial app server like Tomcat), and the Java EE app server will route HTTP requests to your application. Of course, most people use a web framework (like Spring MVC) which actually implements the Servlet API, and you build your app on top of the framework. This is the same idea as Apache/nginx, different technology platform. However, most Java apps run Apache/nginx on the front end to handle things like HTTPS and load balancing (HAProxy) and configure Apache/nginx to forward requests over ordinary HTTP to the Java app server.
&gt; Nobody has manually coded Servlets for years. Beg to differ, but my use case is quite particular. The Servlet API has really stood the test of time for my cases - I can get *very* fine-grained control over how my code gets invoked and how the response gets returned. My only real complaint is that some servlet containers buffer the entirety of a request body before passing it along to servlet code... and that's a very fussy consideration.
In Java you would instead: import static org.domain.ClassName.classMethodCall; classMethodCall(); It's called static import, and was introduced back in Java 5, twelve years ago.
The example you posted is actually describing the problem itself. First of all, your first line will fail with NullPointerException, because ImmutableMap.of will not accept null values (just like the upcoming Map.of method of Java 9). The reason for that is, null values in a map are ambigious by nature - it can mean 2 things: A-an entry with that key does not exist. B-the entry exists but it's value is null. Therefore, better not to use null values in maps. After all, entry with a null value is not a "mapping". Better to keep the key in a separate collection (Set probably).
I'll piggy back onto this comment and try to add a bit more details regarding the actual question itself about the difference between a Servlet and Apache/nginx. Apache and nginx are servers that come out of the box suited for static file serving like html, js and css. (Yes they can do so much more but we'll table that for now in leiu of giving a simple answer) So if you want a static site that doesn't have an application backend (like Java to crunch some logic or connect to a database), then you can just use one of these and forget about java. Now Java Servlets require they run within an app server container like /u/_dban_ mentioned with JBoss, Tomcat, or Jetty etc. These Containers are required in order to use Java servlets which are used to process requests and return whatever content/data you wish. With a Java Servlet you can return web static web pages if you want but that would be overkill for just wanted to render a simple page. Servlets excel in handling requests that require data manipulation and returning either web pages or simply data (in xml, json, what have you form) that contain information pulled and manipulated from other services or data structures (like databases).
it's really project reactor (http://projectreactor.io/) which has no dependencies other than Java 8 i picked it over RxJava because it builds on top of Java 8 (vs RxJava2 which is merely "java 8 friendly") there's also a shared project where the two work together, https://github.com/reactor/reactive-streams-commons i'm not using any other part of the spring stack - reactor can stand alone
I second this, depends on the use case.. Java Servlets with JSP/JSTL still make a good, clean, solid base with no mysteries.
Thanks for the link!
Yeah, don't know. One of the authors has been doing [similar work in the past](http://www.cs.technion.ac.il/~lkeren/scp.pdf). I guess jOOQ wasn't interesting to them from an "academic" point of view... After all, jOOQ is "just" a commercial manifestation of a topic that has been researched by several people over the past 20 years.
fair
You’re welcome!
Easy, static &lt;K,V&gt; Optional&lt;Map.Entry&lt;K,V&gt;&gt; getEntry(Map&lt;K,V&gt; map, K key) { return map.entrySet().stream().filter(e -&gt; e.getKey().equals(key)).findFirst(); } 
The ugly hack is using null to begin with. The creator of null acknowledges this as his greatest mistake. Optional is a solution to using null, so you should look at why you're using null here and stop that.
There is no need for a 'p'. Your 12 factor app should be a REST endpoint and your javascript or browser or mobile version should be asking for the json it needs. Put that logic onto the device not your webserver. Also mysql is at a choke point, it is hard to scale sql laterally and geographically. 
 Optional&lt;String&gt; bar = foo.compute("bar", (key, value) -&gt; Optional.ofNullable(Strings.emptyToNull(value)))
Good article, but it's still better than not learning at all. Getting your feet wet is part of the process of learning how to program. 
If you don't have a programmers mindset when you learn how to code, you will pick it up sooner-or-later. Learning how to code can be very frustrating, so anything that eases you in to that world is a good thing.
Agreed, code academy helped me get my foot in the door and opened me up to the idea of programming. I'm now studying Computer Science at university and can't get enough :) 
https://i.imgur.com/enobUAi.jpg Thought this was a great ad on this article. 
Pretty sure that r/javahelp would be better
You don't get MVC architecture with just php.
This is a common problem with Eclipse users and JavaFX. See: * http://www.eclipse.org/efxclipse/index.html. * https://stackoverflow.com/questions/15592775/javafx-is-not-recognized-in-eclipse * https://duckduckgo.com/?q=eclipse+javafx&amp;ia=web
Wow, really awesome. Looks like exactly what I was looking for. Thanks for all the help.
Thank you. I will try there as well.
Thanks. I'll take a look.
Try e(fx)clipse first. It solves a lot of problems getting Eclipse to work well with JavaFX. When I have to use Eclipse, this is where I start. If you can't use it for whatever reason, try the second answer in the stackoverflow link. It describes how to link the .jar that has the JavaFX classes manually. I have done that too, and it works well enough. :)
Code academy can be useful if you already know how to program and want to pick up a new language quickly. That's what I did with python.
fuck the mods
They teach you the syntax but not how to code using that language. 
for a brief time I used codeacademy to keep up with my basic html/css skills. I wasn't using it on my own projects back then, and I was too busy to do so, so I would do the basic web design courses to help me remember what i'd learned. I learned to code in college courses before I even heard of codeacademy, and codeacademy was a joke compared to the courses i've taken, but it's important to keep up with the basics. Maybe some people can remember HTML/CSS properly without using them, but i'm not one of them.
Every Human Being is a Potential Hitler, too.
That is your personal point. But the point of this thread is to simply find out what is the least favourite thing about Java among redittors. It is a good introspection practice for any{thing,body}, in order to enhance. Nobody is asking for a replacement. You only like Kotlin and want the world to know that. I'm too lazy but you deserve an "nobody cares" meme: http://knowyourmeme.com/memes/see-nobody-cares
I looked at the stack overflow and it says the javafx jar is jfxrt.jar, but i don't have rt. My 32 bit for some reason has jfxswt and the 64 bit has javafx-mx Edit: NVM I found it under the ext folder lol. Of course I would do something stupid at a quarter passed midnight.
Marketing videos to make you feel better about yourself with bright background music, with a series of contextless quotes.... Only one counterpoint needed: Have you ever worked with or interviewed someone who has a C.S. degree and whose intended career is software-development ... and yet they're absolutely terrible at coding? Perhaps anyone can be a coder, but that doesn't mean they're actually going to be any good at it.
Do people in open source projects ever give coaching advice on design? I can code on a line by line level, but by bigger game is weak...
What happened to [your promise](https://www.reddit.com/r/java/comments/6o5rdy/java_recursion_for_starters/dkf4478/)?
Absolutely. There is a community dedicated to helping you get into Open Source projects. Check this out: http://www.firsttimersonly.com/ Using this resource will connect you with people who have specifically gone out of their way to help out Open Source beginners like you. Open Source is an excellent way to enhance your coding skills. The best way to get better is to get in over your head and work with people who are better than you. if you are always the smartest person in the room, you will hardly ever grow. Also, before you get into Open Source, you need to learn to use GitHub and other kinds of version control platforms. The easiest way is to use the Github Desktop program. It makes it very easy to use Github's Version Control. Also, CodeAcademy has a decent course on the git version control platform. It's very similar to github, but they aren't exactly the same. Good luck!
Syntax is still very important, and in my opinion, the most difficult part of coding to learn. 
First and foremost a "standard web server running Apache or Nginx" will only serve static HTML and CSS etc. The P in the "LAMP stack" is something that the server has to be specifically instructed to do so it passes these requests to the PHP interpreter. The same is done when you have a Java based web application. Typically there is a web server (Apache and Nginx are very good at serving content) that knows it has to pass certain requests to a Java application server. Tomcat is the most well known but there are loads of others. That Java application server is 'running' your Java web application. Somewhat similar (but also a bit different) to how your PHP installation runs PHP. Servlets are nothing but a spec for these application servers: following this spec means that you can use whatever application server (Tomcat, Jetty, Glassfish) to run your stuff. But like in general companies don't use "plain" PHP but use MVC frameworks like Laravel, in general companies don't write 'plain' servlets either but use MVC frameworks like Spring or Grails who do a lot more for you. As for the "why": I ask you; why not? Java has a huge mature open source ecosystem that has multiple free libraries available for pretty much any task there is. While Java the language has it's warts the same definitely can be said about PHP and for me Java with it's more strict OO and static typic is definitely the winner there for complex applications. And last but not least; it's fast. The Java Virtual Machine (the 'engine' executing the compiled Java code) is very well tuned and as close as you're going to get to native performance with a garbage collected language. 
&gt; If an object has an instance variable of its own class type, we say the object is recursively linked. Who is "we"? You basically made up this definition yourself. 
Thank you very much for this response I learned alot from this. Going to continue to learn Java and hope to make a java application soon.
Are you using OracleJDK or OpenJDK?
That is how new definitions work, dont they? 
It's interesting how many people call it Code Academy, when it's not actually called that, our minds are trippin with us peeps! 
Okay, sure. I now define the toString method as "a class". That sure won't confuse people!
/r/javahelp has a lot of great resources in the sidebar / FAQ.
From the article a complaint is: &gt; without any real instruction on how you’d apply them to real-life problems. But then goes on to show the programming golf challenge: &gt; Rövarspråket is not very complicated: you take an ordinary word and replace the consonants with the consonant doubled and with an "o" in between. So the consonant "b" is replaced by "bob", "r" is replaced with "ror", "s" is replaced with "sos", and so on. And the first answer is [brainfuck](https://www.reddit.com/r/dailyprogrammer/comments/341c03/20150427_challenge_212_easy_r%C3%B6varspr%C3%A5ket/). Many are one liners that someone should never write professionally.
- PHP is slow - Apache is slower than nginx - Being able to work in Java gives several advantages over PHP in larger teams - way more finely tuned control over what you're doing, whether streaming request bodies, responses, etc - it's not uncommon to forward request from nginx to your servlet container, using AJP Java is used in large-scale enterprise applications. If you need to do something quickly and work just by yourself, like a blog with a few visitors, or you depend on a PHP framework, then you don't need the development overhead of doing it in Java.
npm is broken as f***
Nah not really. Problem solving is.
Then you need an implementation of Map that doesn't allow for a KeyValue pair to be added, if the value does not exist. /u/_dban_ has a great response.
Well that would be nonsense because "a class" is already defined as something else. As far as i know "recusivly linked" isnt yet defined in Java, is it? 
Well, I think it is closely related to well-known problem of learning something in order to solve a concrete problem, and not to gain a general knowledge in some field. People now prefer to copy ready-to-use solutions from stackoverflow without even thinking how they work internally. This approach works well if you simply want to get a job in IT, but also causes a lack of real experts.
Thanks for pointing that out. My first impression of the article was how elitist it is, and that reinforces it. 
I've done this.and it's very handy. All the launcher needs to do is write a temporary pom and launch mvn java:exec against it, passing any command line args.
Until you need to debug your jsp... There's good reasons why jsp isn't in fashion anymore
There are mvc frameworks for php
I got it right from oracle
Java is compiled, JVM bytecode is interpreted
That's just not right
1. Fuck the ads on that site 2. Codecademy is a self learning tool. It's up to the learner to revisit a topic whenever they need. 3. Don't know about the author, but at the uni where I went we've learned to code first (syntax) and the programming mindset came with time as we solved problem after a problem. 
Can you give an example? I imagine that using optionals is more verbose, but also more explicit about type information.
That's adorable.
Linking is a well defined term common term in CS.
I like to bounce between Code Academy and Team Treehouse. I like Treehouse video courses but somtimes their challenges are to hard and projects are ridiculous. I have to pratice somthing over and over again before I can get a good understand not watch a video and magicly apply that knowledge to a project senerio. So I like code academy bc I can pratice coding (like actually writing code) and they tell you step by step what to do. 
There is the [KEEP - Kotlin Evolution and Enhancement Process](https://github.com/Kotlin/KEEP). And then Google and JetBrains are planning a "Kotlin Foundation" to develop Kotlin vendor independent. And all the Kotlin stuff is open source, so I can not spot any "vendor" lock-in here ...
Mh i see your point, but the naming makes sense as the example is a linked list. 
[False](http://imgur.com/aCtarZB)
[I raise you one better](https://imgur.com/a/uJhvN)
Duolingo is a self-learner tool. But they make you repeat a word, sentence, whatever, a couple of times within a single exercise session. they also make you have refreshers after some time.
There is no Java code to debug in my JSPs, thanks to JSTL. Any debugging is done via the Java methods called from JSTL tags. Works beautifully for me. Your mileage may vary :-)
&gt; Minimal Value Types prototype is available for experimentation by power users who are conversant with the Java Virtual Machine Specification and are comfortable generating byte code and working with MethodHandles. https://www.youtube.com/watch?v=vewkfFu8Q7I
What if you have multiple null producing values in the same computation? public class Person { public ContactInfo getContactInfo() { ... } // or return Optional&lt;ContactInfo&gt; } public class ContactInfo { public String getEmail { ... } // or return Optional&lt;String&gt; } public class Message { public String getContent { ... } // or return Optional&lt;String&gt; } For example, this: Person p = ... Message msg = ... Mailer mailer = ... p.getContactInfo().flatMap(ContactInfo::getEmail).flatMap(email -&gt; msg.getContent().map(message -&gt; new MailRequest(email, message))).ifPresent(mailer::send); vs. Person p = ... Message msg = ... Mailer mailer = ... ContactInfo ci = null; String email = null; String message = null; MailRequest request = (ci = p.getContactInfo()) == null ? null : (email = ci.getEmail()) == null ? null : (message = msg.getContent()) == null ? null : new MailRequest(email, message); if(request != null) { mailer.send(request); } The problem isn't with a single `null` value, it is with the proliferation of `null` values, which requires stacking short-circuiting `if` statements or ternaries. The `Optional` type lets you abstract out short-circuiting logic using `map` and `flatMap`. You only use `ifPresent` at the end of the chain. Also note that without `Optional`, nothing in the type system tells you that those are null producing methods. You would have to read the documentation or do defensive `null` checks. BONUS: The "traditional" way to solve this problem in Java: public class Person { public ContactInfo getContactInfo() throws NoDataException { ... } } public class ContactInfo { public String getEmail() throws NoDataException { ... } } public class Message { public String getContent() throws NoDataException { ... } } try { mailer.send(new MailRequest(p.getContactInfo().getEmail(), p.getMessage()); } catch(NoDataException ex) { // Nothing to do }
How did you calculate the `email` value? That requires going through a bunch of null checks to calculate. Also, `msg.getContent()` can return null. But `MailRequest` might not be equipped to deal with `null` content. Also, `p`, `msg` and `mailer` cannot be `null`, but you did a `null` check anyways. Is that a defensive check?
&gt; you will pick it up sooner-or-later. I have to disagree, I still see coder with 10+ years of experience not giving a shit about the mindset or how to do things better/right. They still code until it seems to work and then they leave.
I see you've edited your example. Both `info.getEmail()` and `msg.getContent()` can be null. What if the `MailRequest` throws an `IllegalArgumentException` if you try to pass `null` arguments? Even worse, what if `mailer` does not expect `null` values for email or content, and throws a `NullPointerException` far removed from here? For example, if it tosses the request into a queue for later processing. How would you diagnose the error? The ternaries applied short circuiting logic to prevent these problems. &gt; with regards to defensive null checks, you'd have to do that &gt; anyway with Optionals. No, and that's the point. Defensive `null` checks would be pointless for `Optional` because if they are ever `null` it's a programming error and you should bail because the program is no longer in a trustworthy state.
JavaFX has something similar, but its not backed in the language.
&gt; I wanted to recreate your null-check logic properly. Yes, and you didn't recreate the null-check logic properly. This is the exact problem with null checking logic. &gt; One big reason that you do defensive null checks because of &gt; potential programming errors. Most of the time, it is better to [fail fast](https://blog.codinghorror.com/whats-worse-than-crashing/) rather than proceed when you encounter a programming error. &gt; But if it's 3rd-party code then you need to check for nulls EVEN IF &gt; it's supposed to return an Optional. If 3rd party code returns an `Optional` and it has a `null` value, then there is a bug in the third party library. In which case, you want to fail as soon as possible with a `NullPointerException` and then report the bug. The library is producing untrustworthy values, and it is better to fail fast. Fruit of the poisonous tree and all. If the third party library is returning an ordinary reference, I would check the documentation to see if it can *possibly* return null, and then wrap it with `Optional.ofNullable` depending on what I find out. Bonus points for the type system now reflecting the type of values that the third party library can return. &gt; If the compiler refused you to write code that returned null when &gt; Optional&lt;&gt; was specifie That would be nice, but is not necessary. I would rather fail fast in the face of nonsensical values. 
https://learnxinyminutes.com
&gt; It's not an issue of just failing fast, but how you handle the fail. Exactly. And handling the fail is either at a higher level of the code, or by bug report. Proceeding with bad data is a recipe for worse things like data corruption. &gt; We data check all values from 3rd party libraries as a general rule &gt; because we need server stability and decipherable logs. Asserting on your input parameters is a good idea. As in my example, it would be better for `MessageRequest` to throw an `IllegalArgumentException` if you give it a `null` parameter value rather than let `Mailer` fail at some random location. Logging the exception also helps because Java's stack traces point out the exact location of the error, especially when coupled with robust input validation and failing fast. &gt; my original point is that standard null checks provide simpler and &gt; more readable code The problem with standard null checks is that they don't combine very well, which was the entire point of the example. You end up having to stack null checking logic to achieve short circuiting behavior. Each check that you add increases cyclomatic complexity and hinders readability since the happy path is obscured in the conditional logic. This is one reason I am actually a fan of checked exceptions. The point of `Optional`, other than clearly indicating that a method can return no value, is that it abstracts out the short circuiting behavior, resulting in simpler and more readable code.
Not only that but coding isn't just problem solving or bashing out code, it's translating business requirements into code. Being able to do that and learn coding and having the soft skills cuts down the number of people who can do it dramatically. 
I use Eclipse (and notepad++). I am happy with both and have enough ram that there is no sluggishness unless I am giving it a reason to be running out of resources.
Why would I be reading bytecode? I read Java source code. [Cyclomatic complexity](https://en.wikipedia.org/wiki/Cyclomatic_complexity) is a measurement of the number of states in a program. Each branch increases the total number of states. It has nothing to do with bytecode. Furthermore, *if* there is a performance problem *and* I have identified the code as a hot path in a profiler, *only then* would I optimize at the cost of readability. 90% of the time, readability wins.
**Cyclomatic complexity** Cyclomatic complexity is a software metric (measurement), used to indicate the complexity of a program. It is a quantitative measure of the number of linearly independent paths through a program's source code. It was developed by Thomas J. McCabe, Sr. in 1976. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
And in codecademy you use loops only in the loops lesson ? To learn programming you most of all need projects that are possible to complete.As you go through the project you will repeat everything often enough. Advice - when you do self learning never make shortcuts like copying code, etc, even if it's just some boring boilerplate.
I mean without actually invoking Maven. That's kind of overkill.
Typed languages seem to work better for the maintainability of larger applications, usually Enterprise-ish applications.
Sure, it's simpler in the same way that dynamically typed languages are simpler than statically typed languages. The counter argument is that explicit type information makes programming safer and more informative. A compromise I find useful is to just use null references within a single method, but anytime I'm dealing with return types or input types, I use optionals instead.
&gt; So whilst there are many command line tools for Java There are? I don't use any nor do I think I would want to. I can only imagine the frustration of the *looooong* JVM startup times for what should be a quick command line task... &gt; Is there already something like this in Java that I've missed? I haven't seen anything. Maven/Gradle/Ant+Ivy come close, but that's not really the same thing at all. Great for distributing libraries, but executable tools? Not so much. 'Nix-based package managers (apt-get, yum, and the like) get some of the way there, but the onus for dependencies and execution is still all on the developer. &gt; wondering if it is worth open sourcing and releasing? If you want to support an open source project, then do it. What really matters is your willingness to maintain and promote it. If you have the drive and believe in the tool, go for it.
interesting, the last few weeks i was reading about sparkjava too. But i think that this micro framework was make by an Argento coder like me. So i will create a dummy app to see it in action. Saludos!
I'm intrigued. which part do you disagree?
IIRC, if you specify the correct params for mvn install, it does not require a POM.
First, JVM startup times are a few milliseconds these days. Second, there are a number of really great JVM based CLI tools. 
Read the article. :)
well javascript was written in 10 days, and look at what crap we have to deal with now. Let them take a few years, it's fine. I'm happy all the big boys are on it. 
Looking forward what he is going to update in the new release of that book in october this year
Jooby is pretty awesome, I do like the minimal approach and how it's integrated with a lot of libraries and frameworks :) 
Was this comment going somewhere? Feels like you stopped short of making a point. Anyway, I'm quite impressed with the work the JVM team has done. Especially with runtime performance. Startup times are greatly improved, but they are still huge compared to native programs. That doesn't invalidate the usefulness of such tools, it's simply a consideration. I probably didn't express that well in my original comment. &gt; Second, there are a number of really great JVM based CLI tools. Absolutely. I love Gradle, for example. I don't know of many other JVM-based apps that would fit into the style of npm or rubygem utilities though. I wonder how many of them would pop up if a tool such as this became popular? Quite a few I would imagine...
That is amazing. I love you. 
I've been using this framework for a while now, the thing that stood out to me the most is the helpfulness and friendliness from the core developers
yes, because everyone will build the next google/facebook/dropbox. 
[removed]
It's happening!
I think you are missing the point of the write up or didnt read it. Jooby is a micro framework and typically micro frameworks aren't suited to large scale apps depending on the definition of *large scale. However the medium post demonstrates that with the right modules you can structure an application in such a way that lends itself to be suitable for large scale application development. *Large scale in this definition i assume to be more than a couple of controllers/routes and probably in the relm of 50-100+. 
[Xtend](https://www.eclipse.org/xtend/) can do this, and so much more!
The method returns the specified line as an `int[]` and accepts two args: an `int` that can define any arbitrary line to return and a `bool` that defines weather or not each line is printed to the console (mainly used to debug the function - it only stores one `int[]` in memory.) This is also an optimized version that uses an in-place algorithm rather than my previous version which had some temporary arrays laying about. My next goal is to use this method to expand high degree polynomials.
I still think it will be interesting to see what happens with the TIOBE numbers once widespread support for Web Assembly happens in browsers. Speaking of which, does anyone know of any compilers to compile Java to Web Assembly?
TeaVM compiles Java to JavaScript but compilation to WebAssembly is experimental (&lt;https://github.com/konsoletyper/teavm&gt;)
Very slick. It's nice how direct the mapping is. WASM does seem remarkably similar to the JVM in so many ways, albeit without many of the JVMs features. Sulong is a similar project.
Is it? You want to resolve and download dependencies, which is maven's core function. You'll need do load and process poms, including handling properties that can be inherited from parent poms, set by plugins - which you will have to run - etc.
1. Since this is help with *Java programming* it should be, as the plenty hints on the page indicate posted in **/r/javahelp** 2. Mediafire is not an approved code hoster. The approved ones are *pastebin* and *github gist*. 3. If you want help, you cannot just throw your code at us. You need to explain a lot more. Kindly **read** and **follow** the [**Posting Guides**](https://redd.it/48eykt) in **/r/javahelp** and then repost there following all the instructions.
&gt; node’s npm is a bliss Ignorance is bliss. NPM is basically a mess prior to v3 and have you forgotten about [this](https://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/)?
[picocli](https://github.com/remkop/picocli) autocomplete is in beta. Please give it a try. Looking for feedback. Bug reports, feature requests, comments, suggestions, doc improvements, etc., all are welcome! Your contributions make a difference. No contribution is too small.
:D
Node.js
Don't say it because people get salty here reading the truth
How much RAM do you have? 
 What are VM params? What plugins are running? 1.3gb including embedded server? Memory consumption != performance
Also allocated != used memory (you can enable Memory Indicator in IntelliJ)
As a newbie can someone please explain to me why this is down voted so much? I don't know much about node but heard you can implement server side stuff with it. Serious question.
Going by the chart the popularity of Javascript is not really growing much overall. edit: I mean its literally true. That's what's on the graph. If the data is wrong for some reason, please, point that out. That there is a vote war over this comment chain is pretty silly.
VS is worse for me.
JavaScript just sucks. It's a braindead idea even considering Node.JS for anything serious.
That's what the Maven Resolver library is for. You don't need the build system parts for that.
https://github.com/geany/geany
TIL - thanks!
node. node is taking over... :(
Lmao 
~~Can we take this data seriously if Scratch is in the top 20? Serious question.~~ ~~How is it that a programming language used only for teaching purposes is in the top 20?~~ My apologies to TIOBE, their methodology is spelled out on their website: https://www.tiobe.com/tiobe-index/programming-languages-definition/ It looks like rankings are determined by search history.
Don't count on anything!
The way community contributing and evolving, it would be difficult.
It keeps getting less relevant so I think it will lose its #1 position at some point. Google trends: https://trends.google.com/trends/explore?date=today%205-y&amp;q=%2Fm%2F07sbkfb,%2Fm%2F02p97,%2Fm%2F07657k pypl index: http://pypl.github.io/PYPL.html Tiobe index: https://www.tiobe.com/tiobe-index/ Even if Oracle cared more about Java it would be difficult to maintain its position because of high competition. 
Is it? A few years ago, if you accept Internet forums as a valid source (usually, not a good idea) it seems that *everybody* was using Node.js for *everything*. Nowadays the situation is quite different. Node.js is still very popular, but many people have moved to other languages, like Go or Python.
not because of competition but because nowadays it is cooler to try the next buzzed language than anything else
NetBeans has been available all along and has been very good since around version 7.2.
Well because you're in /r/java. If you want a framework that uses the MOST resources (JVM) and has the MOST boilerplate (https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition) then by all means, use it. Unfortunately the world has moved on long ago, with (as someone else mentioned below) langs such as Node, Go, and others taking over. People are finally learning that despite what the brainwashed say, you _don't_ need OOP as much as college led you to believe. Also with microservices architecture as popular as ever, people are using fast, efficient languages to handle their web frontends/backends/CRUD APIs and sending "complex" BL further downstream for processing by other microservices, which can independently use more robust languages when required. So people are definitely still using Java, but instead of for common use cases, only when *absolutely* required. This leads to decreased usage overall. 
You may disable the IntelliJ idea plugins that you do not need. https://www.jetbrains.com/help/idea/tuning-intellij-idea.html http://p7h.blogspot.fr/2012/12/intellij-idea-tuning-parameters.html https://www.emacswiki.org/emacs/JavaDevelopmentEnvironment https://stackoverflow.com/questions/253170/tips-for-using-vim-as-a-java-ide
I can say, with 100% certainty, that it will not be #1 forever. Actually, I can go even further and say (again, with 100% certainty) that it will even cease to exist at some point and that no programs written in this language will be running on any computer.
https://trends.google.com/trends/explore?q=Java7,Java8,Java9,Scala,Clojure
I’d say quite a lot of people still use node and it continues to gain popularity. Python has always been an up and comer, and it always will, it definitely has its place. 
JetBrains is doing some amazing things with Kotlin. The language and tooling and libraries are well designed and it targets the two major web platforms (the JVM and JavaScript). Kotlin/Native will extend the reach of the language to everywhere else. And then there's Google's official support for Kotlin on Android. And finally, Gradle/Kotlin for your build scripts. At this pace it won't be long before you can use Kotlin for your build scripts, your Android .apk apps, your web apps (JVM/JavaScript), and your native (Microsoft/Linux/iOS/Android) apps. 
I'm not sure what the point of this question is. No language ever has or ever will remain #1. It would be sad if Java was #1 forever because that would fundamentally mean software programming languages stopped evolving. A better question is: what language should I use? Pick the language that best meets your requirements for the design lifetime of the system or application that you are trying to deliver and falls within the skill sets of the team. 
&gt; It would be sad if Java was #1 forever because that would fundamentally mean software programming languages stopped evolving. That's only true if the language itself doesn't evolve. For example, C++ today is vastly different from C++ in the nineties, and Java most likely evolved a lot as well.
Not a huge fan... To me, this looks like replacing standardized, easy to read boilerplate code with smaller but harder to read boilerplate code
All languages receive incremental changes and my 1st OO language was C++. Every language has it's time, but eventually a new programming paradigm will take over and unseat Java. As far as C++ being vastly different from it's peak in the 90s, I don't think so, it's still an OO language, it still allows the developer to manage objects memory. By 'evolving' I mean in fundamental way, such as no longer being an OO language. Java has bolted on aspects of functional programming for example, but it remains an OO language. 
Honestly, considering the low cost of RAM nowadays, 1.3GB of memory usage shouldn't be an issue.
I don't care too much about languages. Have done Fortran, Totally-Beginner-Java, Python, C#, Typescript and now came back to Java. Yes, it's nice to have lambdas and streams since Java 8 and yes, I'd prefer to use Kotlin. But the reason why I'm using Java now is Spring. And I'm using Spring with Java (not Kotlin) because I need to get things done and I don't want to spend more time figuring things out then writing a bit more boilerplate.
It is
1.3GB is not much. I've used Visual Studio for a long time and now IntelliJ. I actually think IntelliJ is much better - feature wise and coding assistence wise. However, IntelliJ (and WebStorm) tend to slow down from time to time, when e.g. open some large files or deleting files ... then I usually restart IntelliJ and it's back good and reasonable fast.
Edgy opinion there, friend
Fair enough, if a new paradigm happens then it's unlikely that existing languages will completely transform.
I'm actually moving an API from Node to Spring. Don't know yet, if it's a good decision. Time will tell. I've reinvented the wheel so many times ... this time I want to see how well tools like JPA or Spring Batch work. I think the main reason for nodes success is the lack of experience of the developers.
c# is on the rise. A lot of people are hopping onto the .net bandwagon, and i'm pretty sure it isn't a fad. It's java-like, but for some reason some people like c#/.net better than java.
Agreed. I'd rather spend money on a ram upgrade than not use intellij.
In the longer run .NET core. Java developers can be productive really quick. It's a nice step to go from Java to C# . The comunity is small right now but it will grow. 
Don't cut yourself on all the edge in /r/java
Yeah well, they said the same thing years ago about Scala.
The debugger is horrible. Also it lacks in documentation. Currently building software on top of their ide and it's not a good experience. 
Any real engineer knows that the JavaScript programming language is a disaster (especially if your name includes "Haskell") and NodeJS doesn't bring a benefit to server-side compution. "Event-loop" is no innovation. NodeJS is a wrapper around a thread-pool (written in C++) that does the I/O work, because JS lacks a true multi-threading model. NodeJS is little more than this: ExecutorService executor = Executors.newFixedThreadPool(4); // yes, fixed at 4 cores 
Go :)
Don't bypass the map by doing a O(n) operation. Use the API correctly: [Map.containsKey](https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#containsKey-java.lang.Object-)
Language wise C# is not a massive improvement over java. In fact, in performance areas it's worse. My experience has been that the C# people are people who have been writing windows code for years, and want to stay in their comfort zone. Or managers the same.
Well it's not like JavaScript and C# are becoming more relevant each day.
C# peaked in 2012, when it seemed like it might be a big competitor to Java. Then it lost momentum, and all the features that C# has that Java doesn't have are now available in the form of other JVM languages and Java libraries. There's a lot to lose from switching to the CLR and not a lot to gain.
Scala is in my opinion a more productive language than Kotlin, but Kotlin is much easier to use. A developer needs a week at most to be as productive writing Kotlin as writing Java, nearly everything but syntax is the same, and most of what Kotlin adds is things that Java already has but in a more verbose/un-intuitive form. 
Are you only running a Core 2 Duo with 2GB RAM and Windows XP? Today, 1.3GB RAM usage is nothing. If that slows your computer down, you need a new computer.
you know what killed scala, right? java 8 just taking the best parts of it :-) same will happen with kotlin imho
&gt; Any real engineer /r/gatekeeping
Plus lets not forget that PHP still powers like what, 80% of websites? That is NOT a small number.
That and the fact that *changing* Scala is a massive pain. Yes, you will need to change your codebase. Just because the way your program functions today is completely correct does not mean that way will always be correct.
Not really. If you check trends it mostly follows Java but with much lower numbers. 
I've worked with C# and .NET on and off over the years, and while I have envied some of the features of C#, I've always been turned off by the .NET ecosystem. The vast amount of quality open source libraries available in the Java ecosystem dwarf what is available in .NET. .NET in comparison seems to me like a commercial wasteland. Consider how much traction the Spring Framework has in the Java ecosystem, an independent effort from the "Oracle way" with JavaEE. I haven't seen anything like this in the .NET world. And even when it comes to JavaEE, consider how many standard application servers there are that aren't developed by Oracle. In the .NET world, you're likely going to be using IIS and Windows Server and not on platforms independent of Microsoft. Recent moves towards opening up .NET might change things, but .NET still has a long way to go to catch up to all of the libraries and open platforms available for the JVM.
Honestly, I don't think anything is taking over. Maybe Kotlin? Everyone I know who knows Java and Kotlin says that Kotlin is like a better version of Java.
The data doesn't seem to bear that out. C# hasn't seen big growth, and it's just not a cool language that will gain a bunch of currency with the trendsetters. I'd look to up-and-comers like Go, Rust, Clojure. They're small now, but growing fast
I know people like to complain about high memory usage but this is very true. Even if you only have 8GB of RAM, 1.3GB is still only 16% of your memory which leaves a lot left over. edit: downvoted for agreeing with him, lmao
I have a pretty old laptop(more than 6y) and only 4GB RAM. It is sufficient for IntelliJ, chrome and a music player. I have to keep and eye not to have too many chrome tabs open (usually when I reach about 10 I begin to close the unused ones). Can't say I don't wish sometimes for more RAM, but most of the time I'm really comfortable. I also have copies on Intellij with plugins enabled for specific projects (web/java etc)
Honestly, with that lack of RAM, and likely other weaker hardware, it may be worth considering installing Linux with a nice lightweight DE like xfce. Are you not able to install more RAM in your laptop, or is it soldered on?
C# lost momentum mainly because people didn't see a future in a locked in platform compared to the vibrant echosystem around the jvm. With .NET core it's another story. Microsoft is building it around the comunity. 
&gt; I simply want to encapsulate the fact that a particular key might not exist An Optional&lt;Map.Entry&lt;K,V&gt;&gt; is what bcd87 wants. The only way to get that is through iterating entrySet. Not our fault the Java API doesn't lend itself to high performance on large maps in this case. containsKey does not return the entry if it exists. It returns a boolean. Besides, you're comparing apples to oranges. O(1).hashcode() could easily be slower than O(N).equals(). Why do you come here not offering answers, just crapping on other people? Is that the sort of person you want to be?
&gt; In fact, in performance areas it's worse. Depends on how you write your code. If we're doing a direct translation from Java to C# I'm not expecting much from the latter. But if you stick to C# idioms such as value types and true generics you can see some significant gains.
Node is a poorly designed platform. The APIs are badly written and frequently have breaking changes from one version to the next. Until recently the package manager was ridiculously bad and would often download the same package dozens, if not hundreds, of times because of the way it nests dependencies. The main language, JavaScript, is not suitable for organizing large applications for a variety of reasons. It is single threaded, like toy languages from the early 90's. There is no standard library, so each application is liable to be very different from the next. Really the only reason it exists is that Ruby is stupid slow, Java tends to be overly complicated (e.g. JEE, Spring), and .NET only runs on Windows. The latter two are being solved, taking away the reason for Node to exist. 
i want to use kotlin more. it's just hard at my current position
It will stay for a long time, specially with Android . #1 spot ? Not so sure, it can be #2 or #3, who knows . But eventually a new language will take its place, see Kotlin or Python, even Javascript. Point is nothing stays forever, no matter how long it was there . 
Don't go Node or you'll get ticks and be homeless living on the streets. 
Have you increased your JVM heap size at all? I generally notice performance issues when the GC starts thrashing trying to free up resources in a hurry - I generally set my heap size to 2GB to give enough headroom while still keeping it small enough that the GC won't take a century sweeping the old generation (considering many objects in the IDE do live past eden depending on how long you keep a file open).
Java the language? Maybe, I don't think many people are attached to the language itself but the library ecosystem - JetBrains is making amazing progress with Kaitlin adoption and considering the official support from Google I think it has a good chance of supplanting Java The Language. Java the platform / lifestyle ecosystem? Not unless something else gains near ubiquitous presence in the language arena with similar performance to the point that more libraries are ported/developed for it. There's a Java library for almost any task, .Net isn't even close.
If the universe ceases to exist tomorrow will no Java programs run on any computer?
&gt; Map.Entry&lt;K,V&gt; _dban_ has a better answer anyway. But iterating on a Map is bad form. I've seen people do that and their code literally ran for hours. If you are stuck with doing that on a Map, you are not using the proper data structure, and doing something that will slow your app can't be good. At that point, OP original code does what he needs, and is fast.
I'm not convinced either, but I love the experimentation -- challenging aspects of the language and API that we take for granted. Eventually some of these wacky ideas turn out to not be so wacky after all!
C# is a much better language then java, although java 8 helps a bit and now it's going cross platform so it's more attractive then it used to be
Entire program code include in a single post
Had Android adopt Scala years ago?
Learn it and prepare to switch. Things happen ;)
I have written things in a lot of languages. I have the highest hopes for kotlin 
&gt; The TIOBE index for August 2017 shows Java as the world’s number one programming language in terms of popularity, but interest continues to fall. Yeah. Stopped reading right there. It's amazing how many sites keep to quote a fundamentally flawed metric and base their entire narrative on a number that is just fundamentally wrong. Tiobe is first and foremost created by a company that uses it to direct traffic to their 'consulting' site. Keep that in mind. Tiobe works by simply counting the number of hits on "&lt;language&gt; programming". What's wrong with that? Well; first and foremost it obviously would not measure popularity. If it would measure the amount of hits, assuming stuff only rarely gets deleted, the number of hits would grow right? So if there's a relative big dip in a language the others should shoot up correct? Funny how that doesn't happen. So what's really happening in those big dips you see? It's simply search engines optimising their searches. As anyone who has used text indices (which does not seem to be the creators of that index) knows there is a very long tail of 'garbage' results. So if you search for "c programming" at the end of the list there will be a ton of text document just showing how for example an Arthur C Clarke documentary got cancelled because of a change in programming. This means that the method Tiobe uses strongy favors short and common terms. C will match with C, C#, C++ etc. Java will have references to the programming language, the island, coffee, etc. You don't see these in Google because google will only show you the first 1000 results and is really good at figuring out context, but if you search "C++ programming" on for example Bing you'll see what I mean. So let's take a look at the [graph they show](http://i.imgur.com/Ek9m55b.png). Take a look at Java in 2004-2005. In just one year it took a dive from 24% to 14% and then went back up to 22% again. So almost 50% of the entire industry lost and regained interest in Java within a year. Feasible? Hardly. What really happened? Simple: Google and other search engines optimise their indices all the time. Whenever Google does something big like this, because Google has a very high weight in the Tiobe results, the ratings change by a huge amount. Metrics like the amount of SO questions or the amount of Github activity in a language are much better metrics. All of these show very different results than the Tiobe index. But they don't promise a 'simple' way of visualising the popularity of language in an entire industry and as such are harder to quote. 
&gt; MOST boilerplate (https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition) then by all means If you quote a joke to support a serious argument your argument becomes a joke. Aside from that; why the heck are you here in /r/java constantly telling everyone Java sucks. How deranged do you need to be to find enjoyment in that? 
The only reason JavaScript is viable at all is because it's the only language browsers support. Granted; ES5 and 6 bolted a lot of 'nice' things onto the language but the language itself is still based on something someone [threw together in a 10 days](https://en.wikipedia.org/wiki/JavaScript#Beginnings_at_Netscape). It's a great example of a prototype they should not have put in production. For simple 'glue' code it's fine. But for complex applications, which these days also include front-ends, a yolo-typed language like JavaScript simply allows you to shoot yourself in the foot way too much. This is why languages like TypeScript popped up; the take away some of that pain. After all; you're still targetting browsers that can only understand JavaScript. In back-ends you don't have this limitation. You can use any language you want and there are tons of language simply 'better' at this stuff than JavaScript. The main reason Node.js became popular was because it attracted a lot of developers who's main strength was JavaScript development on the front-end. The entire ecosystem started as a large collection of badly reinvented wheels. Where in Java-land we have long since figured out that for dependencies it's kinda nice if they're immutable, versioned and namespaced the NodeJS world figured they didn't need all of this sillyness. And then [left-pad](https://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/) happened. The NodeJS ecosystem is a mess. NPM is still in use as the repository for front-end libraries but Node.js is losing popularity in favor of the newest fad: Go. And now Go is over it's initial hype as well when people are figuring out that 'silly things' like exceptions, generics and method overloading are kinda nice to have when you actually code for a salary.
If 1.3GB for an IDE is too much for you I sure as heck don't hope your employer is going to make you use Slack :D
&gt; Oh gosh I so hate spring. Yeah. You make that pretty darn obvious pretty much everywhere on this sub.
How does one move the computer out of the universe?
JCreator (written in C++) was/is the most performant IDE for Java.
Being very memory efficient and extremely fast, [Vim has always been there for you](https://medium.freecodecamp.org/why-i-still-use-vim-67afd76b4db6).
I am able, but as I said before, I rarely feel the need to. I will upgrade it once I get a job that's not minimum-wage. I use ArchLinux with a very lightweight tilling WM
Oh, you already use Linux, fair enough. I assumed you weren't using Linux. :P
Random question: isn't python really old ? I think it was around since ever. 30-some years ago I heard about langages and python was one. Why would it become popular now ? 
I'm not sure github would provide much better data, stack exchange maybe. People who do this sort of thing for big companies for example aren't typically about doing more of that when they get home. I'm not sure how this works these days for folks working at smaller/mid size places. Some do, sure, but if the goal is to find out what companies are using then this wouldn't really tell you. Stack exchange could be useful, but a lot of java questions have already been answered so you would really need to look at searches rather than newly created answer content for the best results probably.
That's actually the amount of RAM Adblock Plus uses in Chrome Ubuntu. If you're unfortunate like me to run on 8gb start by moving Slack/Skype to browser, switch from Adblock to Ublock and kill most of whatever else. From my perspective it's not the RAM usage that causes issues, it's the CPU usage of IntelliJ. Somehow I am sure it could get better (or perhaps I should go back to use a pre 2015 version).
As an example: i have a laptop with 4gb ram and a dualcore 1.75 ghz. If i use intellij+firefox+thunderbird i am maxed out on ram. 4gb arent that unusual in Laptops :) 
&gt; 4gb arent that unusual in Laptops :) That's for the typical *office*, low budget laptops. Development laptops have quad cores and 8GB and above RAM. A decent development laptop uses an i7 with 16 GB RAM.
no offence but aren't there enough absolute bare basic videos around on this.... 
**Sidebar** -&gt; **Do not post tutorials here!** **First warning!**
**Sidebar** -&gt; **Do not post tutorials here!** **Second warning!** Plus, read and follow the **reddit rules** [**What constitutes spam? Am I a spammer?**](https://www.reddithelp.com/en/categories/rules-reporting/account-and-community-restrictions/what-constitutes-spam-am-i-spammer) They state **verbatim**: + If you flood a Reddit community with posts or comments, you may be considered a spammer. Instead, post one or two times and see what happens. + If other users in a community historically downvote your posts or ones similar to yours, but you feel the need to continue submitting them anyway, you may be considered a spammer. Both of the above apply to you, so you are on the verge of becoming a **spammer**.
**Sidebar** -&gt; **Do not post tutorials here!** **First warning!**
Definitely. It's almost impossible to give an answer to the question "what is the most popular language". But it's much better to say "I don't know" than to just give an answer that's completely wrong. 
If you're interested in this sort of thing, you might also want to check [vavr](http://www.vavr.io)'s ["Try"](http://www.vavr.io/vavr-docs/#_try), which is modelled closely after [Scala](http://scala-lang.org)'s ["Try"](http://www.scala-lang.org/api/2.12.x/scala/util/Try.html). 
isn't JS becoming more relevant each day as more software moves to the web?
**Sidebar** -&gt; **Do not post tutorials here!** Plus: this sub is **English only**.
My currently running instance of Emacs is only using 34mb.
It will be 1st 
Just saying that he doesnt need a "new" pc, but rather a better one. My laptop with these specs is fairly new. But you know, money is tight for some of us and dev laptops are expensive. 
It's blocking, in case you were wondering: &gt;This method may block indefinitely reading from the input stream, or writing to the output stream. The behavior for the case where the input and/or output stream is asynchronously closed
Wouldn't develop on a machine with less than 8 GB anymore. For me my 16GB are mandatory as I'm also running a VM with a some containers for my dev environment.
A vm with containers. LMFAO that's exactly what containers are preventing. And you do the opposite. 
Slack sucks and is expensive. Get Hipchat if you use the atlassian tools. 
Running Docker on Windows Hyper-V wasn't that great when I did it the last time. Also there is my configured Vagrant provisioning... Idk why container would prevent what I am doing.
I hear ya. We had a java dev using emacs. He was shit. 
Yes and I built some command line wrappers for Java Platform development. Specifically a [bash script](https://github.com/caiorss/build-fat-jar) to automate many tasks such as build executable jars, fat-jars, bundle scala runtime library with application. And a [small application to download](https://github.com/caiorss/jarget) files recursively from Maven Central without setting up any project. The CLI app was built in Scala. With the application [jarget](https://github.com/caiorss/jarget) to show information about jar packages: $ jarget -show org.jfree/jfreechart/1.0.17 Package: JFreeChart Packaging: jar Coordinates[1]: group = org.jfree artifact = jfreechart version = 1.0.17 Coordinates[2]: org.jfree/jfreechart/1.0.17 Url: http://www.jfree.org/jfreechart/ Description: JFreeChart is a class library, written in Java, for generating charts. Utilising the Java2D APIs, it currently supports bar charts, pie charts, line charts, XY-plots and time series plots. Dependencies: - org.jfree/jcommon/1.0.21 - xml-apis/xml-apis/1.3.04 And also download a jar library with all dependencies: $ jarget -get org.jfree/jfreechart/1.0.17 $ ls lib/ jcommon-1.0.21.jar jfreechart-1.0.17.jar xml-apis-1.3.04.jar jcommon-1.0.21.pom jfreechart-1.0.17.pom xml-apis-1.3.04.pom The script [jar-tools.sh](https://github.com/caiorss/build-fat-jar/blob/master/jar-tools.sh) can also do some useful tasks. - Construct the runtime classpath from the artifact and it's dependencies With this command ti runs scala with all jar files in ./lib added to the classpath. It can be easily changed to this tasks. $ ./jar-tools.sh -scala-repl Show the Manifest $ ./jar-tools.sh -jar-manifest lib/jfreechart-1.0.17.jar It can also build fat-jars from scala compiled jars bundling the Scala runtime library with the jar file and all other dependencies in order to make it portable and easier to deploy. 
All of the developers in my office run at least i7 8GB with some people running 32GB DDR4 and terabyte SSD. When you think a typical developer salary is probably around 75k in my city so the difference between a 500usd laptop and a 1500usd laptop pays for itself in productivity very quickly.
yea ive been playing around with it for fun and its neat for sure