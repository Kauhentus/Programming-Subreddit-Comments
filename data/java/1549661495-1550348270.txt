Pick a proper tutorial (/r/learnjava in old reddit view - sidebar) and it will tell you what to download and how to install what you need. Also, /r/javahelp is for questions like yours, not here. **Removed**
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt; But every example I find usually takes something like Zuul and just maps a public URL to a single microservice. This is the basic case of what you would want to do with Zuul. What Zuul lets you do is map the request through service registered Eureka and pass along security headers or even convert auth tokens stored in cookies (web based security) to authentication headers (microservice security). See [here](https://developer.okta.com/blog/2017/06/15/build-microservices-architecture-spring-boot). However, while Zuul does provide filters that allow you to transform requests and responses (see [here](https://github.com/spring-cloud-samples/sample-zuul-filters/tree/master/src/main/java/org/springframework/cloud/samplezuulfilters), since Zuul is built on top of the ordinary servlets API, I think for this use case it is better to implement ordinary controllers which use Eureka + Feign to compose responses from multiple services. 
Thanks and what exactly do you mean run javac or java from command line?
I'm really looking forward to Power mock support of JUnit 5
If you downloaded java to make programs, you need to check if you can run Javac for compiling and Java for running the created programs
https://junit.org/junit5/docs/5.4.0/release-notes/index.html#new-features-and-improvements-2 Everything with the words assert and float. Essentially adding float tolerance to more functions and not forcing boxing of primitive types.
Intellij IDEA ofc :-)
We currently use RxJava where I work, but we are transitioning away from that over to Mono/Flux in Spring Boot 2.
I wondered the same question. It still baffles me as to how nobody at fosdem decided that transcripts are totally worth it. Never will I believe that developers prefer video over text.
His calm voice and manner gives me confidence.
When you say "doesn't require data storage", do you mean a database? Apache Solr stores it's indexed data in proprietary binary files, so there is no database. 
definitely, ive been doing it. (and trying to convince my team to!)
Store hashes in memory and do a bloom filter on them. If it matches then retrieve full version from the 3rd party. Hazelcast could help if data set is very big. 
Powermock is more trouble than its worth in my experience but to each their own
recursion is great when its right, as long as you don't use it just because you can and you make sure it well tested with all range of inputs before moving code forward
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Wow, now that you say it.. I love text vs video. Is there an actual correlation there?
If you ever find that you need powermock to write a test, it probably just means you've reached a point where the architecture needs to be changed a bit (e.g. splitting up a class, moving a package, inverting a dependency). The *power* is convenient in the short term but will make things unmaintainable later on. If you're stuck maintaining a fort knox'd legacy app then maybe that would be an appropriate time for powermock. It's also great if you just wanna tinker with stuff or learn more about the internals of an environment.
W3 worthy
Wrong place but if you haven't solved it DM me.
I found this article very confusing, especially the parts about Java.
Got it.
I half solved it. I'll DM right away
Why use maven: it just works.
A redirect is a HTTP mechanism, you can't "render" a redirect, but you can include meta-information: response.redirect("/login?error=Invalid login") That way you're redirecting back to the login page, but with a new query param stating that something went wrong. In login-rendering code you would then handle this query param.
Hmmm.... Yeah, you have not migrated to jdk11 yet, have you? 
Our senior developer is pushing so hard powermock in our project. Arguing that if you need to test private methods etc, you shouldn't need to change code structure. To me its not a very sound argument. Even more so, once Java's byte code starts to change (values types), I wonder how fast powermock can adapt, as it uses byte code manipulation.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Disabling unused plugins speeds up IDEA startup significantly. If you're still on HDD for some reason, you should really try SSD.
If he needs to test private methods of his own code, he should change jobs. To something not related at all to software development, preferably.
Now if Maven supported the non-public classes/methods that JUnit promises. Any day now they will fix that open issue.
&gt; Normally you're supposed to use Gradle or Maven when starting a new project. But that might come across too much work when you just want to give JavaFX a try or build something quick, even though JavaFX Gradle Plugin works fine. Strange logic. "Its best practice to do X, and X works great, but let's do Y instead because no reason."
I THINK was OP is trying to say is that current OpenJDK or Oracle builds no longer include JavaFX. It's a separate Maven dependency, which you would pull into a new project with Maven or Gradle or whatever. Azul's build here includes JavaFX built-in as part of the JRE. So it's just *there* with the standard library, like it used to be up until Java 11 or whichever version it was when they decoupled it. So you could download this JDK and do your little "Hello World" demo, without having to learn the Maven or Gradle setup. Then learn that later if you care to. But yeah, this premise is a little odd. If you're a new Java developer and you don't know how to stand up a "Hello World" project in Gradle, then you probably need to start by learning that. Once you do, there are [Gradle plugins](https://github.com/openjfx/javafx-gradle-plugin) to make JavaFX easy with any JDK. Still, I'm a big fan of Azul and always happy to see them getting some attention.
&gt; This Azul includes JavaFX built-in as part of the JRE. So it's just there with the standard library, like it used to be up until Java 11 or whichever version when they decoupled it. Isn's that a bad thing actually? It re-introduces the vendor-coupling and the "it works on my machine" problems that we had with Oracle vs OpenJDK for years and lead to the common "Only tested with OracleJDK" excuse. They might now just put "Only tested with ZuluFX" in their README.txt instead of properly defining their dependencies. Actually a smart tactic from Azul. Not nice, but smart.
No. 1. This is a special JDK build made for this express purpose (i.e. ZuluFX vs. the regular Zing or Zulu Enterprise). No one is downloading this by mistake. At least not anyone doing professional Java development or shipping anything. 2. Nobody ships JavaFX apps with the expectation of running them on the user's pre-installed system JRE. JavaFX developers use `javapackager` (or some similar third-party too), to create an application bundle with a fixed embedded JRE baked in. Honestly, this is also true for Swing-based desktop apps such as JetBrains products... and Minecraft... and really any desktop Java apps developed in the past 10-15 years. God, I hate the Internet. Azul is one of the good guys, there's is nothing "sinister" here just because you're completely unfamiliar with JavaFX.
Current moving away from RxJava to just Kotlin, Livedata and coroutines on my contract gig.
I can guarantee you that learning maven is easier and more worth it than any spam you can come up with.
Why is this not marked as advertisement? 
I prefer IDEA
Maybe we paid r/java mods too?
&gt; If they are uploaded to YouTube Speaking of which: In the last 24 hours, [FOSDEM uploaded 100 videos to YouTube](https://www.youtube.com/user/fosdemtalks/videos).
Good luck endorsing Maven to students trying to do their one-off JavaFX homeworks, or those wanting to learn programming by building desktop applications. They'll either give up, or try to install unsupported Oracle JDK 8 builds from unknown sources. I know this because I've been answering newbie questions about JavaFX for years. Azul is one of the good guys, as u/BadMoonRosin noted. Zulu is licensed under GPLv2 with classpath exception, just like OpenJDK. I have used Zulu before to deploy my LibGDX applications. Other developers did that too, including some LibGDX contributors. Because it's a good choice.
*a special JDK build made for this express purpose* does sound like bad guy behavior. Why is this better than OpenJDK + JavaFX via Maven/gradle/etc ? How do you know what version of JavaFX you're using? Do developers have to coordinate and use the same JDK?
Apparently you forgot to pay the crowd as your post has a mere 53% upvote ratio. While I have your attention - why would anyone not use Gradle?
&gt; Strange logic. "Its best practice to do X, and X works great, but let's do Y instead because no reason." The title is "ZuluFX **might be** the solution you've been looking for", not "let's use it because no reason". Believe it or not, many people with various background want to give JavaFX a try, but get frustrated by Oracle's dropped JavaFX support or relatively complicated Maven/Gradle configuration. There are youngsters with small school projects, there are grandmas trying to run some JavaFX application, there are people who want to get into programming and their passion is building desktop applications. Send them your pom.xml and watch their reactions. They will end up installing unsupported Oracle JDK 8 that contains an older version of JavaFX, or just give up. &gt; Also, this sounds a lot like advertisement instead of a genuine tip from an unbiased developer. No matter if ZuluFX is really great or not, I find these posts annoying. Behind most of the projects in Java world, there are one or more commercial companies. Zulu is a free and open-source software by a company. So is Gradle. Heck, even JavaFX is mainly developed by a commercial company called Gluon now.
It looks like in your [submission](https://www.reddit.com/r/java/comments/aoulyb/im_trying_to_add_objects_to_an_arraylist_but_keep/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You hustler! We'll send you a nice paycheck.
If you had actually read the parent comment, instead of stopping after the first sentence to fire off an uninformed reply, then this would have been clear. You "know which version of JavaFX you're using" because Java desktop apps tend to ship with an embedded runtime. Yes, I would have thought that to be crazy 10-15 years ago. But now disk space is cheap, bandwidth is plentiful, and the alternative is using Electron and shipping an entire Chrome instance anyway. So you don't care which JRE's your end-users have installed (if any), because you aren't using it. As for other *developers* that you're working with on your dev team, then certainly. No real-world professional team has devs working off randomly different JDK versions. 
Oh, everyone should use Gradle, especially with the aforementioned JavaFX plugin to develop their projects. But this ZuluFX thing can be practical for many cases. It took me an hour to introduce Gradle to a Java beginner once. It would probably take even longer if he tried to learn it all by himself. You might argue that Java beginners shouldn't be developing desktop applications. However, like gamedev, making desktop apps gives learners instant gratification and keeps them motivated. I still remember the excitement I had when I got my hands on Delphi for the first time in the 90s.
A noob question i have got here. So I am currently just doing competitive coding in java but now want to build an app on desktop maybe a calculator or a tictactoe game. So for the graphics part is JavaFX enough or do i need to learn something else. As i am going to start learning JavaFX.
JavaFX is all you need. it's actually my favorite game engine.
Thanks for the reply. Now Looking forward to learn it and make some cool mini projects as a starter.
I saw, but didn’t find this one.
Good read. This is a very trippy incarnation of the Baader-Meinhof Phenomenon for me right now. 
Wtf is that? :D
Feel free to google it
JavaFX isn't a game engine...
You don't have to be so aggressive. My question was only about how developers know which version of JavaFX they're using. With this setup you'd have to download a new JDK in order to get new JavaFX features, which seems insane. You'd also have to make sure all contributors are using that JDK. I've been doing Java professionally for years, and I've never concerned myself with what specific JDK anyone on my team have been using. We've only ever cared about if it was Java 6/7/8/11. The vote manipulation in this thread (even after it has been removed as spam), makes me think I'm wasting my time here though.
Hoe can it possibly take a hour? `gradle wrapper` and then add your dependencies in build.gradle, and the IDE automatically imports everything. That's it I think...
Where do I extract these to/how to install on windows 10?
I tried using regsvr32 "C:\Program Files\Java\jdk-11.0.2+9-jre\bin\java.dll" in cmd but that didn't work
Yup. If you have a standard Java project you only have to define your dependencies and the main class for your jar. I mean an hour to explain Gradle is reasonable. I could give a lecture on Reddit that fills a semester which will obviously include a Groovy or Kotlin deep dive. But if the goal was to explain to someone how to use Gradle in terms of building and starting your application and adding new dependencies? Well, okay, an hours still sounds reasonable if you do it really hands on. 
https://science.howstuffworks.com/life/inside-the-mind/human-brain/baader-meinhof-phenomenon.htm
Yes, but this video is not one of them. I am assuming it will be posted soon, though.
Holy hell, there is a term for that?!
Yet it has everything a game engine should have, plus more. That's the beauty about JavaFX.
You're welcome. Have a look at Kishori Sharan's *Learn JavaFX 8* book. It's full of examples.
I was just doing some stuff at work involving optimization for cache performance, and it really wowed some of my teammates, but throw concurrency into the mix and it's all black magic to me. Seeing it explained is really cool.
Thanks mate
Are you interested in optimizing code for trading? Me too...
TL/Dr they only use L1 cache. Therefore it's the fastest thing out there.
Fun fact: this is the technology used by log4j2 in its asynchronous loggers.
Spring OAuth is a good place to start. 
OAuth 2.0? 
Yes. 
Then their machine is 'not well'. It is nowhere near that slow to start (unless you have dozens of plugins)
Does anybody actually use spring? 
No of course not, nobody uses the most popular Java web framework. What kind of question is that? Of course people use it.
Udemy has an excellent course by Agile Intelligence on Spring/React with JWTs later on in the security section of the course. 
Why, and why is it better than implementing JWT for the OP?
You can try wiremock, here is the example mock server https://github.com/gungorugur/mock-server
Most popular framework by a landslide, in case you're asking for real.
we are using Redhats Keycloak with spring adapter. It supports Jwt also. 
That would be incredibly misleading to summarize it like that. Especially with the problems described due to L1 bad usages. 
High level possible JWT flow: Front end passes credentials to a public endpoint. JWT access and refresh tokens are created and returned along with expiration data. Front end stores the tokens and expiration of the access token. Possibly in local or session storage. On all future api calls, check the expiration. If still good, place the access token in the Authorization header for Spring to extract. If the token is expired, send the refresh token to a refresh endpoint. Validate the refresh token on the back end then create and return new access and refresh tokens to the front end and repeat the process. 
It doesn't have anything a game engine should have, you can use it to render, that's all. From Wikipedia: &gt;The core functionality typically provided by a game engine includes a [rendering](https://en.wikipedia.org/wiki/Rendering_(computer_graphics\)) engine ("renderer") for [2D](https://en.wikipedia.org/wiki/2D_computer_graphics) or [3D](https://en.wikipedia.org/wiki/3D_computer_graphics) [graphics](https://en.wikipedia.org/wiki/Computer_graphics), a [physics engine](https://en.wikipedia.org/wiki/Physics_engine)or [collision detection](https://en.wikipedia.org/wiki/Collision_detection) (and collision response), [sound](https://en.wikipedia.org/wiki/Sound), [scripting](https://en.wikipedia.org/wiki/Scripting_language), [animation](https://en.wikipedia.org/wiki/Computer_animation), [artificial intelligence](https://en.wikipedia.org/wiki/Game_AI),[networking](https://en.wikipedia.org/wiki/Computer_networking), streaming, [memory management](https://en.wikipedia.org/wiki/Memory_management),[threading](https://en.wikipedia.org/wiki/Thread_(computing\)), [localization](https://en.wikipedia.org/wiki/Internationalization_and_localization) support, [scene graph](https://en.wikipedia.org/wiki/Scene_graph), and may include video support for [cinematics](https://en.wikipedia.org/wiki/Cinematics_(disambiguation\)). 
Cheers! I've gone through [CodeNMore's](https://www.youtube.com/playlist?list=PLah6faXAgguMnTBs3JnEJY0shAc18XYQZ) vids a year or so ago and was pleased with the format. (re: a simple 2D nintendo type game) 
Do you have ant links on tutorials regarding this!?
Nope, we experienced that on different machines: a recent mac book pro and 5 different max. 2 yo Lenovo Notebooks (2x Windows 10, Archlinux, 2x Ubuntu, all ssds, 16-20gb RAM. Disabling Plugins did not make much difference. Tldr.: IntelliJ is not a good choice to develop on notebooks with 2 physical (4threads) CPU cores. It is a shame, because it has plenty nice features, but mediocre performance.
Thanks for the information
Thanks for the link!
You dropped this.. /s . 
I don't care what Wikipedia says. If those stuff are absolute necessary to be a game engine, you need to omit most of the dedicated game engines that ever existed.
I care
use an arraylist
If something can only render, it's not a game engine it's just a renderer.
 // create a new list List&lt;String&gt; list = new ArrayList&lt;&gt;(); // add all your list items list.add("apple"); list.add("banana"); ... // convert to array String arr[] = list.toArray(new String[0]); &amp;#x200B;
You could use [String#split(String)](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#split(java.lang.String\))
You already got some answers so I contribute a better place for questions like that: r/javahelp
&gt; So I have a list of words Where? In a file, one word per line? In a string, separated by commas? In a `java.util.List`?
Its not better, its just the framework. For authentication you would want to use OpenID Connect, not just Oauth2
https://www.baeldung.com/spring-security-openid-connect
Why, what's with the OpenID Connect? What's wrong with JWT? You're not helping by just throwing out buzz words. For the OP, how about an angular frontend using JWT for authentication ((tutorial)[https://www.devglan.com/angular/angular-7-crud-example]). For another example of integration have a look at (jhipster)[https://www.jhipster.tech/). 
Err... OpenID Connect is not a buzz word mate. Its an authentication protocol standard that uses JWT and is pretty much accepted globally for securing REST API's. 
incredibly misleading is a bit strong. Its one of the tenements of the architecture.
&gt; like it used to be up until Java 11 or whichever version when they decoupled it. JavaFX was *never* a part of OpenJDK, but it was distributed with Oracle JDK. Because we (at Oracle) want Oracle JDK and OpenJDK to be essentially the same, JavaFX is no longer distributed with Oracle JDK, either.
JavaFX handles 3D, 2D raster graphics, vector graphics, charts, animation, audio, video, streaming, localization, windowing, application lifecycle, event and input processing, state management, concurrency, and more. Do you really think calling it *"just a renderer"* accurate?
Nice. Reminds me of my undergrad signal processing lab assignment to read an audio track from disk and send it to a speaker output (in C). IIRC we tried at first using something naive like an unbounded deque, and the audio played back five times slower than intended. After switching to a ring buffer structure, everything magically became real-time. Was a real eye opener. 
... and Oauth2 is for authorization? Got an example on how to set that up for the op?
Except some languages actually have pattern matching which helps with that scenario.
OP ask for authentication. OAuth is an authorization framework. Two different things.
OAuth is for authorization not authentication. They are closely related of course since you can’t be authorized unless you have authenticated; however, OAuth doesn’t care how you were authenticated just that you were. So Oauth is not the answer to your authentication question. The true purpose of Oauth to authorize a 3rd party to access protected resources on one of your user’s behalf. Some people do use oauth to authorize their own apps to access their own backend services but it just isn’t needed and makes things confusing. Just google Spring and JWT and ignore oauth (unless you are going to have 3rd parties access your API on behalf of your users)
Also Logback through logstash-logback-encoder: https://github.com/logstash/logstash-logback-encoder/blob/logstash-logback-encoder-5.3/README.md#async-appenders
Monkeypatching, AOP type stuff, instrumentation.
He's looking for a way to authorize a web app. 
*Woah!* it's your **4th Cakeday** NimChimspky! ^(hug)
In case you aren’t being sarcastic, I’m a software engineer at Home Depot and I can confidently tell you that many teams are using spring at Home Depot alone.
Is "Clean Architecture" in that case a synonym of "Hexagonal Architecture"?
[https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html) It matches the style Robert Martin promoted in one of his early Blogposts. Which is very similar to the hexagonal architecture
And the funny thing is it's neither clean, nor hexagonal. It's just... 3-tier + modular.
... Which is just basically an n-tier architecture rotated on the diagram
Yep, I've seen it mentioned about 3 times this week :P
It may look OK on the surface, with such simple example. But soon you will see such architecture will not work. 
Sounds like you need to elaborate. Why do you think it does work? 
Yeah I put a link elsewhere in the thread. 
There is many things in the article that I personally don't agree with. As the first risk, I see exposure of the data. I agree the core should be business objects. But they should not be POJOs, data structures or objects with methods. Instead, I would see objects as creatures which have very clear and single responsibility (assigned by contract). That's the responsibility business assigns to it. All data must be encapsulated. The only way to interact with business object is to call their (ideally) single public method, being their single responsibility. Understanding the business domain is the way to uniquely identify the business objects. They cannot be just any POJOs. At work we do it with CRC (https://en.wikipedia.org/wiki/Class-responsibility-collaboration_card)
**Class-responsibility-collaboration card** Class-responsibility-collaboration (CRC) cards are a brainstorming tool used in the design of object-oriented software. They were originally proposed by Ward Cunningham and Kent Beck as a teaching tool, but are also popular among expert designers and recommended by extreme programming supporters. Martin Fowler has described CRC cards as a viable alternative to UML sequence diagram to design the dynamics of object interaction and collaboration.CRC cards are usually created from index cards. Members of a brainstorming session will write up one CRC card for each relevant class/object of their design. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Must be. Much of what I read at OP's link aligns with the way we've implemented hexagonal architecture in our most recent projects. It can definitely feel like overkill at the beginning, and may be too much for small projects, but we've already seen the benefits (the mythical swapping out of the database... We actually had to do it, and it was painless).
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
The packages in the domain part should have a breakdown according domain, not types. So, there should by just one package "domain.user" with all the stuff. The breakdown to "entity", "exception" and "port" is not appropriate. Domain classes should be grouped by domain meaning, not by a technical type.
That’s an interesting way to look at things. Thank you for explaining. Could you provide an example project written in this method?
This was one that I found pretty helpful: https://www.callicoder.com/spring-boot-spring-security-jwt-mysql-react-app-part-2/
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
No, no... this is bullseye architecture. 🎯 
Used it in the past. It was great, back then, for building SOA based monoliths. As scale became an issue, it was easy to split up the SOA into micro services architecture. I would not touch it, it's not worth it. Resolving 3rd parties is a pain, especially with JPA.
A lot of the features added to Java have specifically been to make it less verbose, so you're arguing against changes that the Java language designers and developer community want and are happy to use. Java 7 added try-with-resources, so that you didn't have to explicitly write the code to close something opened at the beginning of a try/catch block in a finally block. Java 8 added lambdas. Everything you do with a lambda can be done in a more verbose way without them. They were added to cut down on verbosity, nothing else - and lots of Java developers are thrilled to get them. Java 9 added new static factory methods to List, Map, and Set to make it easier to declare a simple List, Map, or Set with fewer lines of code. Java 10 added the new 'var' keyboard, so you don't have to put a type declaration twice in the same line. Java 12 adds a new extended switch statement. Those are all changes you don't need to solve problems, they just reduce verbosity. To me the *real question* is how do you tell when you've gone too far trying to make code less verbose and made something hard to understand. *Well written* Perl 5 is not hard to read at all. Seriously - I'm a big fan of the language. But you can use some language features to write code that's all but impossible to follow. Basic Scala isn't hard to read, but sometimes I've seen code that makes excessive use of operator overloading - and not just overloading of + and - but operators like &lt;&lt;+!= or something crazy like that, all over the code, and it manages to be worse than bad Perl.
Thanks for posting this. I was looking for something like this.
Goetz is byke fam
I meant to say spring boot.
I assume "all data must be encapsulated" means no getters. Using the example app from OP's linked article, what would the CRC's be for a REST API that gets a user from the database? Assume Spring Boot and what SQL flavor you like as the database.
https://github.com/jpoh97/CleanArchitectureJava
Looks very cool. I might give it a spin tomorrow.
Did I miss anything? Kotlin is still under Jetbrains. Google is just pushing it for Android, they don't have control over it.
Perhaps, but on my machine (Win10) they didn't create the registry keys that software has historically looked for, specifically `HKLM\SOFTWARE\JavaSoft\Java Runtime Environment` (in favor of `HKLM\SOFTWARE\JavaSoft\JDK`)
It just looks like a standard Dao-Service-Controller architecture to me, just with a different naming scheme. It would be even cleaner with IoC. That manual class used to glue the instances is not what I call "Clean Architecture". I don't really like how the packages are organised; "port" feels like an all-purpose bin. It is more important to isolate each functionality, and make them communicate through a message system.
After years of fighting null in Java statically typed nullability was a game changer for me. The issue has never been null itself and has always been dynamically nullability.
I have a question regarding the use-case representation. If the microservices are in place, how the use-case will be implemented? Let's assume, we have modules "Customer" and "Contract". The use-case "Create a new contract" with first step "Find customer". In which module will be placed the UC implementation? I think, the microservices are about providing services, not use-cases. So in such a case, the use-case representation should be replaced by service representation. And the use-cases are in a fact represented on presentation layer, not business layer. Or?
wow, collectors are very hideous to implement 
Misleading title: &gt; Null is your friend, not a mistake After reading the post it should be named: *Null is your friend in Kotlin, ...*
Unfortunately, the big projects are not in public domain, and the small ones (github repos) don't have interesting architectures. You may have a look at takes, though (https://github.com/yegor256/takes). Once you understand the style of writing and naming conventions, you will notice how easy it is to change it, delete it, and make it grow.
Yes people do. And you can also edit posts ;)
Not necessarily, but it becomes significantly harder if you take a step off the main path.
That is correct - getters contradict encapsulation. Before I answer your question, I'd like to point out to the second thing I didn't like in the article - the example. When business wants a project, they describe their domain. It is always a specific domain, so should be the architecture. Uncle Bob presented it very clearly here (https://www.youtube.com/watch?v=Nltqi7ODZTM I like the part starting at 7:20). As a business person I may want to build a product that helps to, say, make a medical diagnosis, or make an appointment with someone, or do laundry. They will be different architectures with different CRC designs. Of course, at some point you may want to find a user or log him/her in but it is never a problem be to solved in the first place. Furthermore, I can tell you that in the three listed business applications I came up with I would not create a user. Instead there would be someone like Patient, Attendee, and Tenant, for example. That would help me realize who they are and not if they have a name or surname. Now, answering your question, when an object needs to store some information to the database, I create that object with some kind of DataSource or pass DataSource to the object when calling it. And that very object should know what to do with that DataSource access.
Okay but what the hell is "teeing"
T
The name derives from a T-shaped-piece, like a pipe that has one input but two outputs. See also the unix/linux command `tee`.
Completely agree with /u/Zdeno_: this 'sockdrawer' approach of bunching together types based on their technical goal is a sure-fire way of creating one big monolith that can never be broken apart again. If you want to create a modular monolith you should create modules based on their domain. You can get away with the sockdrawer approach in microservices but it's nothing more than 'getting away with'. Aside from that; the naming is in no way intuitive. A UUID generator in 'ports' together with a UserRepository and PasswordEncoder? And: classes that just 'proxy' methods from underlying classes 1:1 (like FindUser) are just overhead and IMHO an antipattern. So is creating interfaces for everything while they'll only ever have one implementation. That's just creating code for the sake of linecount.
Ah, i see, thanks. Although it looks like a pipe with 2 inputs and 1 output in this case?
&gt; Although it looks like a pipe with 2 inputs and 1 output in this case? As I understand it, it's mostly splitting the stream to two streams/collectors. Of course after that, it the result gets merged again. So it's probably both.
Thanks, no I didnt edit it so the wankers here can downvote it. 
&gt; After reading the post it should be named: Null is your friend in Kotlin, ... And I disagree with that. What I like about Kotlin is that it allows me to declare variables that are statically typed to be non-nullable. What I don't like is that Kotlin on the other hand makes nulls more attractive again by introducing operators such as `.?` and `:?`. I can see where they're coming from and why they're there. But it's far too easy and attractive in Kotlin to use nulls instead of proper error/exception handling or using other methods of handling special states. Especially as it has no checked exceptions. Kotlin one one hand allows you to avoid nulls, which is great but then it makes using nulls attractive again. It just doesn't make sense.
Honestly, I hate all things Streams. I find the syntax overly complex.
&gt; Kotlin one one hand allows you to avoid nulls, which is great but then it makes using nulls attractive again. It just doesn't make sense. I think, it is allowed to add syntactical sugar to things that are good, e. g. necessary null-checks. And if you have a nullable type, you are forced by the compiler to do null-checks, so it makes sense for me.
Looks similar to jOOλ's [`Tuple.collector()`](http://www.jooq.org/products/jOO%CE%BB/javadoc/latest/org/jooq/lambda/tuple/Tuple.html#collectors-java.util.stream.Collector-java.util.stream.Collector-): Tuple2&lt;Double, Long&gt; tuple = Stream .of(1, 2, 3, 4, 5, 6) // dice roll .collect(Tuple.collector( summingDouble(i -&gt; i), counting())); System.out.println((double) tuple.v1 / (long) tuple.v2); // 3.5
This would be not fair. Kotlin is not the first and is not the only JVM language that properly incorporates null into the type-system, let alone plethora of non-JVM languages that do the same. However, indeed, Kotlin is one such language. 
&gt; And I disagree with that. You disagree with my proposal for a proper **name** of topic? The blog shows the problems with ``null`` in Java and finally advocates the use in Kotlin because of the integration of null into the type system. So imho the title should refelct that by *naming* the target language of this claim!
Of course there are other languages - but you definitly refer to Kotlin in your post and *not* Java. That's the important aspect imho, as we are in a Java sub here. So it would be fair to name the target language to which his thesis applies in the title. 
No, I disagree with kotlin being null friendly being a good idea. Your title suggestion is fine. 
Ah ok... the quoting has benn misleading to me ;-)
I dare you to look at rxjava then :P you won't come out alive
I'm not sure if it's applicable here, but if someone wants to use streams for primitives there are unboxed versions for each: IntStream, LongStream etc. They can be seamlessly converted to/from boxed object streams.
Tagir was faster :) https://bugs.openjdk.java.net/browse/JDK-8209685
Unpopular opinion: Java devs need a scapegoat when they f up badly and nullability fit perfectly for this. 
Thanks for the pointer. I'll comment on there. I mean, why stop at 2? If 40 years of using SQL have taught us anything, then it's that reports like to do tons of aggregations, not just 1 or 2.
Oh, in fact, it was already closed and implemented: http://marxsoftware.blogspot.com/2018/08/jdk-12-merging-collectors-naming-challenge.html. Bummer.
Missing out
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Adding `@Nullable`/`@NotNull` annotations to my code bases has been a game changer, as has `Optional` as a return value. It allows static checking of code in either the IDE or findbugs etc rather than at compile time, but that's most of the issue solved. I don't know if this is just repeating what you meant or if you meant moving to Kotlin.
Even if it happens in Java one day (as it did in C#) there is no need to wait for it. You can use Kotlin now and loose nothing. That is to say, a really substantiated need to be staying with Java is rare. If you are working on an end-user app or a service in Java chances are you’ll get net win if you switch to Kotlin. 
Very cool. Does anyone know if compiling will now enforce Java9+ modularisation and reflective access? They were going to enforce it on 11, but eventually realised no one would be ready for the next LTS, so turned it back to lenient (with warnings).
The post is about Java type system shortcomings. I could have shown solution in some other language beyond Kotlin (and it really just an example). Of course, working on Kotlin it would be fair for me to give an example in Kotlin. It would be unfair to say the post is about Kotlin, though. Btw, full disclosure here. I consider Java to be the greatest language of XXI century: https://link.medium.com/MfYh9vARdU
I agree that the domain problem and language should inform the architecture and names of things[1]. "User" is probably a bad name unless we're writing an operating system. I took a look at the Takes project you linked to in another reply (shout-out to https://github.com/ovity/octotree BTW). I've written code like this as an experiment (no null, no mutators, no accessors) and it was interesting. On the other hand I've been using Kotlin a fair bit, and find the combination of immutable data classes and functions to be quite easy to work with. I'll have to put this on my personal backlog to play with some more. Seeing a decent-sized codebase written using these principles tells me it's feasible, but I'd like to get a better sense of the tradeoffs. I suspect the real problem with the so-called "anemic domain model" is mutability. Because most typical codebases model mutable state and then have code all over the place mutating that state, often duplicated, making it nearly impossible to understand and correctly modify the code. [1] And of course naming things, cache invalidation, and off-by-one errors are the two hard things in computer science. 
&gt; The post is about Java type system shortcomings. Then the title is still poorly chosen - *"Null is your friend, not a mistake"* does in no way imply some kind of *shortcoming*. And the *solution* is presented in another language (Kotlin) - so where is the relation between the title and the Java type system? The title suggest that ``null`` is a super cool thin **in Java**!
The normal name for this kind of operation in FP circles is "zip" - because it acts like a zipper and joins 2 streams 1:1.
You are right. The title could have been made better. I’m sorry if it did mislead you. 
But that's the point. I don't need to. I can get most of the benefit without switching from Java.
Zip is literally the opposite of Tee.
This is more like a reverse-zip, though. It has 1 input and 2 outputs. 
I've been using the EA java 12 for my stuff and haven't noticed any new failures as a result. Some of the libraries I'm using (groovy) had illegal reflective accesses. Maybe 13 kills them?
What does this have to do with Java 11? I didn't seen anything here that couldn't be done in Java 8.
&lt;slaps forehead&gt; Ah crap, I knew something was off. I wouldn't know, I'm just using reactive streams and there it's `share`...
You can still keep compiling and running your code with the classpath (as opposed to the module path and working with automatic or named JPMS modules). In that case your code will be in the "unnamed module" and can keep using reflection as it did before.
I seriously doubt they will enforce any of this until at the very least next LTS, if not the following LTS. There are a TON of places still on JDK 7, and more on 8. Very few have moved to 9/10/11 yet. The release cadence is a major adjustment for java shops. For 20+ years we got 8 versions, now we have 4 versions in &lt; 2 years. Java, like C has been one of those things we rely on every few years or so, after several updates, etc. So unlike languages like NodeJS/TypeScript, Go, etc.. most Java shops are not ready to invest the time and cost to keep their engineers up to date and update the time it will take to adjust to the java release cadence yet. I suspect from reading/talking to others it will be a few years before most java shops are prepared to update to each LTS. Most wont be using the updates between LTS, other than to maybe experiment with builds.
Things are changing. Just a few years ago we strongly rely on Netflix Infrastructural Services but time is changing everything. After all we realized that we can do better, and Netflix is not an exclusion. That is why Spring engineered their own infrastructural solutions, like Spring Cloud Gateway and new Spring WebFlux which incredibly improve applications performance. The next step in infrastructure evolution is changing the way we do network communication. That is why new RSocket support in Spring Cloud Gateway is on its way and that is why we build Consul or Message Broker of new generation, called Proteus
And when will Eclipse support Java 11?
It doesn't
2018-12 already does.
It was finally uploaded to YouTube, [here](https://youtu.be/W-l0Huhb40s).
The video was finally uploaded to YouTube, [here](https://youtu.be/XaWzAMkU-Hs). It does offer an auto-generated transcript.
It takes time to modularize your stuff properly. Any large project will probably stay stuck the the latest jdk that does not enforce modules. I worked on some projects were different jars have the same package names. That is not allowed and requires a large refactoring. In the simpler cases package level access to other internal classes in other jars is used. Then there are the scenarios where classes are replaced in the classpath on purpose - think of a product family that is customized for each client: Jar "defaultimpl.jar" has the default functions for everyone. Now "clientA.jar" has some of same classes in the same packages with client specific stuff. It's going to take a while to migrate that into modules. Then, once you get your modules somewhat ready, unit tests and builds start to fail. It takes time to sort everything out. Having said all that, I like the idea of modules. It's that migrating an old codebase takes time and justifying it to whoever pays you may not be that easy.
&gt; I would love a non-nullable type by default but that's unlikely to happen in Java now. You can write @javax.annotations.ParametersAreNonnullByDefault package yourpackagenamehere; in `package-info.java` to make non-null the default for a package! I found it out from [here](https://medium.com/square-corner-blog/non-null-is-the-default-58ffc0bb9111)
Yeah it cuts down on the annotations, but is still only "enforced" by your IDE or static analysis tool. Integrated into the type system would be much better
If you would be willing to work on a project of a relatively small scale, you look for something on r/programmingbuddies. 
If you're not completely new to programming most open source projects would welcome you. You might get simple tasks (writing docs, fixing simple bugs), but you can contribute more as you get better. What's your skill level, and what are you interested in?
Open source projects.....
13 EAB seems normal as ever but who knows
And here I am, running some boxes with 6 :)
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Just a reminder that @Nullable and @NotNull are not a standard part of the language and are known to not be universally portable. 
That's why they are an external dependency and all major IDEs support defining which annotations you want to use.
This x infinity. I love Kotlin but casually allowing null is the single biggest design mistake they've made. They should have just enforced non-null, period. For potentially absent values they should have introduced a sane Option/Maybe type, but they've left that out too, so now Kotlin codebases are a hodgepodge of questions marks and Java Optionals (yuck), and developers who aren't used to non-null happily leak them deep into the code rather than only permitting them at system boundaries.
In any language, not following the coding convention. If they missed that simple detail, they probably missed others. 
The simplest first. Any method that takes up more than 1-2 screens. God classes. 
It looks like in your [submission](https://www.reddit.com/r/java/comments/apnz4u/java_question_help_please/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Things that a modern IDE or tool will do for you like not including unused imports and code formatting. A lack of automated tests is another flag. Due to the nature of my work (interface engines, pluggable UI modules in Swing, pluggables to legacy apps) automated testing is not always practical so a clear written test plan is an acceptable substitute in those cases. The dev needs to show that we're not wasting code review time showing that it works. Pokemon exceptions are a yellow flag, not awful but c'mon... The lack of a logger being initialized at the beginning of every class is a red flag. Not using it is arguably a ding on the performance review because I wonder how much time was wasted debugging a problem or a bug report because the logger didnt exist to get good triage data. Lack of being a "good scout". If you're in there anyway, clean up a bit.
Magic fucking strings. I don’t know how many hours I have wasted recently trying to figure out the importance of certain strings. 
Single responsibility principle and unnecessary logic/code 
Too many dependencies for injection. Sensible contracts. Generics just for no reason. If they didn't get the memo about streams API you have my attention even more... Reinventing shit... 
Copy-pasta
At what monitor resolution?
Using .toString() when you don't actually need it explicitly. 
This is the kind of thing that has led me to believe that code reviews are largely worthless. You would call this out in a code review? Does having an extraneous toString() make it incorrect or unmaintainable?
printStackTrace()
Things that can and should have been caught with a linter (null checks, imports, catch-all exception handling). Not commenting "weird" bits. "self documenting code" is a fine goal to aim for. But it will always fail. Comment. Especially the lines that sent obvious. God objects, but also leaking God objects. (though this can be more subtle and I wouldn't ding someone for it) Not using interfaces where only a subset of functionality is being used on a class being passed in (obviously a bit more nuanced but still a good thing to look for). None of these things on their own are a red flag on the developer though. If simple errors keep being made, then I'll start to question the dev. But people make mistakes. Catch the common ones in the linter and the tests, but don't fault someone for making mistakes. 
What are Pokemon exceptions?
Powermock. Lack of logs / metrics. Logs without parameters. More than 1 or 2 public methods in a class. Giant methods with more than 2 levels of brackets. Lambdas longer than a few lines long. Hand written pojos (Lombok is good, use it) Guice abstract modules (use private!!)
Gotta catch em all
Thousand of warnings, one logger instance for everything, god-classes, no tests, passwords in clear, extending the code instead of refactoring, packages sorted by technical role instead of domain, copying DTOs to identical DTOs, weak type-safety, bad understanding of autoboxing (new Integer), mixed responsibility classes, no security/sql injections/security done client-side, short-circuit of the framework's normal behavior, hard-coupling everywhere/spaghetti code, returning null everywhere, only one Exception type for everything, ridiculously complex code to do simple things, huge switch cases instead of OOP, mutable types in multithreaded algorithms, no input data validation, no data output uniformisation, no project management tools, no continuous integration...
being explicit is often a good idea, as long as the code is readable. I wouldn't call this a red-flag.
//TODO write test
&gt; More than 1 or 2 public methods in a class This sounds like personal opinion, not something that makes code incorrect or unmaintainable.
Power mock is #1 for sure 
Reflection 
It is absolutely a code smell. Usually means there's a violation of [Single responsibility principle](https://en.wikipedia.org/wiki/Single_responsibility_principle). 
I feel like if during a team meeting, you're trying to set some coding standards, and someone says that we should avoid methods that take up more than one or two screens, and someone else says "at what monitor resolution?" then that team is already pretty much fucked.
- Constructors and methods with more than 4 arguments. - Methods longer than 30 lines - Classes longer than 300-500 lines - Lack of tests - Abusing Stream API - Magic numbers and strings 
&gt; Lack of being a "good scout". If you're in there anyway, clean up a bit. What about "only one logical commit per change"? I'd want the clean up commit to be in a separate CR from the "implemented feature" or "fixed bug" commit.
Of all the crazy garbage people can do in Java, this seems like a weird thing to care about.
For worst practices search and static code analysis you can use something like findbubs([http://findbugs.sourceforge.net/](http://findbugs.sourceforge.net/)). Add it to the project and run analysis, it will show some problems which is mostly touching bad implementation practices and basic language misuse, such as using thread unsafe static variables for example. You can google for the following DRY, LSP, SRP, DIP, OCP. It's very basic principles which is applied to (almost) any language(definitely works for Java), touching overall code structure and architecture. Any type of wheel reinventing, if not necessary. Frameworks re-implementation, just because we can, working with low level API's without real reason - especially within the areas which operate streams and connections, which need to be carefully handled, closed and deallocated. I.e. it's OK to maintain JVM modifications if you need effective memory operations for enterprise multi-threaded application with really high load, where you need to manipulate heap and move it to slow storage while threads is waiting, but absolutely not OK to write your own web server for small company web portal with hundred users at most. Rest depends on technology stack, frameworks, decisions made by architect. For example sometimes DRY can be willingly ignored for critical modules to make its code isolated and fully independent. 
Lately for some reason I've been on a streak about primitive obsession; the same primitive values keep getting passed around to a dozen classes and forty methods. (But the formal parameter names are subtly different, and often in a different order.) For the love of OO principles, when you've got a bunch of things like `firstName, lastName, dob, nationality, ethnicity` put 'em in a class and give it a name. Types are our friends. Really. Other things I look for: * In addition to actually having abstractions, give them good names that tell me what they are/do without having to dig through the code. * Methods should not have code with wildly varying levels of abstraction. * Make sure the code is DRY. Repetition causes defects and prematurely gray hair. * Avoid incidental complexity, extra code that doesn't need to be there, and logic that has no effect * Good exception handling practices. * Logging (as applicable to the application). * Coupling to other packages should be appropriate based on the responsibility of the class and other classes in its package. * Appropriate use of collections. Nowadays this is usually about expressing intent, not efficiency. (Not always.) * Null safety. Avoid returning null. Check for null when you need to. * Good tests. Unit tests for business logic; integration tests for the whole application (or at least a specific layer). * And while we're talking about layers, keep the business logic decoupled from framework/library code. * And that segues into making proper use of the framework/library and the language. * Encapsulation and scope: use private as often as possible, inner classes are useful, and watch the surface area of your API. * Inheritance is mostly abused. Use it to express "is-a" relationships (polymorphism), not code reuse. * Casting -- don't do it (unless the library/framework you're using forces you). * Proper validation of incoming data. (Assume the nastiest black hat and the laziest idiot are both using your app.) * Strict and consistent representation of outgoing data. Is it UTF-8 or ISO-8859? Tabs or spaces? Escaped HTML or not? * Security: exposing stack traces and other technical details to the client; logging sensitive data. * Setters are evil. Getters are usually evil. * Reinventing the wheel. (The world doesn't need another `StringUtils` class. Seriously.) * I/O. There are a ton of things that can cause your app to misbehave when you start talking to filesystems, databases, and sockets. Configure correctly, check for errors, and handle exceptions gracefully. * Don't use `java.util.Date` or `java.util.Calendar`. And mind your timezones when playing with dates. 
Comments where they arent useful or required. Very large methods or classes. Code where a whole bunch of if/else statements are embedded into another bunch of if/else statements 3-4 levels deep. Commented out or @Disabled tests. &amp;#x200B; Check out "Clean Code" if you've never read it. It goes into some pretty good indications that code isn't optimal. It also has an entire section at the end about code smells: [Chapter 17: Smells and Heuristics](https://www.safaribooksonline.com/library/view/clean-code/9780136083238/chapter17.html#ch17) 
I get the feeling that you're in the 8th level of developer hell.
I would and often do call it out, yes. Anyone who understands Java knows when you need it and when you don't. All it takes is one bad Indian to put a .toString() call on a fucking String object and that shit will be all over the code like a copy-paste kudzu. 
It's an obvious code smell that outlines people are blindly copy-pasting blocks of code and changing them without understanding what is happening.
What's abusing streams?
Currently I don't know JUnit. I do not write test cases for my any java programs. &amp;#x200B; **Is it important to learn JUnit?** How it will make my life better? &amp;#x200B; If, anyone has any article which shows the important of JUnit, please share i the reply. Thank you!! &amp;#x200B; I will plan to learn JUnit then! &amp;#x200B;
Chaining a bunch of them together gets pretty hard to read.
To put it another way, I'd be suspicious of anything over 75 lines or so. If you want a better measure, look at the [cyclomatic complexity](https://en.wikipedia.org/wiki/Cyclomatic_complexity)
We got a wrapper round slf4j that takes a Supplier&lt;String&gt; so you can pass a lambda to the log and defer execution if the log level isn't enabled. Someone somewhere got in in their head to always use this on logger calls rather than only when you need to defer an expensive computation, which fight me String interpolation or concatenation is not, then it spread like wildfire. For starters, they put MessageFormat#format calls in because the Supplier breaks the MessageFormatter that sits under each logger method for handling it's args. So a MessageFormat#format is called to interpolate a String, which is passed to it's overload that takes a String and any number of args and applies creates MessageFormatter and calls format on it. Worse, it hides nullpointer exceptions till runtime when the log level is enabled. So when you're bugstomping and you turn on debug logs, now you have a different bug. Worse, I get comments on my PRs to please use the lambda logs. I'm trying my best not to be passive aggressive about it, and instead wrote a blog post with experimental evidence of my hidden NPE concerns and got an attaboy but no movement from the team.
When I say Exception, I mean Exception.class. Worst ones are the try/catch that catch Exceptions and throw RuntimeExceptions so it doesn't crash. Ever. Second worse ones just swallow and log the all Exceptions. Third worst catch and annotate/mutilate the original message.
If you touch it, you own it. Make as many commits as you feel comfortable reverting when QA tests it and call for a regression. Or make a cleanup story and push it first.
My point is that the number of “screens” it takes up is meaningless. It is the number of lines that matters.
lack of tests. Basic oop kinda stuff... ie Improper use of interfaces or bean wiring, or duplicate code. In our project people have a tendency to not use polymorphism enough so I look for that. I look pretty closely at exception handling... it seems like people don't understand how to handle exceptions and I guess I've done a lot of work with them. if you're not running sonar and other tools to see which lines are covered by tests, and other sonar warnings, I highly recommend you look into it. yeah it'll flag some dumb shit but it also helps. Also, probable null pointer exceptions. I try not to be critical about things that are likely my personal preferences. 
This was exactly my point, it is the number of lines that is important.
It's intentionally ambiguous because hard and fast rules are dumb and bad. Some methods do necessitate being huge for whatever reason but generally they shouldn't be. 
Code reviews discourage opportunistic refactoring. That is a huge con to code reviews.
Oh ya, I'm in agreement with you for sure. Just throwing in my 2 cents. One guy I work with has a vertical 4k monitor that'll show like 250 lines at a time. 
* If there's a dev on the team that thinks there's a specific number of lines, such that any method that has more than that many lines is automatically bad and should be rejected during CR, the team is fucked. * If there's a dev on the team that thinks "I know, I'll just set my monitor resolution really, really high, and that way, I can get my code through CR reviews and no one can stop me", the team is fucked. * If there's a dev on the team that thinks "I don't like this CR, so I'm gonna set my resolution really, really low, and then I can reject the CR because as a team, we made the rule be '1 or 2 screens'", the team is fucked. * If there's a dev on the team that hears a proposal for a coding standard, and their first thought is "I want the rules to be very explicit and objective so that I can game the system and rule-lawyer my way through any arguments", the team is fucked. Maybe you're one of the example devs I listed above, and maybe you're not. Maybe your team is fucked, and maybe it's actually going to do really well under your guidance. I don't know, 'cause I don't know you. But the above examples are what came to my mind when I heard your statement.
 Bar doSomething(Foo foo) { if (foo == null) { return null; } // ... }
Thank you for the follow up.
I think either you're changing the topic of discussion, or I don't understand what you're saying. I'm talking about CRs AKA Code Reviews right now. Do you have QA test after each CR, or do you allow for multiple CRs to be bundled together into a release before QA tests it? Do you have multiple stories in a CR, or at most one story per CR?
I think CRs only discourage opportunistic refactoring a little bit, and encourage refactoring in other ways. It's like saying unit tests discourage opportunistic refactoring, because you might rename a method that a unit test calls, and now you have to change the unit test too. Sure, that's a minor discouragement, but unit tests also encourage refactorings because they help you be confident that you haven't broken anything. CRs may discourage refactorings because someone might yell at you if you mix a bug fix with a major refactoring in the same commit instead of separating them out into distinct commits -- but that's a minor discouragement. CRs also encourage refactorings in that it's easier (at least in my team culture) to convince someone that the change you made is "correct" if all the code is easy to understand, and so a "refactoring" commit before the actual "bug fix" commit can make the code easier to understand and thus make the CR process go more smoothly.
&gt;The lack of a logger being initialized at the beginning of every class is a red flag Time to learn AspectJ.
Expecting teammembers to follow opinionated code-styling without enforcing it at the build level using a linter. Not putting curly braces on a newline? Whooooo caaaarrrrresssssss
Don't forget shit like casting an interface to a concrete object.
This can always be enforced at the build level, and if you are not then you have no ground to stand on. If you find yourself commenting on PRs about code styling issues then you should probably re-assess how you're spending your time.
"Rules are rules." Stop, go fucking play games somewhere else.
Can people stop responding with Wikipedia links? I'm sure as hell not going to seek coding guidance from there.
Which is a good thing because SRP is another term for "ridiculously anemic classes with insanely low cohesion". 
Oh no, it's not a *personal* opinion. More like a cult to the dark god Uncle Bob and his detrimental advice. 
Too many interfaces. * If you are making an interface that has exactly one implementation, you're doing it wrong. * If you are using an interface for a local variable even though you know the concrete type, you are doing it wrong. * If you are returning an interface from a method even though it will always be a specific concrete type, you are doing it wrong. * If you are accepting an interface as a parameter... well actually that's a good thing. Carry on. 
I'm not sure what you mean by "enforcing modularization." There are no plans to remove support for putting classes on the classpath, which then comprises the unnamed module. Reflection will still work on such classes. If they are later migrated into a module, that module need merely be declared with the right "opens" declarations to allow reflective access to them to continue. I think you might be talking about reflective access to *JDK internals.* That's controlled by the `--illegal-access`setting, introduced in Java 9, whose default value is `permit`. (This value issues at most one warning but otherwise allows execution to proceed.) The default value is still `permit` in Java 12. There are no plans yet to change this default, but is something that's being talked about. Note however that in the releases after 9 (including 12) do add some new restrictions. For example, reflection on the reflective classes themselves such as `Field` and `Method` is now disallowed. See [JDK-8210496](https://bugs.openjdk.java.net/browse/JDK-8210496].
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt;All it takes is one bad Indian to put a .toString() call on a fucking String object and that shit will be all over the code like a copy-paste kudzu. I hear ya, expect the worst wherever a "derka derka" is coding.
While allowing humans to deviate from the rule is essential, so is setting a fixed threshold because this makes it measurable by a machine and thus objectively observable at the system level. That lets you answer interesting questions like what percentage of methods in the system exceeds our agreed upon threshold. If that number is large you know you have a problem and can do something about it. Anything you can't measure you also can't improve. So I'd advocate for lines for the tools plus human judgement for the concrete code.
If you would use AOP or Proxies or if you use easymock or something similiar, then you would know that having single implementation of interface is pretty common thing. Also returnin some specific type is not better than returning interface. By returning interface you make your code more extensible in future. Are you really returning HashMap from your methods instead of Map? What if you find out later that you have to return unmodifiable map or synchronized map? Or SortedMap just for performance reasons, not that the user needs its API. Or if you decide to optimize some branches with emptyMap or singletonMap? The problem with your statement is the condition "it will always be a specific concrete type". Sometimes it is even better to return Map instead of SortedMap or Collection instead of List or Set. Or even just Iterator, Stream or Supplier.
Gee, sorry for providing a conveniently clickable reference for people who might not know what that term means and want some basic information. Nobody is claiming Wikipedia is the be-all-end-all coding guide. To be honest, I wouldn't be seeking coding guidance on reddit either given the routinely awful advice I see posted here. I'm just trying to constructive by giving pointers based on experience.
&gt; Worst ones are the try/catch that catch Exceptions and throw RuntimeExceptions That's no longer necessary, you can throw checked exceptions without a `throws` clause since Java 8: [sneakyThrow](https://stackoverflow.com/questions/31316581)
Well, I guess that depends on your codebase and how rigidly SRP is followed without respect for pragmatism or other factors. In general, though, creating a class with multiple public non-getter methods (outside of static, stateless utility classes) means that your code's internal dependency graph is being degraded.
I disagree with a few of your absolutes. * An interface with exactly one implementation can be fine in certain circumstances: IoC, DI frameworks that require public setters that are never intended to be part of the API. * Using an interface for a local private variable is generally one of my pet peeves (particularly when it involves down-casting), but I'm never going to quit List foo = new ArrayList() so I guess I can't agree with the absolute rule. * Returning an interface for a method that will always be a specific concrete type can have value when it communicates architectural intent. Like, yeah this implementation has a method you could abuse to get your job done, but I'm going to take away that option by returning an interface with a subset of methods. Basically my first point, but acknowledging there can be reasons besides DI to have inaccessible public implementation methods. I basically see one of my jobs as a developer to be making it as difficult as possible to use a class wrong. It's way easier to make things more permissive later if necessary, and damn hard to get that cat back in the bag if you let it out and it turns out to be a mistake.
Yikes. Impossible to maintain any velocity with that mindset. I'd estimate 95+% of my CRs have multiple such commits. I generally try to keep cleanup stuff sanely segregated commit-wise and CR-wise but requiring one commit per CR with no conflation with cleanup makes for nightmare codebases that are full of annoying things that build up over time and never get fixed because there's too much friction to do otherwise.
huge switch cases, fuck thats me. 
Not only strings but numbers as well. I don't know what your arbitrary return code '4' means. At least use constants for that.
Lack of objects because they copied the code from another language
It looks like in your [submission](https://www.reddit.com/r/java/comments/apqw4v/my_java_installer_wont_install/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Gigantic lambda methods inside one the stream ops is an abuse. When you've got something like a stream &gt; filter &gt; 60 line map &gt; collect 
My biggest pet peeve- unnecessary complexity &amp; writing frameworks "preparing for future requirements" instead of just directly implementing features you need now. "Preparing for future requirements" never works. Future requirements never come, or when they come, they never fit in the framework you wrote to support them "in advance". Just do it. If you need to do X, just do X. It might be boring, but it needs to be done. Don't implement a framework to do X1 ... X99, as you will actually need to do X1 and maybe X2 in a couple of years. No need for all those abstraction layers inside abstraction layers. If you need to write a framework, implement several use cases using simplest code reuse or just copy paste, and THEN refactor and generalize. Don't do that in advance.
Using a switch as a loop and other stupid shit like that. Rewriting their own version of basic Java functions, such as String.join(). Bonus points if the function calls String.join() and unwittingly behaves exactly the same as join with extra code. Premature optimization. "Why the hell did you do it this way, what the hell does this do? " "It's faster" "How much? How performant does this need to be? Are you planning to own this code until the end of time? Is this piece even relevant to performance? Can you at least leave some comments?" I've seen places where they did something super convoluted that saved less than 100ms when some other part of the code took a couple seconds, in situations where performance isn't important such as a nightly job that takes 2 minutes and runs at 11 PM. 1000+ line methods that call multiple 500+ line methods. (Getting into the weeds of recommended patterns and MyBatis) Services that reference another server, its related DAO, and the Mapper interface referenced by that DAO. SQL statements in the middle of a method. 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
InterruptedException not interrupting current thread, catching generic exception or throwable.
What is wrong with making an Integer object ? 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Open class IntelliJ, entire sidebar yellow with warnings: 🤨 
FWIW, that's not what happens in my experience.
Nothing in particular, but you should use valueOf or autoboxing.
Could you give some insight of "huge switch case instead of OOP" ?
I'm not certain, but I believe `new Integer` force-allocates memory for a number already somewhere in cache. This is possible because number classes are immutable. The same thing happens to String class, you don't do `new String` just `"&lt;string&gt;"` I may be completely wrong, so check up on other sources.
How many developers code commits pass your review first time?
Instead of something like switch(animal) case dog: “bark” case cat: “meow” case duck: “quack” You should use object oriented programming techniques like extending and Animal class to a Dog, Cat, and Duck all of which overwrite a “speak” method that you can call. Using polymorphism, you will no longer need a switch statement to output the correct text. 
&gt; copying DTOs to identical DTOs Not sure if that's what you mean, but at my previous job there would be a class used internally in the project and another which would be used for serialisation to json. The classes were almost identical (except for some annotations) and we were copying data between them. The idea was that now you can change the internal class without fear of breaking a contract with another service. I wasn't a huge fan of the practice since 99% of the classes were the same anyway. Is this what you meant? What other approach would you take?
 jshell&gt; String.class.cast(null); $1 ==&gt; null Boom!
 for ( i = 1; i &lt; 100; i ++ ) { if (i % 2 == 0) System.out.println("Even"); else System.out.rpintln("Odd"); }
The worst is to catch the exception and do nothing (or simply log), when in fact this was a real error. Much harder to figure out what the problem was in retrospect. Mutilating the error message (or worse, throwing it away) is also a cardinal sin. Converting to `RuntimeException` need not be so bad, depending on context, and has nothing to do with whether it crashes (an exception gets thrown either way). It does avoid compile-time errors, though.
Now I want to know how to use a switch as a loop
I highly doubt that it was meant that way. My guess is, that the DTO is replicated just for decoupling sake but lives in the same source code like DogEntity &gt; DogControlDTO &gt; DogViewDTO even though the `DogControlDTO` and `DogViewDTO` are identical just to decouple control from view
The first three seem more like soft recommendations than hard guidelines you should absolutely hit. For data classes and classes that represent state, I don't care if there's a huge list of arguments. They're usually constructed in a single place anyway. Sure, methods should be as short as possible, but splitting up a method solely on line count is not a good thing. Methods should help you re-use code, and if the code should only be executed in a single place, don't pull the code to a method. Next thing you know, someone is calling that method even though it should never be called at that point. I don't care if a method is long as long as it's not complex. Initializing a view, for instance, is usually just boilerplate and might take a few hundred lines of code, but it's all there with like two if's. Same thing with long classes. As long as everything in there is a cohesive whole, no reason to split it up. For instance, take a class `NumberFormatUtils` that contains a collection of functions. Why would I split that up into multiple classes? On what grounds? Where do I put the seam?
System.out.println() in production code
You just described our whole codebase
Use of the Vector, Hashtable and Enumeration classes (unless required by an ancient API that you have to use). 
After enough declined PRs, all of them :)
Empty exception catches
Is it suppose to pass the first time? I wonder... If it's a small commit maybe, but passing the review on your first try is unlikely fo any sizeable commit.
valueOf will fetch the value out of a pool if it is already cached which makes it faster and lighter on the memory.
I think this is a good practice, since even a single broken contract can make lots of pain.
So, `Integer n = &lt;integer&gt;` is like syntactic sugar for `Integer n = Integer.valueOf(&lt;integer&gt;)` ?
Not sure why you were downvoted for this.
Thanks for this. I'm gonna totally use it.
&gt; If they missed that simple detail, they probably missed others. The halo effect. 
Hey, I got so burnt out I made a class in my "test project" at work with all the code smells I've found at my current work. Just FYI, "ATomarPorCuloException" is just a joke name and could be translated as "FuckOffException": package reddit; import reddit.exception.ATomarPorCuloException; public class CodeSmells { private String otherText = null; public CodeSmells() { initClass(); iVeSeenThings(); } private void initClass() { System.out.println("Finishing process..."); otherText = "Value"; } @SuppressWarnings({ "unused" }) public void iVeSeenThings() { String text = null; text = null; try { if (null == text) { } else { System.out.println(text.getBytes() + " " + otherText); } } catch (Exception e) { //Ignore } try { if (null == text) { } else { System.out.println(text.getClass().getName() + " " + otherText); } } catch (Exception e) { //Ignore } if (null != text) { try { System.out.println(text.getBytes() + otherText); } catch (Exception e) { System.err.println(e.getMessage()); } } // if (oldBooleanFunction()) { // ArrayList&lt;NoLongerUsedPojo&gt; a = oldFunctionNoLongerExistant(); // for(NoLongerUsedPojo o : a) { // System.out.println(o.getValue()); // } // } try { text = "So happy!"; } catch (Exception e) { System.err.println("So sad!"); return; } try { ATomarPorCuloException atpce = wtfMateSeriously(); System.out.println(atpce.getMessage()); } catch (ATomarPorCuloException atpce) { System.err.println(atpce.getMessage()); } return; } private ATomarPorCuloException wtfMateSeriously() throws ATomarPorCuloException { ATomarPorCuloException retorno = new ATomarPorCuloException("Jarl"); return retorno; } } 
Yuck
&gt; Any method that takes up more than 1-2 screens What. Methods shouldn't be longer than ~40 lines (excluding comments, whitespaces). Maybe 60 if you're doing some exceptions juggling. If your methods are longer, then you're doing encapsulation wrong.
Couple of orientation sessions would make any dev learn what is expected out of a speedy pr review -approval
If you want small methods then you can add a Checkstyle rule and automatically check it in your IDE and your CI tool. A tool tells you "Hey look at this method, it might be too long". Then you look at the method and you have two options: * refactor the method to satisfy Checkstyle * Add a checkstyle:off tag with a comment. Why on earth would you want to wait for a code review to have feedback for this kind of very simple rules?
Yeah, ok. Should refer to a method then. Which should not be 60 lines either.
You missed two 0
Will this type of functionality ever make it into OpenJDK?
How come you're not so fond of getters?
I have been sonarqube for the past few months and it has helped me ace all reviews. Correctly predicts all Java code issues and can indicate how much time and effort is required to remove such issues. Also it comes as a plugin for IntelliJ (sonarlint) 
&gt; At least use constants for that. final int MAGIC_NUMBER = 4;
I'm not the user you addressed it to, but I'll answer the question. Getters break encapsulation by revealing the internal structure of the class and making the implementation fields part of the class' public contract. External code should be calling "real" methods on a class to get work done, and not interrogating the internal structure of the class' implementation by calling its getters.
Your comment makes a lot of sense, and there's always exceptions in programming (unless your using Go ;) ). Maybe I did consider red flags more of 'warnings' rather than hard guidelines. &gt;Sure, methods should be as short as possible, but splitting up a method solely on line count is not a good thing. Methods should help you re-use code, and if the code should only be executed in a single place, don't pull the code to a method. Next thing you know, someone is calling that method even though it should never be called at that point. I don't care if a method is long as long as it's not complex. Initializing a view, for instance, is usually just boilerplate and might take a few hundred lines of code, but it's all there with like two if's. I agree that complexity is a bigger issue than lines of code, but it's very hard to have a complex method if you keep the lines of code down! 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I guess because of why the standard is there in the first place. It's not to arbitrarily impose x lines limit on methods/functions, but can be a sign of poor design, identifying which goes deeper than simple lines counting.
Oh. One super catch Exception, rather than the specific exception types? 
It looks like in your [submission](https://www.reddit.com/r/java/comments/apsjna/minor_violations_java_code_analysis_on_duerank/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Polymorphism based on class hierarchies is one choice, but pattern matching style is valid as well - you should use the tool which fits the use case best. Neither of the two is more inherently object-oriented, btw.
I'd spend more time writing commits than code.
That presumes that an arbitrary threshold has any meaning at all. Example scenario: \- many coders produce a few methods with many lines; \- someone arbitrarily decides this is bad, imposes method line count threshold; \- now many coders produce millions of 1-line methods; \- someone arbitrarily decides this is bad, imposes a method count threshold per class; \- now many coders produce millions of classes, each with 1 method that contains 1 line of code. Did the code quality improve?
And the next time, with way less declined PRs. Having proper code is the easy part. The hard part is the human problem, as always: enforcing the proper culture. In my experience everyone already knows what to do, and wants to do the right thing; but discipline is hard and every one is lenient with him/herself.
Java doesn't have good pattern matching. In Scala, sure, but class polymorphism is the way to go in Java
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
It looks like in your [submission](https://www.reddit.com/r/java/comments/apsrxl/document_your_kafkalistener_endpoints_in_spring/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
At least they printed it. Our code base has hundreds if not thousands of these: try { ... } catch(Exception e) {}
Naming a file "MyJavaClass.java.02122019" because they're too stupid to use version control. Copying an important file across 4 projects and then making changes to it in two of those places. Importing jar files instead of using a dependency manager. Unused variables everywhere. Every method throws Exception.
The most obvious red flags are actually the ones my tools show me. Most of my colleagues use Eclipse and never run Findbugs/Spotbugs. Whenever I open their code with IntelliJ I get a load of (soft) warnings.
It's not a corner case, but a common case, for integers -128 to 127 (8-bit), Integer::valueOf caches the object to optimize autoboxing using IntegerCache object. 
Checking the package name of sub classes to define behavior instead of using an abstract base class to define the child's behavior
I agree and I did adopt that practice in my own projects. My main concern is that the conversion code turned out to be a lot of code and it sometimes led to bugs. Wish there was a type-safe way to do that, were you have to explicitly mark that you want a field ignored and so on. 
&gt; packages sorted by technical role instead of domain You need to let that one go. &gt; no security/sql injections/security done client-side You need to not let that one go.
Switchs, elses, boolean flags...
Findbugs is deprecated, you should use Spotbugs now. It's a fork. Also good: Sonarlint, Unused Code Detector
The idea was we were locked into the database schemas, so we thought a DTO to create the actual objects we need without the persistence annotations would be nice. It ended up being a highly coupled layer with very little value. This way my project from 5 years ago
An interface with a single implementation can also be used in projects with multiple ClassLoader, since the only way to communicate between two CL is by using an Interface. I had a project which was able to hot-replace code at runtime without stopping the server, and it used a such interface.
Also, side effects in map
How can AspectJ help substitute for a logger? It's been a decade since I did much with AOP. What should I review for a refresher?
No, you misread what I said. new Integer can be *faster* than valueOf in corner cases.
 &gt;Rewriting their own version of basic Java functions, such as String.join(). Enh, plenty of projects still exist in pre-8 land. And when they do migrate, a mass replacement of `theirCustomStringJoin()` with equivalent String's join() isn't high on the priority list. I agree with your point -- don't reinvent the wheel just because of NIH Syndrome -- but that's not the best example unless your audience is young. Maybe use `Math.max()` as an example instead?
If you are hot-swapping code then you have two implementations, even if they have the same name. I'm not against using interfaces when it actually gains you something. I'm against it when they are used without thinking.
//dont change, important to check against
I would argue that the other way around is the way to go. Think in terms of business first and think about the persistence later on. There are times were you have a `Dog`, but need special handling or fields only required for persistence like the `@Id` field. My guess a normal `Dog` would not require an `id` field. But since this field can be private you can pass the `Dog` around even though they are persistence annotations because from a consumer point of view, he does not see much more. But you are right, do you even need to decouple your code from your framework. Imagine every bean not being annotated with `@Inject` anymore but you having your own proxy.
Why not use some good old interfaces @Entity public DogEntity implements DogControl, DogView { @Override public void controlSpecificGetter() ... @Override public void viewSpecificGetter() ... } and just pass the specific abstraction to the layer like public DogService { public Result checkDog(ControlDog dog) ... } Maybe decoupling that stuff in your own application this way might be overkill. There might be better solutions if you think about that kind of stuff.
It's not to substitute the logger, it's to do the common instantiation code in one place.
I am not sure either.
That used to work in Java 7, too, but you had to add a generic parameter of RuntimeException explicitly. Seems like type inference in Java 8 removed the need to specify that. I had been wondering about that.
Would you mind expanding on the logger part? We use loggers in our project rather sparsely, certainly not in simple transformers, services, etc. And even if the code is somewhat complicated but it doesn't have a logger in there, I don't see why it would be so difficult to properly debug it and find a problem. I mean I don't see how having a logger is like a major part in finding where exactly the problem is. But maybe I am not working on complex enough system to see this. I am genuinely curious, because maybe my team is making a mistake by not using it extensively and we just not know it yet ;)
&gt; Maybe you're one of the example devs I listed above, You pulled all of those out of your ass. The point was, screens/method metric is useless.
Lombok has some logging annotations to inject a logger at compile time. Pretty nifty. Groovy has an equivalent feature.
The fact that we’re using Java and people are barely out of school and can’t imagine a world outside of IntelliJ
Actually, I made it a specialty to save projects which were going to Hell. So, I'm fairly used to very bad code-bases.
Log4j2 API has built in lambda logging support that works properly. 😉
VGA
You have to use the same DTO, unless you really can't do otherwise (which happens). Copying data between two identical DTOs, only to see them diverge, generates a load of bloat code and errors. Then when the projects grows bigger, it's impossible to know what is used and where because you have to check four paths (up and down) plus the converters instead of two path and no converter. There are ways to customize your serialization jobs (ie. views or customserializer)
&gt; In Scala, sure Does Scala have pattern matching that isn't slow and bloated now?
If there’s no way to recover from a checked exception how do you handle it? Return null at let it blow up on a npe? 
What is the fix for this one? Throwing an exception? Checking for null outside the method? 
Ahah, yeah. Well no I won't let the first one go. Okay! It works when you sort everything by technical role. Especially if your code-base is small. But... sorting your code by domain makes it a lot easier to identify where the responsibility goes. A software grows, you add, update, and remove functionalities all the time. So it makes sense to know exactly what code is impacted by a functionality just by looking at the packages. Also, sorting everything by domain will make it more obvious when you have to use the message system instead of hard-coupling when talking to the other components.
Almost none.
A get is an invitation to break [Law of Demeter](https://en.wikipedia.org/wiki/Law_of_Demeter). I know that law is a bit old-fashioned and not everyone likes it at all, but I think it is a good thing to have in mind.
What's the issue with single logger instance ?
100% agree, but also do not use this as an excuse to write obfuscated code with constants in places where a simple number is makes much more sense, in particular in test cases where I just want to look at a (short) method and see what it does and why the expected values are what they are. It is obvious that you have a 2 and a 3 and expect the sum to be 5, but it is much less obvious that SOME_CONSTANT and SOME_OTHER_CONSTANT added together results in A_THIRD_CONSTANT. I know there are IDEs you can configure to print the value of constants right there in the code, but then maybe the code review tool or git diff or some other tool will not do that so the code is still obfuscated in some contexts where I might want to read it. Encountered the extra bad version of this, because in a project we had automatic commit-rules preventing code with "magic numbers" so of course that resulted in a lot of constants like TWO or THREE just to make the lint tool happy.
The problem is it's a process of constantly rewritting your DTO's, which most people never do. After 3-6 months, the next guy just updates it, he/she never take ownership of the code and introduces larger rewrites. Imagine if a writer introduces a new character in the middle of the story. You would think that writer was lazy not rewriting previous chapters to introduce that character at the write time. Well, we lazily write the code the requires the least amount of thought all the time. A lot of the time that means copypasta and coupled classes. 
This entire message thread demonstrates that code reviews are _almost_ entirely worthless. Everyone is trying to force their opinions on other people through the power of rejecting code during review. There are only two things to check in a code review: 1. Is the code correct? 1. Is the code maintainable? Maintainability is mostly taken care of by having an agreed upon code style for the project and that code style can be checked with automated tools at commit time. The rest is taken care of by having readable code. However, this is where subjectivity takes hold and opinion starts creeping in. Some people have never seen a lambda they didn't like and are fine reading code with 3 deep nested lambdas. Others find almost all uses of lambda unreadable. So readability is un-reviewable. So this leaves correctness. This is a loaded word, but it certainly doesn't mean the code has to be written how the reviewer would have done things. It means the code meets the acceptance criteria. If you don't like how it was done that should have been brought up in the design review. Code review is not the time to redesign things. 
I'm assuming you then sort by technical role within each domain?
Sure. Context matters - a lot of my software are pluggable or deployable modules. It is not often practical for me to put a debugger on it especially if an issue comes up in PROD. I can't debug it, but I can log all the data I want and look at log files. This may not apply in your case. Think of a logger like a debugger that can run when you aren't there watching it. First you want one logger per class import org.apache.log4j.Logger; private static final Logger LOG = Logger.getLogger(MyThing.class); That way you get log messages prefixed with: com.myboss.myproject.MyThing 2019-02-11 ZOMG I logged a thing That is in contrast with one logger per project. That would log something like com.myboss.myproject 2019-02-11 ZOMG I logged a thing, but you don't know where! The next thing to understand is log levels. I can readily flip a log config to log at a debug level and absolutely spam my logs with data. That detail is needed to identify or triage an issue, but it's a total waste during normal ops. Log errors as errors, log warnings as warnings, and so on down to debug statements like entering and exiting a method. Finally know what log operations are expensive. If you have a call to https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/ReflectionToStringBuilder.html to dump out an objects contents, add a check so you don't do that big expensive call all the time. Something like this: if (log.isDebugEnabled()){ String myBigString = SomeBigExpensiveSerializer.toString(); log.debug(myBigString); } If your logs show you exceptions and stack traces that's a good start. The next step is to get enough log data to tell you what inputs you got and what happened leading up to that error so you can fix the root cause. Now combine all that with good log retention or even a log search mechanism and you can know what your code did at any given time. That helps solve problems and spot inefficiencies. 
Yes indeed, if necessary.
You won't be able to attach rules and appenders to your packages with a single logger. Also, your logger won't know which class triggered the log. You should always create at least one static logger instance per class, and attach it to your class (it is recommended to create one instance per instance, and avoid the static part).
Number of lines doesn't matter, either. You can make code far less readable and maintainable by removing line breaks (if-then-else and all braces on one line) just to fit it onto 1-2 screens. If the programmers of your team do not understand *guidelines* and *rules of thumb* and instead take them literal, you have bigger problems then the question of screen resolution.
Yet... :)
You should have one per class, not one per project. You probably shouldn't be passing them around 99.9% of the time either.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You should probably throw a subclass of `RuntimeException` though.
It looks like in your [submission](https://www.reddit.com/r/java/comments/apur13/why_isnt_my_array_code_working/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt; Abusing Stream API What is abuse of the Stream API, in your opinion? I have a hard time imagining what would qualify as this.
Yes, that's very important. If the number returned has itself a meaning, you should of course use the number and not some constant. As for the automatic review situation: I know some tools allow to add a comment after the offending line to disable the check. Only if it's really necessary of course. I meant that some computing functions with more than 2 results (true or false) should not use some random numbers as return values. It's better to just use constants so the code is easier readable. Even better would be to use enums for this IMO. Or split the function/method in to more functions (only if it's long anyway). I guess there are multiple equally good or bad solutions to this problem.
It depends on the context, but very often that's true.
I like this idea, and just because I'm curious, what do you do with services/other code that might cut across domains?
They mean explicitly catching `Exception` rather than a concrete checked exception and throwing `RuntimeException` rather than a subclass. There's no issue with rethrowing a checked exception as an unchecked exception, but you should be adding context and not doing it indiscriminately.
I can answer this in a slightly different way - I think the best way to think of objects is as partially evaluated functions (or in some cases one object represents multiple partially evaluated functions). If you’re not familiar with this term, it basically means a function where some of the variables have been filled in with constants. A getter is the degenerate case of this, it’s basically just the fully evaluated identity function. This is all just another way of saying that getters don’t do real work and they don’t further the abstraction of partially evaluated functions. I haven’t motivated why this is a good abstraction, but I’ll leave that as an exercise for the reader.
That's not a terrible thing. Commit messages are documentation. They should explain why and any other pieces of information and thought processes that went into a change. And generally smaller commits are preferable to larger commits 
I'd rather have a disabled test than a broken test, but then just deleting a test because it doesn't pass is possibly worse. A fixed test is the best solution :)
 Either you create a common package (not recommended), or you use the message system to dispatch the information to your various components. If you think about it, a transverse service has obviously its own domain, the only issue is it requires data from other components. Since you want to have them loosely coupled, instead of fetching the data or doing the action aggressively, you just gently ask them to do it for you. In a complex application, the message system becomes the heart of everything. You could use a simple one (not much better than a Queue), or use expert systems (i.e. Apache Kafka).
How do you know where the log statement came from?
I'm getting the feeling that I meet you somewhere. &amp;#x200B; On my case, we have a recurrent "DataException" that it's used for nearly everything.
References to concrete classes where a suitable abstraction exists. Long methods. In particular ones which perform multiple operations and decide which one to do based on one parameter. Like for example one I saw recently in a Spark app which had the logic for three different HTTP verbs in it and wrapped the lot up in a switch on the verb. Dude... The same eight fucking parameters being passed from method to method to method everywhere. A bunch of package-private members. Not always wrong, but as I keep finding out at the moment, people are often doing it just to shut their IDE up. Commented. Out. Code. Piss off. Enums that are ignored in favour of passing around strings which are occasionally validated with a method on the enum itself. This one drives me nuts. Missing tests. Tests which aren't missing but have no assertions. Don't laugh, I joined a team that "achieved 95% test coverage" using this method. Comments like // adds three to val Comments in general 
I'd rather have a broken test than a disabled test. Disabling it is basically the equivalent of deleting it. If a test is broken you should either: * Fix it * Realize it's not valuable and delete it * Realize it's a bad test that is too difficult to maintain and rewrite it to be better Leaving it broken doesn't hide the fact that something is wrong whereas disabling does.
&gt; &gt; packages sorted by technical role instead of domain &gt; &gt; You need to let that one go. Classes are like coloured cups. You can sort them by colour and stack them, and then you can easily see if any cups are out of place, or take out all 20 red cups. But children don't want 20 red cups. They want 3 of each colour. All the effort you go through to organize the cups when shelving them you have to undo when taking them out. Splitting controllers and DTOs and mappers into separate packages is really easy and looks sensible to our pattern-addicted brains. But it doesn't solve the problem we really have and in the worst case it impedes us.
Ok, so if I understood correctly, having a single logger per project is bad because doing so, you'll get away with the flexibility to play with appenders, log levels etc. and having one Logger instance per package is also bad because then you'll loose class information. Going a bit side track here,: 1. You've also mentioned "no input data validation" as a code smell, internet suggested that we should guard all our public assets. Do you agree with that? If so, then how would you go about handling expensive domain validations? If not, In a typical svc-business-dao flow, we'd usually put checks against input in svc layer since it's the "entrypoint" of the application. So, any data reaching business layer code is treated safe, but what if someone decides to call the method from another place. How would you guard against un-trusted input? 2. What's wrong with nulls ? I mean other that un-handled NPE and ugly code, how does employing NULL\_OBJ pattern add value? The reason I asking is, I've seen this practice advocated a lot of times, but I never understood the USP of this pattern. I mean ultimately either you'd check for a null literal or you would check for a NULL\_OBJECT, what's the difference.
At least JUnit, and probably other frameworks, separate out ignored/disabled tests, so you can see that a test has been disabled. Deleting it, you just know your test count went down. Assuming you notice.
I am pretty sure everyone understands that a method line limit is a guideline and isn't a hard limit. If the limit is 150 a handful of lines over obviously isn't a problem, 1000 lines would be. Does this really need to be said?
This is brand new code from a developer only a few years older than me.
Will the openjdk 12 builds include Shenandoah garbage collector?
If the code I'm reviewing features any one of * //TODO * //FIXME * Commented out code * System.out.println() That's an outright rejection from me
Yes. All of the features can be found [here](https://openjdk.java.net/projects/jdk/12/).
I like to keep methods shorter than 10 lines.
Getters are good when they're necessary, for example: – they are a part of a stable public API of a library (if your project is not a library, then it doesn't apply) – they are required by some other piece of code (usually a 3rd party library) that accesses or overrides them reflectively – the field would be accessed in so many places that refactoring a bare field access into getters and setters in the future would create a 1000-line diff – the field is technically mutable, but for 90% of the world it should be read-only In all other cases, getters are cruft that takes too much room on the screen and you should just use a bare field. Then of course you need to ask whether giving access to that field is a good idea in the first place, but that's another question. 
Magic numbers? Long methods? These are great. But I've worked with people who don't even understand what code is. Their stuff is just a bunch of code-looking words run together that mean nothing and won't possibly compile. How do these people even have jobs?
The problem isn't catching a checked exception you can't recover from. It's catching all Exceptions, as in Exception.class, and naively swallowing or mangling the error.
Nothing per se. You just don't want to do it accidentally. int primitives are smaller and more efficient, but there are times when you need an Integer. If you don't know why you need an Integer object, then you probably don't need it.
 final int FIVE = 4;
1. Add annotations for nullability, so linters can understand the code better. 2. If you want return null, document what it means and consider using Optional instead. 3. If you accept null, document how you treat it. 4. If you don't accept null, consider either `assert foo != null;`, `Objects.requireNonNull(foo);` or something similar. An early exit is especially important if the method has side effects or if it's computationally expensive.
&gt; Naming a file "MyJavaClass.java.02122019" because they're too stupid to use version control. This still happens?
I believe that the null object pattern is designed so that you don't have to perform a null check when interacting with the object's methods. `void` methods can do nothing and the rest can return default values. For example: interface Foo { void bar(); String getQuux(); } class FooImpl extends Foo { //... } class NullFoo extends Foo { @Override void bar() { } @Override String getQuux() { return ""; } } void doSomethingWithFoo(Foo foo) { // The following method calls do not need null checks on foo foo.bar(); String quux = foo.getQuux(); for (int i = 0; i &lt; quux.length(); i++ { //... } }
The problem is most likely in the context. I've seen code bases like this, where nobody is asking questions like, "What does it mean for foo to be null?" and "What does it mean for doSomething() to return null?" For example, suppose the method were something like: Response doSomething(Query query) { if (query == null) { return null; } // ... } What does a null Response mean? Presumably, it means the query found nothing. Perhaps Response is some kind of aggregate (like a Collection or a ResultSet) in which case it's likely better to return an actual Response object that contains zero items. But this code conflates a null query with an actual query that returned nothing. That seems wrong. Why would this method be asked to perform some work based on a null query? Well, maybe we should go look to see where the Query object came from. It might have come from a method like this: Query generateQuery(QueryParams params) { if (params == null) { return null; } // ... } Arrrgh. Now there is a whole other series of questions to be asked and answered about nullability of QueryParams. I've seen code bases like this, where somebody ran into an NPE at some point and decided to make things "safe" by adding null checks everywhere. The result is that *everything* is nullable even when it doesn't make sense. Typical remedies are to 1) provide a default value, e.g. a default query if you don't have any query params; 2) explicitly disallow null parameters using asserts or `Objects.requireNonNull()`; or 3) return Optional instead of null in cases where no-result is an expected outcome.
No, but I still find them left behind in our codebase like a time capsule filled with dog shit
* Hard coded properties * No tests * System.out.println() or console.log() in JS * Classes over 200 lines * Short variable names like "i" or "pb" (auto complete is a thing, just be thorough) * Excessive Map creation i.e. Map&lt;String, Map&lt;String, Object&gt;&gt;
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You should crosspost to /r/de . I bet you will find some Java developers there that could help you. 
&gt; It takes time to modularize your stuff properly. That's usually not that bad. The worse thing is when you have to modularize other people's stuff. It's not unusual to find older libraries that are not maintained very frequently that simply do not work with standard automatic modularization approaches. If you want to modularize them, you need to basically compile and package them from scratch.
Pardon my ignorance,, I didnt know null obj pattern should be implemented this way.. I always thought ``` public static final NULL\_OBJECT = new Object(); public Value doSomething() { // if the computation yeilds null then, return NULL\_OBJECT; } ``` 
1. I do not know what "guarding public assets" precisely mean, but yes you should validate all external entry-points. Especially the ones coming from unsafe sources such as a front-end client. I have honestly never encountered a case of "expensive domain validation", so I guess these cases have to be solved in a custom way when the occur (e.g. lazy validation in the getter). If your business code can be hit by an unsafe source, then you have to validate the input as well. Some frameworks implement the standard @Validate annotation for this. 2. Nothing's wrong with nulls when they are used correctly, but you should try to return something more meaningful when you can. You could return an empty collection instead of a null, a -1, or an Optional. The idea being: your code should never ignore a potential Exception. In this case, an NPE. When I said "nulls everywhere", I meant "an abuse of null values where it could be avoided".
I remember good ol' days when the bytecode of pattern matching had size exponentially proportional to the size of the source code. But they fixed it ages ago, in like 2.9 or so.
&gt; how does employing NULL_OBJ pattern add value? Thankfully, no one here advocated for the null object pattern. By "nulls are bad" people mean you should either throw exceptions or use the Optional type. If lack of something is a rare and unexpected situation, throw an exception. If lack of something is expected and likely, use Optional. Nulls are fine if confined to local code, so to local variables, private fields, etc.
[Is anyone of them called Paula?](https://thedailywtf.com/articles/The_Brillant_Paula_Bean)
Learn spring-boot to develop server-side and leverage your js experience for front-end development with a FW like react.js or angular.
I know and that's awful. Why would you do that?
Here are all the companies looking for java devs in germany and offering visa sponsorships: https://stackoverflow.com/jobs?l=Germany&amp;d=20&amp;u=Km&amp;tl=java&amp;v=true check glassdoor for salaries and reviews for the company cross-post on /r/cscareerquestionseu
&gt; List foo = new ArrayList() I'll be honest: most of us don't write `ArrayList foo = new ArrayList()` because it's too long.
I am not from Germany, and I have no idea what real-life salary expectations should be in that part of the world. But I was curious and while searching the web I found these references: * [https://stackoverflow.com/jobs/salary/full-stack-developer-salary-in-germany](https://stackoverflow.com/jobs/salary/full-stack-developer-salary-in-germany) * [https://www.payscale.com/research/DE/Job=Software\_Developer/Salary](https://www.payscale.com/research/DE/Job=Software_Developer/Salary) * [https://www.linkedin.com/salary/software-engineer-salaries-in-hamburg-area-germany](https://www.linkedin.com/salary/software-engineer-salaries-in-hamburg-area-germany) I also found this: * [https://www.numbeo.com/cost-of-living/in/Dusseldorf](https://www.numbeo.com/cost-of-living/in/Dusseldorf) I have no idea about the accuracy of any of this. Might be best to ask some actual Germans living in the area, if you can. Maybe some folks on /r/de would be able to help?
45-55k I would assume. Depending on company size, Your negotiation skills and your actual practical skills (if they check that) 
Thanks! I actually have a handle on React from code camp and sometimes use at my current position, but I could definitely polish that up.
Why not just return Optional&lt;T&gt;?
Right. It depends on the context. Which means if you don't understand the context enough to justify it you shouldn't do it. There's a place for almost all of these techniques, particularly very high up in presentation layers. But what I'm talking about is more indescriminate.
I know. Unfortunately I don't get to do anything except say we should upgrade.
It has some good concepts, but I would not. Shade if necessary to work around conflicting dependencies, break out into a service if that's feasible/appropriate. It's a ton of cognitive overhead that's probably not worth it the vast majority of the time.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
 That is what meant. Thank you.
Try /r/cscareerquestionsEU 
This was like 5 years ago, so my memory is fuzzy. I think they effectively used it like a for loop, by intentionally omiting the break statements. I think they used this to initialize the members of an array?
Helped fixed some code once where they had made their own suppliers that did database calls inside a stream, and otherwise had side effects. That was not nice to unravel....
Lived and worked as a Software Dev in Dusseldorf for a year across 2017/18 Rent for our 55 sq/m apartment was €1340 per month (inc. internet, water and gas. Pricey, but it was brand new and in Pemplefort) Salary was €52k (low 'cause consulting). Most of our clients Devs were on €60+ If you're coming from the US, healthcare can be a bit funky. If not, healthcare was deducted from my income (around 7.1%, with the company paying the other 7.1% to make up 14.2%).
I strongly disagree with your suggestion. For me telling someone with little or no experience with a certain language to invest in learning a framework that relies on said language is fundamentally wrong. Spring's stack is built upon base Java technologies like the Servlet API, JPA etc. Without s basic and solid understanding of those one will eventually experience problems during dev. From my experience, I have seen several people making the jump from JS dev to Java dev expecting things to be smooth yet they had a difficult time. There are core differences between languages and their fundamentals. Thus for me the best advise is to invest on getting a good grip on the basics of Java and then move on to more advanced stuff. Since the OP has a good grasp of JS they could potentially seek a job that would let them work with what they're familiar but also giving them the opportunity to slowly transition over to another field. E.g. coding in JS while studying the backend.
&gt; `Map&lt;String, ?&gt;` is almost always a sign that you should be using a type instead. `Map&lt;String, ?&gt;` *is* a type
That takes me back.
&gt; Which means if you don't understand the context enough to justify it you shouldn't do it. I agree. But even in the places where it's wrong, it's far less serious than the other two problems.
I don't write it because I don't want to commit to a specific implementation. Who knows what weird requirements the future holds. Maybe I'll have to switch to a LinkedList. Maybe I'll have to write a wrapper for the ArrayList. The fact that it's shorter is a nice bonus.
 catch (Exception e) { //the very best }
I usually see it as: catch (SomeException ex) { } catch (SomeOtherException ex) { } catch (Exception ex) { // all other exceptions } Indicating our hapless developer probably just tried catching exceptions until it "worked". 
Agreed. Though it might be worth taking a closer look at the vacancies. Most likely the majority is working with Spring, but it's better to make sure. As for the basics, make sure those include Java Streams-API and Lambdas.
&gt; trying my best not to be passive aggressive about it, and instead wrote a blog post Umm, you failed. :-)
&gt; I am pretty sure everyone understands that a method line limit is a guideline and isn't a hard limit. Just as everyone understand that 1-2 screens is a guideline / rule of thumb?
Late to the party but here are my two cents: - Copying and pastying code. I have failed multiple reviews due to this. You cannot simply believe that some people are able to understand why this is an extremely bad practise. - Code duplication not generalizing commonly used code. - God classes, carry objects and almost any kind of potential anti pattern. - Poor or no understanding of language concepts. For example a have failed multiple reviews where people have used parallel streams for a small amount of elements thinking it would be 'faster'. Another example is instantiating Spring managed beans using new. - Poor understanding of multithreading and it's caveats. - Poor understanding or avoiding to use proper design patterns. - Spaghetti code. - Magic numbers and in general poorly documented code. - Poor understanding of autoboxing and generics. - Avoiding to adapt to new language specs. For example we develop using Java 8 and now moving to 11 yet people still code using 6 patterns. - No attention to security e.g. when accessing the file system. SQL injection, HTML sanitization etc. I have seen myriad of stuff in the past years so the list can go on but here are the things that pop up in my head. Yet the thing I hate the most is when people don't pay attention or give zero fucks to review remarks. My reviews tend to be very detailed often providing sources for reading up on my remarks. I hate it when people not only pay attention thus persisting to make the same mistakes but I also detest she people ignore review marks thus forcing me to fail something with another review.
Using parallelism when not necessary springs to mind 
I personally would use `Optional&lt;T&gt;` in most cases for a method that can return null because I feel it better represents the contract (to me saying that it returns a `T` rather than an `Optional&lt;T&gt;` indicates that it should always return a valid instance of `T`) so I don't have much use for it, but I can see the rationale. And to be honest, I don't mind writing null/`isPresent()` checks anyway as they're pretty much force of habit at the beginning of public methods. 
For me it's the opposite. Eclipse has a nice central place to see the problems, It's even got a good name (Problems View). IntelliJ, not so much, apart from the pretty multi coloured border on the right. These days that sort of thing is baked into the pom. Format : google-java-code-formatter Style : checkstyle Static Analysis : Spotbugs
Depends. Is a unit test using the Interface for mocking?
Amen!
I think I might have worked on that same code. (shudder)
If you are familiar with dependency injection already, go for spring boot as the documentation is extensive and most modern ones are very resembling. Also in that manœuvre use IntelliJ as an ide as it has really extensive spring support and will help you spend less time sweating over minor typos etc 
https://old.reddit.com/r/java/comments/apcgbn/a_new_stream_api_collector_in_java_12_teeing/
Please provide more informations about about the content and quantity of your work experience as well as the schools education.
This might or might not be a strictly java thing, but while focusing on learning the language and it’s nuances, you should also focus the enterprise aspects of it. I think it helps to know how an application runs in an application server. How maven or Gradle works for dependencies and builds. How the projects are packaged(jar, war, ear). How ORM frameworks work vs plain old jdbc. I could go on. But do focus on the enterprise part. I can not emphasize on it enough. You do not have to master all the frameworks. Maven vs Gradle? Doesn’t matter when you start off and just learning! Just get an idea of it.
Thanks for the detailed response, appreciate it. &gt;. It is not often practical for me to put a debugger on it especially if an issue comes up in PROD. I can't debug it, but I can log all the data I want and look at log files. Actually this is all I needed to know. Yeah in that case obviously logging is the way to go. We too had to turn to logs for info, particularly with - as you also mentioned it - production environment. And yeah, in that case switching log levels in config file is super useful. So going back to the red - I guess it is not universally awful then to not log everything and everywhere. Good to know :P
I get a code review comment everytime I leave a blank line in my code. Or if didn't format one time and there's no space after the comma in an argument list. Every. Time. 
&gt; You should always create at least one static logger instance per class Kind of silly to say "always" there. People have made a fetish out of logging these past 10-20 years, and the result is that what should have been very simple is now extremely bloated. 
Oh Lord
I'm a software developer in Germany. &gt; what are the typical salaries and benefits (if any) offered by employers Probably about 50000 to 55000 a year is lower mid range. Maybe more inside big cities. Obviously varies wildly depending on company size, work hours, how much experience you have and how good you negotiate. Currently there is much demand. Expect to keep maybe 60-70% after tax and health insurance and so on. &gt; what costs I should expect for rent At least 900 incl. heat a month for something somewhat decent outside of the city centers, maybe 60 m². München is more expensive than Köln or Düsseldorf. Inside the centers much more or if you want something new or modern.
If you write a [TUI library that speaks xterm](https://github.com/klamonte/jexer), you will break all but one of these rules. :) (You won't abuse the Stream API because you won't use the Stream API at all.) 
Seems like you're familiar with the high level concepts of web servers, mqs, databases, etc. I'd say dig down into Java tools like Spring-boot/Mvc &amp; Maven
I can refer you to a nice company in Berlin which is one of the highest paying, PM me for details ;)
An Optional&lt;T&gt; isn't a T, therefore can't have implementations of the methods of T.
So what? You learn about those core spring APIs as you go along. Spring boot is the fastest way to get a web app up and since he's familiar with rest back-ends, he's already there conceptually. This is not to say he shouldn't spend some time learning the basics of java first. You should definitely be familiar with java syntax, typing, and more before getting into spring. However, you can definitely read up on servelet after building a few web services. Saying that you need to know about jpa before doing spring seems like putting up unnecessary roadblocks to being a java back-end dev. 
It's time to use auto-format, then.
No it did not because in your fictitious scenario the people didn't do what I said: they used the tool to micromanage people instead of looking at the big picture with it. I repeat: Human judgement for the concrete code.
Yes, you are right, if you are not logging anything, don't create a useless static logger. It wouldn't make any sense.
Yeah Spring Boot is indeed the fastest way of getting an app up and running but this is something that would be more suitable for a uni student. The OP needs to get a better grip of said concepts since he's planning to get a job on the field not just finish a uni assignment. I have 5 years of experience working with Spring and I'm a senior backend engineer. Trust me I have seen multiple people attempting to jump from one language to another and for that matter Java only to make humongous mistakes. Learn the basics first, familiarize yourself with the tech stack and it's notions and then proceed to fiddle with a framework. Going the other way around is a recipe for disaster. 
It hides NPE 'til runtime? Maybe you should fix your wrapper then, because logging should never alter the code's behavior. Catch all Exceptions in the wrapper when you apply the Supplier, maybe?
And I do, but either sometimes I don't or I fat-finger the key combo and it doesn't happen and I didn't notice. And there's lots of reasons it can't be done automatically on save.
Agreed!
No I mean that a single logger instance is more than good enough for 90% of logging purposes.
 **1.Programming help** [/r/Java](https://www.reddit.com/r/Java) is for News, Technical discussions, research papers and assorted things of interest related to the Java programming language, not for help with Java programming. Such "help with programming" posts should go to [/r/javahelp](https://www.reddit.com/r/javahelp).
Lately, one of my guy implemented a functionality which I reviewed. It was working, so the code was correct. And it was clean, so the code was maintainable. But he overlooked something, a small architecture trick which could remove a lots of lines. I told him that trick, he understood, reluctantly did the modifications for about four hours, and finally delivered a code which was five times shorter, and a lot more straightforward. What is your opinion about this?
&gt; €52k Gross or net? I assume gross?
Please help us help you: \- does the program build? Or are you getting compilation errors? If so, which? \- does the program execute? Or are you getting errors? If so, which? You say you are new to programming. If so, you may have to choose a simpler application for starting out and learning how to make executable java applications. Like, oh, a Hello, World!
I wouldn't call this a "red-flag". I would call this a sabotage. :)
Sorry. I don't understand why it didn't detect the duplicate...
Also, there are subreddits dedicatedbto helping people with java: r/javahelp and r/learnjava
Except that the Openjdk from Oracle isn't including it I'm guessing? I just downloaded the bits from [http://jdk.java.net/12/](http://jdk.java.net/12/) &amp;#x200B; $ ./jdk-12/bin/java -version openjdk version "12" 2019-03-19 OpenJDK Runtime Environment (build 12+31) OpenJDK 64-Bit Server VM (build 12+31, mixed mode, sharing) &amp;#x200B; $ ./jdk-12/bin/java -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -version Error occurred during initialization of VM Option -XX:+UseShenandoahGC not supported &amp;#x200B;
Some complex things are only doable through Reflection... or would generate a code overly complicated to do the same thing. I agree that Reflection should be avoided if possible, but I won't call it a "red-flag".
And practice writing form data to a database in java. So make a form and make the spring boot webapp then writing the forms to the database and maybe have a page to search that data via Ajax and return the data from the database.
`catch (NullPointerException e) {}` I will fail that immediately. &amp;#x200B; `catch (Exception e)` `{` `throw e;` `}` Always good for a laugh.
It works for me. I’m on the latest early access build, too.
Over-architecturing can cause more problems than it solves. When you do define the limit between two responsibility? Sometimes, the layer is thin and difficult to estimate. A strict limit of two public methods in a class seems overly agressive. What about fluent interfaces; they requires a lot of public methods.
Yes I know it has its uses. But I guess red flag doesn’t mean bad it means it catches my eyes and I pay attention more if I see reflection being used. 
Jeez! 86 m\^2 in Berlin, 23 minutes door-to-door via public transportation, and it\`s \~1k for the same things...
Thank you for the response. Can you provide the -version output for comparison?
openjdk 12 2019-03-19 OpenJDK Runtime Environment (build 12+31) OpenJDK 64-Bit Server VM (build 12+31, mixed mode, sharing)
You do not use loggers correctly then. I advise you to read a logger's documentation, maybe you will discover amazing functionalities you totally overlooked in your projects.
That's my point though - I don't want their amazing functionalities. My logging needs are very simple and the proliferation of more and more complicated logging is a distraction.
Look at Glassdoor, Numbeo, Stackoverflow and for some reason Xing is also popular in the German-speaking crowd.
It looks like in your [submission](https://www.reddit.com/r/java/comments/apyg9v/landed_java_internship_now_what/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Seeing as you're coming from a Node background, read up on concurrency.
With a wrong pool, too.
yeap
Personally I would have approved the code, then opened a new story for refactoring to the new architecture.
If it's a locally created list, it doesn't matter, you'd have to change that line anyway.
If you have such code structures I would assume you enforcing something like code reviews. Always let the original author or the last 3 committers cross review your pull request. &amp;#x200B; You can also introduce acceptance tests for your DTOs
Yeah. You live you learn. The product I was thinking about was around 5 years ago using SVN. Git allows so much versatility on committed code, you're able to review things before they're running in production :)
Background: I'm a Software Architect/Java Dev working mostly in Finance and I'm involved in most of the hiring we do. Rent varies greatly depending on the city and the commute you are willing to accept. I guess cost of living generally is Munich &gt; Hamburg &gt; Koeln &gt; Duesseldorf &gt; Berlin (Berlin is _still_ pretty cheap, not so sure about Duesseldorf vs Koeln). Wage expectations don't always align that well. Pay in Berlin, Hamburg, Munich is pretty good but you will have a good amount less money left in Hamburg and Munich compared to other cities. The sector you're is quite important, too. Consulting in finance / automotive pays _way_ more than being a developer in an advertising agency. Some tips: - Working with a *good* recruiter is a good idea. He/she will help you a lot with negotiating. The more you get the more the recruiter is payed. You might even be able to skip the negotiations completely and let your recruiter do it (again depending on demand and sector). If you need some good/better recruiting agencies PM me. - go check for realistic ranges for rent at https://immobilienscout.de (or it's competitors) - go check for wage ranges at https://stackoverflow.com/jobs/get-started - good companies include a range - there are some statistics which compare cost of living between cities like this one: https://www.financescout24.de/wissen/studien/lebenshaltungskosten - you can easily calculate how much money you'll have in your pocket with calculators like http://www.spiegel.de/wirtschaft/service/brutto-netto-rechner-was-von-lohn-und-gehalt-uebrig-bleibt-a-223811.html And then some wild guessing so you get at least some numbers: A Java Enterprise (not particularly EE, just enterprisey stuff) dev with a 2-3 years experience might be able to earn - 45 - 70K in Munich - 40 - 60K in Berlin/Hamburg - 40 - 55K in Duesseldorf/Koeln 
Look at the job postings from those companies, that should give you a good idea what technologies they use.
this guy's jumpers...
Concurrency can be deal pretty similar as JS if you use Futures or a library like reactiveX. No need to deal with threads if you do not want to.
why not gradle instead of maven ?
Best combo IMO
I have implemented 2 solutions with this client. I can add the following: \- It does not appear to support web form formatting out of the box. I wound up adding my own. \- It does not appear to automatically add web form data boundaries. I had to add my own. My use case may be unique though: I needed to submit a document to a REST API service that apparently got built to mimic manual file uploading.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You pretty much nailed my background - I'm a junior dev who was introduced to spring in an internship. From a hiring standpoint I have to agree that spring isn't essential and it's pretty easy to transition into if you've got java experience. Our senior devs don't explicitly look for spring. But given how popular it is, I think it's well worth learning even for a beginner, especially someone who's worked with web back ends. It might give him a leg up in recruiting too. I've personally never felt limited by knowledge of industry tooling. With the right guidance someone with understanding of the application needs can figure those kinds of things out quickly. The largest challenges for me have been high level application and service design, not really java specific issues.
With a nodejs background, I would learn vert.x instead of Spring. It's not as popular as Spring, but getting momentum, and so much closer to nodejs.
Although there are critics that can be made of the gradle model itself, it is just because maven is way more widespreadly used just about everywhere, whether inside companies or in Java libraries etc 
so pretty much cause if you land a job you're probably gonna use it ? I used gradle for android so was hoping it became more popular but I can get behind maven. Thanks
Basically, especially in the context of OP's question where it looks like it is an issue for home specifically due to the job market. Also won't get into the specifics of maven vs gradle here but I would not expect gradle to do well long-term anyway.
Yep, gross.
Very true what you say. Having experience with Spring is indeed a plus when it comes to interviews but bear in mind that a good interviewer may spot weaknesses in core stuff. I tend to review resumes and partake in interviews and I have interviewed people that have had experience with Spring (bear in mind junior devs) but had little understanding of OOP designs, the concept of DI and Inc etc. My main point here - which may not have been clear in my last comment hence the downvotes - is that I would not recommend to go ahead and straight up mess around with a framework before acquiring at least some base knowledge of the underlying tool stack. Frameworks are designed with abstraction in mind, which is good and beneficial since you don't want to reinvent the wheel each time. Thing is though that a framework such as Spring or Hibernate will hide essential underlying stuff. I am not saying that a beginner with Spring knowledge is going to suck just because they have invested time in learning it. What I'm saying is that a beginner who has ONLY invested in that area due to market demand is going to have a difficult time. My theory and so fat this has proven to be the case is to generally avoid people with little experience that claim they know a framework. It's best to have someone who will truthfully say that they know good basic Java since that person will be able to adapt (under the correct guidance) much easier to any development need. 
Yeah our spot was pretty pricey. Right in the centre of one of the trendiest neighbourhoods, 5mins to downtown on the streetcar (15 to walk it). Nothing was more than 50m from the front door (tram, supermarket, doctor, post office, pub) Anecdotally, I've heard that Dusseldorf (especially in that neighbourhood) is one of the more expensive spots in Germany.
I am really curious why gradle would fail long term ? Again, I know it's used for android and I liked the syntax, seemed easy enough (but that's about as much as I know about it)
95% of code blocks should be 3 lines at most. Really 1 line since java 8.
It does strike as being to ant what CMake is to Make. I.e. Yes it's better but there's a reason why nobody except C people use imperative build systems anymore. You end up having a build.gradle that is basically a project in itself. Example https://github.com/javafxports/openjdk-jfx/blob/develop/build.gradle Thus the biggest hurdle for it is that build systems should be fully declarative, which most already are, including maven. The one thing it has over maven is not using XML which is, indeed, quite annoying. But projects like maven polyglot https://github.com/takari/polyglot-maven will eventually emerge and I'd bet on some support for not-xml in the future.
In my current job they have a bean with 4 thousand lines of code in a single class. I'm planning to leave this hell...
70-75% is way to much, don't know where you got those numbers from. It's more like around 60%
1. Do a quick Java course so you can get your bearings. For IdE I would heavily recommend IntelliJ Idea. 2. Learn a build and dependency management tool (maven, gradle, etc) 3. Read up on networking in Java and how to setup JDBCs. 4. Create a clean web app of some variety. 5. Look around job postings and see what Tools they are using as this can influence the next step. Also keep in mind what object mapping tools they use (Hibernate, mybatis, etc) and also brush up on them if you have time. 6. Look up web development frameworks like Spring (esp. Spring Boot). The Spring Framework has a lot of other things as well but if you need to use them (eg. Spring Batch) you’ll probably be taught at work. 7. You can probably google your way from here. 
It went a bit over my head but thanks 
Sadly that kind of thing isn't uncommon. I worked at a place a number of years ago where the senior programming staff built much of a JSP application. They were all veteran FoxPro programmers. They just dumped pages of code, buisness logic, database calls, processing, presentation and all into the *.jsp files. 
I think that others (along with myself) believe that spring is a good idea because of the familiarity it offers a node back-end dev. That said, I have to agree with everything you just posted. Solid OOP and design principles are definitely more important than knowing where to throw some annotations. 
I've only done modern AspectJ in Spring, but it's pretty trivial to create a @LogMePlz annotation that gets passed a join and logs some output. Then you just toss the annotation all over the place. I prefer Lombok's logging annotations for sure.
I like the answers /u/CoderMonkey123 and /u/livrem gave you. I'll add an example. Violating encapsulation leads directly to putting responsibilities where they don't belong. And then you end up with garbage code like this: ``` public void payForGroceries(Groceries g, Shopper s, Cashier c) { Wallet w = s.getWallet(); if (w.getMoney() &gt;= g.getCost()) { w.removeMoney(g.getCost()); c.giveMoney(g.getCost()); } else throw new CannotPayException(); } ``` This is bad enough. What's worse is this code is then, over time, repeated all over -- except with slight variations, so paying for gas and paying for a restaurant meal end up behaving a little differently, and you end up with a few odd bugs. But there's even more. The users demand the ability to pay by credit card. First you have to explain to management why it's going to take six months to add the ability to pay by credit card. Then your team has to find every copy of the payment logic and update it to support credit card payments. But you make a mistake somewhere because all the copy-pasta was changed in slightly different ways, and now there's a subtle bug that isn't discovered for a year or five. Your classes want to be smart, and they love having responsibility for their own affairs. Be kind to them and you'll have a much easier time getting along with them. And when you want to get access to a class's data, think of this example and ask yourself if you would be okay with a cashier grabbing your wallet when you pay for groceries. :) 
 `null`
I'm too lazy to look at the source, but I believe valueOf in Integer and Long only cache 0-255.
&gt; it is recommended to create one instance per instance, and avoid the static part Err, why? Unless you've got a whiz-bang naming strategy that does something special for you? Or you're concerned about logging behavior at test time? Or just a general "statics considered harmful"?
"code smell" != "strict limit" Also, I didn't mean to imply that everyone everywhere should be following SRP rigorously. SRP is a guideline and not a hard-and-fast rule, like most other guidelines. *In general*, when I see a class that has more than a few public methods (outside of data classes and static utilities), it means that the class in question interacts with other classes in a way that is needlessly complex and indicates poor separation of concerns at a structural level. I'll be jumping for joy when the day comes when I express that concern and it turns out I'm wrong because the author has created a coherent, useful fluent interface. Until that day comes, number of public methods is a heuristic I'll continue to use when I'm scanning diffs for potential issues. 
Isn't that better than having to test if it's the "null object" of T?
The language itself is probably easier than JS at this point. However, it's the ecosystem that you'll have the most learning to do. Learn how Java devs typically work. Usually we use IDEs because the strong type system makes them much more useful than for dynamically typed languages. Learn a bit about build tools like Maven at least enough to be able to use and maybe slightly change a maven project. Then there are libraries. Depending on what you're working on there is likely a Java library or a framework of some sort. The basics are JDBC, Commons Collections, maybe Guava, JUnit and a bunch of others. Chances are you won't know most of them until you start working with them but you should at least have a bit of a play with the popular ones so you get a feel for them. Others mentioned already that you may need to work on your understanding of threads and the concepts around them like mutual exclusions, semaphores etc. You may not need it for a particular job but usually Java devs are expected to know these things as you're not always working within some framework that does all your concurrency for you. 
I'd fail this comment for line breaks. Let's get a coffee and reconvene in 5 minutes. 
That's one type of concurrency... but what about shared memory? Knowing when to use immutable objects is very important, something you don't likely do in Javascript.
Great list, thank!
A lot to look at. Thanks!
 synchronized (this) { ... Often the sign of someone who does not really understand threading and concurrency,
&gt;web development frameworks like Spring (esp. Spring Boot) I wouldn't have called Spring a web dev framework myself, I've always thought of it as an app-server, backend thing..
Also, read up so you understands the basics of Jars, the classpath, packages, etc. A little bit on the Jvm, mainly the heap &amp; gc. You can also look into concurrency, threading (Thread object), and locks (each object has a built in synchronization lock which you can use to create mutually exclusive sections of code). Also, learn how to go through a Javadoc and be comfortable with its format so you can pick up libraries quickly. Finally, and somewhat evidently, be familiar with the compilation process and type system Java uses. Generics is really cool and can let you make awesome reusable components!
Definitely this. Also ORM, Hibernate (Or the more recent SpringData) in particular. ORMs in Java are really powerful. Coming from Node they might look like black magic.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I feel like that jfx file is the perfect example of what not to do in Gradle (or any development tool for that matter) - "just because you can do something doesn't mean you should"
Use Checkstyle and either build before submitting CRs or enable dry builds in whatever CR tool you use, problem solved.
That's OK. I have experienced the opposite so I know it can definitely happen. I tend to make hundreds of highly granular commits a month. If your team is rigorous about requiring CRs there is simply no possible way to review that volume of change doing a CR per commit and/or not allowing opportunistic factoring &amp; cleanup alongside core changes.
I assuming he specifically means Spring MVC. I use Spring boot for a ton of stuff that doesn't have a web component at all, even desktop apps built with Javafx.
Okay, yeah, then he's being dumb. :-)
I'd say, skip Checkstyle and go straight for something like https://github.com/google/google-java-format or https://github.com/Salling-Group/sg-java-format
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
NPEs never show until runtime. They're unchecked. This hides it further behind the log level. It's the same as checking the log level before doing something. if (logger.isDebugEnabled()) { logger.debug(someExpensiveMethod()); }; Same as logger.debug(() -&gt; someExpensiveMethod()) The modern logger implementations I wish we would use fix this by making the logger arguments suppliers rather than just accepting a single one. logger.debug("{}", () -&gt; someExpensiveMethod()); Also the wrapper breaks the MessageFormatter, which is what interpolate in log4j. They've been using MessageFormat. #format which is different and had a different placeholder style.
You're right, sorry
The point of the "null object" is that you don't need any tests, you just call the relevant method.
Jib ftw. I used it in my last project, instead of Dockerfiles, and I'm super happy with how it works! 
Looks interesting! Has there been any benchmarks done on the resulting containers comparing their performance to a typical docker build?
Spring Boot is basically my bread and butter but the last time I've been exposed to Servlet internals has been well over a year ago. And it's not like there's much to learn about servlets. Aside from that; Reactive Web doesn't even use Servlets anymore. Same with JPA: the last 5 years I haven't worked on a single project that uses JPA. This is something he can learn on the job once he has the Spring fundamentals down.
Just wanted to comment that there are Java microservice frameworks very similar to those popular in JS. For example http://sparkjava.com/ and https://javalin.io/ etc. The reason I wanted to point these out is that trying things out in an unopiniated way is most likely better for learning than using for example the Spring boot app initializer. E.g. Start a maven project, add javalin, logger, template engine and mongo driver from their respective repos and you have a webapp structure up and running in no time and you'll see how things really compare to the JS.
OP doesn't need to bother with ORMs unless the job he is hired for uses them. There are loads of projects that don't use them. Having a solid understanding of underlying database fundamentals (and being able to write your own SQL) is much more important.
This is purely a technical concern. There are issues with static instances when you want to release them from memory (i.g. a container, or hot-replaceable code). The JVM won't do it correctly, which can lead to subtle leaks and sometimes your application not stopping correctly. If you use a logger factory, it will optimise the instance retrievable. But there will be a small overhead for classes instantiated often.
That's semantics. The principle being that methods should not be too long
It's not production ready, jib-core still experimental
What is the up to date Java HTTP(HTTPS) server equivalent to this new http client? Is it still com.sun.net.httpserver from java 6 i believer? Or are there other native options? And what are the most used and up to date Java HTTP Server Frameworks (Maybe splitted for small personal and for big enterprise applications)?
I feel like your CR rule should allow some flexibility. I agree that if a refactor will impact too many classes which may have nothing to do with the actual change, you should probably add a story on your tech debt backlog for it, but if you're renaming a poorly named variable, introducing a method, converting an anon-inner class to a lambda, etc then the refactor SHOULD be reviewed as part of the CR. Personally, I'm more annoyed when someone ignores a glaring problem when making a change.
In my case, it's one story per CR, and QA is able to test as many stories as they want to deploy. If there's a regression issue, it's a team effort to resolve it (among those whose commits were included in the build)
Or not. Aspects are hard to trace. It may make sense for a logger, but you know there will be a cowboy intrigued by aspects who will start adding random aspects and causing you much pain
Prefer this to just blatantly ignoring the fact that a test should even exist &amp;#x200B;
My most recent pet peeve - notBooleanValue. I've changed jobs a few months ago and find that one of the devs who's recently left always names his booleans in the negative `boolean userNotFound;` `If (results.isEmpty())` `userNotFound = true;` `....somewhere down the line...` `if (!userNotFound) //FUCK THIS GUY`
It's so flexible, it's not even a rule.
Please elaborate on setters/getters are evil
This indicates it's ready to go [https://cloud.google.com/blog/products/application-development/jib-1-0-0-is-ga-building-java-docker-images-has-never-been-easier](https://cloud.google.com/blog/products/application-development/jib-1-0-0-is-ga-building-java-docker-images-has-never-been-easier)
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I feel like building your Dockerfiles with a maven plugin is the wrong way to go; I would much prefer to use mvn to create a jar and build that into a Docker image with an external tool (i.e. a shell script). That said, Jib does a lot more than put a jar in an image. I haven't used it yet but would like to hear some impressions from folks who do.
No clue about the benchmarks, but concerning base image - you specify it in plugin configuration: jib.from.image IIRC...
Consider using a factory instead of a huge list of args. It's easier to understand what's being passed into the object. &gt; and if the code should only be executed in a single place, don't pull the code to a method. I disagree. If you're doing some wild stuff in 10 lines of code, create a method with an appropriate name so I know whether or not I should care about what's going on in there. I don't want to see a comment that could've been a method name. I do agree for the most part that hard limits on method, class and line length are more guidelines than laws. The reason it's recommended that you keep methods under a certain length is to encourage the author to consider what he's doing. Is the method doing more than advertised? Is there something else I could reuse? &amp;#x200B;
Same here
&gt;Premature optimization. "Why the hell did you do it this way, what the hell does this do? " "It's faster" "How much? How performant does this need to be? Are you planning to own this code until the end of time? Is this piece even relevant to performance? Can you at least leave some comments?" I've seen places where they did something super convoluted that saved less than 100ms when some other part of the code took a couple seconds, in situations where performance isn't important such as a nightly job that takes 2 minutes and runs at 11 PM. Yeah, this irks me. We have someone (a senior dev who has the ear of the CIO) who wrote his own http handling code for use by our SOAP clients instead of using any of the popular frameworks out there. It's not that he doesn't know better, it's got something to do with performance or a defect or whatever which was probably addressed in a minor release before he even completed writing the code.
Why the hate on PowerMock?
I disagree. Your classes will be extremely anemic if you follow this approach and you'll end up with a shit ton of "Util" classes to provide the functionality that should have been included in your model.
Is exactly the same issue as Java, do not mutate shared state. Java is a little easier to use immutable objects, but lets not fools ourselves, if high concurrency on the same machine is necessary, I would not choose Java anyway and consider Elexir, Scala or Clojure.
Oh it definitely is the example of what not to do indeed, and most small projects will not end up with such a messy build, but I can 100% see that kind of horror crop up in an entreprise project. Hell, even with maven being so annoyingly strict you still end up with parent pom projects etc. But then you are smart and tell me, keep it simple. Alright then, but once you take out the actual scripting capacity of gradle (which is convenient but we seem to agree that any more than almost none is bad), it ends up being merely maven without the XML. And that's not a long term plan for a product, because then if in a very unforseeable sequence of events maven 4 lands and supports some kind of DSL for poms, gradle basically lost all its competitive advantage.
Your options (in native Java) are still com.sun.net.httpserver or the more common [Java Servlets](https://en.wikipedia.org/wiki/Java_servlet) In java frameworks, for something small and quick to set up: [https://javalin.io/](https://javalin.io/) . It reminds me a lot of node.js's express framework. For enterprise usage, you simply can't go past [Spring Boot](https://spring.io/projects/spring-boot) . It's actually really quick to set up. Use [https://start.spring.io/](https://start.spring.io/) and it'll bootstrap you a project with sensible configuration. 
**Java servlet** A Java servlet is a Java software component that extends the capabilities of a server. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
I don't think your case is unique at all! Unfortunately the HTTP Client doesn't provide support for building multipart requests, which is annoying as Apache HTTP Client provides a multipart request builder by default. Have you thought about open sourcing the code you created to deal with this problem? I think it would be super useful. Or even a short blog post on how you went about it.
I am a french developer who moved to Germany a year ago. Salary averages are definitely higher than in France but the cost of living is higher too. But in the end, as a developer, you will earn more. There are some huge differences of salaries if you compare cities, sometimes a bit surprising. For instance, salaries are lower in Berlin than Munich and Hamburg. The average in Berlin for a mid level Java EE developer would be at least something like 60K gross. But I would recommend to move to more "traditional" cities for such technology, like Frankfurt am Main or Munich. Berlin has more a startup scene, focusing on quick-to-deploy but scalable technologies like Python or Node.
The Apache HTTP Client you mentioned is the apache httpd project ([https://httpd.apache.org/](https://httpd.apache.org/)) ?
Thanks for the detailed answer. I will definetly look into Java Servlets and javalin but i really have problems to get into spring. Im not a professional java programmer, in my job i mostly do SQL and Server Setups ,but i program in java alot as my hobby. For me Spring is this big magic blackbox with hundreds of modules which provide hundreds of possibilities and i just didnt find an entry point at which i dont need to know X other parts of spring already :/
This is the Apache HTTP Client I was talking about: [http://hc.apache.org/httpcomponents-client-ga/](http://hc.apache.org/httpcomponents-client-ga/)
Ah my bad i thought of the apache HTTP SERVER, thats httpd
It looks like in your [submission](https://www.reddit.com/r/java/comments/aq53en/everything_you_need_to_know_about_getting_started/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I completely understand what you are saying about Spring. Spring Boot is a nicer package around Spring, but it still has a learning curve. I think you'll enjoy using Javalin, it's a lot smaller and you won't have to deal with much black box magic.
I'll just leave it there https://github.com/GoogleContainerTools/jib/tree/master/jib-core
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I would still recommend learning spring. Spring MVC doesn't provide an explicit entry point you can control. Instead, you define methods in your code that handle certain URI patterns, and spring automatically routes requests to them. I've always been find of knowing the underlying technology rather than just relying on a framework. I can and have built a web server using just the Servlet API, and I've done the same thing using Spring. IMO Spring is worth the learning curve, it allows you to build you app so much faster and makes it far more maintainable by conforming to it's conventions. Just my two cents.
-128 to 127. It's specified in the JLS that all implementations must do this. OpenJDK can be made to cache higher values with a command line argument, but the lower value can not be changed.
I really like this idea.
The simple rule I tend to work to is lambdas should be a single line. Any longer and they should probably be a named lambda or a method reference.
Looks like I got my work cut out for me. Thanks!
Agreed. It might simplify things to a degree but it might signal to new Docker users that this is all Docker can provide. I feel like by removing the mystery of Docker it deprives users of its potential.
I feel like you can say that about any technology. 
To give a concrete example you might look at [good first issues at Terasology](https://github.com/MovingBlocks/Terasology/issues?utf8=%E2%9C%93&amp;q=is%3Aissue+is%3Aopen+label%3A%22Good+First+Issue%22+) (disclaimer: I'm one of the contributors). Sites like [up-for-grabs.net](https://up-for-grabs.net/#/filters?tags=599) provide nice collections of entry-level issues of many projects ;-)
Thanks for you input. What is the plain Servlet API? Iam at the moment learning about REST APIs, creating and using them in java and just using the Java 11 HTTp Client and the sun.net.HTTPserver, is that the servlet thingy?
it caches integers between -127 and 128 inclusive by default on top of the repetedly used integers outside that range. 
The distroless images is interesting as well.
https://www.eclipse.org/downloads/packages/release/oxygen/3a Why Oxygen, though if there are new and improved versions? :( Please do not tell me your school has a required plugin that does not work with a newer version...
Oh, also, the naive search approach simply worked for me: https://www.google.com/search?q=eclipse%20oxygen%20download. That's kinda the first thing you should try next time ;)
Wrong subreddit. You should have asked this in /r/eclipse. Nonetheless, the link is easy to find: Eclipse homepage -&gt; Download -&gt; Download packages -&gt; right side: More Downloads -&gt; https://www.eclipse.org/downloads/packages/release/oxygen/3a
The OCD crowd is winning the war, unfortunately.
The obvious place: [https://www.eclipse.org/downloads/packages/release/oxygen/3a](https://www.eclipse.org/downloads/packages/release/oxygen/3a)
In my last job we had several unmarshaller classes, one for every third party API response we had to read and convert to our standard response object. Those unmarshallers had one method, and only one method: doUnmarshall(Response response) The smallest of those methods had 2.000 lines. I think the biggest one surpassed 10.000. Not only did those methods perform like 20-25 separate tasks (which is a red flag in itself), but there were also code snippets repeated in every unmarshaller across the codebase (which is a red flag on fire). That was unmaintainable. I once had to add some small functionality to those unmarshallers and I spent three days because the code was almost unreadable.
Something like that, I’m not 100% sure to be honest. But it has to be Oxygen. 
You are possibly thinking of a Duff's device. https://en.wikipedia.org/wiki/Duff%27s_device It's a way of manually unrolling a loop for performance reasons. Modern compilers can do that sort of thing automatically.
Usually the best way to write performant Java is to write idiomatic Java, as the JIT optimises for that. (Also my new favourite call is `StringJoiner` which can replace many `StringBuilder` usages.)
You mean sprinkling `synchronized` around doesn't make your code automatically thread safe? /s
Not sure you are using the word "semantics" right. However, you have to tell someone a general guideline of what "too long" is and 1-2 screens is meaningless. A line count would be better. If you use a guideline of "1-2 screens" then that is going to mean something very different to someone using a 640x480 CRT screen and to someone using a 4K monitor in portrait orientation.
the big win gradle has is it's speed and incremental building. maven has nothing on that, and i'm saying that as primarily a maven user. DSL bloat aside, that's where gradle really shines. they have made serious leaps and bounds ahead of maven in terms of speed and efficiency.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Because it's the ultimate code/testing smell. Power mock is a crutch to test poorly written software. Sometimes there is no getting around it, but more often than not when you see power mock being used, it's to get around shitty programming. If you work on something legacy, totally understood. If it's a newer project, *why the fuck are you mocking constructors?*
Many of these other posts are great. However, you should look into getting at least your OCA in that time frame, and possibly the OCP. This will help give you a bit of a boost on your resume, and shows that you at least understand the basics of OOP in Java specifically, as well as, having the ability to read Java code properly. You may also want to look into geeksforgeeks or hackerrank for some practice in Java, there's also the java code ranch site for java related questions, along with open source java projects on Github.
I have the same question in mind, but I have no answer for you. But what I know is - if there is any such situation with Java 8, ie., when there is an issue with JDK 8 and when it is not present in JDK 11, Oracle may not release a fix to OpenJDK (I think). But folks contributing to OpenJDK might try to fix it in OpenJDK 8 branch. Amazon mentioned that they will try to address it.
&gt; Spring boot is the fastest way to get a web app up There are plenty of other Java web servers that can be spun up just as fast if not faster than Spring Boot. They also don't require all the annotation knowledge that might be less familiar to a node developer. You could argue they have to learn it anyway as many companies use spring. Frameworks like this would be more relatable to a node developer though. **Undertow** Undertow.builder() .addHttpListener(8080, "localhost") .setHandler((exchange) -&gt; exchange.getResponseSender().send("hello world")) .build().start(); **Spark Java** import static spark.Spark.*; public class HelloWorld { public static void main(String[] args) { get("/hello", (req, res) -&gt; "Hello World"); } } **Jooby** import org.jooby.Jooby; public class App extends Jooby { { get("/", () -&gt; "Hey Jooby!"); } public static void main(final String[] args) { run(App::new, args); } }
Except you better know those libraries in detail and know how to switch execution from one thread pool to another or you are going to have a bad time.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
No neither of those libraries are the Servlet API. The HttpClient is a tool for making HTTP requests to other sites. I'm not familiar with the sun HTTP Server but anything in a sun package is EXTREMELY old in terms of the Java ecosystem. I wouldn't recommend wasting time with it for that reason alone. The javax.servlet package is a separate library that falls (I think) under the Java EE umbrella. you can download the latest version for free, either directly or as a maven dependency. Servlets work in concert with a web server. The servers job is to listen on a TCP/IP port for any requests. When it received the request, it forwards it to the appropriate servlet based on the URL path. The Servlet itself is a simple Java class with methods designed to handle different types of requests. Whatever Servlets you create then need to be registered with the server so it knows how to route the requests. The problem with the Servlets API is it is very low level. Simple tasks, such as extracting parameters from the URL path or query string, serializing the request/response to/from Java objects, and restricting access based on various security criteria are all examples of things that require a lot of tedious boilerplate code to accomplish with the Servlet API. Boilerplate is more than just extra work for a programmer, it opens the door for additional errors in your application. This is why frameworks such as spring are so popular. They have done all the tedious boilerplate for you. Being that they are used by a wide range of Enterprise applications, they have been battle tested and proven to work extremely well. They have already thought of all the edge cases you may not be considering right now in terms of how they operate, and it's all ready to go out of the box for free. If you're brand new to creating web servers with Java, by all means learn the Servlet API. I think understanding your low level behavior only helps to be able to handle the higher level stuff in the framework, and this ultimately makes you a better programmer. However, I cannot stress enough that if you choose to build your app manually using the Servlet API you're just opening the door for a lot more pain and difficulty than you would get otherwise. Your codebase will be larger and more complex by virtue of the fact that you are reinventing the wheel for things these frameworks have already done. If you're dead set against spring, then at least use Jersey. It's a much lighter weight framework based purely around helping to expose web API endpoints. It's not quite as robust as spring, but it is light years better than trying to do everything yourself.
From FAQ : [https://github.com/GoogleContainerTools/jib/blob/master/docs/faq.md#where-is-bash](https://github.com/GoogleContainerTools/jib/blob/master/docs/faq.md#where-is-bash) &amp;#x200B; It uses Distroless Docker Images [https://github.com/GoogleContainerTools/distroless#distroless-docker-images](https://github.com/GoogleContainerTools/distroless#distroless-docker-images)
Thanks for that detailed answer. I think what im most struggeling with at the moment is the difference between webservers, HTTP(S) Servers and Application servers. I Want toc reate a REST API with various endpoints (resources) which an HTTP(S) client will call. I think i will need an HTTP(S) Server so i landed on the sun.net.httpserver, in my understanding webservers (which springboot, servlets and so on seem to be) and application servers are for other purposes. But maybe i just dont get the concept.
awesome stuff, thank you! will definitely try it out once I have a chance ((:
&gt; It must reimplement the method hashCode() which inherits from the Object class: if it is not reimplemented, it will use something that depends on the instance’s memory address. Therefore, two identical instances in data will have different hashCode values. Nitpick, it isn't the memory address but rather the object reference id. Java objects move in memory as the GC runs.
r/javahelp &amp;#x200B; [http://moocfi.github.io/courses/2013/programming-part-1/](http://moocfi.github.io/courses/2013/programming-part-1/) &amp;#x200B;
Too bad JFokus did not record more sessions
Ah, didn’t realise that sub was a thing. My bad. Thanks for the link! 
What do you mean? There are more on YouTube.
It looks like in your [submission](https://www.reddit.com/r/java/comments/aqazqi/career_advice_what_to_read_to_design_better_api/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
If you'll look at the agenda, you'll see that at least one track was not taped
The question being: When does an ArrayList stop being faster than a HashMap. I'm fairly certain that the overhead caused by the HashMap's creation is heavier than a sequential search for a very small ArrayList.
I think you have to look into the concept more. Look for information about deploying a Java application to Tomcat. Tomcat is the application container/web server that runs the app. What you are trying to do is not trivial. Again, this brings me back to Spring. If you're not a Java developer by trade, and you just want something that works, you should go that route. SpringBoot gives you EVERYTHING out of the box, including an embedded application server. It makes building all of this so much easier. Maybe it's scaring you off, but in the long run you'll have an easier time if you learn Spring.
Do NOT use the sun.net.httpserver. I'm not saying it won't work, I'm saying it's crazy old, likely not maintained, and is nowhere near the industry standard.
Yes. There are still more than last year, though. Maybe if we submit requests they will record them all next year.
I agree. I can only think this is primarily aimed at Java developers or for Java-only projects. A typical Java application will almost always talk to other services like a database, cache, mailer, the list goes on. You will need Dockerfiles for these anyway, so why introduce some additional magic facade that only Java developers will understand? With Dockerfiles we currently have somewhat like a standard that can be understood by developers and ops, and not just by Maven/Gradle guys. But as you said, Jib seems to be doing some additional stuff. It would be interesting to know, if the Jib's optimizations could be implemented with standard Dockerfiles.
What overhead are you referring to? The creation is not that expensive. All you need is an extra pointer indirection and the result of the hash function. `HashMap` will beat or at least tie `ArrayList` in terms of search.
With linear search, [on the order of a dozen items](https://github.com/commonquail/java-hashset-arraylist-contains-benchmark).
Ah very nice, I was looking for such a benchmark. Good to have factual information about it. We often deal with lists with less than 10 items.
I disagree with a blanket rejection of PRs that add TODOs. For example, I recently wrote a tool that sequentially processed a list of entries. I could have parallelised it to help increase our throughout but it would have doubled/tripled the effort and we don’t need the throughput gains right now. So I added // TODO Parallelize this and moved on to more important tickets. 
It is now in preview: https://aws.amazon.com/about-aws/whats-new/2019/02/amazon-corretto-11-is-now-in-preview/
There are also open addressed HashMap implementations such as Trove that use a single underlying array (for primitives, arraylist for generics). 
The main issue I had with nulls is when I get a string from some function call then try to compare that string with another string. `String s;` `s = calledFunction();` `if(s.equalsIgnoreCase("Test")) doSomething();` I would have problems here with null pointer exceptions until I realized I could turn the test around. `if("Test".equalsIgnoreCase(s)) doSomething();` No more null pointer exception problem anymore. &amp;#x200B;
My manager recently suggested that my lambdas would not be readable or maintainable (simply because he doesn't understand them). I haven't used anything more complicated than simple lambdas in stream filter and map, and only where it really seemed appropriate. The response they got on 'who likes lambdas?' was comforting. 
I probably am not allowed to do that, as all code I produce during work hours is owned by my employer. Suffice to say I implemented a small part of the multipart mime RFC.
I forgot to add: Java 11's HTTP client also does not perform zip and unzip automatically. You will have to read the contents and determine yourself whether unzipping is necessary. I noticed this because 1 third-party API server decided to serve GZ content despite me being very strict about accepted content types. (The server reacted completely oppositely to my request. Yay.)
Thanks. Are you on linux or windows? I've tried the download on a Centos and OpenSuse box and both give the same unsupported response. When I pull the build from [https://builds.shipilev.net/](https://builds.shipilev.net/) then all works as expected...
I was this manager a few years ago. I am really glad I didn't push back too hard because they are my favourite part of Java right now. 
I'm curious as to what your manager doesn't understand about lambdas. They're basically just syntactic sugar for an anonymous class implementation. There's some nuance beyond that for the technical side, but there's not much to understand
Why were you that way a few years ago? Did you not understand, or did you genuinely disagree with the feature? What changed your mind?
What's a distroless image? 
What's complex about it?
I’m on macOS.
HashSet outperforms ArrayList already at 4 elements. 
Did you mean Builder instead of Factory? I don't see how a factory necessarily helps reduce argument count.
Ehm. On what operation(s).
Was lightweight threading discussed?
I prefer IntelliJ IDEA. Other choice: Eclipse / MyEclipse 
I've also been this person, but more in an "Ugh, now I need to use that?!?", but right now I'm the biggest proponent of almost-functional programming in the team. * I've realized that a lot of people just dislike things they don't already know out of principle; it seems to be human nature. I'm not excluded from that set. * I would recommend reading Beating The Averages, specifically the section named "The Blub Paradox", it does give a name to something that you've probably felt yourself. * I've seen this happen in our team with RxJava (which uses lambdas a lot); it's ridiculously powerful and can really condense code - but the counterpoint is that that code section needs to be reviewed slower than non-rx non-lambda code if you want to understand it. It's still both faster and with less issues than if you would write the same code in a non-functional way.
The main benefit of Jib is smaller images. Personally I believe storage is cheap enough for that to not be an issue, but YMMV. Other than that I have been removing a lot of Docker plugins from builds; my builds stop with building a .jar typically. Creating a container image is a task for the CI/CD pipeline.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt; I've realized that a lot of people just dislike things they don't already know out of principle; it seems to be human nature. https://en.wikipedia.org/wiki/Neophobia
**Neophobia** Neophobia is the fear of anything new, especially a persistent and abnormal fear. In its milder form, it can manifest as the unwillingness to try new things or break from routine. In the context of children the term is generally used to indicate a tendency to reject unknown or novel foods. Food neophobia, as it may be referred to, is an important concern in pediatric psychology.In biomedical research, neophobia is often associated with the study of taste. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Yep, that's what I meant. Typing without thinking
Well i know its from around java SE 6, but what is the up to date JAva HTTP(S) Server component then said i should use? external frameworks also need to use some sort of native java http server in its base or not?
Ah, I've confused them before. It happens!
Perhaps it depends on what's being mocked. I don't want to test that Hibernate works, so I'm going to stub my entity manager. I don't want to know if some integration party is doing their job, I'm testing my work. There's integration tests that will cover those scenarios above.
Fibers? I think Mark mentioned it shortly.
And that they'd ship in N months?
/u/JavaSuck /r/hmmm
I have one, two colleagues that disagree(d) with the feature BECAUSE they didn't understand, but the reasons are manifold. I think it all boils down to the fact that change/evolution comes at a COST that most people simple ignore or deny that they exist... I had to invest half a day to explain functional programming aspects like lambdas, higher order functions, and then he understood it, but he still didn't like it. It takes time, we're all humans here. Anonymous objects and interfaces were known, so obviously my colleague was at higher speed using them instead of lambdas. If he would have learned lambdas instead of them in first place, we wouldn't need to talk about this topic at all, that's what he also learned now :)
I would have asked why we have not got operator overloading yet. I've been playing around with this in Kotlin and it saves soooo much code. I don't wanna hear though that it can be abused. Anuthing in the language can be abused. We just need a bigger toolbox and let the developers choose.
Very good question, I wish I knew the answer...
The one letter naming is confusing .. it could cause such issue and so i always use proper names inside my lambdas and it improves readability.
It looks like in your [submission](https://www.reddit.com/r/java/comments/aqi2zp/q_java_7_license_support_expiration_date/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
He talked a lot about them in the keynote. 
It looks like in your [submission](https://www.reddit.com/r/java/comments/aqi546/rounding_in_java_with_double/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt; I am having trouble identifying the meaning and between* Premier Support* Extended Support* Sustained Support https://www.oracle.com/support/lifetime-support/
Also serach the web for Mapped Diagnostic Context. It's VERY helpful when you log from multithreaded application and especially if multiple threads work on same problem or if you recycle same thread for various tasks.
I wanted to highlight how it feels to develop js web apps coming from a background as a Java developer, not completely sure if this is off-topic
You'll want to an application container/server like Tomcat or Jetty. Again this is where Spring is very useful, it comes with these things embedded in it. With a few small changes to a configuration file everything can be up and running.
This is a bad habit, I call it out on PRs. IntelliJ does a much better job of expanding to half decent variable names.
Application servers/Web servers are the next big black box. What do they actually do? They will need an HTTP Server basement too. What do they use for this and why cant i just use a "plain java" HTTPS(S) server?
Thank you for sharing! My road took me in the opposite direction, and I think many more developers will use both ecosystems. We will be helped with all shared experiences.
So you keep referring to black boxes. You're demonstrating an unwillingness to really put in effort to learn how all of this works. Yes the application server has an HTTP server component, but I would recommend tomcat and jetty because they're actually being maintained and support modern web standards. They are what major Enterprise companies actually use in their applications. You came here looking for answers on how to build your app. You're getting them. Everything is a black box to you because you have put no effort into actually learning them. This is how Java web apps are done. You use Servlets to handle requests, delegate to your business logic, and deploy everything to your application server. You use frameworks like Spring or Jersey to reduce boilerplate and allow you to build your app faster on a more stable foundation. You can keep calling everything "black boxes" but that's just doubling down on your own choice not to take the time to actually LEARN how to do this. If you want to build a Java webapp, this is the way to go. This is the way that everyone else in the industry does it. Programming actually requires study and work, you know. So feel free to continue complaining about black boxes. I won't be responding to any more comments where you use that as an excuse. If you actually want to learn something, I would be happy to continue to help point you in the right direction.
Either you completely missunderstood my comments above or you just dont want to give the answer because "its the way its done". I want to understand WHAT this frameworks/servers do, HOW they do it, WHY i should use them and WHY it is industry standard. Before im using external non java standard library frameworks/tools i want to know the answers to the questions above. &gt;Yes the application server has an HTTP server component, but I would recommend tomcat and jetty because they're actually being maintained and support modern web standards. They are what major Enterprise companies actually use in their applications. The Java standard library also is maintained. What do these servers do better and why should i use them instead the HTTP Server Options in the Java standard library itself? &gt;You use Servlets to handle requests, delegate to your business logic, and deploy everything to your application server This is a conecpt i cant wrap my head around. I read alot about it but what does the application server actually do and why do i need it? Why cant i create a java program with java standard library which i will execute with lets say java -jar and it produces the same result? &gt;You use frameworks like Spring or Jersey to reduce boilerplate and allow you to build your app faster on a more stable foundation WHAT Boilerplate code will be removed? Programmers which grew up with java will probably know it, but newer ones like me just get tossed X Frameworks on "here use that its better" Why? "Its industry standard" But what are my benefits for needing an external framework? &gt;If you want to build a Java webapp, this is the way to go. This is the way that everyone else in the industry does it. Thats not answering the WHY and HOW does it work deep down. Im willing to learn. But what i cant take is a framework/server which i dont understand or understand how and why it does something and then make it the basement of my applications. Even the Reference Manuals of these frameworks itself dont properly say what, why and how they do it. They just show how to use them. but i want to know whats happening inside them to really understand why its a good idea to use them and most of all to know WHAT my code does.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I would say moditect as maven plugin handles this usecase very good. 
I use both ecosystems myself, and regarding your point about main thread or event loop blocking in JS, have you tried clustering or using the new worker threads functionality for concurrent processing? To my knowledge, this still seems alien to most JS devs, including things like the BigInt primitive, but it’s an important development in the language.
https://golb.hplar.ch/2019/01/java-11-http-client.html#upload-with-multipart is the one example I could find for multipart uploads. It simply creates a byte array for the input which could be problematic for huge files.
As far as I can tell, we're going to be waiting awhile to take advantage of JLink in anything larger than POCs. Modules really need to happen from the bottom up, and that's going to take awhile (years) given the size of the dependency tree for most Spring apps. I hope I'm wrong though. I have seen some hacks where people create modules in their third- party dependencies, but no way me/ my team is taking that on.
Do your own research. There are plenty of helpful guides out there. I'm an entirely self taught engineer using purely the documentation available on the web. I'm not going to be a crutch for your laziness. I've given you all the answers you need. Research the tools and actually learn something.
&gt; They're basically just syntactic sugar for an anonymous class implementation Technically they are not. There is not any hidden anonymous classes. If I'm not mistaken there is some invokedynamic magic under the hood. 
Thanks for the write-up. I'm in the same boat myself. My company is looking for a java alternative due to licensing fiasco. Have you tried using typescript with nodejs?
No i haven't tried clustering, i'm too new to js back end development! I'd like to test an experiment in the future: running the same webapp via GraalVM and see if it is possible to comfortably develop a js application and easily interoperate with java classes like BigDecimal. If the mixing of the two world results in something workable then i think there will be great opportunities.
Yes. I think the easiest path is from java ecosystem to javascript one, but it can work the other way too. Since you come from js, how does it feel web development in java in comparison with js?
right. the traditional ```new Runnable()...``` will be invoked using the invokestatic instruction, and ```() -&gt; ...``` uses invokedynamic. But ignoring that difference, a Functional Interface is just a Single Abstract Method Interface. The lambda is the implementation of that interface. We've been doing the same thing forever ```new Runnable() {...}; new Function(){...};```, it's just that the syntax has gotten cleaner. Conceptually, they are the same. stream.map(new Function&lt;FROM, TO&gt;() { TO apply(FROM from) { //interesting logic to convert FROM -&gt; TO } }).collect(toList());
No, i've been using es6. I must admit i love java static typing but i think that for web development dynamic typing is definitely acceptable. If i should do something different and more "enterprisely" i would still use java (as i did for the crypto exchange i developed in 2018). If you must evaluate some new languages i would suggest: 1. GO if you need to develop a lot of microservices and need extreme performances 2. Python if you don't need high performances and need to do web development and/or may need to integrate with ML libraries 3. JS if you need web development and good performances or scripting capabilities In general i think that if you come from a strong Java background you can approach all the other languages without too much headache since Java (and all its libraries/frameworks) is exceptional but it's one of the hardest one to learn and master 
I guess because I'm a glutton for punishment I'll give you some more info. ** Tomcat, Jetty, &amp; Application Containers ** These are used because they handle all aspects of network connectivity. It takes the process of actually listening to ports, receiving requests, sending responses, etc, our of your hands. They are industry standard tools, they work extremely well. If you want to re-invent the wheel yourself because it makes you more comfortable, go right ahead. You'll be the one suffering because of it. Basically, these are your HTTP Servers right here. They have done everything for you. They are the product of dedicated teams of engineers working on this one problem, and they've solved it better than you or I will. ** Servlets ** This IS the standard Java way of doing it. The Java Servlet API is not a third party package (although it is now maintained by the independent Jakarta EE group, it was originally maintained by the folks behind the Java SDK). Servlets receive the HTTP requests and allow you to write code in response to certain requests. Once you have written your app with your servlets, the standard Java approach is to add a deployment descriptor (web.xml) with your .war file that maps your servlets to certain URL patterns. The application container then knows how to forward requests to your app using that configuration file. ** The Old HTTP Server ** You're seriously considering using the com.sun HTTP Server component? This is a super old Java component that no one else in the industry is using. If you think it's better for you, go right ahead, but willingly choosing to use outdated technology, especially for a webapp, is a design decision I just can't wrap my head around. Moreover, this is a part of the Java SDK that the folks are Oracle are not developing for and are warning folks that they may completely drop from future Java versions (https://www.oracle.com/technetwork/java/faq-sun-packages-142232.html). So it is not something to use for any modern app. ** Why Can't I Execute It With Java -jar ** Depends on how you create your app. Tomcat is a fully external application container, so you'll have to create a .war file and drop it into the Tomcat application "webapps" directory. Jetty, however, is a Java-configuration solution. Using Jetty, you would configure the server in the Java code called by your main method, and start the server that way, so you can use Java -jar to start your application. ** What boilerplate code do frameworks reduce ** This is such a loaded answer I could not possibly fully answer it here. So let's just give a few examples. Servlets can be challenging to maintain and have key limitations. The mapping of your servlet to a URL is based on an extremely limited pattern matching format. To handle arguments in the URL path or query string, you need to write code to manually parse and extract them. When dealing with the request and response bodies, when working with Servlets directly, you need to manually convert your data into the format being sent/received. For example, if you're building a JSON API, you'll need to either construct the JSON manually, or else configure your own way of serializing content to/from JSON. A simple framework like Jersey solves all of these problems. Basically, it lets you write POJOs (Plain Old Java Objects), with simple method definitions. Then you apply annotations to those methods, and Jersey will call them in special ways. Query string parameters automatically get extracted and passed in as normal method parameters. You can use normal POJOs as your request/response body, and Jersey will automatically convert them to/from something like JSON. It gets the plumbing of doing the web operations out of the way so that you can focus on writing your application. Spring does all of these same things as well, and it does them in a more robust way in my opinion. It also provides a plethora of other tools as well. Want to configure your application with properties? Want different properties for different environments? Spring provides a simple configuration tool out of the box that lets you just write your properties files, and then reference those properties in your code, relying on the framework to instantly give you access to your configuration. Want to work with databases? Spring will handle your transaction management, commit/rollback behavior for you with sane, sensible defaults (ie, commit if successful, rollback if exception) without you having to do anything. Spring JPA lets you minimize the amount of SQL you have to write, allowing you to work almost entirely with Java objects. If you prefer SQL, SpringJDBC provides tools for executing SQL queries that require writing far less code than the normal Java JDBC API. It also provides tools for connection pooling out of the box, so you have all of that available to you effortlessly. Want security? Yes, you can do security using normal Filters in the Servlet API. Spring provides a whole Security module, however, which has been battle tested across thousands of enterprise applications. Rather than building your own security rules from scratch, you can use tried and true mechanisms that are the product of teams of engineers whose sole focus has been to build a great security tool. (PS. I will admit that while Spring configuration, especially with SpringBoot, is usually really easy, Spring Security can be quite convoluted to work with. It's worth it though.) So why use a Framework? I mean, that's like asking why use Maven when you could just use Ant to build your application. It's convention over configuration. Build your app the way the framework wants you to, and you benefit from writing less code and creating everything on a more stable foundation. PS. If you don't know what Maven is, then you've got a lot more to learn about the Java world before you even begin trying to build a webapp. ** Conclusion ** This is it. I'm literally done responding now. If you still have questions, do some goddamn research on your own. There are so many resources out there. Don't whine to me that the documentation or resources out there isn't good enough. I've learned every single thing involved in this stack on my own, using the documentation and tutorials and other tools that are out there. Hell, there are tons of free courses and "code with me" videos for all of this stuff, FREE content, on YouTube. There is literally no excuse for going around calling everything a "black box" and using that as justification not to learn things.
Thanks for that really detailed answer. Much of this i already know, but you gave me more insight. I think my main problem is to accept that using these frameworks leads to me not really knowing what is happening. I add an Annotation to map the URL to this method and it just works. Its really nice, but i dont know why it works. Of couse i understand on why to use them. But answering to ppl who want to learn how these things work "just use them cause the whole industry uses them, they are from genius ppl and proofed themselfes" is the wrong answer. i know that i want to dive deeper. But your reply helped me.
How about Ratpack. We use this is it's based upon Netty (very async): public class Main { public static void main(String... args) throws Exception { RatpackServer.start(server -&gt; server .handlers(chain -&gt; chain .get(ctx -&gt; ctx.render("Hello World!")) .get(":name", ctx -&gt; ctx.render("Hello " + ctx.getPathTokens().get("name") + "!")) ) ); } }
Spring is definitely not a mandatory thing to know, even for professionals. I understand what it does, and choose to not use it in my code because I don’t like the auto-magic design, the heavy dependency risk it introduces, and the heavy difficult increase in debugging, for the marginal benefits it brings. Spring boot is occasionally the smart way to go, but seems like it would be a dev-ops nightmare. Instead of managing a pre-configured application server, they now need to deal with more auto-magic black-box software in the embedded servers. For example, if there is a security vulnerability discovered, you probably need to rebuild all of your apps to address it. It takes that work away from ops and puts it on to development for no significant benefit. Spring boot is like DLL hell in all the major ways (and yes makes things easier at first in both cases)
My own experience in doing that was that the Java ecosystem these days is all about Spring magic. The type system didn’t bother me at all, and good programming practices such as exception handling are transferable wherever you go. But NodeJS is somewhat of a everyone-is-a-cowboy-doing-stuff-from-the-ground-up world since it’s a lot younger than JEE/Spring, so I was far more used to building the guts of my web app instead of having everything hidden behind annotations. Node core’s http class gives you the power to very easily build a web server without having to automatically reach for a sledgehammer like Express. It was also very obvious that asynchronous programming and first class functions was something that Java still has yet to deal with well. CompletableFutures sound much more powerful than what JS offers until you start having to deal with exceptions and then suddenly you realize that JS promises and a async/await gives you exactly the right tools for that sort of style (by that I mean you can of course solve the same problem in Java, just not by mapping promise-style programming to CompletableFutures one-to-one). But the Java experience has also fed into my JS knowledge. For example, the static typing and serialization mechanisms in Java can actually be used to vastly improve the speed of JSON.stringify (there’s actually a npm library that does this now... heh) Obviously there is a lot more to this since I’ve been in both ecosystems for a while now but that would be enough for an entire talk. Lol
Maybe a little off-topic, but when I am looking for a new candidate, I get them to create a simple REST api web app. But the kicker is that I specify NOT Spring/Boot. I want to see if they can pick something else up quickly. I my opinion, Spring hides too much. I've had candidates that only know how to wire up annotations and when outside Spring, they have no clue what to do. Just a thought to keep in mind when choosing what tp learn.
I’m not sure if mixing JS and Java will ever be a good idea. Check out the N-API if you’re familiar with C++ as well. It’s for interop with C++ modules (some cpu intensive modules like bcrypt are built like that). That route is far more pleasant than working around all the logistics of the JS-Java language barrier.
[removed]
java != spring. there are plenty of alternatives that are not Spring Boot giant magic boxes. 
Sure, definitely, but imo in the java enterprise context, Spring eco system is the dominant leader due to the significant rich amount of projects and libraries that are integrated one another.
This is exactly what I use. I was able to move everything into our production Jenkins without any issues. It's better to use moditect than to just write a bunch of Jenkins scripts that do it via cli. The samples on the moditect site are decent but I couldn't get it to completely build all steps for my project the way I wanted it done and for each jdk/platform. I still had a bit of shell stuff to tidy it all up in the end, but it did make modular jar management very easy. 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
So wrap static calls in a facade class and use mockito. If you're mocking static, it's because of bad design (whether your own or a dependency of yours). Sometimes you can't get away from that, but in general IMO you should be going "do we really *really* need to use PowerMock here? In almost all cases I find that the answer is no. There are some cases, but IMO it's a bad thing. I compare Power Mock to something like using spring xml for all of your DI. It isn't the end of the world if you do it, and it will work. It's just pretty shitty and makes it easy for future developers to fall into traps, write unmailtainable code, etc. I don't love hibernate either though. Every package I've seen that has used hibernate has been a gigantic mess if random properties files, janky Spring integration, etc. Granted I work for a large company that has *a lot* of Java, so I'm probably just jaded at this point. So to me, PowerMock is adding needless complexity to a project unless absolutely required. If someone puts out a PR adding PowerMock as a dependency, I push back hard. 
I manage a widely used OSS project. We have no plans to modularize anytime soon. There's simply no benefit. Also, it's Catch-22. Until our dependencies modularize we can't benefit from doing it ourselves.
Operator overloading is one of those things that causes more problems than it solves. I spent 10 years writing C++ and never want to go through that again. That said, Java has always had limited operator overloading (string concatenation, etc.). So, if it's severely limited it can be OK.
ModiTect author here, just came to suggest the same, but you beat me to it :) For those interested, it's this project here: [https://github.com/moditect/moditect/](https://github.com/moditect/moditect/). Adding module descriptors for using existing JARs in modular runtime images was the very use case for creating it. That all being said, you also could create a runtime image with just a subset of JDK modules and then use existing JARs on the classpath instead of the module path. I.e. there's no need to patch the JARs, but identifying which JDK modules you need to add to the image can be a bit more work. There's an issue in our tracker for this ([https://github.com/moditect/moditect/issues/69](https://github.com/moditect/moditect/issues/69)), so to let ModiTect help with this use case, too. Any help with implementing it will surely be welcomed :)
OpenJDK already has its own AOT compiler though it can't handle classes loaded by custom classloaders. However you can run Spring Boot applications with all dependencies on the classpath and this way OpenJDK AOT can (theoretically) handle Spring Boot applications. And there is also GraalVM native image tool that can't deal with Spring Boot so far.
Goetz was asked about operator overloading [here](https://www.youtube.com/watch?v=jDU-JALUDd0&amp;t=23m45s). Gosling originally had it in the language, but some felt that it can lead to unreadable code, so it was removed.
what alternatives? I've seen more hand rolled alternatives in the wild then marketed alternatives that people actually use. \~cringed\~ when they were so similar to spring needed to be updated inHouse with no support from a larger community.
Curious what issues you ran into specifically. Perhaps file an issue in our tracker with feature requests? Thanks!
I am just saying that when you want to compare nodejs development to java, reaching for spring would not be the route I would have gone
yeah in enterprise for sure it is the most dominate. &amp;#x200B; But if we are comparing java development to nodejs development. I would have tried to pickup something lighter, like spark - which models itself closer to what express does instead of reaching for spring
Indeed if oracle want jpms to succeed they need to make the gain more appealing and imho jlink is one the real improvements as it could bring a simpler and cheap deployment option. Unfortunately it is too young to use.
I always recommend dropwizard, it's just Jersey/jetty/Jackson and it's own metrics library for production which is awesome and some glue to setup all this together. It also introduced me to jdbi which is the best "orm" I've worked with. 
You can still use jlink to generate a runtime that cover your application and dependencies, **you just won't be able to generate an image of the jdk that include your application and libs with that image.** If your dependencies can all be run as modules or automatic modules, just generate the jdk image you need by using something similar to this: ``` jdeps.exe --print-module-deps --module-path .;modules *.jar ``` After testing your application, you might see that you need additional modules that jdeps didn't detect. For example, in my case I also add the following modules: ``` jdk.unsupported,jdk.unsupported.desktop,jdk.crypto.cryptoki,jdk.crypto.ec,jdk.jsobject,jdk.xml.dom,jdk.charsets ``` You can then use jlink : ``` jlink.exe --no-header-files --no-man-pages --compress=2 --strip-debug --add-modules java.base,java.net.http,java.prefs,java.sql,java.xml.crypto,java.compiler,jdk.unsupported,jdk.unsupported.desktop,jdk.crypto.cryptoki,jdk.crypto.ec,jdk.jsobject,jdk.xml.dom,jdk.charsets --save-opts jlink.txt --output runtime ``` You can then run your application with this runtime and your jars in a specified module path 
Thanks for your work on Moditect, First time I am hearing about it and I will have a look for sure. Creating a partial runtime is not worth it in my case as only 2 - 3%of my dependencies comes already packaged as modules. This bring additional work for little to no value.
The sad story is that I totally gave up on jlink for the time being at least. Reducing binary size vs effort of patching the whole world is easier. Running using modules rather than the classpath is already hard enough as is (but sort of manageable in small apps)
The value is being able to ship a (for example) 25MB runtime and not a 300MB one.
From where are you downloading? Perhaps I'm getting JDK builds and not OpenJDK builds. Thank you.
jdk.java.net
There's a link from the OP link to it. Basically it is a stripped down operating system providing only what is necessary to run the application. It leaves off things like shells or package managers, etc. anything not required for just the basic operating system and the application itself. 
With the mistrust of Oracle right now, trying to get people using GraalVM is going to be hard.
You don't. Applets have been deprecated for years and are no longer part of the JDK. 
I have been thinking about the same thing. 
Typescript feels more like writing Java than Javascript. This might be because classes allow for better modularisation than ES5 does. I can't remember when classes were added to JS (oh ECMAScript 2015). 
what?
Huh, I could've used this at work. Too bad it's in video form instead of text so I won't look at it.
You can use the [text version](https://vladmihalcea.com/books/high-performance-java-persistence/) if it works better for you.
deprecated since Java 9 if I recall and removed recently. 
Thank you!
Enjoy reading it!
I'm downloading from the same site. I get the same "Shenandoah not supported" on macos as I do on Linux.
Applet API is still part of the JDK. You can load any applet using URLClassLoader and custom java.applet.AppletStub then display it in a JFrame ;)
lol sorry let me explain..there's a website that uses java applet for me to download files. This site is safe since it's through work. If there's any shortcut I've created for a file; IE a text file shortcut, I delete this file and leave the shortcut. Everytime I try to download something off the website java applet prompts me to look for this file since there's a shortcut created for it. Does that make sense? Yes it's confusing to me as well and why would java try to look for the file I've created a shortcut for that has nothing to do with what I'm downloading off a site. 
That doesn't really help if you can't display it in a browser though. :)
[Here's the documentation for Panama JDK](http://openjdk.java.net/projects/panama/). I didn't know what it was and had to google it.
No. GraalVM is a Java VM which is designed to allow other languages to be implemented on it. Panama is the project to improve calling non JVM code from Java and the JVM (think a massively improved JNI).
I see. Thanks!
As with everything, blanket statements don't always fit everything, but considering that in most case, a rejection means starting a discussion about *why* (How is your colleague supposed to fix the problem if you don't tell them what the problem is ?) the merge request was denied, the point you're raising can be addressed in said discussion. And also, in the case you're describing, wouldn't it be more productive to push your code without the // TODO and then create a ticket about the parallelization task (with a low urgency, since you said you had more urgent tickets to deal with) ? If there's a TODO that's not mine in the code base, the first thing it does is pollute my task-list, and then, I don't know: 1. If the task has to be dealt now 2. If someone is already dealing with it Now, sure, you can add it in the TODO comment. But now it's not just "parralelized this" and with all this info, it does warrant a ticket (even if with the lowest urgency)
You can't make native binaries with OpenJDK. You have to use another tool like GraalVM, who's licensing leaves a lot to be desired
Is it more than just a tool to generate the JAR file with all C types ported to Java type comparing to the Java Native Runtime used in jruby (https://github.com/jnr/jnr-ffi)? I'm very excited to see the how the Panama project is progressing.
To clarify, it's in preview: https://aws.amazon.com/about-aws/whats-new/2019/02/amazon-corretto-11-is-now-in-preview/
Ugh
Thank you dude, you are a worthy hero and a Java Champion, just visited your website and it was really good.
/r/javahelp is for programming questions, /r/learnjava is for learning related quesitons, /r/java is for "News, Technical discussions, research papers and assorted things of interest related to the Java programming language"
While I don't share the mistrust, I agree. Graal is a hard sell. It is an impressive piece of tech but the fact that there is already a CE and EE edition with performance differences makes it hard for me to totally trust it.
That's what it sounds like -- just an API wrapper generator for a native DLL/SO library. I'm kind of curious about whether there would be any performance benefit as compared to rolling your own JNI wrappers, especially for OpenGL; probably not, since this sounds like all it is really doing is performing that step for you.
I'm not trying to diminish what Amazon is doing, this is a legit question: Should I as an individual care? Do I have an advantage using this over OpenJDK?
It works a lot differently than JNR from what I've seen so far, and I like the changes. Unfortunately, I may have hit a bug in it already (though, it seems like wayland is written in a particularly nasty way and has been giving me trouble for a while with JNR too).
Did they have an internal contest for "Pick the lamest name possible for our JDK distribution"?
As far as I'm aware, the advantage is that Amazon will have packages for this for Amazon Linux. With OpenJDK you'll have to manage it yourself.
Interesting question, one I would love to hear the answer to. The main concern with the Oracle-backed JVM(s) is long term support, and this is bigger concern to enterprise then to the individual. I feel like this is more addressing the big companies with multi year roadmaps and finite resources then it is to the indie developer.
My understanding is that Amazon will provide packages in the Amazon Linux package repo for Corretto 11, something they don't seem to be doing for OpenJDK 11. As an individual it probably is not a big deal but if you're running more than a couple cloud hosts it's so much easier to do `sudo yum update` than deal with trying to update binaries all the time.
Just looked it up: &gt; [Caffè corretto](https://en.wikipedia.org/wiki/Caff%C3%A8_corretto) (pronounced [kafˈfɛ kkorˈrɛtto]), an Italian beverage, consists of a shot of espresso with a small amount of liquor,[1] usually grappa, and sometimes sambuca[2] or brandy.[3] It is also known (outside Italy) as an "espresso corretto". It is ordered as "un caffè corretto alla grappa", "[…] corretto alla sambuca", or "[…] corretto al cognac" "corretto di Spadino" depending on the desired liquor. So, some Java with a twist?
Not if you are on Java 9 or later
Can you get through goggle's "I'm not a robot" checkboxes?
I think this is really good news. Oracle is trying to monetize Java, and that's a huge turnoff for developers and many businesses alike. The openjdk initiative is super-laudable, but it may fall short for some in terms of just the usability of their site, and the feeling of being backed by serious people with serious funding. That leaves Java kinda in no-mans land, strategically. So Corretto is to me a sign of commitment from Amazon to Java. Amazon AWS is well trusted for maintaining their competitive edge and using an open pricing structure, constantly reducing prices and not strangling their customers, like Oracle does.
Oracle and Sun have always monetized Java: through licensing for mobile and embedded devices, through selling commercial features in OpenJDK, or through that annoying search bar. Now that Oracle has concluded open sourcing the JDK, it's changing how it funds Java development. But Oracle is the company that contributes the lion's share of OpenJDK development. [Here's the breakdown by company](https://blogs.oracle.com/java-platform-group/building-jdk-11-together). (I work at Oracle on OpenJDK) 
co-founder: "Yeah, let's do the backend in Java." co-founder: "Do you think we'll be okay with OpenJDK? Why not just go with Python or Javascript? We'll never need to worry about paying royalties to use those." co-founder: "hmm"
Royalties? OpenJDK is 100% open source.
I would've expected JetBrains to have a much bigger impact. I feel somewhat disillusioned. But then, the article doesn't take complexity of the resolved issues into consideration; which raises the question: "How much do they care about the continued development of the language?"
Or some Java that makes you addicted when you're overdoing it and may kill you when you stop using it suddenly and without supervision. ^/s Okay, okay, I'm seeing myself out; stop kicking me 😁
If you take the complexity of the issues into account, Oracle's relative contribution only grows. [Here](https://youtu.be/W-l0Huhb40s) you can see an overview of the breakdown of JEPs (enhancement) in JDK 9, 10, 11 and 12.
Thank you very much for providing the insight.
To be fair, modules do have benefits outside of the whole custom runtime mechanism. The strong encapsulation can be very beneficial when designing a library.
Thanks. I'm glad you liked it.
...but wasn't spark abandoned?
Have you tried jOOQ yet for SQL? It's fantastic.
http://openjdk.5641.n7.nabble.com/how-to-use-IcedTea-web-in-IE-Internet-explorer-on-windows-td343552.html tl;dr IcedTea-Web has a browser plugin that works old versions of Firefox, not Internet Explorer.
I think many of the Java pain points are self inflicted or outdated. Some libraries or frameworks use a lot of memory but that isn't Java's fault. Java also gets a bad reputation for memory because people abuse ORMs and are too lazy to write more optimal SQL queries. This makes them pull much more data than necessary in memory. Interfaces, why does everyone put an interface on everything? This isn't a requirement just something people were taught in school. There are plenty of libraries and frameworks that are not littered with interfaces. I write a java blog where I break a lot of standard conventions to get better developer productivity and I find it to work pretty well. I did have to do a little work to wire up all the libraries but I feel like even with spring boot you end up making many of the same customizations. * I use lombok for less boilerplate. I'm not super happy about it but it can be replaced in a few years when Java rolls out data types. * I don't use interfaces unless I actually have multiple implementations * Most of my code is static functions that can be easily reused. Why require a DI framework if I can avoid it. It would also be easy to use a DI framework though if that is your preference. Here is a quick [example api](https://www.stubbornjava.com/posts/lightweight-embedded-java-rest-server-without-a-framework) The live blog (admittedly it doesn't do a whole lot, ~700 hits a day and everything is loaded in memory) uses less than 30MB of heap. https://stubbornjava.grafana.net/d/sYu06dviz/stubbornjava-overview?orgId=1
It's not just long-term support. The free [Oracle Java SE License](https://www.oracle.com/technetwork/java/javase/terms/license/javase-license.html) only allows development and testing and explicitly prohibits production usage. If you want to use the Oracle JDK, you must pay Oracle for a real license. This affects anyone using the Oracle JDK. My advice: don't. Switch to Corretto, AdoptOpenJDK or Zulu.
Try to find how to install icedtea. Its been a while since I’ve used for anything, but might be worth the shot.
Another nice benefit is now your data access classes can be package private so only the service level classes in that package can use them. This forces other code to be using your services instead of randomly using the data access classes directly.
Just what we need, smarter spam
~~spam~~ scraping
What about SAML? I see this used a lot and would imagine spring security has some type of implementation of it?
You should try Koa, it's made by the same ppl behind express but it's all async, also try objection js for the orm part, sequelize is OK but kinda annoying sometimes, I know that coming from Java you feel like you are used to the orm and you need something like hibernate, but you should try objectionjs, it's really nice
I haven't really looked into it and I'm not aware how the check actually validates if you are human or not. I thought the idea was to just filter out headless browsing (e.g browsers which don't even have a mouse). Underlying mouse mover in NaturalMouseMotion is java.awt.Robot, but if you need you can switch it to something custom.
&gt; that's a huge turnoff for developers and many businesses alike. What's a huge turnoff is NOT the fact that Oracle is asking for money with hand out. This is to be expected. But they're not making this work appropriately visible. I mean, yes, they're not hiding it. I suppose anyone can go figure it out for themselves through source and the like, but they're not PROMOTING it. Since it takes work to figure this stuff out, it doesn't see the light of sunlight. Instead, they've put together a flotilla of lawyers and self-important executives who execute on clauses in the license terms and bring clients to heel through force. THIS IS NOT THE WAY TO BUILD A COMMUNITY! What this will do instead, is bring the focus to many other players, and they will make many promises. But, I notice that nearly all of those names are missing from the list of major contributors. Given that, what REAL support can they really provide? Yeah, not much beyond tribal knowledge. Real engineering insight is likely to be absent; just corporate indemnification style promises. In the meantime, the real work is getting done by Oracle. Once all of that plays out: that is, Oracle doing the lion's share of the work, not feeling the love, and finally disenfranchising the market to the point where it all migrates it all to other "independent" players, they will finally starve the product of its needed maintenance. And then the real shit show will begin... maybe there will be a hero in this ensuing mess. It's likely that a significant portion of new development will simply migrate to something newer, cooler, and with less significant baggage.
Supervision == paycheck. You don't need to be seen out. You're simply not being served anymore. You'll do it for us. :P
Or just use OpenJDK. Coretto does the same thing than all other distributors: assambling the OpenJDK with another nam
Oh jees, I kinda realized I was on thin ice when I clicked submit on the comment, and I’d totally forgotten about the horrible search bar. But in a sense I stand by my comment, not because it’s fact, but it represents what most people are actually thinking and feeling. I feel like Oracle could have handled this transition much much better, and done more to communicate the greatness of openjdk. And the net result is that perception-wise, Java is in a weak position. That’s compounded by the success of nodejs and the fact that universities have dropped Java as their preferred teaching language. 
Yep that was what I was getting at. It really feels like Oracle rolled out the harvester here, I hope that Amazon could emerge in the future as a champion of Java and take over the engineering team. They certainly have the resources. I’m not 100% sure they have the right cultural fit, but maybe their culture could bring some much-needed agility to Java. 
If you use Gradle, you can choose between the [ModiTect plugin](https://github.com/moditect/moditect-gradle-plugin/blob/master/README.md) and the [badass-jlink plugin](https://github.com/beryx/badass-jlink-plugin/blob/master/README.md) (full disclosure: I am the main contributor to both of them), The newest version of badass-jlink also supports the [jpackage](https://jdk.java.net/jpackage/) tool introduced in Java 13, which lets you create installers for your application. 
&gt; I hope that Amazon could emerge in the future as a champion of Java and take over the engineering team. Amazon **could**, but if the Oracle presentations are to be trusted, then they are not yet. I stress "yet" because Amazon does have the resources and foresight to develop that depth, but they have been somewhat shortsighted so far and they're not very effective IMO at community support. So far.. Here's a hard question: How prepared is Amazon, IBM, Azul/Microsoft, Red Hat, etc. to be the "champion of Java"? Ok, let's say one of them gets really serious. Now how long would it be, for you as CTO of a F500 company to take them seriously? Like, "top 5" seriously? Which one would you bet your infrastructure and all of your stock options on? * Amazon. TBD, right? * Azul? Hah! * Red Hat? Obviously controlled by IBM! * Salesforce? Maybe. But they're too busy with other shit. In the meantime.... and I haven't dug through the SEC filings to be honest, but I'm guessing only Oracle has deep enough pockets w.r.t. Java to keep this thing rolling in the style to which its become accustomed. Maybe I've overestimated the importance of corporate sponsorship in general, but I find this is how it works. C*O's go with what is safe. They bet their 3-5 year jobs on it. They are, by and large, sheep. So, you can bet your butt that they're going to "vote" for Oracle simply with their dollars. It's just sad that Oracle doesn't seem to be measuring their success in any other way. If only we could make up for their past short-sighted-ness of good will licensing in the form of current good will....
Yes, there are several performance benefits: [There is a great talk from Mauricio Cimadore at Oracle Code about that](https://youtu.be/M-FPNBFAoSo)
Take a look at the book Elegant Objects. It might give you a bit different perspective on this topic. https://www.amazon.com/Elegant-Objects-1-Yegor-Bugayenko/dp/1519166915
Who said anything about mocking static calls? If your codebase is loaded with static methods then Powermock isn't the problem. So how do you test methods that eventually call your persistence layer (as an example)? Do you load up mock data and execute against an actual DB? &amp;#x200B;
The "I'm not a robot" check is pretty complex: [https://www.quora.com/Why-cant-bots-check-%E2%80%9CI-am-not-a-robot%E2%80%9D-checkboxes/answer/Oliver-Emberton?share=1](https://www.quora.com/Why-cant-bots-check-%E2%80%9CI-am-not-a-robot%E2%80%9D-checkboxes/answer/Oliver-Emberton?share=1) &amp;#x200B;
Hmm, I see. That's amazing. 
Wow. That is amazing.
I thought Baeldung was just a Java website with some tutorials? What is their certification and what does it do? And do employers value it?
I think the discussion about certifications appeared quite a few times on this subreddit and the concussion was it's worthless most of the time. The people who hold the interviews and the managers that do the hiring don't care about them, most of the times. I think you will get better results with a public github repo that shows how you code than a link to a diploma no one cares about , especially Baeldung's
I've worked on a couple projects where an auto-format step was part of the build rather than every save, so assuming you actually compile at least once before committing you'd always have things formatted correctly. Granted there were still ways to screw it up, such as committing *without* compiling, which meant everyone who pulled that commit might find your unrelated code showing surprise changes when they build whatever they're working on.
It’s not worth doing any of them
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Yeah, but they have longer support circle for their own java distributions. I think its nice from amazon. It gives companies more safety on providing old interfaces or older software. Many customers stay on a specific software level as soon as it works, so its provides them some kind of security. &amp;#x200B; And they will downgrade some features (and fix bugs) from higher Java-versions to corretto 8 and later on to corretto 11.
I might be wrong, since I'm not super experienced, but I would say using maven or gradle is quite trivial, because it's so simple. Even if you've never used Maven, all you'll be doing is copy pasting dependencies.
Very few browsers will display them for you indeed. Even less user will want to see them. Face it, the time of Java Applets is just over. Let the thing have its peace.
Although I agree with people that they won't help you on paper, conducting interviews at our start-up has simply proved that people who have an organised structure in their head usually make for great candidates. An exhaustive course like Baeldung's spring certification which delivers a great overview and a great experience that you can benefit after it for the rest of time (after you buy the certification you benefit from updates for the rest of that course's existence, meaning that if you buy it for spring 5 now you will benefit from it whatever spring version will be around then).
To be clear though, Oracle does the majority of the work because Oracle sets the direction that Java goes in. These other companies do a ton of work internally on improvements to Java that don't make it back to the main version because it doesn't fit the product roadmap that Oracle has in mind.
BTW Google's "[flogger](https://google.github.io/flogger/)" API is an interesting approach for logging, with an emphasis on being really inexpensive when logging is disabled while also avoiding the need for guard clauses around potentially expensive operations. It bakes the logging level and options (e.g. whether to produce a stack trace) into the logger instance itself, so it can be set up once at the start of the class/method and then you just call `log()` on it with a format string and arguments for the detail message. Something like: static final FluentLogger debugLogger = FluentLogger.forEnclosingClass().atDebug(); ... debugLogger.log("my expensive object: %s", SomeBigExpensiveSerializer); and if debug logging is disabled at runtime this skips the expensive serialization, the string formatting, and even varargs array creation -- it's just a trivial call to an empty method that takes two references which are completely ignored. Formatting arguments that need more elaborate computations can also be given as lambdas that are likewise skipped when logging is disabled.
You forgot about Google, who happens to have a major interest in Java development both in the mobile space (Android) and on the server-side. Google is already a major contributor to Java, has a history of working on programming language projects, the culture to support it, and the resources to spend.
get your ass off applets
Hi, This is Eugen (from Baeldung) - jumping in here with my own view on the Certification question - which I actually get a lot and I think it's quite a good question. First, to be clear - this is simply a "Certificate of Completion" for the course - which is something quite common when doing any sort of course. A lot of employers do require a quick document that makes sure the employee actually went through the material. That actually why I introduced it - several students were asking for it. &amp;#x200B; Now, is this useful when getting hired? In some cases it is, in other cases it's really not. It basically depends on the company. Some companies look at the courses you completed and do take that into consideration. Others don't care about that. It comes down to the company and their internal hiring policy. &amp;#x200B; Also - a quick clarification - you can now take the Pivotal Certification without going through their live training. That's actually one thing I have in mind for the new "Learn Spring" course I just announced - preparing students to take the Certification. But, the material is not there yet. &amp;#x200B; Anyways, that's generally how I look at the Certificate of Completion for the courses. It can be useful. It can be ignored. Depends on the company. Hope that helps. Cheers, Eugen. 
You can run the code inspector in intellij and get a combined report for multiple classes (up to the entire project) at once, with a customized rule set if desired. Also if you're doing static analysis you should give Google's "error prone" analyzer a try. It runs as a plugin for javac so the issues it finds are reported as compiler warnings. It has a plugin API of its own as well, and I've used it a couple times to create rules specific to a project.
I would personally be quite happy for Amazon to take the help of Java - I feel like they have the right combination of forward-thinking, agility and engineering depth, not to mention community acceptance to take Java to where it needs to go, and maybe even to the next level. IBM is too dysfunctional for my taste, Red Hat too niche, Salesforce too divorced from the community. Amazon have a lot of experience in providing sdks, even languages (cloudformation). They would be a good fit. 
I worked through another course of Baeldung and was disappointed (https://www.reddit.com/r/java/comments/9kg5jx/disappointed_review_about_baeldungs_299_course/?st=JS5VNDEC&amp;sh=4a5ba3bf). I dont know the quality of exactly this one, but I would rather spend the money on Udemy and Books.
Your approach is really interesting and i'm going to read your blog to understand better the extents of it. And i do really agree that java is an extremely performant and pleasant language and context when used without such cumbersome frameworks and i'm really disappointed when i see benchmarks that show how fast is basic servlet + jdbc access performance vs spring ecosystem performances (request per second drop more than 2 orders of magnitude usually). That said frameworks are there to facilitate code developing and maintainability so it would be a wrong move to leave them off. Sure enough there are other java frameworks that should shine in performance respect to Spring and maybe, i should compare easy&amp;lean js web development vs easy&amp;lean java web development that would basically mean let Spring be away and use other simpler frameworks. But Spring is the de-facto standard when it comes to "enterprise java development". It has a strong, consistent and wide eco-system: that's its real power and benefit and has you covered for any need (auths, db, load balancing, scaling, configurations, batch processing, and so on). And with that come all the code guidelines (like the use of, to be honest, useless interfaces) and not so needed dependency injections. I think that what Java really miss is a truly simple framework ecosystem like a dropwizard ecosystem with a lean and small orm (sorry, but on any mid/high size project orm is not a choice, is a need: you can't write all the CRUD sql code anytime when you deal with 20+ model entities, it would be extremely error prone and violating any DRY principle), simple but complete authentication framework (SpringSecurity is hyper-complete but definitely not simple!) and some other niceties. And it should be fast and don't eat java performances like Spring does (when i talk about Spring i'm also referring to SpringBoot obviously). If that ecosystem would exists and be production-grade then IMO it would let Java shine again.
Honestly i do really appreciate Sequelize simplicity and flexibility, it just seemed too much immature to me. Talking about express, i consider it definitely complete and easy for what it must do. Thank you for pointing me to these 2 other libraries anyhow. 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
tens of thousands is not a lot. Arrays are fine for experimenting with sorting algorithms. The only time 'good practice for maximum size of an array' is anything but '... make them however large you need them to be' comes up, is the following: Arrays are low-level constructs. Don't use them at all, use List&lt;T&gt; instead, unless you actually want the low-level stuff. When experimenting with sorting, I'm pretty sure you _DO_ want the low level stuff. Arrays are contiguous in memory. If you have some need to create an array with millions of slots, first you should be thinking: Perhaps I can find a different, less memory intensive model, such as using a DB engine that is specialized for this stuff, or streaming the data instead of storing it all in memory. If that isn't feasible either, you should definitely be thinking: "Perhaps I should write a class that contains a field with the array, so that I can abstract away a bunch of logic, in case I need to experiment with it later. That way, the code I write that uses this large data structure won't have to hardcoded the notion of the implementation". And once you've done that, it's certainly possible that you end up making a few semi-large arrays instead of one humongous one. But that'd be an after-thought; a mere implementation detail that the rest of your code need not care about. 
&gt; universities have dropped Java as their preferred teaching language They do? The only result I find from a quick search is that Stanford University stops using Java as an *introductory* language in favor of JavaScript, because they found that Java's verbosity is making it harder for students to get started (which I totally understand). https://www.neowin.net/news/stanford-university-dumps-java-as-an-introductory-programming-language
That's not really accurate. E.g. [Red Hat contributed a whole new GC](https://openjdk.java.net/jeps/189),[Google contributed a profiling mechanism](https://openjdk.java.net/jeps/331) and just the other day proposed a [race-condition detection mechanism](http://mail.openjdk.java.net/pipermail/discuss/2019-February/004961.html). Most of the companies are not accustomed to significant open source development. As to setting direction, you should watch [this talk](https://youtu.be/W-l0Huhb40s?t=1308), the second half of Mark Reinhold presentation at FOSDEM a couple of weeks ago.
thats supercool, but java 8? cmon, its 2019, not 2014
I've used both, much prefer the syntax of Gradle. Maven is plain ugly
Eh? NetBeans 10.0 was released last year. Oh, I see, you're just [spamming links to some dodgy aggregator site](https://old.reddit.com/user/danielbryantuk/posts/) that regurgitates old press releases for clicks. Reported. 
Hi, NetBeans 10.0 was released a few weeks ago on the 27th of December, but this piece has added some additional context on the updates in the incubating version. As for spamming, apologies if it looks like this, but I'm simply catching up with my reading/reviewing after a couple of weeks of traveling.
They weren't asking about Oracle JDK. They were asking about OpenJDK, which has no such restrictions.
Ok, But my point is that your percentages of fixed issues in JIRA is going to implicitly bias towards Oracle developers, since they are more likely to fix smaller bugs than external contributors are. One big thing like Tsan is considerably more complex than a documentation change, but both count as a single bug in the accounting. And for a long time (when Oracle was in charge, not OpenJDK), this wasn't the way contributions to the Java platform worked, and it was more difficult to get changes into Java. The momentum from this has a lot to do with why Oracle continues to have so much influence on the platform. I'd be more interested to see the LoC contributions than bugs fixed, because # bugs fixed give no information about the complexity of the problems solved. This isn't to degrade or minimize the role that Oracle plays at all, but I think 80% is a vast overstatement of the actual contributions to the innovation moving Java forward.
I think you missed the EE part...8 is the current version.
&gt; Google still has its own version of the JDK that will never be compatible with mainline OpenJDK because of this period in which it was difficult to contribute meaningfully to the platform. Also because those changes are more geared towards Google's specific needs. At the end of the day, every software, open source or not, is led by specific people who have specific biases. The vast majority of the people who steer, guide and lead OpenJDK now work for Oracle, but the direction of the platform is more determined by who they are rather than the name of the company that pays their salary. Of course, because Oracle pays the salary of most OpenJDK developers, it can choose which *areas* of the platform it wishes to fund. This is the same for Linux, where most contributions are funded by companies. &gt; I'd be more interested to see the LoC contributions than bugs fixed, because # bugs fixed give no information about the complexity of the problems solved. That would likely show Oracle at over 90%. The large contribution breakdown is [Here](https://youtu.be/W-l0Huhb40s?t=511). But you should really watch the second half, which I linked to before, that explains how OpenJDK is developed. 
The article states that this profile continues to align itself with Java EE 8. Last time I checked out Java EE was 3 years ago. I dismissed it because it didn't fit my needs. For all I know it works just fine. But the version has me worried: Java EE 8 appears to indicate it is limited to Java SDK version 1.8. Is that correct? Or can it benefit from version 11?
I would suggest running gitlab locally, I do it on a pi. When you show up to an interview with a personal repo with open and closed issues, you will blow them away.
There's nothing conflicting their cross-use, but I believe Open Liberty is currently the only Java EE 8 compliant application server that supports JDK 11... EE-related parts were removed from Java SE 11, and need to be added back on the other side for things to continue working.
Could you please tell me a valid resource I could prepare for that examination from pivotal? 
This is exactly my concern. It is on their website. 
Sounds intriguing 
As for spamming... Why don't you link *directly* to [netbeans.org](http://netbeans.org)? What you are doing *is* spamming. **Removed**
I would challenge a few of your points about frameworks. As you mentioned there are already some leaner framework ecosystems like dropwizard and I have found that quite a few places do use them. I have been a Java developer for 8 years now and I have never worked at a Spring shop, it's always been dropwizard or Jersey. &gt; on any mid/high size project orm is not a choice, is a need I mostly agree here except that I think its a tradeoff. One of my very first jobs was a very large codebase with only 5-10 BE engineers and we did use nothing but raw JDBC and writing every query by hand. It was pretty tedious but I think the time we spent writing queries was traded for time we spent debugging performance issues. I barely remember spending time tracking down performance there because all of our SQL queries were highly optimized to start with. It was an ecommerce company with 300+ million products and 500-900k page views a day. &gt; simple but complete authentication framework There are a few choices here now. [Pac4J](http://www.pac4j.org/) is a standalone Java security library that can hook into almost any time of auth flow with any webserver you want. Another popular option is using a 3rd party service like Okta or Auth0 which hande your auth for you. &gt; load balancing, scaling, configurations, batch processing, and so on A lot of these are now covered by your tooling. Auto scaling groups and ALBs in AWS can cover auto discovery and load balancing. Kubernetes also has its own solutions for that. You can use cloud providers for secret and configuration management. Multiple tools for batching processing these days. I have seen a few Spring code bases and I have personally found them to all still be a little bit different. They each had some weird hacks that modified Spring security's auth flow in different ways. Frameworks like this claim that you can just switch out implementations under the hood but is that really the case? Even with something as simple as JSON serialization you end up customizing the object mapper that you pass to Spring. To switch to GSON you would need to find all the same customizations. Same thing with any underlying webserver or http client. You often need to start customizing them at the library level to get various features/performance. A lot of languages have these splits. C# has large and small frameworks, Ruby has Rails and sinatra, Scala is mostly all smaller web servers but you can pull in some frameworks, Kotlin has both, python has django and flask. Java just happens to be a lot less balanced than some other languages towards frameworks. Where Scala and kotlin lean much more towards the lower level side.
That would be nice in theory if it kept to .java classes. We've had other types of classes where a format created bugs that were very hard to track down (can't see the problem introduced when your default way of examining a commit change ignores whitespace changes!). And then there's the issue of certain long-running branches trying to change whole sub-systems being screwed royally by having to deal with a gazillion pointless formatting changes because back when the branch was made, formatting was not paid attention to.
Not even pivotal's? 
What about running on Linux or MacOS? Is you library crossplatform?
And that's before paying the rent, right?
Props for being honest about it instead of just trying to sell it
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
+ /r/javahelp is for programming questions, + /r/learnjava is for learning related questions, + /r/java is for "News, Technical discussions, research papers and assorted things of interest related to the Java programming language" **Removed**
&gt; Arrays are contiguous in memory. Commonly yes, but not always true in Java.
Looking at their site, it looks like Wildfly does too. Red Hat JBoss EAP (derived from Wildfly) supports it [as of the 7.2 release](https://access.redhat.com/articles/2026253). So we’re getting there. Slowly. 
Very good points, definitely. Talking about ORMs i agree with the tradeoff you highlighted: i've been working in the past on big projects where you had to write all the sql: tedious, error prone, lots of repeated code but definitely best performances ever and debugging was a breeze and a quick process...i miss that feeling with todays' ORMs :D Anyhow you put me in the mood to test and build a simple application based on DW, pac4J and as someone else suggested, jdbi and see how it feels!
Well, there's no point in buying something if it doesn't make sense. In general, being happy with the courses is much better than getting something you don't need :)
Happy to help clear that up. I added a comment above - hopefully that explains things a bit more. 
I'd say, if a company is going to take any notice of a Certification - then Pivotals makes the most sense (if Spring is involved). But, yeah, not all companies do - some do, and some simply don't care. 
Yep. For me it is JDK 8 and Wildfly 14.0.1 which is EE8. I've tried to move to JDK 9,10 and 11 a few times and have been hit by minor incompatibilities in IDE (Eclipse) and Wildfly which have kept me where I am. Now that I've moved to Intelij I'm planning to move to Java 12 and Wildfly 16 next month. 
I really highly recommend jOOQ for SQL. It gives you the best of both worlds. Code generation so you dont have t make the pojo / records, you can auto generate repo classes for crud operations, and finally the SQL DSL feels as if you were writing SQL and its typesafe. It's also great for dynamic SQL where you have lots of optional filters. Here is some older code I wrote for a dynamic SQL query. I would probably use a few optionals to generate it now but should give you can idea of what it can do. public static int affiliatesProducingClicks(ReportRequest request) { Condition condition = trueCondition(); if (null != request.getNetwork()) { condition = condition.and(Tables.CLICK_DATA.AFFILIATE_NETWORK.eq(request.getNetwork())); } if (null != request.getGroupId()) { condition = condition.and(Tables.CLICK_DATA.GROUP_ID.eq(request.getGroupId())); } if (null != request.getStart()) { condition = condition.and(Tables.CLICK_DATA.DAY.greaterOrEqual(request.getStart())); } if (null != request.getEnd()) { condition = condition.and(Tables.CLICK_DATA.DAY.lessOrEqual(request.getEnd())); } if (null != request.getMerchants() &amp;&amp; request.getMerchants().size() &gt; 0) { List&lt;Long&gt; ids = Seq.seq(request.getMerchants()).map(m -&gt; m.getMerchantId()).toList(); condition = condition.and(Tables.CLICK_DATA.MERCHANT_ID.in(ids)); } return Daos.create() .select(countDistinct(Tables.CLICK_DATA.AFFILIATE_ID)) .from(Tables.CLICK_DATA) .where(condition) .fetchOne(0, Integer.class); }
Oh i like that! Thanks for the tip!
Definitely a nice way to write queries, i should give it a try.
[Abstract and slides](https://2018.jpoint.ru/en/talks/2sc3v1jbv2y6eeoyiuisoc/)
I'm a little confused about this -- this new article was published a couple of days ago, and I believed this would be interesting for the Java audience, as it adds more context/links than the source material Just for context, Netbeans was one of the first IDEs I learnt to code in, and I'm keen to help promote it. I do write for InfoQ, but we cover lots of Java news? Several of our editors (including me) are also Java Champions. I'm not trying to troll here, and I genuinely am interested to learn about the rationale for removing this post?
There no OS specific calls, I don't see why shouldn't it be. But please do let me know if you run into some issue.
he is actually correct. `The Dockerfile` in question is made with **Java 8u191** if you look at https://github.com/IvoNet/ivonet-docker-images/blob/master/servers/appserver/payara/5.184/Dockerfile and https://github.com/IvoNet/ivonet-docker-images/blob/master/java/Dockerfile or from the layers https://microbadger.com/images/ivonet/payara
Oh yeah, that's complex alright.
AdoptOpenJDK.net is where most of the big names are lending their weight and Azul and Amazon even sponsor there as well!
Microprofile isn't very micro. A sample application generated by their Starter beta app clocks in with a 128 meg jar file after a `mvn clean package`. I used Open Liberty as the implementation. Conversely I have a REST api application that embeds tomcat, includes Jersey support, and has the necessary dependencies for Kotlin and its deployable artifact clocks in at 16 megs (just included a few tomcat-embed-* dependencies and then a few jersey dependencies in my `build.gradle` since Jersey isn't a JavaEE API that tomcat implements). Even a Spring Boot app with a single rest controller will only clock in at 40-50 megs.
noted...
Well, the site is entirely free and that's a good place to start, of course. The Spring guides are solid as well. But, ultimately - it's practice that's going to be the best way to learn. So - code your way through a Spring app - and you'll be a good shape for the exam. 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
It looks like in your [submission](https://www.reddit.com/r/java/comments/aqyuog/i_spent_hours_try_fix_an_unit_test_the_cause/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Microservice doesn't necessarily mean small in size. Though that normally is a nice sideeffect. Microprofile and Openliberty apparently provide more than is used for the service alone but you could all kinds of differen services wi
File size is important to me because I have 40+ µservices that I have to deliver to a client. If each one is 120 megs that is nearly 5 gigs I have to deliver for a full deployment on initial install. That is a non-trivial deployment package to deliver. It just gets bigger the more µservices I have. Of course after initial install we only have to deliver the µservices that change.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Here are some words from Gosling about this: &gt; A package is generally a set of things that are kind of written together. So generically I could have done one of two things. One was force you always to put in a keyword that gives you the domain. Or I could have had a default value. And then the question is, what makes a sensible default? And I tend to go for what is the least dangerous thing. The whole passage can be found [here](https://www.artima.com/intv/gosling26.html).
No lots of people wish that. Even the current language and VM architects, Brian Goetz and John Rose, wish that. Unfortunately it's too late to change it now!
Everything should be private if it’s used internally only. If it has reason to be used from elsewhere, consider how broadly (basically future proofing). Everything should typically have the lowest visibility level possible; if you expect something to be private, make it private. You don’t want someone else playing with it from another class without you explicitly knowing about it. That just leads to bugs and pain, IMO.
&gt;rivate would probably have been a bad thing to make a default, if only because people actually don't write private **methods** that often. (emphasis added) I see
What if you embedded your services into tomcat, instead of the other way around? Tomcat is designed to run multiple applications, within a single JVM and Tomcat instance. Just a thought.
Did you ship the complete Open Liberty server runtime with the Microprofile app?
I think the number of private methods will depend heavily on coding style. For instance, *Clean Code* advocates very small methods (on the order of a few lines), which in many cases could lead to a large number of short private methods exposed via a small public interface. I don't have very strong feelings on it either way, but I *do* find myself wishing almost daily that `final` were the default, for local variables, fields, classes, and method parameters alike.
I definitely like to have small private methods as "code snippets" but even if I end up with more of them than other methods they still feel very "different" and "non-default". Instead of default finals, I would advocate something similar to Swift's solution: &gt;constant MAX_HP = 100 And allows "constant"s to have their data type inferred, since they are only ever assigned once.
We aren't currently using microprofile+open liberty. I am evaluating it in comparison to things I have done in the past and what we are currently doing (spring boot). Would really like to get away from spring so exploring options (doing some POCs). Our preference would be to have each µservice be executable on its own so they are independent. 
Amazon Corretto 11 has some bug fixes backported from OpenJDK 12. [https://docs.aws.amazon.com/corretto/latest/corretto-11-ug/change-log.html](https://docs.aws.amazon.com/corretto/latest/corretto-11-ug/change-log.html) &amp;#x200B; Oracle also has backpatches of bugfixes if you pay for it. Or if you only use the free version during its limited lifetime for the unpaid version. Once that period is up, no more updates for that version. But that's what people pay Oracle for. With Open JDK it is open source. No Oracle Binary License Agreement. But there are no guarantees. Several sources of Open JDK have pledged to provide updates and bugfixes for certain lengths of time, generally sometime into the 2020s. &amp;#x200B; Here are some places where you can download Open JDK. Hope that helps. &amp;#x200B; Adopt Open JDK [https://adoptopenjdk.net/](https://adoptopenjdk.net/) [https://github.com/AdoptOpenJDK](https://github.com/AdoptOpenJDK) &amp;#x200B; [https://github.com/ojdkbuild/ojdkbuild](https://github.com/ojdkbuild/ojdkbuild) &amp;#x200B; Open JDK [http://openjdk.java.net/](http://openjdk.java.net/) &amp;#x200B; Azul Systems Zulu [http://www.azul.com/downloads/zulu/](http://www.azul.com/downloads/zulu/) &amp;#x200B; Amazon [https://aws.amazon.com/fr/corretto/](https://aws.amazon.com/fr/corretto/) [https://github.com/corretto](https://github.com/corretto) &amp;#x200B; Red Hat [https://developers.redhat.com/products/openjdk/download/](https://developers.redhat.com/products/openjdk/download/) [https://access.redhat.com/articles/1299013](https://access.redhat.com/articles/1299013) &amp;#x200B; SAP [https://github.com/SAP/SapMachine](https://github.com/SAP/SapMachine) &amp;#x200B; BellSoft [https://bell-sw.com/java.html](https://bell-sw.com/java.html) &amp;#x200B; &amp;#x200B; Oracle JDK [https://jdk.java.net/11/](https://jdk.java.net/11/) Oracle Binary License Agreement - DANGER Will Robinson! [http://java.oracle.com/](http://java.oracle.com/) &amp;#x200B;
\&gt; Or just use OpenJDK The three he mentioned ( Corretto, AdoptOpenJDK or Zulu ), really ARE OpenJDK. But with additional bugfixes you no longer get from Oracle on that version. For example: Amazon Corretto 11 has some bug fixes backported from OpenJDK 12. [https://docs.aws.amazon.com/corretto/latest/corretto-11-ug/change-log.html](https://docs.aws.amazon.com/corretto/latest/corretto-11-ug/change-log.html) &amp;#x200B; Personally, I've had good luck with Azul Zulu. I've tried AdoptOpenJDK a bit, and plan to do more testing with it.
In the past I have had multiple apps deployed in the same tomcat instance. But the idea of µservices is to make them independent. Generally you can deploy apps into a shared tomcat instance without affecting any other apps on it, but occasionally things go awry and you have to restart tomcat (this seems to less of a problem with Java 1.8+ though because of the removal of PermGen space, frequent deployments to tomcat would use up PermGen space prior to Java 1.8). Would prefer to have each µservice be executable on its own. Easier to scale this way too IMHO. 
&gt; Oracle is trying to monetize Java, and that's a huge turnoff for developers and many businesses alike. It depends on what you want. If you want someone to call at 3 AM if it breaks. But I don't expect Open JDK to break. Oracle also provides continuing and ongoing bugfixes on paid subscription versions. But again, some OpenJDK providers pledge to provide fairly extended bugfixes as well. But there are no guarantees with OpenJDK.
I don't feel strongly about private being default. But I do feel strongly that `final` should have been the default, and you have to use some keyword in order to make it non-final. If final were the default, that most variables would get assigned once and could never change.
I see the problem you had with PermGen. When you say "easier to scale this way", I think you mean easier to execute individual services, which is a time and labor saver when you have a lot of them. I have an elaborate way I package up Tomcat with scripts that installs it as a service with whatever is installed into it. So on Windows I have multiple services in the Services Control Panel, or on Linux many systemd unit files. But I find it convenient that I can also package Tomcat in a way that it is easy to execute a single instance with everything bundles into it. When doing so is appropriate. Stand alone systems. Demo systems. Dev Test systems. But, whatever works for you is what matters.
I don't remember that he cited Zulu or AdoptJDK when I wrote. The text doesn't seem to be edited, so I guess I didn't read it properly.
This is the plan for [records](https://cr.openjdk.java.net/~briangoetz/amber/datum.html). Value class fields will also be `final`, and you cannot opt out.
404 - Not found.
Weird. I’ll repost.
Package private and protected are unintuitive. Really prefer Scala's approach
Hooray, features and stuff... :-/ Question is: Will they change the license model again? 
I don’t think they will anytime soon. It also seems like most will choose Oracle OpenJDK builds or builds from other vendors.
Very good reference, thank you.
&gt; I do find myself wishing almost daily that final were the default, for local variables, fields, classes, and method parameters alike. Why u hate people who want to extend your API in ways you can't anticipate? JLine 2 is particularly bad about this.
Release notes at: https://jdk.java.net/12/release-notes
Thanks for an honest answer!
It's worth it in the sense that you will learn. But employers don't generally care. I hired people with certifications, they were shit. Really shit.
Hey they have an implementation of coroutines. Is their code open source? At Oracle they're working to get continuations (a primitive co-routines could be built on top of) in OpenJDK with the Loom project. And both teams seem to encounter similar issues. At 38:25 they talk about synchronization, and this is a topic that has been mentioned in the the Loom mailing list as well. It would be great if experience in addressing this could be shared. All actors developing tweaks in the JVM should share them and try harder to contribute their developments to OpenJDK. Google too has their own JVM as well, on top of the Android runtime. Maybe it would not be possible. The Alibaba JDK seems to be doing pretty liberal things to address the synchronization issue, which might be at odds with OpenJDK's backward compatibility promise.
Found the problem--typo in the provided link (ends in a c)
IMHO, there is no reason to make anything private: 1) It is harder to test. 2) Drive us to a non-reusable mindset. 3) It is not a proper way to hide implementation. 4) A minimum knowledge of reflection allows anyone to breake you "security". 
Encapsulation is not about security. It is about compatibility. If someone is using a class whose members are encapsulated, the maintainer of that class can freely update the underlying implementation without breaking existing code.
Ah, okay. Thanks!
If what you care for is performance, there's nothing fancy in oracle's current approach to coroutines, in fact all if it can be done today by anybody EXCEPT for the stack capturing, but that's only useful for exceptions really, not performance. Use actors with Akka (or Quasar if that's your thing) and you have it all ready, with lots of useful things on top such as dispatchers, monitoring, logging and endless goodies (like event sourcing, clustering and more).
Yep, starting everything with private is a good habit. You can always change it later when needed. Java's default visibility is a little weird. It's not useless, but it's not the most useful thing either. And it's weird because it can't be named, we call it package-private but you can't really put those words in your source code or it won't compile... If you read some source code you are never sure at first sight if the previous developer meant to leave that member as package-private or if s/he was simply lazy (you can make private and see if it still compiles, of course). It seems that Java got this default from Oak, where it was the most private level available. They later made **private** really private and left the default level as package-private.
The architects are thinking about making package-private denotable. See [here](http://mail.openjdk.java.net/pipermail/amber-spec-experts/2019-January/000945.html).
&gt; Why u hate people who want to extend your API in ways you can't anticipate? I don't, I care deeply for those people. Which is precisely why I don't want to subject them to the horrors of extending an API that I never designed for extensibility. Not by inheritance, at any rate. You can always compose :). As it says in the Holy Book, &gt; Design and document for inheritance or else prohibit it. -- Joshua 4:19 In seriousness though, default final for local variables is what I'd like most, since my coding style is tending increasingly towards the functional. For classes I'm not too bothered about the default, since there are far more local variables than classes.
So, you expose interfaces and not implementations, right? 
I use package private all the time. It allows me to unit test utilities that I want in the class, but don't want to expose. My default is package private for this reason for most methods. Instance variables are almost always private though. 
That is correct.
Primitive generics? We were promised primitive generics.
[Micronaut](https://micronaut.io/) and [Helidon](https://helidon.io/#/) are a realtively new frameworks, that looks promising. Though I've never used them.
Not in JDK 12... The current plan is for them to come in L-World 100. We are currently in [L-World 1](https://wiki.openjdk.java.net/display/valhalla/L-World+Value+Types).
For loops in Java are quiet easy for example when building a string that says "baby shark do do do do" you just need to initialize that string like, then loop n times for the n "do"s: and return the string String s = "Baby shark"; for(int n=0; n&lt;4;n++) s = s+"do"; Return s; This for loop means for integer n which is 0 and while it is &lt;4 do the thing (s+"do" in this case) and then increase n. Actually the n&lt;4 comes because 0,1,2,3 are already 4 "do"s so to make it more real-lifey you could write it as follows: for(int i=1;i&lt;=4;i++) And so on Meaning start with the first do and do until sou reach the 4th. Another possible would be to make it decreasing: for(int k=4;k&gt;0;k--) Meaning start at the 4th and go down until you reach the 0th. Or letting it go from 3 to &gt;=0 would also be possible. And if you're feeling really fancy you can make it as complex as you want like the following: for (int j=1;j&lt;=8;j*2) This works the same because you increase by 2^n and 8 is 2^4. Also every for loop has an equally while loop meaning the first example as while would be: int a = 0; While(a&lt;4){ s = s+"do"; a++; } And so you can build a String in Java via a for loop, although I would recommend to look up StringBuilder when working with bigger Strings than "Baby shark do do do do" as Java is rather slow to build big Strings in contrast to other languages like PHP. Hope this helped you to build the lyrics for baby shark in java. "Let's code do do do do"
When it's done. 
&gt;While untangling the spaghetti, you will notice you are now able to free up some of your intellectual capabilities. You are slowly getting at the core of the problem. Every piece that can stand on its own can be moved and you are left with the essence of your program. No, what's being described here(and elsewhere in the article) is just bad design. The lack of Interfaces, abstract classes, generic types, etc are the actual problem here. If you want an application to be flexible you need to use flexible language features to achieve it. &gt;Break up those parts into composable units. Define a function that can be used to filter items from a list, or an action that can be re-used for every single item. Maybe add helper functions that encapsulate logic that would otherwise end up inside deeply nested code. While this may be OK for larger chunks of code, doing this for every little thing will just kill readability as you have to jump to utility/private methods or smaller classes to get the larger picture. Tiny little classes can be just as a pain to work with as larger concrete classes.
I do that too. I also group my classes by feature (rather than by layer) in packages so that classes that are functionally related can access each other's package-private members.
No data classes? No reason to upgrade.
Hi, I do a fair bit of interviewing and have a spreadsheet which scores every aspect of a candidate's interview and resume/background with a maximum possible score of 183. A Baeldung Spring Certification is worth 3 points. Just kidding about the spreadsheet. It actually carries zero weight for me. There's too weak of a relationship between "can code their way out of a paper bag" and "has certificates".
Not this round, but we do get the preview of [switch expressions](https://openjdk.java.net/jeps/325).
well, I kind of agree with this. it's very common I don't want a consumer of my class to know about private methods, but if there were an extending class I really wouldn't care what they knew about. furthermore some methods are internal but really ought to be testable, protected allows that. someone will show up and tell me private methods needing tests is a code smell but sometimes the code smells. 
Well there’s no assertions so these are exercisers
&gt;The recommended approach to close files is to explicitly call close or to use try-with-resources. Finally! (pun 100% intended).
I was looking forward to \` style string literals, but they died a couple weeks ago.
everything should be private unless there is a **very** good reason to not be.
I mean the people who write code inside the package can mess up too. Even you yourself can mess up.
`baby shark in java`
API diff available at https://gunnarmorling.github.io/jdk-api-diff/jdk11-jdk12-api-diff.html. The diff is made against build 27 and the RC is based on build 32. 
Nice! That new syntax is so much clearer. 
8 = 2 ^ 3
Unicode 11, new cryptography algorithms, some changes to the keystore utilities, CompactNumberFormat (1000 -&gt; 1K). Given that support ends on September 2019 I doubt that many people will upgrade. I think an Alpine build could really help drive adoption. There were EA builds for Alpine but there is no RC build. :(
What's this about GTK &gt;3.20 being broken? Is it going to be fixed before final release?
Good to see the list of security related changes: dropped support for obsolete protocols, certificates and standards.
Yet by convention, Java developers have decided to put "similar concepts" into one package... Not code that interacts with each other. For example the convention is for foo.controller to have the controllers and foo.dao to have the DAOs... So search logic is split across two packages instead of having a controller and a DAO together in foo.search. I'm not arguing one way is better than the other, I just find it comical (odd?) that we've standardized on practices that disagree with the language design.
Speaking as an open source maintainer: I don't hate them. I just don't want to paint myself into a corner by exposing what I consider implementation details as API. My philosophy is that the long term vitality of the project is better served by minimizing the API surface area. This allows for major refactoring under the hood while preserving API compatibility.
Take the damn upvote.
Take the damn upvote.
Wow, I am actually really impressed with this response.
&gt; Hey they have an implementation of coroutines. Is their code open source? I don't believe so.
And still no one has decided to produce a decent test harness for JEE. As opposed to the superb spring-test. Arquillian you say? Ugh no thanks. 
Same for me, I kind of produced my own "dropwizard" with a fat jar weighting less than 20megs, and docker image of about 80 (alpine jre). Of course nothing that I would use if I had to reinvent the wheel on authorization, Cors, etc...
True. I didn't mention them. But, Google has some conflicts of interest and proven record of not staying focused on the long term. Yes, they could still do it, they have the resources. I just don't see them being ready to do it.
something tells me gosling didn't have "*SimpleBeanFactoryAwareAspectInstanceFactory*"s in mind either.
Just make it all public. Some horrible Indian developer is just going to rape the code you wrote eventually anyways. 
This the most boring Java release in history ;)
I've seen this thing too many times unfortunately. This is just a bad practice imho. I usually try to make a module-like structure. 
+ /r/javahelp is for programming questions, + /r/learnjava is for learning related questions, + /r/java is for "News, Technical discussions, research papers and assorted things of interest related to the Java programming language" **Removed**
angulah angoolaaaaaaaah
Not sure why no one commented, it's a very cool guide. I'll certainly give bits of it a go - Resilience4j is probably something my company will adopt soon anyway. Micronaut - will have a play and read up on
People can always mess up, no matter what you do. You are right to think that we need to take care of how our code is designed and written. But don't you think that it it is something that a team agreement and a code review processo could solve? I still don't see how does it surpasses the benefit of have a code easy to test (and consequently more maintainable). 
What's the term for the people who are not doing any work to use manipulative shenanigans to make the lives of the people doing actual work miserable? 
&gt; My manager recently suggested that my lambdas would not be readable or maintainable (simply because he doesn't understand them). Or because they add nothing of value, they're a 2nd or 3rd way to do what you can already do, that's often harder to read and parse. for-each made my code easier to read. generics made my code easier to read. Lambdas - especially combined with completable futures - made rewritten code way messier and harder to read than the original code.
You should probably learn ES6 before doing anything with modern JavaScript frameworks. React is a good choice and you don't need to learn nodejs for full-stack, you can still write you back end in Spring Boot and front end in react. If you decide to learn Android, Java is a great start since you already know it. You can always try Kotlin later and I would suggest that you do. Great thing is that Kotlin is interoperable with Java, so you can just try to rewrite one class in Kotlin and leave others in Java and the project will still work.. Kotlin doesn't have many advantages over Java in Spring, but it makes a ton of difference in Android. But to see and feel how much Kotlin helps, you should first write semi-comolex app entirely in Java so you can face difficulties and problems with Android framework, many of which are solved just by using Kotlin. As to what you should learn next, I don't know. Both Android and React offer nice career opportunities. You can also try them both. Learn basics of each and build some stupid todo app in both and see what you like better. I've been programming for 3 years, first two I've done Android and now I do Spring Boot with React. I've also made some basic projects with ASP.NET Core and Angular. You can always try out different frameworks, languages and technologies, the more you try out different stuff, the faster you'll pick up new stuff because most technologies today share a lot of similarities.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Thanks for the feedback! I'm curious: what would your solution to the stated problem look like? I assume with larger, concrete classes, interfaces, generic types? I'd like to compare your solution to mine. 
Both are great options. Just pick one an go for it. I'd suggest you pick the one that is more pleasurable to you - it will help with motivation and momentum. Don't be afraid that you'll be missing something by making a choice - you always will, just get used to it. You'll have plenty of time to learn many technologies if you wish and work for it.
You may have confused this build's release notes with the [version's JEPs](https://openjdk.java.net/projects/jdk/12/). Also, eventually people will stop mistaking the new feature releases with the old major releases (the last of which was Java 9, and there will be no more of). The new feature releases are somewhere in between the old major releases and the old [update releases](https://www.oracle.com/technetwork/java/javase/8u-relnotes-2225394.html), but *closer to the latter*. So it doesn't mean much to adopt a specific feature release. You either adopt the release train or choose to stay on some LTS feature version.
[JDK 12 JEPs](https://openjdk.java.net/projects/jdk/12/)
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Liberty is quite easy to bring down. In server.xml you can specify exactly which features you want, and then using a tool you can produce a binary runtime containing only those.
Arquillian works pretty okay ;)
How about some cloud stuff? eg write some Node AWS lambdas, exposed via a rest api to your HTML served from S3. If you're doing mobile dev I'd learn a cross-platform framework like native script.
Didn't know, thats pretty nice. I suspect this wasn't done in this example.
They didn't die, they are reworking them because there were some fundamental flaws in the design they had. 
This is a very broad question. Do you have a specific example in mind?
No you shouldn't really expect people to check every line of code for whether they accessed something they shouldn't. Even if they're already checking for other things it's still going to take a lot of work if they *also* need to consider access levels. There is some merit to python's approach which essentially has private and public equivalents which aren't actually enforced. But I don't really like mixing that approach with Java's strict approach. If we're already doing that why not also allow dynamic typing? Also I wonder if python has / could have a similar convention for typing where you can append something to the name to tip people off but it doesn't actually do anything. A little bit more difficult since there are an arbitrarily large amount of objects but it might work. I'm not entirely sure about the testing problem. There are some people who say that tests should be written inside the class. It feels like testing conventions are determined by an organization rather than the language architects.
This is influenced by 2 things - the problem you are trying to solve - the design pattern you are using.
/r/JavaConferenceVideos
The basis is generally taught in "Software Engineering" courses. Get a Software Engineering book (we had "Applying UML and patterns, Larman") and then I guess it needs some experience.
The more you write little programs like that, the more easily you will spot how to create classes as you mentioned. In Java, it is good to separate domain classes (classes that contain state) with classes that execute business logic, and don't generally have state. So Customer and Book would be the domain classes, and you may have a BookCheckout class to handle some business logic. You could think about how your user will use the system. They will need to create an account, checkout a book, return a book etc.. Then you can think about further splitting down these features into classes with methods. In terms of what attributes a domain class has, think about what you are trying to achieve before writing code, nail down what attributes you think you will need to have, and this will prevent the need for huge changes once code is written (forethought is your friend). In the end, you are wrestling with how objects in an OO system interact with each other to achieve business logic, and this becomes easier the more you do it.
I didn't know this, I will look into this. Thanks for the info!
I _really_ like Rust's `let`/`let mut` distinction, that paired with the borrow checker, make shadowing/aliasing variables idiomatic and safe. I wish Java had that.
Look into the planning side of programming for this one. The thing you want to make is a UML Class Diagram. It is used to map a program and it's classes. I would be very surprised if you can't find some information online on how to make these. Classes usually carry out a small set of specific tasks related to one unique job.
Thank you /u/Gwynnie!
Error, list index out of range 
The jump to JDK 11 is a big one for the EE crowd since the EE (JAX-WS, JAX-B, JTA, etc) modules were ripped out. Once stable on JDK 11 the moves to 12 and beyond should be seamless. 
Learn react and you can use react native to make mobile apps, frontend and desktop apps. Also, you become a fullstack like developer. Of course you have to learn (or refresh) ES6 and beyond, css3, and some (or all) of the boilerplate around react/rnative. Just do a 1h investigation around react and RNative and make you choice
I'm aware. 
The grin at the start is a bit unnatural/creepy, informative video tho ty!