Ok I understand your point. You are correct in that case. However is that problem so prevalent? Can you give me some examples for companies that use Docker as the **only** way to **distribute** their Java applications? Maybe I am missing something here... 
Oh ya that's what I meant, sending the string from the JOptionPane.
What's your issue with "sub-commands" exactly?
&gt; unless you actually want non-humans to look at your logs this is (for example) actually very common when analyzing user behavior. basic analysis of stuff over time.
What's the target audience for the front end? Can. You envision multiple clients consuming it? Would microservices make sense?
Ok got it! Thanks for the explanation. Makes sense now...
&gt; The real issue of string concatenation happens in loops Why would you ever use string concatenation instead of a `StringBuilder` in a loop?
True. But it's easier to simply have a separate database for that and have a huge availability of reporting tools.
Not really sure what OP is talking about. I use Lombok with JPA. I'm not sure what "undocumented" features Lombok uses, as it's a standard compile-time annotation processor. The only difference between it and Autovalue or Immutables is that it injects the bytecode into the class files as opposed to generating new java files. There's no magic, just standard java apis. So, in short, I'm not sure what OP is complaining about. 
That's a good question. Both courses of action have merits. While having more than basic skills in one language (talking about mastering it is a bit premature here) is more important for employability, knowing multiple languages will ultimately make you a more competent programmer. So unless you need to be able to bypass college and get a job ASAP, I suggest doing both: look at real (but small) open source projects to understand how java is used and learn to deal with other people's code. Maybe start contributing to a project or start your own non-trivial one. And at the same time learn a language that is really different from Java to broaden your horizon. Maybe something functional like Clojure, or closer to the machine like C or Rust.
The one caveat I'd add for this specific scenario is that learning a new language is only useful if you're gonna learn a new programming paradigm Otherwise learning another oo language wouldn't yield much except for learning a new syntax. In this case I'd learn a specific api, like jdbc or jms for example.
&gt; Otherwise learning another oo language wouldn't yield much except for learning a new syntax. That's not true - other OO languages can teach someone who knows only Java a great number of concepts: duck typing, prototype inheritance, extension methods, asynchronous programming, modules... Even the act of learning a second language with the same basic concepts but different syntax can be a very important step towards making you a polyglot programmer. And of course employability hinges very much on which languages you know and very littler of how many different paradigms they represent.
Thank you for the detailed reply. We don't want to convert the application to anything. We're building out a new module in the application, so we won't be touching any pre-existing JSPs, if that changes things. &gt; This might cause architectural fragmentation because of two methods, We're aware of that and decided it will be worth it in the long run. &gt; Another consideration is to have a cli for the the presentation layer of your project, much like grails or play. What exactly do you mean by that?
It's an internal application, enterprise customers buy this solution for internal use. Since they're already marketing this as a cheap solution, there shouldn't be any problem to require certain browsers. But then again, the customers are companies, most likely with outdated IT so who knows. I for one will strongly be pushing for going with evergreen browsers basically. No, there is no automated testing in place currently.
Thanks a lot for the detailed reply! &gt; It all depends on how exactly you manage the connections. We recently switched to use HikariCP. Basically, every JSP grabs a connection at the beginning and passes it along. You don't want to know that the JSP also saves it in a session-scoped bean and uses the connection through that bean multiple times... But essentially, the connection management is very simple. One request gets one connection, and the connection is manually passed around in the business logic. However, the business logic also gets an object which would let it acquire a new, different connection. All with the aforementioned temporal coupling with the JSP setting the connection in the session-scoped bean and reusing it through that bean multiple times further down the road
Maybe I've given the wrong impression, it's not about going SPA really. Sure, there is a demand for a more "modern" feel to the application, but we're also doing this (primarily) for maintainability. 
https://gist.github.com/Schaka/4a053c4b0e88e49cb6baeb66d18cf84c Take a look yourself to see if people with no frontend experience could handle this. I'm not sure how familiar you are with Spring-MVC, but basically the SearchParams object is injected into the controller method by parsing the JSON payload with Jackson, whereas the Pageable (a spring-data component, controlling paging) is parsed from request-params and then injected into the controller method. There is no reason to use Spring MVC, but for the example it's small, simpel and I had already most of it done for a project (that I can't share here, I'm afraid).
Try ZK if team members are not familiar with modern front-end javascript development (IDE, build environment, ES6/Typescript) But you should be noted that ZK Community Edition lacks some features, such as render on demand, server side push... 
Spring Config Server gets the config property from git when property is not found in Vault.
Created for my [JavaFX Linux OC app](https://github.com/BlueGoliath/Goliath-Overclocking-Utility-FX). Heavily inspired by my favorite GTK theme. [here](https://imgur.com/a/exETN) is a screenshot compared to the default theme. There are some difference between it and the default theme in layout compatibility because of the tabpane being slightly a smaller height. but ill fix that later. To apply it to your project, copy and past the file to your JavaFX projects's src folder and add it to your scene.
Why is the code not indented? Is that just my mobile browser making it look strange?
Not enough SQL content
My terminology is imprecise because I'm not really familiar with where the line is between the two, but as JSF is written on top of JSP, I lump them together. XPages/XSP is analagous to JSF, which if the analogy holds, is just a tool for compiling the templating tools into JSP code. But I'm still writing custom servlets and action/event listeners and such, which I've generally learned by googling JSP, and they are all part and parcel of building my applications. So I'm not sure where the line between JSP developer and JSF developer is drawn or why. Sorry if my input turned out not to be relevant.
1) language selection has already gone wrong 
SECTION | CONTENT :--|:-- Title | Securing Secrets with Spring Vault - Rob Winch Description | Presented by Rob Winch of Pivotal at the Kansas City Spring User Group on February 1st 2017. Spring Vault: http://projects.spring.io/spring-vault/ HashiCorp Vault: https://www.vaultproject.io/ Source Examples: https://github.com/kcsug/spring-vault-talk Rob Winch: https://spring.io/team/rwinch Kansas City Spring User Group: https://www.meetup.com/kc-spring/ Length | 1:23:35 **** ^(I am a bot, this is an auto-generated reply | )^[Info](https://www.reddit.com/u/video_descriptionbot) ^| ^[Feedback](https://www.reddit.com/message/compose/?to=video_descriptionbot&amp;subject=Feedback) ^| ^(Reply STOP to opt out permanently)
I have never really understood the need for Lombok. All of the big three Java IDE's produce getters/setters, and equals/hashCode/toString with a couple of simple key strokes. Then I don't have to worry about if whatever black magic lombok is doing at runtime plays nice with my other libraries like hibernate. Not to mention having to add a step to the build process. Stop being lazy and just take 10 seconds it takes to tell your IDE to produce all of that code. Adding yet another dependency, and especially a build time dependency, isn't worth it.
the problem with inversion of control is that interfaces have absolutely no guarantee of behavior. When some class implements a Collection interface I only know that it has an add and an iterator method. But when I call add(something) on it, I am expecting that something to appear in a later iteration. There is however no guarantee of it. Without inversion of control that's not a problem. If somehow that something gets lost, I can just look at the code of the other object to see whether the bug is there or with my code. With inversion of control I can't do that. I have absolutely no way of knowing which object I get in production. And thus if there is a bug, and my code is correct (or I believe it to be) there is absolutely nothing I can do as I don't even know whom to assign the bug to, and my manager doesn't understand why I can't fix this simple thing. Now even without inversion of control there are some classpath idiocies where I only think I know which object I have. But I'd consider that a problem just as much as IoC. 
Thing is, most people don't need to inject a `Collection&lt;Foo&gt;`. They probably need a `FooService` or a `FooManager` that has *higher-level* operations than just "add this to the collection". &gt; I have absolutely no way of knowing which object I get in production You should not care. There should be a known, documented contract, and if the other party doesn't conform to that contract you should be able to put their feet to the (metaphorical) fire. (This is Java; you should be able to get a list of all implementations of the contract type). Keep in mind that one shouldn't use IoC / DI for every little thing; like everything with life, moderation is key.
While it is common to use interfaces, there is nothing in the pattern that makes you. But that aside, when you write a class that relies on dependencies, you should be able to, well, rely on them :-)
&gt; one shouldn't use IoC / DI for every little thing Yes! If there's anything annoying in software, it is this all or nothing stance that developers often seem to take to things, whether DI, using interfaces, documenting, test first, etc.
picocli v0.9.7 is just released which adds support for nested subcommands. (There are some [API changes](https://github.com/remkop/picocli/releases/tag/v0.9.7).) It may take a few hours for 0.9.7 to become visible on Maven Central.
Looks pretty nice! I personally use the Arc theme so it would be nice if there was a JavaFX theme similar to that.
&gt; Finally, there is DI’s sibling: Service Locator. This is a pattern similar to dependency injection, and technically it is also an implementation of Inversion of Control. To call SL an implementation of IoC and a "sibling to DI" is to not understand what DI is about at all. And the author does seem to get in that direction for a bit, as he demonstrates how to do DI without frameworks, but then he quickly goes back to talking about containers. DI doesn't require containers. It's not about containers. And containers and locators are not by themselves IoC at all. Looks like the confusion continues. 
I am also kinda disappointed by the article as it started with the story about discussions between Java, Scala and Python Devs. But later on we have gained nothing concerning the other languages. For python it is quite clear: DI is much less explicit, as you often can just change a default dependency at runtime if you need to. How about Scala? AFAIK there are also some different approaches, how to solve DI, for example the cake pattern. Can someone probably tell more about the situation there? 
DI pattern in itself helps in the write of unit tests for classes that follow it by allowing to mock easily their dependencies. DI frameworks (or service locator pattern) are particularly useful for stateless service classes as they replaces the (anti) pattern singleton. 
The article has good intentions in general, but there are several statements that are simply wrong. I really like the history part of EJB3 and Spring but I have objections in the coming points. **Other languages** &gt; It simply isn’t a fit for some languages, and for other languages, the community has a different narrative that means they see the merits of the pattern differently. Clojure is a functional language, and Python supports duck typing, so the fact that DI is not as prevalent in those languages is not a fair comparison. Python can also modify objects at runtime. **Required deps** &gt; it isn’t clear which properties are required to be set before use; Spring supports the "required" property on injection annotations so it is perfectly clear which are required and which are not &gt; there is no guarantee that clients will satisfy dependencies before trying to use objects; There is. Spring will detect missing deps, print an error message and your application won't even startup. **Constructor vs setter injection** &gt; In my humble opinion, only constructor injection is worth using Wrong. There are several valid cases where you have optional dependencies, so setter injection works just fine as well. **XML vs Java configuration** &gt; The earliest Spring versions required you to configure your dependencies in XML files. I’d avoid this at all cost, as it hardly saves you any code. Depends on your use case. Some people think that the model of the application should be "pure" and not have any dependency annotations (Especially if it is reused in another context). Also the XML files centralize the dependency graphs, which is a must for some teams. I would say that annotation based injection should be used by default, but the XML one has still valid uses **Lightweight DI frameworks** &gt;My personal favorite framework in Java land is Guice, which provides a nice mix of explicit configuration in code with some heuristics Can you list some features that are supported by Guice and *not* Spring? Have you also looked at [Google Dagger](https://github.com/google/dagger)? **Service locator** &gt; Finally, there is DI’s sibling: Service Locator. Hell no! This madness with design patterns must stop. It is not 1994 anymore. Service locator is an anti-pattern today and if you are using it for new projects, you are asking for trouble. (Side point, Singletons and Factories are also anti-patterns today and are not needed if DI is used correctly) &gt;If you don’t want to use dependency injection, using the service locator pattern is the best alternative in my opinion. It is the worst alternative. It couples your classes and makes testing next to impossible. I would take manual injection instead. &gt; In practice, I think it is it is fine to see patterns mixed Worst advice from this article. If you work with a team, you need to decide some common guidelines and follow them. Stick to one solution and follow it. This will make life easy for junior developers as well. Finally I am not sure what it is the real target audience as the article talks about Java but shows .NET like code.
Not really back then. Of course, it's a slight exaggeration :-), but the first versions of EJB involved lots of busy work for no good reason. The purpose of DI as with many other patterns is to find ways to write software in a scalable and maintainable fashion. DI helps you isolate the code you write from the environment in operates in. Is there more to it in your opinion? The practice of DI... that largely depends on what sort of DI you use and if you use a container and if so, which.
I honestly can't tell if you're agreeing with me, arguing with me, or just chatting. Either which way: thanks for the response. Cheers! :)
I guess the confusion is that even SL can come in flavors; you could have a container you pass in to locate dependencies, or you could implemented SL as a static factory, which would not be close to DI at all. I plan to tweak the article though.
The Service Locator pattern has nothing to do dependency injection, except that both are ways of abstracting the lifecycle of dependencies from classes that need them. Dependency Injection means that dependencies are provided to the class, either through constructor arguments (constructor injection), setters (setter injection) or directly setting fields (field injection). In the most primitive sense, DI is implemented in the `main()` method, where the program's runtime objects are instantiated and assembled. However, this can get tedious, especially if you want to do fancy things like AOP. Thus, containers come in very handy. But the key point is that the class that requires dependencies could care less about any of this. Thus, DI is the Hollywood Principle, *don't call us, we'll call you*. With the Service Locator pattern, the class that requires dependencies has to look them up. In classic JavaEE, the service locator is the `InitialContext`. The class may not be responsible for dependency management, but its dependencies are not handed to it, it has to ask the service locator and be aware of it.
&gt; the problem with inversion of control is that interfaces have &gt; absolutely no guarantee of behavior In any properly designed system, implementations of interfaces will follow the [Liskov Substitution Principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle). If they don't, the system is not properly designed. If your system is not properly designed, IoC is the least of your concerns. The entire purpose of interfaces is that they make it clear what behavior is expected, so it is easier to adhere to the contract. The only way to avoid this problem is to avoid abstraction altogether. Best to avoid fire too, since you can be burned by fire.
Collection.add() is a bad example because it's an optional method and may throw UnsupportedOperationException: https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#add-E- Eg Collections.emptyList().add(123);
I might install Arc theme and see what I can do. This theme is released under the MIT, BTW. You can absolutely make your own based off of what i''ve done here or continue my current work! I used(and highly recommend) Agrave and gtk3-widget-factory to get the colors from the GTK theme.
This is fuzzier than you're making it out to be. In both cases the dependency-requiring class gets an arbitrary dependency. In both cases the dependency-requiring class asks for a dependency of a particular type, either by e.g. the constructor in DI or by calling some SL that it has as much control over as the constructor parameters in DI. SL could even pass in a service locator object to the constructor of the dependency-requiring class, and then it essentially *is* DI.
I don't think the distinction is as clear as the other commenters are making it appear. See [my comment](https://www.reddit.com/r/java/comments/6ftw9n/dont_like_dependency_injection/dilk7vs/) here.
Seems pretty clear to me. DI stands for dependency *injection*, which means dependencies are being *put into* the class. That's what the word injection means. With a service locator, the class has to *take out* its dependencies from the service locator. This is not injection, it is suction. Thus, the service locator pattern cannot be an example of Dependency Injection. It would more accurately be an example of Dependency Suction. Furthermore, what is the point of Dependency Injection? It is a means of a class specifying its dependencies and depending on someone else to arrange those dependencies. If you inject a service locator, all that says is that the class depends on a service locator, which defeats the purpose of dependency injection.
I disagree. In the case of DI, the constructor of a class is a contract to dependency inject. In the case of SL, you *can* receive an SL object in the constructor, which results in the same contract and abstraction. If the class specifies its own service locator, *and* that service locator is not a singleton, then I can see how it would be different. Otherwise, SL and DI are achieving the same abstraction in the context of the application (although you can edit the singleton service locator and effect changes in all classes that use it, which I agree is different than DI where your dependency is specified by the caller of the constructor). I am not saying they are the same thing. Rather, I am refuting the strong claim that they are barely comparable when in fact they are very comparable.
If you've seen the syntax and don't like the way its laid out I doubt anyone could change your mind
Why would we try to change your perception of the language? If you don't like it, then don't like it. So what?
Why do you need us? If you like Java use it. Otherwise don't. There is plenty of documentation around on pros/cons. For starters you do not have to manually manage memory. You also don't need to write memory allocators. You don't suffer from things like stray pointers, multiple inheritance graphs, operator overloading orgies, spaghetti macros etc. 
I'm open to ideas. I don't hate Java, and perhaps by asking those who have experience with it I'll have a better understanding of why it's such a good language 
Java is a general purpose language. It's good for general purpose programming. It's probably not a language you would choose if you wanted to land a rocket on the moon.
Java is probably the best language for "I have 1000 engineers" it remains fast and performant at ridiculous sizes, with the jit, and a great thread implementation.
The thread implementation is one of Java's weaknesses. The way threads interact is full of undefined behavior. For instance, if you change the value of a non-`volatile` field in one thread, the other threads may or may not see the new value, at some undetermined time in the future, maybe. If you change the values of multiple non-`volatile` fields, other threads may see the new values in some of those fields, but the old values in other fields. Unless all threads involved are `synchronized` on the same object (or use the same `java.util.concurrent.locks.Lock`) while reading/writing the fields in question. Then, and only then, are the fields' values guaranteed to be up to date. There is no automated checking of any of this in the Java compiler or run-time system. You're on your own. If you screw up, then fields will sometimes have incorrect values, and other times have correct values. If you then run the program again, it may or may not run without a problem. These issues extend to using thread-unsafe objects without proper synchronization. For instance, if one thread is writing into an `ArrayList` and another thread is reading from it, the reading thread may get strange exceptions, unexpected `null` values, old values, etc. “Fearless concurrency”, it ain't.
One of the many examples of shockingly bad design that has managed to persist in Java. They went to all the trouble to support interfaces as a first class concept and then the API developers forgot how to use them. Even though the JDK API is probably the strongest feature of Java, the sloppiness displayed in some sections (I'm looking at you Swing) is infuriating.
[removed]
I think there are two Javas, the &lt;= Java 7 version and the &gt;= Java 8 version. Reading and writing code In each segment is vastly different. Streams and 3rd party stream func additions, default methods, the time library etc have changed it. That said, I would not pick Java, but I would pick the JVM. Groovy, Scala and Kotlin are more fun languages *for me*. If you are web oriented then frameworks like ratpack, vertx and rxjava let you say say goodbye to servlets. And gradle 3 reloading is amazing. There are some awesome reasons to pick the JVM whether you like Java or not.
The JVM has portable multi-threading across operating systems and across system architectures. That alone shows DL is a genius. This is besides the fact that is was way ahead of everyone else to do anything like that. The performance of the threads is also great. Yeah, its not Rust, but Rust had another 25 years of research and work before they brought their solution. &gt;For instance, if you change the value of a non-volatile field in one thread, the other threads may or may not see the new value, at some undetermined time in the future, maybe. If you change the values of multiple non-volatile fields, other threads may see the new values in some of those fields, but the old values in other fields. Yeah, that's called a race condition. Don't do that. Again, its not Rust, but the threading is still better than most. &gt;Unless all threads involved are synchronized on the same object (or use the same java.util.concurrent.locks.Lock) while reading/writing the fields in question. Then, and only then, are the fields' values guaranteed to be up to date. The necessity of locks or synchronization on mutable memory is required everywhere. Either be immutable or use locks. Most of your arguments are basically use Rust, or a functional language instead. And honestly I agree with you. But when it comes to writing portable managed parallel code, Java is going to be a better bet in most work places, than in getting people to learn a new language. And as a counter example, do the same in C/C++ which is what Java was improving upon. But my main point about thread implementation was actually about performance, which is extremely good, better than system threads/processes in many cases. They do require knowledge of parallelism, but just know how to write parallel code.
SL was slow, DI works well at software construction time but is a real pain when debugging. Tightly coupled, OO Java is where we need to get back to.
Dependecy Inversion, not Dependecy Injection, they are [not the same thing](https://lostechies.com/derickbailey/2011/09/22/dependency-injection-is-not-the-same-as-the-dependency-inversion-principle/). You can still invert dependencies with SL, it's just harder to express the dependencies externally since they are hidden behind the service locator.
Some Scala projects use a [Reader monad](https://stackoverflow.com/questions/14178889/what-is-the-purpose-of-the-reader-monad) to do dependency injection. The Reader monad abstracts over DI boilerplate in a type safe, compile-time verified way, just like how the Optional monad abstracts over null checks in a safer way.
You're welcome, I'm glad I could help you! I'm sorry if I didn't bring any more technical information, but the most important part of it has already been covered kinda (memory management, jit, thread stuff, etc. If I can think of something, I might reply here again but it's almost sleep time for me). Anyways, good luck on your research!
you will get better response in /r/androiddev
I think you should change your mind on programming languages rather than Java. They are tools to get things done. If your business model, application design is suitable for Java, then pick Java. You want to create a windows desktop application, sure you can do this with Java but C# with .Net would be better choice. Want to develop an application for linux, go with C++ or perl. In my opinion every programmer should have tools in his/her arsenal even though they always have one sweet beloved language they know very well. Yes it is verbose. This is an objective fact. Not liking verbose languages is not an objective fact. If you don't like verbosity then no one can change your mind : ) Pros of Java for me: - Huge framework, library, documentation, community. - Almost write once run everywhere. - Highly scalable and secure. - Backward compatible. - Excellent IDE support. - Excellent Profiling tools. - Android. - Despite the rumors, it is fast enough. Not as fast as C++, but fast enough unless you depend on nanoseconds. Cons: - Garbage collection hiccups. System "halts" for a short amount of time. - Might get quite complex to set up for certain type of projects. If you want a very simple web application node.js can be written &amp; up &amp; running in matter of minutes. However in java it takes time. - Bad UI design tools. This is a bit subjective but no matter what Java tech. you use, Swing, FX, AWT etc, it always feels "weird" and cumbersome to create. 
Haha. I'm currently viewing this on an **Android** phone. I once told a friend that if it weren't for Android, Java would just be another programming language. The fact of the matter is, Google is actually using a fork of Java, and that caused Sun/Oracle to go bonkers! Anyway, yeah, I do need to start looking at programming languages as tools. I remember seeing this meme where each programming language was compared to a sword. Python was a lightsaber! I forgot about the others, but you get the gist of it.
I too struggle with Java's verbosity. It stems mostly from limited type inference. This is a language design choice, as Groovy and Scala prove that the JVM itself isn't the limiting factor. My biggest problem with Java however isn't the language itself. Instead, I dislike the inconsistencies in its APIs and the wasteful boilerplate coding required to scaffold simple functionalities. It's specifically the way inheritance works in Java, that contributes to code duplication. That said, let's compare language and API inconsistencies to PHP. Holy cow! I doubt I'll ever encounter a worse language. Does PHP have 2 methods that behave the same, follow the same naming convention, and order their arguments in the same order? I have used PHP for many years, to a fairly complex degree, but I'll choose Java any day. And PHP also has inheritance issues that cause us to duplicate wasteful boilerplate code. It isn't a Java or PHP issue. It's an O.O. issue. And that's where comparison of Java to c and PHP break down: c is imperative, PHP used to be imperative and can still be used that way. So let's compare it to Javascript instead, another language with which I can boast decades of experience. Javascript used to have prototype-based o.o., plus type inference, plus a weak type system. (I won't speak for ES6.) That made it require almost no boilerplate. And object members and fields could be aliased. Java can't do any of that. Why not? Well, Java was designed to be a safer and saner c++. One that was restrictive yet simple to learn, so that junior programmers could write new applications with confidence and speed. So it needs strong typing, and class-based o.o.. And it didn't used to allow library programmers to override object method implementations on a whim (like in Javascript), sabotaging an application. (Reflection changed that.) And it brought managed memory, cross-platformness, and (with Java 8) ease of parallel computing. At the end of the day, I don't want to map memory and choose between near and far pointers. I want the programming language or its interpreter to handle that. I don't want 3rd-party libraries overruling behaviour on which my applications depend. And I want strong typing, so the compiler can catch data type problems before they destroy valuable data. And Java can do all that, and more. My issues with its insistence on duplicating code I'll take for granted.
Did i look at the right post? I see execution times and not anything about memory usage? **edit**: this page is completely different when viewed on mobile. doesn't show anything but execution time
Is it fair to compare Java to .Net Core, a fairly recent technology in very active development? For comparison, the road map is to go for v1.6, but the version 1.0.1 was tested. Although both technologies are cross platform, a different platform may show different results, won't they? 
You must be thinking about another language, Java sucks at literals.
My computer science professor at Stanford told me "mem" is short for memory.
Value types and RAII with proper scoping means that structures are deallocated as soon as possible, and only take up stack memory. It means fewer garbage collection calls, and before garbage collection runs, it means more free memory. It also helps prevent cases where garbage collection can't free an object because there are a chain of references to it from some persistent object.
Agree, it's not a big change but a welcome change in the right direction 
try viewing it again on mobile
a not very ideal CSS usage :D
Care to expand? Looking purely at these tables Java does seem to be doing better with both cpu and mem.
&gt; I once told a friend that if it weren't for Android, Java would just be another programming language. Java _is_ just another programming language. So is every other language in the world. Some languages are just used a lot in certain areas.
then what is the point to referring to super old versions. If you mentioned EE at least you should have compared it to EJB 3.2 or CDI 1.2; there is also DAGger 2 for example which does basically everything how you would wire it manually.
It use: dotnet 1.0.1 005db40cd1 (.NET CORE v1.0.1) I'm pretty sure C# would perform better is used .NET CORE v2 https://blogs.msdn.microsoft.com/dotnet/2017/06/07/performance-improvements-in-net-core/
What words exactly are you referring to? C++ definitely is more verbose than Java, minus getter/setter hell. If you want something less verbose than Java, look at Kotlin. Or if you're really into functional style programming, Scala.
The cost of linq is generally worth paying as it saves you so much boilerplate code. 
Looks just fine on my iPhone in portrait mode.
According to the numbers Java is using 25% less memory than C#. So not quite on par.
But would you meet jello?
scala does. java probably will too someday if scala continues to be the stomping grounds for new java features.
I'm a huge fan of Java for its clarity, speed, and predictability, but Java will never have what Scala has. Only now is Java adding map literals, and they're really weird. We'll be lucky if Java gets monads, lazy evaluation, and persistent data structures in a decade.
Not really, the functional style is not much longer and you get better code-assist and more functionality. edit: (lambda style vs sql style.)
You dont need interfaces for DI. Just inject the implementation. So, DI can be done with as little as 2 classes, one injecting the other. If, at some point, you want multiple implementations of a class...then extract the interface with Eclipse. and create a second implementation. This is a 2 minute job. 
Sorry I meant lambda style vs sql style. 
Hence my disclaimer! Figured it was good to be open upfront.
In terms of language evolution, things can be done fast, or they can be done right. One must respect the time taken by the Java Platform Group, as they consider countless paths forward, and the consequences of each. I suggest that you watch Brian Goetz’s talk on stewardship: https://youtu.be/2y5Pv4yN0b0
The Java implementation uses ExecutorService (for binary-trees at least), might a ForkJoinPool yield better results? Especially for tasks that are easily split into smaller tasks, for instance something like a merge sort. I've tried some benchmarks, and found similar results for running time between the two.
TL;DR: GA set to 2017/09/21
ForkJoinPool is an ExecutorService. ForkJoinPools are good for big systems doing lots of things, but they aren't so great when you are trying to with performance benchmarks. First, a big problem is that they introduce quite a bit of overhead. Work stealing doesn't come for free, neither does parallelism targeting. For a large system, that doesn't matter, in the benchmark game that could be the difference between winning and losing. FixedThreadPool has pretty much only the overhead of thread creation. The queue management is very low overhead wise. ForkJoin will create more threads, it is just the nature of it. However, thread creation is costly and can slow down the rest of the system due to thrashing from too much context switching. When tasks aren't really inter dependent, a FixedThreadPool will plow through the work faster than a fork join pool. However, using a fixed thread pool with complex systems and hard to predict interactions is just begging to run into thread starvation. Fork Joins do a much better job of stopping that from happening.
I dislike the memory measurement because it really only tells a fraction of the story. All the memory allocated by Java is not the memory currently being used by java. If they want java to "win" or "lose" here, it is a simple matter of tuning -Xmx and -Xms until java is the winner or loser on memory. Most of these applications require peanuts for memory anyways so you could get pretty aggressive. Use the parallel collector, and it is likely that the runtime is hardly affected by the extra GCs. Java's (and probably C#s) settings are tuned for long running server applications. In those, aggressive heap growth makes a lot of sense, because allocating heap space is expensive.
Thank you for your explanation.
There's Java 8 streams, but they're still very limited compared to LINQ :/
I think the article should make a clearer distinction between immutable and unmodifiable since they're quite different. In fact of the language and examples seems to confuse immutable with unmodifiable. E.g. &gt;Creating a new immutable list in Java (before Java 9) is not very clean. Creating a small unmodifiable collection in Java involves following steps. The code example then has `Set&lt;String&gt; immutableSet = Collections.unmodifiableSet(set);` On the up side I didn't realise the Java 9 `List.of()` seems to be properly immutable which is nice.
Because I was using it to sketch the history of the pattern? The current version of EE is what it is for a large part due to DI containers (and ORMs)
Works fine on my Nexus 9.
whose fault is that? oracle's for having supported the openjdk project for years, or microsoft's for having spat on open source and cross platform computing for years?
bring this up to the creator of the benchmarks game. the game hasn't been entirely fair to java and jvm languages in the past (like letting c programs dip into libgmp while java has to rely on the stdlib's ineffecient bigdecimals and bigintegers). 
It is useful, but it's not critical. The cost of writting: Map&lt;String, Integer&gt; example = new HashMap&lt;&gt;(); example.put("one", 1); example.put("two", 2); example.put("three", 3); As opposed to (from Kotlin) val example = mapOf( "one" to 1, "two" to 2, "three" to 3 ) isn't exactly high. There are much more important things that the Java developers can be doing.
Display seems to be width based ... viewing on my phone, I see more details when I turn to landscape orientation.
5 Tips: Tip 1 to Tip 7. Something does not compute. 
That's a silly argument, Microsoft is kicking ass with DotNet Core. Let's see how it compares in a couple years when the tooling and standard library has comparable maturity to the Java ecosystem​'s.
Hi all. Thanks again for the feedback. I tweaked the article and talk about containers rather than frameworks, and for the most part got rid of the service locator part. What I had in mind for service locator was really just DI but passing in the container reference rather than dependencies directly (which can occasionally be helpful, though I was wrong calling this a patter and ignoring the 'official' pattern which does seem more akin to just an indirection of static factories).
[How Valhalla will be announced](https://www.youtube.com/watch?v=CZ_VFJn2kJM).
This isn't a meme language we don't want any meme shit here
Simple getters and setters don't need to be tested, they are too simple to fail. Equals is easy to test.
And propaganda.
Isn't the saying "apples and oranges"?
I should have phrased it better, but the limitations IMO are two things: first, exceptions don't really work with lambdas well, you have to catch them within the lambda which makes things more annoying. Second, no extension methods means you can't add you own behavior to streams without ugly syntax like `myThing(list.stream())...`
Yes, it is. I was trying to say that the comparison was not "apples to apples".
And there is something similar coming in Java 9. Atleast for the first 10 items and immutable map.
Comparison between implementations of *different* programming languages *is not* "apples to apples".
&gt; Most of these applications require peanuts for memory anyways so you could get pretty aggressive. Unfortunately everyone seems to have a different personal preference about whether these tiny tiny programs should be made to use more time or more memory ;-)
You can't make me talk! Who sent you? Time to add another layer of encryption to my project.
&gt; if you change the value of a non-volatile field in one thread, the other threads may or may not see the new value ITT the definition of volatile - thanks captain obvious
THEY sent me, I will find out
I ran into these types of bootstrapping issues when building https://github.com/cretz/stackparam. I just try not to call back into the JVM at load time or any other time before. See https://github.com/cretz/stackparam#how-does-it-work for the hoops I jumped through.
But... in this context where it's a "Computer Language Benchmark Game", it is. That's the whole point of the site in question. Within that context, it is useful to compare implementations in various languages to each other because, if they are using the same general algorithm you can see very noticeable differences in memory consumption, CPU use, and even code size. You can argue that's not useful beyond broad strokes comparisons, but it is useful for at least that.
Well, this definitely looks interesting! Added to my backlog of things to poke around :)
Yes, yes, and yet when someone makes a statement like "C is many times faster than Python", or "Rust is almost as fast as C", you can still find and use evidence of that here. There are many other aspects of languages, e.g. Erlang as mentioned in your link that these comparisons don't even begin to address but the comparisons on the aspects they have in common (memory, CPU, code size), is still valid.
That looks awesome, I'll sure be looking into it
Oh you're correct. I messed with it a long time ago. What I was actually remembering was using the sun VirtualMachine class to attach to processes with the agent. For some reason I remembered the whole thing as being from sun's packages.
In the past, Java programs that used libgmp were accepted - just like the C programs that used libgmp. Stop making stuff up.
But ... garbage cleanup.
i could've sworn when I did some submissions for the benchmarks game that libgmp was not yet directly accessible by the jvm programs, but if you insist it's always been accessible then i'm not gonna argue further. it's been over 5 years since i last made a submission so i can't say that my recollection is accurate or not even a false memory.
Having fun writing the lightest, smallest hybrid web/desktop app I can, using the built-in Web server in Java SE and a JavaFX webview as a client of the app. So far I have Web services, a UI, and a working persistence tier in under 100k. It's been a fun exercise.
i still don't trust MS cause they've frequently talked out of both sides of their mouths wrt to linux and open source. 
Teaching myself R and Android Studio.
simple library system
I may have missed them, but Follow buttons next to their handles would have been nice.
I'm working on a custom, lightweight identity management web app for SMB. Hopefully it'll become a Saas offering.
Yeah, you can generate them in java by using extra tools that do some byte code magic. They are boilerplate. But C# and Kotlin, as well as Scala have a much shorter syntax for getters and setters, they let the compiler handle most of it. So you maintain encapsulation by methods, but your syntax doesn't get bloated either. Don't assume other people didn't go through university, just because you lack knowledge on the aforementioned languages. 
eh, javafx has been open source for years.
Yeah, they've still got some fences to mend, that's for sure. But... the last few years have been promising, so there's that. At this point, they could still take their ball and go home I guess, but there's a lot of IP there now that's just FOSS no matter what they do. In short, I don't think they'll do that. They're about as FOSS friendly as Oracle really and I doubt either of them could really remove that from their mix in the foreseeable future without seriously hurting their own concerns.
Non-Mobile link: https://en.wikipedia.org/wiki/ANTLR *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^77677
I'm still learning.. I'm trying to get understand lambdas and make the most of them. I also almost know nothing about the standard library and what it offers. 
I'm just trying to get the lawn mowed weekly.
I'm making a game with AWT to be put in the arcade cabinet I built. 
Now it uses: 2.0.0-preview1-005977
That's normal in any company. Red Hat says a lot of shit about Windows to get customers.
Personal application. The user-facing components are in Java - with a web ui, of course - but I'm considering redoing chunks of the backend in Elixir. 
Furthermore some of these comparisons are just terrible. The binary tree example is super apples to oranges - no C# code looks like that, dear god that code was garbage.
ms did more than say shit about linux
Streams are way more verbose from my experience using them... additionally, there's more explicit typing than C#, which takes me away from being expressive (while having the type system support me) to having to figure out how the type system can be happy.
Getting a ton of Spigot plugins ready for the new Minecraft version that just came out.
Work: Creating an application to allow State's Attorneys to file documents with the courts electronically, rather than printing them out and physically submitting them. Then it tracks rejections and allows users to tack and resubmit rejected filings or additional filings to a case.
Minecraft modding, something I'd do if I had the time
[Contribute your programs](http://benchmarksgame.alioth.debian.org/play.html) But before you do, check [the other C# binary tree programs](http://benchmarksgame.alioth.debian.org/u64q/measurements.php?lang=csharpcore) to see if your approach has already been done.
Why is it that angular 2 is not yet recommended for production?
Still a student/beginner, but I made this widget thing that I think is cool, with 3 colored translucent arcs that spin around a common center, and the current time determines the length of the arc.
Its important to note that that page is comparing a preview version of .NET core 2.0 to Java 1.8. A more correct comparison IMO would be against the gold release of the full framework v4.6 or higher. I still would not be surprised if .NET was a bit slower or used more memory but I would think it would be better to compare equivalent run-times in their gold released state.
I've recently made a switch from learning JS to learning Java and a little android development. I've given myself 9 months to learn enough Java to crack an app out! Should be fun.
&gt; the cake pattern No! Widely considered an anti-pattern, now referred to jokingly as a Bakery of Doom. Either Auto-Wiring stuff, or leaving those things implicit seems the way to go.
Region Of Interest (ROI) detection for sensor data: [http://myrdocs.azurewebsites.net](http://myrdocs.azurewebsites.net) Hobby, then briefly work, currently a hobby again...unless I pick up more funding.
learning Spring and Angular
I work building ocean going robots at [Liquid Robotics](http://liquid-robotics.com). I mostly work on the infrastructure parts such as logging, communications, service loading, etc. Our entire stack, robots and shore-side is written in Java on Linux. 
Still trying to figure out Java for Web w/ the rather exquisite Oracle ADF framework people used in my company when building those legacy systems... those of which suffer upgrades on a weekly basis, yet. Also learning quick development of web-services through Spring Boot, really nice that is. 
http://kweb.io/ A web framework that makes the barrier between web server and web browser almost invisible. You can "bind" a DOM element in a user's web browser to a field in your back-end database, and the framework will update the DOM element in realtime if the field contents change in your DB. It takes the "single source of truth" principle and extends it across your entire stack. Ok, it's Kotlin - but close enough to Java. It uses Kotlin's [coroutines](https://github.com/Kotlin/kotlinx.coroutines/) and DSL-friendly syntax in all the ways you might hope it would. If this interests you, I'm looking for help with it :)
Of course. Like every software company out there.
Spring Boot and Vert.x I'm happy with both 
Heh. Not quite that bad. The WebView is far and away the heaviest part.
I'm making an overclocking utility in JavaFX called [Goliath Overclocking Utility FX](https://github.com/BlueGoliath/Goliath-Overclocking-Utility-FX).
That sounds like it would be fun to operate.
Making tough, pragmatic decisions does not make someone a train wreck. A lot of deep, analytical thought goes into the decisions they make.
Netbeans IDE has this feature. I don't know about the Oracle JRE but AFAIK the OpenJDK is perfectly OK to include and distribute. You can do an app image(app, JRE, and native executable) or a native package which will integrate with the host OS(.exe installer). Depending on the OS you may very well need to install a few extra things. I use this for my Linux overclocking utility just for the sake of consistency.
Play
Before you look to complicate the bills process, your it team should also solve the existing issue. This is likely a relatively easy fix... As Java executables are relatively well contained. Creating a bat or sh file that uses a direct path to Java instead of relying on path or profile should fix the issue, and will make the execution far more reliable.
Oracle ATG and no, I am not happy at all ...
Definitely! It makes mowing the lawn seem like less of a chore.
Guice, Jersey. It is a refreshing break from Spring.
If you have some sort of global state, you can use a singleton. That way every component has access to the same data.
Like a static singleton you mean? Is that really an appropriate use of static though? Is it conventional?
Spring Boot, and yes. While there are some drawbacks to an opinionated system, it's great for a large team. It helps remove a lot of the decision making otherwise necessary and favors falling in line (but allowing extension where necessary). I'm sure other options are good/great as well, evaluating all is probably worth some time.
Spring framework stack.. Akka
I try to focus on small learning projects I can write blog posts about. I've noticed that anything larger than a simple application that I can finish in a week never gets finished. [A bit like this](http://www.commitstrip.com/en/2014/11/25/west-side-project-story/).
JEE
Java EE, not super happy, but I guess it works. Spring Boot also which makes me more happy.
Grails
Are these applications running on Windows or a unix variant? The jre is set in the path on both OSs in which case a Java app will use which ever is set in the path. I know in Linux that it's fairly easy to set the jre to use. With Windows, it's a registry entry. [link](https://skarlso.github.io/2015/06/30/powershell-can-also-be-nice-or-installing-java-silently-and-waiting/)
Currently - [The Story](https://rskupnik.github.io/introducing-the-story) :)
End to End Encryption Library
Spring Boot, Hinernate. Not so happy, because they can lead to some really bad code i.e. all-in-one services, no immutable objects, duplicated business models (like Entities and DTOs, representing the same business thing), and so on... I tried Kotlin in our project. The language is awesome, but you cannot use all of its strengths because of those frameworks.
Apache Wicket. Pretty happy, and this comes from someone who isn't particularly fond of web development.
Came here to tell that. It still has a lot to go, but it's one of the best things that ever happenned to Java.
Why not?
My current thing is [Gaia Sky](https://zah.uni-heidelberg.de/gaia/outreach/gaiasky/) ([github repo](https://github.com/langurmonkey/gaiasky)), a 3D Universe kind of thing focused on [ESA's Gaia](https://en.wikipedia.org/wiki/Gaia_(spacecraft\)) data. The current public release contains the Solar System plus more than 600K stars from the TGAS part of Gaia Data Release 1. Next year, with Gaia Data Release 2, we'll be in the hundreds of millions camp.
Can I get this somewhere? Sounds cool.
Why not happy? Are you using JBoss Wildfly, or maybe Liberty, or are you on a dinosaur app server?
Nice!, could you elaborate on the incentive?
Spring Boot + Lots of Spring data + spring cloud and some akka. Happy with all, looking forward to reactive streams with spring
Probably one of the coolest things I've ever seen. Do you know if there are any small-ish, affordable drones you can program in Java? I'd love to do something like that at home. Especially as a learning project for Kotlin.
What I can't understand is how the hell you like Arduino IDE, one of the worst IDEs I've ever work with.
Side Note: For folks new to Java, OpenJDK is the OSS project that forms the base of Oracle's and other vendor's Java. It's been very difficult for OpenJDK developers and users to get solidly built and tested binaries for all platforms for their research and development purposes. Although we don't provide commercial support, the goal will be to provide binaries just as good as anything coming out from the Vendors (in fact some vendors may choose to build on top of artifacts coming out of our farm). It's also useful for say an SAP engineer to submit a patch for ARM64 and have that tested on MacOS, Windows, x86 and so forth before pushing that patch for review.
try viewing it again not in portrait mode
Most recently, this: https://poetix.github.io/fluvius/index.html
I would not call it a framework, but GWT is great for javascript heavy apps (Single Page Applications).
jOOQ. Well duh, we make jOOQ, so we're really really happy with it ;)
Very happy with : ZK + Spring + Drools + MyBatis + JasperReports + RESTeasy Running inside JBoss EAP 6.4
Keep us up to date! This looks cool.
Going by your post history, (1) read up on Reddit's rules for self promotion, and (2) learn that no one wants to be shouted at by a post title.
Wicket was a breath of fresh air compared to Struts/JSPs. Have since moved over to AngularJS + Jersey and haven't looked back though!
Gamecontroller mapping utility: [ControllerBuddy](https://github.com/bwRavencl/ControllerBuddy)
Spring boot and I am very happy with it.
I think there was some licensing issue if you bundle Oracle Java, so if you use it at work that's something you might want to look into.
Spring It is well done technically. It is used widely so I get to recoup my time investment in learning it and it makes me more employable. Despite the hype of it being well documented, I find that it is not well documented and not well supported. If you have are doing something less than common with it where you can't find the answer on stackoverflow, it is incredibly hard to find help on the web about it. The books on Spring are terrible. Many of them only give you excerpts of examples so if you aren't well versed in a subject it isn't of much help since you can't see how the whole thing is done.
I used vaadin like 3 years ago. It was pretty good but felt that it created hard to maintain HTML and dealing with CSS was a bit of a mess. How is it now ?
If you use the Netflix oss architecture with boot it becomes very easy to use micro services and configure everything 
What's wrong with Grails? I'm using Grails 3 on a project now and it's been great. Version 3 is built on top of Spring Boot and the things it does for you out-of-the-box are pretty amazing. Very little code is required to get up and running with REST services.
Lagom. Happy. 
Linux, OpenJDK. Windows, Oracle.
OpenJDK on Windows and Linux. So far, no problems.
I've got Blueprint, Camel, Hiberate and we deploy OSGi modules into Karaf I very much enjoy the stack I work on.
Spring boot. Am happy with it.
Focus, mainly. OpenJDK seems to be heavily more focused and supported on Linux. Sure, it may work with Windows just fine, but I'd rather use a product that I feel I can gain support from no matter what. The only way you can get the "official" distributions of OpenJDK on Windows is through Red Hat, rather than OpenJDK's own site. However, it's been an eternity since I've developed Java on Windows. If you wanted me to really answer to "which one I am using" it would be OpenJDK for the better part of the last year.
I'm pretty excited about Kotlin (not mentioned on this list). It seems to have gained some traction now that Android supports it. The nice thing is that I can dip my toes in the water slowly by converting some low level modules first, like the domain model classes (mostly simple POJOs) and have them integrate seamlessly with the rest. I don't have to do a complete framework/language switch for my entire project.
Assuming you are on windows you could use WinRun4J. By setting vm.version.max, vm.version.min or vm.version you can control which JRE version you want it to look for. If you inclulde your own JRE you can use vm.location to set a path it and use vm.sysfirst=true if you want it to only use it as a fallback.
They're running on Windows. I'll take a look at the path in the machines we have had issues with.
Anonymous multiplayer chess for Android
I'm guessing it's related in one way or another to the first part of "Oracle ATG"
Spring on one project and yes, I like it. Serenity/Cucumber and RestAssured for a testing automation project. It's okay, but I'm not sure I'm using Serenity optimally.
We have done this with an app that runs a medical device, and so for regulatory reasons needed the specific version of the JRE it was developed against. We did something similar to what several others have mentioned with .bat files. The NSIS installer puts a copy of the JRE into a specific location next to the app, and does not add anything to the path or windows registry, so other programs are ignorant of it. A .bat file is then generated at install time pointing to the custom JRE location and the app's JAR file. We can even install multiple copies of the app to different directories and they will run on independent JREs. Makes it very handy for testing multiple versions side by side. 
What specifically? And what version are you on?
https://pivotal.io/training/certification
Testability and we are on 10.1.2, about to move to 11.2
I see your reply here now. How could ATGDust be improved do you think? I don't use it, but am genuinely curious. 
I think I can't really answer you: We have two applications, both with Vaadin, and the approach to its use is widely different. I can tell you that maintaining (is that even an english word?) the different views (The classes which correspond to each "page", thus, which generates the HTML) is fairly easy if the design around them is simple enough. Our "old" application is a hellish nightmare of abstract stuff, our "new" application has some abstract classes above Vaadin but most of it is really straightforward to read and maintain. For CSS we use scss, and besides a huge scss common file I don't dare to touch, we have one separate scss file for each view, so, unless some weird name collissions, getting CSS to do your biding is not a big problem. Also, each standard Vaadin component (Textfields, Option groups, that stuff) has its own class on css, so you can say something along the line of "v-nameofcomponent" and the application hooks directly without need of doing javaVariable.addStyleName("nameofStyle"); As a whole is not completely straightforward, but after some months, 40h a week of this, you end up getting it allright.
I use Grails and am quite happy with it.
 I just started a new job -- that's why I'm listing both of these: Current employer we use straight EE, it's been a learning experience but it seems to be very nice. Straight JDBC is so fast! At my previous employer we used Spring, Camel, and MyBatis. I really liked MyBatis and I miss it a lot, and I got to know spring pretty well by the end, but we never really used it other than for dependency Injection, which EE is similar enough in. 
It may be better in your mind (to compare equivalent run-times in their gold released state); but as the final release of .NET Core does not exist, it would certainly be wishful thinking.
False. https://java.com/en/download/faq/distribution.xml Can I distribute Java with my software? Yes, you can provide Java with your software provided you abide by the terms and conditions of Java binary code license. Can I distribute Java Development Kit (JDK) along with Java Runtime Environment (JRE) on the same CD-Rom? Yes, provided that you abide by the terms and conditions of the JDK's binary code license. Can we provide Java on a CD to ensure that people who do not have internet can install it directly from the CD? You may make Java available to users within your organization on a CD. And you may distribute Java bundled with your application to users outside of your organization. You may not distribute Java alone on a CD.
Wow! My first time seeing someone who uses it. Could you give more detail of your experience? Why did you select Axon? What was/is the part you most struggle(d) with? Any tips for someone who wants to start with Axon? Is it a web app? Do you use Spring just for DI?
Do you have any tips to share about how to avoid callback hell in Vert.x? That (and the lack of any default error handling) was the reason I got away from it.
I use vert.x web and just write a "global" exception handler to handle any errors that show up it pretty much looks the same as the exception handler you do with spring mvc and controller advice. When I use vert.x to write worker code the worker logic is usually responsible for error handling. As for callback hell I don't feel like I get into that scenario when I use completable futures 
Oracle ADF. 
99% of my job is taking things from one format of json or xml and making it another form of json with lots of error handling, validation, and metrics.
Created my own framework. Best thing I've ever done.
What don't you like about gradle? I both maven and gradle work fine when you just use them for dependencies. When you start adding lots of things that don't belong they can become quite a pain.
Add static methods in interfaces not interrupting the "@FunctionalInterface" nature, and remember that the definition of a functional interface is an interface with exactly 1 ABSTRACT method :) This is exactly how the Function interface (And many others) it built in Java :) while apply(T t) isn't implemented, compose, andThen, and identity are all default (Or static, in the case of identity()!).
Oracle or IBM based on application so that I remain consistent with our production servers. We've tried OpenJDK in the past but switched back to Oracle without investigating much when we experienced issues.
My company switched to Azul's OpenJDK (Zulu) for both Windows and Linux and have no complaints.
Check out Azul's OpenJDK implementation. They provide binaries for Windows, Mac, and Linux. 
/u/mightymightypeon I've often had similar thoughts about *nix MAN pages. I don't find them useful because they are too verbose and don't have examples. I often just end up going to Google. I've never had that thought with Javadocs though. When I went to school Java was the easy, innovative new language. I'm amazed that today in 2017 people complain that it is too hard. I have to be honest that people who use other things come here to complain. It is sort of like walking into a sports bar and complaining that people are talking sports. If you don't like Java, you have the option of not using it. No offense meant
Why not use Payara Micro if you don't like an installed server? 
&gt; No offense meant hmm I never said anything about java being hard so I think you did mean to offend. Anyways you did not provide any answer just went on the defensive of java. BTW most people don't think java is hard. They just don't think it's as elegant as other languages. Tons of boiler plate, not verbose, etc etc.
I was an intern for 9 months in Intel last year for college, my supervisor was quite helpful, including my other colleagues. It's great having a conversation with people who understand code more than me. I learned a lot from them
You were complaining about Javadocs, which is part of the platform, being difficult rather than useful. My point was I am taken aback by people who don't like the platform, frequently coming to here to complain about it. I find it to a bit rude, and pointless. If you don't like a language or a platform don't use it. Again, no offense.
&gt;If we install both versions of Java only one of the applications will work. That is not true, you can have multiple Java versions installed and all of them can work. You just need to make sure that environment variables are correct So either you use environment variables to use different java versions or look into Docker/Rkt which were designed for that purpose. Also usually Java is backwards compatible. Have you actually tried switching all your applications to the latest Java version. This did not work?
&gt; That is not true, you can have multiple Java versions installed and all of them can work. You just need to make sure that environment variables are correct Yeah I'm gathering that now from these responses but I wasn't aware of this and neither were the software vendors we were working with. They had a pretty strict "you install the correct version and only the correct version or we won't support it" stance. You wouldn't believe how much outdated stuff there is in the medical industry. &gt; Also usually Java is backwards compatible. Have you actually tried switching all your applications to the latest Java version. This did not work? In one case at my old job (also in the medical industry) I did try this and it wouldn't work. But this was a very old application.
Wow, colour me impressed. I'd love to help but I've never touched Kotlin before so I'd only slow you down
I could be out of date on the data types. Arrays, JSON, 3rd party extensions, I believe MySQL's geospatial objects were inferior or non existent when I was last using it heavily. &gt; They actually already came in 10.2.0 the GA of which was released over a year ago. MariaDB not MySQL :). I'm not bashing mysql at all it's my database of choice since I am most familiar with it, but it loses out in several areas. Often times it doesn't make a huge difference, you can work around most missing features and performance isn't a huge concern for lots of applications. Let's rephrase that to the applications generally don't push the DB to the limits in most cases. Performance issues are often user error. Oracle is probably very superior to MySQL when it comes to the query optimizer / planner. How different databases store data in the indexes is also different and can be a pro / con. MySQL implicitly creates indexes for all FK's which can slow down writes if it's not actually needed, other databases you must explicitly add it if you want it. There are also major differences when it comes to replication but again they all have tradeoffs and unless you have huge data sets or very unique constraints. If you really want to know major differences with Oracle you might be able to nerd snipe /u/lukaseder :) or read his blog https://blog.jooq.org/. It has some amazing content I would highly recommend subscribing if you use SQL.
"Killer features" are for marketing teams to try and get money from my boss. It does everything I need from a relational database with peak efficiency. Scalability is obviously something not to be taken for granted. PLSQL with triggers, stored procedures. The wealth of easily available well written documentation, discussion, and tutorials/sample code online. I guess "employablity" of a skill is a killer feature.
Okay, I was mistaken about where you are coming from. We just get a lot of 20 nothings coming here angry that they have to actually sink time into learning Java. Back to the subject. I've always found Javadocs useful, even when I was a beginner, though I have had your thoughts about other types of documentation.
I probably should not have said "terrible" in the title. The javadocs do provide some benefits, however I think it could be improved.
🤥
No I am saying it contains very little and is not even close to the the ruby docs which has 1000's(made up number probably has more) of classes documented. Your tutorial has like 4 classes. It's useless. Again ArrayList was just an example. It's not even included in the thing you linked.
JetBrains JDK on Linux
I guess part of what I was responding to was the idea that to some Oracle DBA's absolutely everything except Oracle is either "trash" or "pretty good but still trash." When you called it "fantastic" I assumed you were one of the fans. 
&gt; MariaDB not MySQL :). MariaDB is the only one I really track anymore but I would imagine that if it's been in MariaDB for so long then MySQL isn't too far behind. The code bases have diverged but they're still 80-85% the same thing. For example, MariaDB's command line utility is still called `mysql`. Given that, even if they're not there I think it's probably safe to still talk as if they both have it or will have it in a production release soon. &gt; Oracle is probably very superior to MySQL when it comes to the query optimizer / planner. Yeah I'm not going to argue against Oracle scaling up better than MySQL/MariaDB and well optimized queries and indexes are probably a good chunk of why a single Oracle server can be configured to run at a higher volume than MySQL/MariaDB. The reason I made the exception, though is that the environment MariaDB is developed in seems value "scale out" more than "scale up." Meaning it runs relatively well and you throw more instances into the cluster to handle a higher load.
i'm not trying to do anything besides manage dependencies with it. i've worked with people who have gotten excited over the fact that a programming language as opposed to an XML file can be used for a build tool and have gotten way too carried away with it
&gt; It's all a matter of perspective. 
last I checked, jython would compile to bytecode. A couple of years ago, we had written a DSL (which ended up being almost a completely full programming language in the end), using javaCC. At first, it was interpreted by walking the AST nodes. Later, I've added the option to compile to bytecode. Eventually, the compiled version had more features so we dropped the interpreter. Writing both the interpreter and the compiler was really challenging and fun.
&gt; If I had to guess, I'd say the GC isn't as good for OpenJDK. Can you provide details? Any reproducible benchmarks? I am sure the OpenJDK devs would love to fix this.
JEE, wildfly swarm, Deltaspike Data (I find it more flexible than Spring Data), primefaces. Very happy with them 
It won't be GC, there is no difference in what the Oracle binaries use and the OpenJDK source code. This is most likely a JIT compilation issue, where there are some differences.
We will be providing OpenJDK binaries at http://www.adoptopenjdk.net for all platforms. Not commercially supported mind you.
I doubt its JIT on my use case: I basically have a sizable application that runs for a long time, so I think there's ample opportunity to apply all the JIT optimizations thoroughly. Maybe you mean the OpenJDK doesn't optimize as much and that could be the case but since my app allocates and frees tons of data every few seconds I'd still think GC or memory handling is more likely as a bottleneck. Are you sure both JDKs have the same default GCs?
And the javadoc is *great* after you have the basics down. It would be nice if they were together though.
 &gt; It's all a matter of perspective. sure except when you told me I was wrong for comparing ruby array to java arraylist. 
i'm building [db4j](https://github.com/db4j/db4j), a database / dbms written in java with java as the query language - transactional, uses coroutines for queries, provides in-memory semantics for accessing the stored data. api is still in flux (and i have a bunch of updates to push to github) but the engine is robust and nearly feature complete /u/PurityLake rather than making a new language, you could explore what you can achieve within java - with lambdas, generics, bytecode insturmentation and unsafe, java can be an incredibly expressive language, and you get the IDEs / debuggers / tooling for free 
&gt; Ruby link has instructions on how to create array &gt; Not a tutorial 🤔 
As far as we can tell, GC and other HotSpot internals are the same in OpenJDK as in Oracle JDK, and therefore the same in Zulu and in Red Hat iced-tea, and any other OpenJDK distribution. We see Oracle has "commercial feature" ifdefs for tools and 3rd party components they could not open source, but nothing else in the JVM itself. OpenJDK is the RI for the Java Standard Edition spec after all.
I had a similar situation I actually found it easier to use EJB's and RMI for some reason.
If you're reasonably proficient in Java then you might be surprised by how quickly you can learn Kotlin - it's a much more shallow learning curve than, say, Clojure or Scala. Google announced official support for it in Android a few weeks ago, which means that Kotlin is fairly likely to be the next big thing. Here is an informative and entertaining [article](http://steve-yegge.blogspot.com/2017/05/why-kotlin-is-better-than-whatever-dumb.html) on the subject :) If you do decide to dabble and are interested in helping with Kweb, I'd be happy to show you the ropes.
 They offer support, certifications, courses and even tailored solutions, they offer all sort of consulting work. https://spring.io/services
If I use RMI or Spring Remoting, I can just share the same Interface and let Spring proxy it. So if I add a new method in my remote bean, the method is also now available in my client.
disclaimer - those ruby docs gave me a seizure. they're busy, it's hard to tell what's an example vs what's api reference, the color scheme is challenging (i have an optical glitch, and it makes me nauseous to read them), the summary only provides the name of methods, not the arguments or return types (which makes it hard to quickly find what you're looking for if you don't know the name). so a lot of this is beauty is in the eye of the beholder but that said, i'm a library writer / maintainer / trying to create a business around my software and i'm struggling with exactly this the javadoc syntax is pretty limited and is closely linked to html. it's awkward to write in, awkward to read, awkward to link to external sources, ... including examples in the javadocs is a real pain i believe you can use doclets to support markdown in javadocs, which would help a lot, but the IDEs don't support this. and realistically, unless/until oracle makes markdown a first class citizen, i don't see the javadocs improving much. so for the foreseeable future, i think you just need to accept that documentation for java will be split between the javadocs for api reference and an external tutorial with examples 
What don't you understand? The tutorial you guys keep linking is a getting started with java tutorial that covers like 4 classes. That is in no way comparable to the ruby-docs I listed that has 1000's of classes. What good is that tutorial for anything but those 4 types? For example what if I wanted to look at a HashMap? Oh look your tutorial does not have that class.
&gt; Look, I fully agree that the Ruby doc you linked to is a thousand times nicer than the Javadoc one. But they do not serve the same purpose, so IMO you can't compare them. That's the problem though. They do serve the same purpose. You just took this passive aggressive stance because you thought I was insulting java. If a dev in ruby needs to know how to use a Hash they will go to the ruby docs. If a dev in java wants to know how to use a HashMap they will go to java docs no?
I suggest you spend some time with the tutorial before dismissing it. It is much bigger than you think Here is your answer: https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html
openJDK on Linux for development. never had an issue
&gt;I usually create one class that is a singleton to hold models or GUI components that might need to be accessed from other parts of the application. So it is OK to just have one class for everything then?
A very practical CSS usage. The ideal CSS usage will have to wait until the ideal web developer actually shows-up and makes some contribution -- but, given a choice, the project would benefit far-more from new hardware than new CSS.
Most recently, they seem more eager to find new ways to integrate spring libraries with pivotal cloud foundry. Plenty of money in that.
It is your app, it is OK to do it if you say it is OK :-) If by "OK" you mean is it conventional or a best practice then opinions will vary; however, for a GUI desktop application I think you will find a lot of apps using singletons for this. As another commenter pointed out IntelliJ uses singletons a lot in its codebase for this exact thing.
My company is a member of the OpenJDK group. We only use and encourage OpenJDK in all environments. I have very rarely had an issue that is caused by it and it has its advantages. Of course my company is built on open source and is a huge supporter too.
OracleJDK, I get much better performance with it compared to OpenJDK. I am hoping that one day OpenJDK will perform as well as OracleJDK for me and then I can switch.
I noticed you are very enthusiastic about grails, I'm a fresh grad and have only really been exposed to grails so I'm not sure the upside it has on other frameworks. What are some things that you enjoy about working with grails and should I continue to practice with grails even though there's a relatively small job market for it?
Spring + Hibernate 
Super happy with Jooby - very lean. The guy that makes it is a machine for completion.
So far we haven't had any issues with Azul as a company or Zulu as a product. We don't use Zing (don't have a need for it) and I haven't heard of any salesy stuff going on. It looks like Azul can support Zulu via paid support contracts anyway. Paying Azul is also much more approachable than paying Oracle. :) Worst case scenario I guess we'd switch to RedHat's builds, but another source would be needed for Windows platform. There is an open source project that does just that - takes RedHat's OpenJDK and builds for Windows - though I haven't spent any time looking into it beyond knowing it exists. https://github.com/ojdkbuild/ojdkbuild
Whatever Oracle's "secret sauce" is for Oracle JDK, it seems to not be part of anything that matters. My company switched off of Oracle JDK and everyone was super concerned about differences (huge legacy application), but as far as we can tell (with minimal measuring attempted) there are no differences in performance. The GCs are exactly the same. We're using Azul's OpenJDK (Zulu) implementation specifically.
Hey this looks nice. Is it related to https://github.com/ojdkbuild/ojdkbuild ? Or any plans for collaboration? If someone were looking for OpenJDK binaries how/why would they choose one over the other?
Don't forget to use method refs! final Iterable&lt;T&gt; emptyIterable = Collections::emptyIterator;
Well I find Javadoc example far more informative than the Ruby. For instance, you can understand: - Which interface it implements. - Is it thread-safe - What's the algorithmic complexity of methods it is implementing from interface - How it adjusts internal size as the list grows. I understand why Ruby seems way more beginner friendly but to me, Javadoc is THE documentation what most people want to see. In the bottom section where it says "Constructor Detail" you can easily understand how to construct and how parameters work. This is far more informative than code sample in my opinion.
spring and hibernate along with lots of apache maven dependencies. I m quite happy with all of them with one exception, spring security. In my opinion it is hard to configure and adjust the way we want. We decided to write custom interceptors to solve security issues in the end.
&gt; I understand why Ruby seems way more beginner friendly but to me Getting all defensive about java and throwing out passive aggressive insults. I wonder why that is? Projecting much? &gt; Well I find Javadoc example far more informative than the Ruby. For instance, you can understand: You can get all that same information that is relevant to ruby in that doc I linked. You can even see the C code if you really need to see how the internals of something work in the same ruby docs.
I can't speak for /u/Dekay2323, but here's what I like about it: * For the model layer: GORM makes it very easy to query and otherwise database-enable your domain classes. Features like dynamic finders (e.g., Person.findByLastName("Smith")) and "where queries" save tons of time, even compared to newer frameworks and libraries like Spring Data. See [the docs](http://gorm.grails.org/6.0.x/hibernate/manual/) for more. There's a lot of magic going on behind the scenes, but it's all built on Hibernate, and you can always drop down into Hibernate (or even SQL queries) if you need that flexibility, but you don't have to work on that low a level in most cases. * For the view layer, the JSON views will automatically return JSON representations of your domain objects, so you can use them with little effort in Single Page Applications. And again, if you need to tweak what Grails is doing for you, just create your own "gson" files and take over the rendering yourself. See [here](http://views.grails.org/latest/) for details. * And for the controllers, the new RestfulController will map GET, POST, PUT, and DELETE calls into index/list, save, update, and delete methods on the domain classes for you. Again, you can always override the default behavior, but if you don't need the extra control, there's just so much code that other frameworks make you write that Grails does for you behind the scenes. [More here](https://docs.grails.org/latest/guide/webServices.html) I'm using it on a project currently, and it's crazy what kind of functionality I get out of it given the really small amount of code I have to write. My usual criticism of "magic" frameworks like this is that, when there's a bug or a special requirement, you never can figure out how to make the framework do what you want, but Grails exposes all its lower layers (Spring Boot, Hibernate, etc.) to you, so you can always make tweaks at those layers when you need to. As for the job market: My experience is that some clients care what technologies you use, and some don't -- they let you pick. I pick Grails whenever I can, but you should know that Spring (especially Spring Boot) and Hibernate experience will translate well to Grails projects, and I tend to view Grails 3 as "the next step" after Spring Boot.
We lose money on every sale, but we make it up in volume!
I use Spring Remoting (w/ Kryo as serializer) at work - it works decently enough, but sometimes we end up with serialization issues that makes me want to smash my head through a wall (either deeply nested objects where a child of a child of a child can't be serialized, or two projects depending on the same API library fall out of version sync and Kryo starts failing to deserialize random objects). I'd echo the sentiments elsewhere in this thread about using a REST API - gives you the flexibility to integrate with any language/framework fairly simply no matter what (which you might have to do in the future - who knows?) If you care about payload size/serialization performance you could look at implementing something like protobufs as well - it'll still keep you fairly language agnostic.
I only use OracleJDK (Windows, Mac, and Linux) at the moment because I noticed a performance drop when using OpenJDK (especially when using IntelliJ and PyCharm). No performance issues with OracleJDK though. I should add that the laptop I originally compared them on isn't the best out there, and I compared them in 2015 so things may have changed since then.
Working on a game with the Unreal Engine, progress is somewhat slow.
Any method that doesn't need class level variable access and is expected to perform a unified action across all implementations of an interface can be represented as a default method. For example, the "compose" function on Function should always perform the same action, no matter what implementation of Function you have, so it can (and is) represented by a default method.
Thank you for the very informative and well put together post. I think you've helped me identify a few of my issues. See, I essentially learned development through learning Grails, so I feel I'm missing a lot of major fundamental information (the code that other frameworks make you write) that makes it hard to interview/land a job. You mentioned Grails being the "next step" after Spring. Would you say that going and creating a project with Spring will help me understand a lot of the "magic" I'm seeing with Grails? Also, how well if at all would my Grails knowledge translate down into things like Spring and Hibernate? Thanks again for the awesome reply!
Docs are NOT tutorials, nor they should be.
If they aren't essential, just use an interface :)
Wonder how that works since OpenJDK is the reference implementation...
&gt; you might be able to nerd snipe /u/lukaseder Impossible! [oh wait](https://twitter.com/vlad_mihalcea/status/870584723906711552)
&gt; the MySQL row actually seems a bit longer than the Oracle one. Oracle: CREATE TYPE o AS OBJECT (a NUMBER, b NUMBER); / CREATE TYPE t AS TABLE OF o; / =&gt; Infinite types. Few other databases (e.g. PostgreSQL) know this kind of user-defined type system. Interesting that this is not reflected in that wikipedia page...
Does anyone have trouble reading the article due to a popup window with no way to close?
Because JavaDoc is more about API spec less about tutorial. They are written with your code in specific format that will be interpreted by the javadoc tool to generate the doc files. By that, you want to focus more about the spec of your APIs. Of course you are free to write your javadocs to become something like tutorials, but its not recommended since that may be misfocused as spec doc and you dont want to add that extra hundreds/thousands boilerplate lines to your source files just for the beginners. That's why java folks (like many famous java library) tend to have some separated user guides for learners. (We do sometimes write few lines of example to demonstrate things that are hard to be explained or understood in plain words)
That could be an option to explore one day, Wildfly has something similar, right?
It's actually number 9
And all of that in a single ***picture***!
Right, the added value is the object graph traversal and avoiding to explicitely dereference the potentially long paths to the objects you want. Like you would do with jQuery $.find(). It is useful if you don't care about the intermediate steps. There is no special reflection magic, it is just tree traversal. Agreed that the very feature of skipping the intermediate steps removes the compiler verification that the paths lead to the actual objects you want. I see that as a feature in the case you want more concise code and accept the cost of relaxed structural validation. 
Libgdx is a great java framework for game development! I'm using one for creating my new mobile game. But at my main work I use Spring boot and Akka and very happy.
Yes, it is called Wildfly Swarm.
It is not an insult to state that the ruby documentation is more beginner friendly : ) Good luck with life. 
Most of the time whatever is easier to install and maintain, that is OpenJDK. But lately I ran a project on an ARM (Banana PI) and Oracle's VM performs significantly better.
Ruby adds example usages to the documentation while Java keeps it strictly as an API reference. Answering **why** it is like that is a difficult question. I guess it's a different mindset, target audience and the age of the language. I find it better if the examples were not part of an API reference, however having examples for each use would be a nice addition in some other doc.
I've seen many applications logging without checking if that particular log level is enabled. Just a waste of resources to generate a log line that just gets thrown away.
Indeed, WildFly Swarm
Voting periods start on tuesdays.
We are in a big Stack Upgrade right now, unfortunately we couldn't move to 11.3, is it very different to 11.2?
As a person who used to work in a GIS office, Oracle's Spatial features were completely unique to it (starting in 10g) until Microsoft started supporting something similar in SQLServer 2012, which came out 8 years later.
log4j was released 16 years ago. Now there's even log4j2 Then again, I know the pains of working with an older code base. It's not fun. But proper logging should be a priority. 
Also, despite the comment about human readability, the author specifically says this is mostly for log analysis tools. Inconsistent log formats are a real pita for splunk, sumo logic, etc...
Isn't that more of an issue with the toString implementation? I thought common practice was to ensure toString() is always fast.
The core use cases are a subset of the JDK use cases though. I don't think it is fair, unless there's a Java core version with a similar set of use cases. 
Lol. A couple years... The full C# framework isn't even there yet. 
You're too junior to understand this. Not everyone likes to have to do full product recompiling only to find various random code or behavior changes every time their language updates. 
I was not looking at that. Thanks for pointing that out, however I still prefer the ruby way of documentation that also includes examples. Like I said it's very convenient. For example if I search a ruby class in google it will be the first thing that pops up. If I search a java class in google the first thing that pops up is the java doc. So I would have to then look at that and search for the tutorial to just get a quick example of how the author intended the class to be used. Also that tutorial does have vastly more things in it then what I thought I still don't think it comes close to having every core java class in it like the ruby one.
thanks for correction ;)
&gt; They have obviously never done desktop programming. I have to disagree. This is not unique to desktop GUIs. The singleton approach was very common on Android too. The problem was of course *testability*. Now things have moved to DI approach. So I would say if the application has a future and needs to be written well, then follow "OO purist" principles, otherwise, sure hack it together and skip testing.
&gt; Regarding getters/setters I like this approach too and have been writing code like that for some time (i.e., getters/setters have the same name but are overloaded). &gt; On req/resp vs ctx I'd have no preference. Thanks. I'll count "no preference" as positive. As long as the majority of people don't dislike it I'm comfortable going forward with it.
A typical data class with (say) 6 fields ends up with a lot of boiler plate code without Lombok, even if the IDE generated it all. That code still needs to be maintained (i've been bitten buy bugs where I did not update equals/hashcode). A Lombok class just has the fields and some annotations.
At work, we tend to relay all the log data to some SaaS for analysis on production servers. 
Number 3 will surprise you. Really tired of these low-effort buzzfeed-style articles.
Snap will do that if you distribute to Linux. It will package the jvm with the installer so that it is guaranteed to work across systems (Linux)
We're working on a survey system that allows us to fetch surveys to users using our services and do data analysis on the results we get. We're using node.js and Angular.js. 
Insightful comment!
Use an abstract class if you have to maintain state of some kind. State stored in a static map in an interface is the path to the dark side. 
Why Azul for non commerical?
Honestly if you have more than a single endpoint that requires validation in different ways (for different sets of parameters, or different concepts of what is required or optional for each endpoint) you'd probably be better off just calling your own validation methods from within your rest controller class (or maybe a service layer beneath that) instead of using a filter. I could be mistaken but it feels like the filter approach would create less clean code and (depending on how you implement it) wasted method calls or conditional checks just to get the right type of validation applied to the right endpoint.
In my own experience, Unity only uses C# for example. The languages compete.
Doesn't spring allow you to proxy rest interfaces as well? I know you can do this with resteasy and it integrates with spring. But like the comments say, rest is language agnostic so it's better to go with that. But your choice in the end I guess.
The builder pattern is more than returning an object on the setters. And returning the object on setters is a design flaw anyways (except when explicitly using a Builder). And yes, as long as you write or generate equals/hashcode into the source file, you have to test them to make sure you don't forget to update them after changes (adding fields).
Grails 1 and 2 were awful as soon as you deviated from the golden path. What you gained in speed, you lose in ability to mesh with other frameworks. Plus, Groovy is a terrible language. The app would require a very specific jdk version to run. But it made for great demos? Anyway, glad it works for you. Spring Boot is good, but I now fear the Grails name.
I used Oracle ADF at a previous job and cannot say that I miss it. When you did everything exactly right it was great, but if you made the smallest mistake you had to scrap everything and start over because there was no way to fix things.
We use the Play framework at work and I really like it. My favourite thing about it is the auto-reload - I *love* not having to go through a tomcat deploy every time I change something, I really like having all my endpoints in one simple file, and I like the way play organizes it's config file. If I never have to deal with an XML config file again, it'll be too soon.
Dzone is in general pretty low quality. They have a lot of these low thought lists, or tutorials that are so basic they are worthless.
The spark approves of this new naming. Always glad to lend my two cents :) 
Transpiler to ES6+ and lightweight framework for multiplatform apps (CEF/WebView as frontend, maybe replace to Servo at the end of the year) and single page sites (custom lightweight render for search bots). Without JSON, POJO on frontend and backend with fast serialization/deserialization.
Transpiler to ES6+ and lightweight framework for multiplatform apps (CEF/WebView as frontend, maybe replace to Servo at the end of the year) and single page sites (custom lightweight render for search bots). Without JSON, POJO on frontend and backend with fast serialization/deserialization.
&gt;Why is there such a push with Glassfish 5 at the moment purely as the reference implementation? Probably because there's little other choice? GF is OSS and owned by Oracle, Oracle owns Java EE, so there you go. Selecting another product to be the RI would be troublesome and requires a transfer of Java EE to whoever owns that other RI, I think. Which one would you propose as the new RI?
Either re-instate support for Glassfish ongoing development, hand the same project over to Apache like they have done for Netbeans or choose someone like RedHat and use Wildfly
Fun: A Java implementation of the Logo language. Aim to be flexible to new languages and show how languages work for learning. http://tros.org/torgo Also for "fun": http://tros.org/l2fprod-properties-editor/ A property editor in the same style as used in .NET/Windows. Wanna help? Work: Social Network emulation and document search triage with fuzzy search capabilities.
Re-instate support for GlassFish... unlikely to happen by Oracle. And do really need it? Effectively Payara has taken over support for GlassFish. &gt;hand the same project over to Apache like they have done for Netbeans Just the project will do you little good, as it will just be a project then. You also have to transfer the Java EE spec, which is going to be problematic with Apache having left the JCP angrily over some Java SE implementation they were going to make. And just handing it over to Apache won't mean automatic support, as you also need a dedicated and knowledgeable team working on it. We've seen what happened with Geronimo, which was 100% owned by Apache, but IBM developers worked on it. When they left, Geronimo instantly died. Apache didn't even bother to update the community about it. They just let it wither and simply ignored any JIRA issues and most messages on the mailing list. &gt;choose someone like RedHat and use Wildfly It's an option, but that would also mean the Java EE spec has to be transferred to them. Red Hat builds great software and WildFly is ace, but they typically only contribute to specs they own. Look at Java EE 8. How much did they contribute to JSF, JAX-RS, Servlet, Java EE Security, ...? Even with EG members on those specs, they just did nothing. So in order to stimulate them to do anything at all, they MUST own the spec, otherwise it's a futile attempt. And how do you get Java EE and all those constituent specs to Red Hat? Ask Oracle nicely?
Actually on an application I am refactoring I am using checked exceptions. I created two checked exceptions; [AppName]ServerException and [AppName]ClientException. Appropriately I throw the former when I hit a system error and the former if I get bad client input. In the methods of my controller I have catch blocks for both of the exception types and handle the response I return to the client appropriately. Obviously this can be done with unchecked exceptions, but felt it better to do as checked as I want controller code to handle these exceptions. 
We run ours using spring-boot.
In what way would this cause spaghetti code? Keen to know a Pro's perspective
I know I'm the minority here but I think the application container and java ee are sufficient for microservices. Wildfly and the now (mostly) defunct glassfish both added unique and impressive ways to handle this. Glassfish has an auto deployment tool which only requires a hostname and SSH key to setup a new server replica. Wildfly swarm builds spring boot like wars which contain all dependencies in a few megs. These containers then give you a higher​level of delivered admin functionality and a standards based development platform (Java EE w/ JSRs have less undocumented"features" than spring). Ultimately I think an open minded developer will find you can build the same app in any framework with little effort difference. The framework just influences what "extra" functionality is available (e.g. spring-boot has a wonderful docker plugin and spring-cloud gives spring some nice restful admin functionality out of the box) I recommend that new developers look at there local industry and do a side project or two in any of the actively sought frameworks to better understand the pros and cons of each. 
&gt; Hi, I'm spring boot and I've brought ALL of my friends, a container that we just finished trashing and 200 undocumented features which you'll learn to use over the next five years. Don't worry we'll change those features on a whim in order to suit the pivotal company direction and you'll be forced to rewrite swaths of code or run legacy versions for years. I might be a bit biased. 
Spring Boot: Yes. Hibernate: No. Working on a proposal to kill it.
How do you handle polygot with this, such as mixing node.js with Java ee with go applications? My understanding is this flexibility is what makes docker containers more attractive for microservice architectures than Java ee application servers. 
ELI5: req/res vs context. I primarily develop Node/Express and am familiar with Koa. I just don't understand the "design pattern" for `context` per se.
Yes, 1 war for 1 server. This is way 2 go! 🚎
Plz, xplain!
What is light weight??? What is you definition???
To fix some issue raised by this post you hould use one application server for each microservice, but an application server is too fat for a tiny microservice. Java EE application server is hard to configure: if you need to write a lot of microservice then you should expect to write a lot of code, not a lot of configuration. IMHO a good tecnology for microservices is Docker: easy to bundle and trivial to boot. Java EE application server doesn't seem a good candidate, Vert.x library fit better, also SparkJava might be more advisable.
Server side rendering and Java script, those two don't mix in my opinion. Unit testing is just a mess to do deal with. Talk to a any project on how they could have avoided spaghetti code, you'll most likely hear discipline or enforce unit testing. At least one of that can't be done with jsfs. This is probably great for simple projects that have a few pages of navigation and you have a lot of middle tier developers. 
Developing a mindmap suite in JavaFX. I'm a .NET boy at heart so despite knowing Java as a language, this is a pretty different approach to my normal development cycle.
that sounds totally different ad 33signals say, while having people all over the world, but maybe you are right and that's an exception 
Usually I think people get a remote job while they're still in their country, then move elsewhere once that's been secured
A lot better than Oracle ever did I think :O But what upstream issues are you specifically talking about?
I suggest you look for a remote FIRST job. Not a company that kinda allows remote. But a full time remote place. Otherwise you will always be on unequal footing with the in office people. I worked 2 jobs found like this, was good.
Maybe this is already out there, but what I'd like to see is Java Doc documentation source divorced from the actual code. There is no need to write an essay, tutorial, or even the nitty details of your function above it's signature. Have a separate file that is stored in the appropriate place (/docs) that's mapped to your classes and functions that contains only documentation source YAML style. This will reduce the clutter, keeps source code clean, file sizes reduced, and no ugly markups.
If you told your IDE to generate it, then you wrote it. equals &amp; hashcode are public so they need to be tested as much as any public method does.
There is this https://www.reddit.com/r/programming/comments/42xdd9/javadoc_source_samples_that_dont_suck/ We use [this](https://github.com/codenameone/JavaDocSourceEmbed) for our sources and they look better. They allow us to host the snippets of gist and thus allow people to fork, comment and star on the code samples.
When I started at my current job I was in the office everyday. Then as we started running out of space they asked for people to start working from home. I went from full time in the office, to half time, to full time at home over the course of a few months. Now I live in another state and fly back once a quarter for larger meetings. Works great! The big thing is the culture and toolset tho. My company has fantastic vpn, telecom, and im tools setup and has changed the mentality of the company properly such that remote workers are even with the people that go in everyday... make sure this is the case wherever you end up. 
I prefer [QueryDSL](http://www.querydsl.com) in combination with Hibernate. jOOQ isn't FOSS.
Does this mean we have to update production tomcat? How does your company handle this? I guess automatic updates are not always possible.
I think the term "application server" doesn't make any sense in the context of microservices. Actually an "embedded application server" is no longer a real application server. Think for example of Spring Boot and Wildfly Swarm: they follow both (more or less) the same principle of embedding libraries/frameworks and shipping an executable file. But would you call Spring Boot an "application server"? Of course not! Maybe we should simply stop to use the term "application server" when they are embedded.
My company has a case like that. A coworker went to a foreign country to work remote for a couple months and then never came back. They visit once a year or so (still have family here). In our case the longer you've been around (and the more you can prove reliability when working remote) the more flexibility is offered.
Java EE was proposed to be a silver bullet in enterprise application, so it is highly configurable and rich of features. Unfortunately this approach doesn't fit well for a microservice deployment, so your application services may doesn't require JPA, Java Mail or CDI. Spark Framework is 150kb, so is micro (Kotlin standard library is five time bigger). Vert.x is well designed for microservices, it has a low memory footprint and it size is 2mb with all core dependencies, and you can boot thousand of verticles in 2 second (in the same JVM). &gt; Spring uses more memory, more disk space all together (all the jars are in the war) and starts up slower. I fully agree, IMHO Spring is a modular replamcement of JavaEE, but it's big and slow to start, Spring Boot doesn't fix these problem. Spring is a nice idea but I prefer Kodein for CDI (300kb). Vert.x may be (in general) a good choice, the only issue with Java is the asynchronous programming style, I suggest some changes using Kotlin's coroutine (https://github.com/vert-x3/vertx-lang-kotlin/pull/14), I hope they will fix this issue so Vert.x can become more programmer friendly (for any languages with async/await support). &gt; Please, enlighten me Sorry, I'm not a guru :) I hope to have explained my point of view to you.
Why did you leave the word "multiple" out of the title? Because that's what he's saying. I would think someone that posts as much as you do knows you can edit the suggested title.
&gt; I fully agree, IMHO Spring is a modular replamcement of JavaEE, but it's big and slow to start, Spring Boot doesn't fix these problem. Something we agree on ;) So let's take it from here. For better or worse, Spring (Boot) IS used a lot for microservices. Clearly it works for people. Java EE is not in any way worse than Spring. I'd say it's better in some parts even (startup, memory usage, disk space). So it follows easily that Java EE can be used pretty well for Microservices, as long as you don't fall into the trap that a Java EE Server MUST be installed by operations and MUST have multiple wars deployed to it. &gt;Spark Framework is 150kb, so is micro Now about this, you're confusing two usages of the term "micro". A micro framework is a very small framework. It doesn't do a lot for you, but that's the entire idea. A microservice is a service that does one thing and does it really well. The two are not necessarily dependent on each other, which is the crazy big mistake people make all the time. Although I wouldn't recommend it, theoretically you can run a microservice perfectly fine on WebSphere, as long as that service itself only does one (small) thing. Microservices say NOTHING about how small or big the environment on which they run must be. 
He's also got that ESL thing...
Thanks &amp; noted. I think the delay is certainly reasonable but needed a sanity check. I'm quite interested in JSR 376 but generally unaware of the JCP culture.
Mostly learning. I have only been using Java for a few months but I am thoroughly enjoying myself and moving along quickly. My ultimate end goal is to develop indie desktop and mobile games. I also created a blog to provide updates to anyone who cares. www.mypcsmith.com
&gt; It’ll be a game changer, no doubt about that, primarily due to its module system. It can put an end to the jar-hell we might have been facing for a long time. Unfortunately it doesn't. Atleast not in an early release. At best the optional version string can be a hint for build systems for shadowing. As we do now with artifacts, just that with artifacts, the version is mandatory.
I'm looking forward to welcoming you back to the jOOQ community, eventually. It's inevitable :)
&gt; Am I missing something or do we have an entire data type (2?) for exactly this Depends if you're interested in a `TIMESTAMP` (easy) or a `TIMESTAMP WITH TIME ZONE` (mad)
not exactly what i asked for but thanks !! :)
i have a similar script i called [mvnrun](https://github.com/nqzero/mvnrun) that uses a simpler mechanism for calculating the class path * `mvnrun org.db4j:kilim kilim.tools.Weaver` will run the weaver automatically * `java -cp $(nvnrun mvnrun org.db4j:kilim) kilim.tools.Weaver` works too, if you want to prvide jvm args or whatever i haven't tried jrun, but would love to see something like this end up being more or less a standard tool 
Great article 
This gave me the creeps: if (JDBCVersion &gt; 2 || srs == true) Whenever I see someone compare a boolean variable to a boolean constant to get a boolean result I want to shake them.
I am brand new (only started a few months ago). Most of what you listed is foreign to me. I will research each area thoroughly. Thanks for your response!
Reactive programming (rxJava / reactor), java8 Stream / map / flatMap ...
If that is what you want, you are still able too. In terms of microservices we talk about individual components. You take away the individuality if MS A is unresponsive due to MS B. And it all depends on your context. Maybe this sounds far easier for a small team. What if you have 10 teams? 25 teams? 400 teams? The requirements change depending on your development environment. There is **no** silver bullet. 
Yeah I learned the ins and outs of jdbc when I wrote persism. http://persism.sourceforge.net/main.php
1. So what? It's interesting that this technology some of us have been using for nearly 20 years still has unexplored nooks and crannies to be discovered. And there *could* be rare use cases where it might come in handy. 2. Perhaps scrolling is impractical in certain high-scale use cases, and perhaps updatable `ResultSet`'s are inappropriate for certain complex transactional use cases. So what? There are use cases in which either of these *could* be extremely beneficial. Nothing is the right tool for everything. 3. ^ 4. I think the whole point of this article is that few people use these things because few people are even aware that they exist. 5. You are very much overestimating the average Java developer's familiarity with JDBC, after more than a decade of ORM's dominating the industry. I've seen raw JDBC batch mode used maybe 4 or 5 times in my career. For those use cases, most younger developers would reach for Hibernate (or whatever the Hibernate-alternative-of-the-month is at the moment)... and many older developers would look to some kind of PL/SQL or T-SQL driven approach. 
Everyone's suggestions here are great. But I have another one, you probably will end up not developing apps, but maintaining very old ones. Learn refactoring tools/ideas. 
[undertow](http://undertow.io) has a similar abstraction, their `HttpServerExchange` encapsulates both, and it works out well.
Because if you want to do that you need to deal with version conflicts. Official stance however: &gt; A module’s declaration does not include a version string, nor constraints upon the version strings of the modules upon which it depends. This is intentional: It is not a goal of the module system to solve the version-selection problem, which is best left to build tools and container applications. They have since changed some of that. The module declaration can now include a version string though it is optional and probably meant for build tools. The version selection problem is still not part of the module system, therefore there is still no real solution on the table. See this [link](https://blog.codefx.org/java/dev/will-there-be-module-hell/).
Is Java on the front-end used anymore? I get there's legacy code out there.. but for new projects? Must be rare 
##Betteridge's law of headlines Betteridge's law of headlines is one name for an adage that states: "Any headline that ends in a question mark can be answered by the word no." It is named after Ian Betteridge, a British technology journalist, although the principle is much older. As with similar "laws" (e.g., Murphy's law), it is intended as a humorous adage rather than the literal truth. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^] ^Downvote ^to ^remove ^| ^v0.2
I found a good use for them in implementing Xmodem/Ymodem recently. Those standards require timeouts and resends, hence non-blocking I/O, but I still wanted to use basic InputStream/OutputStream rather than nio so that one could easily later do something like Ymodem over HttpURLConnection. Using checked exceptions I was able to much more cleanly separate the protocol's logic from the exception handling and also differentiate between timeout (requires resend), local file EOF (normal exit point), and general network I/O error (something weird). It resulted a really tiny library that works well. 
Everything in Joshua Blochs "Effective Java"
I'm sure I'll get downvoted for this, but I don't care. I'm allowed to express my opinions too. Absolutely 100% cannot fucking stand articles that assume what I don't know. You don't fucking know me, and you don't know what I know. Article titles like this say to me "I'm so much smarter than you!" Even if that's true, you shouldn't fucking insult your reader. This is the worst fucking trend in articles - even worse than paginating after 9 words - and it needs to fucking stop.
Android
I'm curios, why would this be ?
If you're not just doing it for fun (LOL) and you want a job out of it it would not hurt to git gud at Git and Maven. Those two get used a LOT.
Java 8 introduced the CompletableFutures and they provide reactive behavior without an external dependency. 
Right, and how many JDBC drivers do you know that implement all 5 correctly? Hell, I'd settle for having JDBC drivers that have BASIC functionality that works right. Most commercial vendors have JDBC drivers that are utter shit. Especially Sybase...
Should be titled "How to Make Your JDBC Code and Database Slow and Unscaleable". I use raw JDBC for almost all my database needs and i wouldn't use 4 out of 5 of those.
Really? Because I'm somewhat in that category and I much prefer backend over front-end stuff..
E.g. I think that if (val==false) is often more readable than if(!val)
Even if you are doing it for fun, get used to source control of some kind.
but **if (val==false)** and **if(val)** is not the same (✌ ﾟ ∀ ﾟ)☞
I've had a good experience with this one: http://jd.benow.ca/ EDIT: You decompile the .class file, which is a compiled .java file. A .jar file may contain .java files as well.
i would try fernflower from intellij (https://github.com/JetBrains/intellij-community/tree/master/plugins/java-decompiler/engine) for this. 
Note that a decompiler can't provide the source code for you. You can get valid Java code, but it's not going to be especially readable.
u/leobm suggested `if (!val)` and not `if (val)` and that *is* the same. The issue is actually worse in C, Ruby and other languages which have multiple boolean values. In Java it works but it is just bad style.
Jd-gui is great. Drag and drop entire jar files, and the decompiled source is searchable in the tool.
If you are using eclipse get the JAD plugin. Works great for me.
CFR (http://www.benf.org/other/cfr/). From the homepage: &gt; CFR - another java decompiler &gt; &gt; CFR will decompile modern Java features - Java 8 lambdas (pre and post Java beta 103 changes), Java 7 String switches etc, but is written entirely in Java 6.
You can just unzip jar files with something like 7-zip.
JD-GUI gives perfectly readable code. Of course it won't be exactly the same as the source due to the compile process but it's close enough. 
I've been pleasantly surprised by the decompiler in IntelliJ IDEA. Don't do anything special, just inspect the classes in the jar and it behaves like it's looked up the source for you. I'll toss another vote for jd-gui though.
Both jar and war extensions are just zip files. Change the extension to .zip and open it in any file browser 
You know, I see misposts about that silly survival game in /r/rust every day. This is the first time I've ever seen a mispost about the Indonesian island in /r/Java.
The jar I have in mind contains .class files.
Is GCJ still a thing?
Always found this to be the best and most intuitive. No public javadoc? No problem.
JDBC Immutables JSON Servlets
Same thing with `.doc` and `.docx`. Someone send you images in a Word doc? Change it to `.zip` and extract. Boom images.
Yup any of the new office document formats with an x in it can be opened as zip files.
Is there a reason that relocation isn't an option? Or just a preference? Because it probably limits your prospects quite a bit depending on where you are. 
This is highly improved if you don't use some Byzantinan garbage like jdgui or fernflower. The code from procyon is very very close to src.
Seconded on CFR being solid.
TL DR: Minecraft is no longer in java, and thus it doesn't support older mods.
Everyone here is going to tell you a something different. Just start off with these three principals: Inheritance. Polymorphism. Encapsulation. Some extras to keep in mind: Software reuse. Less is more. Method inlining. Garbage collection. Profiling memory/cpu. You'll be using those principals for most of software engineering. In almost every language. I know these will seem far fetched right now, but the more you use them. The more their usefulness becomes clear and it will naturally come to you. Wish you the best.
Since I have seen nobody mention it yet, I am a fan of https://bitbucket.org/mstrobel/procyon which works decently well with https://github.com/deathmarine/Luyten. Both are a bit out of date. But in the end, I'd just learn to read the bytecode, it's not too bad. Also, not all bytecode can go back to Java because it was never Java in the first place and the jumps and what not are not anything like what javac would produce.
The only difference is the power. The way every big company works is the same.
Thanks for taking time to respond to the question. As you have said, I'm wondering how to use JWT correctly. I'm using it in my play framework for authentication purpose. Since its a web application, I'm using it for authenticating the user by generating the token and using the same for all request calls. The token contains the username, role etc. There comes couple of things to consider for me: 1. If I sign the token only with private key, how could I tell the token is invalidated when user logs out? For that purpose, I thought of using a timestamp when the token is generated. But again the service needs to know the timestamp + public key to encrypt the data. 2. What if a user changes the password? How can I invalidate the token? May be I'm thinking in wrong direction about JWT! Thanks for your help! 
&gt; Minecraft is no longer in java The article very specifically states that the old Java edition will still be supported. 
But the article seems clear that the Java mods will not be supported in the new C++ version of MC. This will surely splinter the community. I don't have a horse in the race here, so I don't have a bias either way, but the trade-offs seem clear from where I sit.
&gt; but hate to see the downvotes given the language has subsumed the namespace of an ancient and massively populated place I'm not downvoting the namesake island Java, I'm downvoting the spam account.
I use [these guys](https://authrocket.com/docs/jwt_login_tokens) a lot at the moment, but I wouldn't recommend them, they do have a good overview of what they are and how they work. Check out [this](https://paragonie.com/blog/2017/03/jwt-json-web-tokens-is-bad-standard-that-everyone-should-avoid) but take it with a heavy pinch of salt. 
Too fat? Think not huh! 🎂
Token invalidation is one of the shortcomings of JWT: it's the sacrifice that must be made in order to achieve truly stateless authorization. You basically cannot invalidate tokens without either adding state or doing something a bit wonky and contrary to the intent of JWT. My general approach in the couple projects for which I've used JWT is to set short expiration windows for tokens and then putting automatic token refresh logic into the clients. This works well for me since I'm generally building a vertical system (both the front- and back-ends) and know exactly how to integrate the two. It gets a little trickier communicating that to 3rd-party developers (eg, someone else building a client) but it's not entirely uncommon.
&gt; Microsoft _is_
&gt; No surveys, no job offers! Such content will be removed without warning. See side bar for sub-Reddit rules.
If you want to be a grammar nazi, please learn how English is used outside of the bastardised American dialect.
Sorry, I can't hear you over our GDP
I bet you really profit by that gdp
The x stands for zip.
This makes me quite sad. I love the egalitarian and portable nature of the java version, not to mention the mods. (Although I really only ever played with a few I suppose.) I don't mind a faster version or the console market, but Macs and Linux are the biggest losers here.
I'm a newer java dev, so I know some of the differences but not all the nuance. But it's something I heard a lot.
I can't say I understand the rules well, but here is a discussion on the topic: https://english.stackexchange.com/questions/1338/are-collective-nouns-always-plural-or-are-certain-ones-singular &gt; So the company "Microsoft" is singular, but if you use the word "Microsoft" as shorthand for "the employees of Microsoft", that is plural.
Your usage is a bit unique, but I needed a similar functionality (business requirements in a highly regulated area) and used the `jti` claim (token id) with an expiration in a cache (redis) and validated them at the API gateway layer so no one else had to care.
You missed the entire point of JWTs, statelessness. Each request provides all the data that is needed for authentication so that the server need not make a lookup through a DB or cache to authenticate the user. The way JWTs are intended to be used are by verifying the JWT using only the secret or public key and nothing else. If you're making a DB call to verify a JWT then it's no longer stateless and not much different from cookies based authentication.
So then how is the usage of are correct here? 
Classic Microsoft. Not that i play much MC these days, but it was THE game back in the day when i made the switch to linux. I actually like not having to reboot into the gaming-os... 
I can't say I understand the rules well
The most common thing I run into is the fact that all generics are stripped out because of type erasure. But typically, it's not too hard to fill that information back in by inferring from the context it's being used in.
In all fairness, it might be to everyone's benefit to simply move forward with the new product. It's sure to perform better anyway, and new features development is likely going to only be in that product. On top of that, just the fact that it will perform better will enable even larger creations in the future. 
I thought it was for xml Edit:[I migh be right](https://en.m.wikipedia.org/wiki/Office_Open_XML)
Agreed but it's not really correct from a security point of view: if you have a logout link/button, you can't invalidate the JWT on the server side with a stateless authorization. From user side it's really disturbing thinking that you click on logout but the JWT is still valid on server side... 
JWT is just a way to [securely transmit information in a self-contained fashion](https://jwt.io/introduction/) between servers which have a shared secret, so the server receiving the information can verify the authenticity of the information using the shared secret that was used by the server sending the information which signed the information with the shared secret. JWT is often used in conjunction with authentication protocols like OAuth and Single Sign-On because it allows stateless transmission of authorization information (such as roles and permissions). The authorization server generates the token, and the token can be passed around between resource servers to verify user access rights without having to contact the authorization server, because the authorization information is self-contained within the token. All the resource server has to do is verify the authenticity of the message, which is a far cheaper operation. &gt; when the user changes password so that I can invalidate his/her &gt; token OAuth [combines](https://auth0.com/blog/refresh-tokens-what-are-they-and-when-to-use-them/) JWT based "access tokens" with non-JWT "refresh tokens" . The access tokens quickly expire (say, every hour), while "refresh tokens" are valid for much longer (if they expire at all). The user must get a new access token using the refresh token. You don't invalidate JWT access tokens, you simply let them expire. Instead, you invalidate refresh tokens. The advantage of refresh tokens is that you significantly reduce load on the authorization server (and increasing performance of resource servers), while gaining a little bit of insecurity due to having an access token that can still be used (for a short while) when the refresh token has been invalidated. &gt; why can't just send username &amp; password as a part of every &gt; request? You [could](https://en.wikipedia.org/wiki/Basic_access_authentication), assuming that the transport is encrypted so you don't reveal authentication information. But the only information you have is that the user is authenticated, but you have no information about what authorizations the user has. Which would require communication with the authorization server to validate every request. 
##Basic access authentication In the context of a HTTP transaction, basic access authentication is a method for a HTTP user agent to provide a user name and password when making a request. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^] ^Downvote ^to ^remove ^| ^v0.2
&gt; If I sign the token only with private key, how could I tell the token &gt; is invalidated when user logs out? JWT tokens are used for *authorization*, not *authentication*. The authentication process generates a *refresh* token (non-JWT) which is used to obtain new *access* tokens (which use JWT to encode *authorizations*). You don't invalidate *access* tokens, you invalidate *refresh* tokens. Invalidating the refresh token (not a JWT token) is how you log out a user. &gt; What if a user changes the password? How can I invalidate the &gt; token? You don't invalidate *access* tokens, you let them expire. You invalidate *refresh* tokens. If the user changes their password, you invalidate the *refresh* token. When the *access* token expires, the invalid *refresh* token cannot be used to get new *access* tokens. &gt; May be I'm thinking in wrong direction about JWT! JWT is usually best used with an authentication/authorization protocol like OAuth.
[The employees of] Microsoft are leaving the Minecraft you know[...] 
Glad i got the opportunity to play minecraft in it's simple raw alpha/beta form back in 2010.
Why would that be implied? 
In case you're using Eclipse, you can install this [plugin](https://marketplace.eclipse.org/content/eclipse-class-decompiler). It allows to decompile with either JD, Jad, FernFlower, CFR or Procyon and compare which one does the best job.
People are playing this on consoles? Isn't such a game pita to control?
Use the force. Go to the source.
&gt; Token invalidation is one of the shortcomings of JWT You're not supposed to invalidate JWT tokens, you're supposed to let them expire. That way, the information in the JWT token is only useful for a short period of time. The usefulness of JWT is that they are self-contained and verifiable without a call to an authorization server. You invalidate refresh tokens, which it doesn't make sense to make JWT tokens, but rather a UUID or something. Refresh tokens don't carry information, but are used to get new JWT tokens when they expire.
Strange to see this as the most controversial post here. If you downvoted, could you explain why?
I’ve had much better luck with CFR than Procyon.
With decompilers "YMMV" applies pretty hard
That is up there on my Amazon wish list. Definitely going to purchase after I have a better understanding of the basics.
&gt; You're not supposed to invalidate JWT tokens, you're supposed to let them expire. Exactly. Perhaps I should have been more clear in how I expressed my above comment: when I call this a "shortcoming" I mean that the inability to invalidate JWTs is something that may make the use of JWTs unacceptable in some use-cases; I can imagine auth use-cases where immediate session invalidation is a requirement. It's something that must be taken into consideration during the design of the authentication/authorization flow, there are pros and cons to any approach. Although I may simply be misreading your intent if you're just providing a brief synopsis of what JWTs are? In which case, I apologize, and it is a good overview.
&gt; if you have a logout link/button, you can't invalidate the JWT on the server side with a stateless authorization True. &gt; From user side it's really disturbing thinking that you click on logout but the JWT is still valid on server side... I think it's a marginal worry. This is why I advocate short expiration windows on JWTs combined with automatic token refreshing client-side: after the user "logs out" (essentially, clears the JWT from their local storage, or what have you) they will no longer be refreshing the token and their last token will quickly expire with no more refreshes. **EDIT** And depending on your implementation, you should also be invalidating refresh tokens server-side upon logout.
&gt; Do not do that. Keep reading in the brackets, never said that I am, just making a point &gt; Already happening. They have not released the details, but there are already official mods Okay, I should have said "when" (read the article and still said if, I know it's pointed out there). And as already put, from here on in, we are playing by Microsoft's rules. If they want to limit various components of the game from devs, they can. A bit harder to do with the Java version. I see one good thing stemming from this, and that's the promise of plugins/mods not breaking every update like in Java now, but again, not sure how much Microsoft will permit in their API. I'll believe their promises when I see them fulfilled, but I do foresee at least an initial backlash from the wider community about the progressive switch. 
Hey quick question from a half techie.. would swapping to C++ , which is more powerful, finally allow minecraft to have good psychics based stuff? (Cloaks that flap in the wind, water that sloshes, sagging rope bridges) or will it still have a tough time dealing with soft bodies? Edit : jesus guys, I wrote only a few lines of java back in highschool.. I was just passing through and wanted to pop the question. Why all the downvotes? 
&gt; Pico then presents these web applications in its own iframe Ew. Also, you may want to reconsider the name: http://picocontainer.com/.
Java didn't have an issue with that either, though. At least, not at the scale I imagine Minecraft needing. Maybe in high resolution texture packs or something it may get overwhelmed.
&gt;As Java EE 7 and below, your option on securing your software application is either depend on application container (application server such as Wildfly or Payara) or using third party library such as Spring Security or Apache Shiro. Today I would like to share my experience on configure Security on Payara 171, and yes this configuration will different with another Application Server. This can be rephrased to: * you can use a framework (such as Spring Security or Apache Shiro) and create a generic security implementation that will work on *any* application server , * or tie your application to your application server by using proprietary security resources that only work for that particular app server. It should be obvious what is the correct approach, and I am a little disappointed that the article demonstrates the wrong one. 
Find an open source project that has paid developers from different vendors. Contribute good code, become an expert. 
java was never what held minecraft back. im baffeled people still believe that c++ is so much more powerful than java.
great theyre taking away the ability to use shaders with the justification that you can just by them now. how very generous of them. also the API will never have 80% of forges capability
Notch himself gave an excellent reason, trying out a game. If you like it, then buy it. So many games don't have a trial or demo version, and how are you supposed to get a feel for the game from a video.
I second this. When I was trying to package my app both as a .exe and a .app, the netbeans native app packager was literally 1 click to package as .app.
which is awful. Minecraft lived on its moddability and there's no way in hell Microsoft is gonna carry that on. 
Only if you add the jar as a library first.
C++ isn't more powerful than Java. There are benefits and weaknesses to both. The only real drawback for Java, which Minecraft could use, is that it doesn't have what's called fortran arrays (basically n-dimensional arrays that are still stored linearly, though there are Java variants like X10 that do have them). But even that isn't going to be a massive change in speed. Most Java code actually runs *faster* than most c++ code, because on average, the first write of a java app, between the jit compiler, jvm optimizations, and the gc cycle are more efficient than c++. It is possible for a c++ app to be optimized, on a specific operating system on a specific hardware configuration, more than Java, but the reality of the industry is that most people do not have the time and money to invest into any application to actually make that feasible. Java often makes a memory for speed trade off as well, that since it takes marginally more memory, it can then be even faster. Even things like you mention, that stuff would be ported over to the GPU, which you can call that code from Java directly (there is even an experimental ibm language called lime that compiles java code to CPUs, GPUs, and FPGAs all at once) so that is basically nothing. The C++ is more powerful than Java thing is really a meme by sophomores in college and gamers who don't know a thing about software engineering or computer science.
I still remember when n0tch used to post pics of his WIP on JGO. White blocks...everywhere.
To open garbage collection logs?
Thank you so much for the detailed response. After seeing your answer, I guess I need to use OAuth for getting the refresh tokens to implement user logout/change of password etc. Actually I had a look at OAuth before, but for me it seems that OAuth should be used when user needs to get authentication for 3rd party apps like Google, Facebook etc. Now I'm wondering if I want to use OAuth to issue refresh tokens for my own website authentication, should I build my own authentication service on top of OAuth protocol? 
Great list for web stuff. I would add Logging - Why does nobody know how to properly use a logger these days?! Metrics - Nothing like being asked to debug why your app is slow and having no data to work with. Maven - Like it or hate it. Its so much better than Ant scripts. Java.util.concurrent - If you are extending Thread you are doing it wrong. Jsp/Jstl - It sucks but its used everywhere in web apps. 
This book should be required reading. I tear my hair out every job I go to when I see people messing up basic things like exception chaining.
I haven't noticed any of those things and we use it heavily at the moment.
Spring is definitely a good default but has a suprisingly steep learning curve unless you can use spring-boot. I would argue that unless you need to integrate with other j2ee features it can be a bit overkill. It is also a bit slow to start with all the classpath scanning it does.
Hey Durple, I read that you Worked at Globe Tap Bar and Grill in the Kitchen..I was there opening day and was the Kitchen Manager after the Chef Dave Gallo Stormed out on a Friday Lunch rush... who are you?
Sorry, I somehow misread the post. I thought it was heap dump. My bad!
I'm currently taking the Udacity Java course- am still very much going over the basics, but it seems like a helpful way to get oriented.
Interesting, r/java is not where I would expect to run into someone from there! I was also there opening day. Well actually, a week or two before opening day, helping Dave scrub down the last of the big kitchen pots that were inherited from the various businesses that inhabited that location before. I mostly worked days while they were still trying to promote some semblance of a lunch business. Dave treated me as sous chef and let me come up with salad recipes for the monthly specials. When summer hit I'd also come back around 11 Friday and Saturday nights serving burgers and dogs off a bbq that one of the owner Marks had brought in for after the kitchen closed. PM me if that rings a bell :) (When I left Dave was still there. I could totally see him storming out tho lol. I was always in his good books, but for anyone who wasn't -- look out!)
&gt; seems that OAuth should be used when user needs to get &gt; authentication for 3rd party apps like Google, Facebook etc. Google, Facebook, etc., provide the authorization server and manage authorization grants to apps making use of services provided by Google, Facebook, etc., or apps registered with Google, Facebook, etc., to make use of their services. Since OAuth is a [generic authentication/authorization protocol](https://tools.ietf.org/html/rfc6749), you can certainly host your own OAuth authorization server to serve your own authentication/authorization needs for your own services. Spring Security comes with [an implementation](http://projects.spring.io/spring-security-oauth/docs/oauth2.html) so you don't have to implement the OAuth protocol yourself. You can configure Spring Security to use JWT as the access token format. You don't have to use OAuth of course, which has a lot of features which might not sense for an internal application (such as the permission flow to allow third party applications access to your app). You can implement a part of OAuth, or your own security protocol entirely using access tokens and refresh tokens. Of course, rolling your own security isn't always the best idea...
Well it technically is more powerful, because it has manual memory management and other lower level features, leading to more possibilities for optimization, but *power* does not necessarily mean *performance*. The most widely used Java virtual machines are very well engineered and can do a lot of runtime optimizations that ahead of time compilers can't do. Java is a perfectly good programming language to use because Minecraft in now way requires the types of optimizations that would warrant using a language like C++.
Cloth physics could be implemented in the Java version right now, but it would take lots of effort for a pointless feature that doesn't fit the style of the game.
But it requires OSes that Oracle doesn't care about and Microsoft only wants to have a single language across the Minecraft codebase. Maybe one day Oracle will care about iOS, Android (besides suing Google), UWP, PS4, XBox, but I don't see it coming.
watch this video for java hosting
Minecraft performance is death by a thousand cuts. Not too many things in the game (aside from the renderer itself) are horrible or inefficient it just has thousands of them. It's an open world sandbox with Turing complete electronics and thousands of entities. The reason I point this out is that when you're dealing with a large amount of small things you need to pay a lot more attention to data layout and access patterns. Java makes this hard/impossible and even if you pull it off with sun.misc.Unsafe the resulting code has all of the verbosity of Java with none of the security or ease of use, the worst of both worlds.
I read the book and really thought "why isn't this required reading???", but I have trouble remembering everything at once when I don't use it regularly. For example your mention of exception chaining: I immediately thought "Oh yeah, that's in the book. Never used it since I read it; is it one of the good things or bad things?".
The first part of the article that talks about Spring calls is good to follow. The second part where the Java code is "changed" to accommodate testing is questionable, so I would not pay attention to it, if you are just starting out.
Apple doesn't allow virtual machines on iOS. Same probably goes for PS4, XBox, etc. Android already uses Java, just a really screwed up version making it less compatible with Java SE, which rightly makes Oracle angry.
&gt; But the article seems clear that the Java mods will not be supported in the new C++ version of MC. This will surely splinter the community. How does this splinter the mod community? The Pocket Edition mods are currently very far from their Java counterparts. Even Pocket Edition has not reached Java feature parity after 6 years of development. Official Minecraft development moves really slowly. The Java mod community is much faster creating fun content. I think that over time this will unify the Java modding community on a single version of the game. * Millions of players play the Pocket Edition (now becoming unified Minecraft) blissfully unaware of the Java edition. * As far as I know Microsoft do not have any plans to make a similar API as the Java modding community. The Plugin API does not seem to go that way. Developers are limited in what features they can implement. * Java skills do not transfer 1:1 to C++ skills (If they make a C++ API). I don't see many Java modders making the switch. In the end, old mods will still work and are still fun. Microsoft will still continue to distribute the official Java libraries. Players will still make and play mods on Java Minecraft. Even though they do not get any new official features, which they can just reimplement as a mod instead. I currently play Java Minecraft 1.7.10 with Forge mods and still have fun. It was released close to 3 years ago. Many hundreds of thousands of players do the same. 
Hi Thanx for the feedback. I cannot seem to recall a talk or post about the benefits and trade-offs, but i will investigate and blog about it. About your comment on deterministic, I agree and i believe they are deterministic Yes these tests will sometimes fail, but that is the whole point. If it fails it found an example in which your system would fail with the given input. The examples with property-based testing are repeatable and this way you can resolve the issue that without these tests you would probably find in production only. The given example that is run by the framework is deterministic. Because it is repeatable. Running that example a 100x will fail the tests a 100 times. It is just a different seed it is running against the same tests. So yes they are deterministic imo, more importantly they are repeatable. Also, can you tell me what exactly makes the test unreadable to you, so i can learn from it and improve it :) ? 
Quick question. How is your context reacting, if one uses cookie(name, value) and then after that tries to use the getter. Would the new cookie be included? If no is there a way to get the newly set cookies? 
That is a lame excuse, all commercial Java compilers support AOT compilation to native code, even Java 9 has some support for it on Linux/x64 systems, with more support planned for Java 10, but with no mobile OSes updates in sight. Also Xamarin used to sell .NET AOT compilers for those platforms, to the point that Microsoft ended up buying them, which makes C# more of a WORA story on those platforms that Java will ever be, thanks to Oracle not caring. Regarding Android, I do side with Oracle, but that is just one platform among all the others that enjoy C++ and C# support, but lack Java.
You're not my supervisor.
Coming soon.... every tree will have an azure ad.
Java GC absolutely was a problem for minecraft. Much of it stemmed from the bad design of minecraft of course but maintaining 60fps with java gc on consumer machines isn't all that easy in the first place.
He did make this comment prior to the demo, and I think since then he has reiterated that this is still his opinion.
&gt; better portability Still waiting for their linux version...
Well, this kind o answers what I asked in [the thread I opened the other day](https://www.reddit.com/r/Minecraft/comments/6gr1s9/regarding_the_future_of_the_minecraft_java_version/). Microsoft is moving towards their fancier, closed version of the game so they can sell everyone mods and skins. God bless "industry" and big companies runinig everything nice. At least the Java version will still stay as it is. I'm wondering what will happen with those who use Mac, Linux or Windows 7 machines...
Java was always the wrong language for the game. Sucks that existing mods won't work, but that's what happens when you port an entire game to a different language like this. The performance increases should be worth it in the long run.
the problem was that MC abused the GC to all hell. creating thousands of objects every frame and then manually calling the GC
I don't think it manually called gc. At least I've never seen that in the server. MC did create tons of objects, but this is less of a problem in a runtime where you can stack-allocate (for example position vectors). Java definitely did play a part there.
C++ is surely not as portable as Java? You can run the JVM on a lot of different platforms already, meaning anything you write in Java can run on all of those different platforms. With C++ you'd still need to develop things specifically for certain platforms, wouldn't you?
You might be interested in Tailor, which does something similar, without iframes: https://github.com/zalando/tailor
Frameworks and libraries will help you, but they won't last eternally. What every devleoper should know is the SOLID principles. This will help you during the duration of your career.
Without it it can be literally impossible to debug exceptions because you are throwing away exception information.
Creating objects isn't a problem so long as they're short lived. Allocation in the Eden space is done by pointer bumping which is faster than a call to malloc. When a minor GC runs it only copies live objects to the survivor space so the collection of dead objects in Eden is effectively free.
+10000 does not mean anything without benchmark and analysis of the asm generated it's useless.
Java is meant to be run in a virtual machine. The new AOT options do not negate the need for a vm. Besides, do you really think Microsoft would allow a language they tried to destroy on a platform they created? They already use their Java knockoff C# on their platforms and seem to want only languages they control on their platforms. I wish there were JVMs for more platforms, but it probably won happen.
Cookies (and other headers) are still set directly on the request/response, so you won't be able to get a cookie you just set. You could inspect the response and get it from there, but what would a typical use-case for this be?
Open closed principal..... Extend classes to add functionality, rather than update the base class...... leading to huge class hierarchies. Yeh, right. 
Modular code is better because of a better readability and ease of change. Modular code is organized code. You'd rather have a few huge classes?
The only Java to machine code compiler I've heard of was the GCC one which was discontinued, and I guess the Android Dalvik one. What are other ones that are out there?
What would you call it when I have a problem that doesn't require concurrency, but it turns out that it's a nice way to structure the program. For example, a compiler with a lexer and parser. I could fully lex and then fully parse, or I could have concurrent tasks, and alternately run my lex and parse coroutines, pausing one when the other has enough work to start going again.
Probably going to get hate but seriously the groovy ?. operator is my favorite thing about any JVM language period 
Yeah that's very true. That's not what I was insinuating though. I was talking in a more general sense.
MVC
Hmm I'm not sure I think that's a sensible thing to say. If the user requires a pure function to take a string and produce a parse tree, and that's all they care about, and I choose to totally internally use concurrency to do that, not visible to the user in any way at all, then I'm not sure you can sensibly say I've restated the problem. Otherwise all program design decisions could be called 'restating the problem'.
OO 🙂
Still, without the measurements it's not worth to even ponder rewriting your loops to a less human intuitive way. And we did not even start to talk about what dominates execution time of a program... It's an interesting fact to know but I'd say 99.9958% of Java programmers will never be in a situation where they need this knowledge to save the day.
Did you even watch the video or just cherry pick from some of the slides you scanned? 
IBM J9 AOT still requires a vm for the program to run.
Then it is structuring it as "communicating state machines". In fact, coroutines were used (by Melvin Conway) in the 1950s for precisely the lexer/parser problem. A coroutine has a stack of its own. Lua and Kotlin have coroutines, as do Python and ECMAScript 6 with their "yield" keyword. Add independent schedulability to this stack, it becomes a thread. Add an object-like structuring and isolation mechanism to this mix, and you get Ada tasks, Erlang processes, Akka actors etc. Sending a message to an actor helps schedule that object for execution, instead of invoking the object's method directly (in the caller's stack), as would happen in C or Java. I love communicating state machines as a structuring concept, particularly for network and UI applications, and I prefer languages that support lightweight actors natively. There is however a downside, particularly for highly computational domains. Actors fix the granularity of parallelism at code-time. Suppose you are doing graphics. Would you make every Point an actor? No? Why not? Because you don't want to make every Point object independently schedulable. It is just a piece of data, a passive object. There's a lot of overhead to make it "active", schedulable. It is a bit of a black art to figure out just how much data should be present in an actor. More actors means more scheduling and more communication, which drastically drags down performance. This is precisely Brian Goetz's point. His (excellent) presentation is about mechanisms for even finer grains of execution, while still maintaining a structure reminiscent of a sequential program. 
Not on embedded targets. The variant known as Websphere Real Time, using the Metronome real time GC.
return NullObject
Would you please explain 2 scenarios, 1 for each case? They can be really basic. Thanks
Do you mean something like this? https://www.tutorialspoint.com/design_pattern/null_object_pattern.htm
Concurrency is a property of the problem. Concurrent languages give you mechanisms to address the problem. These mechanisms also allow you to take advantage of parallel hardware. Your solution is about taking advantage of the parallelism capabilities of the language. The problem itself has nothing inherently concurrent about it.
No there's no parallelism in my example at all. That was deliberate because I knew people get this confused! I'm talking two coroutines. Only one runs at a time. The program can either be lexing, or parsing, but not both at the same time, and they cooperatively yield to each other. It's concurrent because both the routines are active - on their own stacks - possibly on their own threads - at the same time. The two tasks are concurrent, but not parallel.
The user also doesn't have a problem of lexing and parsing, the implementer does; they're separate problems from the outset.
Thanks for the feedback! Appreciate it :)
I much prefer gradle over maven 
You are right. Your solution has concurrent stacks. This fits in with Brian's definition of concurrency as a program-structuring device, whether or not the problem is of a reactive concurrent nature, contradicting my assertion. However, there is no non-determinism; the lever and parser take turns being active, and are indistinguishable from a solution that uses normal objects. Are all objects in a heap concurrent? In a sense they are, but without nondeterminism, I wouldn't put that solution under the concurrent umbrella.
The MessageDigest interface is plain ugly and inconvenient to use because of the crazy checked exceptions everywhere like NoSuchAlgorithmException which is a silly thing caused by the use of magic string constants. If you're going to use it either wrap the thing yourself or use existing helper libraries like Apache Commons.
The most [common patterns](https://en.wikipedia.org/wiki/Software_design_pattern) I use intentionally Java is the Factory Pattern (because you can't override `new` in Java) and the Strategy Pattern (to implement the O in SOLID - Open/Closed Principle and to implement callbacks). I use the Template Method Pattern to make classes sensibly extendible. The most common patterns I use unintentionally are the Iterator Pattern (`for` loops) and the Proxy Pattern (Spring uses this pattern heavily for AOP, for example automatically starting a database transaction on method entry).
##Software design pattern In software engineering, a software design pattern is a general reusable solution to a commonly occurring problem within a given context in software design. It is not a finished design that can be transformed directly into source or machine code. It is a description or template for how to solve a problem that can be used in many different situations. Design patterns are formalized best practices that the programmer can use to solve common problems when designing an application or system. Object-oriented design patterns typically show relationships and interactions between classes or objects, without specifying the final application classes or objects that are involved. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^] ^Downvote ^to ^remove ^| ^v0.2
It doesn't enforce the check anyhow, lazy programmers will just call get() on the Optional plainly because nothing stops them.
Very interesting, who cares about the benchmark, just happy that i learnt something. :)
 &gt;I didn't watch the video. Of course you didn't. You're intuitive genius transcends context hidden in a digital stream of a man who is decidedly a god in the Java world. You're ability to divine that context with a single glance of a presentation slide should be rewarded as sign to others that you should be heralded as well, for you is smart and stuffs. No don't count yourself slightly diminished at all despite your 'sounding way more critical' as you are, again, an intuitive (yet humble because you 'liked' his slides) genius. 
Since the sdk has high throughout creating empty collections seem kind of an overhead.. would you say that wrapping a collection in an optional is bad practice? (So the collections get created only if they contain elements)
Even looking at the assembly won't necessarily tell you if it's faster, it will depend on your specific CPU and workload. Benchmark is king. We've actually had to "un-optimize" code because a newer CPU actually ran slower than the older one when running a specific workload. In its simplest explanation, the newer CPU ran half speed of the older one, but supported out of order execution. That meant the vast majority of general code ran faster, but it ended up running optimized code slower (since that optimized code was often vectorized and optimized for memory accesses). Basically went through and undid a bunch of "speed ups" for the new CPU.
I'd like to commend you for putting yourself out there. In this case your intuition may have gotten the better of you, though. I hope you don't let reddit's reception ~~persuade~~ dissuade you from pursuing your curiosity and instead treat it as an opportunity to learn something new.
I really like the release logs of Gradle. They cover information for CTOs, devs, and API users.
There is no enforcement either way. Someone who doesn't care about correctness will just call get() to get their work done. The only difference being that the tooling working with nullity is much more mature then the tooling around Optional so static analysis that you're using might not even detect everything that well nicely.
Do it! Over the past few years, I've converted the vast majority of my department's projects from maven to gradle. Way less work than I expected, we're much happier with the builds, and the difference in speed is huge. Maven users never believe me when I say a build used to take 20 minutes now takes 3, but its true. Parallel execution, caching, work elimination, they really can make that much of a difference.
I had tried to convert to Gradle (for standard java projects) back when Android studio had just started its beta process (for timeframe). I was not impressed then... I probably still won't like it, but if it's that much faster, I can learn to like it.
https://i.imgur.com/u3xMlEn.jpg
The gif reminds me of [Buck](https://buckbuild.com/)
I've felt that way since the first time I had a christmas present that was a lemon and had a company give me an artful run-around in customer service and ultimately didn't get it replaced. Structuring society around competition is fucked up and megacorporations have it down to a science. Minecraft was always going to die this death as soon as it became popular
I would like to try Gradle but as far I know querydsl won't work with gradle properly :(
StrategyFactorySingletonBeanObserverQueueManagerImpl
Mostly command &amp; builder..
I use this. It works under Linux I haven't tested under different platforms. https://github.com/federkasten/appbundle-maven-plugin Takes a bit of config, but creates a dmg with the app bundled.
What is this?
null. Why create an extra object that any sane caller is going to check for null anyway?
is this an advertisement or something?
[Big ball of mud](https://en.wikipedia.org/wiki/Big_ball_of_mud) :|
##Big ball of mud A big ball of mud is a software system that lacks a perceivable architecture. Although undesirable from a software engineering point of view, such systems are common in practice due to business pressures, developer turnover and code entropy. They are a type of design anti-pattern. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^] ^Downvote ^to ^remove ^| ^v0.2
&gt; Are you saying the JIT automatically rewrites while loops to count down to zero? Yes. Look at the other discussions tab at the top, read that comment thread.
It can be but rarely is that the case outside serious, serious number crunching. Most GC and memory related issues can be addressed with proper design like flyweights, and truly slow spots can be moved out through the JNI to C++ anyway as long as the JNI is crossed minimally because of performance cost.
I see only two relevant factors to benchmark: how quickly the `for` statement advances (forwards vs. reverse) and how fast you can operate on the loop index (direct operation vs. array lookup). It doesn't really make sense to extend the duration of the loop body since that would be doing more work that has nothing to do with either of the above. In this context including the enhanced `for` statement isn't very interesting either because it really can't compete. The enhanced `for` statement is syntax sugar for for ( Iterator&lt;Object&gt; it = list.iterator(); it.hasNext(); Object item = it.next() ) { } (with some special-casing to adapt raw arrays; maybe with `new Iterator()`?). The instruction used to call a regular method, `invokevirtual`, is the most expensive instruction in the language (*possibly* excepting the newer `invokedynamic` for lambdas but I don't think so) and it's a lot more expensive than raw array access. And there are three method invocations right there.* "We know" that intuition about [locality of reference](https://en.wikipedia.org/wiki/Locality_of_reference) (so, cache lines and CPU prefetching) holds up in the JVM even though Java makes it a little difficult to take advantage of. The regular loop has much better locality, especially when dealing with primitives. ^(*It used to be a formal recommendation to use raw arrays instead of collections in Android where ergonomically feasible precisely because they're a lot speedier. I don't know if it still is.)
Optional&lt;&gt; FTW! Personally, I've found it's extremely rare for object instantiation causing a bottleneck in an application. Especially something as lightweight as Optional (has only 1 field...). For the same reason as adding "throws MyTypedException" to a method forces callers to think about handling it, returning Optional forces callers to interact with Optional. Lazy programmers can do a blind optional.get() the same way lazy programmers can do "catch (Exception e) { throw new RuntimeException(e); }", or worse, ignore the exception and continuing. Keeping with the "throws" example, you can add @throws IllegalArgumentException to a javadoc, but less people will write code to handle it than throwing a typed exception, because not every programmer does the research of reading every javadoc/annotations. @Nullable can be unknowingly ignored by some programmers with the best of intentions. Like others are saying, Collections.empty*() should be used in place of Optional&lt;Collection&lt;&gt;&gt;. Just keep in mind those collections are immutable, so callers attempting to modify the collection will get exceptions.
Get this off my front page Jesse!
If you've seen pre-generics Java code then casting was pretty much the only way to do containers etc so the type system didn't really protect indeed.
We've moved pretty much our entire codebase (repositores and services in Spring Boot microservices) to Optionals for 0-1 return values and collections for 0-n return values. Optionals just give you a lot more ways to deal with what's returned: an isPresent check, an ifPresent call, mapping, throwing an exception, returning a default value, etc. So definitely in favour of using Optionals. 
&gt; It doesn't enforce the check anyhow, lazy programmers will just call get() on the Optional plainly because nothing stops them. If you have that kind of developers in your team you need CheckStyle and CheckStyle warns against this. So no; it's not the same thing. 
&gt; IsPresent checks are just like null checks, there's nothing inherently different. You have a LOT more options than just an isPresent check. It's the option we in general use the least in our code. We .OrElse, .map or .orElseThrow are used a lot more. User user = userService.get(1).orElseThrow(UserNotFound::new); IMHO much more concise than: User user = userService.get(1); if(user == null) { throw new UserNotFoundException(); }
DTO and DAO
That is what I referred to in my second paragraph. Just replacing a nullable reference with an Optional will make people use isPresent instead of the null check they used to have, not rewrite it functionally or learn functional patterns. My point is that Optional is useful if used right but it's not a silver bullet to solving problems with null. I've seen this a lot and tutorials on Optional don't emphasize the functional aspects of it enough. In a way Optional::get() could even be considered a mistake which allows the programmer to just avoid dealing with exceptional cases.
IMO a sign of very inexperienced programmer not to check for a certain thing that can blow-up. Who'd actually think that Optional always contains a value, when it explicitly says otherwise?
&gt;The language changes. The language changes and so do decent developers but the truth is that this is an extremely slow process. Java 6 is still widespread in the industry (ahem, Android) as well as developers who continue to use old practices and code style in the new language. This fact should not be plain out denied because you might not be in these circles. Updating the technology in enterprise is never a flash decision so this stuff keeps happening. &gt;Why are you reasoning against a point no one made? All reasoning doesn't need to be an argument with someone... 
Once upon a time, I came across an [SO question](https://stackoverflow.com/questions/39588251/in-java-can-be-faster-than) which asked whether `&amp;` was faster than `&amp;&amp;` for a simple `if()`. «Easy pie!», I thought; «`&amp;&amp;` is short-circuit and thus faster! Just look at the bytecode!». Oh boy, was I *wrong*. The bytecode for `&amp;&amp;` is indeed much shorter but, as I learned after much investigation and tinkering and editing my answer, the actual JIT compiler does not really care about that. It will optimize and rewrite your loops and comparisons depending on number of iterations, processor, Java version, etc. etc. etc. **Lesson learned: *byte code doesn't mean sh!t when it comes to performance*.**
unless you use emacs I'm going to say you don't know what you're talking about... 
Once you've spent 5 years drilling it into your muscle memory, it does!
yeah, I know and I tried, after ~2 hours of fighting with it, QueryDSL generated QClasses for me but I wasn't able to use it in project (I don't know why) and I gave up :/ I think I need to learn gradle syntax and then try again, because copy-pasting source code from internet is pointless, because I also use MapStruct and Lombok, so configuration these three things may be tricky. 
Null-checking something that the API guarantees to be non-null and which is in fact a type that specifically exists to elininate null checks is not sane, it is stupid cargo-cult programming. 
The main difference that makes Optional much better is that calling get() when there is no value will throw an exception immediately instead of in some completely different place where you pass the result to. Also the type itself signifies "there might not be a value here" much stronger than any nullable reference type.
The `NoSuchElementException` might be the only real semantic difference here, good point. If in doubt you should always treat any reference as potentially nullable, especially when writing reusable code like libraries, which will be used by many and also less experienced programmers.
In gradle almost everything is an experimental API and a lot of third party plugins break. It's a pain to rewrite these.
Not at all, not even in Java projects, where I rather use Maven. I only use Gradle for Android projects, because Google forces me to do it. On the other hand I don't suffer from XML allergy, so I don't have issues using either Maven or Ant, and they perform quite fast.
&gt; When you say something like "99.9958% of Java programmers will never need this" what you are really saying is that Java should be consigned to only those applications where performance isn't important. No, not at all. That is a deliberate and utter misinterpretation of what I wrote. &gt; It's that attitude that gives the Java language a bad reputation outside of Java circles. I do not think so. Java's reputation for slowness has been formed quite a while ago when it really was slow. Unfortunately those labels tend to stick for completely non technical reasons; there are plenty people out there who just do not bother to update their believes. &gt; The thing is that Java CAN be fast and efficient, Of course! There are some very fast Java applications around, for example in the field of financial trading. &gt; but we have to dispel with this ingrained notion that Java performance is not important. Performance is important in every application. I am sorry, but that is plain wrong. And even for applications which have advanced requirements for speed you start with the slow parts and optimize them. You will have to iron out quite a few design level and IO caused bottlenecks before performance of these types of loops that have been presented in the linked article even shows remotely on the radar. &gt; When it comes to code, fast &amp; ugly should always take precedence over slow &amp; pretty. That is a complete inappropriate over generalization. There are huge areas in software engineering where readable code and engineering efficiency vastly trumps squeezing out the last nanosecond of performance, because the longer you optimize the more expensive individual optimizations become (see also [80/20 rule](https://en.wikipedia.org/wiki/Pareto_principle)). You can find some nice discussions of Martin Fowler's quote ["Any fool can write code that a computer can understand. Good programmers write code that humans can understand."](https://www.quora.com/What-are-some-opinions-about-this-Martin-Fowler-quote-Any-fool-can-write-code-that-a-computer-can-understand-Good-programmers-write-code-that-humans-can-understand?share=1).
##Pareto principle The Pareto principle (also known as the 80/20 rule, the law of the vital few, or the principle of factor sparsity) states that, for many events, roughly 80% of the effects come from 20% of the causes. Management consultant Joseph M. Juran suggested the principle and named it after Italian economist Vilfredo Pareto, who noted the 80/20 connection while at the University of Lausanne in 1896, as published in his first paper, "Cours d'économie politique". Essentially, Pareto showed that approximately 80% of the land in Italy was owned by 20% of the population; Pareto developed the principle by observing that about 20% of the peapods in his garden contained 80% of the peas. It is a common rule of thumb in business; e.g., "80% of your sales come from 20% of your clients." Mathematically, the 80/20 rule is roughly followed by a power law distribution (also known as a Pareto distribution) for a particular set of parameters, and many natural phenomena have been shown empirically to exhibit such a distribution. The Pareto principle is only tangentially related to Pareto efficiency. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^] ^Downvote ^to ^remove ^| ^v0.2
&gt; It doesn't really make sense to extend the duration of the loop body since that would be doing more work that has nothing to do with either of the above. But keep in mind what your results then say. Just as a simple math example: assume your benchmark really *proves* (which might be quite difficult in its own) that the reverse loop is 25% faster than the forward loop. So, where your forward loop takes 10 seconds your reverse loop only takes 7.5s. Now, assume further that 80% of the time of a single iteration of the forward loop is taken up by things done in the loop body. We get optimized iteration time = 10s * ((100% - 25%)/100%) = 7.5s iteration percentage = 100% - 80% = 20% loop time = 10s * (100%/20%) = 50s body work time = 50s - 10s = 40s optimized loop time = 40s + 7.5s = 47.5s percentage of time used = (47.5s/50s) * 100% = 95% improvement = 100% - 95% = 5% So, from an impressive 25% improvement we arrive at 5% overall improvement - for that single loop. Now, if the program spends 1% of its time in this loop we get percentage of runtime = 100% * (47.5s + 50s * 99) / (50s * 100) = 99.95% relative improvement = 100% - 99.95% = 0.05% Now, from a 25% improvement we arrive at a 0.05% overall improvement. And all this does not include effects of JIT (e.g. maybe JIT translates loops with empty bodies differently) and economic calculations (even a non profit open source project might want to invest their time in what brings visible advantages to users of the software). Edit: added resume I had forgotten initially.
Object pools carry a higher performance cost than stack allocation - I'd more compare them to heap allocation in C. This isn't only because of pool management overhead but also because it's more difficult for the JIT to work with. Then there's certain memory model implications you have to be careful with when using pooled objects. It's also very easy to get pool leaks especially when you have objects which are very widely used such as vectors - a good API helps but leaks still happen, especially when using the objects in fields (as in, not on stack).
well this sounds painful if you rely on many plugins
and interesting link. i'll see if can poke some of the maven guys on this. Fixing maven issues unfortunately often requires touching several different repositories and coordinating everything is a pain. Also unfortunately, it can be difficult to get the maintainers to do stuff, especially if there's no company sponsoring a maintainer (just volunteers) 
(Note: I didn't vote) It's not a matter of controversy. It's a matter of saturation ([number of posts about the same content in a short period of time](https://www.reddit.com/user/javalin_io/submitted/)) mixed with the fact that release notes are not *that* interesting, compared to in-depth articles. Don't see it as something negative. See it as "meh". As a fellow content marketer, I suggest you start a blog and write about things you've learned about HTTP, Java, concurrency, the web, etc. while making Javalin, of course with some Javalin examples, rather than posting pure Javalin content. That's usually more interesting for most people.
I agree with the idea that there are two potential audiences for your code... the computer and other programmers. Someone once quoted Martin Fowler to me as an authority, so I looked him up. He literally spent 2-3 years actually writing code and the rest of his career he has spent telling people how to write code. I have spent 20+ years writing code to make things work in engineering companies. At the end of the day, nobody gave a shit how pretty the code was. By far the most important thing was that it worked reliably and fast. The reason was that the code we wrote enabled the production and sale of some tangible product, like semiconductor chips. I now work for an agile software organization now and there is a huge emphasis on code legibility and "smells". There's a lot of process and emphasis on design patterns. Productivity is a lot lower here. My point is that I've worked extensively in both areas and can tell you that Martin Fowler had no idea what he was talking about when he made that quote. It might sound good in a book he wants to sell you full of perfectly structured good and very affirming to software developers, but it is a LOT harder to write code that runs efficiently. Martin Fowler is an writer, first and foremost. He is not an expert on software development.
I see. The fetch size specifies how many rows should be fetched from the server (database) in bulk. So, yes, setting this to 20 will initially fetch 20 rows, and when you need the 21st, it'll fetch another 20 rows. But this is only reasonable if you're consuming large parts of the result set in one single request. From what you're describing, you should probably use keyset-based pagination (or if you must, [offset-based pagination](http://use-the-index-luke.com/no-offset) with all its drawbacks) and run a new query per request. This has nothing to do with JDBC
&gt; collections for 0-n return values Why not streams? If you declare the return type of a Spring Data query as a stream, the query will be evaluated lazily, i.e. it can defer fetching elements from the database until you actually need them.
I'm confused - are you agreeing with me?
&gt; i thought if the fetch size was set to N, attempting to access the N+1'th row would simply return no records - like fetch size would act like "limit" That's [`Statement.setMaxRows()`](https://docs.oracle.com/javase/8/docs/api/java/sql/Statement.html#setMaxRows-int-). But you should *always* use SQL LIMIT, because if the database knows you only need 20 rows, then it will run a much better query plan than if you just instruct the client to stop after 20 rows. &gt; Too bad JDBC does not have some kind of pagination system, though. It seems pretty easy to implement, or am I so mistaken? Yes, you're mistaken, and it's great for JDBC not to have one :) JDBC is a network protocol abstraction API. Its purpose is to shield us users from the hairy details of how to communicate with individual databases over TCP/IP (or other channels), and it does this quite well. The fact that queries can be paginated *at all* is none of JDBC's business, it's part of the query language that JDBC has absolutely no idea of. It's just a String that you pass to the `prepareStatement()` call (or other calls). Your suggestion of implementing pagination on a JDBC level implies that the query language is no longer transparent to the network protocol abstraction layer (JDBC), which should know nothing about the delicate syntactic intricacies of pagination. JPA made that big mistake, among many many other mistakes. For instance, it implies that offset pagination is the preferred way over keyset pagination, which is a silly mistake a lot of people still make. [Details here](https://blog.jooq.org/2016/08/10/why-most-programmers-get-pagination-wrong/). Again, the `setMaxRows()` method is a reasonable feature as it doesn't really paginate, it simply stops worrying about more than X records, which is an entirely client-side feature. This doesn't touch the server *nor* the query language. **TL;DR:** Just use SQL's LIMIT for pagination, preferably along with keyset pagination. Side-note: I feel what you really need is www.jooq.org (Disclaimer: I'm biased of course, working for the vendor)
&gt; Why not streams? In practice: because I haven't convinced colleagues yet ;) I'm quite a big fan of reactive programming and am definitely going to push for trying it in at least one new micro service once Boot 2 is released. TL;DR: yes please (when applicable). 
Blindly relying on the integrity of 3rd-party code while you are writing your production-worthy code is not sane. You can revel in your snobbish insults. I prefer my code to not crash because some person whom I've never met and never will had a brain fart.
I mean... the title says "5 things you don't know..." so it *is* about me. It's about anyone that reads it. I don't take downvoting personal; I just don't agree with the hive-mind approach it perpetuates ("Think like us or feel our wrath"). But, hey, that's the basis of reddit, so whatever. It's not a meh-ish form of disagreeing; a meh-ish form would be to ignore it and move on. To downvote takes effort. Effort does not equate to meh. Which begs the question that if you feel strongly enough to downvote, why do you not feel strongly enough to say why? My constructive criticism is that I'm the intended reader, and I don't like being insulted. I would assume others feel the same way, but if they don't, that's fine too. I started with "I'm sure I'll get downvoted for this," because I've said similar rants before (because these garbage titles pop up every couple of weeks), and that's always what happens. Swear words help to express the amount of irritation at such an insult. I'm actually quite a chipper person. I just don't like being insulted by someone who is trying to earn a read from me.
The only thing I'm still missing is archetypes.
Yeah, definitely. I'm totally in favour of returning streams since they're more flexible. 
I'll admit it! The only reason Groovy and Kotlin even exist is because Java is so bureaucratic and unattentive to the needs of ordinary devs.
Thank you all for answers!
There was a huge lag in development on Java for a few years after Oracle acquired Sun. Transitioning a big and complicated project like Java required time. They seem to be back on track now.
Different definitions. Clickbait for me is a shock title just for the juicy juicy click. Also self promotion.
I went with the HTTP2 client, though I'm also really looking forward to the concurrency improvements and collection factory methods. Having a built-in, non-blocking HTTP client is going to do a lot to encourage a migration away from the sort of blocking APIs that cause me a decent amount of pain, as well as allow me to drop a dependency or two from libraries I maintain by having them rely on the built-in HTTP client. As for the other two, a sensible and unified way to create collections from a few given values is well overdue (as opposed to Collections.singletonList, Arrays.asList, etc.) and having an interoperable Reactive Streams interface in the stdlib will do a lot to encourage a move towards that and away from nightmarish callbacks when integrating with event-based systems (ActiveMQ comes to mind).
There's an option for selecting any other new feature if you wish. I've scraped all the JEPs and put them to spreadsheet. Here they are for your convenience: https://docs.zoho.com/sheet/published.do?rid=30xmz0ac7a8c7ce57470a95989c496e973367
&gt; you're thinking it's some sort of automated bot that farms accounts, using some script to post links and collect a bit of karma, but never commenting ? Thats about what I thought, yes. Whether the endgoal is spam or bot-downvoting I don't know. &gt; how widespread are these accounts ? Just today there were twomore in this very sub: https://www.reddit.com/r/java/comments/6hf97q/700000yearold_elephant_fossil_found_in_central/ and https://www.reddit.com/r/java/comments/6hf8av/c_java_excavation_finds_ancient_megafauna_thu/ 
This subreddit deals with **Java, the programming language** exclusively.
On raw arrays, it compiles to a fairly straightforward loop with an index. See the [JLS](http://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.14.2).
Hah! That'll teach me.
Why not null with @NonNull/@Nullable?
We hear you, and a significant amount of the rest of the year will be spent providing better tools to allow plugin backward/forward compatibility. Thanks for the feedback!
Buck has provided some great inspiration.
Out of genuine curiosity what kind of 3rd party plugins do you use? 
Builder, DAO and some Visitors.
We used to use some plugins for getting around our proxy (which was problematic for the normal tools) and for interacting with a very weird service which is apparently quite popular with the industry I'm in, but not anywhere else. There was also a couple of in-house plugins for out specific deployment needs, but now we just use python scripts for that, since they are less of a pain.
But we're not measuring the unknowable loop body, we're measuring the loop statement *overhead*. Since the result of that measurement was unsurprising the relative improvement just isn't relevant. It's a largely meaningless micro-benchmark.
Don't know enough about your SDK to have a real opinion for you. My own APIs tend to be very conservative (JDK 1.6/7-era), so my rules tend to be: * IllegalArgumentException thrown for bad input, including null checks on arguments. * Return empty collection for no data in sets, not null: behave like a ResultSet with no rows. * Return null for missing values in key/value stores: behave like java.util.Map. * Return empty string ("") for fields that will be stored in a SQL database: do not expose "(null)" to end users. (And add logic on the back end to distinguish between SQL NULL and empty string for Oracle databases, because Oracle sucks at SQL-92 compliance.) * Do not catch unchecked exceptions, allow them to propagate to callers. * Where possible, catch checked exceptions and handle them automatically without having to throw something else. When that is not possible, add it to the throws clause. Usually this will be only to propagate existing commonly-used standard library exceptions (IOException, SQLException). * The exception to the above: catch UnsupportedEncodingException and rethrow it as generic RuntimeException. No need to pollute the API for the nonexistent case of a JVM without UTF-8 support. * Use new checked exceptions rarely. Where possible, subclass off an existing standard library exception (e.g. a ReadTimeoutException as a subclass of IOException). So far I am satisfied with the above.
It's almost as if testing confirms hypothesis and not the other way around.
A bit late, but if you plan to use it extensively, I'd recommend to read the full specification, which is well written and concise, because there are some nuances: https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/jniTOC.html JNI tips on Android web site are likely to be useful too: https://developer.android.com/training/articles/perf-jni.html Also consider using `-Xcheck:jni` [JVM flag](https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/clopts002.html) when running your integration tests. In this mode JVM will perform some additional checks to catch JNI programming errors.
Don't listen to the people who insist that every attribute needs to be non-public with a getter / setter.
Thanks for your input! You got some interesting points :)
Thanks Lukas, you make some valid points. In your experience, do people really prefer in-depth articles? To me it seems that people favor flashier and shorter articles and examples.
Except that decent IDE's catch a possible violation
Even just giving us properties would cut down on a lot of boilerplate.
Works on TomEE 😴
No it doesn't. Now stop whining. 
There is a dedicated language feature for iterating over arrays: foreach. Unless your compiler is shitty (in Java's case, it isn't), using a dedicated language feature is probably faster than doing the same thing by hand, since any performance issues with the compiler's implementation are likely to have been found and fixed already.
&gt; @Param(value = {"1", "10", "1000", "1000000"}) Benchmarking a running time of milliseconds. Is that even meaningful anyway?
Sorry meme police I will be sure to not that again ;)
Just some light-hearted fun :) Nice article btw.
how so?
Defenitly not in JavaScript https://stackoverflow.com/questions/22155280/why-is-native-javascript-array-foreach-method-significantly-slower-than-the-stan
I would not know about the JavaScript side but sometimes optimisation technique that were once valid are not anymore. Would v8 or nashorn not be able to generate the adequate native code? 
That's a function, not a language feature. JS doesn't have an equivalent to Java's array foreach.
You can view this demo here: https://sse-demo.cfapps.io/
I used default jmh settings 10 forks 20 warmup iterations 20 iterations iterations length 1s. It took about an hour to run. Jmh is a robust micro benchmark framework and has not issue measuring micro nano level operation. Checkout the jmh sample. A millisecond is a very long time at processor scale that's a lot of cycles
If you are looping more than 300 times (last time I checked. might be less now). It is faster to catch an exception than to boundary check in the for loop. like... try { for(int i =0;;) pixel[i++] = i * 23; } catch (Exception ex) {} Only if you need to go there though. edit:correction.
I'm skeptical about that goes against a lot a my personal experience, only one way to prove it, write a jmh benchmark! Post the source and the result, wait for comment
The boundary conditions are not even the same in the two example loops. One goes 0 to 9, the other 10 to 0 (inclusive). Not that it really matters to what is being discussed here, but it casts some doubt on this guy's programming ability.
[removed]
Nice work! I've had to fight with people writing custom implementations of things like hashmaps because they are "too slow" and theirs is "faster". No benchmarks and they refuse to even run them. Usually they don't even work right.
The reverse loop version should start from 9, not 10.
IE11 has negligible market share, like under 2%
Please do this. Now I'm curious.
That would be terrible :)) You are a very bad person :) /s I use (sometimes) the false test instead the **"!"** Operator because the operator is often not visible at first glance and this will result in errors. E.g. see below... /u/ptrwis miss the **"!"** in my example. Sometimes, for very long conditions I put the false statement at the beginning of the statement. Especially when you have to scroll to see the entire code line. if (false == (a_very_long_condition....)) A better solutions would be to create a helper method like...e.g. boolean isBankAccountUsableFor(int customerId) { return condition1 &amp;&amp; condition2 || condition3; } or reverse... boolean isNotBankAccountUsableFor(int customerId) { return !isBankAccountUsableFor(customerId); } when I use now if (isNotBankAccountUsableFor(222)) { } I think the intention of this code is now very clear. instead if(!condition)..... I would prever a 'unless' statement like in ruby. unless (conditional) { code } else { code } 
Nice write up and thanks for doing it. It's important to note that different processor architectures will yield different results as well. And not just ISA, but even within processor families. Pentium 4's had a stupidly long pipeline compared to Core processors, for example. Until you benchmark against your target, you won't really know. I took over as performance lead on the project I'm on now, we managed to get the PS4 and XB1 to 98% core utilization with negligible thread overhead. These micro opts are cool academically, but if we went nuts all over our code, we might get back .5ms simulation wall time better spent elsewhere to get time back. We're saving that last 2% in case shtf, but pretty cool. Being basically done at this point, it's amazing how many people make assumptions about performance without profiling it. 
&gt; people slightly missed the point of it because of my title Welcome to reddit where time is money and titles are all we ever read.
Maybe so, but if it's the default browser of the enterprise who's speccing your work, it's effectively mandatory to support it. 
yes that's from the original blog post. the benchmark start at length - 1.
but the end is still based on the base code analysis ignoring the hotspot optimisation. moving thing out of the loop might not have the actual consequence you think they have. as I said moving the array length fetch before the loop does not have the impact you're saying. Hotspot try to recognise well-known pattern of coding and optimise for that, try to optimise for byte code might make it less likely to identify the intent of your code making it harder to optimise. - see the might there :) - the only way to prove that it might have a positive impact is to run a benchmark and to validate that what is happening is what you think by looking at the asm. I'm thiking here about the paper about StringBuilder that argues that sb.append().append() is faster because of skipping an ALOAD when really what happens is that it falls in the pattern recognition for some optimisation. 
I hope your saying that for [Chaoslab](/u/Chaoslab)
&gt; Ever heard of transpiling? Then you lose the potential optimizations that newer JS implementations might have for `for…of`.
Not on the site I'm responsible for, it's not. IIRC it's more like 10%.
Transpiling for old browsers doesn't prevent you from serving the original source to newer browsers. 
Yes, you're right. I may have overly generalised "in-depth" when I meant: - Very tempting title - Great intro - Examples, caveats, lessons learned - Possibly some in-depth content thereafter, with further explanations, for those looking for it It depends what you're after, of course.
What's your opinion on `java.lang.Boolean` for three-valued logic?
thanks for your article. It will help
Ok, now we're talking with real examples and numbers, but I've noticed some things in the code that bugs me and made some correction, so could you rerun the tests with this changes and display new results. I'm really curious regarding it :) @Benchmark @CompilerControl(CompilerControl.Mode.DONT_INLINE) public long testForwardLoop() { long l = 0; int len = numbers.length; // read the first article where backward is faster for(int i = 0; i &lt; len; i++) { l += numbers[i]; } return l; } @Benchmark @CompilerControl(CompilerControl.Mode.DONT_INLINE) public long testBackwardLoop() { long l = 0; int len = numbers.length; // read the first article where backward is faster for(int i = len; i &gt; 0; i--) { // don't do double comparrison &gt;= , try just &gt; l += numbers[i]; } return l; } In first text where it's stated that backward is faster, author noted that it's faster if we declare variable that will be used as a reference in the loop, than if you use ```numbers.length```, so I added that change in the code. In the backward loop test you had ```numbers.length - 1``` and also ``` i &gt;= 0``` I personally think that that takes some more operations so i tweaked that code also to reflect forward loop's code. I removed ``` &gt;= ``` since you're doing double comparison ``` i &gt; 0 || i = 0 ``` Backward and forward loop tests are now the same since we are removing unnecessary logic that's initially added. *Note: I'm not an expert programmer but rather junior dev with some of my logical thinking included.*
&gt; It's a largely meaningless micro-benchmark. Exactly my point. Sorry, if that has not become clear. Edit: spelling correction
I doubt it will make a difference, but what you can do is checkout the repo do the change and run it on your machine and check for yourself :) If you look at the asm generated the actual arraylength read is done outside the loop. '&gt;=' is actually one operation jge. https://en.wikibooks.org/wiki/X86_Assembly/Control_Flow#Jump_if_Greater_or_Equal also by uing &gt; you never read numbers[0] 
... + NIH syndrome
JMX is horrible. That's what it is.
When you're doing something that has been standard for a long time, there's a good chance the compiler has found a way to optimize it.
I added that to the quote
&gt; Which is a decent framework for smaller games It's like saying that OpenGL is only decent for smaller games.
i wouldn't say that, its good for getting informations from inside the jvm. also invoking functions is pretty useful via jmx. 
When designing the database schema, choosing the most compact column types that can fit any possible value is the way to go.
Alright, I did the testing regardless that I have never did this before today but hey .. we always learn :D The results 1st is with original code, 2nd is with edited code: Original code Benchmark (size) Mode Cnt Score Error Units LoopBenchmark.testBackwardLoop 1 thrpt 200 207584572.766 ▒ 3141903.533 ops/s LoopBenchmark.testBackwardLoop 10 thrpt 200 136862543.734 ▒ 482340.824 ops/s LoopBenchmark.testBackwardLoop 1000 thrpt 200 3006372.893 ▒ 22399.750 ops/s LoopBenchmark.testBackwardLoop 1000000 thrpt 200 2453.124 ▒ 18.636 ops/s LoopBenchmark.testForwardLoop 1 thrpt 200 205697452.214 ▒ 3832688.507 ops/s LoopBenchmark.testForwardLoop 10 thrpt 200 136606549.210 ▒ 1417924.205 ops/s LoopBenchmark.testForwardLoop 1000 thrpt 200 3061581.808 ▒ 4899.013 ops/s LoopBenchmark.testForwardLoop 1000000 thrpt 200 2836.776 ▒ 6.013 ops/s Edited code Benchmark (size) Mode Cnt Score Error Units LoopBenchmark.testBackwardLoop 1 thrpt 200 208703243.302 ▒ 1576926.598 ops/s LoopBenchmark.testBackwardLoop 10 thrpt 200 131543991.800 ▒ 753186.959 ops/s LoopBenchmark.testBackwardLoop 1000 thrpt 200 3026393.264 ▒ 4934.237 ops/s LoopBenchmark.testBackwardLoop 1000000 thrpt 200 2495.942 ▒ 12.094 ops/s LoopBenchmark.testForwardLoop 1 thrpt 200 211270357.326 ▒ 2453408.671 ops/s LoopBenchmark.testForwardLoop 10 thrpt 200 137693156.517 ▒ 357275.569 ops/s LoopBenchmark.testForwardLoop 1000 thrpt 200 3044515.220 ▒ 6900.277 ops/s LoopBenchmark.testForwardLoop 1000000 thrpt 200 2823.872 ▒ 9.248 ops/s The edited code: @Benchmark @CompilerControl(CompilerControl.Mode.DONT_INLINE) public long testForwardLoop() { long l = 0; int len = numbers.length; for(int i = 0; i &lt; len; i++) { l += numbers[i]; } return l; } @Benchmark @CompilerControl(CompilerControl.Mode.DONT_INLINE) public long testBackwardLoop() { long l = 0; int len = numbers.length; for(int i = len; i &gt; 0; i--) { l += numbers[i - 1]; } return l; } Had an error at line 18 so correct me if I made some error in this. Overall the results point out that Forward loop is ahead of Backward loop. The difference is really small :) but yea, they do exist The test was run on my laptop: i5-7200U 2.5GHz, 8GB Ram, 250 GB SSD, W10 x64. A side from that I was doing daily tasks, nothing cpu intensive but still those tasks can make some influence on the end result as they require 'some' cpu processing. It would be for the best to have plain default windows (clean install) with default services, no internet connection and background tasks, set to run these two sets of tests :)
Some hints: - OAuth is not an authentication protocol. If you're implementing your own provider, you're probably building your own authentication. OAuth has nothing to do with that - It is generally a bad idea to implement security on your own. Better stick to known and tested solutions like for example Spring Security for OAuth and Keycloak as a provider. Both support JWT
The loop example might be alright, but you forget JVM optimizations that only happen at a larger scale.
don't really follow you there, are you talking about inlining? escape analysis. in what way would that not be alright?
Firstly I gotta learn Java, then I'll check the testing, but thanks :D
It is an authorization protocol. The difference is: - authorization tells you whether a user has access to a resource. So, the user is authorized to do something - authentication tells you whether the user actually is the user he claims to be. The most common way would be a password that only the real user would know 
It's going to be difficult to get a job without a degree. There is no shortage of people who recently graduated who are looking for work. They would probably reject your resume before even giving you an interview, due to the lack of a degree. If you still want to try, you'll need look at small companies, where they may be more likely to take a risk. You should also look into internships. I think most target people in their last year of college, but there could be others which are more flexible.
I think reusing a component is a good Idea, but using it for multiple purposes is kinda discouraging. Personally, I would like to see a similar syntax but within a new construct allowing for a clearer separation. It is called pattern matching but not using it in the statement is strange. Suggestion: matches(obj) { case Integer i: formatted = String.format("int %d", i); } I don't see any usage for `break;` in pattern matching. `break` are really useful to determine a result, for example, using Enums, where multiple states could be reduced. This is not really the case for JEP 305 imo
If you think about it, switch is already pattern matching, but it can only match naive types. 
Why don't use Smart Casts from Kotlin?
Can you show me an example of what you're thinking? I'm curious
Enterprisey stuff. If I recall correctly it's just a standard for declaring that a type is a resource that can be managed. All it requires is a default (no-arg) constructor and EJB also provides some annotations for declaring and organizing your Management Beans
Finally migrating to github is a start. I think that's a huge. Although it's laughable that they request a contract before any commits
There's many different ways to do so, usually it depends on the feature you want to test. The most basic test is to just try to use it, if it throws then it's apparently not supported. If you're interested, [here's](https://kangax.github.io/compat-table/es6/) a website that has test for pretty much every language feature, and uses that to construct a table of browser support per feature. 
jaotc! Although it's a shame it's only halfway there
He might be thinking of this: def format(o: Object) { return o switch { case Integer i: "o: int = " + i; case Double d: "o: double = " + d; default: "o: Object = " + o; } } This expression evaluates to a String object, so you may return it, assign to a variable, use in other expressions. Scala has this feature, Rust has it, hope it gets to Java too :) *edit:* _formatting_
What is your current language that is easy to find remote engagements for?
Check out the [RFC for OAuth 2.0](https://tools.ietf.org/html/rfc6749). The description of the different OAuth flows is very good, complete sample HTTP request/responses (for success *and error* cases) and [ASCII graphics](https://tools.ietf.org/html/rfc6749#section-1.5)! There are quite a few flows associated with OAuth, but it sounds like you want to use the [client credentials grant flow](https://tools.ietf.org/html/rfc6749#section-4.4) and the [refresh flow](https://tools.ietf.org/html/rfc6749#section-6). The OAuth specification doesn't specify logout, but invalidating the refresh token is how you can do that. If you're creating your own OAuth provider, you *may* want to implement the [authorization code flow](https://tools.ietf.org/html/rfc6749#section-1.3.1) or [implicit grant flows](https://tools.ietf.org/html/rfc6749#section-1.3.1). Definitely check out the [security considerations](https://tools.ietf.org/html/rfc6749#section-10).
It's not that hard to improve on the performance of Java's HashMap. Their map is designed using old techniques and for general purpose use. It is resistant to HashDoS and basically doesn't have any pathological cases but that means it is average to poor in all situations.
Not relevant for this post. :)
Thanks! I guess from my requirements, I'm slightly borrowing OAuth 2.0 terms, but may not fully implement them as per my requirement. But I guess my steps are pretty fine (yeah I knew its a very bad idea to re-invent the wheel on security level) but its just a learning process. Today after reading the comments, I came to knew that OAuth 2.0 does provide only the authorization leaving the authentication part to be dealt by the developers somehow. 
You certainly can, however, pattern matching is more versatile. In this primitive example you're fine with `Objects`, as they all have `#toString()`, but what if you need to cast them to the appropriate type? Pattern matching does exactly that for you.
PHP
(Different asker) What about OpenID Connect using OAuth makes it "for" authentication? Asking more about server to server communication.
Yeah, that's correct! Thanks for your time one this.
You can have compiler exhaustivity checking, including required default cases if the match isn't exhaustive. Scala has it (with a compiler flag).
&gt; And the conclusion of all those retrofitting optimization is: UTF-8 as internal unicode representation would have been a better choice than UCS-2 😉 No, because UTF-8 is variable length so it must be sequentially interpreted when trying to do direct access into the underlying char array. Calls to String.charAt would become O(n) instead of O(1). Calls to #length become a problem. You would have to mark positions in the utf-8 stream where the characters are and if you are going to do that then you might as well not store it as utf-8 but something else that's more conducive to what you already are working with. 
The three documents here go into it fairly extensively: http://cr.openjdk.java.net/~briangoetz/amber/
This is briefly touched on in the "future work" section where they mention *sealing*. If you're interested in a little more in depth reading there is some stuff in these documents about it: http://cr.openjdk.java.net/~briangoetz/amber/
It's possible. Especially now when there are not enough Java developers out there. Hit the books for sure but code a lot. Practice practice practice. Know the theory and study the '100 Java interview questions to give yourself the best chance.
Using the code in the sample, I need to write String formatted; switch (obj) { case Integer i: formatted = String.format("int %d", i); break; case Byte b: formatted = String.format("byte %d", b); break; case Long l: formatted = String.format("long %d", l); break; case Double d: formatted = String.format(“double %f", d); break; case String s: formatted = String.format("String %s", s); break default: formatted = obj.toString(); } if switch was an expression, that can be simplified to String formatted = switch (obj) { case Integer i: String.format("int %d", i); break; case Byte b: String.format("byte %d", b); break; case Long l: String.format("long %d", l); break; case Double d: String.format(“double %f", d); break; case String s: String.format("String %s", s); break default: obj.toString(); } that IMHO looks like a possible change in switch that does not break compatibility It would be even nicer to write String formatted = switch (obj) { case Integer i: String.format("int %d", i); case Byte b: String.format("byte %d", b); case Long l: String.format("long %d", l); case Double d: String.format(“double %f", d); case String s: String.format("String %s", s); default: obj.toString(); } but I think it breaks the fallback by default behaviour in switch, and that will break some people's code... 
Before next summer, you can go for certification exams. Complete an entry level and advance level certification. It will help u a lot in getting job.
Doesn't Oauth2 provide a mechanism for securely accepting authentication from a third party, like Google or Facebook? Isn't that the whole point of it?
That's one use case where the third party provides the authentication, yes. It is not the only use case, though
Well, that would be more interesting than sugaring up the switch syntax. I'd love to see the sealing proposal in the JEP.
not sure that anything here is worth tracking tbh
As far as entry level / junior jobs. I've seen *far* more .Net positions than Java ones. Of course, I am speaking from the southeast U.S.
well there's the site plugin, but that's mostly covered by gradle fury
What would a "continue" statement in a switch do?
Good project, there are several benefits of immutability in Java. I wrote about it a while back: https://www.linkedin.com/pulse/20140528113353-16837833-6-benefits-of-programming-with-immutable-objects-in-java
On web, Java have one official framework to GUI: jsf. Other options include gwt, Thymeleaf an there's also a lot of smaller solutions. Jsf is similar to html, but the designers must learn it's syntax. Gwt is for programmers, although it has a possible markup solution. Apache Thymeleaf is based on standard theology for web, such as html, CSS and JavaScript (also needed for above frameworks) so it's easier for designers. I don't know if exist some tool for a non programmer to build a Java desktop interface, but there are some designers that facilitate this work (on eclipse, for example) but they need to know Java.
I always recommend JavaFX for this, since your designer only needs to open ~~Window~~SceneBuilder and generate the UI from the GUI, without ever needing to acces the source code.
AFAIK WindowBuilder doesn't even support JavaFX. You mean SceneBuilder right?
&gt; Trick the innocent developer into installing the malicious package LOL
Yes, as long as you don't need commercial support. Like /u/zayzn said, [Payara](http://www.payara.fish/) offers commercial support for GlassFish. Strictly speaking, it's Payara is a GlassFish fork, but it is 100% compatible with GlassFish.
Most Enterprise apps don't have drop or alter on DB, and don't have write access to application folder. Encrypting the files is further made irrelevant by source control. You could delete from db but that requires traversing and interpreting fk constraints, not impossible but hard. Instead of going after files, you could alter responses more directly, e.g. target springs dispatcherservlet. This article glosses over the attack vector, though. "Assume you get some code in via maven then you can do some evil stuff." The industry knows code injection is nasty. HOW do you get the code in? How do you attack maven? How do you circumvent maven's checksum mechanism? How do you avoid this getting detected in testing and only running in production?
You're right! Even better. Now I wonder if we can get rid of the `case` and write String formatted = switch (obj) { Integer i -&gt; String.format("int %d", i); Byte b -&gt; String.format("byte %d", b); Long l -&gt; String.format("long %d", l); Double d -&gt; String.format(“double %f", d); String s -&gt; String.format("String %s", s); default -&gt; obj.toString(); } It really looks like 'chose the first usable lambda expression' 
It is a nice demonstration. However the technique is not applicable on a "Enterprise" environment. Every company has a CI/CD process before you ship it to production. You are not likely to work on product ion database while developing. If test database gets encrypted? Remove the malicious dependency. I am not even going to talk the details of database access restrictions.
How does it compare to https://github.com/MutabilityDetector/MutabilityDetector ?
I'm looking forward to us getting closer to JDK 10, which will get us closer to JDK 11, which will get us closer to JDK 12, which in 2035 will finally give us value classes.
Expected results regardless the promises. As a former Minecraft Modder, I am glad that I worked in its prime time. Was a lot of fun and a very good experience. Farewell o/
In this case, OP is unlikely to have either unless he builds a good portfolio.
learn using the CLI, then you actually understand what you are doing imo.
though NPM is not made for that you can actually do that with NPM too. Not sure if you can integrate Maven as an external dependency management system.
Cool project, like it. I guess they're complimentary, two different ways of achieving the same goal.
Nice! Speaking about JPMS, how are things going with the proposal? Will it be shipped in Java 9 or we risk having it being pushed back?
It's so good. 
sadly this is true even for "mature" OSS. Best are the log messages telling you something which isn't the problem, sending you off in a totally different direction if you want to fix that.
As others said, go with Payara. I personally found Glassfish 4.1.1 (it's still the latest, I think) to be unstable. And it has an annoying bug with JAX-RS Json marshalling: it doesn't work out of the box, you have to "manually" take care of it.
Lol, cryptocurrency mining. That's gonna be a short job.
Doesn't making a class final violate the open/close principle? 
No offense to the person who suggested it, but no one cares about certs. I say this as a software engineer who regularly interviews people. The degree is very important. Rather than spend time on a cert, I recommend learning (core CS and stuff you may not learn in school, like real world frameworks and libraries) and working on small projects that you could talk about I'm interviews (using popular frameworks/libraries).
poor man's polymorphism
Can I also have a tip, I like properties too and I'm hungry.
It definitely is possible if you do a personal project and are able to talk about some design decisions. The interview is a lot more light and more fun.
Well, this is exactly how many old-school developers were reacting to jobs that web companies were offering like 20 years ago (thinking that web is bubble, etc.). The other devs, that actually took the "unknown" jobs back then are now either in very high and respectful positions in some of the best web companies or are sitting on shit load of money. Are we offering a lifetime average job? No. Are we offering well-paid job in the fastest growing technology in the world? Hell yes.
Sure. !tip 0.001
####🎉 A tip of `0.001 ether` has been sent to /u/Retrotransposonser's tip jar! --- Visit [your tip jar](https://www.tip-jar.me) to check your balance and withdraw/deposit funds. ^(Beep boop, I'm a bot. |) [^([What is TipJar?])](http://www.tip-jar.me)
I assume they'd want a way to detect whether it's in testing mode or some sort of real production and implement some kind of seamless encrypt/decrypt process so that unless you look carefully at the database everything will keep working fine until the malicious code decides to active it's payload properly (i.e. suddenly break after working fine for 6 months - 1 year leaving you with data loss and partially mangled backups going back half a year or more). Seems like the sort of thing you'd want to hide in a updated version of an otherwise reliable database library and maybe install a mean of remote activation...
Huray! My first ether, thanks :D
It's not an authentication nor authorization protocol, it's a delegation protocol. It's a way for a user to delegate access of their resources to a third party. 
Only if you believe inheritance is a requirement for OCP, which it isn't.
Well, since the 51% attack is a thing, governments *will* manipulate the hell out of it. Probably to kill it and force everyone back onto a saner currency.
Well, since the 51% attack is a thing, governments *will* manipulate the hell out of it. Probably to kill it and force everyone back onto a saner currency.
Well, since the 51% attack is a thing, governments *will* manipulate the hell out of it. Probably to kill it and force everyone back onto a saner currency.
Well, since the 51% attack is a thing, governments *will* manipulate the hell out of it. Probably to kill it and force everyone back onto a saner currency.
Well, since the 51% attack is a thing, governments *will* manipulate the hell out of it. Probably to kill it and force everyone back onto a saner currency.
And when was the last time an Enterprise software project was on time? 😋
Uninstall all the Java installs from the machine. Smoke every key in the registry that says Java. Triple check every path on the computer for leftover Java dlls. Reboot. Reinstall 64 bit and see what happens 
Open the Command window. Cd to the bin folder under the 64 bit Java folder Type java in the Command window. What do you see?
Looking forward to his 3rd edition
I use a REPL for "real" programming in clojure. It's really great for debugging and local testing. Its also good for testing black box functions quickly. I haven't done much on Java, but for the most part, the same concepts apply. 
Sneaky
https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/ReflectionToStringBuilder.html
https://google.github.io/guava/releases/19.0/api/docs/com/google/common/base/MoreObjects.ToStringHelper.html public String toString() { return MoreObjects.toStringHelper(this) .add("statusChange", statusChange) .add("relevanceChange", relevanceChange) .add("validationErrors", validationErrors) .toString(); }
isn't this technically slower than just having your ide generate it? Since it has to get the fields and set the accessibility for them before reading their value.
 public String toString () { if (Math.random () &gt; 0.99999) throw new RuntimeException (); else return super.toString () }
It's *a lot* slower.
This gave me a nightmare :D
Why do people use it then? 
Also, hide this in a library with hundreds of classes and obfuscate the code to make it really hard to locate.
Dayum, gonna buy this. I hope there's a sequel for Java Concurrency in Practice too :( 
 /** * This object (which is already a string!) is itself returned. * * @return the string itself. */ public String toString() { return this; } 
Compile to a stub and add at runtime with javassist? To all the abstracts of course.
There are solutions to generate the code on the fly, e.g. project lombok. 
Why slower?
An almost certain infinite loop, on the basis that local host will always be reachable. Why you'd do that instead of just while(true) though I don't know, same as I don't know why anyone would bother posting this in the first place.
Effective Java 3rd edition, Paperback – 19 Oct 2017 Can't wait :-)
&gt; you get a correct implementation for free But this isn't automatically true, and in fact the Javadoc makes it very clear that it has some severe pitfalls.
And what is wrong with that? You just get infinite loop. This code doesn't seems hurtful.
Sure, and that's great if you're using that. But good luck convincing the tech lead to pull in a big new dependency just to clean up `toString` =P
&gt; Why create an extra object There is no extra object for the empty case, `Optional.empty()` always returns the same instance: /** * Common instance for {@code empty()}. */ private static final Optional&lt;?&gt; EMPTY = new Optional&lt;&gt;(); public static&lt;T&gt; Optional&lt;T&gt; empty() { @SuppressWarnings("unchecked") Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY; return t; }
Hide it with the unicode-comment trick and only let the "return super.toString()" stand there as readable code...
&gt;getters/setters/toString getters / setters / toString / equals / hashCode / copy 
Start a single line comment with //, then unicode-encode a line break (\u000A), then continue the rest of your code as unicode-escaped sequences. Most IDEs will highlight it as comment. It isn't human-readable. But its still all valid Java code... it fools lots of people. Put this into your main method: // FIXME this crashed with the following mem-dump: \u000A\u0072\u0079\u0020\u007b\u0043\u006c\u0061\u0073\u0073\u003c\u003f\u003e\u0020\u0063\u0020\u003d\u0020\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u002e\u0063\u006c\u0061\u0073\u0073\u002e\u0067\u0065\u0074\u0044\u0065\u0063\u006c\u0061\u0072\u0065\u0064\u0043\u006c\u0061\u0073\u0073\u0065\u0073\u0028\u0029\u005b\u0030\u005d\u003b\u006a\u0061\u0076\u0061\u002e\u006c\u0061\u006e\u0067\u002e\u0072\u0065\u0066\u006c\u0065\u0063\u0074\u002e\u0046\u0069\u0065\u006c\u0064\u0020\u0066\u0020\u003d\u0020\u0063\u002e\u0067\u0065\u0074\u0044\u0065\u0063\u006c\u0061\u0072\u0065\u0064\u0046\u0069\u0065\u006c\u0064\u0028\u0022\u0063\u0061\u0063\u0068\u0065\u0022\u0029\u003b\u0066\u002e\u0073\u0065\u0074\u0041\u0063\u0063\u0065\u0073\u0073\u0069\u0062\u006c\u0065\u0028\u0074\u0072\u0075\u0065\u0029\u003b\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u005b\u005d\u0020\u0061\u0020\u003d\u0020\u0028\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u005b\u005d\u0029\u0020\u0066\u002e\u0067\u0065\u0074\u0028\u0063\u0029\u003b\u0069\u006e\u0074\u0020\u004e\u0020\u003d\u0020\u0061\u002e\u006c\u0065\u006e\u0067\u0074\u0068\u003b\u0066\u006f\u0072\u0020\u0028\u0069\u006e\u0074\u0020\u0069\u0020\u003d\u0020\u0030\u003b\u0020\u0069\u0020\u003c\u0020\u004e\u003b\u0020\u0069\u002b\u002b\u0029\u0020\u007b\u0069\u006e\u0074\u0020\u0072\u0020\u003d\u0020\u0069\u0020\u002b\u0020\u0028\u0069\u006e\u0074\u0029\u0020\u0028\u004d\u0061\u0074\u0068\u002e\u0072\u0061\u006e\u0064\u006f\u006d\u0028\u0029\u0020\u002a\u0020\u0028\u004e\u0020\u002d\u0020\u0069\u0029\u0029\u003b\u0049\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u0073\u0020\u003d\u0020\u0061\u005b\u0072\u005d\u003b\u0061\u005b\u0072\u005d\u0020\u003d\u0020\u0061\u005b\u0069\u005d\u003b\u0061\u005b\u0069\u005d\u0020\u003d\u0020\u0073\u003b\u007d\u007d\u0063\u0061\u0074\u0063\u0068\u0020\u0028\u0045\u0078\u0063\u0065\u0070\u0074\u0069\u006f\u006e\u0020\u0065\u0029\u0020\u007b\u007d and watch the world burn... (hint: This does a Fisher-Yates Shuffle on the Integer-cache, so....)
Pure evil
Because they haven't discovered Lombok yet
Oh dear! As if there was no [StringBuilder](https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html) in the standard library (and [StringBuffer](https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html) is around even longer if compatibility was an issue). The only real feature here is to optionally ignore entries with null values (which I believe is not such a good idea anyway).
It's also super useful if your ovject gets populated over long time, since you can just add the properties as they are added. I think it might be less garbage collector intensive. 
&gt; Apache Thymeleaf ugh
whats the big deal? generate it once and benefit from compile time checks and speed. OR go dynamic and deal with tool integration and add the overhead of one more thing to manage. me, the former, erytime.
[*cause why not, mate?*](https://www.reddit.com/r/causeWhyNotMate/)
I found Satan.
This guy cites a book; http://javarevisited.blogspot.com/2011/07/string-vs-stringbuffer-vs-stringbuilder.html?m=1
We have tests in our code that check the toString for each field. So if you add a new one the test will fail if you didn't regenerate things. 
show me something natural like Optional with a NPE
~~No I meant in that snippet~~ Edit: lol yes you're right (`val`, please 😄)
We'll see what comes of it I guess. I definitely agree that Java is far too verbose for that. You'd end up having to do like ones in BASIC, honestly.. &gt; 10 ... &gt; 20 ... &gt; 30 ... &gt; ... &gt; LIST &gt; ... &gt; 40 ... &gt; ... Which is to say having to write each function a line at a time and then list the whole thing to double check for errors and expected formatting. This approach is a lot more sensible with Python since it omits a lot of brackets and other stuff and uses tab/space indenting for determining scoping, etc.
But why? Both are decent enough for education of the teacher/instructor/professor is good at teaching and the class is structured correctly.
Ha ha, this made me angry to see
Is there some dumb utility I can use to convert a string into unicode escape's. I don't want to convert code by hand.
from amazon description: &gt; Since this Jolt-award winning classic was last updated in 2008 (shortly after Java 6 was released), Java has changed dramatically. The principal enhancement in Java 8 was the addition of functional programming constructs to Java's object-oriented roots. Java 7, 8, and 9 also introduced language features, such as the try-with-resources statement, the diamond operator for generic types, default and static methods in interfaces, the @SafeVarargs annotation, and modules. New library features include pervasive use of functional interfaces and streams, the java.time package for manipulating dates and times, and numerous minor enhancements such as convenience factory methods for collections. &gt; In this new edition of Effective Java, Bloch updates the work to take advantage of these new language and library features, and provides specific best practices for their use. Java's increased support for multiple paradigms increases the need for best-practices advice, and this book delivers. &gt; As in previous editions, each chapter consists of several “items,” each presented in the form of a short, standalone essay that provides specific advice, insight into Java platform subtleties, and updated code examples. The comprehensive descriptions and explanations for each item illuminate what to do, what not to do, and why. &gt;Coverage includes: &gt; Updated techniques and best practices on classic topics, including objects, classes, methods, libraries, and generics &gt; How to avoid the traps and pitfalls of commonly misunderstood subtleties of the platform &gt; Focus on the language and its most fundamental libraries, such as java.lang and java.util
It's not even present at runtime :D
I'll even throw in `equals` and ` hashCode`... import com.google.auto.value.AutoValue; @AutoValue abstract class Animal { static Animal create(String name) { return new AutoValue_Animal(name); } abstract String name(); } https://github.com/google/auto/blob/master/value/userguide/index.md
What's wrong with it?
So it's basically while(true); ?
You're probably better off having a HTML/CSS/Javascript guy build the front end of the web app and make it talk to RESTful web services. He won't need to know anything about Java. Then the Java programmer can implement the RESTful web services and back end in Java. If you build the front end with a Java technology like JSF or Spring MVC then you're front end developer will need to be a Java guy.
Suitable, as in a necessary and fitting part of the process? Probably not.
That's good to know. Now all you have to do is check that the Optional return value is not null and you're good to go.
this one - https://hackernoon.com/a-blooming-good-java-tostring-for-the-rest-of-us-50dca980a462
Waste of time and quite frankly an Object shouldn't have the responsibility of representing itself externally. Most of the toString implementations I see are useless, dumb and made just because of insecurity or some other psychological trait which has nothing to do with good programming practices. (Such as printf debugging, non-sensical logging, etc...) It's like clone on Cloneable. It is a pretty bad idea to begin with.
I'm a bit late to the party, but here it goes: @Override public String toString() { System.exit(0); return null; } This leaves no stack trace at all.
&gt; It's also super useful if your ovject gets populated over long time, since you can just add the properties as they are added. I do not think this is a good idea: you incur memory overhead in your class for the redundant storage of state in String instances and there is an overhead in all setter methods for building up a data structure that might never be used (i.e. if toString() is never invoked). &gt; I think it might be less garbage collector intensive. Why less? I looked briefly at the [source code](https://github.com/google/guava/blob/master/guava/src/com/google/common/base/MoreObjects.java) and at least for primitive types there is a String instance created and retained until the value is overwritten. And we haven't even considered life time of the instance that is to be represented as String: if it is long lived and ToStringHelper is maintained in setter methods then the cost of GC will significantly increase over a code version that uses MoreObjects.ToStringHelper only in the implementation of toString(). Because there everything is short lived and will most likely never leave eden space. Objects in non eden space have higher GC cost because they have to be looked at more often.
Please elaborate.
Really just personal preference. I dislike kotlin syntax, mainly just because I prefer the verbosity of Java. I like the FEATURES of kotlin, but after trying it out I can't get over the syntax. Sure it's probably silly, but it's what works for me. 
Debugging code is done with a debugger, toString doesn't make it easier to use. If you're down to being forced to use printf debugging on your business code and you don't have any unit tests helping you trap bugs, you have much bigger problems than printing the representation of an object.
I don't remember anything outdated. 
It's not bad, it's just not as efficient as say logging the wired request instead of the marshalled object. Your API's role is not to log its calls right? It's to process them so if it's spending a lot of resources in building/logging/writing request &amp; response objects, it's kind of a waste, specially if you're building the log regardless of the level and then write it only on debug or trace for instance. The only reason you would have to prefer logging the object is if you're not 100% confident with your model code. This is where my comment about insecurity comes in. You want to be secure make good unit tests and get 100% coverage, that's it.
[*cause why not, mate?*](https://www.reddit.com/r/causeWhyNotMate/)
Breaks incapsulation and is a good sign your "single responsibility" either isn't singular or poorly defined. Your model of the system you are writing is off somehow. They are definitely needed sometimes but when i see a class full of them i immediately realize the code is probably a mess. It is one of the biggest code smells. Only poor programmers do this. You might as well made the variable public if you are just going to make a getter and setter (hyperbole to some extent).
Thanks! This is perfect.
Honestly I don't know how to put it into words. There's just something about it that I like. 
Im trying to get back into Java, care to explain?
&gt; I do not think this is a good idea: you incur memory overhead in your class for the redundant storage of state in String instances and there is an overhead in all setter methods for building up a data structure that might never be used (i.e. if toString() is never invoked). You put your objects which you know will have toString called on them. If you're about to log millions of objects per second you don't want them to create new String every time toString is called. &gt; Why less? I looked briefly at the source code and at least for primitive types there is a String instance created and retained until the value is overwritten. If that String is retained it means it won't have to be collected and then created again next time toString is called, and then collected again, so it's less gc intensive. It looks like something that could be very useful in banking/stock trading for example, or anywhere where you have large amounts of objects, which are changing and often logged.
Comparator is a more verbose approach. A good choice when the order you want to achieve isn't that obvious and using precisely named comparator clarifies your code. 
Damn going full Kathy on us now!
This is becoming infested with Lombok cruft and Kotlin fanboism.
Ehh, it's a Javadoc comment though. Those should be as detailed as possible. 
Oh yes. That comment should be burned with fire. 
The code isn't open source. 
[removed]
Do you even know that Tinder is written in Java?
I don't. I'm still new to this whole thing and its turning out to be alot harder than I thought 
Google answered my question https://www.quora.com/Which-programming-language-is-Tinder-using
Honestly I read android is all java based but when that guy asked I've been googling android languages and have come to java every time so I assumed lol.
The compiler has been doing this for ages but like /u/rents17 says it applies only in the simplest cases. For instance, buf.append(foo + bar); becomes something like buf.append( new StringBuilder(foo).append(bar).toString() );
[Thanks, captain obvious](https://i.imgur.com/dETvJG8.gif)
In some ways, verbosity is a form of self-documentation. Terse code may feel good to the coder, but it potentially obfuscates the code to anyone who inherits it. 
But this is especially easy with toString as no reasonable logging framework will build log messages when the log level is higher (as in less fine grained) than the level of the log event 
While having a goal is a very good approach to learning a language/technology, I'm not sure if that applies to learning programming in general. Have you considered just trying out some courses on the web? They may just provide the necessary push. No, I cannot recommend any but i'm sure google would be happy to.
Touché ;)
Never thought I'd see a Kendrick reference in here 
[Alt-Insert](https://i.imgur.com/ZtuIUeB.png)
Here's one social network opensource client for android: http://andstatus.org/ But don't expect it to have some geo-tracking or other tinder-specific features.
We just too humble most of the time
OK, this looks like a use case but I am not convinced yet. First of all, what is the use case of an application that needs to log "millions" of instances with high frequency? Then, if you indeed have to log a single instance with changing state with high frequency caching of string representation of unmodified parts of the object may or may not make sense. You would have to seriously benchmark this. Because, as I said, there is a GC price tag for long lived objects (i.e. moving outside eden space). And the string representations that are cached inside ToStringHelper are only used for adding to another string representation (of the whole owning object). I think the only justification for this approach can be to save CPU cycles for generating log messages if calculating the string representation of a member is expensive. But with such dramatic performance requirements it is questionable is whether using toString() for logging is a wise choice. The purpose of the method is to return useful information, usually about the complete state. In an application with these requirements chances are that one would craft a specific solution for that and provide logging functionality via other methods.
Wrong sub, buddy.
Its pretty much basic stuff if you want to mess with Java and or "break java".
There are awesome arrangements of Java Certification Training in Kolkata that immediate you adequately through guide in getting the required authentication. You have to pick the establishment painstakingly. Go to the site and allude to their conditions and address the coach before joining.
it should also be noted that a comparator can handle null, where comparable can't. Given a List&lt;Object&gt; which contains nulls: Collections.sort(someList); //throws NPE once it tries to call compareTo on the null element Collections.sort(someList, someComparatorWithNullHandling); //properly sorts, because null is handled in the comparator. Obviously, you would generally strip out all the null values (or not allow null into the list to begin with), but if you can't for whatever reason, comparator would allow you to handle the nulls gracefully, pushing them to the bottom of the list.
Do you mean for web applications or desktop applications?
To be honest, I haven't measured. It's clean Selenium WebDriver api, so if you search some stats for that, you should get the idea. It also depends on what you do with the pages. As said above, everytime the batch size is met, Repository.export() is called. so depending on what you do there, the overall crawl() may take longer. But with this design, you can start a WebCrawl on a separate thread and not worry about speed :) I was actually thinking of writing a decorator for this purpose. Would you find it useful? 
&gt; (...) the **clear fact** that Kotlin is a more succinct, effective, and powerful language Dzone.com... the rainbow press of the developer community.
Desktop
Actually can be useful to convert old applets with lost source code. 
Swing's look and feel stuff doesn't lend itself to a lot of customization. You tend to find find a look and feel you like and use it (whether one in the JDK or a 3rd party one). So there was no real need/role for a designer on a swing application. May have a small part to play for logos or images but those could just be provided to the programmer and no Java knowledge was needed by the designer. However, JavaFX can be styled with a style sheet whose syntax pretty much follows CSS. So there may be bigger opportunity for a designer for a JavaFX app. With JavaFX they probably wouldn't need to know any Java either, they just create a mockup. The developer can translate that to javaFX stylesheets. 
&gt; As a bonus, we are releasing to the public a free to use Chrome extension that enables Java applets without the need of plugins and a local Java installation. The extension can be downloaded here. Woah. 
**UTF-16** UTF-16 (16-bit Unicode Transformation Format) is a character encoding capable of encoding all 1,112,064 valid code points of Unicode. The encoding is variable-length, as code points are encoded with one or two 16-bit code units. (also see Comparison of Unicode encodings for a comparison of UTF-8, -16 &amp; -32) UTF-16 developed from an earlier fixed-width 16-bit encoding known as UCS-2 (for 2-byte Universal Character Set) once it became clear that 16 bits were not sufficient for Unicode's user community. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^] ^Downvote ^to ^remove ^| ^v0.22
There are big chunks of the JVM that are going to be very difficult to reconcile with the browser sandbox. File I/O? Real sockets?
If your code can return null as a well as an optional, you've failed to understand the concept. Edit: If it's from a third party, inform the author(s).
No.
What about Wildfly?
It'll almost certainly be a scenario where those parts of the library just throw unimplemented exceptions and you get some alternatives instead.
Excellent, thanks will friend. 
I use Wildfly currently. As far as I'm aware it's pretty solid.
File I/O is supported, it is based on the idea that the Web platform does not have access to files on the system disk, but can use plenty of filesystem-like services. Both local ones (IndexedDB and files explicitly selected by the users) and remote ones (HTTP servers and cloud based services like DropBox). Raw socket I/O is not possible in current browsers as Web Sockets are not intended to be compatible to raw sockets for security reasons. Is it still possible to provide networking by using browser APIs directly (in CheerpJ Applet Runner we support HTTP directly using XHR). We plan to also support raw sockets using a lightweight server-side component. Moreover, apps in chrome OS can use plain sockets, so full support on Chrome OS is actually possible right now.
It is absolutely possible and we have done it, please take a look at our demos here for proof: http://www.leaningtech.com/cheerpj/demos/
We have released several demos that should serve as proof that this really exists: http://www.leaningtech.com/cheerpj/demos/
https://en.wikipedia.org/wiki/Betteridge%27s_law_of_headlines
"I have a building I am trying to create (first building ever) and I want to make it like the [Sagrada Família](https://en.wikipedia.org/wiki/Sagrada_Fam%C3%ADlia) and I need a starting point so I want to look through the schematics .Does anyone know where to find the schematics of Sagrada Família?" Seriously though, starting with tinder for a first app is a no-go. Try this first https://www.reddit.com/r/dailyprogrammer/
**Sagrada Família** The Basílica i Temple Expiatori de la Sagrada Família (Catalan pronunciation: [səˈɣɾaðə fəˈmiɫiə]; Spanish: Templo Expiatorio de la Sagrada Familia; English: Basilica and Expiatory Church of the Holy Family) is a large Roman Catholic church in Barcelona, designed by Catalan architect Antoni Gaudí (1852–1926). Gaudí's work on the building is part of a UNESCO World Heritage Site, and in November 2010 Pope Benedict XVI consecrated and proclaimed it a minor basilica, as distinct from a cathedral, which must be the seat of a bishop. In 1882 construction of Sagrada Família commenced under architect Francisco Paula de Villar until 1883, when Gaudí became involved when Francisco resigned as the head architect. Taking over the project, Gaudí transformed it with his architectural and engineering style, combining Gothic and curvilinear Art Nouveau forms. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^] ^Downvote ^to ^remove ^| ^v0.22
Whatever happened to [dragome](http://www.dragome.com/)? I wonder how CheerpJ differs from it? They both appear to run off of .class files (compiled Java "binary"), not Java source code. Dragome is Apache 2 OS licensed, CheerpJ appears to be proprietary. Let's not forget the other players in "Java in browsers" space: [JSweet](http://www.jsweet.org/) [DukeScript](https://dukescript.com/) And the tried and true classic, [GWT](http://www.gwtproject.org/). **edit:** forgot [TeaVM](http://teavm.org/) 
Why is that a breaking change? Java 7 code runs more oe less without changes on Java 8. Same with compiling. Look at Python 2 to 3, now thats a breaking change.
How exactly? Why would you even want to use Java for scripting? It's not designed for that purpose. Also, http://sleep.dashnine.org/index.html ?
You may be confusing terms of backwards and forwards compatibility, as I have. A version compiled with a old compiler will work on the new runtime, even if they may not benefit from newer version features: that is backwards compatibility. Now, forward compatibility is the ability to have an older runtime run a program compiled with a new runtime. That is what is not guaranteed here, unlike backwards compatibility.
Are there plans in the works for a WASM backend?
&gt; compatible with 100% of Java 🤔🤔🤔🤔
Well, bummer. 
There's few reasons not to write new Android code in Kotlin. And those reasons mostly fall under tooling/static analysis tools, which will get much better over time.. However, "replace" is the wrong word. More like coexist.
Back in my day we used to call them 'sprites'...
Why bummer? That’s the whole point of value types. If you can’t give that up, use regular classes.
If it's for converting legacy apps to browser... Does it work with swing? 
Long live the Java app! They came back from the deepest of the deep web and now they came back as zombies. What does the community think about it? [hmmm?](http://i.imgur.com/aIaFk.gif) More seriously, there's definitely no way to convert those legacy app which are still using all the native stuff in it. Thought, I can see how this can be useful for simple java app and I wonder how the whole process can be optimized.
Regular classes aren't passed by value, and immutability is certainly not the whole point of value types. Value types can be mutable **and** passed by value (with copy-on-write optimization for collections). If you want to see examples of this, see C# and Swift. This is very useful when transforming values deeply nested in other values, because the immutable approach quickly turns into hell, where you need to manually write code to "cascade" the change up the hierarchy to the point where you need it. 
Since this does byte code to JavaScript, it should work for Kotlin, Scala, etc, right? 
Well, that list of known issues certainly looks acceptable so far. I was expecting worse from the title.
Probably once WebAssembly supports GC. Otherwise you might as well compile the JVM to WebAssembly.
pepperidge farm remembers
I'm sure other people found more - I hope they'll share,
Boxing and unboxing will still be present for all value types under the hood afaiu, just much more rare. For example we will be able to parameterize and specialise generics over value types (List&lt;int&gt; etc.) without the performance overhead of boxing.
Neat! Thanks. 
I think I saw some discussion on this sort of optimisation on the mailing list the other day, but I don't follow the technical stuff too closely so I may be misremembering. I think it is on of the things they're thinking about though.
Why a sequel? It is one of the best books out there. Many things still hold today.
That makes sense, the interface case don’t occur to me, but that’s definitely not a problem.
This isn't terribly surprising. Every release of java since 5 I've had to wait a while for them to work out the kinks. I never even bother with update 0. Usually 20+. At a previous employer we tried java 7 when it freshly came out and iirc the JIT's default loop unrolling was so buggy that while we knew we could disable it, we were spooked from using JDK7 altogether for another year. *Edit* In fact, I Remember even recently (I think fixed in jdk8u111?) they were still fixing type inference bugs in the compiler. The fact that they're still doing so worries me only slightly. Usually I can fix it with a cast, but it's ugly. 
This is a good start I have been looking for something similar to this to filter out bots for implicit site feedback.
I don't think this is the right sub for this question.
Google is your friend: http://scriptmode.com/androidtutorial/ although, like others have said, if this is your first app and/or you're just learning to program, it will seem a bit advanced. 
Are you new here?
in general, type inference should not be fixed by type casts but by making type arguments of generics methods explicit.
yes =)
spritesheet!
Not sure why you're being downvoted for giving an honest answer and admitting you don't know. Everyone has to start somewhere. People can be jerks sometimes, especially when they see someone else showing a lot of ambition while they themselves are sitting on their asses and doing nothing. Ignore all the haters, and just dive right in with whatever you want to build. My very first personal project was a site that has 90% of Reddit's core functionality. Was it complicated? Yes. Did I spend a ton of time googling and asking "stupid questions"? Hell yes. But it taught me more about programming and technology stacks than anything else. If you're enthusiastic about building something, just do it. Worst case scenario: you may not have the time and energy to finish it, but either way, you'll learn a ton in the process. You can read more about my experiences here if you're interested: http://www.thecaucus.net/#/content/caucus/tech_blog/107 
I fail to see how a text editor is an "additional dependencies that anyone might not want to trust or rely on." Maybe you should write your code on paper and convert it by hand to bytecode and then enter that with some highly simplistic program and leave it to someone else to give that to a JVM?
I don't think it covers Forkjoin pool, ManagedBlocker, CompletableFuture, and other recent improvement.
Sure, cheers!
Does it only work with thymeleaf or jsp? What about single page apps that use plain html files? And what about cached html files?
I think value types would be beneficial to the language. Do you happen to have the link to the JSR you're referring to?
JEP 169 I think. http://mail.openjdk.java.net/pipermail/mlvm-dev/2015-February/006414.html
"cross-platform" is not a noun
And the death of Java in *--&gt; insert random industry here &lt;--* every few months.
&gt; until it's referred to from another variable or location You can't refer to values from different places in Java. If you have an `int x`, then the only way to observe the value of `x` is via `x`. The same will be true for user-defined value classes.
How are integers handled? JavaScript doesn't have a 64-bit number type, but always simulating Java `long`s may slow some things down unnecessarily.
This explains everything. char character = 'A'
What's different about today's multicore processors compared to yesterday's? 
I've been needing something like this for ages and just now I realized I need this. I hate it when people write python bots to scrape my blogoblags. It screws up my SEO analyses because seeing what people are liking is drowned out by the endless bot scraping. Upvote. Reddit needs a better button for upvote. A Highfive button. 
.
No, but your post history does extensively
Instead of "Integrate with Spring Boot" what you really mean is java config instead of xml config.
Java has been around for 20 years, and with little exception has remained largely unchanged. Why? Because it works. It's verbose and readable, and takes a lot of the pains of C/C++ away. Is Java going away? No. Will it still be king of the hill? Time will tell. Kotlin is what Java should have been with 20 years of hindsight. I really love it! However, I find Java to be far more readable and easier to understand what is going on.
Project is here: https://github.com/konsoletyper/teavm
You could write a simple Maven plugin that runs through your source files and throws an error whenever something's wrong. Should be a three-liner.
What I'm referring to is called "copy-on-write" and it's a transparent optimization, which as I said many languages already implement. From the PoV of a Java developer, the values will behave as you describe. Internally it can be a bit more complicated (in the matter I described) for the benefit of better performance and lesser memory usage. Don't confuse semantics with implementation. I'm talking about implementation. The semantics don't change.
https://www.youtube.com/playlist?list=PLyUlngzGzkztgTizxM6_zqiw8sRj7vBm0
[removed]
This should have been posted in /r/javahelp as the *plenty hints* in the **sidebar** explain. **Post removed** programming help
I'm going to guess Google knows.
i don't see any mention of the DOM. is there a binding included ?
Asking the right questions
Haven't they announced it like two JavaOnes in a row? Doesn't seem to be newsworthy.
Today's is a day newer. :)
In my point of view it isn't. see https://www.google.nl/search?q=ongeschikt+voor+hbo&amp;oq=ongeschikt+voor+hbo&amp;aqs=chrome..69i57.4618j0j4&amp;sourceid=chrome&amp;ie=UTF-8#q=late+objects+java&amp;tbm=vid&amp;start=60 @UnspeakableEvil got tips? 
Well obviously they aren't talking literally about today and yesterday, but today's core are becoming more and more NUMA - non-uniform memory access - meaning that accessing memory that is near your core can be faster than reading memory that is near someone else's core. This work is about reducing memory indirection in the layout of objects, which should improve memory locality, which should work with, rather than against, the NUMA approach that we are starting to see more of.
Use Checkstyle. Set its `TodoComment` rule ( http://checkstyle.sourceforge.net/config_misc.html#TodoComment ) to be an error. Fail the build on error ( https://maven.apache.org/plugins/maven-checkstyle-plugin/check-mojo.html - `failsOnError`) Note that this is a regular expression matcher. &lt;module name="TodoComment"&gt; &lt;property name="format" value="(TODO)|(FIXME)"/&gt; &lt;/module&gt; You can modify it to have the information to not trigger on a task id.
&gt; What about single page apps that use plain html files? It's a servlet filter. It will work on any HTML file whose path matches the URL spec, as long as it is rendered by the app server. You could have your app server serve up the plain HTML template, but why? It would be better to have a frontend HTTP server serve up the template, since it serve it up directly. &gt; And what about cached html files? This completely defeats caching. With HTTP caching, the client doesn't have to make another resource request for HTML content that hasn't changed. With this filter, the HTML content changes all the time. &gt; What about single page apps This would be pointless for SPAs. SPAs typically interact with the backend through REST API calls, i.e. JSON messages. Only standard web apps would do HTML FORM posts. Something like this wouldn't really even be desirable for SPAs, because you want the client to cache the static HTML templates and Javascript, so that the client only has to transmit and receive JSON.
Do you know of a sample that runs through the source as an AST? Or does it just read the java files line by line. 
I hope so. I cringe when I encounter Kotlin Js having to escape JQuery's 'val' function because that is a Kotlin keyword.
[removed]
Some IDE's generate class diagrams on the fly. Eg: Ctrl+Shift+Alt+U in IntelliJ (Ultimate?) gives me class diagrams around the class that I'm currently viewing...
I wrote [a library called Papercut](https://github.com/Stuie/papercut) to avoid this scenario a few months ago. It gives you annotations to use in place of TODO comments in the future. You can set conditions that will cause them fail your build, or spit out a warning in your build output. It won't help you with existing TODOs, unfortunately.
Quite the contrary, the issue is that there is hardly any uptake in JavaFX after the way it was mismanaged. At least in Europe we don't have any problem to get contracts for Qt, Windows Forms, WPF or UWP. Just not for Java desktop GUIs, other than occasional Swing maintenance work.
so do you see any future for it? 
Actually 57 is overstating it... If you look thru the entries you see a lot of them don't list JavaFX as a required skill and it's unclear how they use it or whether they even do. This isn't news: https://dzone.com/articles/should-oracle-spring-clean-javafx People like to blame Oracle for effectively dumping Java FX (or not investing in it) but a lot of the bad decisions originated at Sun and this just carried over. 
Reducing memory indirection would benefit any memory access architecture, not just NUMA. Basically, you are avoiding storing an extra pointer and the corresponding lookup, thus saving memory and reducing cache contention.
Bot scraping should not be an issue with SPAs. SPAs are usually bootstrapped with JS. Most of the DOM gets rendered on the fly by some JS events. Since bot scraping does not trigger JS events, the bot never gets to see anything relevant.
I would like to, however Java native apps seem to be more focused on Android currently, if it wasn't for it, most Java projects would be Spring and JEE ones. Sun really didn't understood the desktop developers and their needs. While Swing is quite powerful, reading books like "Filthy Rich Clients" wasn't something most Java developers would spend time on, thus many applications weren't as good as they could have been done. While Oracle has done better than Sun with JavaFX, for a long time it was a separate component, even the documentation is still separate, and they gave SceneBuilder to Gluon instead of keeping developing it. If you check the JEPs for Java 9, you will see that other than a few improvements for DPI support, Gtk and GStreamer update, there are hardly any GUI related improvements. So this doesn't inspire companies to start new projects on it, when the majority of desktop are Windows based still, Oracle never cared to create a Java AOT compiler for iOS and Android situation is as it is. Instead they have spent resorces creating a framework like [Oracle Mobile Application Framework](http://www.oracle.com/technetwork/developer-tools/maf/overview/index.html), basically ADF for mobile with a Cordova like deployment.
What components? There isn't much more other than what gets occasionally listed on http://fxexperience.com/, which is supported by Gluon not Oracle. Compare those community quality components, with the components these companies are selling, and many Fortune 500 pay for without thinking twice about it. http://www.telerik.com/ http://www.componentone.com/ Just two examples, there are plenty more selling such high quality components.
Because on Sun days it was J3 and then a programming language totally unrelated to Java (JavaFX 1.0), Oracle made it a proper framework, only to lose interest afterwards.
Yeah. Do people really advertise JavaFX specifically on jobs? My company has written some JavaFX apps but we never advertised specifically to hire JavaFX developers. It turns out you can hire regular developers with Java experience and they can pick up JFX pretty fast. I mean I wouldn't advertise for "JAXB" developers either. At some level you cross a line where you're just expected to be able to pick frameworks up and learn them if you need to. The web world doesn't work this way of course - web dev *used* to be unified and there were only "web developers". The ecosystem has split in recent years into "front end" and "back end" developers, partly because frontend web dev became so insanely complicated and the churn rate got so high that it wasn't feasible to just hire generic web devs and ask them to do everything anymore - just keeping up with the rats nest of transpilers, forked languages, gazillion overlapping frameworks took all day, let alone using them. I think maybe people are generalising from that a bit. JavaFX is easy to learn. It's UI design that's the hard part, but if I wanted to hire someone with a great eye for attractive UI I'd hire a UI designer, not a JavaFX developer.
The question is, what can a native JavaFX application do, what a browser and a web application cannot do. I personally think there are limited use-cases which reflect in the job offer count.
Yes memory indirection has always had a cost. But when they designed Java accessing far memory cost about the same as accessing near memory. So indirection had a little cost but the reduction in complexity for using it but having a simpler object model was probably worth it. Now accessing far memory can cost an order of magnitude more, and it's getting worse quickly with today and tomorrow's processors. So indirection's cost is no longer worth it, and it is now worth adding the extra complexity to get around it. So yes indirection always had a cost and I didn't say that it didn't, but the question was about why it was worth removing it for current processors, when it wasn't worth removing it in the past.
Have actual layout. CSS is a joke.
What else can one use for cross-platform GUI development? Qt is expensive and C++-only. C++ sucks. Gtk probably doesn't work on phones. Swing sucks. Browsers suck even more than Swing. Xamarin.Forms doesn't work on desktop. WPF doesn't work on anything other than Windows. As far as I can tell, JavaFX is the only one that does everything.
1. Are you really talking about **Java** or about Java**Script**? The part: "building a website" threw me off here. If you're talking about JavaScript, the post should go in **/r/javascript** 2. If anywhere, since this is more help with programming than anything else it should, as is indicated in *plenty hints* on the page be posted in **/r/javahelp**.
GNU/Linux desktops are irrelevant for Fortune 500 companies, usually the standard IT image is Windows based and the only place where GNU/Linux is visible is on servers accessible via SSH. As for the prices, they are also irrelevant in the context of project budgets, which you could use to buy a house. The amount of money spent on licenses is quite tiny versus overall project costs.
&gt; Qt is expensive and C++-only. C++ sucks. Not everyone shares this opinion and we gladly use it, when we need to target native desktop apps outside Windows. Since 99% of our enterprise customers use Windows desktops, we usually stay with WPF and UWP for many internal applications. Anything else is Web based, with the exception of mobile devices where we do a mix of JavaScript/C++/Xamarin, or pure native when targeting single OS, it all depends on the customer and project requirements. 
The JVM can already choose to put objects on the stack (actually it turns all their fields into local variables, so they can go on the stack or even into registers) instead of on the heap if it is able to, and that does indeed mean 'free' GC and probably faster access. However it isn't always able to do this, because some things you can do with objects breaks it. This can give you a 'performance cliff' - your code was fast, but you change something and all of a sudden the object has to go on the heap and now it's slower and you don't really understand why. These new values are guaranteed to be always able to be put 'on the stack'. As well as going 'on the stack' they can also be embedded in other objects. So an array of them will include each object fully in the array, rather than a reference to the object somewhere else. So that's still on the heap, but more efficiently.
I feel like this write-up was written for an audience that doesn't exist. People who both: 1. Are extremely knowledgeable of advanced database concepts and terminology (e.g. "bitemporal models") 2. Have inexplicably never seen another ORM in their career, and need the most basic concepts explained at an absolute novice level. I get two-thirds of the way through this article, and I'm thinking, "I get it, I get it. But what makes this *different*?". Because it just looks like: 1. Everything that I hated about working with EJB 2.x entity beans (use tooling to build a cluster of verbose helper classes for each entity, making your build process more complex). 2. Old-school Hibernate XML syntax for defining your O/R mappings (which I'm fine with, but sadly will be dismissed out-of-hand by most developers under the age of 35). 3. Hibernate criteria queries. Granted, the DSL syntax here is a bit more clean and sophisticated... but the concept has been available in some form for at least 10-15 years. It's only on the last page or so that they talk about composability, which is rather novel. However, they ironically also cover transactional support, and I see far less use for composability when you're using transactions. I checked out their [GitHub repo](https://github.com/goldmansachs/reladomo) (the link is buried at the bottom of this article), and a lot of the [detailed feature list](https://github.com/goldmansachs/reladomo#detailed-feature-list) sounds interesting. I hope they skip the boilerplate and get straight to it with the follow-up article(s). This article and most of the documentation reads like IBM manuals from the 1990's... so if a community does build up around this, there's a definite opportunity for someone(s) to contribute by creating some material with a more modern feel. 
Have you tried googling "YouTube API"? First result that comes back's got everything you need: https://developers.google.com/youtube/ 
It's not JavaFX, it's the desktop market. Everything is either mobile or web now.
nothing that an ide doesn't do. it provides convenience things that are largely useless. 
I use it both in my day job and in most of the personal stuff I do. I'm a big fan. It removes a lot of the needless boilerplate and visual clutter.