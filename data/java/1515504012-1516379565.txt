Ratpack :)
It would be easier to read if the bean+web groups (yellow+gray) were in the same place between EE 7/8 rather than being swapped and if there was some border for JASPIC since it moved. I think it also would have been easier for me if EE 8 was on the bottom. But once you get past those quirks, it's a nice summary :-).
[removed]
I think when people say type inference as a feature, they mean at variable declaration, but sure.
Ah right, Java had some poor support for variance.
My theory is that video tutorials may be the result of tech phobia and not liking reading.
[I cannot believe this survey is missing Oracle as a database choice](https://twitter.com/GeraldVenzl/status/950580818392449025)
off topic ... i've dabbled in thinking about how to really test a database. some manner of generating data and operations on that data such that you could linearize the results and verify that they're correct. and then bombard the database with many threads performing those operations [my database](https://github.com/db4j/db4j) doesn't use sql, but it's transactional with similar properties so there should be a one to one equivalence has anyone heard of such an algorithmic database stress test ? 
&gt; excluding someone doing something ludicrously and deliberately dangerous like calling get() And _that_ is exactly the reason why I see `Optional` as a missed opportunity. "Here, have this new `Optional` thing I made so you are forced to check for `null` values. Oh, and by the way... I added a `get()` method to it so you don't _actually_ have to check for anything ;) ;)". Before `Optional` we had this: SomeThing sth = database.thisMightReturnNull(); // but it doesn't if (sth != null) { // better check just in case (and to avoid nagging IDE warnings) SomeValue svl = sth.getSomeValue(); // cool } SomeThing sth = database.thisSurelyWontReturnNull(); // actually returns null SomeValue svl = sth.getSomeValue(); // unchecked NullPointerException And now we have this: Optional&lt;SomeThing&gt; sth = database.thisMightReturnEmptyOptional(); // but it doesn't if (sth.isPresent()) { // better check just in case (and to avoid nagging IDE warnings) SomeValue svl = sth.get().getSomeValue(); // cool } Optional&lt;SomeThing&gt; sth = database.thisOptionalIsLegit(); // actually returns empty Optional SomeValue svl = sth.get().getSomeValue(); // unchecked NoSuchElementException `Optional` is nice as a "THIS MIGHT BE NULL" neon sign, but the bare existence of its `get()` method cripples it IMHO.
&gt; C'mon, how comes in Scala or Ceylon opportunity costs somehow different than in Java? For a lot of reasons that all boil down to no other JVM language being Java. All the other languages are niche languages (including Scala and Kotlin) and get away with much lighter requirements for backwards compatibility. A mistake in Java is simply far, *far* more costly than in any other JVM language. Besides, research languages, of which Scala is one, tend to be kitchen-sinks on account thereof. &gt; You are most likely just not working on the projects with complex architecture having lot's of DTO layers. Yes, I'm sure your anecdotal experience is far more valuable than mine.
True
I had not heard of this plugin before. An example of the report it produces is at: https://maven.apache.org/plugins/maven-checkstyle-plugin/checkstyle.html 
&gt; ...get away with much lighter requirements for backwards compatibility... A mistake in Java is simply far, far more costly than in any other JVM language. Imports section is completely internal for every single class. New feature is pure compile-time sugar that has no effect in generated code. Could you please elaborate, how this change may break backwards compatibility?
&gt; Ratpack Are you an Anarchitect
That looks nice. And in fact, it seems that you should be able to write a generator that uses details from a `Method`, which would be used like: Method m = ...; // Person.class.getMethod("getName"); MyAccessor fastGetter = MyAccessor.generate(m); Object val = fastGetter.executeGetter(target); 
I've got a longer breakdown of this I've posted before which I can link if you're interested, but I'm not as certain that `get` is such an issue. Ignoring the fact that it's basically just an alias for `orElseThrow(NoSuchElementException::new)` and that the Scala community also has a `get` on its `Option` type with little complaint, I think it's pretty much just `Optional`'s version of casting. Just like you can flip off the type system and cast an `Object` to `Integer` (implying that you know better than it what's going on), you can flip off the type system and call `get` on an `Optional` (implying you know better than it what's going on). Both are almost always terrible ideas that will likely blow up your program, but the language does technically allow as an escape clause - it's just extremely advised to never take it. You can argue about naming (`get` isn't great, in fact there are suggestions that an alternative might be added in a future release) and that casting is much more clearly ugly than a method invocation - and you'd be right. But that doesn't change the fact that the semantics are pretty much the same. A final note - your `Optional` code sample is very unidiomatic. I know it's toy code, but it still might be better to ensure that it's written to preserve compile-time safety by trying to never use `isPresent` and `get` together, even when it's "safe".
That does seem annoying, but isn't enough of an issue for me to remove the benefits of strong typing with `Optional` values. FWIW, we've had little issue using `Optional` types in all parts of our application - maybe we're just using radically different frameworks?
If you call a method a lot, won't it get optimized.
If you want to build something very generalized and flexible around Jasper, as I did, that is going to be more than a few days work. If you want to build a few simple reports that have one specific output, then you can probably do this. I would try just building one report first, and see how far you get. I've explained how you connect all the pieces together. There probably are numerous code examples online.
So, [reflectasm](https://github.com/EsotericSoftware/reflectasm)?
Reflection stays slow.
&gt; similar approaches can use ASM or CGLIB, but those infer extra dependencies But javax.tools.JavaCompiler requires "tools.jar" as extra dependency
Did you try https://github.com/drewnoakes/metadata-extractor?
Can you please give me the instructions on how to run the code? I'm a beginner. 
reflectasm can't be used for accessing private members. Also I'm wondering what its advantage really is, as JDK's reflection employs code generation (after a couple of invocations), too.
Hopefully you know how to use Maven. In that case, view the README.md on the GitHub page. If not, then you'll have to clone the project, import it into your ide and make it a dependency on your project. Either way, make sure the code is not malicious and doing something nefarious. You can do this by reading reviews online if such exist. If not, then you can peruse the code base. I can't imagine it'd be a large codebase Hope this helps.
I was never impressed with DBUnit... I generally just use raw SQL or develop a mini DSL in the tests to get the DB in the right state. However.... If you enjoy developing it and solves your problem, then more power to you!!
Interestingly, while I enjoy watching entertaining maths and pop science videos (e.g. Vsauce, Isaac Arthur, Numberphile, 3Blue1Brown, etc.), I don't feel this way about programming videos. From my experience, it seems that videos are a good media for entry level content, but not for people who need solutions for more specific problems in topics they're already proficient in.
It makes sense that generated code is as fast as native code since when you dynamically compile and load it it is native code, which can be optimized by the JVM. Still, yuck. I've never had a use case where I couldn't just resort to plain old Java for the extreme pressure points in an application. 
Agreed, this was some pretty pathetic blogspam, not a true review at all. I am still interested in the book, however.
Seems like they removed the previous HttpURLConnection example. Still bad though: `var list = new ArrayList&lt;String&gt;(); // infers ArrayList&lt;String&gt;` The list should be of type `List`, the underlying implementation should - in most cases - not matter. I'm also not that happy with the path and bytes example. It forces you to learn the API by heart. Otherwise you e.g. have no indication that path isn't of type String (old IO API worked with Strings a lot) or more importantly that bytes is an array and not say, a list. It's less worrysome though as atleast the variable names are acceptable this time. 
For the CLI portion, you could simply write it like any other non-graphical application (e.g. Hello World examples). Check out [Apache Commons CLI](https://commons.apache.org/proper/commons-cli/) to assist with parsing the command line options. I would also suggest looking into MVC pattern—if you haven’t already—for the GUI portion. Both the CLI and GUI aspects are part of the same application, so there is no need for a daemon or any sort of web calls.
Yes, but the tools.jar isn't an extra maven dependency, nor does it bloat wars, etc because it's already there in the JDK installation. When going to environments that don't have tools.jar, it's probably better to go with ASM or CGLIB.
You simply need to have all your business logic separated out into its own classes, then it doesn't matter if you access the business logic via the command-line portion or a JavaFX GUI. 
Or ByteBuddy, which is pretty amazing and seems to perform really well.
How did you get this to work when the "javax.faces.STATE_SAVING_METHOD" is set to "server" on Apache MyFaces? Do you have any documentation that shows how you were able to do this?
tools.jar went away in Java 9, so any solution needs to support the new scheme.
I mostly agree with you. I see the reason to include get(), though it could've been implemented differently. &gt; your `Optional` code sample is very unidiomatic. I know it's toy code, but it still might be better to ensure that it's written to preserve compile-time safety by trying to never use `isPresent` and `get` together, even when it's "safe". Yes, it is toy code, but I've seen production code exactly like that (which I promptly replaced with orElseGet() btw). It's an example showing how easy it is with the current Optional API to write code not only as insecure as before, but even more because "it's ok, I'm using Optional so it is safe". If get() forced you to catch the exception, people who doesn't know better would not be so tempted to use it as a quick shortcut. 
There's a 'java.compiler' module in Java 9...
Well, these are just one-liners that illustrate the syntax and mechanics. They have no context. For HttpURLConnection, I don't remember such an example from the JEP. Are you thinking of [my example](https://www.reddit.com/r/java/comments/7lgts6/what_to_expect_in_java_jdk_10/droywmq/)?
&gt; If get() forced you to catch the exception, people who doesn't know better would not be so tempted to use it as a quick shortcut. Hmm, that is a good point. I normally have a low opinion of checked exceptions, but this is a case which they fit well.
dbunit was ok-ish. The thing that I found was lacking was it's inability to add data to tables via a project's own DAOs instead of xml datasets.
&gt; Does JavaFX have a future? ...more so than Swing.
SIMD registers are not only for floating point computations, so the title should probably be SIMD register spills.
Which only re-enforces my point that OPs scheme will require differences with Java 9.
How do you execute this code when it doesn't have a MAIN function? 
But why not just assign null/0 to finals and also instrument super classes in the same manner?
Well all you have to do is ask yourself how well it would survive randomly crashing services and restarts. In a docker environment you want your services to be ready as soon a as they started and not depend on someone else to adjust their conf. 
Where is it released? https://mvnrepository.com/artifact/org.apache.maven.plugins/maven-checkstyle-plugin shows only recent 2.17 version.
Think of your utility as a separate library which contains all the business logic. The CLI is a thin wrapper which talks to your library. The GUI is a separate wrapper which talks to your library as well. It's probably best if the GUI and CLI don't interact with each other, but each interacts with the common library.
Btw, creating a mini DSL(presumably for Java, Groovy and for Kotlin) for small datasets would be the next step for JFixtures. The YML format is only good for big datasets and for high level (integration/acceptance) tests, when, for instance, test that hitting an http endpoint triggers reading many tables and many rows on the backend
This is a purely theoretical question, but ideally I'd already have my docker images good to go, it's more a case of wanting to be flexible when I spin up another container, so that as it registers itself as a service instance with my service registry, it can pull down any config needed at that moment decided by some kind of server brokering said config. But agreed, I'd definitely want my containers as close to ready to go on startup.
It's kinda difficult to discuss options since it depends heavily on your surrounding infrastructure, I don't like the idea of changing any config in runtime unless you put it in a database or something like that but I can understand cases where it's a valid option.
https://search.maven.org/#artifactdetails%7Cmaven%7Cmaven-checkstyle-plugin%7C3.0.1%7Cjar
Please post screenshots on how to run this code. I'm having difficulty as this doesn't have a MAIN function. 
Please read the sidebar and rules, thus this is for /r/javahelp and https://github.com/alecdhuse/Java-Jpeg-Geotag-Reader is a library; the usage is explained in the `README` JpegGeoTagReader jpegGeoTagReader = new JpegGeoTagReader(); File photoFile = new File(fileName); GeoTag geoTag = jpegGeoTagReader.readMetadata(photoFile); double altitude = geoTag.getAltitude(); double latitude = geoTag.getLatitude(); double longitude = geoTag.getLongitude();
Calling the non-static "getName()" method of the Person class, for a given person instance, with LamdbaMetaFactory, without doing a (Person) cast is proving to be quite challenging. In the referenced url, they're calling a static method. Same for most other examples I run into. getName() isn't static, so a Person instance is involved too.
The benchmark has warmups which do optimize the reflection code, but afterwards it is still twice as slow.
The idea is that Person::getName fits the interface interface Getter { String getName(Person); }
I'd be more opposed to reading it from a database than passing it through JMX. However in my head the cleanest option would be have any config changes deployed in the form of a complete fresh redeployment of the entire infrastructure
Yea that's what I would do too, we generally have a config yaml built into each docker image so changes would be made there and a image version upgrade made.
Similar for me, we'd pass it in through the docker-compose file. I'd avoid having things like port allocation locked down to the docker image itself though, in case I want to have multiple instances of the same microservice, could get messy forwarding the port through.
And a response of 2xx does not guarantee that the page exists. Some systems return 200 even for 404. Typically pages that have availability depending on your location within the network. Eg, some URLs are available online, some online while logged in, some on the intranet depending on which security level you're logged in as, etc.. Those systems may well spit out a 200 OK and ask you to login.
We've been influenced by the following masterpiece development books: Clean Code By Robert C. Martin, • Code Complete 2 by Steve McConnell, • The Pragmatic Programmer by Andrew Hunt, • The mythical man-month by Frederick P. Brooks, • Java Effective 2nd Edition by Joshua Bloch, • Java Concurrency In Practice by Brian Goetz, • Refactoring by Martin Fowler. We owe a lot to all the authors above. Without such quality readings we would be still writing if(.. != null) everywhere in our code. 
I'm not an expert, but I just had a go at this and it is very fast. Change was basically making `getterMethodHandle` public, then: private static final MethodHandle getterMethodHandle = (new MethodHandleBeanPropertyReader(Person.class, "name")).getterMethodHandle; ... @Benchmark public Object _201_staticMethodHandleDirect() throws Throwable { return getterMethodHandle.invokeExact((Object) person); } Results: Benchmark Mode Cnt Score Error Units FasterReflectionClientBenchmark._000_normal avgt 20 2.586 ± 0.027 ns/op FasterReflectionClientBenchmark._100_reflection avgt 20 5.351 ± 0.033 ns/op FasterReflectionClientBenchmark._200_methodHandle avgt 20 5.966 ± 0.034 ns/op FasterReflectionClientBenchmark._201_staticMethodHandle avgt 20 5.267 ± 0.019 ns/op FasterReflectionClientBenchmark._201_staticMethodHandleDirect avgt 20 2.585 ± 0.011 ns/op FasterReflectionClientBenchmark._300_javaCompiler avgt 20 2.870 ± 0.010 ns/op So the question is why does `executeGetter` (which is doing the same thing) kill optimisation? I decorated everything around it with `final`s, but it's obviously not enough.
The title is misleading, it should be titled: "Creating dependency images for running Java apps on Docker using the ModiTect Maven plugin". Just skip this if you don't use maven.
Java coding conventions: http://www.oracle.com/technetwork/java/codeconvtoc-136057.html
Then just don't use var in this situation. 
[removed]
It seems they did that mistake more than 11 years ago: [timestamp shows 2006](http://repo1.maven.org/maven2/maven/maven-checkstyle-plugin/3.0.1/). At the moment the latest release is still [3.0.0](https://maven.apache.org/plugins/maven-checkstyle-plugin/download.cgi).
I explained that to /r/ge0ffrey [yesterday](https://twitter.com/shipilev/status/950774722173825025), is probably worth copying here: &gt; Note that if your MH resides in static final MethodHandleBeanPropertyReader, VM has to trust MHBPRS' final fields to trust the identity of that MH inside, to enable folding. It does not by default. See https://shipilev.net/jvm-anatomy-park/17-trust-nonstatic-final-fields/
That is true, the post title follows the nomenclature for the Hotspot (-XX:+UseFPUForSpills). "SIMD spills" would be a bit more technically correct there, but alas.
[removed]
Aha, I guessed this was the reason. And I only knew about it thanks to your article, so many thanks for all your work.
what are it's advantages over [hystrix](https://github.com/Netflix/Hystrix)
Only twice as slow? Damn, that's much faster than I expected it to be!
While the article is specific to Maven and ModiTect (sorry for not making it more clear), the underlying concepts are not: instead of frequently re-building and distributing a fat JAR, it's more efficient to split the more stable parts (dependencies, and in case of Java 9, the set of used of JVM modules) and the frequently changing parts (your actual app) and manage those in two layered Docker images. This pattern can also be employed by hand (calling jlink directly if you like or just assemble a directory with your dependencies) or other build tools. A Gradle plug-in would be a nice addition to ModiTect.
See the Readme, look e.g. for "To highlight a few differences to Netflix Hystrix".
I automatically wanted to point out Hystrix and [Failsafe](https://github.com/jhalterman/failsafe), but ... this is better, or at the same level, at the very least. Very nice, will experiment with it!
From what I've read in 10 minutes: Hystrix is more like a framework (opinionated, batteries included) while Resilience4j is a collection of libraries where you can pick what you need and ignore the rest. 
nice, I like the ability to stack the decorators. 
Yea well that shouldn't be in conf, use a service registry with health checks etc like consul or similar to dynamically reg and ask for services.
More ideomatic is: ````java return x.getBase().map(Function.identity()) ````
Who downvotes this shit?
A variable has three important information: Type, name and accessability / scope. This information can be present on two axis: for the developer visually as an aid or for the compiler. The goal of type inference is to eliminate the cases where the type information is redundant for the compiler so that the developer has to type less. You're never going to gain more visual information through type inference, but there are many cases you loose information: on method returns. &gt; If I look at new code and see User foo = bar();, I think "Okay, the return value is some kind of user object" and the context in my mind is user-related functionality, but I don't know exactly what. I see a user foo. Foo that is a user object. Lets proceed with a better example: `Name name = person.getName();`. I can immediately conclude that I got a name. It's mostlikely the name of some sort of team leader and I know I can call e.g. `name.firstName();`. &gt; If I see var user = bar();, I have the same thought process. You don't, because you wonder what kind of object this user is. What can I do with a "user"? In our case it would become `var name = person.getName();`. You miss the type information of "name". Is it of type `String`, `List&lt;String, String&gt;` or `Name` or what? I need to look it up if I don't know the method by heart. You'd need to name the variable `nameName` (or `nameString`) but that's exactly silly, confusing and even a source of error when refactoring the method return type but forget to rename all the variables too at call-site. You can't get it wrong, when the type is present. &gt; If I'm really looking for more information, I can quickly get the IDE You only need to do that, because you're missing visual information. Even if you have an IDE at hand, which is not always the case. It is less quick then just seeing the information at first glance. &gt; Depending on the name of bar and better options for the variable name, I can get more information on what kind of user this is. You can name the variable anything even when the type is visually present. Though it's bad practice to be reduntant. No good developer writes `Person johnPerson = new Person("John");` This whole issue intensifies with Generics and abstract classes / interfaces. See `Optional&lt;Car&gt;` or `Set&lt;Books&gt;`
I don't, but many will. Like OP. Like the [Oracle guys](http://openjdk.java.net/jeps/286).
Thanks for looking this up. Those code conventions are very shallow.
I can recommend Sebastian Daschner's "Architecting Modern Java EE Applications." He's a Java Champion and frequent speaker on Java EE and the book has only just come out (as has JavaEE 8). I was surprised to see it in this list.
It would be very, very nice if it had some comments on memory consistency, Java Memory Model and Happens-Before-relationship; I have the impression that awareness and sufficient understanding of those issues tend to be very lacking among professional developers.
I'd say that's fast enough to be an negligible difference for almost all uses. How often is the time spent on method invocation really a significant portion of the total processing time?
Very informative, thanks.
I do as well, so I'm slightly concerned about it becoming an Apache project.
Who downvoted this......
Java: Concurrency in Practice was written by Brian Goetz, and is probably the best source for it. It was published in 2006, and a number of people has asked for newer editions of it, but Brian Goetz has said that if a new edition came out, it would only be additions. There are newer approaches and techniques as well as experience, though I am convinced that Brian Goetz is correct in that the book is still valid and very relevant, especially in regards to the parts regarding memory consistency, JMM and Happens-Before relationship. The main issue is that the book is a bit expensive, including the online e-book as far as I have found. I still have my old hard-copy, though I have searched online for possibilities to share with others. There are also the Sun/Oracle tutorials, though they touch only very lightly on some of these issues: https://docs.oracle.com/javase/tutorial/essential/concurrency/memconsist.html. It has been some time since I read through the concurrency tutorial, and the tutorial have changed since then, but I recall the tutorial being good but not at all sufficient after reading Java: Concurrency in Practice. There is also the website for Java: Concurrency in Practice: http://jcip.net/, including code listings. The code example 3.15, for instance, shows some of what can go wrong if thread safety is not followed; the `AssertionError` throwable can be thrown in that example if the class is not used properly regarding threading. If anyone knows any good, online and free resources regarding this, it would be great if they would drop a comment regarding it; the book is still very good and I wonder if it should be seen as mandatory for professional Java programmers that use threading in their programs and does not follow a purely-functional programming style (many/all of the memory consistency issues disappear without mutable state that are worked with from more than one thread - I believe this is one of the reasons why Brian Goetz worked on in Java 8 and is working on in future versions of Java more support for functional programming - seriously, the crap that can happen with lack of thread safety is really, really bitter and for many befuddling and completely unexpected :-( ).
Listing 3.15 as mentioned in the other reply (originally released under the Creative Commons licence): package net.jcip.examples; /** * Holder * &lt;p/&gt; * Class at risk of failure if not properly published * * @author Brian Goetz and Tim Peierls */ public class Holder { private int n; public Holder(int n) { this.n = n; } public void assertSanity() { if (n != n) throw new AssertionError("This statement is false."); } }
As a side-note, I believe Java/JVM is one of the better languages in this regard, given that Java was one of the early languages to get a properly defined memory model, and still being cross-platform. Haskell and Erlang I somewhat believe also does really well in this regard due to complete immutability - in fact, if you do not use `unsafePerformIO` and the like in Haskell correctly, I think you can get fairly similar really strange behaviour (I recall a somewhat recent blog post or similar on /r/programming regarding that, though I might be mistaken). In Java, memory consistency errors are not quite at the level of C++ undefined behaviour (where absolutely anything horrible can happen), but it is considerably in that direction.
Groan. We're into Java 10...still writing (or generating) getters and setters for the 98% of the time they don't do anything special. How about @property or some already guys?
Agreed. That would be very handy in reducing boilerplate tremendously.
Shipilev has two long articles about the JMM and its implications: - https://shipilev.net/blog/2014/jmm-pragmatics/ - https://shipilev.net/blog/2016/close-encounters-of-jmm-kind/
Hi HansVader, should be able to read it on mobile and tablet I have increased font size; please let me know if any issues, thanks
Your most welcome rahulshishodia :)
The preferred Java method to run stuff concurrently is not explicitly creating Thread objects and start them, but give Runnables to an ExecutorService. I suppose it's fine to demonstrate concurrency patterns, but then again, if this is supposed to give a good example, maybe they should start at the basics.
Thanks Shipilev &amp; shellac, that makes more sense why my static approach isn't as fast as it could be. That being said, static fields are still virtually unusable for this very common use case of frameworks - but I 'll update the article with the improved test and better explain why static fields are unusable.
Here's the code for that: https://stackoverflow.com/questions/48203370/use-lambdametafactory-metafactory-for-plain-non-static-getter
&gt; As client application development continues to shift from the old “plugin” world to modern deployment What?! Webstart is THE way to select an app from your appstore(website) and install it without hassle. Server side updates are checked whenever you start the app.. In my opinion *dropping* JWS makes the Whole JAVA SWING APPS lose any benefit over native desktops and their Appstores. 
Null isn't a primitive, which is my question if you didn't read it.
I use this https://commons.apache.org/proper/commons-collections/javadocs/api-release/org/apache/commons/collections4/CollectionUtils.html#emptyIfNull(java.util.Collection)
I think http://webswing.org/#!/home is here to save the day migration
Aggggg! The contribution of my life is wasted! ;-) Why I've never saw that before? I always use apache commons, and I try to reuse that as much as possible. Thanks for the information!
Article updated with correct results for static MethodHandles (they are indeed as fast as direct access), as well as a better explanation on why they are useless (for this very common use case). https://www.optaplanner.org/blog/2018/01/09/JavaReflectionButMuchFaster.html 
There are a few edge cases: - The Traveling Salesman Problem with incremental score calculation that I mentioned. The gain is clearly visible (18% faster) - Maybe insert 10 000 person objects into a database with JPA?
I still would prefer an automatic updater / launcher ... are there any good ones in use ? 
So the only value of this is for migrating existing Swing apps, right? Because I don't see why anyone would start a new project in this way. The whole value of webstart is that it's Java that runs client-side. If it's gonna be running on the server anyway with a thin-client then there are a ton of other options that aren't hacked up on a twenty year old UI framework. But yeah that sounds like it could make quite a few people's lives a whole lot easier if they want to keep their legacy stuff chugging along, good find.
As Nalha said, it depends on your other infrastructure, but if you have many services, you can still use something like consul to store your config, and then use it's template feature (I think it is a plugin) to build a config file. For Spring Boot you also have a Consul client, which will connect Springs application.yml-config to Consul, but there are existing Java projects to create auto-updating configs if you need that. What you want to avoid for sure, is to store credentials in git-repos... I am not affiliated with consul in any way, but are currently researching this for a project I am involved in.
Not something that you can use in production, but I'll drop it here nevertheless: my colleague co-authored a project that aims at turning the whole concept upside down (which they think was always _the_ upright position): https://github.com/brunoborges/webfx
Bruh... again, read the comment above mine. 
Sounds like what you want is central configuration, look at https://zookeeper.apache.org/ for example.
How is this a shortcut, and how does it hurt maintainability? Haskell has full fledged type inference, and no one has ever complained about that being an issue. I think for many people it is just a fear of the unknown.
Thank you very, very much, a quick skim makes it looks like it is exactly what I was looking for, though I have not read through it yet. I will return once I have read through it.
When a language syntax compiler can replace custom test cases, that is definitely good. Usually, you still want some automated tests on top of what the language syntax does.
I don't think so. I just want something that does what webstart does, and I'll have to install it to the clients computer (since it won't come bundled with java). The goal here is that I can put my app.zip somewhere and the clients on that network will update themselves with it. Shortcuts problems aside under WebStart, this is what it did good.
This looks like a breakdown of low level concurrency tools, not the higher level abstractions most engineers work with. If it was, there'd be a lot more talk about `CompletableFuture` - no manual submissions to an executor required. ;)
s/ElasticSearch/Elasticsearch/ It is nice to see the high level rest client get some use and coverage. As someone who works a fair bit with Elasticsearch's sort of callbacks I don't find them particularly difficult to reason about. Debugging is certainly an issue because you don't have stack information about the caller but I've always thought of that as the price that you pay for doing async work on the JVM. Maybe I'm just used to it though. Anyway, I'm not sure this is callback hell, but I'm glad you can adapt it easily into a thing that you are more comfortable with. And I'm very glad dealing with performance degradation from components is a thing you are talking about.
Absolutely agree. And if you want to take the toy example further. Assume Email is more than just a string, that there is an Email object. userDetails.getEmail() .map(Email::getAddress) .orElse(null); null is awful because it hides the fact data may be missing. In some cases, I've seen code littered with pointless `if (foo != null)`s just because there was a possibility that foo might be null (even if it never was).
Can we all just let WebStart die quietly? really, no need for a replacement
&gt; Does Oracle envision Swing users use JavaFX? &gt; &gt; Does that have any benefits for the Desktop? I have no idea to be honest what they are up to, I haven't been following their noes to closely, though. I've been following the JavaFX development, and I'm not seeing anything interesting there happening. In my opinion, JavaFX is not an alternative to Swing, not if we're talking about ERP/office applications. I'm still more afraid that there new release model is a scheme to kill FLOSS in companies. Because with their rapid releases and "just use the next release if you need something fixed" the only option for companies are the LTS releases which will not be open source. So there are two possibilities: 1. They are selling these LTS to generate money. Nothing new there. 2. They are giving them away for free. The only reason why to make them closed source must be to remove FLOSS from companies for some reason. I never thought that I'd actually hope that something was *just* a money grabbing scheme...
I hadn't heard anything about JNLP and Web Start being deprecated or phased out. Source? There is still documentation on the file format on the Oracle site: https://docs.oracle.com/javase/9/deploy/java-web-start-technology.htm
https://jdebp.eu/FGA/systemd-house-of-horror/tomcat.html
To judge your ability level, attitude, etc a lot of people lie on their resumes
Effectively what Webstart does, is download a bunch of jars as mentioned in the jnlp and run a JVM with those jars on its classpath. The simplest form would be to have a cmd file use curl to download je jars and start a jvm with them. (Webstart became complicated when they had to guarantee the jars weren't tampered with..)
Me neither Source e.g. https://stackoverflow.com/questions/46904795/java-web-start-support-in-java-9-and-beyond 
Meh, that benchmark again. How were the test warmed-up, what happens when each server is configured for such excessive testing? What happens if the servers actually have to do a little *real*work, etc etc... 
There's also the [Techempower Benchmark](https://www.techempower.com/benchmarks/) with Light taking top spots. But it has no Payara Micro.
Can you explain where the pain comes from, Just to get a clue?
Apache Commons
I don't get it. Senior programmers should know principles and patterns, design and architecture. Aside from core Java, specific libraries shouldn't be on the list. Who cares if one senior is well-versed in RxJava while another is well-versed in vert.x or vavr or Apache or Guava ??
A language is just a tool and a library is a tool of the language. A senior engineer needs to be well versed in libraries specific to the applications they are developing as a carpenter needs to be well versed in using wood working tools. But there is no set of universal tools in my opinion that every senior engineer needs to know. Only architectures, patterns, problem solving approaches, communication skills, negotiation skills, platforms, that kind of things are what senior developers need to be good at. 
I know exactly how webstart works... anyways...
Some background would be helpful here: If you're pretty green and looking to prepare for your future, start with The Clean Coder and Effective Java. If you are in a position to enact organizational change and are wondering where to start, consider reading Project Phoenix. If you purely want to stay up to date on fresh technologies, start attending your local java/js/.NET/ux user groups. I'm in a town of 700k and there are a couple dozen user groups available each month.
I would say Spring Framework is a fairly common requirement.
[removed]
Project Phoenix? A quick search and all I get is some dumb game scandal.
Also, spring data has neo4j support, ended up being super simple to do.
I suggest vavr.io. You may not ever use it in production, but it's a really nice look at functional programming in Java, and it will make you look at code a little bit differently.
looks good based on code samples. how does it perform compared to other libraries like gson?
😆
Hrm... that ain't good. I have a sizable use case that depends on reliable cross-platform deployment of signed code that needs to run in the security context of desktop users, and that does a moderate amount of "heavy lifting" on the client machine. JNLP deployment of signed pack200 jars works perfectly right now. Not having an alternative is going to be a capital-P problem.
You are wrong but it is generally true.
[removed]
You will be much better off in the long run hiring the guy who understands all of the interfaces instead of just the APIs of certain implementation. To be specific to your example, hire the guy who understands dependency injection over the guy who built a reddit clone in Spring once.
It's a book I believe. 
Agreed, Spring Framework, Apache Commons, and Google Guava are everywhere in the enterprise Java world. To a lesser extend, RxJava and MyBatis/JooQ are also worth having some familiarity with. 
has anyone seen what's happened with the call for vote on project loom (continuations on the jvm) ? doesn't look like anything make it into the linked feature list for 10 
This is a good list: https://github.com/akullpp/awesome-java You don't need all of it, just the bits that are related to the sort of work you do. 
Seniors already know them
know and understand the principles, not the implementations. know how to explain stuff and know pros/cons of stuff. you cant know everything. you can be a senior with zero spring knowledge. simple example: know how you can read/parse json, every project uses a different lib for it. if you need days to learn how to use it, youre not a senior. also required that you can explain the difference between json array and json object, and 0 is not null to a php programmer without violence
Short list off the top of my head. A senior engineer should be aware of pretty much all of these and have very strong knowledge of at least one per category. * Logging - Know SLF4J and one of Logback / log4j * HTTP Client - OkHttp, ApacheHttpClient, Ning Async Http Client * JSON - Jackson / GSON * Webserver - Undertow, Netty, Tomcat, Grizzly, Jetty, Glassfish * JDBC - JDBC in general, HikariCP for connection pool most others are out of date. * SQL - jOOQ, Hibernate, JPA, JDBI * Utils - Guava, Apache Commons * Config - Typesafe Config, Apache config, Spring Config
I suggest adding "DI - Spring, Google Guice" to that!
It's a book about agile development, our agile coach is always banging on about it
The point is senior engineers should be well versed in some libraries. If a senior engineer only knows patterns, design, and architecture they aren't very senior in my opinion. Knowledge of the libraries you use is very important. Do you care about blocking vs non blocking? If something uses thread pools what are their defaults and can they be configured? Timeouts are very important. Is your webserver using the thread per request model or IO threads that dispatch to worker threads? Does your http client / webserver support gzip and is it on or off by default? Or how many connections per host does your HTTP client support by default? (it's generally 5 or less which is often less than you might want especially in microservices) Some of these can have major performance implications. So yes senior engineers should know at least some libraries very well and at least be aware of the other libraries.
Look at your answer en detail again: Do you see any *libraries* or *frameworks* mentioned within? You are just talking about *concepts* and *general* aspects. So that's exactly what /u/KeepItWeird_ talked about and it contradicts yourself!
See https://www.reddit.com/r/java/comments/7ps3l0/libraries_senior_programmer_should_know/dskd40a/
unless its javascript then the best libraries are coming out next week.
As a junior who is a bit worried now that he is not using JDBC correctly now, can you point me to an article or something where I can read more about that correct usage? 
Without violence? Hey, I can't make any promises...
If you remove all the spring and reactive praising, the article boils down to: **tl;dr;** You can use CompletableFuture/Promise/Mono/Whatever with a callback based API by rejecting/resolving the Future/Promise/Whatever from within the callback. 
A senior programmer will know how to find a library when he detects a reccuring issue that needs to be solved. He will quickly learn to use it and implement it. I'd rather hire a guy who knows about concepts, who will be able to detect problems and think about many solutions to solve the problem and pick one of those solution, over a guy who masters a specific library but cannot work properly with technologies he never used.
I'd add: * Functional: Vavr.io, Java 8's lambdas (java.util.function) * Resilience/Circuit Breaker: Hystrix, Resilience4j, Finagle * Date/Time: Joda, Java 8's time (java.time) * Reactive Streams: RxJava, Java 8 streams (java.util.stream), Akka Streams * Concurrency: Java's concurrency (java.util.concurrent), Akka Actors, Threadly, JCTools * Build tools: Maven, Gradle (not just executing, but customizing/extending) Less important (IMO): * Scheduling: Quartz, Akka Scheduler * Event sourcing: Akka Persistence, ES4J * Monitoring/Metrics/Tracing: JMX, Dropwizard, OpenTracing (Zipkin), Statsd * Documentation: Swagger, RAML * Profiling tools: JProfiler, VisualVM I'll add more as i think of them
&gt; Debugging is certainly an issue because you don't have stack information about the caller but I've always thought of that as the price that you pay for doing async work on the JVM. This is why `CompletableFuture::get()` wraps exception in a new `ExecutionException` (with a new stack trace) instead of just re-throwing the original exception. It helps a lot.
[I wish the Oracle tutorials got it right, but unfortunately, they don't](https://docs.oracle.com/javase/tutorial/jdbc/basics/index.html). As a general rule of thumb, put every `java.lang.AutoCloseable` and `java.io.Closeable` in a [try-with-resources statement](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html), *unless* you know that you want to keep the resource open for more than a local scope
Thank you :)
True but most would know one other http client (maybe not ning), connection pool (perhaps c3p0) or ORM (hibernate), no?
Thats kind of my point, by the time you are a senior engineer you should have hit several issues like this which would lead you down the path of mastering at least some libraries right? So if you are a senior engineer who hasn't mastered any libraries are you really that senior?
Exactly! This is why there are no "MUST KNOW" library. I would have agreed if OP said something like "every senior programmer should know one library for X, one library for Y etc..." And even thinking like that, there are very few that every senior should know about. If you are not working on web dev or at a higher level, you don't need to care about http clients. But having to know a specific library? Makes no sense.
I would not expect any senior engineer to be able to rattle off dozens of properties along with their default value for each just by memory for every library our company uses. A senior engineer just needs to be aware that a concurency library probably has min, Max, and ttl settings somewhere and a logging library probably has formatting and logging level properties somewhere and should know to google for them if they get in trouble. Spring boot is very configurable but I would not expect an engineer to walk in and replace every library they are unfamiliar with to one the are familiar with. In fact, if I hired someone and they literally replaced dozens of the default libraries on day one, it would be a red flag if they didn't have a solid justification for each one. Does your company just never change libraries if no one is a master at it? 
You example is not a good example, because it is really specific. You are talking about encoutering an issue and hopefully, you have a senior programmer that knows the libraries, therefor he can adress the issue. This is not relevant. First of all, your example is filled with premature optimization. You have already choosen technologies and you are already trying to reason on performance. Second, your example only works because you have an engineer in your team that knows about the problem. Not relevant. The worst problem you are faced are the problems nobody understands. THe worst problems are the problems you don't even know the cause. If you don't know the cause, you can't hire someone who masters that undetermined library. Smart &gt; Skill. A good senior will ask other questions before even choosing a technology or a library to use. He will choose a library that can adress the issues he is presented with, rather than trying to adapt the library he masters to the problem. If I hire a good senior that doesnt know shit about Apache HTTP, I will trust him enough to investigate the problem, read the docs and fix the issue. My guy will know how to solve a large array of issues, while yours will only fix AppacheHttpClient related issues.
&gt; A senior engineer should be aware of pretty much all of these and have very strong knowledge of at least one per category. Is that not what I said? One per category and you probably should have heard of the others you don't have to know them well or know how to use them but know they exist. The libraries you should know are whichever your company uses. I'd say its very hard to become a senior Java engineer without knowing a good portion of these though. Frameworks do a good job hiding a lot from you but ultimately you often need to know how the internals work. I know that Jackson and GSON can both do json serialization in java. I barely have any idea how to use / configure GSON. I'm sure I could figure it out but it would take quite a while to get to my same understanding of Jackson. Simple things like how do I ignore nulls / empty strings, camelCase vs snake_case, how do I format dates in the json, how do I stream a large json file that doesn't fit in memory, how do I add custom mappers, how do I handle dynamic json that doesn't have a fixed POJO to map to, how do I trouble shoot it when it's not working. These are all things I know in Jackson that I would need to learn in GSON. A senior engineer should know stuff like that for either Jackson or GSON if they deal with JSON regularly. Its fine to look stuff up but you should have some kind of direction and prior knowledge / trouble shooting skills.
The only thing I said is I would expect a senior engineer to have mastered some libraries. I would expect them to learn whatever libraries we use and offer suggestions if they have better solutions. Those suggestions would be weighed and decided on by the team. But if you literally copy paste snippets of code from SO and that is the extent you know every library you use then no, you are not senior. I wouldn't expect junior engineers to know that Jackson ObjectMappers are meant to be singletons but if a senior engineer has been using Jackson for a long time and is constantly making new ObjectMappers that would be a red flag to me. I wouldn't expect junior engineers to even consider turning on gziping on the server side / client side of all HTTP but a senior person should probably know how to do that in their framework. I would expect them to know that most HTTP clients are meant to be used as singletons and shouldn't be recreated for every request. A senior engineer who uses a lot of SQL I would expect to know how to do SQL batching in their framework of choice. As well as know to use connection pooling (and hopefully give thought to the size of the pool instead of just throwing 50-100 connections at it). I would expect senior engineers to know to use the message formatter of SLF4j instead of String concatenation when logging. I would expect them to know to wrap expensive logging in the logger.is{level}Enabled() blocks. I would expect a senior engineer to know how to use logging in general, it's kind of sad how many don't. I would expect a senior engineer to have a pretty good idea of how their web server works. is it thread per connection vs IO threads and workers and how big are the pools (how many concurrent connections can we handle). Can they set up access logs for it, can they debug it easily, how do they add request filters. (some of which can be covered by frameworks, some configurations need to be done to the server though) All of this is relatively easy to learn and is fine if you are a senior coming from a non Java background but if you are a senior Java engineer you would be expected to know some of the frameworks you use. Is that really that unfair of an expectation? That someone knows the tools they have been using for years well?
The problem is exactly the same with any of the HTTP clients and web servers +/- a few. I never said they should only know 1 library. They should know at least one http client, at least one web server, at least one json serializer... If you are a senior engineer and don't know any libraries well that is a major problem in my opinion. Unless you are coming from a different language then I would expect you to know some of those libraries well. In your example if the person is able to solve my problem then I would assume they at least know some other libraries well. And the fact is, in my experience these are issues I see all the time. Lots of "smart" people try to optimize the code before reading the docs. My point isn't that they should know specific libraries it's that in order to solve more complex problems you end up digging deeper so as a side effect I would expect them to be very knowledgeable of some libraries / frameworks. 
Honestly, it all depends on the kind of project you are working on. If you're hired as a senior engineer to actually build things in a timely manner, you better know relevant libraries. If you're hired more as an architect or visionary engineer, you might not have to actually write much code and mostly shepherd the project, which is more about good engineering principles. In truth, the "pie in the sky" architect roles are becoming fewer and fewer these days, so you probably need to know both. You will be MOST effective if you can both mentor your team on how to write good code utilizing the write libraries and tools as well as using good engineering principles so the solutions are reliable and maintainable in the long term. 
I agree that through their travels I would expect a senior person to pick up some in depth knowledge of a few libraries. But if one of the "senior devs" ever came to me and said &gt; maybe apache http sucks I hear great things about OKHttp let's refactor We'd be having a long talk about that person's decision making process and unless this was a one-off incident that person would not be making decisions without supervision for awhle. 
&gt; that is indeed very hard to keep track of without any significant overhead Yeah!
I hope they reconsider their decision to get rid of Java Web Start. It is a great way to deploy desktop application. I have a feeling it is used in enterprises more than Oracle thinks it is The one drawback it has is it depends on a preexisting java installation (because browsers map jnlp files to the javaws executable). I believe this is why it is deprecated. They are trying to get away from deployment mechanisms that require a runtime to already be installed (picked this up from the mailing list), there is a somewhat lengthy thread about this here: http://mail.openjdk.java.net/pipermail/discuss/2017-November/thread.html#4586
I have shared a list of 20 libraries, which I think, every Java programmer should know, you can take a look at that, you may find useful: http://javarevisited.blogspot.com/2018/01/top-20-libraries-and-apis-for-java-programmers.html Thanks Javin
&gt; JNLP deployment of signed pack200 jars works perfectly right now. I couldn't agree more. 
Well yeah, it's called Java Web Start.
You must not know what web start does if you don't think it fills a need. Web start going away would be a huge blow. It can't be removed without there being a replacement.
But look at what you're writing: "if a senior engineer *has been using Jackson for a long time*" ... "a senior engineer *who uses a lot of SQL*" ... "a senior engineer [should] have a pretty good idea of how *their* web server works" (never mind that a good many senior engineers never touch a web server)... there are so many "ifs", you can't say a senior engineer should be expected to know all this stuff. Maybe you could start to say "what libraries should a senior REST engineer know" or "what libraries should a senior UI developer know" or "what libraries should a senior database developer know", and I'd expect senior engineers to kknow some libraries, but there's no core set of libraries all senior engineers should know. The core principals remain important; the specific libraries (why SLF4j? Why not log4j2 or logback or ....) are less so. The original question (OP's question) has no answer.
I totally agree, but I also see this happen in practice quite often :(.
Spring, Apache and Hibernate yes. I've only seen Guava used at one place and I've been around quite a bit. I've never (or perhaps rarely) used or seen RxJava or MyBatis or JooQ used yet. I'm in the boat that the OP's question is interesting but not directly relevant to defining "senior". I don't think there is a definition of senior that works yet, the programming industry is still too new for that. Perhaps in another 25 to 50 years it will become clearer. I think that someone with 2 years practical experience who is suddenly asked to fill a lead role is to be considered senior as they now are dealing with people as much or more as software. I think that if you've been coding for 30 years and prefer to just keep coding and avoid senior roles doesn't mean you're not senior; it simply means you're not in a senior role. 
And conveniently placed a Udemy referrer link with each of them? You're trying to make money, not trying to help.
Maybe "JSONs-D"
How about core ones, then? Which do you think are most important to dominate? As a Java beginner for over 10 years now (long story), it's borderline overwhelming to try and make sense of what's necessary and what's not
`java.nio` If you are instantiating a `File` in 2018, you're doing it wrong. For that matter, throw in `java.util`, `java.util.concurrent` and `java.net`. If you don't have a proper understanding of the capabilities of the standard lib, then you probably don't understand what third-party libraries are really good for.
I'd add Reactor to the Reactive Streams libraries - it's the implementation Spring Boot 2 will use under the covers. I've been working with it recently and it's pretty nice.
No history :-(
No history indeed... best to keep those old repos around then...
Yup repositories, I know it's not the prettiest using custom query method's, but between the built in paging and sorting support as well as being able to write database agnostic query method's by simply defining a method signature in an interface is amazing and gets rid of so much boiler plate code. This is particularly useful when I'm doing R&amp;D for a new project, I can swap between neo4j, SQL, and Cassandra with hardly any code changes. It's awesome.
&gt;If you are instantiating a `File` in 2018, you're doing it wrong. I don't even... What? 
Depends on the type of programmer. java.lang, java.math, java.util, and java.time for sure, maybe java.sql, java.net, java.io, java.nio, as well 
Why not use micrometer ?
Could be used as well, and the conf will remain the same!
I had already seen this tutorial as a keynote. A fun part of the features displayed in the keynote, is that `ServiceLoader` can actually load modules as "plugins". Like, drag and drop a JAR file to a folder, and invoke the service loader and boom! There you go, you have more implementations. The talk can be watched in YouTube, and here's a [link](https://youtu.be/tamVhtV18dY?t=38m15s) for the example I've given. I encourage watching the whole talk,as it's reaaally good. 😁
Thanks for sharing WebFX :)
[@author's latest tweet](https://i.imgur.com/qkNeI8w.jpg) [@author on Twitter](https://twitter.com/author) - ^I ^am ^a ^bot ^| ^[feedback](https://www.reddit.com/message/compose/?to=twinkiac)
Considering [JSONP](https://www.w3schools.com/js/js_json_jsonp.asp) already exists as a means of handling cross domain AJAX requests, yes it would have been nice to pick something else.
Too bad [Castanet](http://web.mit.edu/outland/share/lib/castanet/tuner/lib/doc/introducing/introducing.html) from [Marimba](https://www.wired.com/1996/11/es-marimba/) didn't make it. I actually gave it a shot and it wasn't a half bad idea.
It was a very insightful talk, it really kick-started my interest in Java 9, as before I just knew about the module system and it's use for streamlining the jdk, but not the uses an end user could give it.
Relevant discussion on the mailinglist: https://groups.google.com/forum/#!topic/querydsl/B5UOzCYbNcE
Aside from being work, it doesn't sound too complicated to replicate. You probably don't need tamper-guarantee right? Or you could add a hash-check.
I think it's more of the latter. But the ones that do get the attention and support turn out really good, I use Apache POI almost daily for processing CSV and XLSX files.
We can only hope they maintain Netbeans.
That would be great news. I miss stealing a feature every now and then.
You are talking about Java**Script**, not about **Java**. These are two distinct languages that have nothing in common. You will rather need to post in **/r/javascript** - or maybe even in **/r/techsupport**.
Ahh thanks. Didn't know that. Anyway I think I've concluded the problem to be on the website's end.
I'd say all of this foundational knowledge is crucial for a senior in combination with the libraries and packages to apply them. I think the original question is valid. If a senior candidate cleanly described some architecture with good reasoning, but could not recommend any actual libraries or frameworks or whatever, do they even actually write code? Have they been rolling their own guava, hibernate, spring? Huge red flags
For those who don't know: /u/lukaseder is the author of JOOQ :)
I hate running out of mana
Maybe it's not feature complete :)
/r/javahelp 
I have had nothing but trouble with hibernate. It always seems great until you try to do anything complicated with it and end up banging your head against a wall for a week... JooQ, MyBatis and straight JDBC is what I prefer. SQL is your friend. 
I prefer straight SQL too, many places still use Hibernate which is why I mentioned it. JooQ looks good, I was just saying, it's been my experience that I've not seen it; not that I don't like the concept. For my own site, I've been playing with Spring JDBC Templates, seems like it could be a good way to go.
Yeah I've used spring JDBC template and it is great. Lots of convenience functions. Still very close to the SQL. I'm using JooQ for a rather large project right now and I love that it is like writing SQL with Java syntax and gives you great portability. You can easily add support for a new SQL flavor because it takes care of that for you. 
Oh and I hate Hibernate. Nothing but headaches. Looks cool at first but I always regret it when doing any complicated relationships. 
http://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase7-521261.html
Advertisement for garbage. Basically with JavaFX and the AOT codename one is going out of business. Wahhhh.....
Funny guy
Using JooQ on a project now. It is wonderful. So natural. Fast. I've used many query DSLs in many languages and it is hands down my favorite yet. 
That's a lie, don't make up stuff you don't know. We are the only company in the mobile Java field that actually has a stable revenue stream. 
That's nonsense. AoT compilers for JavaFX have existed for years and literally no one used them. Why would this new AoT make a difference? Has the team involved invented a new way of compiling ARM code? There are technical requirements that aren't circumvent-able. Some a*holes have been saying we'd be going out of business for years and so far we are the only company in the field with a good long term revenue stream while everyone else has either closed or effectively stopped development. These are facts. Try to build a hello world application in any JVM other than Codename One. Hell use Xamain and compare the size to Codename One... Out iOS build is 3mb and an Android build can be as low as 1.5mb.
True
I have editing privileges to that page. Find **one** verifiable factual mistake and I will personally fix it. 
It's missing what in my view is the best blog in Java: Nicolai Parlog's [codefx blog](http://blog.codefx.org/). 
JSP is _very_ low-level. It's almost as bad as drawing in paint vs drawing in photoshop. Spring gives you an enormous amount of tools to make your work a lot easier.
JSP is a view technology. It is not a way to implement a whole web application (although, of course you can do it if you really really want to prove a point). You can use JSP with Sprint, Struts or some other framework to implement your views. In that sense they complement each other. The framework allows you to write your backend code in an efficient and maintainable way. You can then populate your JSP context there and render your JSPs using information on that context. Again, of course you don't "have to" do that, but this allows a nice separation of concerns and results in a more maintainable system.
This. Usually even most basic applications need to do CRUD -operations (Create, Read, Update &amp; Delete). If you as a Java developer don't know basics of relational databases: on how to create a database, how to use it, how to connect to it via JDBC, etc... Then that is a big minus. When you know basics of using relational databases, one can then expand to either know how to use ORM tools or how to use NoSQL databases.
This sub isn't for learning Java though, check out r/learnjava 
Is there anything like this but for podcasts? Are there any good Java podcasts except JavaPubHouse?
Confusing title. Clickbaitish primitive equality works. 
&gt; News, Technical discussions, research papers and assorted things of interest related to the Java programming language &gt; NO programming help, NO learning Java related questions!
Try /r/javahelp
They do another one called off heap, if your into mobile Java Fragmented. Then the next best thing is vJUG or night hacking which is actually video so doesn't always work as a podcast. Would love to know others...
Yeah, know about off heap, but I'm looking about podcast that are more focused on Java programming topics than discussions about EE and it's future. vJUG looks interesting, though. While not Java exclusively, you can checkout se-radio: http://www.se-radio.net/
I wish someone did a Spring boot podcast
As you have probably already discovered, JSPs allow you to dynamically alter the HTML of your website. For example, instead of having to copy and paste the same chunk of HTML around, you can write a loop and have the same section repeated. If you have never used a full web framework before (like Spring or Struts) this may seem very sufficient at the moment. For very simple websites maybe it is sufficient. However, you will quickly encounter things that you want to do that are quite difficult in JSPs. You will start writing code that becomes more and more torturous to change and maintain. If you have never experienced this before, I would strongly encourage you to keep going with JSPs on their own so you can experience this pain for yourself. Web frameworks will solve these problems for you but they do so at the cost of significant complexity. For those who are used to them, I think it can be difficult to remember how complex they are, when first encountering them. Adopt more complex tools when you have a good understanding of why your simpler tools are insufficient. 
&gt; Up until recently there was no JavaFX on mobile devices and arguably there still isn't, a team at Oracle open sourced a half baked JavaFX for iOS implementation that suffers greatly from the limitations mentioned above. Are they hinting at / aware of [Gluon Mobile](http://gluonhq.com/products/mobile/)?
[removed]
RoboVM back when it was written but the inherent technical limitations apply to Gluon just like they would apply to anything that depends on thousands of classes and a complex porting layer for a basic hello world.
Fragmented is an amazing podcast, can't recommend it enough 👌
Don't learn learn to be a "Java Programmer" in school ;) Focus on becoming a software developer/engineer whatever you want to call yourself.. Be language agnostic... When taking your classes in school do your coding assignments in multiple langues. Sure your class may use java but learn other langues too ;) In my current job my primary language is Java but on any given day I could end up writting/debugging in Java, javascript, pascal, perl, python. As far as what you should know? - Learn to use version control: svn/git - Learn design patterns and when to use them - Learn about product lifecycle development: agile/waterfall etc - Learn principles such as DRY, KISS etc - Learn how to review code and refactor - Learn how to write clean code. I highly reccomend the book Clean code. - Learn to test: unit, integration etc - Learn about CI. This will save your butt... - Learn regex and a tool such as grep. The product I work on is massive. It is split into many parts and nearly impossible to search the entire system by reading. Regex/grep make it easy to find things. - Learn a good IDE and what it can do for you - Learn to use a good programmers editor such as sublime, atom, notepad++ - Learn to learn
&gt;(full disclosure: I love java and think it's a great language) really? your post didn't give that away.
Memory. So so many indirections. And not to mention gc hiccups if you don’t be careful. 
&gt; Java is going to have a hard time justifying itself in the new cloud economy. Simply put, it has higher operational overheads and slower startup times I believe the module system and future JEPs will address this issue.
What about serverless makes Java undesirable? 
- Generics kinda suck - Bit of rot in the standard library, esp. with thread-safe and non-safe operations. Both can be worked around though.
From scratch, but using Jetty? As someone who created a new JVM web framework last year, I wish you luck. There's a lot of competition in this area.
The JVM was built for long runtimes. These serverless and cloud operations are built for fast turn around (turning servers on and off on demand). The long startup time and long time to optimize isn't going to play nice with this sort of environment.
Not totally false. Certainly for high amounts of mathematical operations, java isn't the best. However, I would argue that most code is not that. Java is fast for most code.
Nothing stops something like AWS Lambda from keeping a JVM alive for longer than a single request (and I believe that they do exactly that). I also suspect that if startup and hotspot-profiling-for-optimization becomes a bottleneck, someone will step in (Oracle, Amazon, Azul, etc...) to do better AOT optimizations or cache optimizations and metrics longer than a single invocation/process.
Is Java still worth learning or is it a dying language and better learn Go?
I agree. And honestly, I think (reading the tea leaves a bit) that is exactly what is going on right now. A part of Graal, for example, is about exposing hotspot to the outside world. Then a large part of Jigsaw was about controlling the size of the class path that is loaded for a given application.
Java is worth learning for the next decade. In the meantime learn node and go because they will make you a better programmer at the very least. Before the current round of competition there was .Net which didn't make Java irrelevant, but the Java ecosystem grew. 
Most other relevant languages have a feature that Java does not have. support for different paradigms (prolog), dynamic typing (c#, scripting languages), homoiconicity (lisp), better control over the machine (rust, c, cpp), better functional support (haskell and others). My most damning criticism of Java is that it does not offer anything special as a language and only shines because of its adoption, it's vms and it's ecosystem. 
Generics are terrible
I don't really understand the fuss people make about verbosity. I've been a java dev/trainer for 17yrs now and have never once been bothered or frustrated by verbosity.
Jetty is just used as a HTTP server, all the route handling etc is made from scratch. I know there is a lot of competition, but this project is mainly a great experimentation project for me! 
* Checked exceptions are mostly just a constant annoyance. Not much you can usually do about them, and often times the response is to catch and then let fail - so why catch in the first place? All the exceptions should probably be optional. I don't know of any other language that does this. * Interfacing with C/C++ code is pretty horrendous and high overhead. Java would have been much more successful in the scientific computing and ML space if this was easier and cheaper. 
Its verbosity compared to other languages like Kotlin and Swift
I write a lot of math heavy java code. While its not the best in this arena, its not as stark as you make it out to be. It really falls into a sub-set of non-memory bound math operations where Java can't fully keep up. I've even had my Java code come out faster than C++ implementations of the same algorithms. It really comes down to the specific math being done, and how much effort you want to put into writing your C/C++. 
I'd say one thing that makes java shine is it's standard library. I can't think of any other programing language which has as much functionality read-to-go. Its something that really shouldn't be much of a moat, others could easily expand their standard libraries - but none have done as good a job as Java has imho. 
Unless you want to give me union types, I'm going to go with the concept that checked exceptions are part of a static typing system. Otherwise the "return value" of a function is essentially impossible to know.
WTF, node will make you a better programmer ? I mean perhaps haskell, or list. but javascript and callback hell? seriously ?
How are checked exceptions related to return values? Function return type is completely unrelated. Perhaps you are thinking of something else? I'm referring to things like InterruptedException, which you have to put a try-catch around no-matter what, even if there often nothing you can really do about it. 
To be fair it's been years since I had to code in a simple text editor, but I don't remember it being too much of a pain even then. Getters and setters were a bit tedious I suppose... Bad devs and bad coding can make any language a pain to use! 😊
There are, no doubt, poorly designed APIs. My favorite is NumberFormatException in response to parsing a number from a string. 
Not being able to control memory. 
* type erasure * slow start up for the jvm That's just about it for me. It can be more verbose than something like scala (although that can be cut down in java with things like the immutables library), but go's recent popularity has shown that for some people more verbosity is desirable. So I don't consider that a valid criticism.
&gt; My most damning criticism of Java is that it does not offer anything special as a language and only shines because of its adoption, it's vms and it's ecosystem. Which is true mainly because of its age. The same can be said about most programming languages that old though.
Which is not a thing, in my opinion. With an IDE you can write java code just as fast as kotlin or swift. Reading it does not pose a bigger burden than the others. If it does, one needs to ... learn how to read then.
 Item item = new Item().withPrimaryKey("Id", 120).withString("Title", "Book 120 Title") .withString("ISBN", "120-1111111111") .withStringSet("Authors", new HashSet&lt;String&gt;(Arrays.asList("Author12", "Author22"))) .withNumber("Price", 20).withString("Dimensions", "8.5x11.0x.75").withNumber("PageCount", 500) .withBoolean("InPublication", false).withString("ProductCategory", "Book"); table.putItem(item); This is the stuff I'm talking about, this would be done with a object in JS removing at least half the text.
IMO Java is great for working in teams. It has inherent limits on the abstraction level that one can use, and this helps keep code readable with a relatively small context on a line-by-line level. This makes it easy to have a team where members have varied skill levels working on the same project. The wizards will write their whiz-bang fancy stuff, the rest will do the main effort of wiring things together.
The thing is, exceptions *are* part of what a method returns - they're even in the method signature. 
Exception are, but that has nothing to do with them being *checked* exceptions or not. 
Eh I think C# did exceptions better. I don’t miss Java’s exception handling icky-ness when working on .NET projects. Relying on exceptions to know the “return value” of a function feels like poor design. Even more so if it’s included in a public API.
&gt;That would be entirely a matter of implementation choices. Yes, but that's not what you said. You said any Java code would be slower than the same C++. That simply isn't true. The question is, if X is the maximum theoretical performance: How close can C++ and Java get to X, and how much effort does it take to get C++ and Java code within some percentage of X? For most general purpose code, I'd argue Java is easier to get near X. For mathy-code, I'd argue it becomes more of a toss-up depending on the specific nature of the problem, and how specifically closer to X you want to get. If you want to get within a percentage point, I would agree it's easier in C++ because it offers you more visibility and control over explicit details. But for a few percentage points, Java is still quite decent and can be faster than equivalent C++. 
I'd argue that the .net libs are much more comprehensive. 
Yeah, but formatting aside, that's clear as a bell. The "superfluous" text (my word) serves to delineate things nicely and thus makes it easier to grok. I for one find it more expressive (and I'm coding in JS 75% of the time so I'm well-versed in the alternative). I've always said that code doesn't have to look like CODE, and that's what many developers seem to want it to look like these days and I think it's going in the wrong direction. I'm not saying we need COBOL levels of verbosity, but Java has always seemed to strike the right balance, generally, and I'd suggest your example is a good... err... *example*... of that ;) 
That's a bad API, you could easily redesign that to be much, much shorter. No need for specific type-related words, no need for `new HashSet()...`(also, Guava and Java 9 solved this `Arrays.asList()` nonsense).
How come? They're amazing! And yes, sometimes, like once a year, I bump into erasure, but that's not very hard to work around, is it? For the 99% od the required behaviour, they work great!
Yup, this. [Project Valhalla](http://openjdk.java.net/projects/valhalla/) will be a revolution for us!
Yup, this. [Project Valhalla](http://openjdk.java.net/projects/valhalla/) will be a revolution for us!
&gt; Generics kinda suck In what way? I think they're great and work wonders 99% of the time. &gt; Bit of rot in the standard library, esp. with thread-safe and non-safe operations. Yeah, this. This is something we need to learn by heart, know what to use and what to avoid (HashTable, Vector, File, Date...). I hoped the module system would solve this by putting old stuff into `java.obsolete`, but alas, no such thing happened. At least now I'm hopeful they'll introduce a new `java2.util` etc. which would omit the bad parts and only have the good parts...
I'm with you on the idea and agree on the point but I think this style just takes it a little too far. Keep in mind that this is a super simple example, doing more complicated things makes the code super long and almost loses readability because of it.
Personally I find it like trying to read a 1000 page when the story could've been written into 250 pages. 
Nobody cares about ram now.. 
Type erasure is criminal. Also, the fact they don't work with value types is a major pain point.
you can’t split packages accross multiple modules.
value types will have generics...
Though Java has adoption across many platforms. You have a huge library with excellent cross platform support. I know that .Net is expanding on cross platform but it isn't as mature as Java's.
there is work being done on native interfacing through Project Panama.
Cold starts are definitely a problem on Lambda, but can be worked around satisfactorily for now. Supposedly JVM startup times are going to be vastly improved in Java 9 . The harder part is diagnosing/optimizing things like garbage collection. 
Could you explain why type erasure is an issue ?
Yes, that I would say is a valid criticism against Java :(
Exactly. In Java 9, you can write `Set.of("Author12", "Author22")`. Much better.
OK sure, but that's a different question really. The original question was _which_ libraries should a senior know, which really casts it as, "if you don't know XXXXX how can you be a senior??"
I worked with Java some years ago, and figured out techniques to go around these issues you list here. Mapped buffers for big data blocks (that need to be sent to the GPU), the Unsafe for buffer access without bounds checks, ThreadLocal objects to avoid object allocation and garbage collection, usage of arrays of primitives instead of objects for cache coherency. I did benchmarks then, and these techniques really helped. Now i've come back to Java, and i found that the above techniques are not more needed, are not worth it, or are actually hurting performance, since they prevent the optimizer doing its job properly. The scale has changed and "big data", where some special treatment is needed to be efficient has gone up too. So its more acceptable to just let Java (the JVM) do its job and optimize the program as sees fit, and not worry that much about the underlying stuff. 
You know, I didn't really consider Java lambdas. 
I think the common argument against generics in Java is usually about type erasure. While this is a valid concern, I think it can be blown up a bit. For me, generics (and the java type system in general) are fairly restrictive compared to other languages. For example, we lack higher kinded types which is a real pain point for me. In addition, the lack of a true top type (caused by the division between primitives and object types) can be fairly annoying. This is being addressed with generic specialization in Project Valhalla, but it's a band aid rather than a real comprehensive fix in my opinion. 
I think a standard Try monad would work for most of my uses, but you are right without union types even this falls apart if your method can throw multiple exceptions. 
To reply to your verbosity comments, both are being solved soon! Implicit typing is coming very soon (March) with java 10 and data classes are making there way along too (although there is not a set target for them yet as far as I know)
By "modules" you mean Java 9 modules, not maven modules nor some other abstraction called "modules"?
One word: null
correct.
You can't do squat in a simple editor like VIM or sublime. When I program in Python/Django I can get setup and moving super quickly without much fuss. However, Java essentially *needs* an IDE to get work done.
&gt;To be fair it's been years since I had to code in a simple text editor This is javas biggest issue. You can't get much done in a editor. Imagine working on a construction project where you needed a crane to move a pale.
- Checked exceptions. Violates the dependency inversion principle. - Startup time. You don't write quick command line tools in Java because starting the JVM is nontrivial. - Developer startup time. Teach a junior "Hello World" and you get "What's 'public'? What's 'static'? What's 'void'? Why are we calling 'System'? Why does main have a String[] parameter when I'm not giving any arguments?". I guess this ties in to verbosity. - Shoehorned functional programming. - IDE lock-in. You either write Java in an IDE or you're lying. I can't think of another language I need an IDE to be productive in. - Publishing libraries to central repositories is painful. - Packages. Poor man's namespace/module. - Methods (functions) are second-class citizens. - IO. Bet you don't know how to read a File as a String without googling it first.
Some of the devs I’ve seen are my main criticism against java. It’s like companies will hire anyone who can explain overriding and overloading. 
`Optional`? I wish they had implemented it as an algebraic data type, but it still gets the job done as it is.
As a language, Java is missing much. But I’m a C# guy really, which just did it better. Events, lambdas, properties, generics, all of that. I don’t plan on using Java again, I’ve switched to Kotlin. (When I’m not using C# or Swift). The JVM tho, that is an engineering marvel. I really love the JVM and the versatility of it
It basically leads to cases where you can have type-related run-time errors which you would have expected to have caught at compile-time. To be fair, this is really an issue with the JVM, not the language. The oracle docs have a one example &gt; [Sometimes type erasure causes a situation that you may not have anticipated](https://docs.oracle.com/javase/tutorial/java/generics/bridgeMethods.html)
A non-evolving standard library. In the name of backwards compatibility, a lot of crap APIs are retained in standard library and it always requires a google research between standard library, google guova, apache-lang to decide the correct class to use for a particular purpose. Other languages like python have a clear plan for deprecation and removal. This helps to keep the language nice and clean.
A function with Optional return type can still return null. As far as I know there is no way to tell the compiler “I want to this build to fail unless you can prove statically at compile time this function will never, ever return null for certain.”
Except programs are not stories they are technical documents. I prefer longer and exact technical docs over short and clever ones. 
Fair enough. Question is pretty low context, so I can see that angle now
Agreed. I hate to say it but, at least as long as I stay in web development, I likely won't take a job if it doesn't use C#. The language is just too amazing.
I know exactly what you mean. The workflow seems so much more solid than something like Java which seems to have loads of old crufts. LINQ is just fucking beautiful and nothing even touches it for mapreduce in any other language (except maaaybe Ruby). Another solid use of C#'s expressivity is Autofac. Specifically how it uses lambdas to produce really tidy configuration syntax.
It does require thinking about things a bit differently, yeah
[Project Lombok](https://projectlombok.org/) gets rid of a lot of the standard Java boilerplate. The language itself should have this, but at least there's something.
Implicit typing is icky. Otherwise seem like good points.
Example? Unless they make/made Optional a primitive it's still an object and 'null' is a valid return for any return type which is a subclass of Object. 
* Generics suck hard. They *should* have gone back and redone them, deprecating the original java.util.* collections section in favor of generified collections that actually worked. * I'm not a huge fan of non-object primitive types being a thing in object-oriented languages. They should have committed to the paradigm (though I realize there are memory considerations that caused this back in the day, and it's an early design decision we're stuck with now). * There is an unwillingness to clean out the default libraries. There is a *lot* of extra, unused, and depreciated stuff in there that people *will* trip over. * There is no means of doing properties correctly in standard Java: we have to use getters and setters, adding a fuckton of boilerplate to the language for very little value. * The standard library is too fond of checked exceptions. Some things really should be runtime errors.
num 2 -- not the purpose of the language num 3 -- verbosity, C based, and some people shouldn't be programmers num 4 -- it's a freakin *Object-Oriented programming language*, not sure why there should be any functional programming in there num 5 -- what do you see as things you need the IDE for? num 6 -- no context. how does the language have anything to do with publishing to a repository? num 8 -- definitely annoying on occasion num 9 -- pretty sure that's always true unless you have syntactic sugar by default. 
* support for different paradigms (prolog), This was not seen as particularly valuable in 1991, for whatever reason. * dynamic typing (c#, scripting languages) Isn't always a feature you want. Try maintaining a large codebase in a dynamically typed system. (C#'s dynamic type--as this is /r/java, and not everybody here may know, `dynamic` is a type in C#, mostly to allow for clean interfacing between C# and scripting languages, particularly Javascript and Python--is not the wild eyed support that you might expect from saying that C# is dynamically typed (it isn't). * homoiconicity (lisp) Is mostly useful in Lisp and other languages with a history and necessity of metaprogramming. Most languages don't bother with this kind of feature these days. * better control over the machine (rust, c, cpp) This was sacrificed for the core promise of Java: write once, run everywhere. (Did that promise come true? No. But that was the promise, and making efforts to live up to that promise meant not having direct machine control.) The early success of Java is entirely predicated on that promise. * better functional support (haskell and others) Again, product of 1991, when functional programming wasn't on the radar outside of the affictionados of Caml and Lisp. Hell, pipelines were barely a thing in consumer hardware. Multithreading was so far ahead of everybody that most of functional programming's features weren't relevant yet. Should this have gotten better? Yes. C# does a better job of incorporating functional features. * My most damning criticism of Java is that it does not offer anything special as a language and **only shines because of its adoption, it's vms and it's ecosystem.** And yet, that's exactly why it's succeeded. It did a good enough job at being universally available in the early days before server hardware and software infrastructure standardized on Linux on x86. The JVM is a highly portable platform in and of itself. And that encouraged one hell of an ecosystem to develop. The things you brush off here are key to Java's success.
&gt; 'null' is a valid return for any return type which is a subclass of Object. Exactly. That is a huge problem with Java. All user-defined types being nullable is bad.
When you parse a string as a number: either you get a number or an exception. Sure you "throw" exceptions and "return" values, but that's a somewhat artificial separation between the happy path and the sad path.
Couldn't have said it any better :) Also: ```List&lt;Integer&gt; foo = Collections.emptyList(); ``` works fine. ```foo(Collections.emptyList()); ``` doesn't (with ```void foo(List&lt;Integer&gt; v)```)
I haven’t said anything about that? I’m talking about checked vs unchecked exceptions. There is nothing technical that mandates the existence of checked exceptions 
It's just a bit inconsistent - many standard implementations aren't thread-safe, and it's not obvious which one's are and aren't, unless you read the documentation. 
Probably. I find that the extra control would really be needed for things where you need every ounce of performance you can get. 
Go back late enough and you'll find that they're way more efficient than Java. 
Not OP, but it's a pain to deal with. 
Node js? Not too familiar, why would you recommend it? 
Thank you so much
Any language compiled to machine code will be more efficient than one running in a VM, no matter how optimized the JIT would be. That's not even a matter of discussion. Whether or not the benefits you're getting are worth it, is a different matter. Sometimes it's worth it, sometimes it isnt.
&gt; (full disclosure: I love java and think it's a great language) this is this guy's first (and only) post in /r/java we need to stop enabling this sort of troll - he's never asked a question about java, never helped answer a question about java, never added value to the community. and his first post in the subreddit is a backhanded attack on the language. and we get this every week or two, and we keep upvoting it the question itself is a false equivalency, and is just bad, doesn't meet the subreddit posting requirements and doesn't belong in the subreddit 
This is why I think it has such high industry adoption. It's harder to make an abhorent mess in java when working in large teams. 
You are right. This is my first post to this subreddit, but it's not a troll post. I really do love java. I think it's an extremely mature language and ecosystem that's constantly being innovated. However I only have 5 years of experience in the industry, most of that being Java, and I wanted to know where javas real pain points were. There is a difference between attacking Java and being overly critical, and being self aware enough to give the language a fair introspection. 
Read up on Hindley-Milner. Languages that use the type inference that stems from that method are really cool and some are VERY strict.
Weird. Someone should have told me this earlier. I use sublime all the time for java...
I wouldn't gloss over the VMs or the ecosystem like that. The VM is well-understood and battle-hardened, and the way Maven/Gradle make dependency management a first-class part of the build toolchain is something other ecosystems still haven't managed to do. NuGet was just a nightmare when I tried to go back to C#. JS and Python and Ruby have system-level dependency management that's just way too easy to mess up.
I'd rather use static typing. Why waste any time making the computer figure it out?
I think I can spare a few ms every time the ide saves.
You can never be sure if a return value from a method call is 100% non-null. Sometimes it's not, it's NPE instead...
But your untyped JS object will easily break when someone else casually edits the code in a simple editor. Sure there’s always an alternative to Java, but simply using something more terse as an argument is something I never understand. Terse solutions (IMHO) are usually bad for long term maintenance in a team oriented environment with varying degrees of capabilities... I get people don’t want to fire up a full blown IDE to make a quick change, but if your target thing can be simply changed with a text editor then we’re probably not talking about production grade stuff that was delivered through a proper SDLC pipeline, so you’re probably not using Java in that scenario anyway 
If you write your own code I think you can be pretty darn sure, just don't return nulls.
wtf, bot!
*Beep boop*, I am a bot, *darn it*.
Hey guys I have a question for those of you that learned Java. I had a job interview the other day and they said i would have to know Java. I have a computer information systems degree and did a little bit of programming. My question would be how do i got about learning Java? How long will it take me to learn? (I know thats a relative question) and when does one call themselves proficient in java? Thanks!
type inference is still static typing, it just means that the compiler infers it at compile time instead of you typing it out. why do i have to say that x is a string in `String x = "foo";`? String is the only possible type so why not have the compiler infer that and save me the time writing out the type?
Java should be faster than node in most conditions. The main performance advantage of node is that the ecosystem provides async apis for essentially all blocking IO calls. Because node is single threaded, async IO is mandatory to prevent your application from dosing itself. Java on the other hand has excellent concurrency, supporting a wide range of concurrency models. The consequence of that being that developers tend to just use more threads rather than using async IO. The overhead of having so many threads can start to add up as ypu do many requests per second. Java does offer decent async IO support and therea lots of libaries that assist with it, But its not really a first class citizen like it is in node. The main performance benefit of java over node is that you can use concurrency. 
the "question" that you've asked is the equivalent of "have you stopped beating your wife ?" you can use verbage that's productive and respectful if you're really interested in a discussion (though even that probably belongs in /r/javahelp, not here) explain what you're trying to do, ask what the tradeoffs are &gt; give the language a fair introspection if you look at my comment history on this subreddit you'll see i'm far from above criticizing the language and virtual machine (the inlining problem is my personal favorite). but as you've written the question (in the context of your lack of posting history) is a troll 
Checked exceptions. One of the main reasons why I felt liberated when I switched to kotlin. Also, compile-time type-inference Is a feature that's hard for me to let go, as every other language I've used in recent times has it. I know it's gonna be solved rather soon, and for that I'm thankful. Another missing feature is, in my opinion, a standard unit-testing library. Including the JUnit jar in every single one of my project seems just a tad silly. Oh, and let's not forget about JSON. It's about time that there will be a a place in the standard library for that. 
There are alternatives, e.g. [Rust has Result&lt;T, E&gt;](https://doc.rust-lang.org/std/result/) to tell normal and an errorneous output apart. It has [None](https://doc.rust-lang.org/std/option/enum.Option.html) to indicate absent values, but the compiler won't allow you to assign it to whatever reference you have. I believe there are couple more languages with similar features.
Default values are kinda lame. I hope this feature is not going to be present in java too. If put an arg for a function, you need it. If you need to use default ones, overloading should be the way.
I don't code in Rust myself, but if you get a Result back don't you still need to check whether the result is okay? How is it different than &gt; SomeClass result; &gt; if( (result = testFunc() ) == null ) result = dummyobject; or defining some Result object yourself? &gt; Result&lt;Boolean, Integer&gt; r = doWork(Type...someVars); &gt; &gt; if( r.ok() ) { &gt; doSomething( Result.payload ); &gt; }
I don't code in Rust myself, but if you get a Result back don't you still need to check whether the result is okay? How is it different than &gt; SomeClass result; &gt; if( (result = testFunc() ) == null ) result = dummyobject; or defining some Result object yourself? &gt; Result&lt;Boolean, Integer&gt; r = doWork(Type...someVars); &gt; &gt; if( r.ok() ) { &gt; doSomething( Result.payload ); &gt; } Is Rust wrapping functions all the time or is just a standard library type that's useful here?
So on one hand you want to make arguments optional if they are null and on the other, you want the ability to specify null by omission. 
Your arguments sound like you're a Scala fan. I disliked Scala's type inference, because people kept using it which meant I often had to chase down compiler bugs 4 classes away. It opens a can of worms when it comes to encapsulation. I also dislike optional being a language default. Generally speaking, I dislike objects as defaults if we can get away without it. Strings and arrays are exceptions which also introduce a number of counterintuitive facts in the language.
Can you elaborate on the speed argument? I know Java is technically fast, but that complaint has to stem from somewhere for it to be so commonly brought up. From what I understand with my terrible programming experience, Java has a bad garbage collector that can cause stuttering in some video games and that leads to it being "slow" to some.
A better case would be **not** Optional. Sure, Optional works if you can accept a missing parameter, but what about cases where you're sure you **can't** accept a null parameter? Any situation where a function can take or return an object could be null. Not only that, but the language can't easily change to fix this without breaking backwards compatibility with any third party library of a prior Java version. 
&gt; As we see movements like serverless starting to take off, there's not a place for Java in that environment. If you had some experience with AWS lambda for example you would've known those systems keep them loaded. So the 'start up' of something like 1 second you'll only have the first time that particular instance is called.
&gt; Nothing stops something like AWS Lambda from keeping a JVM alive for longer than a single request (and I believe that they do exactly that). They do. Which is incredibly evident to anyone actually using it. So I'm pretty darn annoyed with people spouting uninformed nonsense (not you, people you're responding to).
What a *darn* shame.. *** ^^Darn ^^Counter: ^^298
Legacy: many improvements are being held back or curbed by the original design of the language and the api. 
Sure, in JS you could just write something like this: var item = { "Id": 120, "Title": "Book 120 Title", "ISBN": "120-1111111111", "Authors": ["Author12", "Author22"], "Price": 20, "Dimensions": "8.5x11.0x.75", "PageCount": 500, "InPublication": false, "ProductCategory": "Book" } Now lets say that we want to refactor our code to add validation logic to all of those fields. Like, `Price` and `PageCount` cannot be negative, `Dimensions` must be in inches, "ProductCategory" can only be one of 5 predefined categories, and so on. And we want to do that without changing a single line of already written code outside of the Item class itself. Good luck.
I don't know if I agree with this analogy, having any current, free Ide is not difficult or even that demanding on the system. and once you have the code base, you can easily make quick edits in vim or something similar.
I agree with this: &gt; and we get this every week or two, and we keep upvoting it However, for once the question was very fairly worded and didn't seem to me like an attack at all (unlike some others before it). But yes, it's been a while that we get "Things you don't like in Java" threads every other week, and surprisingly nobody points to the last one, everybody keeps commenting the same points over and over again. It's good for venting, I guess.
Do you maybe have a respected / legitimate research to link for the java speed claim, that it's not slow any more? I just want to have a proper source the next time I'm assaulted by other webdevs for liking java.
Yeah haha definitely don't do that. I've suggested it before on this sub, but intellij community edition is awesome.
Whys it's lame? Many cases of function overloading could be replaced by default parameters.
I'm not sure about Rust specifically, but typically for wrappers of that kind the code wouldn't compile if you didn't address one of the paths for an ATD, so you feel nice and cozy and NPE-free.
Because that is the opposite goal of modules. Modules are to use multiple packages, while hiding the ones intended for internal implementation, not the other way around.
Well, there are languages with dependent types.
What video games are you having an issue with? I've found that with the right tuning I can generally avoid full GCs while playing minecraft. The main issue with java and videogames IMO is that people dont tune the GC very well for the application or they use programming models best suited for REST apis in their game code.
Actually they could have done better with the on-object primitive types, it would be enough to follow Eiffel's lead on it. In Eiffel, it is like Kotlin and Scala behave. Basically everything is an object, and the right representation is choosen. It also helps that Eiffel has value types, so something like an Integer class is an *expanded* class that maps into the right register size.
Java is compiled to machine code, it would help not to mix languages and implementations. https://www.excelsiorjet.com/ https://github.com/oracle/graal/tree/master/substratevm Just two examples, there are others to choose from.
`ConcurrentHashMap&lt;String, Nullable&lt;Foo&gt;&gt; varName = new ConcurrentHashMap&lt;String, Nullable&lt;Foo&gt;&gt;();`
Type erasure is something I crash into practically every time I want to do something non-trivial with generics. I don't think it is "blown up", and it really is a major wart in the language—on the other hand, it is warts like these that have enabled Java's amazing backward compatibility.
Once upon a time I believed this was an advantage of Java. Java is a "simple language", or so they said. Sure, on the surface level this may be true. But now, knowing a lot more non-beginner stuff, I'm no longer sure Java is actually "simple". 
minecraft is terribly coded and dosent even let the GC do its thing on its own. there is a ton of manual GC calls which slow the game down a bunch. there was a forum post by the guy that made optifine some years ago that went more in depth with the issues
Can you elaborate on what you mean by "weak" module system and "basic" generics? I think use-site generics aren't all that "basic", although I agree that they're somewhat limited by type-erasure and there not being any higher-kinded generics.
But it does. Checked exceptions are mandatory as part of the method signature.
I'm still split on checked exceptions. To me, the biggest downside of checked Exceptions in Java is that they don't play nice with lambdas.
Sadly I only got to use the books and papers, EiffelStudio was out of my league back then, and most likely what killed mainstream adoption, leaving it for enterprise and high integrity computing. So I can't tell if it helped or not. At least now there is a free license for open source projects, guess I need to play around with it. 
This has been fixed in Java 8, and `foo(Collections.emptyList());` works fine now, too.
Last I tried the IDE (3 years ago?) it was still buggy, crashed and had some very unusual UI choices. Incremental compilation would sometimes fail mysteriously, create huge temp files and the compiler's idea of reporting syntax error was often "syntax error". I think the language has some fine ideas, but the tooling is simply unreliable and behind the times. Especially considering that you need to pay for this in a non-open source setting.
This mostly boils down to "Java is fully backwards-compatible". While backwards-compatibility is huge for some settings, it imposes significant limitations, and essentially cements past mistakes forever. I truly believe they should have decided to re-launch Java around version 5/6, ditching most backwards-compatibility in favor of modern concepts and fixing past mistakes (similar to how .Net 2.0 wasn't backwards-compatible with .Net 1.0/1.1, but fixed a lot of things). 
Ah, my favorite topic. Explaining the Java Language by looking at the implementation...
&gt; IDE lock-in. You either write Java in an IDE or you're lying. I can't think of another language I need an IDE to be productive in I cannot think of a single real-world language (one of the top 20 in TIOBE is a reasonable definition, but I mostly want to exclude things like Piet and Brainfuck) in which I wouldn't be immensely more productive using an IDE. Sure, I can write Python using vim alone, but using Spyder or PyCharm would save so much time and effort I really don't see the point (unless I'm writing a really short script, in which case Java wouldn't be my first choice due to other arguments you've raised - VM startup time and developer startup time). 
The difference is that in Java the compiler is not enforcing explicit handling of all cases while in Rust skipping the None case (precisely what you wrote in your example) is a compile time error. That's the point /u/IHireWriters stated in top of this comment thread. Of course, you can theoretically achieve the same "non-null" safety if you meticulously write null checks everywhere but nobody does that in practice. I saw a proposal for non-nullable reference types in C# and I think it would be nice to have it in Java too.
&gt; even if there often nothing you can really do about it **You** don't do anything about it. Other programmers may want to stop their own thread that was interrupted, verify state of variables shared between threads, maybe close some resources because application is closing and interrupted your sleeping thread to let you know about it. Java prefers to remind programmers there's something to take care of, rather than rely on the fact that they'll remember (they won't).
That's your formatting. Few lines more for better readability: Item item = new Item() .withPrimaryKey("Id", 120) .withString("Title", "Book 120 Title") .withString("ISBN", "120-1111111111") .withStringSet("Authors", new HashSet&lt;String&gt;(Arrays.asList("Author12", "Author22"))) .withNumber("Price", 20) .withString("Dimensions", "8.5x11.0x.75") .withNumber("PageCount", 500) .withBoolean("InPublication", false) .withString("ProductCategory", "Book"); table.putItem(item); In real life most of the values would be some variables or constants and authors would probably be already in form of some collection rather than 2 separate strings.
Java language or JVM? I'd like some lower level features. For example if Java has some kind of bare memory structs and type casting (maybe with some @IKnowItsUnsafe annotations). If we compare c++ implementation with java, often c++ will just cast a pointer to array, java has to do some manual work, implying array copy (for example, think about readAllBytes, you end up with byte[] array and now what?..). Also I'd like a way to reference class members in annotations for type safety. Now it's often done with a string. OpenJDK/JVM - I don't like that it's such a memory hog (not sure which of them). Think about small apps/batches. Or do you remember azureus/vuze? Then utorrent came and it was so small/sweet.. If a small Java app used 5 times less memory, it would still be like 10 times more than a basic luajit app.. (yes times, not %cents) And it's also hard to estimate exact memory limit. And if you run your java program in a small cron batch, it would probably be slow, because it will end before it warms up. Maybe JIT will still do something, but forget about near c++ speed.
Huh, I was pretty sure I was replying to a different comment, no idea how this ended up here. * Generics do kinda suck; reification and value types should help (when they land) * Lots of cruft left in the standard library over the last 20 years. * I just assume everything is non-thread safe.
One that comes to me is StringBuffer and StringBuilder.
Spring boot + a front-end in React/Vue(or Angular, if that ever comes up for me). Takes like 1 minute to set up, zero configuration and it's straight on to developing. Very enjoyable compared to the configuration hell you can end up with in other languages/frameworks. 
Java is still a fair language despite all valid weak points it presents. Do you remember those ruby boys aggressively criticizing Java for not having all those kool aid Ruby have? Well, look at Ruby now, just a few still care about it, and Java is pretty well.
I would go far as saying it's easier to read Java because of its verbosity.
I genuinely feel like Maven/Gradle is one of the most underrated parts of Java. Dependencies just aren't really an issue unless your overlapping versions of the same dependency.
So,basically web development right? 
Well, specifically, webdevelopment with the MVC framework using Spring Boot on the backend and exposing it via REST to a View-layer in the forms of React/vue. Yes. :) 
In the same boat now but with Angular as our front end and Websphere as our app server. I'd much rather go with the Tomcat servlet container but we developers lost that fight with management. 
You can’t pass a function pointer as a method parameter like in C, you have to wrap it in a lambda or anonymous function
My condolences
Functions being second class citizens is really painful after using other languages that treat functions as first class. I must say though that multithreading in Java is a lot more pleasant than a lot of other languages 
But you have `obj::method` and `Class::method`. Doesn't this make them essentially first-class?
For me it is that language development is slow and mostly misguided. I understand that they don't want break backwards compatibility but it is used as an excuse to not change or add features to the language. Even if these features could be implemented in backwards compatible ways. And when new features are implemented they are intuitive at best and useless at worst. Examples: #Functions What java calls functions is actually just a shorthand to create anonymous-inner-classes that implement interfaces with only one method on them. These where hacks used to emulate functions. besides the lambda and method reference syntax it's business as usual. Functions still aren't first class, we only have the `Function` interface, that in itself is nothing special. Atop of that javas type inference is just not powerful enough to support any real functional programming. You have to cast and add explicit types everywhere. Even if you get it to work you are stuck with unreadable type signatures. And don't get me started on generic methods. #Modules A module system would be cool. You could validate that all required modules are present on startup and have a way to encapsulate code further. Unfortunately one of the biggest causes for dependency conflicts are version conflicts which the java 9 module system doesn't address at all. Even the encapsulation is kind of useless, since reflection is so pervasive that you have to turn the encapsulation mechanism of on any realwolrd system. #OOP Writing classes is a pain. * Getters|Setters have to be written by hand even though there is only one way to write them. * `equals`|`hashCode`|`toString` have to be written by hand even though even though there are sensible defaults. * Constructors that only assign their arguments to fields have to be written by hand. * inherits Stuff from Object that is useless to harmful: `clone`, `finalize`, `wait`, `notify`. * primitive values aren't Objects. The first three points can be fixed by something like project lombok but they should be part of the language itself. #Core Library The core library is a kitchen sink the size of a football field. There is rot everywhere. Again, this stuff reaches from useless (e.g. CORBA) to actively harmful (e.g. Serialization). There are attempts at splitting these parts of off the core library in java 9 and making it more modular but I didn't have time to look at it yet. Hopefully these kinds of issues are resolved by it. #Concurrency It's so easy to shoot yourself in the foot using anything that has to do with thread based concurrency and mutable state. You have to use arcane design patterns when dealing with concurrency like Double-checked locking. Testing is also pretty hard. This isn't a problem with java alone though, many languages have the same problems since most only provide a somewhat thin layer above OS concurrency mechanisms. That said there are more user friendly ways of dealing with concurrency than threads. Luckily some of these can be expressed as libraries so java is capable of using other concurrency paradigms. The native java approach is threads though and the associated APIs have the same problems as everything else in the core libarary.
What do you mean by high overhead in c/c++ interfacing? I've always delegated performance critical code to a JNI layer without any memory / CPU performance degradation.
What choice do you have instead? Pass a large parameter object? You'll have to define the fields anyway at some point. I guess something like C# autoproperties would somewhat reduce boilerplate, but writing .setX( ) not that different from .X = .
Local type inference is good. But I agree types should stay specified in full in method signatures.
One of the best things about Java is a strong emphasis on backwards compatibility. But a side effect of that is some issues remain unfixed for years. Some have already pointed to Generics. I like to point to Lambdas. They do not work nicely with checked exceptions. Especially with collection streams APIs. And, this is not exclusive to Java, but nulls. :(
The difference is the that Option types are rare enough that the compiler can make sure that you always check if a value is present before you use it. When every single value is potentially null, the compiler can't enforce a check for null without driving programmers insane because you would need to check every single parameter in every single method before you use it and check the return value of every method before you use it.
Java is WORA. Almost no other languages are. All non trivial Ruby and Node apps, for example, depend on libraries that depend on native code.
Because man, everyone who can Main Strijg Args calls themselves a Java Dev. I used to work with a Senior Dev who didn’t even know what a class was. 
What are your thoughts on Scala? It seems based on all your arguments, Scala answers them except the enforced nullability. 
Try the Checker framework. https://checkerframework.org/
What? RAM is more expensive than it has been for a LONG time.
PDFs. I've been working for an open source PDF library for the past 5-6 years now.
&gt; Is there any circumstances where java backend is faster than a node one? All of them.
Complex data structures and audio processors.
&gt; Java has a bad garbage collector that can cause stuttering in some video games and that leads to it being "slow" to some. Java has excellent garbage collector, and games are not stuttering because of Java, they're stuttering because they're poorly written.
Paid work is industrial controls. Hobby time is bringing VT100 / BBS-era stuff into the modern age.
I don't know, and thats the issue. The problem is that the language can be very verbose and sometimes it's good but other times it's not.
In days of old, the garbage collection wasn't the best... and that was an issue at times. The gc pause was noticeable in some heavy applications (particularly in the applets - where people saw Java the most and it was also the most constrained). There were other slow things that were around until Java 1.5. Many of the data structures in 1.4 and prior were synchronized by default. Vector, HashTable, StringBuffer. Every call to them was synchronized. I suspect the early design ideas was "threads everywhere sharing memory" - which isn't how most Java applications turned out to run. That synchronization call has an overhead... and it was being paid everywhere. So with 1.5 the revamp of many classes (and the entire [collections framework](https://docs.oracle.com/javase/7/docs/technotes/guides/collections/changes5.html) rework) made things better. Note also that there are many more types of collections with 1.5 that may better suit the BigO for what type of access you want that wasn't there before as part of the core library... so everyone used Vector even when it wasn't the best choice. And then there was the IO. If you go *way* back, you'll find things like [Articles: Tuning Java I/O Performance](http://www.oracle.com/technetwork/articles/javase/perftuning-137844.html). There was an entire black art to IO performance tuning and most people ignored it... so they wrote slow code. There are other things that are... less than ideal practices (like using throw as a control structure (try a named label and break instead)... which then has to package up the entire stack trace to attach to it) that can contribute to slow code.
Consulting using the Java and .NET stacks. Everything from frontend, backend, web and mobile, depending on the customer. Focus on telecomunications and life sciences domains.
Healthcare, just another world of standards everyone has their own take on. Also a common theme: throwing technology standards at a problem hoping it solves organizational issues.
I love me some Maven enforcer plugin.
Fullstack developer
Absolutely agreed. Usually we try to hide the excessive verbosity behind API, but that still means someone at some level will have to write al that so it can be less verbose elsewhere. In the given example one could replace Item with a BookItem which would do something like withId(int), withTitle(String), etc.
&gt; And not to mention gc hiccups if you don’t be careful. Please elaborate with an example. 
What should a method like Integer.parseInt( String s) do instead if it can't parse the passed in string as an Integer? I find NFE annoying af too, but I don't know what an alternative would be. A method like "Integer.isParseable(String s)" would be nice, but that wouldn't prevent Integer.parseInt(String s) from receiving an unparseable string.
Case in point: A typical stateless Spring Boot service runs fine with 512mb of RAM (often fine with less). The constraint for me always came out to be the CPU or Networking because a Spring Boot service could oftentimes run 100+ requests per second and peg the CPU before RAM became a problem (assuming you don't have memory leaks or heavy in-memory caching happening). 
Oh, gotcha. Misread that. It is definitely handy to have more of these convenience functions. 
Naaah. Of these features only the custom blocks would require huge changes. Other features are completely reasonable and already available in C#, JavaScript, Kotlin, or C++.
JavaEE backend + Angular frontend. Basically web apps for the government. We've been using a custom JavaEE framework, but we're trying to move to VertX because the company is building a Kubernetes-based private cloud 
Union Types would handle such cases. They will never be part of Java, though :(
Don’t call ‘em microservices. They aren’t microservices. But they have a lot in common with microservices. I’m using JAX-RS for this shit. Alas, the version o java we’re using does not have JSON object support natively. That would be nice. 
I love how Typescript handles this. You just declare an interface and then turn your objects into instances of the interface. Someone even built a function called tassign. It works like Object.assing, but validates the names and types of both sides at compile time.
How to you use the front-end framework with Spring MVC? All the front-end examples I've seen in React or Vue just use straight REST services, which doesn't seem to line up with Spring MVC?
Link? 
Hmm. I use MVC as an architecture - for the web app itself, it's just spring boot serving an index.html file as a starting point. Spring MVC is huge and I've never worked with it. Sorry if my comment was confusing :) 
&gt; we developers lost that fight with management Serious question: why does management care?
Ok. But C++ *is* a monstrosity, JavaScript is an untyped mess, C# works reasonably only on Windows, and Kotlin isn’t used much yet
A game server developer. Working with networking, game logic, databases, server platform, performance tuning etc...
Aws deployment framework using SWF
Do you have a couple examples of these times? I can think of very few cases for me where type erausre was a big problem for me. 
Java rest API servers for gambling
Don't want to seem like I'm advertising, so I'll just tell which one it is: iText.
Can you be a little less specific? :)
I use Angular $routeProvider to hit the REST routes. 
Can you use ObjectMapper from jackson? 
Java has long been much faster than JavaScript, but recent improvements in JS engines means that some sources will show them as being fairly equal. A real world sizable business app is likely to be much faster in Java, because of some JIT compilation advantages from type safety etc. 
Error 404: javax.servlet.ServletException: java.io.FileNotFoundException: SRVE0190E: File not found: /guides/docker is very eloquent :)
Thanks for the reply. I also do some frontend stuff, so I've used npm and yarn, how do they solve it "a lot better"? Sure, I agree, C++ templates are much more powerful. However, they're kind of a different beast. For one, because specializations are generated on-demand and currently seem to come at the cost of having to forgo separate compilation. In Java, it's compiled once, there is no specialization. Thus, separate compilation is easy. I'm told that they're trying to add modules to C++ which should deal with some? of the pain points of excruciating compile times due to changes in template headers, but I'm no C++ programmer. C++'s templates seem more like fancy structural subtyping by employing code generation, Java's generics OTOH are still subject to nominal subtyping. 
Nobody mentioned Play framework? 
What do you do exactly?
Mobile games. Currently in gambling industry working on 3D and VR libraries (GWT, WebGL, WebVR)
Bridging the Java and SQL languages.
Business apps with Spring, REST services, and weird stuff once in a while like JMS queues. Also JSF. We tend to have massively complex databases.
A fair complaint - but my experience has been that all the other installers were far "hackier". Now... If the JRE would validate JAR signatures, and allow Pack200 to live on the classpath when invoked from the command line, we'd be a lot closer to not needing JNLP.
Well some things are just easier with sublime. I use eclipse most of the time ;)
Good link: https://openliberty.io/guides/docker.html
This is irrelevant. I want the nice features from them, not their faults, quite obviously. C++ is a monstrosity because of C compatibility and template metaprogramming. I want none of those. JavaScript is an untyped mess because it can *only* be used untyped. I want a strongly typed language with the option to go dynamic when necessary. Same with null safety and mutability. Sure, C# and .NET started with Windows exclusivity, yet made huge strides multiplatform compatibility. Obviously I want a language that is fully multiplatform. Kotlin is nice but still subject to JVM limitations. I want to extend JVM at least by value types and proper generics. CLR is a role model to follow.
Right there with you, and stuck trying to combine legacy with the latest to add to the confusion. Mostly just CDA and FHIR at the moment, but of course that is subject to change tomorrow. 
Personally I prefer a function with the values it needs.... Others prefer "a functional style" like Python. :)
Consultant. Intranet Android development connected to a back end system from IBM. Backend is Java/Webphere/Oracle. Done dozens of projects across North America over last decade. Customers are powerplants, oil extraction, oil refineries, governments etc.
Cliff Click has been posting podcasts lately to his [blog](http://cliffc.org/blog/) in lieu of actual blog posts. I've been enjoying them very much. While his topic list is somewhat scattered, many are at least somewhat Java/JVM related (which makes sense, given his history).
In office - web development with Spring MVC,Spring Integration to mainframe and angular for UI,@home working on machine learning with java, basically trying to create few libraries to help MI
So, apply some arbitrary values? If the constructor has a UUID field with a NonNull annotation, should it provide a random UUID? Not sure of the value of that approach.
For example you have to profile and tune up your gc knobs and switches if you want decent throughput and latency percentile. Log4j2 zero-garbage logger exists for a reason. Good caching solutions use off-heap memory for a reason. Value types are being worked on in JVM and Java for a reason. Object pooling has been notoriously famous. OTOH, there are some great ultra-low-pause gc's like C4, Shenandoah, zgc etc but they need loads of heap which brings us back to the memory usage issue.
&gt; Again, product of 1991 You know they are still doing releases right? Java doesn't HAVE to be stuck in the early 90s.
just reposting the headers; you might already know every technique: 1. stateless 2. no shared state 3. message passing 4. immutable state 5. `java.util.concurrent` 5. synchronized blocks 6. volatile fields 
Audio processors sounds interesting. For what kind of software? 
OK. On my current job I write only server side code using spring framework. And I never touch frontend code. One time I worked only with jsf frontend and sometimes write required changes in managed beans. For my own project I use my knowledge in all technologies for frontend and backend. 
Banking. Working as a backend developer using spring frameworks and JMS
Productionalized ML systems, currently mostly scala (spark and then play/akka for backend services to drive stuff and communicate with web apps/frontends). Prior to this gig I did similar stuff elsewhere (more datapipelining though). There we used Dropwizard for backend apis (in java) and some java for hadoop jobs (using cascading).
Honestly, template in C++ really sucks. You should look at SFINAE Debugging C++ template is absolutely awful. That's one of the main reasons I decided to abandon C++ in favor of Java. When I need a template with basic types I copy the class several times. This is rare and only few of my classes are generics. 
I work my company's RPC infrastructure (both in-house RPC framework + gRPC), including service discovery integration (Zookeeper based) and RPC libraries Basically boils down to running a few HA Java services built on top of our internal container framework, and integrating the Guice based RPC library into said framework
Woah, I really liked his podcast about self-esteem and salary negotiations. Definitely a good find, I'll be sure to check out his podcasts more. Thanks, mate.
I want a pony now!
Neat, I unfortunately still have to use jdk6 (for now).
Core microservices: things like enterprise access management, audit logging, notifications...
Applications that have to worry themselves about GC are probably niche and a _very_ small subset of applications. For the vast majority of apps default GC settings work just fine.
&gt; IDE lock-in. You either write Java in an IDE or you're lying. I write in Emacs. But when I started in 1999 it was joe. 
You can look at features of the jvm. You can get an overview about the various garbage collection techniques of the jvm. Also you can look into fine tuning the jvm. You can also explore utilities available in jdk like jvisualvm and java mission control. These will help you to manage and monitor an java application. You can look at jmx , in which these tools are based. Also knowing about concurrency in java should be a big plus. Also explore collection framework of java.
Your programming fundamentals are most important. We've hired java devs who have never written a line of java code before. If you have the basics, I recommend picking up a copy of Effective Java. The latest edition just came out and it does a great job of explaining the best way to use the language.
Wow, now how did that happen 😮
No commit history... That's just...
Banking sector. Building Web API's with an in-house corporate framework based on Spring and Jersey. Also connecting to SOAP services through EMS. And the accompanying AngularJS frondends.
do you pair program with a coworker who writes the else blocks?
Did you ever consider a viewer? The ones available out there are leaky / trash.
Marshaling bits between protocol buffer formats. Anybody else here who works at my company will know exactly what I'm talking about
In 2.92277266 × 10^11 years the apocalypse foretold by `ChronoUnit.FOREVER` will make the headlines.
Weather - ingestion and display of relevant data.
I work on language runtimes and most of the time on a JIT optimizing compiler.
cheminformatics
If you learn COBOL you can also get a nice job, but it doesn't mean it's worth learning (unless you just want a steady boring job that pays the bills).
That only happens because of the use of a "raw type" (`Node` instead of `Node&lt;Integer&gt;`), which *is* caught at compile time and gives a warning.
In one of the leaders of gambling industry. So... games like Roulette, Blackjack, Baccarat, Dragon Tiger, Poker games and so on (The live version of them: https://en.wikipedia.org/wiki/Online_casino#Live_dealer_casino_games). To add to it a lot of strange integrations and regulations go into the development also which adds a nice twist.
COBOL isn't even close to the ubiquity Java has. COBOL is slowly dying and Java is not dying any time soon. It's massive in enterprise gigs, and constant in the top three most popular languages on polls. If you're a back-end/services dev, Java is always good to know. And most developers will have a steady boring job that pays the bills, because they are not all starry eyed 20 year olds with aspirations to work at Google/Facebook.
sure, but they literally said value types will have generics, which you seemed to say the opposite of.
Low latency algo trading. I write the server and surrounding framework and provide APIs for Quants to write pricing code which can be run live or in backtest. It’s kinda fun - but it’s easy to feel that you are losing touch with the ‘mainstream’. E.g no microservices or VertX or SpringBoot or ............ Edit: examples 
Work on software for CNC machines. Front-end (GUI, user interaction, etc) is all done in Java, while motion and hardware are controlled in real time via C++ modules. We also automate a lot of stuff with scripts and have in-house tools that are typically done in C#. I typically work on the motion system and safety features. 
Surprised this has no responses. Trains how exactly? Scheduling? Control?
Yea, not really worth reading the article unless you're a beginner.
RuneScape. I contribute to two different unrelated 3rd party clients. One is an open source enhancement client that overlays additional information to the game screen. The other is an automation cheat client.
Why not use messaging, e.g., Kafka?
&gt; Union Types would handle such cases, How exactly would they do with without cluttering type declarations up with exception types: Union&lt;Integer, NumberFormatException&gt; r = Integer.parseInt(x); ?
I've worked on a few projects, including: - Path finding for a given schedule - incident management software - monitoring and controlling of trains It's really quite interesting work, even though a lot of the tech I work with is fairly old at this point. This stuff has long lifecycles.
Definitely interesting. Particularly the path finding/scheduling side of things, interesting that there's still work to be done there for a network as established at rail. Seems like the rail network (in mainland Europe at least) is hugely underutilized when we have so many trucks on the road.
Whiteboard interviews and finding hidden log n algorithms.
REST web services and database persistence.
Totally agree. There is no substitute for immediately seeing which datatype what variable is.
Huh cool
You can’t move something to another package without breaking backwards compatibility. Many items in the standard library - especially java.lang - use package level (default) access. Moving them to other places would cause problems with massive refactoring. The best thing is to finally say that HashTable, StringBuffer and the like are @Deprecated and have people start cleaning up old code. 
Are you from India?
Not knowing Java 8 at this stage is pretty inexcusable. Lambdas, streams and new networking tools are all very useful. Ultimately the experienced developers won't know the _language_ any more than any newbie, but they will know all about libraries available, when not to use them and how to deal with common problems. Assuming that you come from knowing nothing work on putting together a few example Spring apps from end2end. Figure out and observe where you mess up. Be happy to show code. Follow what IDE is suggesting you need to fix and figure out why. Some will suggest you look into gang of four and patterns. That's useful, but useless if you don't have enough knowledge to absorb the whys. In the end practical experience trumps all.
Data in Ad Tech. Processing hundreds of billions of messages every day, with about a petabyte of data per day going into just this system, but being able to call up every single interaction in detail. Handling staggering sustained growth in data volume. Tools: mainly hadoop and local POJO, gradually switching to spark as it improves. Techniques: finding ways to make the right code easy to write and incorrect code hard, while expressing things flexibly. Actions: actually, it's mainly the communication with other people in the organization. 
Well, trying to be brief: We've got three technical teams in iText: Support, Roadmap Development, and R&amp;D. The first two are fairly straightforward. The former deals with customers and inside sales people, the latter focuses on iText core and its plugins. I work on the R&amp;D team. What we do varies. Our team gets to investigate all kinds of new things. Stuff we might like to add to our library or a product. When we don't have a release going on, I'd say we have almost always someone working on something new (1 out of 4-5 people (small team)). This can be based on a question of a customer or our own interest. Sometimes it's the obvious POC that we need to make, but the fun lies in the cool projects, like trying to figure out why printers/photocopiers/photoshop don't handle currency, so that we might incorporate that into a PDF that won't print. Unfortunately that turned out to be nothing, but we had fun (and learned a few things) while doing so. We also handle all things related to iText that aren't planned on the development roadmap. Urgent bugfixes, licensing, ... The biggest task I've had to do here last year was to open source a few of our closed source plugins. It was pretty challenging defining what we needed to clean up before making the repos public. Biggest hurdle here was fixing the git history, which proved to be a one way ticket into madness. One of the cooler things iText allows us to do, is give talks at conferences. We try to let every developer at iText give a talk at a conference. I've given around 10 talks so far, most of them abroad, but the coolest one was my talk at Devoxx Belgium last year. It was a non-technical talk (had nothing to do with iText) and drew a huge crowd. Still makes my heart racing when I think about the rush afterwards :) This also means booth duty, but it's always fun talking to developers and users about their projects. We are also tasked with writing technical documentation, meaning blogs, white papers, code samples, flyers. We have a technical product that we target to developers, it's only logical that developers write that content. As for me personally, I'm the scrum master of the team and senior developer in the office, I (try to) guide the newer developers in getting to understand the PDF specification. The specification isn't particularly hard or anything, it's just huge. One day, I'd like to help shape the PDF specification through the ISO meetings, but we already have two iText people on the comittee and that's enough for now. Well, that turned out to be a bit longer than expected...
Scientific research data management. I'm building a REST service where researchers can upload and annotate their work (including large source data sets) for publication and long term preservation. It is basically a database for large files and metadata with transactions and all that. The service handles about 600GB of new data a day.
Especially scheduling is a lot of manual work right now, the first time there even was a first step at automation (in this company anyway) was just over 10 years ago. But it's getting more and more automated as we go. Yup, with better train tracking we could achieve about 30-50% higher capacity for the same infrastructure. Especially self driving trucks are a big fear of the cargo train industry right now.
Using your library at work. It is extremely solid. Thanks
Always happy to see a happy user! :)
Spring and hibernate for developing a warehouse management platform aimed at the ecommerce market.
just start man, you can't learn swim on carpet, jump in the Water and swim ! When you are in the first company -&gt; learn the shit out of there. The company treats you bad ? leave. Dont be fooled, they hired you to make profit, biggest profit you can make = get better, get knowledge, dont be afraid to go. If you feel like you not learning anything new, change company. Do this few times, until you are solid. (Took me 3 Companys, now im solid java8, Spring, Vaadin, javafx, learning java9. All the patterns and best/worst practices included. Good luck!
There are other issues/annoyances with type erasure, that's just one that's so common it's worth putting in the docs. [Here's an example](https://github.com/vavr-io/vavr/issues/1226) of some of the people over at javaslang/vavr leveraging an extraordinary amount of brain power trying to overcome the fact that you can't examine generic types at runtime.
Actually it would be something like Integer | NumberFormatError r = Integer.parseInt(x) 
Mostly ETL development at the moment
Hey I'm interested in your hobby. What do you mean by bringing it to the modern age? Do you dig out the programs' source code and re-program them in modern languages?
No, real experience is far more valuable. Even a hobby project with unit tests built with spring and angular js and open sourced on going would be preferred over a certification.
Making a game in my free time. Full time I'm just a std::ent. 
That's just bad API design. The type signature of [this method](https://github.com/vavr-io/vavr/blob/master/vavr/src/main/java/io/vavr/collection/TreeSet.java#L649) public &lt;U&gt; TreeSet&lt;U&gt; flatMap(Function&lt;? super T, ? extends Iterable&lt;? extends U&gt;&gt; mapper); is telling a lie. It claims it can be used for an arbitrary type `U`, but it only works for a type in which the objects are `Comparable` to each other. It should have been public &lt;U extends Comparable&lt;? super U&gt;&gt; TreeSet&lt;U&gt; flatMap(Function&lt;? super T, ? extends Iterable&lt;? extends U&gt;&gt; mapper); 
I use VSCode extensively at work. The debugger is awesome. The only thing that I wish had more support was Lombok. I haven't figured out how to use it with VSCode and Maven/Gradle without downloading the jar and linking it in my class path. I have come back to Java for the first time since high school, and I must say it is not as bad as people make it out to be.
thanks
Well it's implementing `io.vavr.collection.Set.&lt;U&gt; Set&lt;U&gt; flatMap(Function&lt;? super T, ? extends Iterable&lt;? extends U&gt;&gt; mapper)` so that's not possible. Besides, that's not what is desired anyway. The desired behavior would to return either a `SortedSet` or `Set`, based on a `isAssignableFrom` to see if `U` is `Comparable`. But that's where the erasure of `U` becomes an issue. 
Integrations. 
Second using your product. It’s been great!
&gt;If you write your own code I think you can be pretty darn sure So in other words you can never be sure in any case that actually matters. I can't think of a single non-trivial program that I have ever worked on that didn't either have other people working on it or use libraries written by other people.
What a *darn* shame.. *** ^^Darn ^^Counter: ^^569
If you're asking what other techs can create UIs, there's many. As for techs widely in use, try spring
I feel like there is a Zoolander can only make left turns joke in there somewhere.
&gt; fairly worded "what are the tradeoffs involved in choosing java" or "what are the problem domains in which java shines vs those in which it struggles" would be fair. by only focusing on the negatives the question is inherently loaded 
First, Spring isn't a web framework, it is a generic application framework based on Spring Dependency Injection. Spring MVC is a web framework, like Struts. The MVC is what Spring MVC and Struts do that JSP doesn't. Spring MVC organization your web application into Model (which populates views and is what forms and other inputs are bound to), View (the JSP which is ultimately rendered, without any logic), and the Controller (which selects the view and coordinates actions with other layers of the system, such as persistence). Note, you don't need either Spring MVC or Struts to accomplish this. You can use plain servlets as the controller and not use frameworks at all to achieve MVC. But, you'd have to roll your own validation and binding logic, which web frameworks make really convenient.
Probably Hasbroo 
Are you brazilian?
Are you building GUIs in Java or a web technology? If Java, are you using Swing or JavaFX (or something else)?
&gt; It would have to be declared as just Set&lt;U&gt;, forcing you to downcast when you know you're getting a SortedSet. That would be fine, the point is that the when doing later monadic operations the set would remain sorted as long as possible. This way a simple `if(set instanceof SortedSet){(SortedSet) set;} else {TreeSet.ofAll(set);}` could be leveraged efficiently later on. `flatMapToSorted` would lose all polymorphic benefits. &gt; Maybe I sometimes want an unordered Set even if U is Comparable. I highly doubt that would happen in a reasonable case. Wanting some flavor of set with O(1) lookup would be reasonable, but a completely different concern than wanting it unsorted. &gt; I can't do that if the choice is being made implicitly by run-time type magic. What run time magic? `Set.flatMap` says you're getting a `Set`, it doesn't make any promise about what kind of `Set` you get.
Yup :)
It may give you brownie points with clueless HR people. It will certainly give you black/red (bad) points with fellow programmers. Talk is cheap. Code.
But it looks absolutely awful. Works in some places, not in others, the example code I've seen looks like a mess.
GUI is done in Java/Swing 
Healthcare. I mostly create custom solutions to work with the software that we use. Data analytics, web services and queries. Queries for days.
Missile Defense. Everything from Swing-based utilities to math-intensive algorithms to TCP messaging. I love my job.
No, I want to make arguments optional if they have default values. And there's nothing inherently wrong with null. What I want is the language to distinguish between 'values' and 'nullable values'. **Optional Arguments:** Consider [this example from RabbitMQ](https://www.rabbitmq.com/tutorials/tutorial-one-java.html). public static void main(String[] argv) { ConnectionFactory factory = new ConnectionFactory(); factory.setHost("localhost"); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); // Here's the real problem: channel.queueDeclare(QUEUE_NAME, false, false, false, null); } Notice how we have to pass in all these 'false' values, just to declare a simple queue on the channel. Perhaps 'false' isn't the perfect reasonable default, but I'm hopeful you see the point. If these all had defaults, then we wouldn't *always* need to pass in all the extra parameters. Furthermore, if we did want to override one of those parameters, **if we have named arguments**, we could selectively override them. [For example, consider the RabbitMQ API for 'queueDeclare'](https://www.rabbitmq.com/releases/rabbitmq-java-client/v1.7.0/rabbitmq-java-client-javadoc-1.7.0/com/rabbitmq/client/Channel.html#queueDeclare(java.lang.String,%20boolean,%20boolean,%20boolean,%20boolean,%20java.util.Map): channel.queueDeclare( queue = QUEUE_NAME, autoDelete = true ); Awesome. With **positional** parameters, if you only wanted to modify the first and last parameters, you'd have to override every parameter in-between. With **named** parameters, we can selectively override parameters. And we get more readable &amp; declarative code. Granted, any IDE could tell you the parameters' names, but in my opinion, this is much better than having to rely on an IDE tell you. You can just read it. ** Nullable values ** Consider this function: CoffeeOrder getCoffeeOrder(long orderId) { // Imagine this looks for a coffee order which may or may not exist return coffeeOrderService.findById(orderId); } What will this function return? We'd expect the function to return a 'CoffeeOrder' object. But what if the CoffeeOrder object doesn't exist for the given orderId? Then this function MIGHT return 'null'. G-dangit, that's not good, because our client code is expecting a CoffeeOrder object, not 'null'. We might get a NullPointerException. **If only there was a way for our function to declare the return type *might* be null**... Well, we could return an Optional&lt;CoffeeOrder&gt;. That way we signal that the return type could be *either* a 'CoffeeOrder' ***or*** a 'null'. Then the client code would be forced to handle the possibility of a 'null' being returned. Now you could argue, "just return an Optional, duh." But it's not **enforced** by the compiler. In fact, watch this: // How is this acceptable...? Optional&lt;CoffeeOrder&gt; getCoffeeOrder(long orderId) { return null; } What's the return value? It's not an 'Optional'. It's just a 'null'. And if you try to treat the return value as an Optional, it'll explode: public void someOtherCode() { // null pointer exception; returned value isn't an Optional... it's a null. getCoffeeOrder(123).ifPresent()...; } There's nothing inherently wrong with functions returning null. What's wrong is that the compiler **always** let's you return null, with no compiler-enforced way to discern between *'SomeType'* and *'null'*.
 public Optional&lt;String&gt; greeting() { return null; } if you try and access 'greeting.get();', you'll get a null pointer exception... because it's not actually an "Optional". It's 'null'. 
There are only two kinds of languages: the ones people complain about and the ones nobody uses. - Bjarne Stroustrup's (the guy who made C++)
It all depends where you live. In the US or UK (from what I gather): no. In more conservative countries like Austria or Belgium: yes. To answer the question, ask yourself if someone with a degree is considered to have a leg up over someone who doesn't when applying for an office job where you live. How about when the degree isn't in a relevant field? If the answer is yes to both, then certification is likely to be worth it. Even better would be to network with programmers in your local area, call some companies' HR services and flat-out ask, etc.
Healthcare here too. Like you said, a lot of it is importing old standards from other industries as innovative ideas--while supporting and transitioning legacy code/systems.
&gt; The only one that really comes to mind is that Java has real verbosity problems. However, that's starting to get better with Java 9. This is Java's worst problem, imo. After years of trying to raise themselves up by competing with Java and failing, now they're trying to add a smorgasbord of "language features" into Java quite likely making it an undecipherable mess. The only thing I find really annoying about java because it would be so easy to fix is that you still have to generate getters and setters. How are we on Java 10 and yet we don't have a @property annotation? Even then it's just an annoyance, but it's such an easy annoyance to fix. Java's "verboseness" is a positive. There's a bazillion "non-verbose languages" out there that didn't catch on, partly because they're hard to read and parse through. 
The verbosity is still a thing. You didn't say "Java isn't verbose." All you said was "use an IDE". It would be nearly impossible to do *anything* non-trivial in Java without the help of a full-fledged IDE. [Also, case in point, please consider this rabbitmq tutorial.](https://www.rabbitmq.com/tutorials/tutorial-one-python.html) Here's the code for python: #!/usr/bin/env python import pika connection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost')) channel = connection.channel() channel.queue_declare(queue='hello') channel.basic_publish(exchange='', routing_key='hello', body='Hello World!') print(" [x] Sent 'Hello World!'") connection.close() Here's the exact same code but for Java (comments are mine): import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; public class Send { private final static String QUEUE_NAME = "hello"; public static void main(String[] argv) throws Exception { ConnectionFactory factory = new ConnectionFactory(); factory.setHost("localhost"); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); // What are all these 'false' values...? // Without an IDE or the API as reference, you won't even know the parameter names. channel.queueDeclare(QUEUE_NAME, false, false, false, null); String message = "Hello World!"; // What is that random 'null' param passed in? Why do I have to convert to UTF-8? channel.basicPublish("", QUEUE_NAME, null, message.getBytes("UTF-8")); System.out.println(" [x] Sent '" + message + "'"); channel.close(); connection.close(); } }
And ... what's the difference between the two? Is the same API, same order of operations, same amount of code. 
Have you read any of the comments I left within the code of the Java example?
so you're angry that in python you can specify the parameter values by name and in java you can't? oh well, yes you can't. Is java more verbose because of that? No, you need the docs/IDE if you are to write java code, no question about that. you can probably write python code with VIM and the dick in your hand. so what? I use an IDE to write code and that's that. &gt; Why do I have to convert to UTF-8? is that a joke?
That's the interesting thing about software development. You go to school to learn your trade, but then you get a job where you have to learn someone else's trade better than they know it, because you have to take care of every possible case. Things I've worked on where I had to know more than the user: * Software to enter police case reports (this shit has to be reported to the FBI using NIBRS, you don't get to make up your own violations and ethnicities) * Software to do automated trading (trust me I got you a better fill than you could nave. If we got beat it was by another programmer not another human) Other things I can think of * Software to land planes * Software to shape radiation treatments for cancer I bet the programmers at TurboTax know all the best tax scams.
Web portal for a bank. AEM. 
Definitely good job security wise. When HIPPA was passed it was like thousands of new jobs were created overnight. But when it comes to complying with standards, there's a ceiling on what you can get paid. Sure everyone wants to be compliant, but no one is going to pay 3x as much to be the most compliant healthcare org. Other industries, people will absolutely pay 3x as much to get the best programmers, because they want to win. You don't WIN at compliance, you just escape LOSING.
Yup.
And doing a perfect job at it. jOOQ is amazing!
We're looking for more developers. Please contact me
Take a look at canyoncryptoclub
How much experience? Im mostly self taught, so i probably cant do much.
We're looking for individuals to grow with us. Message if interested. 
I'm about halfway through school and would like to get into consulting (obviously down the road and with much more experience). If you don't mind me asking, how did you get started/any tips for someone looking to follow the same path? 
Currently working on an Employee Scheduling Application built on top of vert.x that will be responsible for 20k+ employees.
Working for Brightcove. Video analytics and high performance data storage. Bigtable, dataflow/beam, netty, golang, kubernetes if anyone is interested. 
^^^
Ding, ding. Also there are several other projects on Websphere so management thought it would be a good idea to stay consistent with them. 
Professionally? Robotic automation for healthcare. Personally? I like to work in various areas. Currently remaking my first ever full game. Also interested in getting into genetic programming, as I think I would like to specialize in genetic algorithms. I also like boolean logic circuits, so Minecraft Redstone is fun to play with.
Amazing. 
One client said Spring Boot is out of the question because the SpringApplication.run() line seemed insecure to them. So we went with Vanilla Spring 
Not sure if this counts but Android Developer for 4 straight years. And Spring developer for fun and trying to maintain my Java skills up to date. 
Supply Chain, specifically warehousing. Conceptually it's simple, but implementation is on a scale of it's own.
Can't wait for the tide to change. People feel compelled to use spring only because their next job will likely list spring as a requirement. It's the stupidest thing. Spring's popularity entered a positive feedback loop and feeds on itself. Freaking bubble.
You’d probably like Swift. 
Regarding your second point, I believe this has been revamped in Java 9 (project Panama). 
Too short and incomplete for really *learning* something, too basic for people who are familiar with concurrency. On top the section about immutable classes is not really sufficient. Just to declare a field final doesn't automatically lead to an immutable object concerning the external visible state. The object behind the field needs to be immutable too - or independent from external manipulation like returning a copy within a getter. Conclusion: Better read the classic book "java concurrency in practise" by Brian Goetz et alt. 
Really helpful man!
I'll bite - what kind of gambling needs APIs? Online casinos? DraftKings.com?
No. I have a JCP cert and I would only recommend going through it if your employer gives you both the money and the time for doing it. I got mine from my employer (over 10 years ago so I even doubt it's still considered valid). Language certifications don't teach you programming.
Scheduling, catering planning, invoicing and other management stuff in aviation.
Curious; why would you use it over IntelliJ or Eclipse?
I started working long time ago, .com boom in the late 90's, joined a startup, switched several jobs until I landed on the current one. It is not hard to get a consulting job, because that is what the majority of companies are doing nowadays, selling IT related services. The majority of companies don't have software development as main business, for them IT is only a cost center that they would rather dump somewhere else, so they hire consultancy companies to come in, do whatever they need and leave. As tips, work on your soft skills, they are as important or sometimes even more than the technical ones, open minded for solutions, be open to use whatever tech the customer needs even if you dislike it, be a polyglot dev not a language X dev. Oh and if you work in a country with good work laws, know your rights and how to enforce them, don't let them abuse you with false promises.
I write process automation software using Java and groovy for large businesses. Uninspiring technically, but good pay because no one else wants to do it.
Same here. The professional certification lifts your skill level a lot, even when you think you know Java. Passing the exam really feels like you now have a certification that is actually worth something. I don't know about the associate exam. It's probably poodle to start with. Showing problem solving skills during the interview is usually more valuable.
Test automation framework for Applications using DB-Packages for business logic. I'm using Spring Boot with Angular Frontend for configurating the Framework and test data
Fabulous.
Glad to see that!
Apparently we work in the same place :) 
Thanks for your nice words
Hi pdf man. I’m looking for a tool which I can visually design pdf templates and produce from. Particularly if they can be done through a browser. Does such a tool exist?
Messaging (JMS api). Currently AMQP implementation. Running a broker (ActiveMQ Artemis) for the enterprise and helping other app developers make the paradigm shift to more async work. Assisting in on boarding clients. Java clients use Qpid JMS client. Also on boarding .net and node clients with their respective AMQP libraries. Recent history: integrations, web dev, RESTful api design
ITT: People who took certification saying that it helped them more or less. People who didn't trying to explain how pointless it is
Spring boot + Vaadin. Internal applications for 9 billions revenue company. Also migrating old tools to todays versions of Frameworks.
Exactly! All these "new" VSCode features were already there in IntelliJ as far as I can remember.
Hi reddit man. Coincidentally we're working on such a tool with a partner of ours. It's going to allow you to design forms (both input and output templates) through a web front. iText is hooked into this editor to generate PDFs. If you want to know more, PM me. 
Do you take requests? 3D PDFs. Use them a lot at work. The tooling around it kind of sucks. 
Depends on what you mean by "tooling", but I don't think that building a 3D toolkit is going to happen from our side.
I don't work for one of the famous ones I'm afraid. But most gambling websites, webapps, and native apps will use APIs to get data, display data, get price updates, place bets, find offers, and then any other extras the site might have (competitions, leaderboards, friends, cashout, whatever you can think of) I write those APIs for our websites, apps, which is really just glorified XML or JSON translation.
Without writing compiler plugins, you can just write a lot of static helper functions, and do static imports for them, to get this syntax for print. Though ';' is mandatory at end in java. Btw, you can use every java lib in Kotlin with no hassle, sometimes you need a few extensions functions added, just to make API more *idiomatic* to Kotlin, and null checks between platforms are lost, but besides that java-&gt;kotlin interoperability is seamless.
That depends. I'm in consultancy and the decision makers for projects/contracts look at the gold fact. If someone has 2 years of experience in Java, and you have 2 years plus a cergtification from Oracle, you get picked. 
Use an IDE.
&gt; All Zulu binaries are distributed, without charge, under the GPLv2 with classpath exception license. This means that users are free to deploy these binaries with any form of environment and are not constrained by any field-of-use restrictions.
IDE is your friend. I'll type 'sout', autocompletion and the cursor will be placed within the quotes of System.out.println("cursor"); Learn to use your IDE, yeah, it's wordy. But it's good, because you read the code a million times and write it once. And the IDE will help you to speed up the process. If you don't use the IDE tools, it's like you have an electrical chainsaw but use it as it it was a friggin manual saw
No, I'm actually mostly working in Java
You work for a company or individually?
Hey,where do you work on?Freelancing or 9-4 job?
So you go from the industry standard for testing in Java, to the sequel of the industry standard for testing in Java, to a new framework for testing in a Java dialect. Brave. I'm not convinced.
For your `println` example, you can just [statically import](https://docs.oracle.com/javase/1.5.0/docs/guide/language/static-import.html) `System.out`: import static System.out.*; // class // main() println("Hello World!"); Bear in mind that, while doing this might seem cleaner to you, it's actually confusing for most Java programmers. We're so used to read `System.out.println` that we just mentally map it to "print". However, **by hiding the `System.out` part, you're forcing everybody else to double check your code** in order to confirm that `println` is the `System.out` method, and not a different one you wrote on your own. So instead of hiding information, just use your IDE (as others have said) to automatize most of your code input.
I think you will find kotlin very pleasing to work with. It is fully cross compatible with java, which means that you can use all the java libraries within kotlin.
&gt; import static System.out.*; But you can't do that (or even fully qualified import static java.lang.System.out.*); **out** is a field and you cannot statically import its methods. So at best it would be import static System.out; // class // main() out.println("Hello World!");
If it's just a console app and you want to display a message wouldn't it be fine to just have an IO class with methods that outputs various things you want then call its functions in another class? example: a method called printStr(String passedStr) that takes String. a method called printInt(Integer passedInteger) that takes an integer. Both of these methods could contain your sysout lines but not be in your main class.
Must be hard when the semicolon guy doesn't come in.
Sure, just yesterday I was working on constructor dependency injection. I have an `interface X` that a `class Y` depends on and needs passed in through the constructor. At runtime there can be multiple different objects that implement `X`, all of which should be passed in. What I would like to do is: class Y { @Injection public Y(List&lt;X&gt; dependencies) { ... } } But the type `List&lt;X&gt;` is erased to `List` at runtime so I cannot lookup the type to find the correct dependencies.
Orbital dynamics software for spacecraft operations. Maneuver planning and calibration, orbit determination, predictions, telemetry processing. Primarily a Java desktop app based on NetBeans. A lot of our older code is in Fortran or C, but this app uses almost all Java under the hood except for a couple specific and complex libraries from other groups we haven't ported over. 
Oh, lovely!
I certainly hope that they look a bit beyond that and look at my experience first and foremost. 
thanks. I don’t think I’ll write java without IDE then.
Comping in Java 10 is AOT (Ahead Of Time) compiling. I think it will be in the base module first. This will speed up java considerably. Just to note that IBM AS/400s did this around 10 years ago, but to all Jars, compiling to 64-bit machine code.
Good to know. Do all java libs work with kotlin?
I bet I did. The remained concern is when I came across problems, there were many solutions for java while few for kotlin.
Kotlin was designed with Java interoperability in mind. You can call Kotlin code from Java and vice versa.
Looks like you are.
What does your application run on? 
So... why aren't you convinced?
Corrected, thanks.
what if this person without certificate have nice github repository with high quality code, who gets picked?
Hiring managers don't give a crap about your github repository, and they sort initially before engineers will spend time interviewing. 
Interesting. Thanks!
Digital guitar effects pedals. Just a little hobby of mine.
What you are really complaining about here is the lack of named and default parameters (features I definitely miss in java after working with groovy and kotlin for a while). Besides for the extra parameters there isn't much difference. You could probably get away with not encoding with UTF-8 but it is best to be explicit. In your python example how are the bytes being encoded? Do you even know? When the receiver tells you they are getting unprintable characters and asks you what encoding you are using what are you going to tell them? In the java example you could immediately tell them UTF-8. In the python example you would have to tell them ¯\_(ツ)_/¯
That's awesome! I love signal processing. Would be awesome to find work in that field.
I've been re-implementing stuff brand new. Started in 2003 with a [clean-room clone](http://qodem.sf.net) of [Qmodem](https://winworldpc.com/product/qmodem/45) . That was in C, originally just meant to scratch my own itch (wanted a long scrollback on Linux console + Zmodem), and 100 kloc and 14 years later became a legitimate successor to the original. From that experience I learned a lot about VT100 and BBS era stuff, because Qodem had to do all of that. So: terminal emulations, character sets, ncurses keyboard/video/mouse, and of course the transfer protocols. As Qodem neared completion, I decided I wanted to extract some of the harder bits out into stuff others could use. Two projects came out: * [Jexer](https://github.com/klamonte/jexer) is a full-featured text user interface windowing system, built out of what I learned from VT100/Xterm emulation. It will the basis of a couple applications later on. For now it is almost beta-quality, has a growing widget set, and its TTerminal class is a real vttest-passing terminal emulator in its own right. (Jexer can actually run inside itself.) * [Jermit](https://github.com/klamonte/jermit) is a new implementation of the serial file transfer protocols. Still in alpha with a year or so to go. Xmodem, Ymodem, and Kermit are in now, Zmodem is coming, and new protocol is in design. These are both what I consider "teaching" code bases. They are intended to show others how to do it, at reasonable performance and decent reliability, but not trying to become flagship projects on their own. I'm hoping to spur more interest from the Javascript/Go/Rust/Python/etc. language communities. 
&gt; Without using tools like maven, gradle or others you will have a hard time managing dependencies and your own modules in Java. I managed dependencies on my own for years before using Ivy with Ant and now Gradle. It really wasn't that hard at all. Even today I am wondering what problem dependency management really solves. Sure I don't have to hunt down the jar files, but I still have to hunt down the group, org, and version. And then wade through and see if I really need all the transitive dependencies. Sure I use dependency management but it didn't really seem to make anything better or worse. 
Do you mean implicit typing? I will assume that and encourage you to read the [JEP](http://openjdk.java.net/jeps/286). I think the choices behind only allowing it on local variables are fair enough, especially for java developers. 
jenv does seem kind of handy but I just use some env variables and aliases: LATEST_JAVA=/Library/Java/JavaVirtualMachines/latest/Contents/Home export JAVA_HOME=$LATEST_JAVA export JAVA8_HOME=/Library/Java/JavaVirtualMachines/1.8/Contents/Home export JAVA7_HOME=/Library/Java/JavaVirtualMachines/1.7/Contents/Home export JAVA6_HOME=/Library/Java/JavaVirtualMachines/1.6/Contents/Home alias jh='cd $JAVA_HOME' alias gj='cd /Library/Java/JavaVirtualMachines' alias gj9='cd /Library/Java/JavaVirtualMachines/1.9' alias gj8='cd /Library/Java/JavaVirtualMachines/1.8' alias gj7='cd /Library/Java/JavaVirtualMachines/1.7' alias java8='/Library/Java/JavaVirtualMachines/1.8/Contents/Home/bin/java' alias java7='/Library/Java/JavaVirtualMachines/1.7/Contents/Home/bin/java' alias jsetL='export JAVA_HOME=$LATEST_JAVA' alias jset8='export JAVA_HOME=$JAVA8_HOME' alias jset7='export JAVA_HOME=$JAVA7_HOME'
BR BR HUE HUE Também sou brasileiro, programador Java, trabalho numa empresa que dá manutenção em sistemas públicos e suspeitei pq trabalhamos com setups quase idênticos! BR BR HUE HUE
Ah yes I try to steer clear of things like dependency injection (and anything that strays too far from compile time safety). I suppose a lot of the issues with type erasure occur in these scenarios, which makes sense since it's all about type information at runtime. 
I've actually never learned c++, although I know I probably should. I have heard that templates in the language are subject to pretty bad abuses. 
...and that's how you end up with bloated monster programs, eating all possible RAM and resources.
Supply chain information systems. I spent many years working for everything from startups to fortune-50 companies in this space and have struck it out on my own to build a new product for courier, freight, and field service companies from scratch using Java Spring, React, Material Design, PostgreSQL, and ActiveMQ. 
Difference between being a "cost" center and "profit" center. 
Are you sure your code actually executed in the second instance? You sure it wasn't just optimised away? Ir doesn't look like you used JMH. `[info] IncWhile.main avgt 100 2112778741.540 ± 9778298.985 ns/op` `[info] IncWhile.main avgt 100 2.739 ± 0.029 ns/op` 
It's not solving a problem that my existing tools can solve as well, which allow me to write in java. To be honest, I stopped caring when I read Groovy. There's no reason to learn Groovy when you are a Java shop. The time it would take to have every team member learn Groovy is too much for the returned value of this framework.
Any solution that has Electron as part of it, gets automatically ignored by me.
There is two part of the application. The web app runs on tomcat and the app written in JSP, servlet. And the data processing part is written in pure java application that runs as a service and connect with web app that runs on Resin server.
I know what you mean. But you cant deny the popularity it has (and will probably gain in the future) 
I reproduced your numbers, but try this benchmark: ` @State(Scope.Thread) @OutputTimeUnit(TimeUnit.NANOSECONDS) public class Inlining { @Param({"100000000", "1000000000"}) int size; @Benchmark public int inlined() { int i = 0; int result = 0; while (i-- &lt; size) { result = nextNumberInlined(); } return result; } @Benchmark public int notInlined() { int i = 0; int result = 0; while (i-- &lt; size) { result = nextNumberNoInlining(); } return result; } @CompilerControl(CompilerControl.Mode.DONT_INLINE) int nextNumberNoInlining() { return ThreadLocalRandom.current().nextInt(); } int nextNumberInlined() { return ThreadLocalRandom.current().nextInt(); } } ` It looks like the IR is being matched and optimised, and the entire loop is removed since it trivially terminates.
I don't really understand the title. "JVM JIT compilation as a way of performance optimisation". Of course it's a performance optimisation. That's *all* it is! Is the author saying that they think this is a novel way think about JIT compilation?
funny statement being in /r/java -- there was a time (still is a time?) where this was a criticism of people why not to use java too.. as much as I don't love electron, what good alternatives are there? 
Not sure you're getting my point. Exceptions have the nice property that only need to be explicit about them at the point of throwing and the point of catching. The "union" approach entails explicitly handling them at each step. Also, union types and monads are possible in Java now.
A possible middle ground somewhat related to the linked article would be a backend in java using an embedded webserver (jetty for example which is rather lightweight) and a webapp connecting to the backend but in whatever default web browser, instead of packaging Electron because how many separate web browser can you run simulateneously a desktop when you could just run one...
Furthermore a lot of java standard classes like String are replaced with a Kotlin variant with added features. This doesn't lose any interoperability because during compilation it all gets turned into regular java classes the JVM will understand.
Err, I'm an architect lol. Must be a reason why Sky use Ratpack. Samsung Smarthings too.
its Rossmann, second biggest german Drugstore.
In Xamarin.Android it can be as low as 2.9 MB. Pretty good considering it has to include the .NET runtime.
I've seen 11mb as the number somewhere but maybe 2.9 is achievable by stripping out any UI or something? Not an expert on Xamarin though. FYI the 1.5 number isn't for a hello world app. It's for one of our demos: swiftnotes. It's a simple note taking app written for native Android which we ported to Codename One as part of a tutorial. A hello world would be smaller.
I would re-evaluate the "time it takes" argument. I've been hearing it for years since we started getting (for example) the likes of Groovy, Scala, Kotlin, and others. There are two big problems with this argument: First, the same people making the argument never seem to see any problem having to learn the XML, annotation-based, or other DSL's of Lombok or Camel or Spring or whatever. Second, where is the hard data under that cost/benefit analysis? Anecdotally, I have never personally had a problem learning new languages, from Scala to Python to simple Bash scripting, and have often found that it helps me work faster than someone who only knows Java. I wouldn't make the assertion either way that it's more cost or more benefit without hard data, and I don't think anyone reading this should either.
&gt;I've seen 11mb as the number somewhere but maybe 2.9 is achievable by stripping out any UI or something? Not an expert on Xamarin though. From what I've seeing it works by removing unused binary code from the DLLs. &gt;FYI the 1.5 number isn't for a hello world app. It's for one of our demos: swiftnotes. It's a simple note taking app written for native Android which we ported to Codename One as part of a tutorial. A hello world would be smaller. I'm actually comparing it with your iOS solution because there you have to "include" the Java runtime. Of course compared with Android there's nothing there Xamarin can do about it.
-&gt; /r/javahelp
Qt for starters. And the irony is that even Java, AOT compiled to native code, does indeed use less resources than Electron app and is faster.
Only among webdevs that can't be bothered to learn anything else.
Yes Xamarin can't compete, what's wrong with that ;-) On Android Xamarin needs to go through the JNI bridge constantly so it's a pretty big disadvantage. On iOS I'm sure they did a great job. Our iOS build will probably be larger than theirs because we do something very different from Xamarin even though I'm guessing our VM is smaller/simpler. 
The is oracle certification? How does one get it
Because my employer has products that were written in Java and I have to work on them.
Well. One could say that you are a backend dev that refuses to learn anything new. I dont like the uprising of electron but realisticly we will miss out from good tech if we just ignore it. 
Reasons: * I want to write code now that I will be able to run without much change 15+ years from now. * I want it to be absurdly obvious to other people how I got things done. * I want Windows and Mac users to be able to run my code. * I want it to have decent performance. * I want it to be able to run on a supercomputer / cluster. * I want it to be able to run on a smartphone. 
Because it is the fastest way to solve problems of business customers.
Here is a much more detailed comparison http://blog.codepipes.com/testing/spock-vs-junit.html Also https://semaphoreci.com/community/tutorials/stubbing-and-mocking-in-java-with-the-spock-testing-framework
&gt; There's no reason to learn Groovy when you are a Java shop Given the fact that Groovy is also the scripting language for Jenkins I would say there are a lot of reasons to learn Groovy. Have you also looked at Gradle?
Not many people do. It’s dying fast
Except that I do full stack dev, and appreciate learning native APIs so that the users of my customers can enjoy a good UI/UX. Electron has nothing of good tech compared with Qt, and is an idea already done by Microsoft with Active Desktop apps back in Windows 98, and Mozilla with XUL apps. In five years no one will care about Electron apps.
💲
I understand your concern and it looks rather suspicious. I am not saying that that is sole effect of inlining I was rather trying to demonstrate one technique and for sure can enable loop optimisation or dead code elimination. I was checking generated machine code which looks as follows: 0x000000010b22a4d6: mov 0x8(%rbp),%r10d ; implicit exception: dispatches to 0x000000010b22a529 0x000000010b22a4da: cmp $0xf8033d43,%r10d ; {metadata('IncWhile$')} 0x000000010b22a4e1: jne L0001 ;*iload_3 ; - IncWhile$::main@4 (line 7) 0x000000010b22a4e3: cmp $0x3b9aca00,%ebx 0x000000010b22a4e9: jge L0000 ;*if_icmpge ; - IncWhile$::main@7 (line 7) 0x000000010b22a4eb: sub %ebx,%r14d 0x000000010b22a4ee: add $0x3b9aca00,%r14d ;*iadd ; - IncWhile$::inc@2 (line 16) ; - IncWhile$::main@12 (line 9) 0x000000010b22a4f5: mov $0x3b9aca00,%ebx ;*if_icmpge ; - IncWhile$::main@7 (line 7) L0000: mov $0xffffff65,%esi I also was checking flight recorder but it is not my daily routine so I might miss it. But those were my two tests as the numbers are somewhat great
but why do they care now? what's the difference?
mhmm, beside of things like improvement of language, stability, and all the things that other guys will for sure also write. Me, i simply understand java pretty good now. Took my some time, im still nowhere near the absolute cracks, but im confident. And this i like :) (well, but i also worked with php and javascript, so i guess im out :) 
for many people, no. for some people, maybe... for example, if you're looking for work without a finished degree, it might help get your resume past some screening. it might help in some consulting situations, but probably not a huge amount.
Do you have a source for your claim? What language do you think is better? Why do you like to troll?
Simple and honest I like it
Because employers in my area want Java devs. 
It seems you are looking for more technical answers, but I'm also another dev that works on Java because there's some dudes in a company that give me money for spend time writing what they want on Java. The last programming courses I did were on Java, so it was the easiest way to get into a programming job, but I wouldn't mind/care about switching to C#, as usually corporate applications are all more or less the same. And well, I'm thinking on trying another branch of development, because of that, which would make me either keep on Java (Android stuff) or move to any other language.
That's a bad property, in my opinion. Regardless, this is yet another "problem" that has already been solved ([and it will soon be solved in Java as well](http://openjdk.java.net/jeps/286)). 
Let's connect. Check out canyoncryptoclub sub Reddit 
Nice? I'm actually incredulous at the comparison. &gt; JMeter wins on Project History. The project is significantly older and has more contributors. Both Gatling and JMeter are maintained regularly. JMeter has a significantly bigger codebase (almost 500K lines now, which Gatling tool is much smaller (50K lines of code). Of course, Scala code is more concise than Java code. Lines of Code is a stupid metric. Full stop. Project lifetime is not a useful metric. I mean, why don't we all use Java 1.x instead of Java 8? Java 1 has more lifetime! Same thing with Tomcat vs. Jetty, `java.io` vs `java.nio`, etc. Prioritizing projects based on their age isn't very helpful, and it means you will be forever stuck in legacy land. In addition, the number of contributors says nothing of the project's quality. You can end up with 10k contributors by having a whole bunch of pull requests for documentation updates/fixes. So this is a useless portion of the comparison, and yet the primary argument that the author is primarily basing his recommendation upon. &gt; JMeter has clearly more features than Gatling Tool. This is completely understandable considering both project histories. If I need SOAP, I can craft SOAP myself as an HTTP RPC. And who's load testing FTP servers? Or IMAP servers? Are those really such compelling use cases? Throw those out, and how many contributors/lines of code go away? Raw feature count is not a useful metric. You need to look at how helpful those features are, how stable they are and how they combine into a suite for your purpose. &gt; You’ve probably heard this a million times: the scripting winner depends on your feelings. &gt;Do you prefer a point-and-click tools or Write Code? Depending on your preference, one tool may be better than the other. I would argue that the code tool is objectively better. Necessitating a UI means that you need to not just learn the tool and its capabilities, but the UI quirks as well. In addition, your pull requests won't be usable since the XML files aren't meant for humans. Yes, it's code, but it's also a DSL. Most QA engineers these days can write some basic code. &gt; Distributed Testing Verdict &gt; JMeter stands out! Gatling Tool simply doesn’t support distributed testing in the free version. Again, wat? The entire point of the actor model is that you don't need 1000 threads to model 1000 users. And most actors are not going as fast as they can, they have delays and whatnot built in. If you're attempting to load test your server, you want as many users as possible. With the user-per-thread model, JMeter ***needs*** to be distributed. There are hard limits both in the OS and in the JVM about how many threads you can have online at a time. There is significant performance problems coordinating communication across that many threads. The threads are true OS threads, so they involve a full context switch. That's not free. When your load server is under a heavy CPU load itself, it can affect the results. Gatling's lower CPU usage means that it won't affect the performance results as directly. Gatling's innovation is that it doesn't need to be distributed for the most common use cases. And if you're going into the 100,000-1m simulated user range, neither tool is going to be appropriate. And the final f-u: &gt; JMeter is clearly the winner. With greater number of Features and support for Distributed Testing, JMeter compensates for slightly less performances than Gatling Tool. JMeter’s Longer Presence can be seen with two different point of views: &gt; ... &gt; Choosing JMeter or Gatling tool really depends on what you are comfortable with. So you call JMeter the clear winner, then hedge it by saying "pick whatever lol!" So you didn't compare/recommend shit. You said it doesn't really matter. 
For the following reasons : - A great selection of web servers; - Lots of options of web-frameworks; - Extensive open source library, aka maven central; - Verbosity... I know everyone hate that but I have been supporting some applications for more than 10 years and this helps a lot... - Java must be the language with less gotchas of all ; - Two great free IDEs; - Run on any OS without trouble. Aka develop on windows, deploy to linux... - Java strictness makes harder to write stupid code; - JCP and JSR; - Production proven stability; - It's not PHP. I hate that shit. To be honest, the greater advantage of java against other decents languages it is really the escosystem. 
except it isn’t required.
Because I like it :)
There is a "serious" book called just "Design Patterns" but it is extremely *dry*, hard to get through. I would start with the head first book, hold your nose at the style, and get the benefits of learning the idea. Then, if you want to channel your inner grad student masochist, take on the more "serious" volume.
I tried to read GOF book but is too bland and drowsy. Not saying its a bad book but it didn't suit my taste.
Java versus what? Versus JavaScript, because I can't imagine trying to keep up with all these hipster JS libraries and frameworks, also because I like back end development more, and although I know you can do that in JS its not as common. Versus C#, embarrassingly enough it's because I had a couple .NET internships where the code was written in VB.NET, thus giving me a bad taste for all of .NET (including C#) even though I've hardly used it. Versus C/C++, because I don't work on embedded systems or game engines or anything like that. 90% of the projects I've done over all my jobs are web based API's, mostly REST APIs. Also... Because I really like the spring framework, it simplifies so much and makes so much, so easy.
&gt; There are only two kinds of languages: the ones people complain about and the ones nobody uses. -- Bjarne Stroustrup, The C++ Programming Language Everyone has gripes about the languages they use. Every single one. But they're used... and typically for good business reasons. You don't see people complaining about INTERCAL or BrainFuck or COBOL... Now, some day people might not have any criticisms of Java... and we'll all be working in other jobs.
I write it like this: page: hello, basic_frame module: java $print Hello World! Save it as hello.def, translate it as: $ mydef_page hello.def --&gt; [hello.java] Or directly run it as: $ mydef_run hello.def --&gt; [ hello.java ] javac hello.java &amp;&amp; java hello Hello World! Where, basic_frame is a macro in std_java.def that is automatically included (and customized). $print is a mydef plugin that parses and translates into java's System.out.printf, that can also be customized. MyDef is a general purpose preprocessing layer that I coded exactly out of a similar desire of looking for a easier way. It only do preprocessing so there is no need to invent or learn anything extra -- just do Java and it should pass-through.
IDE is write once. Can't push into repository, for example. Hit a simple key or click a few buttons, let IDE spit out lines that covers up your screen -- that is vomiting.
If it's the i7, 16 GB, and SSD beast you mention in your history, you're never going to notice a difference. Install the 64 bit. 
Because it's fun
Personally, i use java because it is a powerful yet simple programming language. It is powerful in what it can accomplish yet it is often considered the best first language to learn because of its simplicity.
You can't win em all. Just pick 1 of the 2 (Head First or GoF) and work through it. I've heard good things about A Little Java, A Few Patterns but it has a pretty wacky style. I read this book a while ago and it got me what I needed: http://enos.itcollege.ee/~jpoial/java/naited/Java-Design-Patterns.pdf
Generally speaking, 64-bit applications are slower than 32-bit applications. Why? Because every instruction and every pointer take more space. Which means you have less room in your cache for actual data. That in turn means you are spending more time waiting on RAM to copy data into the CPU cache. Of course there are exceptions. 64-bit gives you more RAM to work with, which may eliminate the need to go to disk so often. 
If you do end up studying for it, check out this neat study guide: http://ocpj8.javastudyguide.com
Well who am I to shit on someone's curiosity? /u/grauenwolf has a great answer.
Are the links still different depending on if I use a perspective? There are so many usability issues with Spring HATEOAS.
The school I went to taught Java as the primary language, so I have a solid understanding of the language. I use Java because it's the defacto language for Android, the platform I develop for. My feelings when I first used it: * Straightforward syntax * Very little behind the scenes "magic" * Lots of tooling, libraries, and internet support My feelings after a few years of writing Java: * Overly verbose; lots of typing to accommodate things that one-liners in other languages * Lacks functional programming capability (better in Java 8+) * Lacks shortcuts that lend themselves to implementing OO patterns Recently I started using Kotlin on the job and I'm loving it so far. Kotlin addresses many of the beefs I have with Java and it makes writing code enjoyable again. Since Kotlin compiles to Java byte code, interoperability comes out of the box. For any new programmers out there: you should learn Java because it teaches you the basics and it's a marketable skill. For seasoned Java veterans: try Kotlin; it will streamline your programming experience. 
&gt; First, the same people making the argument never seem to see any problem having to learn the XML, annotation-based, or other DSL's of Lombok or Camel or Spring or whatever. Most likely they're not the same people. Like I personally minimize my usage of those as well. I don't use Lombok, I don't know what Camel is, and I minimize my use of Springs special features as much as possible. &gt; Second, where is the hard data under that cost/benefit analysis? In this scenario you'd be the one who needs to provide "hard data" about greatly improving speed with Spock. I'm sure you'd realize at that point that there isn't really any hard data on these kind of topics.
FOR MONEY!
Fashion driven industry.
It has some JavaScript there to please webdevs. :)
in your case, I venture to offer you Log4j2 to.
It has more addressable registers, which isn't the same thing as having more registers. The actual number of registers is an implementation detail. As the CPU pre-fetches and interprets instructions, it's going to detect register logical reuse and spread things out across physical registers. I'm not going to say that it will never matter, but it's not like the 486 era where your EAX register is literally a specific piece of silicon.
For Java, there is [Java Design Patterns](http://java-design-patterns.com/) which I personally find nice.
I would expect from a comparison to provide more information about pros/cons of listed tools. Also would be nice to have some information about how well all 3 frameworks scale on a large number of tests. And if one suits better than another, how long it will take and how hard it will be to rewrite existing tests (worth it?). Comparison of one 1 simple test brings almost 0 value. Official docs will have more examples. Even code formatting is not consistent in code blocks :)
Got anymore complete beginner questions to ask on your troll account by accident?
Don't mind him. He's actually a complete beginner. A few months ago he forgot to switch accounts.
A couple of reasons. The ecosystem is extremely mature. No matter what you want to do there are usually multiple libraries that are production-tested, well documented, and open source. The other side of it is risk. Java tends to be used in companies (e.g., banks) which are extremely risk adverse. Java is seen as low risk becauae it's unlikely you'll have any issues hiring and training Java developers for the foreseeable future.
I would suggest to ignore the *childish* feeling and give the book a further try. It is an outstanding piece of work with a very good didactic structure and simple but fitting examples. Of course it is old and some patterns are considered anti patterns nowadays or have better language representations nowadays, but the core topics are still relevant. This book shows very explicit the hierarchical structure of OO foundations, principles and patterns.
Because for money. There are a lot of Java jobs here in Poland.
If you're starting out you should master one area, that's my opinion. Get comfortable with the backend, and afterwards, try to move towards full stack. 
Goddamn. Together with cobol probably.
Because I get paid to do so.
I think the question is 32bit vs 64bit operating systems.
Oracle's JDK / OpenJDK use "compressed pointers" if possible. So unless you use a very big heap, this is just not true, pointers will still be 4 bytes. And "very big heap" means &gt;=32GB (the actual number depends on other JVM settings and your environment)
Generally, since this is **Processing** you should ask in **/r/processing**. **Java Programming help** questions should be asked in **/r/javahelp**, as the plenty hints on the page indicate, not here. **Post removed:** Processing/Programming help
You would be surprised how much cobol is still running and beeing maintained/developed in sone industries
Huge number of well paying jobs
Because it's stable, mid-level complexity, performant and scales well. Safer than C++, more stable than Javascript.
In my observation (read: a couple of submissions doing some simple GUI stuff in Java) while TAing a course, the 64bit version far outperformed the 32bit version, although that may be because the 64bit version is `-server` by default while the 32bit is not? At least that's what I seem to remember...
OOP patterns could become outdated with functional programming. See [here](https://www.slideshare.net/ScottWlaschin/fp-patterns-buildstufflt)
Hmm, the website should give a recommendation for the packages you need in a "default" setting, before listing 20 odd packages and only then linking to sample projects, but apart from that, it looks really good.
The x86-64 specification also has more CPU registers than x86 does. Twice as many, in fact. Which the CPU won't use for 32-bit programs.
What does "GOF" expand to? I you are referring to "Design Patterns" I agree and many people have had that to say about the book. There is something to be said for a book you can read being tired after a long day of work. The Head First book, despite being cutesy will let you do that.
Java's support for FP isn't as powerful as Haskell/Scheme/Scala/ML, so, most of the patterns are still valid for Java 8. For instance, a powerful pattern matching system turns the Visitor pattern useless, but Java has no such feature. Likewise, with Mixins, the decorator pattern becomes unnecessary, but Java has no mixins. And so on. Java is still a statically typed/OO/imperative language, so, design patterns are still relevant. FP is fantastic, but it's not mainstream. And Java is well established and there is a huge code base in Java to be maintained.
And really, you see people complaining about it all the time when you work with people who actually use it.
"Design patterns", written by Gamma, Helm and others. GOF expands to Gang of four, referring the authors of the book.
Where have you been, buddy?
Just want to point out that COBOL is still heavily used in the financial industry, but your point stands regardless. 
The Just-in-time compiler/JVN is one of my big reasons. Every release of Java makes my programs faster and I don't have to do anything to my code in order to benefit. 
 &gt;Java strictness makes harder to write stupid code Also, I makes stupid code more obvious that it's stupid code. 
Java evolving quickly??????
I really don't get your arguments, as they don't have any logic. I suppose therefore you're a troll. Stay positive. Life's going to get better! Do something worthful with your time! Have a nice day m8
Objects in the java heap are aligned, compressed pointers are usually shifted left before being used since the low bits will always be 0. A typical alignment is 8 bytes, giving you 3 '0' bits so 32 + 3 = 35 bit of addressable heap space: $ java -XX:+UnlockDiagnosticVMOptions -XX:+PrintCompressedOopsMode -Xmx2g -XX:+PrintFlagsFinal -version ^ /dev/null | egrep '^heap|UseCompressedOops' heap address: 0x0000000080000000, size: 2048 MB, Compressed Oops mode: 32-bit bool UseCompressedOops := true {lp64_product} $ java -XX:+UnlockDiagnosticVMOptions -XX:+PrintCompressedOopsMode -Xmx4g -XX:+PrintFlagsFinal -version ^ /dev/null | egrep '^heap|UseCompressedOops' heap address: 0x00000006c0000000, size: 4096 MB, Compressed Oops mode: Zero based, Oop shift amount: 3 bool UseCompressedOops := true {lp64_product} $ java -XX:+UnlockDiagnosticVMOptions -XX:+PrintCompressedOopsMode -Xmx8g -XX:+PrintFlagsFinal -version ^ /dev/null | egrep '^heap|UseCompressedOops' heap address: 0x00000005c0000000, size: 8192 MB, Compressed Oops mode: Zero based, Oop shift amount: 3 bool UseCompressedOops := true {lp64_product} $ java -XX:+UnlockDiagnosticVMOptions -XX:+PrintCompressedOopsMode -Xmx16g -XX:+PrintFlagsFinal -version ^ /dev/null | egrep '^heap|UseCompressedOops' heap address: 0x00000003c0000000, size: 16384 MB, Compressed Oops mode: Zero based, Oop shift amount: 3 bool UseCompressedOops := true {lp64_product} $ java -XX:+UnlockDiagnosticVMOptions -XX:+PrintCompressedOopsMode -Xmx31g -XX:+PrintFlagsFinal -version ^ /dev/null | egrep '^heap|UseCompressedOops' heap address: 0x00007f4d19000000, size: 31744 MB, Compressed Oops mode: Non-zero based:0x00007f4d18fff000, Oop shift amount: 3 bool UseCompressedOops := true {lp64_product} $ java -XX:+UnlockDiagnosticVMOptions -XX:+PrintCompressedOopsMode -Xmx32g -XX:+PrintFlagsFinal -version ^ /dev/null | egrep '^heap|UseCompressedOops' bool UseCompressedOops = false {lp64_product} 
Ah, so the nodejs cult indoctrinated the guy. Cute and sad.
Right, but reporting a billion x speedup as the effect of inlining is a bit contrived, no? 
Hey guys! You could try this awesome source about Design Patterns - https://refactoring.guru/design-patterns
Oh, okay. Nice to know! Thanks
Java made JSF possible.
Still not sold.
I spend my time between Java, .NET, C++ and Web. Why Java is part of the list. - It was already portable, when I was still fighting for ANSI C compatibility and ANSI C++ was yet to be ratified - Very good set of standard libraries, with a very large eco-system build in the last 20 years - Regardless of the naysayers, its GUI frameworks are nice to use - Safe programming languages with GC, are more than enough for 99% of the issues I need to deliver - In spite how Google played dirty with Sun, it is nice to have a variant of it on some of my devices - I like languages that support large scale development, that favor clarity and ease of understanding over write-only languages - I don't need to care which OS I am using - The IDEs workflow, inspired by how Xerox PARC and ETHZ did language research Most of those points apply to .NET as well.
Cobol is actually quite modern. :) https://www.microfocus.com/products/visual-cobol/
Yes. You can influence it a bit: for example you can use a bigger object alignement (`-XX:ObjectAlignmentInBytes=...`) if you prefer to potentially waste space around some objects to still get compressed oops for bigger heap sizes. One thing to consider also is that different modes have different runtime costs: zero-based schemes with small shifts can be folded into the addressing mode on x86 but shifts &gt;3 or bases that don't fit in 32bits can not.
https://www.amazon.com/Interface-Oriented-Design-Pragmatic-Programmers/dp/0976694050 This is a good book. All of Ken Pugh's books are good, and he's also a great guy to. 
If it make it easier - Oracle does not provide 32-bit Java 9 builds anymore
It depends how good they need their employees to be. I am getting many job offers because of projects I was contributing to. Many companies who need their employees to be as good as possible hire this way.
Yep, lesson learned. I was more focussing more on technique itself that actual results and didn't event wanted to create impression that this is just by only inlining. Wanted to explain JIT as it is and provide some insight in it as it is not a trivial stuff and most developers are not aware of. Maybe too much aspects in one small blog post. The result for me was supernatural as well so wanted to check with more experienced people as well. Which actually happened as well. Hopefully I already fixed all those impressions and personally committed that I need to learn flight recorder better. Lot of aspects here. Thanks for shouting out!
I’m not surprised... though it was more of an attempt at a joke that fell flat. A few of the programs that I maintain are java programs that were COBOL ported to java by a former COBOL programmer (who now writes Java). That said, you’ve got to dig in order to find people who openly gripe about writing in COBOL.
Can you please post a link to that valid criticisms question? 
Looks like I should try Game Design after completing Head First. Thanks for the suggestion.
Reddit - Can I upload 10 times plz?
If you are in a "web shop", you probably won't get around Spring/Hibernate or a J2EE stack or something similar. But you won't be able to stomach all this in a week or so, if all you know is Swing. So enjoy the journey :)
Why did you "refuse" to learn Java 8 in the first place?
Laziness, lol
I really enjoyed “OOP Design Patterns Explained” by Alan Shalloway and James R. Trott. It actually turned my perspective about OOP in general.
The difference between Java 9 and 8 is much bigger than 8 vs 7. Java 8 changed how we write code, Java 9 changed how we design it.
I was too lazy to learn C / C++ so here I am... 
Because it's the number one programming language where I live, and will be for a while. 
God, no! It’s all nice for simple things, but it gets very tricky when you want some custom behavior. I would use a client side rendering framework, but even if you need server side there are a few nice ones.
Java9 breaks some projects... Not a single other project of mine has broken from 6 -&gt; 7 -&gt; 8. Honestly, I detest Java9 for all of the reasons that I need to redo things in an ecosystem where that shouldn't have to be the case (aka, backwards compatibility). To be clear, Java9 didn't break all of the projects I use, but enough to be really annoying.
Don't feel bad, I was much the same. I'm now a .stream() over-user like everyone else. I still don't know what's so bad about: for(Object o : objects) { // do things with o } The thing that sold me on `.stream` was the `.map(...)` method (not to say it's the only useful one), but it's what got me to make the jump...
I did experience some breaking with Java 8 (some overloaded methods suddenly became ambiguous)... but yes, Java 9 is worse. The thing is though, you'll probably have some JAR hell upgrading to Java 9, but instead of working around the problem you're now forced to actually tackle it. It does improve quality IMHO.
Yea, I'm excited about most of the changes, I'm just really annoyed at some of the Java 9 breaking changes. Heck, even the new versioning scheme is throwing a wrench into things. The worst breakage I'm running into right now is related to the MacOS extensions. There is NO WAY to compile the app to work with both Java9 and Java8 (keeping the same feature set like icons in the tray, etc). I've "fixed" the app by not using some things (like the custom about box) and relied on reflection to fix easy stuff (like custom icons in the tray) I know Java9's system will be better in the long run, but there needs to be a better upgrade path than what they did.
Holy crap I love what you do. You know that deeply satisfying feeling you get from throwing an old, clunky, 50s era mechanical switch? I get that same feeling from your re-implementations.
the solution emerges from the requirements, not the other way around, so obviously yes
Your product has saved my ass in the past. Thanks for making a very solid product!
Out of everything listed here in this thread, I think this is the one that's most criminal
Nice work, we need this type of projects in the JVM community. Having fast backends for number crunching brings new opportunities and will help the JVM platform get traction in the fields of AI (ml, computer vision, agent simulations, etc). How ND4J compares to Neanderthal in terms of features, usability &amp; efficiency? 
Depends on your experience. When you encouter shitty bugs, that nobody on stack overflow knows what is going on, when the PF forums don't answer and you have to patch it yourself, and when patching it, you find yourslef reading the dirtiest code you ever had. Source : happened to me.
There is a somewhat heated discussion about this on the ee4j mailing list. I have just skimmed it but it seems people aren't happy about the lack of history (rightfully so).
You have written some words, but they don't make any sense.
Please elaborate on a few nice ones.
It's good to be well rounded but you will move up early in your career by mastering one area and being competent at others. Big areas to learn the basics of: 1) backend coding 2) frontend coding 3) databases 4) server administration 5) systems architecture (microservices, SOA, messaging patterns, load balancing, etc)
It’s what my school uses for most of its classes. It’s also used in a ton of devices so learning it inside and out will be beneficial in the long run. 
7 years of commertial exp in java. Here's what i have to say Pros: * Wide spread, easy to find a job * It's fast if u know how to use it * Lots of code/libs/tools/frameworks * Great IDEs (but also kind of slow) * Functional stuff is getting popular (Streams, reactive etc.) * Documentation Cons: * everybody use spring (just admit it... it's bad... we sick of it and it will never change) * I bet you can even code entire thing in XML * too much legacy. most projects are legacy. classes that date to java 1.0 * write once - run away. Because we have android and cloud APIs * UI? Is that a thing? 72dpi font rendering for anyone * Most java devs have no clue what's going on and never care for anything new, other tend to over engineer * no fast and easy build tool
Err... What does JavaFX have to do with carrying a browser? Am I missing something?
HTML and raw JavaScript with no includes is better than dealing with JSF. I’d rather write my own AJAX handler library than use JSF. Thankfully, the current model of fully front end pages with calls to REST-ish services is way easier to maintain. Angular is pretty good, if you want a heavy library instead of a framework, there’s React. I’ve heard good things out of the clojurescript camp, but I can’t recall the framework names at the moment. Both JSF and it’s “predecessor” JSP leak between the layers of responsibility and eventually cause a big mess with maintain-ability. (Yes, vigilance works, but what happens when the guard changes in 2 years?) 
Spot on my experience with PF as well. It's all well and good when it's working correctly but as soon as you hit a bug (which is not that uncommon in my experience) all the ease and simplicity you gained by using pre-written components is out the window. I'd go as far as to say Angular is significantly better solution to the web front end problem even though it requires a bit more skill and knowledge.
Not just no, but hell no. There'd have to be some crazy reason for me to use JSF.
Can you please show me where the JNI code is?
My experience is that the other JSF frameworks are even worse. So if a customer would require JSF based project that is the only viable JSF implementation from my point of view.
Which one? The code for CPU interop with Intel MKL is in neanderthal-native. Or you are asking for interop with CUDA and OpenCL?
Debugging huge shitloads of code on the fly
Being a more native friendly alternative than a packaged browser disguised as native app.
Spring + Hibernate making my life easy
The latest non commercial release at the time which was 5.x i dont recall the minor version number
yes obviously this is not a one week thing :p but I know all basics stuff about java, its just framework/libraries that I barely know which is probably the biggest problem now
Yes other jsf libraries are worse. I am sorry your customers require a specific technology instead of stating a need and let you decicde which technology is best suited.
Yes. With JSF/Primefaces as I feel like I'm working at a higher level of abstraction than working the Javascript frameworks (though my only experience is playing with Angular). I also feel confident that introducing a new JSF/Primefaces version won't require a large upgrade effort (if any effort at all). There are times I may have to drop down to JS to do something but that is pretty rare these days as JSF/PF/Omnifaces takes care almost anything I need. Also, using Intellij I can refactor something on the front end or back-end and the refactoring will find it in both places. On a big app where I might not know where and instance is being used on many dozens of pages this is a great help.
I meant - it sounded from your comment you were saying JavaFX means having a browser along.... 
No, because JSF serves HTML and HTML should be static. HTML pages (written in HTML5) are about HTML,CSS and JavaScript. this is an ecosystem on its own. You only should care on how they get the data (possibly passed in JSON so to have a good interoperable format) And now that data comes from AJAX. So on the Java server side all you need is to be able to define a neat http API for your communication. So JSF would be the wrong fit. 
They quote, “encourages use of its own abstractions rather than fully embracing the underlying web model”, which is exactly my feelings about JSF and why it's bad. In my experience with JSF over the past 5 years once your UI needs become more complex than various input elements bound to a backing bean that serve as parameters to something that produces easily tabularized data, then JSF becomes a hugely inefficient tool to build such UI. You end up fighting with the framework to get it to do what is required, and inevitably implement "creative solutions" which don't necessarily fit correctly within the abstractions provided by JSF. Maintaining this going forward becomes increasingly difficult unless your pages are trivially simple to begin with. I've also found it quite cumbersome to build reusable widgets and components that provide common functionality throughout our app. Building the UI for any new feature is always the most time consuming, tedious, and error-prone process. It can easily take 2-5 times the effort of implementing the other functionality required for the feature, depending on UI complexity. No other UI framework I've used can come close to the to pure hatred I have for JSF. 
not yet it isn't
I want Windows and Mac users to be able to run my code. Not only: Linux and other future OSes too.
Apache Wicket
What year is it?
OpenJDK downloads - http://jdk.java.net/9/
If you are using any code that requires native libraries (dlls on windows or .so on linux), then the JRE has to have the same "bitness" (yeah, totally not a word) as the libraries to load.
The differences between Oracle and OpenJDK are getting smaller and will eventually disappear.
Would you rule out all sever side rendering frameworks? I feel like there are some advantages to them, like maybe better SEO and initial page load. What about isomorphic apps? 
not all chapters are relevant but I guess 75% will atleast be.
For Java Server side development. My approach is that is that if I am building heavy form based applications, I would go with JSF. If I am building a heavy interactive experience applications, I would consider an Action Based MVC framework.
That's an interesting point and now it's not with just ranting about the new technology. Do you have any fundamental informations except your own "physical" study for that or is it just something you created? I personally don't think, that's true, tho. My counter argument is, that I can use abbreviations like PoE and (given in context) someone knows the meaning of PoE, it's wired to power over Ethernet, and ingrained in the brain what the principle is. So if you type sout, your intent is another than typing sout. You want to put something onto the console, whether it's sout, system out, or printf, heck, name it xxx if you want. The effect of sout is wired to "output" same as printf. May I just didn't understood your argument correctly tho. In this situation I may ask for more information, if you aren't annoyed by my lack of understanding.
Enterprise consulting, desired technology stack is part of the Request For Proposal sent to companies selling consulting services. Which is quite understandable, they want external companies to be able to work with the tools their developers are familiar with, not having a guy bringing in whatever tech that 3 months later no one knows how to fix. 
Adopt OpenJDK downloads. https://adoptopenjdk.net/index.html https://adoptopenjdk.net/archive.html?variant=openjdk9 https://github.com/AdoptOpenJDK https://github.com/AdoptOpenJDK/openjdk9-openj9-releases https://github.com/AdoptOpenJDK/openjdk9-openj9-releases/releases Scipts for creating Docker images of OpenJDK binaries. https://github.com/AdoptOpenJDK/openjdk-docker 
Apache Wicket is very close to JSF, but is less used and has less activity.
&gt; which can clash with Java 9 modules. Fortunately, this has a solution! Include "--add-opens=java.base/jdk.internal.ref=ALL-UNNAMED" in your JVM options if you use these libraries with Java 9 Sorry but that's not a solution. It's not a problem of the library though and there's nothing you can effectively do, expect trying to make it work within the bounds of the Java 9 restrictions. Also Clojure libraries tend to be extremly awkward to use in Java.
Community builds using source code from OpenJDK project https://github.com/ojdkbuild/ojdkbuild
Zulu® is a certified build of OpenJDK that is fully compliant with the Java SE standard. https://www.azul.com/downloads/zulu/ 
Are you capable of reading? If so, the **sidebar clearly states:**: #Do not post tutorials here!
FYI . . . Red Hat also has prebuilt binary downloads, but I don't touch them since they require my personal information in order to harvest my vital organs. But if you're okay with that you can google it and download. 
I had great optimism there for a moment until I realized that you meant "the differences" would disappear rather than "Oracle" would disappear. 
Raspberry Pi runs Java, within its hardware constraints. At home I use Eclipse / Java on Linux, and the same at work but on Windows. It works the same.
Yes. Java IS the Cobol of the 21st century. And for the same reason. The sheer volume of enterprise software. The total economic value of that software is so huge that it would be unthinkable to try to rewrite it anytime soon. Like Cobol.
I can't ever see there being a compelling case for JSF on a greenfield project. In general i personally don't like java EE and stick to spring and it's derivatives , i'm not saying that java EE is inherently bad or shouldn't be used but given my preferences and style I just don't like it that much. 
We make use of the Facelets! Is very good, I think is better than Thymeleaf no? Is sure use less memory huh? 😝
Is you use JSF 1 maybe? Is JSF 2 embrace web, and no it have not abstraction for css!
Why?
Give me Maven over Gradle all the way. A build tool that does not use a sane fixed-schema configuration (XML, Yml, Json, hocon, choose your poison), but instead offers you a touring-conplete freedom, is destined to be abused continously. And this is exactly the same problem I face everyday at work with Jenkins and his "groovy-ish" jenkinsfiles written by my inventive co-workers... Thanks god we are slowly introducing a saner approach with GitlabCI (which uses Yml)
I am having trouble understand your question. Which point were you referring to that you found insteresting? Which statement is in question (that you personally don't think is true)? 
As much as we all want to hate on Oracle, they have been warming up to the open source community a lot for whatever reason they might have. Maybe they like the free labor, maybe they actually care, who knows, but at least the net effect is more openness.
* It's temporary * It's a JVM options. Most have no control over their customers JVM * Complicates deploy * It completely runs counter the module system: you don't want to open up the JDK internals for some 3rd party library
All these points are relevant. However: 1. This is *a* solution. Not a perfect solution, but a solution. 2. Every library for HPC, big data, etc. has the same issue, and all other solutions that I've seen are even less perfect.
1. neanderhal-native on github 2. JCuda on github 3. JOCL on github
We're currently using JSF 2.2 with Primefaces 6. I imagine the abstraction being referred to, at least what I refer to, is the JSF request/response lifecycle: [Lifecycle](https://bansihaudakari.files.wordpress.com/2009/03/jsf-lifecycle.png?) 
Pardon me but what is that?
I hear you and I know the problem (all too well really), but with JSF and Facelets it’s much more difficult to put business logic in the view. It’s a best practices to largely use the same type of service calls you would make when on the client from a JSF backing bean. In fact, you can even use the JAX-RS client API really well from JSF backing beans. The advantage is you’re doing server to server calls to servers that are likely (very) close to each other, so if you need to do multiple service calls (very likely for a full page) the total latency can be much lower. You also put less stress on the client’s device.
Way too much abstraction between html/css/js. 
Has it ever dawned on you this is essentially what each and every framework does? JSF just gave it names and some people made a diagram of it. But every framework loads a template or has an option to do, every framework can grab the request parameters, every framework allows you to validate whatever the client sends you, every framework has something to let you call your service code, and really... every web framework eventually generates a response of some kind.
2018 The year that JSF has been going at it for some 15 years. A time period the current crop of frameworks can only dream of (they’d be happy if the last for 15 weeks)
And all of that doesn’t happen when you encounter an obscure problem in Angular 1? Or Spring 3? Did you ever had to debug those? I did, and honestly it’s not pretty either.
Angular, that changed completely between 1 and 2? But also, have you ever noticed how much Angular was inspired by JSF? With the difference you have to deal with JavaScript when doing Angular, which even its biggest fans admit it horrible.
OmniFaces is a pretty good companion to PrimeFaces, so you gave 2 good libraries ;)
Of course! Nothing is as adaptable or deadly as a Joint Strike Fighter. 
This talk is pretty good - lots (lots!) of detail about the rationale for the design of Optional, patterns and antipatterns: [The Mother of all Bikesheds](https://www.youtube.com/watch?v=Ej0sss6cq14)
(if you're wondering about his laptop stickers, check this out: [Hodor](https://www.youtube.com/watch?v=seYS8TVKTcY))
Pretty much what I understood as Java noob trying to learn something from conference talks.
Oh man I guess that's frustrating. Do you think there is a lack of conference talks for noobs? That's something the Java community ought to address IMHO.
The compiler in general is a beast, the fact you can run a program modify its code and see that code get applied while the program is running is insane.
https://www.reddit.com/r/java/comments/7qdrjg/what_are_the_valid_criticisms_against_java/?utm_source=reddit-android I should have shortened the link but I'm currently on mobile. In any case its well worth a read.
https://www.reddit.com/r/java/comments/7qdrjg/what_are_the_valid_criticisms_against_java/?utm_source=reddit-android I should have shortened the link but I'm currently on mobile. In any case its well worth a read.
From this "This is the final planned release for JDK 9. Users of JDK 9 should update to JDK 10 between its release in March 2018 and the next planned Critical Update Release in April 2018." I got the impression that we'll need to get up to date or left behind (as in no more updates to "older", say a year old, versions) in the new six months schedule. Can anyone enlighten me on how it will be?
It doesn’t really map http to a component model that directly. All the urls map to views, which is not different from most other things out there. At the plain URL level there’s no component mapping. You could theoretically do that in a component framework, but JSF doesn’t do that. Links between views are plain GET based links, and for form POSTs it’s the well known PRG pattern, which doesn’t map to any component. Incoming request parameters to views aren’t mapped to components either, eg example.com/mypage?param=1, there’s no component mapping their either. Yes, JSF 1 didn’t had that, and gave JSF a debatable reputation, but this is what JSF supports and advocates since 2.0. JSF *is* a component framework of course, so IFF you use components, then the parameters posted back by those finally DO map to components. Is that so crazy? I don’t think so. If you have a non component based template it can be an issue to distinguish between the different parts of the page that caused data to be sent. If there multiple tables with multiple rows, user clicks something, how do you know what was clicked? I’ve seen action based framework users ask for things like ID management, which is essentially what JSF does. Just saying. 
I would always choose Java in a heartbeat.
Which abstraction? How is css being abstracted from in JSF?
&gt; don't wire the written code to the seen code Are you sure you meant "wire" and "seen" in your sentence? I am very puzzled in what you mean here. 
Guess I absolutely don't get your logic. You say I can't read my code properly, because I'm used to write sout, but there is system.out.println So what you say, if I'm not wrong, is that I wired(associate) the output meaning (in my head) to sout, and not to system.out.. Maybe I'm just to sleepy to articulate my problem properly. ^^
I don't think you're getting why static HTML is recommended for SPAs. Static HTML is recommended for SPAs so that the application can take advantage of HTTP caching. The browser only needs to download static assets like HTML, CSS and JS once. By using HTTP APIs, updates are data driven with lightweight formats like JSON, which are a lot easier to parse than HTML. If you design your front end correctly, you only need to parse the HTML template once from the browser cache and keep the HTML "compiled" in memory, so you don't have to parse HTML again, significantly improving front end performance. This style of app development is called [app shell](https://developers.google.com/web/fundamentals/architecture/app-shell), and is the current trend of SPA development to specifically optimize applications for mobile devices, allowing the application to work in both online and offline scenarios. The problem with JSF is that HTML is dynamically generated on the server, making it impossible for the browser to cache responses. Although, since facelets abstracts the rendering process, there is nothing that says that JSF *must* dynamically render HTML, and it is possible for JSF to generate an app shell for you. But at this level, I'd rather work with the browser natively rather than through a Java-oriented abstraction.
[Betteridge's law of headlines](https://en.wikipedia.org/wiki/Betteridge%27s_law_of_headlines).
Non-Mobile link: https://en.wikipedia.org/wiki/Betteridge%27s_law_of_headlines *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^138925
Thanks for clarification. Surely sout existed in your process at some point, right? Whatever its role is, it is lost as you commit to code. And there won't be any clue for a third person (or yourself) at some later time, potentially without or with a different IDE, that sout ever existed.
https://projects.spring.io/spring-cloud/
Node.js dev chiming in here. I've recently started learning Java. People really talk a lot of trash about it, but I really like it so far. It's a truly nice language and ecosystem. It's also nice not wondering how long x library will be supported. Just programming in Java as a hobby right now, looking to do some Android development, but I have more reasons for why I chose Java. There's also a few really cool companies where I live that use Java that I could work for in the future.
The thing I dislike most about electron is that when you think memory usage isn't so bad, you look at other processes and see more instances of the said electron app even when you only have one instance of it open (like Chrome).
I’m here, buddy
Depending on other work he does, VS Code could prove to be more flexible.
Master it... 8+ years. Convince someone to pay me to write it ... 6 months
Thank you for posting this! I always wanted a good way to get the OpenJDK for Windows, but other providers were kinda iffy.
You will start to feel very comfortable with Java after 2 or 3 years, but you will still not be able to build anything extremely complicated until 7 or 8 years. 
We're a small team and pretty invested in JSF and PF, we don't have a frontend guy let alone team, so the article rings true with me. We were attracted to the platform and especially Primefaces years ago because it did help us establish a look and feel that looked reasonably professional with little effort. It's been all pretty great for us, building up our own components over the years, but lighter frameworks are somewhat attractive. PrimeNG seems to be maturing well, just not sure we have the time right now to even consider changing.
Damn I must be doing something very wrong, I have been unable to find someone to pay me write java code, and I've been around since the 1.4 days. Seriously though, exactly how do you get a company to actual take your application seriously without a CS degree?
Local variable type inference will be here in March!
Time to move on to a project-based approach. Make a GitHub and just dump everything you're writing up there. If you want more spammy job opportunities, make a LinkedIn. Put your GitHub up there too. You will get e-mailed often by recruiters. It will take some time, but it's a good long term strategy. I don't think solving coding problems on hackerrank will get the job done on its own. Another thing you could get into is Kaggle, but that's a conversation for another day.
Are you capable of reading? If so, the **sidebar clearly states:**: #Do not post tutorials here!
My journey with java started with c... Then c++... And 3y into my first job as a java dev. I can say it will be at least another 3 before I even dare consider myself a master
I own them all. Does that count?
**A for effort**
Im on mobile ao perhaps I didnt see it but is edgeware a project like spring cloud zookeeper or is it just another name for spring cloud family of projects?
I am a beginner,I want to see the list but i cant open the link,could someone comment me back the list?thanks!
I've been working with Java since '98 but I'm never going to claim I 'master' it. "Knowing" Java is not just about the language anyway, it's also about the ecosystem. And there's so much stuff happening that you can spend the rest of your life learning new things. 
Show recent relevant projects on you CV. Show that you know about the ecosystem around it. CS degree helps to select between you and that other candidate. And put Java as a skill on your LinkedIn profile. Follow some tips to write a good LinkedIn profile. They use keywords to search. 
I agree from 1 to 5.
The plan is to have LTS releases ("long term support") which see longer support by the JDK implementor. The next LTS release will be Java 11 (scheduled for September this year). You can find more details in [JEP 322](http://openjdk.java.net/jeps/322) ("Time-Based Release Versioning"). So if you are on Java 9 right now, you should upgrade to 10 and 11 in a timely manner once they are out, but then could remain on 11 for a while, seeing updates for that for a longer period of time.
thank you very much!
&gt; And all of that doesn’t happen when you encounter an obscure problem in Angular 1? Or Spring 3? When I say debugging JSF is shit, it does not mean debugging other frameworks is easy. You just made that up. &gt; Did you ever had to debug those? You are sweet :) Yes. Angular is different than JSF as it is a pure front-end framework, you only need to investigate the js/ts part, which are simple to describe as a concept. Debugging JSF? The framework is infinitely more complex, there are phases, and each component of the tree has something executed in each phase. So yeah, debugging JSF is not easier. That does not mean that Angular &gt; JSF because that would not make sense, it totally depends on your project needs and your resources skills. Spring? Dude, this framework makes sense. It is complex, and you need to understand the base concepts, but it is a clean framework. I usually never have to debug Spring because the framework works as expected, when I have issues, I just try to fix my configuration.
oh, I understand better and it makes total sense.
I am in china,my network maybe blocked😐
Some of the Spring ecosystem projects are umbrella projects that incorporate a set of modules, like Spring Data (JPA, MongoDB, Redis etc). Spring Cloud is one of them, too. These umbrella projects use a release train model that in turn uses a naming scheme. Spring Data uses famous computer scientist's names, Spring Cloud uses London tube stations, Spring IO Platform uses European capital names etc. Actually the project website's usually explain that model https://projects.spring.io/spring-cloud/#release-trains
Java changes faster than it takes one to master it. There's just incredible amount of stuff to learn. Basic language features like loops and syntax are the easy part. I've written it professionally 6 years now, but in total written it close to 8 or 9 years, every day at work I learn new things about it or see classes and packages in java SDK what I've no idea about what they are used for. It's like more you learn about it, the more you discover you still have to learn.
worth pointing out that they are all oldies... (note: I am not criticizing that aspect, just pointing it out)
Thanks! 
I have really been thinking about doing just that. I’m worried it might be too specific and I would run out of topics. Maybe Java based with a focus on Spring 
I just saw this now. How is that any different than a shortcut you have in your brain for e.g. sout to autocomplete? You're doing the exact same, generate code by macros. But even worse, you 'compile' your OWN language, which noone can read except yourself to java. Which then compiles the code to bytecode.
&gt;Spring? Dude, this framework makes sense. It is complex, and you need to understand the base concepts, but it is a clean framework. I usually never have to debug Spring because the framework works as expected, when I have issues, I just try to fix my configuration. Yeah, sure... Spring has tons of bugs as well and tons of things that don’t just work. I hear the devs down the corridor curse about it all the time. And if Spring is so clean and wonderful and free if bugs, why do they even have a bug tracker?
`JavaScript != Java`
First one is the hard one to get. After that it becomes easy. 
I've start learning programming at 29 and got first job after 7 months (about 4 hours a day) when I passed OCA exam.
Looks like we found the literal guy here. Of course no software is bug free, you have to put things in perspective, compare the stability of this framework to others. 10 years of experience lead me to conclude that Spring is the most stable Java framework I have used.
As with many of OP's posts, the above link has nothing to do with Java.
This is one of those things that is somewhat annoying that it is brought up time and time again. "OMG, you could return null!". Yup, you could. But here is the thing, in some cases that is desirable. In particular, a cache. null == I've never seen the key go load it. Optional.empty() == I've seen the key, it isn't there. Optional.of(thing) == I've seen the value, it is blah. But the other case, the bad ones? Well, I've just never even seen them take place. I've never seen someone return null from a method that returns optional. I've never seen someone pass in a null to a method that takes an optional. I've seen some really REALLY shitty code. Mutating collection parameters, horrible inheritance hierarchies, returning null instead of an empty collection, Doing something different with an empty collection vs a null collection. I've seen those things! But I haven't seen anyone return null for optional or pass in null for an optional. At this point it is all worrying about something that just isn't a real problem. There are bigger fish to fry in the language than the nullability of optional.
In that case, a better headline would be "Does Optional let you say goodbye to NullPointerExceptions?"
Yeah, and I don't understand the problem why you want the real source code, which is, in fact java. Im just to lazy to write verbose java. I don't want to argue with you anymore. I wanted a bit of source long ago which will give your arguments weight. Til now you didn't deliver, and I don't think I agree with your point. I accept your perception, but I don't agree with that. 
Scam! I read through author's description of Clean Code and Code Complete. These two books are in my favorite 5 list, and are definitely the top two that I quote from. This statement shows that the author did not read Code Complete at all: &gt; This book is similar to above book but it's mainly for C and C++ developer while Clean Code is for Java developer. Except that both are about software, Code Complete and Clean Code are not similar in any way IMHO. In addition, Code Complete contains examples in Java, VB, C and C++, and in no way is intended to be "mainly for C and C++ developer". Also, saying that "Clean Code is for Java developer" is a totally misleading statement. It's like saying that Harry Potter is about English... Author definitely did not read Code Complete, and, probably, neither Clean Code. This looks like a very lame attempt to make some affiliate bucks from books that the author himself never read. The link to a paid course at the end only reinforces this feeling... 
The javafx scene builder [1] is what you are looking for. As far I know it is now maintained by Gluon [0] [0] http://gluonhq.com/products/scene-builder/ [1] http://www.oracle.com/technetwork/java/javase/downloads/sb2download-2177776.html
Refactoring by Martin Fowler is very good together with clean code.
If you are a junior programmer I would advice to get it. You will learn from it and learn some details about Java. When you work as a consultant, and might give you the deciding factor between 2 parties. Not necessary, but could be a plus to have it.
I was never arguing. I was merely explaining. I have no interest of making you agree. I am only interested in explaining myself and to understand the peculiarity around me.
thanks for help
I suspect we'll only ever understand in hindsight what this all means.
Very clear explanations, thanks a lot.
"Oracle does not support or recommend the use of the JCP (Java Community Process) for future Java EE enhancements. "Oracle recommends and supports the use of EE4J-driven processes for functional enhancements to Java EE 8 specifications, and does not recommend or support use the JCP process..." * No JSR for Java EE 9 * JSR 366 was for Java EE 8 * JSR 342 was for Java EE 7 So they're saying they're not using JSRs...and the JCP, they're doing it through the Eclipse Foundation.
&gt; no-one responds to applications If you aren't getting hits on your resume it's your resume that is the problem. Seek professional help re-writing your resume.
Saying Clean Code is for Java developers is definitely not misleading... there are whole sections on Log4j, JUnit, internals of JUnit, and AspectJ. And some other sections are only really applicable because the nature of how Java works. Yes, developers of any language can benefit from reading it, but it’s definitely a book for Java developers. 
 &gt; But here is the thing, in some cases that is desirable. In particular, a cache. null == I've never seen the key go load it. Optional.empty() == I've seen the key, it isn't there. Optional.of(thing) == I've seen the value, it is blah. For me, Optional clearly models only two states: empty and not empty. In your example, I personally see three states. Why not just create a custom value object like CacheResult with a state property to indicate a cache hit or not?
Make some projects, like a Football database of the English Premiere league teams by making a web app or desktop app Upload it to github, post screenshots in the readme, add it to your resume/job app doesnt have to be production ready, but suitable enough so that I can see you solved a CRUD problem because a huge amount of Java related jobs are just CRUD
This might help - some free examples and Java code examples, I've had it bookmarked forever https://sourcemaking.com/
"Mythical Man-Month" should be number one.
Imagine you are implementing a cache. How would you use CacheResult to indicate data not available if the value has not been seen in the map before. Now, how would you do that without double locking the map. You don't have to expose externally that you are dealing with nulls and optionals, that is an internal implementation detail.
There's not only chrome headless, Firefox too has headless mode :)
I wouldn't suggest he looks at JVM monitoring and performance metrics until he understands data structures and designs a bit better. There are more important fundamentals
Eclipse Che is probably your best, if not only, option. You can use [Codenvy](https://codenvy.io) online and have everything run for you. It's pretty good, though not as good as a proper IDE. You could also try running IntelliJ in a docker container and starting it with X forwarding on, though I don't know how well that would perform.
Yeah, but what does this mean? Is Oracle going to put more effort in the process? Or less? Will things move forward faster? Or slower? It's pretty hard to have an opinion on this Java EE to EE4J change (yet).
idk, I already own a Design Patterns book in C# that I use, but this site is useful to check in every now and then to refresh my mind
One of the side affects of all this is Oracle not allowing the usage of the javax.* package name going forward. This is a real mess as the existing JEE APIs and any new stuff will be unnecessarily split over different package names. Basically, Oracle torpedoing the whole thing.
Hey Bob, I really enjoy watching you streaming. I am doing many technical interviews for company I work for (very old company from travel industry) and I would hire you as far as I was watching you doing code fights tasks. 
I read it, but typically had to be drinking whisky at the same time. If you get that Balmer peak going then it reads better. 
Agreed. One thing to add is that you do not have to read books like it through cover to cover. Rather, I recommend reading the beginnings of each pattern to understand what problem it addresses and how the pattern works. Then, only read all the rest of the details if you need further clarification. Really, the concepts are what is important... 
Yes, when we finally get value types. Until then, yes it is going to be a bit of pain.
This is definitely a reason that I use it!
IntelliJ has it built-in as I remember.
I've only had experience with IntelliJ, but I find that it is so resource heavy. Don't get me wrong. It's a great tool for some people. Just not for me. I am more of a text editor, and terminal kind of guy. Inherited it from my dad. I also recognize that IDEs can be extremely useful, so I like that VSCode is kind of a happy medium :)
Standalone is better. The one embedded in IntelliJ is laggy as hell
"The Phoenix Project" and "The Lean Startup" restored me some faith as well, although first one is a bit fictional
Last I checked (half a year ago), both Chrome and Firefox headless modes still require xvfb. So PhantomJS still has an edge in the overhead arena. Tho the use case is smaller and smaller, as you rather move to Node for unit test, and Chrome/Firefox headless for end-to-end/integration test. 
JavaFX.
&gt; It is hard to implement responsive rich UIs with JavaFX I can't take that article seriously when it includes that bullet point. You will always be able to produce much richer GUI's with JavaFX and/or Swing than you will with web technologies like html/css/js. Mostly because manipulating a text based DOM to produce rich GUI's is, at best, a dirty hack. 
NetBeans This YouTube channel will make things clear https://youtu.be/HqjeeTMjMTU
Definitely I would put the cornel somwhere in a ten book selection it teaches a lot of fundamentals which are helpful in my programmer life I did not like clean code at all.
oh come on..
I’ve had the same issue! It’s really tough to try and job search when you’ve spent all day already working. I actually ended up finding this pretty awesome tool where you sign up and the website matches your experience for you, so you don’t have to job hunt or apply to roles. I think they use some kind of AI technology and the roles I got matched to were amazing! If you don’t want to do the actual job search, but want a new job, this is the perfect place – [Skillgigs.com](https://www.skillgigs.com)
What's the advantage of running headless? Also how do you take a screenshot on a headless browser?
1. You look more like a "real person" 2. You can do more with JavaScript heavy sites and single page apps 3. Check out puppeteer https://github.com/GoogleChrome/puppeteer/blob/master/README.md#usage
It should be noted that Codenvy *is* Eclipse Che and they contribute to the project. OpenShift.io also has its own version of an IDE developed by Red Hat and probably using Codenvy bits since Codenvy is owned by Red Hat now. Anyway it’s pretty slick. Implement/build/test/deploy all from your browser.
Depends on if you're scored on total runtime, or amount of "stuff" that gets done within the allotted time. If either is true, use C or C++ (or anything that compiles to a native binary) to avoid the startup cost of JVM warmup, bytecode interpretation, etc. Otherwise, use whatever language you're most comfortable with
C/C++ is so fast that sometimes slower algorithms written in it outperform faster algorithms written in Java. Java's runtime optimization (JIT compilation) takes longer time to archive its best than progrraming competition's ordinary time limit (a few sec). I recommend using C/C++ if you only focusing on better score.
[removed]
My experience with Java in competitions is good so far, most competitions don't take startup into account (pre-warmed jvm). If you still have doubts, I was regional champion twice.
Why is javax or any package name so important it can torpedo anything?
If you're a fan of balusc, check out https://github.com/omnifaces/optimusfaces
It depends what the challenge is about. Most of the competition are like "can you write an algorithm that solve problem X in less than Y amount of time" where Y is achievable with any language. The language you should choose is the language that you are the most familiar with so you can focus on the actual problem rather than how you code it... Java performance are very good in general so you shouldn't care about it unless the challenge is "whoever writes the fastest program wins"
As I said, I often use Clean Code as a reference and a source of quotations. However, I didn't remember "whole sections on Log4j, JUnit, internals of JUnit, and AspectJ". Luckily, I do own the book, which makes it very easy to check myself. Log4j is only used as an example of a third party library that can benefit from writing some unit tests against. So-called "learning tests". Chapter 15, titled "JUnit internals", is not about JUnit. It shows how to refactor good tests into outstanding tests using one of JUnit's internal unit tests as an example. AspectJ is given as an example of AOP framework in chapter 11 "Systems". There are 13 lines of text dedicated to it. I will say it again in order for readers to have a clear picture: Clean Code is not intended for Java developers specifically, it is not about Java, and no prior Java knowledge is required in order to read this book. Clean Code only uses Java in order to demonstrate general concepts in code, and all programmers who know what OO is will feel completely comfortable reading these code samples. 
Depends on whether you're using vanilla java or Java + framework. Either way, I think for hackathon and stuff, Javascript/Node would probably serve you better being lighter and also more suited at hacking things together. That said, you should use the language you are most familiar if time is tight.
It would be awesome for many people although unfortunately there are too many java devs who currently don’t use switches and stay away like it was a plague 
Yeah, I setup a [project](https://github.com/udebella/facratio) where I run my unit tests on firefox headless on Travis CI. It was really simple to setup. But don't read the code, that's garbage :)
Yes, my only grief about Oracle open sourcing all of this stuff is that they still keep all of the trademark names, causing these headaches.
[The previous discussion on them](https://www.reddit.com/r/java/comments/7j9s30/jep_draft_switch_expressions_for_the_java_language/).
I skimmed the JEP and could not find whether `switch` *statements* are going to be improved as well. I mean, there is this: &gt; Extend the switch statement so that it can be used as either a statement or an expression, and improve how switch handles nulls. At the beginning, but I could find nothing that explicitly talks about improvements to the statement, only about making it an expression. Does somebody know whether `switch`, as a statement, will get `null` support? 
Well `break;` will be optional in the expression form, so that is an improvement. What exactly do you mean by `null` support?
Currently, `switch (null)` for strings and enums will always throw NPE. You can't write `case null`.
That is probably because the default fallthrough mechanism is counter intuitive, and it ends being a pain in the ass having so many breaks. With this change, I expect previous use cases that were handled with if conditionals, can be morphed into using a far more descriptive switch expression.
Yeah, I figured he was referring to those cases. Do you currently know how the enhancements will address this?
&gt; You can't write `case null`. Curious: Why not?
Yes, good point. Just realised my comment doesn't really make much sense without making that clear!
I'm not quite sure, but isn't it possible to install IDEA in your docker, and just access it using SSH X forwarding?
Does a “candidate” jep mean it’s ready to be merged into a release or it has qualified the strawman phase and ready to be implemented?
You can write it, but it won't compile: "constant string expression required".
The project the article is describing is written in Java.
Odd example. They should have used one that shows a real usecase of switch expression. This one cries "bad design".
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/onedrive] [Eclipse IDE and OneDrive](https://www.reddit.com/r/onedrive/comments/7ri06m/eclipse_ide_and_onedrive/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Wait, you do realize that when you type "sout Hello World!" and press enter it literally gets converted to 'System.out.println("Hello World!");' on that very instance? "sout Hello World!" is never saved in the file, so never pushed to the repository and no other preprocessor needed as well. That's literally what autocomplete is, just keyboard shortcuts for typing out larger statements in the file. Maybe I didn't get what you were trying to say. I just didn't understand your point about can't push to repository. Correct me if I'm wrong.
Has someone proposed it?
Sounds like a OneDrive thing but I'd recommend looking at some form of version control instead and one the providers e.g. GitLab, GitHub, Bitbucket.
You are a full time troll, aren't you?
I noticed. My question stands.
RxJava is nice. Tried that, like that. Would like to smt like that (if return to java). Have you tried other implementations of Reactive streams?
Username checks out.
It's odd to have `break &lt;value&gt;;` be the return statement from a branch expression. Why not use `return`? 
Because that has existing semantics, and it is useful. 
can you be more specific? are you talking about order-matching engines? how about trading bots or perhaps data distribution &amp; handlers?
Jetbrains removed it because it looked like shit when embedded and had lots of bugs when embedded
Yeah agree, but these books are also important to cover code level efficiency. These things are equally important. Software development is like craft business. We need to look into minor things as well.
it literally talks about null support in the linked article :P
I was referring to the exact IDE process that you described, that is good. You also got exactly the point of 'can't push to repository', that is good. Now I assume you understand the benefit of repository -- not only it keeps record of your coding process, it provides a base for peer and your self's review. If you don't understand the importance of review on the progress, I could comment on that (just indicate). I took the importance of writing down, repository, and review as granted, which probably is the source of your puzzle. Now why don't I try another analogy. Since the dawn of chat and especially smart phone, we are now very familiar with words such as "LOL". Originally, we simply meant to be a auto-complete although the IDE that does auto-completes are our brains. If the program always auto translates LOL, dictionary will never have this word, and our language will stay the same (just as Java did). Well, in reality program at that time don't have this function so LOL etc. gets written down and gets read and reviewed as is. Now not all shortcut or slang catch on but a portion of them do and the language -- the way we expresses our idea -- evolves. Nowadays, LOL don't necessarily mean literally "laugh out loud" and even when it does, it has additional annotation. Now contrast to IDE. "sout" never gets recorded, its usage is contained -- in fact, different IDE use different shortcut. "sout" is not custom controlled, and can't be extended, -- can't use sout for logging or with formatting. And above all, to the effect of language, sout never existed. So while IDE initially gives you convenience of less typing, it blocks progress, both your personal progress and the progress of programming at large. 
15 years with Java EE lead *me* to conclude that that one is the most stable framework, based on JBoss (Wikdfky) first, then Liberty too and recently Payara as well. In JSF pretty much everything is replaceable as well.