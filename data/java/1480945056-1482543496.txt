&gt;You think you can wear a suit regularly for years? Nice job singling out a single example of what was said. Let me quote it for you since you can't seem to remember: "Dentists and doctors buy a shit ton of equipment." To answer that question, definitely, they can be used for *many* years. &gt; You think you have to pay JetBrains every year? They changed their licensing model last year to be subscription based. So abso-fucking-lutely. &gt;You think JetBrains have no infrastructure cost associated with scale (not that it is relevant). Definitely. They don't need to scale anything at all. What, serving disk images? It's called a CDN, it scales linearly. &gt;Ides are expensive due to no competition? Java ides are normally free. Yeah, and there's a handful of them, and most of them are terrible.
More people using = more bugs found across more varied environments = more support = more money to pay developers Also they keep adding features = more software surface area = even more support It pains me to see devs complaining about the price of software. It's like watching a person, sitting on the limb of a tree, sawing furiously at the limb they are sitting on. Management will always think the way to cut software costs will be to hire cheaper developers. They are wrong but that's the way they go.
OMG... &lt;sarcasm&gt;That never happens in the real world! Why would anyone ever tolerate that? It's unthinkable!&lt;/sarcasm&gt;
&gt; More people using = more bugs found across more varied environments Hah! That's some comedy gold right there. More users == More Bugs. Incredible. &gt;It pains me to see devs complaining about the price of software. It's like watching a person, sitting on the limb of a tree, sawing furiously at the limb they are sitting on. Management will always think the way to cut software costs will be to hire cheaper developers. They are wrong but that's the way they go. And management needs to "cut costs" for a very successful/profitable project.... why? Tell you what, I work for a very large web site that you've undoubtedly used: I bet you use an adblocker, and are willing to brag openly that you do.
Yea, don't mean to sound dramatic, but it's honestly a massive mistake if you plan to scale the application. My company is hurting badly because of this solution, it's impossible to keep developers around hammering sql solutions, nobody wants to do this stuff.
&gt; shared mutable state is the root of all evil. wrong &gt; In nature there is no mutability Thats an opinion. A philosophical question at most. Mutability feels more natural than immutability to me (same as recursion) and probably 90% of people in this world.
By having at least 1 year long subscription you also get the discount and perpetual license. https://sales.jetbrains.com/hc/en-gb/articles/207240845-What-is-perpetual-fallback-license
I wish I was very clever, but at best I'm moderately not-stupid. Thanks for the advice, I'll just take the few kb per image storage size hit.
I'm not sure I understand how it is cutting down on the size. Are you programmatically generating the image or is it a pre-rendered image? Having the context blit the image would most likely be faster since they incorporated many performance features in. But if you don't want to ship with the pre-rendered image you could also render the image to a file on boot and read that later.
&gt; They're charging more simply because there are no other viable players, it's called a monopoly. They're not a monopoly; not by far. I'm sure the number of installations of Visual Studio and Eclipse alone probably outnumber them 10 to 1 at least. That said, they are without peer from a feature coverage and depth standpoint. Eclipse comes somewhat close because of the ecosystem, but you have to Frankenstein that together yourself. 
I'm creating a custom image file type that just stores the color data and alpha data from a png, with a bit of custom compression built in. (I say custom image file type, but it's just an array of hex codes and booleans stating alpha data). Obviously this wouldn't be compatible with graphics.2d so using this method I would have to come up with my own solution. This isn't anything I would do professionally, it's just something I wanted to try out of boredom.
For a junior dev position? Keep in mind, we're generally hiring kids out of pretty good colleges. If you were self-taught, you'd get a bit more scrutiny/have to prove yourself more. You'll need to be able to speak intelligently about programming, oop, and java topics. We go a little further than the interview lists you can pull up online. You'll be asked to program solutions to a bunch of simple problems, like list reversal, etc. The hardest part (this is where most of our prospective candidates fail) is something I put together about a year ago that is a singe tier, multi-service application that is deliberately broken. You're given a series of unit tests that expose progressively more complicated bugs that you need to fix. None of them are crazy, but you need to be able to think about things systematically to get the last ones. We're not looking for accomplished developers. We're looking for people with the background skills that can think through problems, work hard, can learn, and will listen. We're more concerned about how people think and react to new information than their specific application skills. "Needs to know Java EE?" Jesus, I don't need people to write a full n-tier application. We already have one. I want them to understand how that sort of application works at a mostly high level, but if something needs to be done at the application level, it's not going to be our junior devs driving that work. I need junior devs to be able to, under the guidance of a team lead, take specs and turn them into working rest and service code that doesn't suck and are able to test and debug their code and others. I train my people up into the more complicated stuff, because I'm an expert at it. When they can handle it, they get promoted to devs or senior devs.
It's something all software companies have been doing for decades. Supporting your product after you release it is part of the original cost. If you release buggy code, it's your duty to fix it after the fact. If I buy a new house and it's full of problems, the construction firm that built it better fix all those issues, and for free. If I buy a car and it has all kinds of bugs/defects that are not related to my use, they better replace/repair it... FOR FREE. With subscription-based licensing (which Jetbrains switched to recently) they now charge me to get bug fixes on software I already paid for.
One skill that I look for that a lot of candidates are deficient in is actual decent SQL knowledge. With most of the projects that people work on now being based around ORMs, a lot of kids don't learn how to actually work with or think about data. Another one is debugging skills. We put a lot of emphasis on being able to write code, but the reality is that a large chunk of time is going to be finding, fixing, and testing bugs. You should know how to use a step debugger. I find that at least a third of the problems posted in /r/javahelp wouldn't be asked if people actually knew how to debug.
Look ma'! A retard!
I think most times that we decide to roll our own X we tend to eventually reimplement a standard thing that already exists. My approach is always to do these out of fun by never use in production. As such, performance really shouldn't be a concern for you then.
Do you have any resources that you would suggest people read?
might get awkward with `getChild().handling()` :/
You two remind me the beavis and butthead show
Yes, well, now you're complaining about the entire industry. Your complaint is hardly unique to JetBrains. Also, if you actually try to invoke warranty for all sorts of little issues for houses/cars, etc. I think you'll find your warranty runs out fairly quickly and provides little recourse for non-recall issues found after the 1 year is up. Oh, and with subscription based licensing, you're not buying software. You're paying for the rights to use the software under the terms of the license. JetBrains is atypical here in that they extend your right to use the software indefinitely after your subscription expires. This is not typical in the world of software subscription licensing. IBM doesn't do it. Microsoft doesn't do it. Oracle doesn't do it. Etc. Now, you can pay for a CAL or a copy with them, but in most cases you're going to find yourself paying a LOT more for the product because you're not subscribing. Note, I'm not really defending the state of the industry here. It's confusing at best, and a racket at worst. That said, JetBrains is being fairly forthright here and they're affordable compared to the competition. In short... you should probably just use Eclipse. You seem like someone who is never happy with something, so really why ever pay for it? You won't be happy anyway.
Maybe you are right. I just always had in mind that JSP + Java code had a closer relationship.
&gt; Yes, well, now you're complaining about the entire industry. Your complaint is hardly unique to JetBrains. If by "industry" you mean "subscription based software companies", yes. &gt;I think you'll find your warranty runs out fairly quickly and provides little recourse for non-recall issues found after the 1 year is up. Major defects on a new house (where I come from) are covered 5 years after I buy it. Years ago I had my iPhone replaced more than a year later because of a defect in the screen. Bugs are defects. &gt;Oh, and with subscription based licensing, you're not buying software. You're paying for the rights to use the software under the terms of the license. I don't know why you included the word "subscription" before "license" since all software is licensed. &gt;JetBrains is atypical here in that they extend your right to use the software indefinitely after your subscription expires. Traditional software purchases do not expire. If you stop buying new copies of windows, does it expire? Do you cease to get bug fixes a year after you buy Windows? &gt;You seem like someone who is never happy with something, so really why ever pay for it? You won't be happy anyway. Thanks for the assessment doctor arm-chair.
I love selenium, I know it better than I'd even like to admit. I will say that if you have an unresponsive ui or a ui that is constantly changing and undergoing revisions, writing selenium will be the bane of your existence. No amount of abstraction or good architecture can save you from bad front end developers.
How do you build dynamic native SQL statements (containing window functions, CTE, PIVOT) for which the WHERE clause varies based on user input? You need a framework for that like QueryDSL or jOOQ, or Blaze Persistence. The worst thing one could do is to start concatenating Strings. Unfortunately,[even StackOverflow answers are poisoned with wrong examples](https://laurent22.github.io/so-injections/) that suggest solutions that lead to SQL Injection attacks.
If you spend too much time doing it, then errorfondling.
For a package name? `error`. Don't overthink it.
&gt; Nice job singling out a single example of what was said. That was the only example. you don't have to pay every year, the version you bought doesn't stop working. Support costs, and you think scaling linearly is free ? But that is not relevant anyway. Java IDEs are not terrible, eclipse and netbeans are still the industry standards (I prefer intellij).
[http://activemq.apache.org/](http://activemq.apache.org/)
&gt; you don't have to pay every year, the version you bought doesn't stop working. Do you use software that is no longer receiving security/bug updates? I don't.
Whatever you choose don't name anything after language level constructs, e.g. `my.package.error.Error`. Pick a semi meaningful name for your use case. 
they still get minor version updates. You speak with authority on intellij, yet its like you've never used it.
JavaFX.
fuck jsps - stop using them, ugly as shit.
lol, good one.
I think the question was about null checking the Optional itself, because this is valid: `Optional&lt;String&gt; opt = null;`. This is a pretty annoying downside of Java Optionals (and I guess Scala suffers from the same?) that every object is a pointer so can be null.
Same thing, but YUI. I am an xpath god. 
Major defects are covered sure. Most bug fixes aren't, and a house is a much more sizable investment than an IDE. If you want indefinite support for such a relatively small thing, then they will simply have to raise prices even more to make up for the fact that they wouldn't have enough ongoing revenue to continue to fund major bug fixes, minor ones, and new feature creation. Traditional software purchases are going the way of the do-do. As you said, you don't purchase software anyway, only license it. Licenses can and do expire, so this is no big change. And really... fire yourself as a customer and use something else. I really wouldn't want your level of vitriol plugging up the forums of a quality vendor like JetBrains. Go inflict yourself on someone else that might deserve such poor treatment.
They are legacy now. The browser has become fast enough to forgo tracking most client state on the server. This removes their reason d'etre.
If you want to try something different, Try Vaadin. Write Java code, it creates client side javscript. It works really well, and if you are not primarily a web dev, it gives you a nice web dev toolkit. Framework: https://vaadin.com/framework Demo/Sampler: https://vaadin.com/demo
What I hv gotten so far is DAO is an object in the layer.. I probably find some more information later.. 
It's not specific algorithms, it's common simple programming tasks. If you demonstrate a knowledge of the most efficient algorithm, it's going to speak well for you, but again, it's really more about demonstrating that you can code in the language and that you are capable of thinking your way through problems. I'm in a very large east coast city and competition for good programmers is fierce, so much so that you aren't going to turn away people who have the potential to become good programmers with some guidance. I should also mention that there is a 90 day probationary period after you are hired where you need to continue to show that you can think about problems and you need to show growth. Honestly, I don't think 90 days is long enough or that we are overly generous, because I don't know of anyone who didn't make it past their probation period, even some that should not have. 
Yup we have things like Optional&lt;T&gt; now...things are very different now.
It's a great stack IMO and at this point is matured enough that any problems I come across have generally already been solved. I've played around a little in the past with Angular but was not sure why I needed to learn another technology (Javascript/Angular) to get what I needed done when JSF does the work for me. I like the fact that I have to write little to no Javascript when all hard work has already been done for me in JSF component libraries. I like the fact that I can refactor, using IntellJ, from back end to front end. I like the fact that I don't have to lean heavily on my UX guy to make nice looking pages. I like that I'm going to have to make few if any changes when JSF gets updated. I guess I don't get all the JSF hate. I guess some people equate mature == dead.
&gt; they still get minor version updates. For a single year.
This really depends on your delivery platform, for example do you want a web service or a locally installed application? For Web, any you're comfortable with will do: jquery, angular 1/2, react, vue, backbone, etc. For natively installed, I think JavaFX is the future (that said, I don't know many thick client developers anymore, but I know there is still a niche for it).
Yeah The barons book is all you need Hit up some codingbat.com too! Do a lot of em
I picked up JavaFX for a personal project a little while back and I'm just thankful I'll never have to deal with swing ever again
If you ever have to do that again, Firefox has an XPath-Plugin which lets you right-click elements and then simply generates the XPath for you. But XPath is very, very slow and I had to test multiple versions of data with the same UI on a remote system and it needed something between 6 - 10 HOURS to execute its damn tests.
I hate selenium. It's slow, very hard to debug and it's incredibly incompatible. Executing extra JS to get stuff running was the norm and then you would always run into problems between browsers. I don't know of any test I wrote that worked in IE, Chrome and Firefox without summoning Satan and sacrificing your first born. 
thats simply not true- I've received numerous updates for old versions. 
"Java tutorials The JVM is Java Virtual machine that execute the Java bytecode.JRE stands for Java Runtime Environment it contains JVM + other class libraries + other files that are required to run. " 
"learn java the hard way" was a really good one. Is your JS experience backend or frontend? If it's frontend you're gonna be a bit..surprised. EDIT: Oracle's tutorials are very thorough, but they are very dry.
Look at the prices for things like Embarcadero C++ Builder for example. It is seriously expensive compared to IntelliJ. Plus can't you just buy it month to month if it bothers you? 
Nonsense, there are still many advantages in having the server send HTML instead of letting the client run a heavyweight JS framework that costs time to startup and drains the client's batteries and/or causes fans to spin up. Most clients also aren't particularly thrilled about the current trend where each tab starts to occupy hundreds of megabytes or even more.
subscribe to mailing lists: awesome java, java weekly, java performance tuning, java specialists. each week (or month) the latest in java news, tips, tricks, etc.
`javac` does not compile JSP. All markup languages do not have a compiler to catch errors. They are all runtime. Let us just take an example from JSF. If you call something like `value=${bean.property}` it has to know the conversion from the EL specification that it is by name convention via getter and setter. Additionally there are two different properties. Read-only and Read-Write. For a read-only property you will not need a setter. If you refactor the method, do you only refactor the getter, setter or the property? Is that refacotring even valid? You can refactor boolean getters to `isStatementTrue` but not `can` and `has` is not due to Java Beans Specification. And let us not forget about normal Java Stuff might or might not be even considered like Javadocs `Class#method()` or commented out methods etc. **TL;DR refactoring is not just a matter of grep and sed**
Man since JavaFX came out I don't think I'll ever mess with Swing again. The only issue I've had is with the TableView. Having to create custom cell factory implementations just for simple things is infuriating.
And it should be used ONLY for debug That's a thing I learnt while reading Java 8 in Action =)
it is getting more and more attention since SceneBuilder is such a good tool to work with. With http://www.jpro.io/ they even made it into the web applications with JavaFX. Very useful if you need 3D rendering or other fancy shit JavaFX supports.
Yeah but that code is obviously a bug. If someone send null value instead of an optional, then its method is crap imho. Nullpointer exception should never be raised with optional way of thinking. And if it is raised, the solution is not adding a nullpointer check which is obviously the "hide under the carpet solution" everyone's using :/
I think it was not made clear, but I have not read anything wrong. Which statement do you refer to?
I'm pretty sure JSPs can be precompiled to find errors. For example by using: https://github.com/Jasig/jspc-maven-plugin I mostly agree with you, but I think missing code has a higher priority than just a missing javadoc link..
Cool. Is there a JavaFX version or can it integrate into a JavaFX app?
He's constantly drawing updated data. Why does it matter it's not coming from an external source? It's a demo after all. 
That exact code is obviously a bug, but in Java a null can come from anywhere. The standard library, a third party library, a branch in the code that isn't commonly used that you missed when converting from null to Optional. So to be sure you don't have a null, you have to use `Optional.ofNullable()` pretty much everywhere. Is that actually helping me any more than `value != null`? You can make the argument that it is safer, but I've found that it's too annoying to deal with these cases to try and migrate a codebase from null to Optional, so instead we end up using Optional sparingly. It has benefits, but built into a language with a null pointer it's not half as useful as it could be without null.
Agreed!
They have solutions for the problems I have they are just terrible to use. My main issue was creating a TableView of an arbitrary number of columns, and having it populate them properly. I forget the exact details, but if I remember correctly it wanted the datatypes and/or column count at compile-time which I find unacceptable. The reasons behind it are quite obvious though. They want to push their observable collection concepts for FX. I was able to work out a solution, but I think it involved a custom implementation of CellFactory. Being forced to use observable collections to populate data is extremely frustrating. I'm a pretty good programmer, but I still don't understand why these UI items are not simply BACKED by observable collections referenced by interface. Then the update methods could be called on the UI item *directly* if so chosen. Further, this would be able to create a non-observable-based implementation (since it'd reference by a low, low level interface like List/Set/Collection) simply by extending it. TL;DR my complaints are stylistic, fundamental complaints about JavaFX's organization. I just want pretty buttons not a shitty &lt;? extends Observable&gt; system.
I'd hazard stating that, if you can't produce a fast implementation of [BufferedImage](https://docs.oracle.com/javase/7/docs/api/java/awt/image/BufferedImage.html) for your custom format, you're probably better off dealing with an off-the-shelf image format.
well documentation is part of your code base, but I understand your pov.
I stopped using JavaFX in my product (Poker Copilot) and went back to Swing only. Why? Even though JavaFX is my nicer to work with, it is not as mature. It crashes at startup when run in a VM (although there is a work-around), HiDPI support on Windows is worse than Swing (although Swing is not great here either yet), and we'd get occasional spurious crashes from our customers that we'd trace back to JavaFX internals and known Java bug reports. Finally there is the Stack Overflow factor. Almost every conceivable question to do Swing has been asked and answered on Stack Overflow. Makes development easier. It's a pity, I'd prefer to stick with JavaFX, but for customer-facing software run in diverse environments, it is not as solid as Swing. 
depends how you set the deadline. The deadline is in a game a world tick for example. It could be 1s or 50ms. You just need to guarantee that the processing is faster before the next cycle starts.
I always wonder how to keep up with the JCP / JEPs / mailing lists for Java. Does everybody subscribe for all 34942342 mailinglists?
&gt; Most clients also aren't particularly thrilled about the current trend where each tab starts to occupy hundreds of megabytes or even more. This is interesting. I didn't know this. I mostly use Jquery and the extra load is noticeable. I imagine with frameworks like AngularJS the load must be a lot higher.
A lot of times a single tab uses more memory than a full Java EE server does, just to put things into perspective. Some clients we have that make extensive use of client-side frameworks have already started to state minimum system requirements for visiting what is really a rather simple web site (like 2.5Ghz CPU, 8GB memory, ...) which is a bit insane really.
The underlying Qt framework is very elaborated and has a long development history. The combination of tooling (designer, code generator / dynamic class loader) is also better than lots of other solutions were or still are. Qt also strived almost 20 years ago the approach to model UI with a declarative language as XML dialect. So the designer does not create code, but XML. An approach lots of frameworks has started to follow, like xaml in the .NET world or JavaFX with fxml (?). I don't think the Qt engineers were the first, but indeed they have brought the idiom to lots of developers and stood the test of time while this concept was ignored by AWT, Swing or WindowsForms. Within the python bindings it us even possible to load the XML file and create the UI classes at runtime - very nice feature that saves the external compile step and makes even changes via the designer visible at runtime. So imho it is always fun to dig into a well designed framework ☺ Even if one cannot use it for work or in production...
There are equivalent classes to use under FX to get the same thing as this swing version.
What I do for my hobby projects in that case is decode it to a texture/image (whatever the program expects) pixel by pixel once on startup. Other than the very very small startup impact (it takes what, less than a second to process 500 megapixels like this?) it is the same as if you had loaded an image file to the program both in runtime performance and RAM usage.
Step one: abandon java
https://github.com/Norconex for their nice URL parser / normalizer
And there is Eclipse SWT
some of these frameworks supports both client side and server side rendering. You can do that with angular
NotThatDangerous
Also if you remember to not inject primitives, because the HK2-Guice bridge explodes if you do. ;)
Personally speaking, I found the migrations to Jersey 2 to be kind of a nightmare. While there is support for Guice integration, there are a few nasty edge cases as well ready to bite you in the leg.
JSF is number one or two in every survey I have seen. There are some vocal people on here who do not like it. 
They do have projects that do not use JSF. They have Prime UI (jQuery) and PrimeNG (angular). It does take a lot more JavaScript code to work with them though. 
I was just thinking about this today. Thanks OP.
Food for thought: SQL injections vulnerabilities in Stack Overflow PHP questions https://laurent22.github.io/so-injections/
Conclusion: avoid String concatenation.
Not to mention that there are significant changes to JavaFX with update releases of Java 8.0. We've had to specify for our app that not only we need Java 8.0, but that it has to be update 70 or better. 
Sigh... I miss Eclipse SWT/JFace 
There is also the venerable JFreeChart, http://www.jfree.org/jfreechart/ Has been around for many years and has served me well. 
Usetrace doesn't have IE / Safari yet but the tests are no code and still pretty flawless (especially for regression tests). Over the last few months the QA tasks have shifted to our UX / PMs and we've actually been testing faster (for now).
If it does I wouldn't recommend it unless you ABSLOUTELY need *exactly* that. It sounds extremely resource intensive to me. If you're doing desktop automation look into the robot class. If it's for web look into running a selenium driver. If it needs captchas run a firefox driver from selenium in Xvfb headless. Hope that helps!
Conclusion: our languages sorely lack reflective statements, which can be translated to statements for another service we need to call.
Maybe something like this: http://www.sikuli.org/ (was linked on this sub a couple of months back) Haven't tried it, but it has a Java API.
The [Robot](https://docs.oracle.com/javase/8/docs/api/java/awt/Robot.html#createScreenCapture\(java.awt.Rectangle\)) class can gather pixel data from the screen and you can run a basic algorithm to find a certain "image" on that screenshot. The algorithm should just be a simple scan and match. Start looking for a pixel in the screenshot that equals the color of that in the upper-left bounds of your image (maybe add a bit of a tolerance), and when you find one scan across and downwards for both to ensure equality.
&gt; Adding concurrency makes no sense anyway. You won't get speedup magically. Either you design and develop with concurrency in mind from the start - when you plan to do heavy calculations with huge amount of data or you serve a billion customers - or you leave it be. You think at a different scale than the people you're talking to. Encapsulated small amounts of mutable state can be controlled. At a larger scope, you're always running concurrently to other processes, machines, systems and so on. You can't avoid it.
"Use prepared statements" is three words, why does it take a "guide" to say three words
I get that some sites/apps etc resort to it because they don't feel that people will pay for what they provide. Some sites even have metrics, "we tried donations and it didn't work". Development (in the solicitation of money sense not the key pounders) is a difficult and highly skilled job. Simply adding a donation button isn't enough. You have to have an engagement and even a marketing (in the good sense) strategy. 
Damn dude vlad deleted his account 
The most up-to-date resource would be http://activemq.apache.org/version-5-getting-started.html . Its organization could have been much better, so you need to visit every link in the documentation for an in-depth experience.
&gt; ... if you concatenate strings, ... java.sql.PreparedStatement are prone to SQL Injection attacks. If you are referring to that quote, it is a retarded thing to say, since nobody would use prepared statements that way, since it defeats the purpose of using prepared statements.
I have loved IntelliJ for many years. I never regret learning it. It pawed the road to Emacs for me. For very long time I was afraid I won't be able to find in Emacs, replacement for every single feature of IntelliJ I've had become so accustomed to. Oh, I was so wrong. I won't tell you to switch to Emacs though. Because it is as well - not free. It won't cost you money though, the price is - enormous devotion and profound passion. If you willing to pay such price, you may find something way more awesome than any other IDE or editor could provide.
2016 and not using object models. 
And never in the history of corporate software development has something so silly happened.
This is actually easier done than you think. You can make Screenshots in some 24 bit format like BMP because this format allows easy access to the **uncompressed** information. If you have a reference image, you can just substract that image from the screenshot. If the whole diff is in the sum 0 you found the image on the screen. If you need computer vision use something like OpenCV. If you need exactly that, use that. Nothing hinders you to use Python as a service in Java.
&gt; In nature there is no mutability Presumably the author is an immutable zygote...
I don't think it's just about state, but also about the fact that no matter how you put it, ready to render HTML is faster for the client to render than downloading a potentially huge amount of javascript and partially pre-compiling that internally. Processing all that framework code takes time, uses CPU cycles and as mentioned uses memory. Also don't forget that a server warms up when many clients request something, so client 100 likely benefits from clients 1 to 99 that came before it, but with a pure client side framework each client has to warm up individually. The costs of that is amortized when using a long running application such as Gmail, but it's not always optimal when the client is just doing a single view and then leaves your site again. If you use a server side framework, your backing beans (in case of JSF) can call out to a rest API just as well. There's really nothing preventing that. In that case you'd often have much faster calls as the UI server and the API server are likely co-located. Also don't forget that often a native app and a website don't show the same information. A native app typically shows less at the same time or less detailed data. Even when going the route of using the same rest api for both the app and the website, there's a non-trivial amount of APIs calls that differ. 
It's funny. These features, and other functional features in general, are getting more and more common among mainstream languages. I can't complain for sure.
You're mixing up shared state and immutability. And the author is merely saying that in nature, you cannot turn back time. However that has nothing to do with mutability and immutability, given that you can combine immutable structures and changing timelines, as well as fixed timelines with mutable structures. Those concepts are orthongonal to each other. The benefits of mutable structures have been well explained already in countless articles, this one does not add any value.
Ahahaha, noted. :D Maybe will change the name down the road. 
This, uh, makes me so happy. There's been so many cases I've found that I wanted this. 
Java6, Struts 1-2, Spring, Weblogic - Tomcat, Oracle 11g New projects will be in Spring boot
I love it.
I've used a combination of the robot class and open cv to achieve this before. 
/u/pastrypusher/ I meant that SceneBuilder is a third-party tool. (not part of NetBeans) but /u/punit_arya is also correct it is technically a third way of building JavaFX GUIs. You essentially drag and drop components into a view builder and it builds the FXML for you. Then within SceneBuilder you have options to assign FXids in your controller class to the FXML components that you just dragged/dropped. Its a free and powerful tool. Originally it was made by the Oracle JavaFX team but they open sourced it and gave stewardship to the guys over at Gluon http://gluonhq.com/labs/scene-builder/ Gluon also makes some awesome transpiler tools for having your JavaFX app run on either ANdroid or iOS.
Why ? What are the features you don't like ?
$...@Boo : public (&lt;&gt;); This is future Java for the entire code base of Google.
oh snap...
* post datapoints to it and let it plot them * post image to service and let it detect user JavaEE has with CDI already a dependency injection framework. You generally either choose JavaEE or Spring ecosystem. It is generally advised to learn both. Depending on the area you are living in one could be prefered over the other. I suggest you to learn JDBC, JPA, SQL, NoSQL. Using Spring is making this a breeze but the information gain is close to zero. For distributed systems look into Docker. This is the closest distributed system you can simulate efficiently (running 10+ VMs is not)
So, um, what is the reference?
He can't be inspired, he is friendless.
[Wikipedia](https://en.wikipedia.org/wiki/Sifu) to the rescue
Silver bulletry is the root of all evil.
His point is that these features are already mostly available in Kotlin today, so he's not too excited about them coming to Java at a future point. 
I wonder why make CLI for the worst Central search engine. When you know exactly what you're looking for (exact GA), you can use any http client to call search.maven.org REST API. When you don't know exact GA, use google, https://javalibs.com or even http://mvnrepository.com Also see comparison of these search engines: https://www.topjavablogs.com/news/java-libraries-search-engines-comparison-2016
If you're saying for it to be included inside the Java 10 early builds then yeah, probably. Actually being considered stable and being able to use it in production Java 10? 2020, probably.
Still goes faster than the Android Java fork.
Yeah, but how many people get paid to write Kotlin? Can you maybe see how this is exciting for some people?
I guess you triggered him! 
A real problem to some people, blessing to companies .
Properties would be better: public string MyProperty { get; private set; } And fields / methods should be private per default. Like C# without Micro$oft. 
Being excited about programming languages and their features is fine. Popping up in every Java language discussion to say "Kotlin does this better" is not fine, it's infantile. The not-so-recent [contretemps with Cedric Beust](https://www.reddit.com/r/scala/comments/454ahd/recent_dottyscala_fud/) and his sock-puppet trolling should have told you that this kind of behaviour won't be tolerated, and will only serve to drive people away.
I'm using the REST API to do the searching. I spend a lot of time on the command-line, so the least amount of typing and clicks was what I was going for. Ordering them by usage stats would also be helpful, so that would be nice to add. Ideally I'd like a site somewhere between https://www.ruby-toolbox.com/ and any of the Awesome lists. A curated collection of popular and useful libraries. I started a site like that once but eventually lost interest: https://github.com/spilth/java-toolbox And thank for that comparison link!
Properties are a solution in search of a problem.
Yes but we are creating solutions to problems that we are creating, all so a few people can feel better about not typing getters and setters.
Whoa. I thought Maven was doomed to forever be stuck with POMv4. I'm very glad to see I was mistaken! Suggestion: POMv5 could be published into public repositories with a different type/extension, e.g. `pom5` instead of `pom`, with the `pom` being for anybody that doesn't understand the v5 format. That way, publishing doesn't lose any information.
It's not so much about the file size per se but about the conceptual complexity that comes with it and the effort needed for understanding it. A user of a library isn't interested in all the metadata and config related to the build of that library, so why put all that info on them which they don't need? As an example, compare the published POM of Hibernate ORM (http://central.maven.org/maven2/org/hibernate/hibernate-core/5.2.5.Final/hibernate-core-5.2.5.Final.pom) - which is using Gradle and thus is able to do what I describe here, publishing a minimal POM - and the one of Hibernate Validator (http://central.maven.org/maven2/org/hibernate/hibernate-validator/5.3.3.Final/hibernate-validator-5.3.3.Final.pom) which is using Maven and thus is publishing all the build info in its POM. The former is much easier to grasp for a user. You could say that no one reads the POM of their dependencies, but I often find myself doing it, e.g. when analyzing transitive dependencies. So the entire &lt;build&gt; block should be filtered from published POM files. Another one is plug-in repositories. It'd be fine to configure them in the POM for plug-ins needed for the build of a library, but of course you don't want to force them into the build of your lib's users (Maven Central won't even allow to deploy a POM doing it). So you need to work with a custom settings.xml in the lib's build. Again that'd be nicer to handle if the published POM allowed to filter that build-only information and remove &lt;pluginRepositories&gt; from published POMs.
JavaII sounds a lot more useful to me. At a certain stage you can teach yourself Android within 1 week. The other topics are generally more difficult to grasp. 
I'd never heard of that before. I just do programming, not politics. I agree 100% with ZakTaccardi above - I'm excited because it's a great language, and after 20 years of using Java and watching it decay I think it's time for a giant leap forward.
Is it a plugin for FindBugs or does it piggyback on FindBugs somehow because the word on the street is that that project is dead (in its current form at least)? 
I don't really get it. Can someone explain a compelling use case for this?
Ok. IMHO, in general, POM are displayed in IDE which make it a breeze to filter out irrelevant parts or highlight relevant ones.
Okay, how about a case where you use enums in a strategy pattern where you need to perform specific actions based on which enum you get?
Isn't that easily achievable with an overloaded method on the Enum today? Or a switch statement, or a `Map&lt;E, Runnable&gt;`?
I'd go with Java II. Android is just another flavor of Java, so the more you know there, the more you can apply to Android as well. Also, the Java II topics sound like basic Java to me. IE: essential to have as a junior Java developer.
is the "dry" part in the name "dryTools" a reference to "don't repeat yourself"?
I had some weird mapping between strings and Class types that this would have eased some casting headaches.. But those were just in transmission. I think I got too excited too early. I have a few Class to Data Map instances, and it'd be great if there was a built in map that didn't force me to do unsafe casts that I "know" are valid. 
This is the correct answer. Good companies hire talented people that can learn.
there's this dude I talked to who was a teacher and became a technical writer and he said he missed the social interaction and I was, YESSSSSSS *dream job* haha
Do both! I am a technical writer with some coding background (java, c++, c#, SQL) and the knowledge has made my job SO much easier!
Also, while I do attend a meeting or two a day, most of my day is spent at my desk with my head phones in doing my work.
YESSSSSS *dream job* hahaha Can i pick you brain a little? I will take a year off work. What skills do you suggest I acquire during that year? Assume a Lynda membership or coursera, etc. I have also been looking at the U of Limerick in Ireland for a degree, though I don't know if a degree will improve matters substantially in a way that will justify the cost (degree is 11,000 euro in 1 year - technical communication and e-learning). There's also a part-time certificate that can be done via distance learning and ends up being around 7000 euro
I would advise not to go for the degree and focus on certifications. Degree's depending on the university can sometimes be very broad and you want to something that is more specialized and focused on what you want to learn. Specialized certifications is the way to go like Java SE Programmer certification, Oracle or Microsoft certifications which are really good such as MTA and MCSE, the choices are endless. I feel that taking specialized certifications is a more effective way of learning compared to Uni, but that's just me. 
Spring boot has simplified a lot of integrations. E.g. Spring data is extremely simple to integrate. Same goes for things like spring cloud and actuator. Since ratpack integrates with guice as well as spring to support its registry, this can reduce the boiler plate involved in integrating your ratpack app with all those services that spring boot offers. You could, of course embed spring into your ratpack app, but then you might end up with some extra boilerplate. Depending on how much you need spring boot starters in your codebase as well as how aligned your organization is to spring components, it might be a better idea to embed ratpack into springboot.
I'm biased, as I'm a software engineer, but start down the Java dev path. Developers aren't being automated away any time in the near future, and if you do decide to become a technical writer the experience as a dev will help a lot. 
&gt;She emphasizes a low stress interview based on what I do know rather than what I don't know. Don't be surprised if it doesn't end up this way at all. 
It really depends on what the position is. I know where I work we do Android, and if you don't have 2-3 years, you aren't even considered for a intermediate position. We've hired a few that were lacking practical knowledge in android but had other undertakings, we regretted it each time. You might get your foot in the door, but it's unlikely you'll get placed in a high position if you don't have deep knowledge of the domain you are working. I could for example leverage my Android skills to get a IOS job if I wanted, however I'd be a junior for at least 2 years, it's not like you can just pick up an entire stack overnight and be a expert. Different domains have different patterns that the community/industry adopts. There are general trends in certain directions, but an IOS vs Android app are going to have drastically different architectures/patterns/tooling. Edit: I'm at 20 years industry experience now, this is definitely different when you are new, but I'm 8 years entrenched into android. I can make 6 figures doing android, or bump myself down a few paygrades and learn IOS on the job.
As an intern it shouldn't be important what language you learned in class. When I was in school, I learned java for a year and C++ for a semester; my first internship was C#. My next year of classes were primarily language agnostic but I continued to use Java. My second internship was a mixture of Perl, Python, and x86 assembly. My first team out of college was CoffeeScript with some Ruby. Now I use Java and Ruby. My intern last year didn't know Ruby at all coming in and did just fine. Don't stress about what language you will use at a job; when you get there you will get guidance on the best practices used by your new team.
java developer FOR SURE
At the beginning of your career, work anywhere that will take you. However, learn some background on java so you don't seem ignorant. Showing interest in what they said in the first interview will make a huge difference. As an interviewer I really like it when people pay attention and are passionate about the technologies we use. Learn a bit about the java ecosystem, learn what these things are from a high level. 1. IDE: IntelliJ and Eclipse (there are others, but this accounts for probably 95% of java dev). Install them both. 2. Build Tools: Gradle and Maven (This is probably 95% of java build systems) 3. JVM and JDK (The Java Virtual Machine &amp; Development Kit) Learn a bit about the JVM and generally what a JVM is. Also, get an overview of other JVM languages. 4. Modern Java Versions 5/6/7/8 - 5 brought generics (Similar to C++ templates) - 6 brought some api improvements - 7 brought strings into switch statements - 8 brought lambdas and streams (functional programming) 5.Have some fun with Java. I'd recommend checking out LibGDX setup a project and look through the tests. It's pretty easy and well documented and it's a great open source gaming platform for java. As for general interview advice. - Let them lead the interview and don't ramble. If you aren't sure how to answer clearly, ask for clarification. - Be optimistic about what the job actually entails. - Ask lots of leading questions, leak knowledge through questions (e.g. what sort of build system do you use? is it gradle?) - Don't lie about your skill level or what you've done, but actively show that this is a serious interest. The more you do before the interview, the more you can say you've done in java. - Don't bother offering information in a bragging way. Listen to what they say, and offer information relevant to it. If you go on tangents talking about Big O, they will get bored if they didn't ask a question about complexity or algorithms. - When all is done, ask them if there is anything they are uncertain of that you might be able to clarify on before you leave. 
The front end will be in html. However, you still will need a back end server to store / process player data. This is one I am working on at the moment - https://apps.facebook.com/friendlystock_reload/ Its a player trading game, where you buy other players low, and sell high, to make profit. The game runs on a Apache TomEE server (tomcat + EE extensions), with Websockets, and postgresql database. There used to be a game called Owned!, a similar idea where you bought / sold other players. This was very popular in its day, you might want to look at resurecting the idea. 
awesome post thank you.. http://www.metaforumtechnologies.com/training-courses/java-courses/java-j2ee-training-in-chennai
Yeah, I misunderstood the problem a bit, my bad. I suppose you could use a static method as a workaround: public static class PersistentList&lt;T&gt;{ public static &lt;U, V extends U, W extends U&gt; PersistentList&lt;U&gt; append(PersistentList&lt;V&gt; list, W newValue) { throw new UnsupportedOperationException("To be implemented"); } } public static void main(String[] args) { PersistentList&lt;Dog&gt; dogs = new PersistentList&lt;&gt;(); dogs = PersistentList.append(dogs, new Dog()); PersistentList&lt;Pet&gt; pets = PersistentList.append(dogs, new Cat()); dogs = PersistentList.append(dogs, new Cat()); //not allowed PersistentList&lt;Cat&gt; cats = PersistentList.append(dogs, new Cat()); //not allowed } 
&gt;aren't even considered for a intermediate position &gt;unlikely you'll get placed in a high position &gt;not like you can just pick up an entire stack overnight and be a expert. He's going for an internship. There's no expectation that he's going to pick up the stack overnight or be an expert. He'll be fine.
There are some pretty big differences between C++ and Java, mostly having to do with the fact that Java programs run in a virtual machine, whereas C++ runs on silicon. The biggest differences are 1. garbage collection, so you don't need to worry about memory management, no need to every worry about "deleting" objects, or virtual destructors or anything like that. There is a performance penalty for running the garbage collector, but it is minimal. 2. There is no multiple inheritance. However you can create "interfaces" which are similar to purely virtual classes, and class can "implement" multiple interfaces. Personally, this is one thing about Java I like better than C++. 3. Classes exist in the Java programming language, but also as objects in the file system. Every class is compiled to a single file with a ".class" extension. Furthermore, classes are organized into units called "packages," which are not namespaces. The virtual machine actually places compiled bytecode files that are all in the same package into the same directory on the file system. So some of the programming language constructs actually have 1-to-1 relationships with files and directories in the filesystem. The Java virtual machine itself is a fascinating bit of technology. It is really like it's own CPU and operating system together in a single, miniaturized package that can boot itself up in miliseconds. It can "Just-in-Time" compile (JIT) functions that are used often, meaning if the virtual machine judges that a particular function is going to be used often enough, it spends a little bit of CPU power to convert the bytecode of that function to native CPU instructions. Some Java programs can run almost as fast as C++ programs as a result of this. If I were you, I would peruse the Java documentation, and start to familiarize yourself with the [Java API](https://docs.oracle.com/javase/8/docs/api/). The [java.lang](https://docs.oracle.com/javase/8/docs/api/java/lang/package-summary.html), the [java.util](https://docs.oracle.com/javase/8/docs/api/java/util/package-summary.html), [java.io](https://docs.oracle.com/javase/8/docs/api/java/io/package-summary.html), and [java.net](https://docs.oracle.com/javase/8/docs/api/java/net/package-summary.html) 
I always hated MS's syntax. Not only adding keywords for common verbs/identifiers (get, set, value), but you can't name your parameter for the setter, the storage for properties is confusing, and once you figure it out if you're not using auto-properties it's much wordier than necessary. I would prefer to do it with annotations, something like: class Person { @Getter(Scope.PUBLIC) @Setter(Scope.PRIVATE) String name; @Getter(Scope.PUBLIC, Person::getAddr) @Setter(Scope.PACKAGE, Person::setAddr) int address; String getAddr() { return String.format("...", address); } void setAddr(int address) { this.address = address; } /* We can dispatch to different methods depending on the type that is attempting to be assigned. If no appropriate method is found, we get a normal "can't assign type X to type Y" compile error at the callsite */ void setAddr(String addr) { //Reverse of getAddr() } /* The complement of the type-dispatched setter the type-dispatched getter is called when we attempt to get the field as a class other than as declared for getAddr() with no parameters. */ &lt;T&gt; T getAddr(Class&lt;T&gt; clazz) { if(clazz.equals(Integer.class)) { return (T) address; } else return null; } } The syntax is heavier, but for 90% of use cases (`get; private set;`) it's only slightly heavier, and in the other 10% of use cases, it's more powerful and fits into the language better without adding new keywords.
Clickbait title. Thought there was something wrong with JUnit.
Kotlin always seemed really cheeky and trivial to me. Function declaration keywords like fun or def are hip, but why do params have declared types but functions don't? Optional semicolons are hip, but why? `?` for null operations is hip, but why not just not have null at all? (Except as required for jdk interop, in which case using some ugly constructs as "border security" sounds good to me anyway.) data classes and little-o `object`s are handy, but not enough to justify switching languages
Judging by the marketing hype in the link you provided, it appears that the 2013 article is still relevant. 
This is help with *Java programming* and thus should be posted in **/r/javahelp** as is indicated in so many places in this subreddit. **Post removed:** programming help
except the POM is by definition, a document that describes how to build the project. its not a package descriptor, or a README, or any of those things. you are wanting a POM to be something it isnt.
&gt; 6 brought generics (Similar to C++ templates) Java Generics are nothing like C++ templates, except insofar as they solve some of the same problems, in some of the cases. 
A little bit like Lombok: https://projectlombok.org/features/GetterSetter.html
None, I am stuck at java5
&gt; Ugly scripting language signed
My bad, Collections framework is the only thing I use from Java 6.
This looks pretty cool - I wonder if you guys looked at Scientist4J ( https://github.com/rawls238/Scientist4J ) before working on Jan20? You mention looking around but didn’t find anything acceptable - what sort of things didn’t suit your project?
(contributor here) Thanks! The easiest answer is that we don’t believe this library existed at the time we did the investigation. Now looking at it, with the caveat that I've now looked at this for a total of about 5 minutes, so I may very well be wrong, it appears that this project only allows you to define equality via .equal. While this makes a lot of sense, we really needed a bit more flexibility. We find that as we migrate code from one system to another, the organization of the data and the data itself changes. For example, the new service exposes only a subset of information, with more more specific keys. While addressOne and address_one aren’t really “equal”, in the case of succession we probably say that is correct. Another example is migrating ids to uuids. While the old system contains only ids, the ids missing from the new data does not indicate error. Also it looks like it's Java 8 only, and we needed Java 7 support (our monolith is 7).
I think fun and def come from Scala. Functions usually have declared return types, but you can omit it in cases where it can be inferred. The parameters need declared types so the compiler knows which implementations of functions invoked on them to use - e..g if your return value is "a+b", which "+" to use depends on what types a and b are, and as Kotlin is statically typed that matters. Semicolons are optional because they can be. Whoever said "what a good program needs is lots of unnecessary semicolons"? Yes, they need null for Java interop, but I'm personally not against null anyway. Kotlin certainly makes me consider my use of it more closely though. I think Optional is about the stupidest concept ever - using it, there are now 2 different values you might have which are wrong, rather than just one. You don't get NPEs, you get some other exception resulting from not checking! So Kotlin's way is much much nicer, even though it can be a little frustrating to convince the compiler to trust you that the value's not null. Because of the interop, you don't need to switch languages, you can have both. Of course there's the problem that your developers won't all be able to understand the Kotlin and for the moment you may not be able to hire someone to write it. Make no mistake, Kotlin is not the new Ruby, where everything is cute and quick to write. It is that, but the type system is stricter than Java's, and it compiles to about the same bytecodes as equivalent Java code would, there's no dynamic sleight of hand going on.
So if I'm writing a longer code, I'd be able to test individual methods without having to run through the whole program?
Basically. Unit testing tests components in isolation, as compared to integration testing which tests a suite of components working together (which may or may not be the entire application), as compared to functional testing which tests the entire application in different environments (browsers, OS, etc.). Unit testing is really important for ensuring that your public API remains consistent, even if the internals change. If you have a class that produces widgets given flimflams in reality you don't care how the widgets are produced. You just know that if you give the class a flimflam a widget comes out. Unit tests ensure that if you change your class internals to use a different widget producing algorithm, the public API continues to function as expected.
Yes that's exactly the intent. It's for testing units of work, and not a full blown integration. E.g. making sure a method called addTwoNumbers() behaves as you intend regardless of what might be passed in a parameters or whatever other methods exist in the class.
You learned how to learn, not language X
Shouldn't design patterns be part of the knowledge? I see them much more used in Java world. 
I also must disagree. Before being given the opportunity for an interview, your resume must first pass through the company's HR department or a recruiter. A degree looks much better on paper than a few certifications, and unfortunately, how you look on paper determines whether or not you will be brought in for an interview. That being said, I want to share with you my education credentials: I have a degree in English, a minor in IT, and a specialization in technical writing and communications. I do not have a computer science degree! Do not feel that a computer science degree is the only way to become a technical writer. 
I'll make an educated guess, but Oracle won't launch a gigantic lawsuit against you if you use their logo on a colorful background. If they ever decide to care for it, they'll first send you a nice letter from their lawyer and you'll have enough time to comply. So, in short, do as you please, it's not as if you're using the logo to slander Java.
I definitely agree JavaScript is the way to go. There is a big need for JavaScript developers and you can make good money. But I disagree that most technical writing isn't done by someone hired to be a technical writer. Developers and PMs don't really have the bandwidth to write documentation. Most of them hate it, and to be honest, most are not very good at it. I would never let a developer write a document I wanted to send to a potential partner or client without having a technical writer at least edit it first.
More specifically: http://www.oracle.com/us/technologies/java/java-licensing-logo-guidelines-1908204.pdf Page 6 and 7
you are describing a new improvement, not a flaw in the existing system. POM/Maven is working as designed - it is a build document first and foremost and other content is largely metadata, subservient to the primary goal of the POM: to describe the project structure and build information/deps/etc. What you want is a descriptor designed for the end user - which POM never really was.
Pretty regularly use java, ruby, python, golang, and js. Different tools are good for different jobs. Personally I like ruby the most (to write) but prefer java for backend services.
The linked article is 3 years old, which in the internet age means it may as well been written in egyptian hieroglyphics.
Of a sort. I do research. Often time a client will come with an existing tool they need more development on. Or I'll find a library that does 40% of what I need done in only a given language. Some languages are really great at somethings and not at others. Java is amazing at servers, front end not so much (haven't tried FX yet). SQL is great for some data but sometimes you need a graph database (Neo4J is awesome) Right tool, right job. 
You monster 
Wait, what is this doing on a credit union site?
Red bubble has a few. This is the best I could find: https://www.redbubble.com/de/people/acecoquelicot/works/21374144-java?grid_pos=41&amp;p=sticker . They have a lot of other programming stickers too!
No idea, i found it by googling "javascript logo".
I don't get it? I use Oracle JavaScript everyday. 
Unixstickers.com is where i bought all my programming stickers for my laltop
Oral own the copyright of "JavaScript" trade mark so... yeah. 
ex-Sun/Oracle guy. This goes back to the days of Sun, they were REALLY pissed if you use the logo and weren't a licensee. They literally **must** sue you if you don't comply. The reason is that if you use it and they don't say anything then some other guy uses it "badly" and they sue, that other guy can claim that they are being unfair by targeting only him... That's how copyright law works, if you don't enforce it you lose the copyright. Even Linus enforces rules on usage of the Linux brand. That's something he tried to avoid until some a**hole registered Linux as a trademark and tried to "steal" it. Bottom line, that's what duke is for...
Those free "I code Java" stickers from Oracle have transparent backgrounds. Did I mention they are free. http://www.oracle.com/us/technologies/java/gimmejava/index.html
[Yeah, better safe than sorry...](https://en.wikipedia.org/wiki/Oracle_America,_Inc._v._Google,_Inc.) lol
As long as openjdk doesnt include javafx by default, ill have to sstick to swing :(
We have to pay Excelsior a non-trivial amount of moneys, because Oracle can't get Java application installers out of the 90s.
Oral? Sounds like my kind of company
# ☕
[removed]
 If I click on "Order Java Affinity Mark Stickers Now" I get redirected to https://community.oracle.com/community/java.
Not sure. They have been available for at least 5 years, I'm not aware that it has changed.
Correct, my bad. 
In the land of Java, things move at a glacial speed, for the better or worse. As /u/mangopearapples points out, Swing's still being taught heavily in schools - and there's also the consideration that many existing apps are not using JavaFX, and businesses seem reluctant adopting new Java tech (some companies even bizarrely refuse to migrate to newer JVM versions).
I think JavaFX is a good technology, but as far as I know, it just isn't as popular as the many other competing graphics platforms out there. It is just there for people who are required to build their product on Java who also need to build a graphics-intensive front-end application. As it is now, Android, .NET, and the Web (with JavaScript) are the most popular user-facing platforms, so there is lots of demand for high-performance graphics on these platforms, especially games. But Java isn't used for user-facing applications nowadays, it is mostly used in enterprise data centers. If it were more popular for programming games and user interfaces, there would be more demand for JavaFX.
Neither necessarily suck FX is easier if you use jfxml otherwise it's pretty similar in structure, your third option is a JSP/JSF UI Oh and QT... Which is very powerful http://stackoverflow.com/questions/7358775/java-gui-frameworks-what-to-choose-swing-swt-awt-swingx-jgoodies-javafx 
&gt; javafxpackager is a piece of crap that is just awful. I need to have the "right OS" to build a package and if I make the mistake of using a 64 bit VM it won't work on a 32 bit VM. I agree with the central message of your overall comment (i.e. improve what you have rather than add new features). And there are definitely some improvements that I'd like to see in `javafxpackager`, such as: 1. support for "compact profiles", or stripped-by-Jigsaw bundled JRE's, to reduce the size of standalone JFX apps that ship with a bundled JRE. 2. The option to easily exclude WebKit and/or gstreamer video support from the bundled JRE... since those *native* shared libraries are now the biggest chucks of the JRE, and go completely unused in more apps than not. 3. Startup performance optimizations. Still, the quote above is disrespectful and a bit over-the-top as written. `javafxpackager` (and its plain `javapackager` alias) are one of the nicest additions to the JDK in years. Until *real* AOT reaches maturity (probably Java 11 or later, if at all), `javapackager` gives us the "*can I ship it as a standalone EXE and not worry about a JVM on the target?*" feature that people have been requesting since the 1990's. There's just no need to talk to people like that, it certainly doesn't make anyone **want** to accommodate you. Moreover, cross-compilation of desktop GUI apps would be nice... but it's the exception rather than the rule. If a GUI framework is a "piece of crap" because you can't build for one target on a different OS, then everything Apple has ever done is crap. As well as Microsoft. And GTK, for all practical purposes. Just migrate to Qt and be done with it. My jaw dropped when you suggested that it's *Java's* fault that you tried to ship a 64-bit JRE to a 32-bit target machine. I mean, come on... &gt; It can't dynamically download the right JDK... Haha... it's *in* the JDK! I think you want a completely different, *external* product. Which is fine... but not really a reasonable feature request for a JDK-bunded tool.
He's not being aggressive. You're just an overly sensitive snowflake. 
I don't think writeObject works on anything other than primitive types, so I don't think it would work. What I would do is create "Save" and "Load" methods in each of the classes that need to be saved, with an ObjectOutputStream parameter for the save method and an ObjectInputStream parameter for the load method. I would only use writeObject on primitive variables that have been declared in the class I am saving. If a variable in a class is another class I would call the "Save" and "Load" methods for that class, passing the input/output stream as a parameter. That way each class controls how it saves and loads all of its own variables. For arrays of classes I would use a for loop to save/load each object in the array.
Thank you.
Ouch. JavaFX has its problems but I'd take them all just for the ease of dealing with Tables compared to Swing.
&gt;but it was only part of the JDK at JDK 8 Via: http://www.oracle.com/technetwork/java/javafx/downloads/supportedconfigurations-1506746.html &gt;Starting with JavaFX 2.2 and Java SE 7 update 6 (7u6), the JavaFX libraries are part of Oracle JRE 7. So very early in the Java 7 lifecycle it was packaged in the runtime and available for use. Edit: JRE 7u6 released: 2012-08-14
I'm an ex-Sun/Oracle engineer who worked on a lot of products there. Calling a product out as "crap" isn't disrespectful to the people who worked on it as much to the process of producing it which includes decision making, QA, resource allocation etc. Notice I was specifically in this case referring to javafxpackage not FX as a whole. Packaging as an EXE has been a long time request. Unfortunately rewriting the provisioning of Java apps strategy has been a "sport" practiced for years with every revision re-inventing this over again... The product itself is just bad, if you actually try to ship with it this would become very apparent. Java's core is about WORA. That is the one advantage over other platforms so yes it's Javas fault that it can't deliver what was possible with Java WebStart. In fact javafxpackager is worse than webstart which makes it REALLY horrible. Yes it should support shipping 32 bit packaged apps from a 64 bit machine (Apple does allow that in Mac OS by the way) it's not a big deal to do. 
Consider a more appropriate title next time. I have been learning to code for a few years now and except for HTML maybe it was never easy, but if you like it and are interested in it, continue to do it. Programming is no black magic and if you are an interested learner then why not? Obviously this is a personal standpoint, but if you were able to complete the first few steps and understood the basics you already gained a lot of "programmer thinking". Somewhere programmers hit a point where it is "I want to do x in language y, I know how to do it in z, just put the pieces together", but it will never be "easy". 
&gt;bizarrely refuse to migrate to newer JVM versions). Absolutely. I've even seen some teams still stuck on Java 6 because the clients would absolutely not have it. In my last team, it was only a considerable effort on my part that convinced the architect to adopt Java 8!
So for a new application, do you recommend QT?
Well here's an upvote. I think you've had enough downvotes for the day.
It's always challenging to me but if your like me you will get bored pretty quickly if it isn't. You have to put in the time behind the keyboard to get better. Spend 100 hours coding pretty much any non-trivial project and you will get a lot better. 
Grow up. 
Thanks to all the folks who shared their experiences. It certainly has helped me make up my mind! 
cute
The link for the sticker at the above site no longer takes you to a page where you can buy a sticker. Is there a different place I can buy this sticker?
Unixstickers.com does not have a strictly java sticker.
I use it for my desktop applications. I'm not shipping mission critical stuff though. Mostly just internal stuff because I'd rather use JavaFX than go learn how to C# and then go learn how to Swift. 
Have you tried to write your own programs, or only the ones assigned in class? My advice is to hack, hack, hack. Come up with a simple idea for a program that will give you happiness, and write it. Figure it out, understand all its moving parts. Break it. Fix it again. 
Joking aside, can you post a link to the stickers with the white background? 
Or take an existing project and add some features. Or take two projects and put them together to do something new. 
&gt; it should support shipping 32 bit packaged apps from a 64 bit machine It **does** support that. You just have to be running `javafxpackager` from a 32-bit JDK. There's nothing stopping you from installing a 32-bit JDK on a 64-bit machine, or even multiple 64-bit and 32-bit JDK's on the same machine side by side. OP was complaining that it's a problem when you forget what you're doing, and use a 64-bit JDK when you meant to use a 32-bit one. Of course that would be a problem... but not a problem with a JDK. 
College uses JavaFX because it has a good reward to effort ratio when teaching Java (console output is boring.) It's a crime really to lead these kids into thinking it has a future or that you should be doing any 'Java on the desktop' programming at all. The college demographic is the only reason it has life on reddit.
Yeah, I know, this is the first place where one should start to look around. I am asking rather for your suggestions or companies
Wtf? That would explain why most (if not all) of the posts are on /r/javahelp. That really is not a good idea at all!
Seriously, this is getting to be boring. Let's end this conversation here.
Firstly - JavaFX by Oracle is a huge improvement over JavaFX by Sun. Oracle did a surprisingly fine job reviving FX. However they didn't follow through - it seems abandoned once again. Secondly - JavaFX is very slowly growing, though growing nontheless (it's "the biggest it ever was", which isn't as impressive as it may sound :P), while Swing is obviously (also thankfully :P) dying on our eyes. Thirdly - unfortunately (imho) non-browser, non-mobile UIs are on an obvious decline as well, virtually... everywhere. All in all if it was delivered a few years earlier it could have eneded up being massive. If that ship didn't sail yet though, then Oracle surely isn't helping enough now. It does the job more often then not however, and is suprisingly nice to work with. It's what Java needed to rule GUIs, when we ended up with Swing ;]
Most colleges started switching to Java in 1998-2000. Back then they were teaching AWT and the 'new' Swing. It's been going on for a long time.
+1 for Widgets and Flimflams.
Embedded chromium is really picking up steam too 
&gt; Our standard development IDE is Eclipse and it just works with Maven and we have developed custom Maven archetypes for common development components we build. This sounds awful to me.
I am building b2b financial services applications with it. It's a really nice GUI toolkit. The java world tends to moves slow. JavaFX is gaining traction, but Swing has such a long history that it will take quite some time to over come. As long as it's actively maintained, I wouldn't consider it dead. 
Actually, based on my experience, I would have no issue shipping a mission critical application with JavaFX. My only complaint is with the installer and there are 3rd party packaging apps I could use. Also, if you're willing to do some leg-work, https://github.com/javafx-maven-plugin/javafx-maven-plugin is really close to making it passable. It's not perfect though. Installer + auto-upgrade are the two features JavaFX needs more than anything.
We re-wrote our call centre software in Java fx from a web application as there are telephony APIs that are simply not accessible from the sand-boxed environment of a browser. It's been a pleasure from start to finish, but for all the reasons people have already given I don't think we would have been given the go ahead to do so if it weren't for the constraints we have. 
I use filters.
Interesting use case! Just curious - wouldn't AJAX calls from the client suffice to invoke those APIs? Or was performance an issue/concern?
javafx and fxml are p great imo. unlike others in here, i would ship a javafx app to our customers. so far, using javafx and scenebuilder has been like using a much less painful to work with swing. the apps are also super responsive and don't seem like typical java apps at all. in short, as a beginner javafx user, i'd give it a 10/10 would use again
i wish that redbubble make the white part of their decals transparent 
Do your homework 
Serious ?
Very interesting indeed! I have heard of TornadoFX. Perhaps I need to dig deeper since I am kind of interested in Kotlin as well. Thanks for the links! 
No, it just looks like that. I had meant to highlight the following line in my previous comment: &gt;You're just an overly sensitive snowflake. but instead, reddit chose to highlight the wrong snippet. Oh well, I'll leave it as it is. Also, you are free to call me any names you wish.
I've been using it for 3 years. Excellent tool, with lots of depth. All the more now that it's integrating with ios and android. Much better than swing.
Commercial.
Any good tutorials on how to make a good UI for Java desktop application using JavaScript? I really like the feel of desktop applications but it would be much smarter to make UIs with JavaScript to learn it more.
Front end development is a humongous topic that's completely separate from Java development. I use angular 2 for example, their documentation is really good to get you started, and I can link you some projects I've done. React is also good, or just jquery. 
First of all: Wrong subreddit as is indicated in many places here. Second: We are not /r/domyhomework - none of the programming related subreddits work like that. We *help*, we *guide*, but we *never do*. **post removed**
The nice thing about JavaFX is that, at least in JDK 8, its GUI Look&amp;Feel automatically and natively supports High DPI screens with zero work needed on the part of the developer at all. I recently started porting my Swing apps to JavaFX for this very reason alone.
How do you embedded the JS UI into a Java application though? 
Would be interesting to see some projects with embedded js UI. I've done some web stuff with Spring MVC so I'm more familiar with that, but it feels a bit clumsy for standalone.
&gt; Any programmers who followed through with it even though it was though Well, basically *every* successful programmer. If you're struggling with the course, how about using secondary tutorials, like the **Free Tutorials** in the **sidebar** of **/r/learnjava**. People who **really want to learn something** will find a way, no matter how difficult it is.
I think you just mistook /u/1110101010's comment as aggressive when really he was just making the point that JavaFX is simply not the popular choice at the moment, and added that if you only want to use what's popular the "current fad" usually lasts a few months to maybe a year. Just look at the number of JavaScript frameworks that have rolled in and out of popularity the last few years. There wasn't anything about his comment that sounded aggressive though :/ Also not about namecalling or anything, just seemed you were lashing out at someone who was really giving you genuine advice on making your thoughts and design decisions, which obviously everyone here didn't seem to like. 
Second time today i failed reddit, sorry man i just assumed they did.
I will say that Javascript dev has gotten so much better with Typescript, which angular 2 uses by default. It basically adds classes and interfaces and makes you feel like your coding in a real strongly typed language. 
We wouldn't use JavaFX where I work, but we would consider Electron as a wrapper around a web front-end. That's only really worth looking into if you have a specific use case around running an application directly on a computer (e.g. you need access to the file system).
The way AP computer science is structured is to teach you how to pass the AP CS test. I didn't actually learn how to program until maybe my 2nd or 3rd year of CS class in high school. I was in a similar boat as you for AP CS tho. I spent several hours working on that class and barely made an A. I remember it being a huge pain to have to spend all this time studying and was considering not pursuing it further but once we started to actually learn about objects and what object oriented programming is I was hooked and I knew I had to become a software engineer. School can make you wanna give up on any subject depending on the teacher. I would come up with a project idea you are passionate about and create it to see if you want to pursue computer science as a degree or not. Lastly, you have to remember “Nothing in the world is worth having or worth doing unless it means effort, pain, difficulty"- Teddy Roosevelt
Yeah I've used flow to do similar with type safety.
I am working on next-gen, web-scale, machine learning algorithm that hopefully conquer some of our biggest healthcare issues. . . . . . kidding, I do programming at work which is just another CRUD app :)
ewww
I am currently formalizing a specific language and writing a syntax, linting and auto-completion engine for that.
Good ole Reddit Hug of Death, I see
good advice, thank you :)
&gt;You don't get NPEs, you get some other exception resulting from not checking! This suggests that you haven't really grasped how Optional types are used. Unless I'm misunderstanding you?
Bioinformatics, mainly processing enormous amounts of data produced by the modern DNA sequencing technologies.
I just learned Java last term, so I'm trying to keep my memory fresh by doing a complete gomoku board &amp; AI in Java, implementing as much stuff I've learned in class as possible. Getting a decent AI is a bitch, though. God damn (and yes, I have read L.V. Allis' paper)
html5
Security system with firebase and samsung smart things rest api on the rpi2
Java was advertised as a compile once, run everywhere language but there have turned out to be caveats to actually making this work. When you create a Java on the desktop application you need a JRE and I'm going to explain why there is no sane solution other than to bundle a JVM with your application, no matter how bloated that alternative may be. FACT: No end user is capable of maintaining their own Java installation. As a java dev you absolutely can not trust that the end user has installed Java correctly or that the original Java application they wanted to use didn't alter/extend key java components your application relies on. Minecraft came out as a java GUI program that relied on the end user maintaining their own JRE, you can google that colossal shit storm of people asking for help for years until they finally bundled a jvm with the game. Anyone that attempts to rely on the end user maintaining their own JRE install is automatically going to incur a massive tech support responsibility for every conceivable computer problem the end user has, whether its related to your application or not. It will boggle your fucking mind at the leaps of logic end users will make to blame you for breaking their computer. FACT: The Java browser plugin that is delivered with the JRE install is the single largest security hole for the last twenty years. The Java browser plugin is the thing that allows applets to function. Many malware ads used the 'you need to update java' as an attack vector (similar to 'you need to update flash/divx/etc'.) This was such a pain in the ass to everyone that the browser makers themselves finally disabled use of Java plugin. Trying to get applets to work in a browser is an ever increasing difficulty, and it only gets tougher because browser makers have chosen to make it this way as an incentive to get rid of it altogether, just like Flash. FACT: JavaFX was a knee jerk response to Adobe Air and Windows Silverlight. They had no intention of making it last and everything has played out as planned. Both Air and Silverlight are DEAD. Oracle was late to the party with JavaFX and their efforts have always been lackluster from the beginning. Corporations often have to enter markets they have no chance of competing in only because they have to show up to the party to stay publicly significant. Look at Windows mobile platform, they have a paltry market share against IOS and Android yet they still are there, why? If you don't show up to the party, people will eventually stop inviting you to the party. That is the reason in a nutshell. So to summarize, JavaFX is sacrificial anode in Oracle's playbook and always has been. As a side note, you can laugh at anyone that complains about the Java installation trying to install an Ask toolbar or macaffee or whatever from java.com. That site is SOLELY a public relation site of historical value. Anyone that calls themselves a java dev gets their jdk/jre bundle from the oracle.com site. The number of people that shit on the 'oh my, java still installs ask toolbar' is an instant tell that they are clueless fucking morons that are only commenting because they once tried to run a minecraft server. The reason people don't install java from the java.com site is again because **No end user is capable of maintaining their own Java installation.** That leaves only one option, bundle a jvm with your application such that the end user never knows that its java at all. This in itself is a moot point because in the end, you must support all operating systems so you can send the correct jvm bundled application to the end user. Graphics libraries for linux are different from windows, are different for mac. Look and feel for these issues each have their own quirks. Programs exist to do this for you but the end result is a big ass download for the end user which usually doesn't match realistically with the quality of the application. Example might be a 500mb download for a sudoku app where as in html maybe a liberal 100kb of java script. Sadly, no one explains this to CS dept heads or key professors in college. Every one of them should be slapped upside the head or forced to maintain their own java application with a significant end user base. Until this happens, college CS depts will happily take your money and teach you a dead end technology all because they think that if they make homework of a graphical nature because....essentially... kids like games and games are graphical and thats what most CS freshman want to do. Every CS dept in the world is complicit in this crime.
My company, SEL, works with power systems too. Our software product for monitoring a power system is called "synchroWAVe." We've got great developers, so good luck. ;)
Sounds like an incredibly easy project.
I'm trying to write a civilization clone in Java. 
How far along are you? Did you find a tutorial or did you just kind of start?
What should i learn instead?
I hope not. It's the only cross-platform GUI toolkit I know of that isn't complete garbage. The only other truly-cross-platform GUI toolkits I know of are: * Web/HTML/CSS/JavaScript. Terrible. I was doing Swing layouts in 2004 that ran circles around what this dumpster fire can do in 2016. Flexbox is a joke. Form controls can't be styled without obscene hacks. JavaScript is a programming language for masochists. * Qt. C++ only. Problem: C++ sucks.
What kind of applications do you want to write, or what kind of career do you want?
The post suppose only developer are here and that's kinda true :) Working on material design for my android app.
I'm trying out a robot that my school ordered. They're called Finch Robots and have prebuilt classes you can use. The robot has temperature sensors, gyro sensors (I know there's a name for them I just can't remember), among other features. It's really fun, and I highly recommend it
Working on a bot that searches Google images for different countries, scans images of most popular images and then build a flag using colours and shapes identified from the images. It's an experiment for me to learn algorithms related to image processing. 
Open source and publish it on github. I'll contribute :)
Are there any publicly available databases for people at home to look at?
What form of encryption are you using?
It's probably an endpoint routing provided by your container. As people have mentioned before SOAP is implementation agnostic as long as it's compliant with SOAP requirements. JBOSS could be the one doing this for you. Try looking at its documentation.
wait so do people jerk off to anime pictures
I was not actually trying to promote anything. But having a look at my profile, now I too think it looks a bit like that. My website is completely non profit and is just meant to share knowledge. And the app, people here really helped me with it. It's helping to make the app better. And again, there is no financial profit for me on anything. But I do realize it looks like I'm spamming. I'll try not to do that. Thanks for bringing this up.
At work I'm building an Android and iOS app for morgage lenders and borrowers. At home I'm trying to learn Kotlin and Vimscript. Currently build a note taking app to mess around with programming concepts and functional paradigms. Absolutely love K and hope to make open source libraries for it. Wish more people would use it
Yeah, but that's not the real purpose of what I'm working on. I'm sure at least one of my friends started a folder for just stuff like that though. There's 55k images now so I can't be assed to keep track of it all. 
I am new to writing tests. I was first introduced 2-3 weeks ago on junit4. Then I thought "Better learn the new thing". So I started writing on junit 5. That was on intelij community and at the time it was M2. They updated a couple of days ago to M3 and I had to fix my project so it would work with M3 or make some additional changes for M2. So I changed it to M2. Then I decided to change from Community to the Ultimate Edition. And suprise, suprise, there isn't M3 on Intelij Ultimate. So now I have Intelij Ultimate but I am usung Intelij Community...
That's all right. I know that a lot of intent gets lost sometimes with text! I do appreciate your point, and I know that my title itself can come across as inflammatory (even though that was not my intent!). Good luck with your projects as well! :-)
I think there was all around confusion everywhere. And thankfully, there has been a lot of useful information shared in any case, so it's all good!
Nice try, rival company!
Working on a Producer Consumer program using Semaphores for my University assignment. As it's Christmas he's made it Christmas based, with Santa the consumer, Elves the producers, Santa's sleigh the buffer.
:P
Create a GitHub account if you haven't already. Don't just create your own portfolio, but contribute to others' code. This will show that you can contribute as a team member, not just work on your own. It also shows your ability to understand the code of others. Use tools like JIRA to track user stories and issues in your own code and commit/push incremental changes, not just "here's my last 3 hours of coding." Show that, even though you learned on your own, you're able to jump into a team and contribute. Attending local meetups for developers will help you network and potentially get your resume to the right person, bypassing the standard HR filters. Be careful not to let 2 recruiters send your resume to the same company. They work on commission and the company doesn't want to waste time resolving a dispute over who gets the money. Finally, grind. If you've applied for 10 jobs, you've barely started. If you can land several technical interviews within a couple weeks, you'll be in a much stronger position. 
Still exploring Spring MVC, so nothing too serious 'cept the project used for practice. GalagaJ is a shooter I'm putting my functional Java skills to good use.
I am in the Chicago area currently but am trying to move to California near San Francisco at some point. So I'm not sure how much that would differ from Europe, and yes I am planning on starting out primarily developing mobile applications for android devices, and eventually moving on to wearables and "internet of things" devices. Thank you very much for your advice, I am going to make a GitHub account right now. 
Thank you for your advice! I am going to create a GitHub account right now, and I am planning on attending a few meet ups in the Chicago area soon, I am using meetme right now. Do you know of any other meet up apps for meeting other developers? 
Working on transpiler WebIDL (from chromium source code) to Java. And ECMAScript 2017 to Java code. After I will write lightweight transpiler from Java classes to ES6 classes.
I think the next step and something a lot of people go to interviews without knowing is properly doing encapsulation, separation of concerns, polymorphism, once you understand that side of java, I would advise leaning spring
Neat! You use SableCC for that?
ADT Based data structure that multiplies, subtracts, adds and powers long integer numbers, both in an array and linked list. senior project lol. almost done yippee!!
It's a windows authentication thing. What we needed access to simply isn't available in the browser. But given how thick the client was getting, it was also just getting to the point that being able to use the same shared object model both in the client and on the server made life a lot easier. Better debugging also.
I'm building a game using default Java libraries. I'm still a high school student, so it's nothing crazy, but I like how its coming along.
It is actually already up. My github is the same as my reddit. Don't be disappointed though because I started yesterday and am working in between course work. It has a window and menu buttons. EDIT: [link](https://github.com/bashterm/openCivV). Bewarned, it's very rudimentary right now
Interesting - how did you overcome the lack of ready made usability libraries that was available in Swing? There's no docking library that's really good, there's no really useful table based utilities, table filtering. Pojo's have to be changed to have properties to bind to JFX. I would have expected if JFX had taken off there be a lot of opensource libraries available to do simple things available already. We have JFX and the lack of ready made or rich ecosphere means a lot more time engineering than app dev. We can't use other GUI tech's as we are thin on the ground and predominantly a java shop - no point using say HTML5 say. 
r/cscareerquestions has a lot more info on this topic
Running a robot on java is precisely what I wouldn't do.
Simply asking ye for help I wasn't aware some of you would get so offended jeeez...
Im in the same boat as you are OP. Recent computer science college dropout, I want to teach myself instead.
Right now I'm working through "introduction to Java programming 7th edition by: Y. Daniel Liang" its great. It has 20-40 keywords, 20-40 review questions, and 10-40 programming exercises at the end of each chapter (with 43 chapters) so I made my own class out of it. I take the top 10-15 questions in each category from each chapter and save them for tests. I test every 5 chapters, and this makes for pretty long comprehension tests. I am currently working through 2 full chapters per day (spending around 5-8 hours per day working on it, taking notes, and making my tests and answer keys) highly recommended this strategy. P.s. I got the textbook for less than $5 on thriftbooks. This is by far the best cost to value way of learning the introduction to Java I could find!
+1 for [Vert.x](http://vertx.io). Coming from Go/Node, it should be a quick transition. 
Thanks, i'll look into it. So the bottom line is I have to use some Framework to build a server app.
Looks nice.
My current project has been taking in a well formatted XML document (such as an ODT or docx file) and outputting formatted HTML. It's currently able to get plaintext (dead simple), but getting out formatted text has been a right pain in the neck, mainly because I've yet to find a good way of constructing an HTML document in Java without resorting to (shudder) String Builders. While I'm sure there's a metric tonne of handy libraries out there that do just that, I'm trying to stay away and puzzle it out myself (because, apparently, I'm a masochist) before I go make it easier on myself.
Native toolkits like .NET offer way better platform integration. The web frontend ecosystem is massive and both more diverse and usable than the Javafx and swing ecosystems. GWT and friends try to integrate with it but fail to do so. I've mostly given up on java for front end, it just doesn't work well there, in my opinion. 
Agreed here, it's really found a good niche on android and servers. 
Javafx is far from stable unfortunately, and swing has had very little development in the past years. You might as well use a web framework from 2010 now and you'd still be using newer technology 
I'm a Java guy but have been considering Qt or .Net for GUI work, as they run on mobile as well as desktop.
I know this might be a little bit off topic, but you might also want to look into kotlin. It's java++, so much nicer to work with, but 100% compatible with java code unlike scala (you can call kotlin code from java and vice versa). 
I'm also considering Qt, but I'm not sure if we can use this in closed source projects.
I've worked with Swing, JavaFX, WPF and WinForms in the past. Nowadays I'd definitely try something like Electron for a desktop application based on Web technologies, though. Seems very promising and success cases like Spotify and Slack don't seem to be doing bad at promoting the library, if you ask me.
Try writing an Android app. Possibly the most lucrative Java coding you can do.
&gt;Companies generally don't give a shit about either your degree or certifications. Over here in Finland companies do care, depending on where the certification or degree is from. Only practice no theory will almost always cause crappy code (in any meaning of the expression). Not to mention how experience is automatically acquired due to the curriculum in good schools.
Thank you! Im pretty solid with html, ill start looking at the others. Thanks again
I don't think there's a worse platform for developing desktop applications than javascript. Applications like spotify, slack and discord prove that point. Plus ... javascript when you don't need to use javascrip, not unless I had a lobotomy. The only argument I heard in favor of electron is that you write once run anywhere (like java). Applications like spotify and slack and discord and atom and vs code prove that it is simply not possible. This is why they have delays between various platform releases: there is native code, tons of it, written for each platform. The entire "write once run anywhere" thingy is a lie. Just like it was with java, it's the same with javascript.
I do a lot of hiring. Depending on what you are targeting there are different angles. Anyone who has an hr/recruiting firm does keyword matching on resumes for buzzwords in the area they are looking for. Even still its a rough rough process. Word of mouth and "hackathons/hack nights" have been our strongest driver. Find a company you like, find one of their events, show up. Having your own source controlled projects, understanding deployments out to perhaps your own webpage, it really helps people get a sense of how important the big picture is to you, enough so to invite you over for a coding session
because they know Java?
That has a lot in common with a JDBC database call, it's blocking.
Java on machines (though not being used in this case) is just fine. Real Time Java is what you're missing. The Real Time Specification for Java (RTSJ) 1.0 from JSR 1 and RTSJ 2.0 JSR is in JSR 282. 
Gradle is just Ant with Groovy as the DSL instead of XML. I'd pick convention over configuration/scripting every time.
For cross platform, Qt is king. Otherwise, if you're targeting say just Windows, .NET is excellent. I'd only use JavaFX for something really simple and that must be cross platform
&gt; Yes also your poker co pilot pisses me off Poker Copilot is my product, made with Java and Swing. Please do tell me what ticks you off; I'd love to know what we could do better. 
I'd not be surprised if your arguments turn out to be valid, in fact I'm highly skeptical of all this "write once run anywhere" thing (I already felt for this once with Java), but just out of curiosity, do you have any quotes from these companies saying that the benefits of Electron doesn't justify its adoption and that they would not do it if they had a chance to go back in time? Please don't take this as a challenge, I'm genuinely curious :). I like the LaF of Spotify/Slack so much that I'd happily live with Javascript just as I do in the web.
&gt; Applications like spotify, slack and discord prove that point what exact problems do you have with those apps? i use 2 of them without much of any issues.
Don't use java for ui
Except a web framework from 2010 may not work as expected in modern browsers. I maintain an swing client from 1999 and it still works exactly as it should on mac, linux &amp; windows but it sure isn't sexy. 
"THIS PREVIEW IS WRONG! The theme is actualy wayyy better." anyone got any screenshots to share? Not near my dev machine atm.
Oh I didn't say it's better than Swing :-) We still have quite a few Swing applications... and yes the libraries are much better... I wish there was something like Jide for JavaFX. Table filtering "like Excel" is at the top of my wish list... 
* Their UI sucks balls. They should stop doing drugs and think before they implement everything their UI expert suggests. * Bugs bugs bugs. If you've ever used discord or spotify for more than 2 minutes you would be hit in the face by them. * Use JS for the sake of using JS. Wtf is wrong with you people? * They fucking huge in both download size and memory consumption. Now, I do have a ton of memory on my desktop, but fucking shit, it's a chat app or a media player app. Why would you need to use hundreds of MB to several GB of RAM? Javascript, that's why. 
Nice.
If I take the numbers into a calculator (without the %) I get the same as Java, so nothing wrong with the calculation. To get the "correct" answer you need to use 0.0396 and 0.2526 instead of 3.96% and 25.56% Note: the % sign has a different meaning in programming it is a modulo operator. 
Create an interface for your plugins/addons to inherit, and create a register method taking any instance of that interface. Just like the JavaPlugin interface in MC.
Slightly off topic: Electron IMO pretty much wins the battle of GUI on desktop.
I had to use JavaFX for a class at university this semester (was hoping to take it next semester since it's an Android one but oh well). I went in expecting it to be like pulling teeth but I was pleasantly surprised. It's rather coherent and usable from the perspective of a novice. I also recently picked up Android development (since I'm gonna be a TA for that class and next semester is on Android instead) and it's pretty comparable. My team was even able to make what I felt like was a pretty good looking app with CSS styling on everything. The biggest problem I faced with JavaFX was lack of documentation and tutorials to build off of. With Android, there's a lot of established best (or even just good) practices that I can find tutorials for and build off of, with JavaFX I felt like I needed to figure it out a lot more of it on my own. 
When my team went to make our business case to migrate our internal call centre web application to FX, we had several reasons: 1. We all hated using javascript-heavy front-end frameworks. We were using backbone/marionette, and in particular, the event bubbling model was an absolute stinker to debug when something went wrong. 2. We're a Java shop, we use Java for everything else, so FX really doesn't require learning a lot of new concepts, and having only one language to write in makes it easier to bring people in from outside to quickly pick up the work. 3. There is simply stuff you cannot do in a browser sandbox, there are certain native APIs particularly related to security that you just don't have access to there. This was the reason that I suspect swayed it really, the business wanted access to some specific functionality, and we weren't able to provide it without migrating. 4. Performance. The application is way more responsive now, and much easier to optimize (imho) with flight recorder. 5. Just more goddamn fun! 6. Quick to port over to. One of our team managed to port several pieces of functionality over in his spare time to give the head of development an idea of what it would be like. I keep seeing these threads popping up about how awful Java FX is, despite the fact that they don't seem to have used it in any sort of major project. It's probably not great for certain use-cases, but in an enterprise environment where you need a lot of power, stability, and performance, and you have a team that has a very strong background in Java, I think it's a great tool for certain jobs.
Here's probably what you are looking for. [Stack overflow](http://stackoverflow.com/questions/3093434/execution-of-groovy-code-in-java-at-runtime)
Sorry didn't know. Will do from now on thanks man :)
You're right, of course. However, sometimes dependency upgrades just drag you along. Still, I'm not necessarily a proponent of Java GUIs, just throwing something I had read into the mix.
Groovy is still a very valid option. The groovy scripts and classes can be loaded at runtime, with or without compilation. 
What's wrong with Swing?
For creating a web app in Java, I'd use https://projects.spring.io/spring-boot/.
I've never thought to hear things like massive frontend ecosystem, diverse, native and platform integration (except Windows) for .NET. Diversity is something else, certainly not .NET. 
It is easy to include simple 3D renderings and the surface looks decent on Windows, Linux and Mac. Building the GUI was a breeze and the team could focus on the logic instead: [Object Graph Visualizer](https://github.com/Nurtak/ObjectGraphVisualization) Screenshot: http://imgur.com/ZbT6Ihn
You can build the complete GUI without relying on CSS or FXML. It's then actually similar to Swing, just without the Gridbag and resizing headaches.
Didn't know that. Thanks for telling me.
btw. What do you think about Spring (Netflix OSS) vs Java EE (Adam Bien Way) in microservices world?
Slow, memory hog, buggy and crashes. But the worst is that they have no native feel to it. In fact they look like those incohorent Flash ads. I know "look and feel" doesn't have necessarily have much to do with the framework, but there most be reason why they all look the same.
&gt;&gt; I used quite a lot software written in Java and they all were crap, slow and weird. &gt;They are crap because people learn from crappy tutorials you can find on the web instead from official source. &gt;Blocking UI thread is bad thing and documentation mentions it several times. Yet people do this notoriously. Even big apps like Eclipse and IDEA were often guilty. There are mainly two types of people that complain about Java speed: people who write real time applications that actually need the speed and naive fanboys who think that saving 0.00058 seconds per 20,000 items in a sorting algorithm will make or break their toy app.
So... ASP.NET?
Lucky you having 10 members in one team. My slack eats ~2gb. 4 teams x ~600 people each
f electron, seriously
Frontend! JS, HTML, CSS
[Betteridge's law of headlines](https://en.m.wikipedia.org/wiki/Betteridge's_law_of_headlines). Java is always going to be more verbose, but it is becoming less so with time.
Why the hate ?
Thanks. I find it much more readable than the built in dark theme. 
My point was simple: it's all in the profile, the language is just a conceptual model, and Java is simple enough so well-rounded subsets of its model can fit many targets. Say, realtime programming, why not: https://www.ibm.com/developerworks/library/j-rtj1/ Depending on how the tooling is realized, there shouldn't be any difference whether you code in C or Java. Java may take care of a few more things, but that's not necessarily a con. Because bugs happen due to C's "anything goes" model, as well. You may have heard of Toyota "sudden gas acceleration" issue, the culprit was spaghetti of C code.
And it's not Web 2.0 enough.
Real content starts at 6:28. And here's part 2: https://www.youtube.com/watch?v=4a7twg_Zvco. Ending part: https://www.youtube.com/watch?v=jf1FyroqjoY.
sounds like it's more than just a chat app if you can communicate effectively with ~2,400 people...
&gt; That doesn't seem too excessive, at least to me For a chat app? It does nothing else but send and receive text. There are IRC apps out there that do that in KB of RAM. Their language of choice is reflective of their programming style, ideas and workflow. You can make a chat app in any language you want. Really, any language. They chose JS. You "choose" JS when you live in the browser, since you have no other option. You don't do that in the desktop.
Indeed. At the moment we just run on windows, but the possibility of both running it on another os if we need to, or possibly monetizing it in the future are possibilities that wouldn't be there if we had written the application with wpf or something.
you dont. you could write a rest server in java though
Thanks. I guess "wrong" wasn't really what I meant, more like - highlight the differences to convince me to download an extra one :)
exactly
This video was filmed in mid 2015. They mention a third edition of Effective Java that would cover Java 8. I would buy that book in a heartbeat but I don't think it has been published yet. 
There are ports. On iOS this requires an AOT compiler, since a normal JVM is not allowed on that platform. Android runs Java code semi-natively, so yeah.
You could always print the data to various types of files. I use text files for some things, delimited by a "|".
Just like JavaEE receives a lot of crap by people who either haven't used it at all or used it so far back they still call it J2EE.
You can try using JaxB or Jackson to marshal java objects to XML or JSON, respectively. You can then print those files to disk. Other possibilities include using a database with a framework like hibernate to manage the persistence, but that might be a little advanced. 
Nope. Looks like we'll have to wait a while!
Hahaha... yeah, I've found this laxity especially in Google Hangout videos. Very annoying indeed.
You can always give feedback to Simon, for example trough his Tweeter handle @sjmaple or directly on vJUG @virtualJUG.
yes, i read a stackoverflow thread about Serialization, but briefly skimmed the Java Tutorial linked in the thread. With serialization I guess I would have to create a object to store objects like a hashmap, and serialize it and every object i store? To my understanding serialization just helps keep track of objects.
its a small application that will only ever be used by my computer. not looking to develop it once its done, just want a small program that does some work for me. data i need saved are just small objects that contain some string data. thanks for your advice i will look into serialization since it seems to be the popular result in my searches. 
sounds simple enough thanks.
Look at this cable mess! It looks like R2 threw up back here! 
You can now install this using Homebrew: `brew tap spilth/tap; brew install savant` You can also now easily initialize Maven projects using just `savant init`
Easy enough for [Properties](https://www.mkyong.com/java/java-properties-file-examples/) probably. It saves key value pairs as String. Meant for simple config files.
Ladder Logic... It's like Assembly and Basic had a child :(
You should not have to be defensive inside your codebase. Lib can return null if it wants that's where optionals are great. Methods in your codebase should never return null. You should checkout the 3rd pattern : http://code.joejag.com/2016/anti-if-the-missing-patterns.html And i'm repeating myself null+optional really IS a bug. The solution is not using if (value != null) or Optional.ofNullable(value) in this case. You should instead understand why the method you called returned null. Checks should only be done when you call an API that don't return optionals or when you can't access source code of the method you're calling ;)
Here is my experience...I tried to learn android before really understanding Java and I found it incredibly frustrating and difficult. I then focused on core Java and when I went back to android it was easy and fun (at least the basics)
I'm writing my own implementation of Scheme R5RS in Java.
For saving key value pairs, I would use redis or if I wanted it to be portable : gson.
The problem with serialization is that it is both difficult to maintain compatibility using it and that it is very hard to deserialize untrusted data securely. It's also not human readable. Json is usually a better idea in my opinion
Can't help you sorry, but I'm 16 currently and not aware that this sort of thing is real. Thanks for the insight I hope a up vote helps you out
Huge parts of the book is still relevant no matter what year it is. Even without Java 8, the book is still worth looking at.
With all their vulnerabilities.
thanks :D i hope it stays fresh for you
I appreciate his response, but owning a company is not for everyone. Especially not for more.
Absolutely agree with everything but slight disagreement with the last sentence. I used to spend too much time with computers as well. But I believe what I do still defines a big part of who I am. I just realized it cannot be the ONLY part. But otherwise yes, as much as I love coding and building things either for work as a hobby, it took me too long to realize I could be a better and healthier coder if I wasn't just a coder
&gt; There are so many technologies and so many new things, it's impossible to keep up This is something that you just need to accept. You can't keep up with everything that's happening and you never will. The field of IT is just too big. What you need is to know enough to solve the problems that are relevant to you. And to pick the problems that you enjoy solving. Also, if you don't enjoy programming then ... welll ... maybe you should stop doing it. It's not like you have some obligation to keep programming. I totally agree with the recommendation to find a non-computer hobby, though. Some sport, beer tasting, photography, playing an instrument, whatever.
Yeah but how can you just leave it all behind? I can't not do this for a living.
I don't know what else i could do, not to mention that programming is the only decent paying job here. I do have non-computer hobbies, but maybe i could do better. About the technologies, it's overwhelming to see how fast everything changes, i guess i need to accept that i won't know all of it. 
Just shut all news channel and all the BUZZ. i feel like you are too much to the internet. TL;DR just ahut down your phone yr pc and enjoy your outside life 
Yes, well. With everything that's happened in 2016 (including 2 elections in my country), it's not so easy to switch off :D
Don't let a prolific coder cloud the way you perceive your career/life. Just because someone can spend 12+ hours a day doing nothing but coding doesn't mean that you have to as well, or that you are any worse for not. I shut off at 5 when it comes to code. I use to code in my free time, but then I got a job and I realized I just don't *love* it like I really thought I did. There are so many other things for me to do that I have decided that I would like to do them. I cook. I play guitar. I bike. I read. I play video games. I walk the dog. I clean my house/yard. Etc. Its ok to like or want to do these things above your career. 
&gt; Note: The gateway is disabled by default because Slack can make no guarantee about the security of any IRC/XMPP client (including transport encryption or data security). We recommend you enable only the gateways you intend to use and trust only those clients you have evaluated thoroughly. For the highest level of security, we recommend using only Slack's desktop, web, and mobile clients. hipster IT people that get scared by the FUD Slack is spreading.
No problem. Don't give up!
Switch to node.js and get a high-paying job ASAP
It's been 5 hours, have you switched off your computers and gone for a walk yet?
Hello everybody. I used to work with Java and Hibernate in past and Hibernate in my opinion one of the best ORMs ever exist. Now I want to show you guys TypeORM - Hibernate-like ORM for TypeScript and JavaScript that can be used both in browser and node.js platform. I want to hear feedback about TypeORM in a humble comparison with Hibernate. And if you are using, or interested to have Hibernate-like experience on node.js or browser platforms using TypeScript or JavaScript - then feel free to jump in ;)
Not judging the quality of your courses here, but a friendly word of warning: You cannot keep submitting only links to your youtube tutorials. This is considered spamming and also forbidden according to the *reddit self-promotion* rules. Only *one* self-promotion is allowed in every *ten* contributions. On top of that, you need to *participate* in reddit discussions. Currently, you fall fully in the "spammer" category, especially with your submission frequency. What you are doing could easily earn you a reddit-wide permanent ban.
So what advantages does this provide over json for configs?
9 submissions alone in this sub. Today. 100% youtube links, every one of them with an attribution-link. 14 submissions in the last 24 hours (and a single one 3 days ago). Definitely a spammer. Reported as such.
More appropriate for /r/javahelp. However, see https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html
GridBagLayout was made for GUI builders and not meant to be coded by hand. Avoid GridBagLayout like the plague. Use BorderLayout and BoxLayout.
1. Since this is help with *Java programming*, it should, as the plenty hints on the page indicate, be in **/r/javahelp** - but please read the [**Posting Guidelines**](https://redd.it/48eykt) there *before* posting there. 2. [What have you tried?](http://whathaveyoutried.com) - nobody, neither here nor there is going to do **your** homework. **You** need to come up with something first. **Post removed:** programming help
We have a few internal applications as well as a few client facing applications that are written with Java and Swing, and deployed with Java WebStart. They work great and even today I don't see realistic way to make them into web applications. They are client/server applications which handle anywhere from 10-100+ messages per second. I can't imagine a web browser being able to handle that many messages per second and updating the GUI in response to the messages. Java/Swing handles it no problem. (and you couldn't even consider trying until the relatively recent addition of WebSocket support in browsers). 
Of course people only want web applications on the desktop. On a mobile device everyone wants native apps. Some things work well as a web applications (e.g managing configuration information and paying a bill online). However, something like http://www.trello.com should really be a desktop application. People complain Java/Swing doesn't look native. However, they then use a web application where each one has a totally custom look-and-feel and there is nothing remotely native about it. People need to make up their minds. 
Dude, especially with everything that happened in 2016 it's better to switch off the news. The world will move on. Otherwise you'll just fall victim to this: https://en.wikipedia.org/wiki/Hostile_media_effect While there's plenty of positive news in the world, there's nowhere near enough positive news ON THE NEWS, so if you keep watching news, you'll end up depressed. 
I can almost guarantee with the way the world is going you're going to get even more burnt out if you continue to follow politics and world events the way you do now. 2017 aint going to be any better.
Burnout can be very hard to overcome, there is a good chance you will never feel as enthusiastic about programming as you did before. The healing process will take time. Take a vacation, spend a month or two traveling around the world, go new places and meet new people. Learn a foreign language, or a musical instrument, basically, find something else to dedicate your time to. On the job, you can move to management, or try a different kind of technology. Radical career change is also an option, but I feel it's only for a case when you absolutely can not stand the industry any longer. 
How does it compare to TypeSafe Config?
Doubt it
Wrong subreddit. And stop asking people to do your homework for you.
The only similarity is the word Java in the titles. That's all!
Very true, for all occupations. There's always the myth that the grass is greener, but the key is to do good work, and life a life outside of career that you enjoy... 
I can feel you. You know, there are other ways to "go beyond" than keeping up. Become a domain expert and focus on one area only, and get really good at that. Of course, that's just one option. There are others that might not involve coding.
I got a bit confused about the "dark maroon" static fields. Then I downloaded the theme from the site and WTF?! It changed/resetted some attributes... static fields' foregrounds are wrong and the Kotlin scheme is f*c*ed up... it seems that the website is discarding lots of data from the XML scheme file... sorry about that :/
Is there not any other roles in the software development you could do? Team leader, project manager, scrum master, business analyst etc. I know plenty if people that got "tired" of programming and switched over to such a role.
Get a dog and do long walks in the wilderness, if you happen to live nearby such places.
voice of wisdom! stopped watching/reading news a month ago and feel so much more relaxed and happy! 
I think so. Just did a fast comparison between the original scheme file and the exported scheme file aaand... http://imgur.com/gallery/xUUE2 Not only it is removing some XML nodes... it's also replacing all dots with $, invalidating colors for other languages like JS
It sounds like you want akka cluster sharding or akka distributed data.
Step 1. Unplug from all the new stuff for a few weeks, tech news.. twitter.. github emails. Just shut if all off. Leave work at the same time and act like you have something better to do. Step 2, go find something better to do. Go find a hobby or activity that you have been interested in doing but never got around to. BJJ, welding, lock-picking, bowling, pinball, travel and immerse yourself into that for awhile. Your love for coding will come back. If you are just that type of person that can not get out of the loop and get away from the computer. Then hop onto a feelance site like upwork or something and find a fixed rate job that is a 180 from what you do. If you are a Java/Linux guy, go grab a C#/Win8 task and challenge yourself to complete it. Even if it only pays $10.
This. I love programming and some days I can contentedly sit in front of a computer for 12+ hours. But I agree it's not good for you. I'm an avid outdoorswoman. I hunt, I fish, I hike, I camp. I have found that having more than one passion prevents me from getting too burned out on one or the other. And nature therapy really is good for the soul. 
For me, there are 3 things that help me recharge my batteries: 1. Wood working. You compensate something very abstract with something concrete. 2. Astronomy. Amateur, but within a year I am able to distinguish the constellations even if the sky is partially covered. 3. Gardening. This summer we've only eaten tomatoes from our own garden. Bought a country side property 1 1/2 yrs ago. My advice: try to have a fixed program. Go from 9am to 6pm, do what you can, find something you can do without the computer or phone, go to sleep at a fixed hour. Don't sit in front of the TV, in fact forget you have one. Find something concrete you can do with pleasure. My hands are now uglier but my mental strenght have never been better.
Apache Ignite
this is much smaller in scope. this is more like an enhancement on Dropwizard Config.
It's not that they know "every nook and cranny," they simply are more familiar with different nooks and crannies than you. They probably look at you and think the same thing. 
Lol
Have you tried taking some time off? Developer burn out is super common. I went through something like that a few years ago and took a leave of absence from work and traveled for a few months. It helped a lot. 
I really do appreciate your comment, and i really do understand how that would motivate me. But you also have to understand that not everyone is made for it.
Yes, i realised that after i posted and was wondering if someone will point it out. It seems you are that someone i was thinking about :D Also, can't edit the title.
Hey guys, I'm an author of the site. I'll try to explain how it works. (Disclaimer: I'm not in JetBrains team and have no relationship with them) When you upload a theme - site parses xml and extract color identifiers and values for them (actually there are 2 different format of storing that information in xml). That pairs are stored in database. When you downloading a theme - site generates JAR archive based on that color pairs and recreates XML file inside of archive. All JetBrains products can import settings in jar archive, but some of them exporting colors in *.icls files, that why it needed. Common problem is - that theme file can contain not all color pairs (its about 300 of them and growing when guys from JetBrains adding new features). In that case IDEA uses fallback mechanism and use some other colors (mostly from "general" group) instead of missing ones. But for some cases IDEA do not provide fallback colors, thats why some of missing colors can be black/maroon etc. Thats why theme that initially contains coloring only for python maybe partially broken for javascript. Now about previews on the site. It displays only colors from "general" section, because they are set up correctly in the most of themes. I did not implement context-depended coloring (like static fields, etc) in a reason of that crazy fallback mechanism. It is doable but I have no time to implement it. If some of you can help with that - you are very welcome - all the sources are open: https://github.com/y-a-r-g/color-themes P.S.: sorry, I'm not a native english speaker, hope this post makes sense 
Yes, I can recommend that. I felt burned as well (I'm 35, coding for 20 years now) and this summer it got really bad so I decided to quit and simply "take a leave". I'm on that leave since beginning of November and I already got much better maily because of two things: 1. I don't have any plan about when I'll go back to work (this annoys people around me cause they can't understand that I'm simply not looking for work - made me realize the world is really crazy today) 2. I'm still coding and I live in the programming world even on this leave, but I learn things I always wanted to learn and I'm doing things I always wanted to do. So I'm helping with some opensource projects, I'm strating my own open source project, I learn things which will be totally useless in my carrer, but which were aways interesting to me etc.... it helped to bring a joy back to the programming... After 6 weeks of such leave I feel really good and I'm starting to think about next carrer in coding, which is quite good considering I wanted to quit this industry completely in summer... 
.. note that I want citus and build my own pg in that case. While citus needs pg. I don't need app-level though.
The 90's called, it wan't it's article back.
Crawl back under the bridge, troll. No one's paying your tolls today.
hi didn't understand this meaning.......
I enjoyed this article. You should make an infographic about Car vs. Carpet and post it to /r/cars.
While JavaFX is an ok-ish framework for desktop UI, the examples on oracles site are anything but beautiful.
lambda slower than inner class? i am skeptical 
I have used mapDb a few months ago, maybe it is an option for you https://github.com/jankotek/mapdb
&gt; I’ve heard many times that Java IDEs have refactoring abilities bordering on wizardry, so surely an attribute could be automatically changed to use accessors if necessary. Anything that references that class would also have to be recompiled. It's why you're encouraged to use accessors when you start writing code instead of converting public variables over later. C# encourages using properties instead of public variables for the same reason.
I feel the same way as OP (even though I'm only 27) and I can totally see myself doing something like that in the future. It's especially discouraging when you see people around you being so much more passionate and better (had this feeling all through uni). But I'd rather not think about the things I don't know and focus on the ones I do. I prefer to take it one project at a time. :) I regret however not having the energy/passion to code in my spare time, the last thing I want to do when I get home is to look at Eclipse, even though I do want to learn new technologies. TL;DR: I'm in the same boat as you, OP.
See discussion here, particularly this answer: http://stackoverflow.com/a/35031412
*clutches static typing defensively*
Thank you very much for your time explaining it! I'll surely try to contribute to the project when I can
I'll read this right after my lobotomy 
Etc/XXX Timezones have the opposite sign of the now commonly used ISO 8601 standard and thus of GMT/UTC timezones. In Etc timezones, the positive sign indicates *West* of Greenwich whereas in ISO 8601 it indicates *East* of Greenwich. In Etc timezones, a positive sign means Greenwich is ahead, whereas in ISO 8601 it indicates ahead of Greenwich. So, Central European Time (CET) is UTC+1 because it is *east* of Greenwich, but in Etc time it would be GMT-1.
nvm the error that both statements do not print the same (he used `range` instead of `rangeClosed`) but this is also a valid solution IntStream.rangeClosed(1, 5) .boxed() .map(i -&gt; i == 3 ? "dear NAME" : "to you") .map(it -&gt; "Happy Birthday " + it) .forEach(System.out::println); the equivalent code would look more like this using `IntStream` IntStream.rangeClosed(1, 5) .boxed() .forEach(i -&gt; System.out.println("Happy Birthday " + (i == 3 ? "dear NAME" : "to you"))); and personally I think the more idiomatic way would be IntStream.rangeClosed( 1, 5 ) .boxed() .map( this::happyBirthdayToYouButOnThirdCountToNAME ) .forEach(System.out::println);
For the last example, it would have to be a method reference. So it'd be `this::happyBirthdayToYouButOnThirdCountToNAME`. God I hate the naming convention...
That description is from Guice's own website. Guice is definitely lightweight in terms of breadth of API/function in comparison to Spring which was/is the rival library. I don't know if Dagger is necessarily more lightweight, since it needs a breadth more Annotations the benefit being it does compile time bindings.
On my phone right now, so I can't double check, but I believe the properties you're looking for are: deployment.security.TLSv1.2=false deployment.security.TLSv1.1=false IIRC, you can make them unchangeable by the GUI by also setting the matching \*.locked properties (e.g., deployment.security.TLSv1.2.locked). When I get back to my office I can double check, but give these a try. (E: formatting)
Anonymous classes *are* inner classes.
Thank you! I'll give that a go tomorrow; I guess oracle didn't feel like including those with the rest of their deployment.properties documentation :/
I have "knowitall-itis", no solution so far. Only hint I got is to find a "boring" shop to work at, boring in the sense of using an non recent stack (say Java). No thrills but you might only need to relearn once every 4-5 years rather than every 6 months.
It doesn't hurt to be specific when nitpicking the performance of similar things, I think.
OK, now that I'm back home I gave it a shot, and I remembered the enable/disable properties correctly - they do indeed enable/disable TLSv1.1 and 1.2 (there is also a 1.0 property, FWIW). However, I forgot to mention that the .locked properties only work in a system deployment.properties (i.e., the one pointed to by deployment.system.config in ${deployment.java.home}\lib\deployment.config). As for documentation, yeah, I first heard about those props on the Oracle Java blog (https://blogs.oracle.com/java-platform-group/entry/java_8_will_use_tls). I don't know why they haven't yet updated the Deployment Guide.
Well yeah, but not all inner classes are anonymous. So it stands to reason that they are talking about only the inner classes that are anon, not all of them. 
Is there any difference in the implementation of anonymous and named inner classes? If not, then it probably does hurt to pretend like that difference matters.
Is there a practical difference in the implementations of the two types of inner classes?
As far as the compiler is concerned, the only practical difference is availability. Anon inner classes are only available where they are defined. That makes them highly analogous to lambdas and in fact you could create an anonymous inner class definition anywhere you could use a lambda. Named inner classes are not necessarily defined where they are used. They could be used multiple times within the enclosing class or even outside it. In the comparison that was made, the semantics of the anon classes are important as they are essentially what lambdas are shorthand for. While the distinction is only semantic, I think it is a valuable distinction especially for any inexperienced developer who may not know otherwise and sees this thread. What you said isn't wrong by any means, but being specific is valuable. It would be similar to the distinction between a car and a Mustang. Sure, a mustang is a car but if you're talking specifically about the mustang, it makes sense to refer to it as a mustang and not a car. Sorry for the rant, I'm sick so my coherence isn't top notch right now. 
Everyday tbh
GOTO 2013 • Lambdas in Java: A Peek under the Hood • Brian Goetz https://www.youtube.com/watch?v=MLksirK9nnE&amp;feature=share 37:00 min Lambdas speed is equivalent to inner classes in the worst case, but better in most cases. The whole video is worth watching.
Scope I'd think is a practical difference
I've got this generified bifunction for you so you can break all that!
The same can't be said, really, because they are different constructs. Anonymous and named inner classes are literally the same constructs, iirc.
The best option for the happy birthday song would be to write out the actual song and append the name variable in it. No loops, no streams, everyone can instantly understand what it does. (Although I can see that this wouldn't scale for hundred lines, then for loop would still be better.). I kind of agree with the article, less code is not always better. And writing some clever stream appending oneliner instead of simple loop, is shooting your team in leg, because it's harder to understand it and notice bugs by code review.
Try using java.lang.Math without using statics. I'll be right here.
 class Bob { public static int test = 10 ; } You access it like so: System.out.println( Bob.test ) ; // Prints 10 Bob.test = 5 ; System.out.println( Bob.test ) ; // Prints 5 It's associated with the class, not an instantiation of the class (an object). Bob foo = new Bob() ; foo.test = 5 ; // This is not required to access test Because *test* is **public** it is shared/accessible from anywhere in the codebase. Another class can access it, if *test* is modified then anything else accessing it will see those changes. A good example of **static** usage is [Color](https://docs.oracle.com/javase/7/docs/api/java/awt/Color.html). Color uses it to pre-define a set of basic colours so the developer doesn't have to instantiate an object and know what RGB values it should be.
The insight is that there exist query systems that can optimise query expressions if those expressions are written in an adequate query language, rather than manually implementing the corresponding algorithm using an imperative approach.
Math math = new Math(); double myPi = math.PI;
i have tried everything and i am facing problem in selecting each pixel as the size of the pixel varies,if i click twice on same pixel it will be deselected 
You could add this to your previous question as a comment. This subreddit is not for **programming help** (that's what **/r/javahelp** is for), nor for **learning Java** (that's what **/r/learnjava** is for). Your post stays removed because it is more about programming help/learning than anything else and thus doesn't fit here.
Since this is help with Java **programming**, it should, as the many hints on the page indicate** be posted in **/r/javahelp** - we even have a separate "SEEK PROGRAMMING HELP" button here. You will need to read the [**Posting Guidelines**](https://redd.it/48eykt) there because your post is in no way acceptable. You need to provide far more information and include [**what you already have tried.**](http://whathaveyoutried.com) &gt; i have tried everything Doesn't tell us anything. **Code** tells us what you have done. **Stays removed:** programming help
Well, there was an attempt. Good folks at Oracle/Sun wisely made that constructor private, though :-)
&gt; It can't because any lambda expression is allowed to capture scope from outside the stream. It can have side effects. With those, SQL-style optimisation is impossible. I somewhat extended my comment up there, so this point wasn't made while you were replying (sorry for the ninja edit), but this is the small problem, because you can analyze a closure and determine it's "pure" and then "reify the loop" so to speak, and eliminate some overhead. This is what Rust does. The bigger problem is there's no such thing as "data index on a stream". And plenty of the optimization SQL does come down to using an index.
If you mean "Can I live without ever creating static methods in my java code" then the answer is "yes". If you mean avoiding them altogether then I would say "probably not". In fact, I would encourage you to avoid them if you're unsure of how to use them. It's not that they're tricky or anything but there are limitations imposed on you when you use them. Namely, you can't override them and they aren't polymorphic.
Yes, and that's also why people did not switch to cars to get anywhere, because cars need refuel, repair, all those hassles. Just walking on your legs saves so much time. Legs do not need refuel or repairs.
The OP made the mistaken assumption that "BlueJ but it is only supported on Windows, OSX, Debian based OSs". I was mainly trying to correct that and point out that BlueJ runs on _any_ system where a java runtime is available (like any pure Java application should).
Reflection to the rescue!
After your lobotomy? The fact that you keep reading and commenting on the java sub reddit just to tell people that the tool they use to support their family isn't as good as the tool you've chosen tells me you already had one. 
You just need to *cast* the elements in question to `Teacher`. This is possible since `Teacher` is a child class of `Worker`.
I agree. This is a ONE line basic thing. This is a waste of a post. I don't even get how this can be upvoted here...
Thanks man. I knew its something simple im missing. Thank you for the answer, really appreciate the information. its working now!
800 euro a month in Poland is roughly the salary for Java interns. Juniors would earn ~1350 euro. A bit more in Warsaw, a lot less in smaller (&lt;200k people) cities.
Ok. 
I won't lie, calling it a "wrapper" when it really acts more like a mutable copy of the list seems like a very confusing name to me. It is like a mutable copy that has a copy-on-write optimization I guess.
OK, I called it *Example* to avoid this discussion :P
I get that :) But I think from the article the "asJavaMutable" and "toJavaList" are the same thing: they both provide a mutable copy of an immutable list in Java List form.
Oh god, whyyy... If you really, really need to replace "for" with a stream (whyyy...) then do it, don't add maps and whatever you can in there IntStream.range(1, 5).forEach(i -&gt; System.out.println("Happy Birthday " + (i == 3 ? "dear NAME" : "to you")) ); But whenever you do it a kitten dies. So please don't. 
I don't understand why anyone would ever use Scala. It's a cool language, but backward incompatibility is a deal breaker imho. I guess I can imagine writing an application in it, but a library? Never. 
OK, but in the end, it doesn't really matter, does it? Since the source list is immutable, it doesn't matter if you keep a reference to it, or not. The important thing is that you start out with the same data (and sequence) as the immutable list.
If you structure it that way, then it is no different from from a normal for loop. At the end of the day, the example is trivial enough that it does function better in the for loop, but my code is a "correction" if you would to the one posted in the article. Streams are meant to split work into individual units, forming a pipeline of instructions, and that's what mapping is for. The `map` operator also allows each task to be **functionally pure** (your way concatenates the `String`, which relies on the built-in `StringBuilder` which is a mutation). Edit: I guess the whole `StringBuilder` being functionally pure can be made irrelevant by the fact that in other languages that are pure, I.E: Haskell, it could be done as... foldMap printBirthday [1..5] where printBirthDay n = "Happy Birthday " ++ (if n == 3 then "dear NAME" else "to you") ++ "\n" Which arguably, if Java did the same, it would be fine. Map is still appropriate here however... Edit 2: Had to edit above edit so it looks better and more understandable.
Have your security department weigh in. They may help create incentive/$ to upgrade the software. Rolling out a deliberately vulnerable version of Java to all your faculty feels super cringe to me.
Agree
This is a solid framework for 2D games/visuals in JavaFX. 
Umm so how exactly am I supposed to da a join with flatMap?
I was joking because ng router is at 3.x they're upgrading to 4 soon. Rubbish framework 
Well same deal. Can't have statistics on a lazy stream. 
Nice. Because of what you posted, such use of statics will be discovered in over 68 thousand codebases over the next 10 years.
Ethernet is used in industrial automation as a bus. Systems like [PROFINET](https://en.wikipedia.org/wiki/PROFINET) (the Ethernet version of [Profibus](https://en.wikipedia.org/wiki/Profibus)) and [Modbus TCP/IP](https://en.wikipedia.org/wiki/Modbus) have been around quite a while. Ethernet &amp; TCP/IP are the link from the controllers to remote devices or remote I/O. This is nothing really new, nor revolutionary.
 collection1.stream().flatMap(x -&gt; collection2.stream().flatMap(y -&gt; { if (x.id.equals(y.id)) { return Stream.of(new CombinedRecord(x, y)); } else { return Stream.empty(); }; })); Streams are not particularly efficient, nor recommended, for this particular task. But they are able.
You're right, I wrongly assumed Color was just a bunch of constants.
Maybe we can... In the general case, obviously not. But sometimes the data source knows more than we can get from just an IEnumerable interface. What if, in some cases, it actually could provide basic statistics in the stream's header? Enough to do things like choose which join operation to use.
&gt; What if, in some cases, it actually could provide basic statistics in the stream's header? Enough to do things like choose which join operation to use. Hmm we can form a standard for such data providers, and then we can convert the stream operations into a standard query. We could call this "Server Query Language" for example, and when we natively do this from our language, we can call it "Language INtegrated Query". Sorry, couldn't resist :P.
I need help with this problem, Im new to CS
He should actually try to solve it himself first. No one is going to help him if he's not going to put in any effort. 
Thank you for putting effort into writing all of that, i promise i've read all of it :D I've had the urge to try new things for the last 2 years, so maybe it's my body telling me i should explore other passions as well. I just hope i won't loose programming forever, i know i still love doing it.
How is it obsolete when everyone says as a Java programmer you should learn it? I'm just asking because I hope to be a good programmer and there's so many frameworks and tools, I want to learn the right things. Maybe I'll just get really good at C and assembly then nothing can fuck with me
I completely agree, on my current project we create a bunch of static methods only because 80% of the time our stream only did 1 operation, it reduced a lot of boilerplate. Having those methods on the JDK or somewhere else would be nice
There's [jOOλ](https://github.com/jOOQ/jOOL) or [StreamEx](https://github.com/amaembo/streamex) that add some additional features on top of streams... (bias disclaimer: I'm behind jOOλ)
What use does this serve for Java devs over and above what Intellij enterprise includes? 
If you want to take this one step further, `flatMap()` is really more like the SQL Server/Oracle `CROSS APPLY` or the PostgreSQL/Oracle `CROSS JOIN LATERAL`, i.e. the "right stream" is produced for each element of the "left stream"
We could do a heuristic, though. Sample, say, 20 stream elements and over time, improve your samples...
To give you the short answer: Coati is a source explorer, made for reading and understanding source code faster, which developers actually spend most of their time with: https://blogs.msdn.microsoft.com/peterhal/2006/01/04/what-do-programmers-really-do-anyway-aka-part-2-of-the-yardstick-saga/ Coati combines a simple search box for finding any element in the whole codebase, an interactive graph visualization to show the relations to other elements and a concise code view with all the details of the implementation. With this UI concept it's very simple to explore and navigate relations within the source code. Download our trial to find out for yourself, it includes javaparser (http://javaparser.org/) as sample project: https://www.coati.io/trial
In fact, you didn't answer the question at all. I have all that in Intellij already! [edit: fixed typo] 
Even if you switch over to Spring (Boot), you can mix and match Java EE frameworks with it so all is not lost. I'm currently developing an application which uses Spring Boot and Apache CXF for JAX-WS (which is Java EE specification). You could also be using JPA, another Java EE specification. So even if you're not using a full fledged Java EE application server like Glassfish/Payara or Wildfly/JBoss, knowledge of the Java EE frameworks will still be useful.
This guy does not seem to understand what the technology is. I have been reading about the death of Java and the death of Java EE for 10 years. It remains as popular as ever. The only other major framework is Spring and most Spring applications use parts of Java EE as well.
Obsolesense != dead
In my opinion the most important thing that makes Coati different from other tools is that has been MADE for the user to navigate and understand source code. It only has one kind of visualization. This visualization shows ALL the relations between different source code elements. I don't mean "just calls" or "just member relations" or "just inheritance stuff" etc. I mean everything (but still it is not too crowded (most of the time)). So if you are using Coati to figure out what you need to consider when changing some part of your codebase, you just need to take a single look at a single diagram. But that diagram is not the most important UI element in Coati. It's code view is equally important, because having just a visualization is much too abstract for the majority of programmers. To really understand source code you also need to take a look at it - read it. So to answer your question in one sentence: Coati offers a kind of user interaction that is quite different from other tools. When you say that you can figure out the same information using other tools you are probably right. But in addition to getting you to see everything you wanna see Coati is also about getting you there as fast as possible.
No, but it would at least mean it is not one of the most widely used frameworks for new projects. It is still either number one or two depending on how you look at it.
Thanks for that. &gt; Coati is also about getting you there as fast as possible To do that, it has to be built into my text editor, my IDE. If I have to switch tools, is it really "as fast as possible"? 
Core java isn't going anywhere. 
Oh, that depends on your current task. If you are implementing some new functionality and already know how to do that it's faster to do the occasional lookup of a method's declaration in the IDE. If you wanna spend an hour or two to understand dependencies and relations in some existing part of your team's codebase (maybe you wanna do a refactoring that involves real thinking ;) ) you don't need to edit anything. So no switching back. From my experience: When I start a new task I'm usually using Coati to get the big picture and figure out what will be involved in the change I'm planning. Then I switch to my IDE and stay there while implementing. At least this is what I do for smaller changes. Edit: forgot to mention - Coati has IDE plugins that can trigger a sync of the currently viewed source file and location between Coati and IDE
&gt; You could also be using JPA, another Java EE specification. JPA pretty much just trails Hibernate though. If you're using Hibernate already, JPA is pretty much meaningless.
The world is simply moving to nodejs and there's nothing that can be done about this. Static typing is super overrated when the JVM is out here gobbling up trillions of gb of ram for ordinary users 
At work, Gartner is treated as gospel. It's similar to the "no-one ever got fired for choosing {IBM, Microsoft, Oracle}" line of thinking: where no-one ever got fired for choosing IBM, but no-one ever ended up with the {best, most affordable, easiest to work with} product for their needs either. I have been on several projects where, despite obvious intuition that the product wouldn't meet our needs, we used a "gartner magic quadrant" product. And promptly regretted it. For me, and most of the techies I work with [but not managementtypes, of course], Gartner making a recommendation is an immediate red flag.
Their analysis has some good points, but they packaged it up in an idiotic way. * There is an undertone of Java as opposed to J2EE. This will only hurt Pivotal * They mention dynamic &amp; loosely typed languages, but everybody is leaving those in droves for static &amp; strong typed languages. Who starts with Ruby anymore?! * Like salesforce has any context in generic app platforms I could go on.... 
But, but, but JSF is Java EE and that sucks(and is now apparently obsolete)!!!! /s
&gt; Java EE is dead? That's OK. Use .NET instead. I'd rather use .NET than the moronic Node or Ruby suggestions they made. Although I wish I could kill windows.
I wouldn't call it obsolete, but i would say there is a strong trend away from it. There are simply more options now. Of course the market share will feel the impact of choice. Not quite FUD.
You should not be doing this. https://www.java.com/en/jre-jdk-cryptoroadmap.html
Sorry I have never used DeltaSpike, so it is difficult to do a meaningful comparison. I made this as a personal hobby, so I think it will firmly fall into category 2.
Nice job. Thanks for the information!
Plenty of legacy projects still using cobol and VB6. Lots of jobs in Java EE for legacy/maintenance projects. 
I wouldn't say that the world is moving away from JavaEE. Everything eventually gets written against it. The thing is that *new* applications get written in something else first, then redone in JavaEE because the original succeeded beyond anyone else's wildest dreams, and now you actually *need* JavaEE's overengineering and redundant guarantees. I don't see computing on demand and PaaS as major competitors to JavaEE. In fact, there's nothing that says you *can't* use computing on demand to power JavaEE applictions and give them more throughput. And similarly, PaaS services are largely written against the likes of JavaEE. JavaEE will never be sexy. But it will remain the workhorse of back offices everywhere for a long time to come.
Not so! Gavin king said to us JPA is Hibernate API done better, him given second chance!
Except in the case of Liberty, I'd completely agree with you. WAS happens to be the beast I know best, but I'd probably never advocate it as the best solution for anything. Liberty, though, liberty is solid stuff.
I'll say it: I love Java, but C# is amazing. It basically cribbed everybody's notes about what we hate about Java and decided to not do that. Sure, it has its warts, but having redone their collections from scratch to take advantage of generics (instead of making generics syntactic sugar on top of getting an object out of a collection and casting it as the expected type), allowing for some amount of operator overloading, and reducing boilerplate by the use of Properties for data attributes (just make 'em public, write the getter/setter when you actually need it, and interfacing code doesn't need to worry) were all great ideas. Similarly, having var and val are things we're only now beginning to think about in the Java world, and only because they've worked so well for the .NET guys (and the Scala guys). Let's not even mention the support for lambda expressions five years before we got 'em. Those guys are paying attention to us, and it shows.
Strange, I've been in and out dozens of industries, and it's very often Java EE what's being used. Of course, I see Spring, but to state you've been on so many projects and then have never seen it sounds highly suspicious.
Uhm. What? It's just short hand for Java EE? Why is JEE not okay but Java EE over Java Enterprise Edition is?
Could you cite a resource, ps im not downvoting u. I don't think i believe that use is up. There are large portions of market share going to node, go, and various java frameworks. They cant all be increasing unless the number of developers is likewise increasing.
http://compilers.cs.uni-saarland.de/papers/bbhlmz13cc.pdf Also look at how the OpenJDK does it. The source can be quite hard to read in there though. Graal may be easier to read. It converts bytecode to SSA in a sea-of-nodes graphical format. https://github.com/graalvm/graal-core/blob/master/graal/org.graalvm.compiler.java/src/org/graalvm/compiler/java/BytecodeParser.java
So you don't think the people who created the product get to decide how it's named? That seems a strange perspective. What if people started calling you by a shortened version of your name that you didn't like? Surely you should be able to ask them not to call you that.
It's a little weird how emotional this post is, as well as the pseudo-doxxing being a little creepy (and likely isn't even correct; you were possibly too busy frothing at the mouth to consider carefully). Java EE is not your childhood friend. It's just some tech in the bin (along with everything else) to utilize when it makes sense.
now this is really confusing and a little bit scary:)
Do you know for a fact that you've linked the "correct" profiles for public shaming and harassment? Would be a shame if, for all your seething rage and condemnation, you started firing at the wrong targets.
&gt; known apparently this person is on ee vendors' hit lists.
&gt; you don't think the people who created the product get to decide how it's named? no, they don't get to pick how people refer to things in shorthand. &gt; What if people started calling you by a shortened version of your name that you didn't like nonsequitur. jee isn't a person. jee doesn't care what you call it, because jee doesn't have thoughts or emotions.
"programming decisions" is vague. but the job market is as valid as anything else at informing what one should consider learning; generally you pursue your goals according to the information you have at hand.
Or, as /u/philwebb pointed out in his comment on your other thread (https://www.reddit.com/r/java/comments/5ii6hh/develop_a_strategy_to_deal_with_the_obsolescence/db8vrqe/), perhaps you've "doxed" the wrong person. It appears there are actual Gartner analysts by those names. In fact, simply googling "Anne Thomas gartner" or "Ashish Gupta gartner" brings up links to those Gartner folks, who are almost certainly the actual authors of the paper. If you're going to "have a dig", don't you think the simplest of possible research should have been the least you did before posting links "outing" the supposed conflict of interest here? None of this is to say that I agree with the Gartner paper, of course.
&gt;instead of making generics syntactic sugar on top of getting an object out of a collection and casting it as the expected type Reification is a porblem that is blown way out of proportion by C# zealots. The manifistations of this happen in so few cases. &gt;allowing for some amount of operator overloading Operator overloading is an opportunity for the morons to cause problems for those actually keeping systems running. &gt;reducing boilerplate by the use of Properties for data attributes There are so many solutions in Java that make this a non-issue. Lombok, AutoValue, Immutables that add a lot more value than just the properties themselves. &gt;and only because they've worked so well for the .NET guys I think other languages were far more inspiration for both languages. .NET still has shitty open source community and it sucks as to run on Linux and on open source tooling.
Basically first one you can use only when initialising variable: int[] myIntArray = {1,2,3}; myIntArray = {4,5,6}; // invalid While second way is valid in both cases: int[] myIntArray = new int[]{1,2,3}; myIntArray = new int[]{4,5,6}; // ~~invalid~~ valid edit: copy pasted invalid part :) Also: valid -&gt; will compile, invalid -&gt; wont 
&gt; &gt; Reification... &gt; I want an ArrayList of ints. Oops, can't do that, as int isn't an object! You're clearly a bad troll as your not familiar with your chosen subject matter. Reification (the problem you tried to point out earlier) has nothing to do with that. Now to take the tangent that you are taking us on... autoboxing makes it so the difference in code between C# and Java is irrelevant except for memory use. Java has other libararies for dealing with that if it's a significant probelm (in the general case it's not). &gt;We're adults here. If someone does something dumb, correct them. If they keep doing dumb things, fire them. That a feature is abusable is not an argument against the feature. Clearly you must operate your own company, you definitely don't work in a large organization or you have some sort of godlike ability to fire whomever you choose. &gt; Lombok is not a part of Java. Saying that a third party library solves a problem with the language design is saying that there's a problem with the language design in the first place. That's a moronic argument. You might as well say every general purpose programming language should have a standard library that covers every application use case so you don't need to write code. &gt;In both cases, the solution is .NET-like properties. That's what Lombok and AutoValue are providing. They're just papering over the lack of that feature in core Java. The only folks that care are the ones that don't know what their doing or people looking for bullshit reasons to back up bullshit arguments. &gt;Immutable objects aren't quite the same thing (though the idea of properties incorporates immutability as a concept). I suggest you look at the Immutables library before you attempt to correct me. Why are you in /r/java anyway? &gt;.NET is a Microsoft product. What do you expect? (That's why I don't use .NET.) While there is an explicit difference between the two, for all intents and purposes C# and .NET(core) are inseparable and should be considered a platform I'm sensing a pattern. Time to grow up beyond black and white these features/arguments are grey-scale. 
Lots of Java EE jobs for new projects as well.
Ha, good catch.
Java EE is obsolete and even Sprint is bloated. Microservices in docker will be the future. https://networknt.github.io/light-java/architecture/jee-is-dead/ https://github.com/networknt/light-java-example/tree/master/performance
People prefer REST for the same reason they prefer Javascript: they don't want to think through the problem beforehand. That isn't entirely fair, but it isn't exactly a lie, either. With Java and SOAP, you have to define your domain objects beforehand. With REST, you just kind of throw shit from the server and let someone else figure out what it means. That means prototyping with REST or Javascript can be faster. It also means maintaining the resulting pile of shit is a nightmare.
Looks like I need to put my hands up and say I was wrong. Gartner also has these people: https://www.gartner.com/analyst/37083/Anne-Thomas https://www.gartner.com/analyst/51673/Aashish-Gupta These are *not* the ones I found on linked-in. 
Is that first way even valid Java? I've never done that before. 
There are way too many shortcuts, it's hard to remenber everything I would love something similar to the the "Search Everywhere" popup but for commands(shortcuts)
Because it leaves people with a bad taste in their mouths. ^sorry^I'll^see^myself^out Shitty puns aside, I think a big part of it comes down to the involved technologies as well as personal preferences. For example, if I'm building a web app, it (to me at least) makes much more sense to simply have the client interact with some REST service than it does to attempt to do it over SOAP and can still provide type safety while doing so. Other than that, I personally find it much easier to manipulate JSON than XML if I ever do want to just make some requests from some simple client
Ctrl + Shift + A (Find Action) lists the actions with shortcuts.
I think this is completely unfair. If you don't receive a well formed JSON request, reject it. The same as any other bad request. 
So how did things work out? 
"programming decisions" refers to what I'm interested in and what I study
It's hilariously over complicated if you are just dealing with the raw XML. It's only usable if you have a WSDL file and a soap library that somebody else has written, otherwise you will be days reading and understanding the standard and all its ridiculous ceremony basically for nothing except the eventual hope that it will work when you could have been up and running in five seconds with JSON. Not to sound too ignorant, but IMO there is good type safety and then there is just getting in your way and preventing the simplest things from being simple. In practice, nothing XML tries to do ever seems to help much. There are plenty of ways for an API to screw up and preserve XML's concept of type safety. It really is just the bare minimum of type guarantees. I've written a lot of code consuming SOAP and JSON API's, and at the end of the day if your assumptions about the SOAP API are wrong, it will still break just as hard as JSON. I dunno, I guess I really just hate XML. I feel like there is theoretically a language out there with the same features but way better developer ergonomics.
[removed]
With untyped languages and loosely defined interface (REST) you can add and modifying things and you have a reasonable chance to don't broke things. SOAP hard wire things since compile time. 
If your using .net the tooling makes it simple but in other languages it seems to be a nightmare to get right.
Yes.
Definitely yes, the Android team is pretty vocal that Java is the "systems" language for Android. Even if you do happen to do the Game in C or C++, the majority of Android APIs are not directly exposed to the NDK applications and require JNI invocations. 
Definitely. Worth keeping in mind that unless you're using the new tooling (Jack) then you'll be stuck using Java 7. [here](https://developer.android.com/guide/platform/j8-jack.html) is a list of the Java 8 features supported by Jack.
This sounds like a horrific case of bureaucracy gone really really bad
&gt; The S in SOAP stands for simple, that's some sweet irony right there. See also; SNMP, SMTP, SAX
How does SOAP imply compiled? You could build SOAP servers and clients in non compiled or dynamically typed languages. REST also doesn't mean loosely defined as it's an architectural style. That's like saying MVC is loosely defined (ok, bad example as everyone has a different idea of what MVC is). 
A very balanced response. Thank you!
It all worked out well. Thanks again. Oracle really should have one page where they list out every possible deployment.properties setting
I think that's because soap can be used over multiple protocols but in practise it's always http
But you have all that documentation. The SOAP schema defined that. And yes, XML schema tells you what everything means, it wouldnt work otherwise. And no, you don't need to "see" what a thing is, you can validate it programatically beforehand as it has to be a known type, defined in the schema. 
You can even hardcode the XML, make XML from concatenating string.... and it will still work. The "compile time" is not required...
SOAP is shunned because people had no idea what it is and how to use it. Yes, it has a learning curve, you cannot just throw shit together and expect them to work. You have to define a WSDL (the contract) but after that code generators can write everything for you and you only need to fill in the gaps. With JSON ... anything goes. There are attempts right now to define JSON schema, but ... haha, like that's gonna catch. In the end SOAP is a much more capable and stronger specification, with applications that are easier to maintain long term. JSON based services tend to be spaghetti with no start or end and in which no thought has been put into beforehand. 
WSDLs seem a good idea until you realize every fucking software that consume them is just slightly different. The RPC vs Document, wrapped vs Unwrapped is a clusterfuck and the library support is not spectacular. I had to integrate with a third party (that could not for any reason change) and the only java library that I could get to generate XML that they accepted was Axis2 which is quite old and not very intuitive. Soap reimplements part of http, it's pretty much impossible to use it with JavaScript. Again, being able to generate code from the WSDL is nice, especially for integration with third parties, but in practice it's hell.
This is a common myth, and personally I have difficulty understanding how seemingly intelligent people can delude themselves so. The XML Schema can tell me that a certain field contains an int. That's all it can do. Explain to me how this tells me what the field *means*. I'll give you an example. We receive an event saying a user looked at a certain page. There's a field named `location.accuracy`. XML Schema tells me it's a float, and let's me check that it always contains a float. Great. But what does the field mean? I don't know. Right now I'm working on a search engine for data sets. It crawls tens of thousands of data sets and makes them available through a search interface. So you get exactly this type of information. You see immediately that the schema is better than nothing, but not terribly helpful. Right now I'm looking at something called `ip-library-centroids`, each record has an ip, lat, long, count of ips, and `quality`. Quality is a float, but ... what does it mean? I don't know.
You're welcome - glad to help. Yeah, I wish they would donate those docs to OpenJDK, preferably in an easy to exit format, so we could offer patches to help keep them up to date. Anything other than JavaDoc or marketing assets seems never to get much attention right now.
Dealing with stuff like MTOM is also fun. Suddenly your simple SOAP-message is turned into a weird multipart message where the SOAP-action is still wrapped into your content-type somehow. Ugliness.
&gt; JSON won't tell you that either Absolutely true, but then I never claimed it did. The difference between JSON and XML Schema is that the latter will tell you which fields are always there, which fields that you haven't seen might appear, whether the value in this field is always of this type, and so on. That's more than JSON tells you, but it *does not tell you what anything means*. &gt; SOAP is certainly not perfect (and XML's verbosity certainly doesn't help) but is better than JSON because at least it gives you types. I'd argue that depends on the use case, but there definitely are use cases where this is true.
How will it affect distributed systems using frameworks like Jooby, Sparkjava, Spring Boot etc. deployed as microservices orchestrated using Eureka from Netflix, Zookeeper?
[Java SE general FAQs](http://www.oracle.com/technetwork/java/javase/overview/faqs-jsp-136696.html?ssSourceSiteId=ocomen)
All of that is true and I'm not disputing it. What I'm pointing out is that XML Schema does not tell you what any of this MEANS.
And in layman's term? How does the JDK fit into this? Please no links.
This is /r/Java - your question is completely unrelated to Java. And: no. it is not possible at all the timestamp is produced from the mail server.
That sounds awful. I just realized that I'm very happy not having to deal with MTOM on any level.
Edit: Since it seems that I worded this not clearly enough: The hack in the article enables some patterns from the language Smalltalk that are normaly not doable in Java. (Since you can't add new methods to Object, for example). **Obviously this is not meant to be used in a real java program.** --- For whoever likes this kind of stuff, I recommend taking a look at Smalltalk! Everything is an object that you can change, including parts of the IDE and the debugger. This offers a cool way to check if an object is an instance of a certain class (in Java Syntax): In ClassA, you implement: boolean isClassA() { return true; } In Object (from which everything inherits), you implement: boolean isClassA() { return false; } Et voila, instance-checking done purely by means of polymorphism!
http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/812ed44725b8/src/share/vm/opto/parse1.cpp I'd rather read the Graal code written in Java though. This is pretty complex code in HotSpot.
Thanks for the link! I'll check it out later when I have the chance, I like having both options. As well, it's probably just me, but for stuff like this, code that forces you to think and explore rather than assume what each does helps me understand it more. I also end to learning more than I originally would. Thanks again!
Well, it seems more and more that Oracle will kill Java. I am seriously thinking about going to the other side of the fence now.
you might as well say you study "stuff"
Is there a changelist somewhere for what was added/fixed in this release?
Thanks for posting this, I don't use Java FX too often but when I do scene builder is a must. But I never keep track of its updates
And by "no longer" since 2015-12-04 is meant when the corresponding [Jira](https://bugs.openjdk.java.net/browse/JDK-8080959) was closed - over a year ago.
Eclipse does a lot of your refactoring via text-matching. IntelliJ will actually build your code and understand the context a lot of these refactoring operations will have. For instance public static void foo() { s = "asd"; System.out.println(s); } public static void main(String[] args) { foo(); } If you refactored this in Eclipse, such that s is a parameter, Eclipse will actually break your code. Grr. Intelli J will not. It will add the parameters to wherever it figures is appropriate. In this example: public static void main(String[] args){ foo("asd"); } When you have many hundreds of lines of code, knowing that my refactoring has actually not broken anything (as far as is reasonable) is a genuine comfort.
I was about to say - there's no way they'd just kill the regular SE like that. And yet over at proggit, people just read the clickbait title and are on outrage about how C# is their saviour and how java is dead.
As sad and indeed how childish it is, this has been a fact ever since Rod started Spring. Spring didn't just rose to fame all by itself, Rod's tactic was explicitly based on a "us vs them" situation and to get any form of attention for what was then a largely unknown and unproven framework, Rod started to blacken Java EE's name, and of course pushing Spring forward as the solution for all that badness. It's really not meant as a random insult that Spring users are conditioned, but this has been happening and part of Spring culture from day one. Maybe you don't notice it so much, but Spring presentations, documentation, interviews, they always give mostly subtle but sometimes not so subtle ideas about how supposedly bad Java EE is.
&gt;What if you want to use an older library that wasn't built for newer scala version that you use? I don't - I only use libraries that are still updated. If a library is abandoned, it should be replaced with one that isn't for technical debt and security reasons. It's important to pick stable dependencies anyway, so you shouldn't be using something if the maintainers are likely to suddenly vanish. &gt;I wouldn't really mind if the language was backward incompatible at compile time, but at runtime? Just why? Agreed. I think it's something to do with when the AST is generated. IIRC, Dotty (Scala 3) is meant to fix that issue. &gt;At my work, we develop a library for spark and so we have to build it for every scala version we want to support, which is a real bummer. Don't you just set up an SBT cross-build? As I recall, it's not that difficult. &gt;In maven repository, you can see a lot of artifacts which have artifactId ending with "_2.XX", which, I think, is absolutely ridiculous. Yeah, though not a huge problem for me. Just set some variable ${scala.version} and stick it on the end of the artifact ID. Or even hard-code it, upgrades are pretty rare. Don't get me wrong, this stuff is annoying. But like long compile times, it's something I'm very happy to tolerate so I can keep writing Scala.
P. good troll
Wtf? This is a legit pattern which I used quite a lot... Which you normally can't do in Java, but with this hack you can, just in case you missed the connection.
That's what I've heard from a ton of people I've asked, as recently as last month. And I'm not trying to argue. I am trying to learn. 
I don't know if it's regional or cultural or industry or what. Apparently that stack is very popular *somewhere*. I've been working mostly in the New York area with a wide variety of clients and I've never seen it used. Same with JSF. I've only ever seen it mentioned on this sub.
I am talking about Smalltalk... It is a pattern in Smalltalk that, due to this hack, could also (but should not!) be done in Java. There are OO-patterns older than GOF. &gt; In Java you could compare classes or check instanceof, both of which are built in. *Sigh* I know (I earn money by writing java programs), this what I was refering to by "Et voila, instance-checking done purely by means of polymorphism!".
German here. Currently, the law has to be decided by higher distances. However, there are thousands of lawers waiting to sue little private persons like the author, so it makes sense so take precautions. When it comes to internet infrastructure and laws, Germany is way behind compared to the other rich european countries.
Nothing to see here. Useless post about something that: - should never be used in production code. - can't think of any case I would have used on my 10yr Java career. Maybe, it's something fun for some ppl to play with.
This has been solved.
Best advise you'll see imo. Effective Java for when you're comfortable with the language.
Spring is good. Consider Spring boot specifically and JHipster perhaps I prefer drop wizard. Get IntelliJ CE ASAP. 
What part of "this is not possible" did you not understand? E-mails have more than one timestamp and even if it could be manipulated, only the local timestamp would be affected. The server timestamps cannot be changed. There is no way.
I never understood why Sun did ship it on first place, specially since it was always behind Derby and only available on the JDK.
For a newbie, I'd stay away from Jhipster. It's a fine project, but does pretty much everything for you. Meaning that over the longer run, you will likely not have learned quite as much. It also adds a ton you may not need just to get going (async and scheduling setup, coming to mind right away). For employment, at least in the web space, I would echo the Spring Boot advice. I've not once touched another Java stack in a large corporate atmosphere in quite some time.
Done well SOAP services aren't that bad at all really. Back in the days it was part of my job to create custom SOAP interfaces for our customers. I did this contract-first; so I created a proper WSDL and from that generated the server stubs (using Axis2) for which I then wrote the mappers. I also always made sure that the XSD schema made sense and that you didn't end up with 3 different 'the same' objects on the client. Both the server and client sides were easy enough to implement. However; a lot of people and frameworks didn't work that way. The industry simply is a big mess and there are tons of people who did stuff like hand-assembling SOAP envelopes, create frameworks that didn't follow the standards (whatever Visual Studio did back then wasn't compliant for example), use XML schema's with just XSD-any so you had to deserialize by hand anyway, etc. For example; I had to get mad at two different suppliers of ours that just had pretty mediocre developers create their soap interfaces. SOAP is just XML right? And XML is just text with tags right? So we'll just concatenate text together and call it a SOAP interface. That's how you end up with crap that contains stuff like &lt;firstName&gt;Noëlle&lt;/firstName&gt; and breaks everything in production. TL;DR: SOAP services work fine if you use the right frameworks and approach to create them. Most people didn't and it became a horrible mess. 
What part of Javascript being related to java did you not understand when you said &gt;This is /r/Java - your question is completely unrelated to Java. 
mostly people using java need to use Java script for dynamic functionality ,i was thinking if there was someway to extract the timestamp from server ,manipulate it using some piece of code. On another note,there is a way,nobody found it yet.
&gt; mostly people using java need to use Java script for dynamic functionality No. One language has nothing to do with the other. Java **can** be used as server backend language, but then JavaScript is on the client side - which is common to all backend languages. Java is a compiled general purpose language - JavaScript is an interpreted front end language - unless you count the fairly new node.js where JavaScript runs on the server as well. JavaScript is necessary to get dynamic content to HTML pages - but again, this has absolutely nothing to do from where the HTML pages are created. These two languages have nothing but a similar name and some syntax in common. They serve completely different purposes. They even have a completely different architecture.
good riddance
Spring, Struts, Hibernate
Nope, it just kind of tickled my cringe sense. 
&gt; I recommend to dive in the Spring Framework I'd be inclined to pull off the gas pedal a bit here, Spring isn't a free ride, there's a lot of conceptual stuff you need to learn first, otherwise you'll probably end up with hours of autowiring exceptions and wondering why your TODO list application requires 30mb of dependencies. Personally I'd say just learn the basics first, frameworks can come later. 
You might want to start here: https://youtu.be/7cOVaxlxA5k
&gt;[**Annotated Spring: Episode 1 - Spring Boot QuickStart [2:54]**](http://youtu.be/7cOVaxlxA5k) &gt;&gt;Starting a Spring Boot project using the Spring Boot CLI &gt; [*^Brian ^Kelly*](https://www.youtube.com/channel/UCeOkT0DuFBZWgeoY01Cf3UQ) ^in ^Science ^&amp; ^Technology &gt;*^774 ^views ^since ^Aug ^2015* [^bot ^info](/r/youtubefactsbot/wiki/index)
I'd say stay away from Gradle until Maven proves ineffective, I always use Gradle but it can be a PITA sometimes. Also spend the money on JRebel
Liberty is exceptionally neat indeed. Quite surprising that IBM went from having the biggest beast out there to the leanest creature.
Jesus Christ buddy... Oracle declined to comment. How did you arrive at "agrees in principle"...
it just means that it's a meaningless pair of words. and you started with picking on wobbly.
A Java.net glitch or Oracle trying out if people would notice?
Looks like a permission issue. Weird nonetheless… https://java.net/projects/jpa-spec/lists/users/archive/2016-12/message/4
Why has noone said Tomcat? Tomcat *is* a framework you know. 
I think Maven has support for something similar to Gradlew. I love and loathe Gradle at the same time. I'll never switch back to Maven, one of the latest tasks I built rendered all my template files with fake data so I could run some js tests with Mocha
I also only know of Red Hat and Azul publishing OpenJDK binaries for Windows. There are some others, but none of them keep it up to date. I obviously recommend Red Hat's version. JavaFX is developed as part of the OpenJFX project. OpenJFX is under the OpenJDK umbrella but not part of the OpenJDK sources. Anyone who builds and publishes OpenJDK will not include OpenJFX unless they go the extra mile. And OpenJFX includes several other dependencies (such as webkit) that makes keeping it up-to-date and secure much harder. I haven't seen enough demand for JavaFX to justify it. You can, of course, get the OpenJFX sources, build it yourself and add the binaries to the OpenJDK version you download and you should get working JavaFX support.
Lol no.
If you are using them with weblogic I'm pretty sure you are ok cause you get a restricted use license 
&gt; ...or using the ARM embedded JVM in devices You can use [Azul Zulu Embedded OpenJDK](https://www.azul.com/products/zulu-embedded/) for that. They specifically mentioned about the licensing of their embedded zulu [here](https://www.azul.com/files/Zulu_Embedded_DataSheet.pdf).
If you don't want to build OpenJFX yourself, either wait for OpenJDK 9 (where OpenJFX is slated to be included in the JRE), or use Swing. It's a bit more of a PITA to make things pretty and flashy, but certainly not impossible. The only real issue with Swing (other than it being more work than JFX to get the same level of bling), is lack of HiDPI support, which isn't coming until Java 9.
Nice set of links for those who aren't already aware. Thanks for contributing actual useful information!
Why?
The Java language will never be restricted by Oracle, only Oracle's products can be.
You can install maven into the root of your project and create shell and batch scripts to run it from there I guess? This is totally not the same imo.
&gt; Using OpenJDK you are allowed to distribute your program with OpenJDK as long as you don't modify the OpenJDK itself. This is due to the GPLV2 with Linking Exception that OpenJDK use. This is incorrect. The Hotspot component does not use the linking exception. It is not entirely clear if it is legally possible to distribute a proprietary application along with OpenJDK. [Here is what the FSF has to say about this.](https://www.gnu.org/licenses/old-licenses/gpl-2.0-faq.en.html#IfInterpreterIsGPL) Most applications will only use the core library interfaces (which are subject to the Classpath exception), but some of those are just thin wrappers around Hotspot interfaces, which makes the whole situation confusing. Whether a backend application written in Java needs to copy or distribute OpenJDK is subject to interpretation, too. Uploading to a service provider may involve copying, for example. I assume it is permitted to combine your proprietary application with a download of an OpenJDK implementation built by another party and run it on someone else's server, but I'm not a lawyer.
What about it? Google didn't properly implement Java so Oracle sued them.
OpenJavaFX is a thing, too.
She doesnt necissarily need to leanr JAVA to begin with. Have a look at getting her a Makeblock Mbot .. they are fun, interactive and use Scratch for the coding which is very easy. It will give her the login behind coding without making her learn the actual code, then from there she can pick up proper languages like Java to make proper things like AI to take over the world!
Nice list and explanation, mods should sticky it to the sidebar. Also, Azul Systems is awesome.
Sorry but that's what open source people don't understand. The goal is not to write better software or to make collaboration easier or to optimize synergy whatever that means. The goal of free software is to empower the user. If your software cripples its users, you are not usable. Torvalds is wrong. The focus is GPL has always been the user and that's the right way. 
It was not a trademark dispute as far as I know. If Oracle had won (is it over yet?), it would show they can restrict the language. 
You may try this http://www.oracle.com/technetwork/java/embedded/downloads/javase/javaseemeddedev3-1982511.html Java is perfect choice. It has best tools, sh1tton of libraries, and she (your sister) will not be forced to learn a "real" programming language later. And if you already know Java, she will have great support. Good luck. 
Red Hat contributed a free ARM64 port to OpenJDK (NB: do not confuse with Oracle's commercial stuff). Seemingly this move has forced Oracle's hand and they are now proposing to open their currently closed AARCH32 code and merge it with the AARCH64 contributed by Red Hat to make a combined offering. http://openjdk.java.net/jeps/297
Did that article provide sources or are we all just freaking out over nothing
Yes, sure. But this doesn't mean that one should not take a kid-friendly approach. Strange is that wherever you look, **Scratch** is recommended for kids. If it doesn't work for you, fine. Go and play with your toys and troll somewhere else.
Are you familiar with http://www.devoxx4kids.org/ If she likes minecraft that is an excellent way to teach. I think that learning to hack something you love and gaming is a great doorway to this. Also not explicitly for kids but Loke Hansen did some videos teaching mobile game building in Java: https://www.youtube.com/watch?v=pZ-R7qOKTCo https://www.youtube.com/watch?v=UVUmKCpExIc It's not for kids but is simple enough so they can pick it up, the value of having something running on your mobile phone can't be discarded. My eldest daughter is 6 so I'm preparing ;-)
Again, do you, Sir, have any proof for your words?
As of right now it is very easy to avoid licensing. It may always be easy to avoid licensing, even in the future (it also may not, who knows). However Oracle is destroying faith people have in Java and I could see this as an argument for new products to be done in some other language that is not owned by sue happy Oracle. I don't think jobs will run out quickly but over the course of 10 to 15 years if Oracle continues to get bad press we could see Java jobs degrade. As Java developers we should be concerned about the hits to Java's reputation.
REST is not JS. You can do the same thing with REST using Open API specs (aka Swagger), among other tools.
Doe that library work with both BSD grep and GNU grep? As they take different arguments. Would be cool if it abstracts that away.
You want to teach kids lies and callme a troll in the same time? These kids will be trolled by you. I remember the time when I had to learn Pascal because it was "educational" language. Till this day I regret learning this sh1t. This was a massive waste of my time. You sir are full of it. Programming is hard, and the kid has to accept it. Will he choose something else knowing the truth? Maybe. It is a kid after all. I don't care what kind of sh1t you are throwing at your kids, but I'd like your kind of people stay away from mine.
Well to be fair I started programming at 11 with Java and didn't get bored...
Grep4j seems to wrap actual GNU grep (going by https://github.com/marcocast/grep4j/tree/master/src/main/java/org/grep4j/core/command/linux/grep) whereas unix4j seems to implement it in java.
&gt; Again; stop making this an "us versus them" thing. It isn't. Then stop saying stuff like: "pretty sure it's just a bunch of people pissed that their expensive certificates are becoming worthless."
So am I, and I generally avoid streams. Unless I need to parallelize. Lots of if statements though.
How many children taught by these "experts from MIT" stepeed out of their sandbox today? Yes I tried. And most of them had nothing to do with if statements or for loops which together with goto are most horrible inventions in IT. I'm not saying graphical languages or environments are bad. Many CAD software have constraint engines built in. You can write scripts or just click. However putting such primitives as if / for as block elements is a serious step back in evolution. Why not go another step back and have assembly instructions as well?
&gt; Do they know that if-else and loops are modern goto? Bullshit. People spouting this kind of nonsense have no place in this sub.
That's a tad hypocritical don't you think?
Check Akka indeed. Check Hazelcast or Infinispan. You may need to do that by yourself for the kind of stuff you're speaking about. For that : - Check jgroups if you want to do your own low-level protocol (jgroups is used by infinispan). - Check the "consistent hashing" algorithm (used by several tools like cassandra), you may not need it but should be aware of how it works for doing that kind of thing. - Check netty, could be useful for the low level communication if you don't go the jgroups way You may also check zookeeper for the high availability (master elections, and so on).
Gradle is scary because it's a DSL in a language the IDE can't help you with in any way (Groovy, ugh), so it seems super arcane. But once you learn it well, you never want to touch Maven again. Configuring build logic using XML? that's nuts. I like configuring my builds using code like all of my actual business logic. Luckily, Gradle is now moving towards using Kotlin, which is like a saner Scala with a lot of Groovy influences. And it's statically typed and maintained by JetBrains so IDE support is top notch. gradle-script-kotlin, as they're calling it (or GSK) isn't 100% stable yet but is good enough for daily use. Seriously though, it's so much easier to understand Gradle once you jump in. I never want to use Maven again if I can help it. 
Definitely not Thinking in Java. I have no idea who is recommending it but that book is geared towards C/C++ developers coming over to Java.
(Hitching onto this comment for visibility.) Reminder: Don't feed trolls! There's one in this thread, wth a triple-digit _negative_ comment score.
&gt; calling people trolls? If it walks like a duck, looks like a duck, and quacks like a duck it definitely is a duck. Your comments in this thread prove exactly that.
So you may laugh but I promise you it has worked well. I started my son with Scratch when he was about 6 and he did well. It came from Kahn Academy's [Hour of Code] (https://www.khanacademy.org/hourofcode) Not sure if these are identical but after he finished that up he moved from there to https://code.org/student He went through all of the Scratch stuff and he understands general binary logic but I found myself spending a lot of time trying to explain abstract principles that he wasn't fully grasping. It definitely added value but there were parts of OOP that just couldn't be extracted from it. He moved on to [Code Combat](https://codecombat.com/) and he did very well. He went through to the "Forest" area (Not sure what that is, that is just what he told me) and after talking together, he grasps some pieces of how events are handled, still not well versed on how a character is an object and has properties etc. Intermittently we did the [Programming with Minecraft](https://www.nostarch.com/programwithminecraft) from No Starch Press (All of their books are just phenomenal). It became clear there was a lot of stuff in relation to the underlying filesystems that he didn't understand which made it difficult. (It instructed him to create a folder named "./SomeFolder" so he tries to name it quite literally "./SomeFolder"). In addition to Python being a very sassy language, it was very hard for him to understand how to fix what he had broken in an easy way. Amazingly enough there is so much context that we have built up that are just gobbledy-gook to children. Then I sit him down with me and we jump into TDD (Test Driven Development) I start interactively showing him some code katas like FizzBuzz and very basic interactive **Hello World**/**Hello [Username]** things. With all of that built up knowledge as well as the ping-pong nature of paired programming, he flew through it. He stumbled here and there, but I've interviewed people who have done worse than that. This was really a time period that he took off. I would still say he doesn't fully understand OOP, inheritance, and really any programming practices, but he started understanding how to work with an IDE when it's complaining that there are problems and come up with mostly accurate assumptions of what is wrong. Now we have moved towards small things around the house and in his life. - He gets a reward if he learns all of his times tables. We build an app together to write out the multiplication tables and record the output. Simple stuff like that which appears to help him get closer to the rewards he wants. **I would say whatever your approach, be willing to switch up gears in the slow points and try to find things she enjoys and build a small little application around it. As long as it is interactive and can have small iteration cycles, you can probably keep her engaged. Be prepared to put it down for a month or two. She will see you doing something and it will spark her again to come back. Everyone needs to build up their tolerance, meaning everyone occasionally needs a break as well. When they see other peoples passions, it can be easily contagious and always reel them back in.** One thing my son loved was changing the numbers until they broke. Making a loop go for a million iterations. Timing them, making them say silly stuff. Counting string lengths and making the strings crazy long. Things that seem silly at first, but I actually started having a lot of fun just off of his energy. Reawakens programming for some rusty souls. By the way, he was able to knock out his times tables in about two weeks. That is, memorizing and being able to recall the range of 0 - 9 times tables in sub 3 seconds. I think he was very invested in it from so many angles that it became more enjoyable and we threw a party when he finished. It says something for me at least about how much more he enjoyed it in comparison to when he was memorizing addition and subtraction which each took him a few months to master. **Edit:** Formatting and spelling.
&gt; I mean even in Java now people rarely use if statements ... what?
Agreed. Personally I think Herbert Schildt's books *Java: A Beginner's Guide* and *Java: The Complete Reference* are better books for a beginner to programming in general. The Complete Reference is still a beginners book albeit just slightly more advanced than a total beginners book. 
and by the way....Java is the language we moved to after Scratch, Javascript, and Python. I would say Javascript was pretty easy for him to understand, Java as well was equally easy for him. We use IntelliJ and the IDE supported him so much that he was able to be productive with it. A strong IDE with good autocompletion and templating goes a very very long way, letting the language slowly reveal it's complexity over time instead of forcing everything to be understood upfront.
Seems Swift appeared in right time. 
People from this thread have similar experience, except some expert MIT "teachers" and you.
I doubt that Oracle is just going to let you uninstall a couple of things and avoid the back charges. 
C# fans? Working for The Register? Ha! 
I will step in to add to the "don't start with Java" message. I taught at a STEM camp at my university for a while, where I ran a couple classes teaching kids how to program. One class was just straight Java programming, was programming through Minecraft modding (which is done in Java). I can say that it is definitely possible to teach children in the 11-year area how to program in Java, but it is NOT easy. It is a wordy language that requires a lot of setup to get it working. The simplest Java program still has a lot of code just to set up a simple class, then there is compilation, and it's just altogether a bit overwhelming. I HIGHLY recommend starting with something like Python or Javascript. You want a language with minimal complex and specific syntax, and preferably no compilation to avoid potential confusion and frustration. Also, you are really really going to want to find something that they can work with that gives them more interesting output than text on the screen. The Minecraft Modding class was a logistical NIGHTMARE to get going in, since just setting up the tools can be a difficult task for someone who already knows a bit about computers. That said, hours of scripting and automating on my part all but eliminated that issue for the kids, and I made a really simple API they could use to do basic things without all the complex coding. Even though the content of this was still far more complicated than the content of the basic Java programming class, the kids were FAR more willing to dig into it and figure it out because it was so exciting to get to see the results of their work in the context of something they enjoyed. Try finding a simple game-making library, and teach the coding through making, or even modifying, very simple games. It's much more rewarding than making a boring command-line calculator.
I'm cold like stone. I don't care about others if I consider their opinions harmful. You remind me of my Pascal teacher. I asked her, why are we learning it when almost nobody is using it. She told me that if you dont like it then change teacher. And guess what. I went to C/Assembly class. Actually C because I already knew Assembly. I can write software which is not even using interrupts. And this is what I call experience. Not for loops and if statements. Like these poor kids today I wanted to have full control over machine and system. After time I understood that low level programming has no future, because no matter how smart your low level code can be, if its architecture is incorrect nothing will save you. I can call myself a hacker, all others are just users of language A or framework B. Actually I dont care how you will tech your kids, but I'm sure mine will have almost no competition.
Get her to build a text based game. Building a game is fun, and if it has an easy objective then she can share it and explain it to anyone. If she does it herself it's science fair grade stuff. Easiest to do is Hangman. Javascript only requires a web browser with developer tools and is very forgiving, so concepts such as compiling, memory management, etc. are not necessary to learn at first. She can also post it somewhere and show everyone, which will encourage her.
Yeah, http://bad.solutions is probably the best one :D
This is the best tl;dr I could make, [original](http://www.theregister.co.uk/2016/12/16/oracle_targets_java_users_non_compliance/) reduced by 93%. (I'm a bot) ***** &gt; Oracle is massively ramping up audits of Java customers it claims are in breach of its licences - six years after it bought Sun Microsystems. &gt; That perception dates from the time of Sun; Java under Sun was available for free - as it is under Oracle - but for a while Sun did charge a licensee fee to companies like IBM and makers of Blu-ray players, though for the vast majority, Java came minus charge. &gt; Why is Oracle acting now, six years into owning Java through the Sun acquisition? ***** [**Extended Summary**](http://np.reddit.com/r/autotldr/comments/5j23ka/oracle_finally_targets_java_nonpayers_six_years/) | [FAQ](http://np.reddit.com/r/autotldr/comments/31b9fm/faq_autotldr_bot/ "Version 1.65, ~35918 tl;drs so far.") | [Theory](http://np.reddit.com/r/autotldr/comments/31bfht/theory_autotldr_concept/) | [Feedback](http://np.reddit.com/message/compose?to=%23autotldr "PM's and comments are monitored, constructive feedback is welcome.") | *Top* *keywords*: **Java**^#1 **Oracle**^#2 **more**^#3 **customer**^#4 **Free**^#5
I'm 13 and just learned Java, learned Scratch when I was 9 and Python when I was 12
You seem like a joy to be around, I wish more of my coworkers had your unique perspective and skills.
are you on drugs
I would also disagree that devs do not want to learn. I work with 20-something year old devs who are pumping out side-projects in truckloads to *try a new thing*. This explosion of: * [Codingame](https://www.codingame.com/start) * [Treehouse](https://teamtreehouse.com/) * [CheckIO](https://checkio.org/) * [Hackerrank](https://www.hackerrank.com/) * [Pluralsight](https://www.pluralsight.com/) * [Codefights](https://codefights.com/) * [CodeWars](https://www.codewars.com/) * [Screeps MMO](https://screeps.com/) * [Steam - Shenzhen IO](http://store.steampowered.com/app/504210/) * [Steam - Human Resource Machine](http://store.steampowered.com/app/375820/) And just a ton more... &gt; the only obstacle is stiff educational system and many devs who by themselves do not want to learn Your statement is just unbelievably short-sighted and false. Maybe you are in a tech wasteland where people show up to work in pain and agony....I am seeing something very very different. It is a system that has accelerated the expiration date of those developers who choose not to learn.
Yup, unfortunately all my coworkers still use interrupts so they are all just users of language a or b. 
I work for a company where we (devs) are not allowed to use external libraries like Guava ,and Java 8 is a distant future. I had to reinvent fully lazy/concurrent map/reduce framework for us. I have not seen if statement or for loop since a long time. Well, maybe if new predicate is introduced, but even then it is not entirely "if" but "()?:" instead. If statements are evil because when function has anything else besides them it violates SRP principle and code stops being modular. For loops have the same issue: body of a for loop is itself another thing which has to be separated. I mean if statement and for/while loops in C-like languages are abstractions over Assemblys (un)conditional jumps, but in my opinion should be avoided. These constructs are gotos of the XXI century. I could go even further and say that filter/map/reduce are evil in favor of Prolog, but for now lets wait until functional paradigm catches its second wind. 
I admit that predicates may have some kind of if statements, but if you are using them elsewhere your code 100% violates one of the SOLID principles. 
Check out my grep lib too: Runtime.getRuntime().exec()
Who are you if I may ask? And how do you know who I am? xD As for Kotlin, I've been absolutely loving it!
That's a good point. It is a bit scary that Oracle would sue a company for simply copying the default java libraries but I doubt they would try to extort billions from an individual or a smaller company.
What's wrong with Python? I understand about Scratch, I remember it too, and it's alright for someone who's about 10 and doesn't know or desire to know about programming just yet, but I don't see it being inherently useful. 
A lot of instructional YouTube videos out there for programming which step you through the process of creating programs and explain syntax/structure. Learning programming is a lot of practice just building different programs and debugging them to fix errors. I recommend just getting started with an ide and just keep trying different projects. Stack overflow and Google are your best friends for problems or errors you can't figure out. 
The last release (1.2.0) introduced a new algorithm to combine the matches found within a password which provided better results, but drastically slowed down estimations. I spent some time profiling where that extra time was going, and optimized most of that slowdown away.
Cool. What is that ? 😕
lol
Can I join you dude :)
My favorite maven plugin! Not any exiting new features though 
Good to hear! I’m just a hobbyist-REer that also really loves JVM stuff though. I remember looking at RE related stuff written in Java and coming across Abendigo and being amazed.
+1 for pascal. It was my second programming language, and in terms of understanding what the computer did, it tought me so much more than python. I went back to python and suddenly I was programming way better. 
&gt; It was Derby and still is. always behind Derby in regards to the actual latest Derby version and what was delivered with the JDK. &gt; It has always been available separately--just download it from Apache Derby website. Which we had to do anyway if we wanted to have the latest stable Derby version, so what was the point of having an outdated Derby version renamed as JavaDB delivered as part of the JDK? 
I don't mean notepad and cmd I just mean a more basic IDE. I've felt that way because I learned C# on VS (the only way) and it was preeetty rough.
&gt; If you develop a Java program on Sun's Java platform, you are liable to use Sun-only features without even noticing. By the time you find this out, you may have been using them for months, and redoing the work could take more months. You might say, “It's too much work to start over.” Then your program will have fallen into the Java Trap; it will be unusable in the Free World. &gt; The reliable way to avoid the Java Trap is to have only a free implementation of Java on your system. Then if you use a Java feature or library that free software does not yet support, you will find out straightaway, and you can rewrite that code immediately. - [The Java Trap](https://www.gnu.org/philosophy/java-trap.en.html)
It seems that Hotspot has Assembly Exception: [Is it legal to Bundle OpenJDK + HotSpot with a closed source application?](http://opensource.stackexchange.com/a/4855/6971)
Once your Pom is setup you'll want to use mvn deploy. Package will just build the jar files in the local target directory. Sonatype has some guides on the extra steps involved with central, such as signing the artifacts with a key they know about and the staging process. http://central.sonatype.org/pages/requirements.html 
Nice work. The only thing on my environment is the color of static final fields is very hard to distinct: http://imgur.com/a/AQnCZ
That seems like a good idea. For Unity with Android you could even consider a website like Udemy to see if there's a good course on sale. You often find discounts on courses there.
Should you be worried if you are running say, Spring or Tomcat web app in production? Provided you just installed default oracle java on your server? Or is this only relevant if you are dealing software product to end users?
I know quite a few people (including myself) that have gone through the same process. I feel it is a natural transition to rediscover that there is a lot more to life than programming. Of course, if you don't dedicate your entire free time to it you are going to miss out on learning some stuff. The fact is that even if you do dedicate all your free time to learning new technologies, you are never going to catch up with everything. It is a losing race, and you need to learn to accept it. It simply doesn't matter whether there are things you don't know. No one knows everything, and no one needs to. You probably know most of what you need to do your job effectively, and are already aware of any gaps that you might need to overcome. Other than that, it is good to keep tabs (at a very high level) on the trends of the industry, but it is not possible nor healthy to try to get fluent in all the technologies that keep popping up everywhere. When I realised this I switched to non-programming activities in my free time. In my case that meant spending more quality time with friends and family, as well as improving some "analog" skills, such as cooking or foreign languages. I have started to enjoy programming a lot more, now that it is no longer a central piece of my existence.
The author of the article complaints about "ORMs and the never ending object-relational impedance mismatch" and "creating yet another Mapper class to transform one DTO to another DTO, both of them being 95% the same." I wonder how these were solved with using Clojure.
SQL tables are represented using native Clojure data structures. A row is just a map with columns as the keys. A table is just a collection of rows. SQL is either written as plain SQL as seen with [HugSQL](https://www.hugsql.org/) or using a Clojure DSL such as [honeySQL](https://github.com/jkk/honeysql) or [Korma](http://sqlkorma.com/). Korma would be the closest to traditional ORMs.
OP, please crosspost this also in /r/javahelp &amp; in /r/learnjava. This is a very important document detailing *proper* coding standards and personally, I would even consider linking it in the sidebar of the above subreddits. I am moderating both other subreddits and think that this could be a very valuable addition to them. I don't want to do the crosspost because it is your post.
Spot the bug at page 15.
Thank you for your answer. I would sum it up as ditching ORM and going more low level. There are similar approaches in Java world like MyBatis and JOOQ. The only principal difference that I see is the extensive use of native data structures like maps and lists. How is type safety handled in this cases? If I select a row into map, what guarantees me that I can treat numeric value only as numeric and string values as strings?
Glad for the author, but couldn't find anything useful for me. TLDR: I liked Java more than C, but then it felt bad writing too much boilerplate code so I now like Clojure.
Additionally you might want to look into a CI environment like Jenkins or one of the many SaaS provider which deploy your artifact as a snapshot and on tag as a release.
I maintain a set of small modules in Maven Central. This is the parent pom that I use: https://github.com/guppy4j/libraries/blob/master/pom.xml To do a release I have a Jenkins server on one of my computers at home configured to checkout the github project and release it using the Jenkins Maven Release plugin.
SQL is already a great DSL for working with relational data. I really can't fathom why I'd want to wrap it in another DSL. The problem with ORMs is that you don't know what SQL ends up being generated, and it's not very efficient majority of the time. So, you end up having to write it by hand anyways if you're dealing with non-trivial amounts of data. To make things worse, the ORM will usually work just fine in development and testing, the time you end up seeing performance issues is in production when you hit serious loads. Fixing your performance at that point is not ideal. If you just learn to use SQL, then you know exactly what your queries are doing, and you're not getting any surprises because the ORM decided to do something stupid.
I assume you mean that they never actually extend thread
 Runnable thingToRun = new Runnable(){ /* ... */ }; Thread thread = new Thread(thingToRun()); One would assume that NASA, making a very rigorous document like this, would actually test their own code, and see if it even compiles... Also something went weird with their document rendering, as there is a stray `$body` tag over there. Page 15 is a bit of a mess. Finally, why manually manage your `Thread` life cycle in the first place? This is why Doug Lea gave us `ExecutorService`. Seems pretty odd to me to put this in a best-practices document. 
`thingToRun()` I didn't spot that one, but then again I did notice Thread thread = new Thread() { @Override public void run() { System.out.println("Doing something"); } }; thread.start; // emphasis here From a glance there seems to be a lot of good advice in there though (which I suppose makes sense with it being the JPL Java coding standard and all).
I am a tutor at the school I attend for Computer Science. And teach people that have never coded before in their life. A few things I recommend : 1. Intellij is a powerful IDE (what you code in), i highly recommend using it. If you are serious about programming and really want to get into jt, then read the hotkeys and shortcuts for intellij. It saves massive amounts of time and helps you organize things better. 2. If you learn better visually, definitely use YouTube. When i was learning i watched TheNewBoston channel. He is good and explains most things very well, is easy to understand and not too nerdy. 3. Anything you don't fully understand READ THE DOCUMENTATION. Java writes what everything does in the language at: https://docs.oracle.com/javase/7/docs/api/ Or you can jusy search it on google of course. Keep your code organized and think every step of what your doing.
I can't find the original place I read this, so perhaps I'm wrong. The closest references I found were [here](https://wiki.openjdk.java.net/display/OpenJFX/Building+OpenJFX#BuildingOpenJFX-IntegrationwithOpenJDK9), where they state that, with Java 9, it will be necessary to integrate OpenJDK with OpenJFX, rather that just overlay it like you can with OpenJDK 8, and [here](https://twitter.com/chriswhocodes/status/696640575752310785), where Chris Newland (of JitWatch fame) states that it's in the Java 9 jigsaw repos and ea builds. 
Oh I didn't catch that. Good eye. I wasn't being sarcastic. Eclipse is spoiling me.
I just want to say that this is the most useful information I have ever gotten from someone named "MassiveDiarrhea"
Here's an example just for class variables: Static class variables are associated with the idea of the class. Non-static class variables (aka "instance variables") are associated with instances of the class. For a Dog class, "latinName" could be a static variable, and "name" could be an instance variable. *Canis lupus* is the Latin name for **all** dogs. Spot is the name for **a** dog.
Just skimming through it, some of the checks are definitely possible in the checkstyle, pmd, and error-prone analyzers, but I don't know if anyone's tried to make a specific configuration to match this document. Those tools can also easily be made more rigorous than this document, making some of its guidance moot. For example if you follow checkstyle's "DesignForExtension" rule, then that inherently avoids several of the inheritance-related problems the document is trying to solve.
The Register is rather no one's friend.
I tried implementing this in one of my own toy projects that compares tsp solutions. After some exchanges with the author, this code seems like a pretty reasonable intro to Simulated Annealing, with which I had little prior experience. Some observations about this 'solution' compared with guaranteed optimal or other approximation heuristics: 1. By starting with a complete solution and permuting it, SA lets us vary how much time we spend much more easily than guaranteed optimal solutions (which can take significant time to even produce any solution at all). 2. Fine tuning the starting temperature and cooling rate seems quite challenging for large problem spaces. In a sample problem with 25 nodes, I could consistently find routes about 50% longer than true optimal, but struggled to identify parameters that would get closer. 3. The author notes that very little variation occurs after temperature drops below a certain threshold, and so it seems like one way to explore other local minima would be to re-shuffle the starting node once that has occurred. This might result in a more complex algorithm, but also seems suited to parallelization. 4. Because it's not guaranteed to find optimal, you also have no way to know if you are finished, which means that, while you will never spend more time on this algorithm than your number of iterations (or until your temperature is too low), you will also never spend less time. Ultimately, for low numbers of nodes, I think I'd rather use a guaranteed optimal solution, and for high numbers of nodes, I'd be curious to see how this solution compares to a constrained branch and bound using a low value n-nearest neighbors heuristic. 
RMS is our prophet! He suffers for our sins!
Closure has maps as records. Thing is Java also has maps, so doing hundreds of DTOs is entirely a choice of the programmer, not something the languages make you do.
As someone who just recently started learning Java, Eclipse is totally fine. I haven't used IntelliJ no idea how easy/complex that is. Imo eclipse is very easy to get used to if you have a general knowledge how software usually works, if not there's always google.
Thank you very much for the detailed description. I'm bookmarking it for future reference, as is it not a problem I have to solve right now but might have to in the future. Forwarding it to colleagues as well... Quick question though : for spatial matches, do you take into account several keyboard layouts ? 
Yes, and its easy to add another layout through the configuration if you wanted to.
Also in many instances the button and the event method can be defined entirely in the FXML. Obviously whether you can make use of that depends on the nature of the project.
What is JayBird 3? It's an improved JayBird 2. According to the not so helpful ReadMe. 
Thanks, but see my problem with the youtube videos is the fact that I can't see how it applies in the 'real-life' sense as I'm watching the video/working on it in the IDE. Any tips on how I can understand the line text in a graphical sense instead of looking at lines of code and trying to make sense of?
&gt; imo working with Java in Big Data is just a PITA and you being a moron. Are you suggesting that working on (production) Big Data in a dynamically typed language is better? If you are, I think you're the one off base. &gt;Glad to see that the author realized that FP is really strong in BD Functional programming is a paradigm represented as a style not a programming language. A lot of the great libraries for production systems as opposed to adhoc exploration have some sort of Java interface. Most of the big data systems are written in Java.
Nasa has impossible standards 
So it's about using a tool that happens to be written in Java. Gradle is Groovy, and so are pipeline scripts. IMO this article is more about Jenkins and pipeline scripts than Java-the-language.
I'm a huge advocate for Udacity. I have more background in Python but my next Comp Sci course at university will be in Java so I'm preparing myself with their free [Java Programming Basics course](https://www.udacity.com/course/java-programming-basics--ud282). I quite like it, as it's very easy to digest, not at all overwhelming. It may good for you as a verbal learner because the course is video based (as are all Udacity courses). You'll watch a short video or two then have a quiz or solve a problem with code. I implore you to check it out! I'm only 18, a freshman in CS, and had no experience in programming before my senior year (took an Intro to CS &amp; SE course) but I've been using Udacity for over a year now and it's helped me immensely. There is also [this page](https://www.udacity.com/pathfinder) which may help you chart a course on your journey. Have fun! Edit: I will advise you, if you do go with Udacity, make sure to start with *Java Programming Basics* and NOT the San Jose State University *Intro to Java Programming*. You should take that one afterwards when you're ready to get to more advanced stuff, it's structured a bit differently. You can skip over the things you've already learned into the advanced material. 
&gt; Are you suggesting that working on (production) Big Data in a dynamically typed language is better? If you are, I think you're the one off base. I never suggested that, only if you think that a dynamically typed language is the opposite to Java. Fact is that most production systems are not made with FP in mind &gt; Functional programming is a paradigm represented as a style not a programming language. A lot of the great libraries for production systems as opposed to adhoc exploration have some sort of Java interface. Most of the big data systems are written in Java. And? Why do I have to narrow my options down to specfic languages. In comparison to other languages Java has only FP support on its lowest level. And just because many use a tool does not mean it is the best tool nowadays, maybe it was when they started using it. 
Great work, I could've used this a few weeks ago when I did the same thing. You probably know this but the `publishToMavenLocal` is a nice way to test the publish
Stanford NLP is arguably the best NLP library available - across all languages. I have personally worked with it over an internship this past summer and I can definitely recommend it.
Deeplearning4j has word2vec, which is useful if you want to do things in the direction of topic modelling.
XML? You can use groovy DSL (or even kotlin) to generate the pom. Check this http://central.sonatype.org/pages/gradle.html
To be honest, if you are planning to publish a library to maven central, you are better off using maven. All that XML you avoid with gradle you have to recreate in groovy, it's a net loss. I tend to use maven for published libraries, and gradle for applications. Secondly, this is a terrible way to do this in gradle. It's sad this people are going to reference this mess now. 
Wrong. I believe OP is asking for libraries that process nature. 
As i mentioned earlier, check this - http://central.sonatype.org/pages/gradle.html . IMO, it's not that bad to do this in gradle. The plugin will generate the pom automatically with the required dependencies. 
None of the issues the author mentions are 'solved' by moving to another language. If you dislike ORMs (I do too), don't use them. JDBC returns maps; so you can use maps in Java if you want them. If you don't want strongly typed DTO's/domain objects to pass around by all means go and pass maps around (which I don't agree with). None if these are language issues at all. What really irks me however is the reference to another article about lines of code. That other article however doesn't show any proof of how it was achieved; it's easy to claim language X has less code than language Y when you don't simply show the code. And this is how a long chain of blog posts all referring to each other starts. It does however compare a bit of 'function' Java code to it's Clojure counterpart and they're the exact same length. And personally I think the Java version is more readable to boot (granted; I'm inexperienced in Clojure). And to me personally code being readable matters a ton more than the length of it. I intend to build software that lasts.
Thank you
Since this is help with Java programming, it belongs, as the plenty hints on the page indicate in **/r/javahelp**. Kindly repost there. **Post removed:** programming help
In favor of Spring. At frst blush I interpreted this as Java itself.
&gt; "is your solution JEE based" What's JEE?
I'm not going to have that discussion again. You know what I mean.
&gt; I've seen a shift to C# That's curious. I don't know a single company that moved from Java to C#. It's a shift that doesn't make any sense economically. Java's open source ecosystem is much larger, .Net's Linux support is new and incomplete and you also end up with basically the same application rewritten in a new stack. For what? It's also something I don't see happening here in Holland at all. All the new hip Big Data stuff companies are doing here is done on top of Java for example. Even in the Amsterdam hip Fintech startup world Java is dominant. 
I think for production log files of say a million lines long you wouldn't want to try to render it through Markdown and HTML and scroll through that in your browser - however this would be a very useful technique for more report-like logs (e.g. one log file per execution).
i've long been of the opinion that type safety would be a tremendous addition to javascript. i thought they solved that problem with "use strict" and that was enough for me, but it sounds like TypeScript takes it a step further and that (IMNSHO) is a really good thing. when *I* (italics because i mean only me) say "light weight" i mean a small amount of application code to make something happen. IF you do the true OO methodology/paradigm with base classes and subclasses and implementation classes and blah blah blah you wind up with more code than is necessary. 
Yeah well. Tests are not "necessary" either but proper design is just as important to creating maintainable software as tests are. Copy-pasting code instead of using OO techniques to facilitate reuse might be 'easier' at the start of a project but becomes a huge burden later on. And this is the problem with most of the arguments against the verbosity of Java (or OO in general): it's a tool that can be used to write readable maintainable software. Also please don't confuse Java and OO programming with outdated dogma's like AbstractSingletonFactoryBuild patterns or interfaces with just one "Impl" class: it's 2016. Java 8 with all it's FP influences might not be the most cutting edge but it's still a modern pleasant language to work with.
Wow, indeed, strange that it ended up here.
&gt;that doesn't necessarily mean the language is on the decline. but, people will look for simpler solutions and they are being found. No, they are not yet. Ever heard of javascript framework fatigue? &gt;very few, AFAIK, use java on the front end and are happier with scripting langauges a la javascript. No, people aren't happier. Javascript is being used because it's universally available in a web browser.
It's been 10 years since J2EE death, i'ts Java EE now. And Java's syntax is perfectly fine. 
The obvious undertone to this whole thing is that people are using Spring in favor of Java EE. What constantly blows my mind about this claim is that the people developing on Spring insist that Java EE is useless and they have no need for it. I would love to see them develop their apps without the Java EE libraries and specifications for things they constantly use like Servlets, and JPA. Edit: Wow! Thanks a lot for my first gilded comment!
Others have suggested learning resources, so I'll skip that. My advice is- think of a specific problem you want to solve or a specific project you want to do. Then learn stuff you need to accomplish that. Stay motivated. That's the most important thing- no matter how much you fuck up, if you keep at it, you'll learn eventually. The main point is not to give up and leave. And main 3 points in motivation is: * Have clear measurable goals. (I want to do X, and X will be done when T runs and does Y) * Have clear sense of progress. (Today I implemented step 3 out of 10 to do X. I can see it runs and does T. And at this rate I'll be done in 7 more days) * Have a reward at the end? I guess that's a bit moot for personal projects. Set aside some money and buy yourself a nice dinner or something when you're done :) --Coder
&gt; some even tout it as a good thing. Because *it is* a good thing. When you have a project, not a couple of scripts, but a real project it's the only thing that keeps developer sane, and code readable. If I want small non-verbose code I would rather take Python. Also, there's more to JVM than Java, you can use Kotlin, for example, and call Java libraries from it. 
I still don't see what you are trying to prove. So we must abandon Java because majority of startups want to be hip and new? You can be hip with Java too: use vert.x, use spark, and you don't have to abandon stable, proven language in favor of JS or PHP. And you still have your new ~~shitty~~ shiny frontend frameworks, like Angular/React and what else is popular these days. C#? What does it better than Java? You get worse performance, maybe better syntax sugar and what else? 
there was a time, when java was touted as "write one, run anywhere" that it was a display mechanism in browsers. it can still be a a browser display mechanism COBOL, believe it or not, once had a UI generation product just because you can, doesn't mean you should unfortunately, programmers took "write once, run anywhere" waaaaaaaay too much to heart and we have the unGodly mess java is today 
Look into minecraft forge, the bulk of the documentation is probably for version 1.7.10, but if you want your mod to be 'current' I'd suggest going for 1.10
&gt; i meant happy as in "the browser will run my code and i can see my changes a hell of a lot faster than if i have to compile/deploy the thing" Really? With Java EE I hit ctrl-s in my IDE, then *immediately* after f5 in my browser and the change is there.
that's wonderful. how much did the package that does that or the IDE cost? how meaty of a laptop do you need to do that? how complex is the whole production deployment process? what systems had to be purchased/put in place to ease the deployment process? how much bigger does java used for screen handling make your application? i'm not saying you can't do it. i just wonder if you should forgot one: what requirements does this put on the user's machine?
14, 21, 7, 288, 23
&gt; Trivial. mvn clean deploy basically. Builds the product from source and deploys it. sorry, i meant deployment to the end user
I think a lot of this frustration about Java EE is misdirected as well. People seem to conflate the Java EE specification with the implementations available in servers like Weblogic and Websphere. Here's a big newsflash, most people seem to hate those servers, including me. That doesn't mean that there is something wrong with Java EE. I can use modern lightweight containers and pick and choose the parts of the spec I want. There really isn't a reason (besides maybe vendor lock in and corporate support contracts) to be running these giant monolithic app servers anymore.
I would really prefer if you'd call it Java 2EE. 
Our 'end user' deploys a docker container. So that's just a single "docker run &lt;servicename&gt;:latest" basically. So how do your customers deploy PHP applications?
&gt; and we have the unGodly mess java is today Mess? The hell are you talking about, lol? Java is one of the few crossplatform languages where you don't pull our hair our writing application. I can create desktop application, web application, or game in Java without much effort and have a good balance between performance and sanity.
oh, the api is a mess - i've worked with php before. light weight is from the perspective that its interpreted so you write it and run it and that's it.
i do java so my war files are being deployed to clusters of servers. its a big gigantic process
Whoa, that was unexpected but that's pretty cool. Makes sense that there would be a JVM one, and I can also use that as a reason to learn more Haskell. 
&gt; sorry, i meant deployment to the end user oh, then please say that. In that case it's: `mvn clean deploy`
Struts 1 is more of a thing I think.
That pretty much says it all. 
Agreed. We still have some v1 apps floating around. 
Yes, Spring is not bad at it. But Java EE is a lot better. Spring is one company that drives the whole thing, there is no way to change the vendor of the implementation. In Java EE, you have Red Hat, IBM, Oracle etc.
Funny. I work at the largest Dutch bank and we never had issues with Spring. 
I wasn't even aware that MVC was under consideration here. I mean, doesn't everyone just use something like Spring Web MVC if they want a Java MVC framework?
The belief that of you don't curry, you end up with "spaghetti code" is a very specific (and extreme) requirement for clean code. But, one thing you can take away from this article: objects are just partially applied functions (through constructor/method configurations and injection). I tend to see objects this way myself. "Objects are poor man's closures; closures are poor man's objects."
unlikely ORCL will do more... the scope of Java EE 8 has been further reduced. it’ll only have a new security API &amp; JSON-B, plus updates to existing JSRs https://blogs.oracle.com/theaquarium/entry/java_ee_8_community_survey2 
&gt; want decent performance and graphics you've got to get close to the hardware. that's always been C/C++. I'm not talking about new Battlefield level graphics here. I'm talking about a decent 2d platformer with good effects, or maybe even Minecraft. You can write in OpenGL using lwjgl, or you can simplify things and use Libgdx, if you're not an OpenGL developer. I don't see anything close to Libgdx in Python/JS world. &gt; something like that is going to be volumes and volumes of code regardless of how you write it First you say that Java is a mess, because of the volumes of code, but now you say that this will take volumes in every language. You need to determine your use-cases. 
&gt; You need to determine your use-cases. i *like* small code bases. i recognize this is not always possible 
Actually Spring Boot and Spring MVC are the top two frameworks in Java - JSF is considered by *many* to be the worst part of Java EE and it has not aged well. JPA, JAX-RS, Servlet, JMS are some bright spots for sure. https://zeroturnaround.com/rebellabs/spring-and-java-ee-head-to-head/
Just write Scala? 
"Changing the vendor" is a completely unrealistic argument. Java EE vendors have never truly been interchangeable, there are holes in the spec / things the spec doesn't address that create vendor specific versions. Sure, if you use servlets only, you *might* be able to swap out servers if you don't use vendor - specific session state persistence or something. But if you're just using servlets, there really isn't any value in paying for a Java EE server anyway, which is why Tomcat has been leading the market for nearly a decade....
I'm about to test some XML generation code, and this would be useful to torture test it. But I baulk at adding annotations to my production entities. Maybe we could combine it with Fakir https://github.com/dmcg/fakir
You can give Alias-i's [LingPipe](http://alias-i.com/lingpipe/index.html) a shot. It's a professional library that has many built in high performance models for a wide variety of NLP tasks. 
I'm going to have to call bull on this. I've watched an entire enterprise drop C# like a bad habit, switch to cloud based operation which I feel C# hasn't been able to move quickly enough towards. Not that OSS will eat the world, but it has a certain mobility factor that a lone entity can't keep up with. Small companies are developing the power of large ones....small companies are not going to license software and IDE's (within reason) when they can get it for free. Even if they did, the vendors couldn't eat bread off of the money they'd make from it. Just opinions clearly. I agree with your view of Java's slow adoption. It does feel like we are the last to get the nice things.
Its widespread use in legacy systems, perhaps?
You've seen an entire enterprise switch to Java so there for all of my experience is invalid and I must be lying. I'm clearly wrong for stating my opinion. This is why I typically don't speak up in Java discussions. Java folks come out of the wood work and attack me for not stating Java is the best language ever and everyone everywhere obviously uses it for all things. Thank you though for the agreement about Java being slow to adopt new things. Edit: Clarification. I meant to say Java is slow to adopt new things, not slow performance 
Sure, and that's probably all they meant here, as well. It's just that the way they worded makes it sound like a separate license is necessary for*any* commercial use, which is obviously not true.
I stated multiple times that Java is a fine language, which I am using and will continue to use professionally. I merely tried to point out some of the reasons it *might* be in decline based on my personal experience. Things that could and probably should be addressed. I never said anyone should abandon anything. I never said C# was better than Java. Again I stated both have their uses. ...and not only have I been called a liar by one commentor but I am being treated like I am personally abusing people. I apologize for suggesting anything could possibly be wrong with Java. It's obviously perfect and anyone who doesn't adopt it immediately is clearly a moron like me. I'm glad we got that resolved.
Some of that can come from watching people give coding examples. Most of the time this will come from creativity. Just stopping and thinking of what this could be used for will do it. Books lay this out for you, videos will not usually.
Well, you answered your own question :-) Node is big because Javascript hackers think they can write the server side like they write the client. Maybe a few can.
Yeah. You have a point. Big companies, with something to sell just have a built in tendency to try to make people **think** they need to buy said thing.
&gt; please. that culture left with Rod Johnson a long time ago. Then what's the linked article about? I'm willing to accept that when Rod left the big push behind the hate campaigns lessened, but it's still not totally gone. &gt; Sure, individuals from the team will complain about the parts of Java EE that are frustrating them that they need to work with, That's another thing. If Oliver complains about things in JPA he has to work with or the frustrating process around it, then that's understandable. What I was talking about is mindless bashing of Java EE because it's still seen as one of the main competitors of Spring.
&gt; "Changing the vendor" is a completely unrealistic argument. It's absolutely not! It's true that often you don't just run your application on another vendor's server unless it has been specifically designed and constantly tested for this (we have some universal apps were we indeed do this). The idea however is that you can relatively easy port your app to another vendor's server, and this we have done a couple of times over. One of our apps was ported from Orion to Bea, to GlassFish and then to JBoss. Every time the development efforts was a couple of weeks, *at most*, for a multi-million line code base. Now try porting such a huge thing to a completely different platform, like say Node.js or .NET. Don't think you'll be able to do that in even 100x the time.
I was thinking of adding an alternative for those who don't want to go directly at their model layer. The annotations are inoffensive, but I understand some people not wanting them in there. I still haven't decide in which direction to go (any suggestions ?). As it is implemented right now all the @RandAnnotations are actually calling methods from a class called Rand.java, so the mocking functionality remains there.
JavaEE has always....*always* championed having multiple, seperate isolated applications running in a single container. Writing them in such a way that they can be added/ removed / hot updated without restarting the container. This is how it was intended to work, and if you follow the spec, without creating your own threads / threadlocals, it works great. Multiple small applications running in tandem together. JavaEE was never meant to become a single monolithic war , that does everything (like database connection pooling, messageing, etc). this was intended to be handed off to the container. This is, Microservices. In fact, this pattern is described exactly on microservices.io http://microservices.io/patterns/deployment/multiple-services-per-host.html So, yes, JavaEE has done microservices since....well, forever. 
This. Really. https://learncodethehardway.org/ 
&gt; many GPL projects offer separate licences that allow that. So does OpenJDK, because it is actually licensed under GPLv2 with Classpath exception as far as I know. It's strange that the article does not mention it, because pure GPLv2 would require you to have a different license for any commercial use.
Verbose because of what? OOP? Because I have to type types and actually know what variable type I return and take? Wait a bit, we will get type inference and you can write your beloved "var". Streams and lambdas already cut codebase size in two. 
So you are saying I should not use the official plugin for this? Because that was kind of my goal here. Regarding your two suggestions: Both look pretty good but the first one seems to be [almost abandoned](https://github.com/bmuschko/gradle-nexus-plugin/graphs/contributors), which is a pretty good example for why I want to avoid a third-party dependency. I will give the second a try if I can not make that work out of the box.
It's perfectly possible to use a pure GPLv2 license for commercial use. 
I see. So the "solution" was simply implementing the complexity from the compiler level, to allow the developers to use MI in the application code, **not** mitigating any of the issues it can potentially cause. Whereas in Java, why implement the complexity from the compiler level, when MI is considered a bad practice from an app implementation and shouldn't be used anyways (for most cases). The logic makes sense to me. I guess those boundary cases and edge cases (something I have no idea about, I assume they exist) are the reasons some developers dislike not having MI.
Good point. I guess it's trivial to add it to the existing code, should you want to get the comparison
Again you are just attacking me now. You have never seen me code and have now idea what conventions I use or why. You argue that verbosity is a good thing in one comment and that it is not in another. I can't really keep up anymore. You win. I will never post in a Java subreddit again. 
This is a bit confusing. Wasn't string concatination already optimized by automatic replacement of "+" operator with StringBuffer by the compiler in Java 7? I often hear contradictory statements about this topic, I'm still not sure what to believe. All I know is that the performance of my code was always great or at least sufficient and in 99% of the cases I never used StringBuffer. 
I don't know - I've been developing games in Java for 4 years and I've never had issues. libgdx, especially, makes it all run fast and efficient, and targets both desktop, mobile and html5 platforms. Raw performance isn't a big deal any more, and for most games the extra bits of juice you can squeeze out by using C++ simply don't matter. Android uses a different VM, yes (ART), but the language itself is still the same inside and out. There is however a fairly large "stigma" against Java in general, in that people have used shitty and slow Java apps in the past (see: all applets ever and most Swing programs) and thus associate Java with "slow and clunky" - the opposite of which a game should be.
Have you read this? http://softwareengineering.stackexchange.com/questions/55104/why-isnt-java-more-widely-used-for-game-development
Not a great article in tbe first place, but you have amazingly managed to further reduce its value with a bullshit clickbait post title. Congratulations! 
It *is* used for game dev. Besides the obvious example of non-mobile, non-Windows 10 edition Minecraft, [Puppygames](http://www.puppygames.net/) uses it for their games. I'm sure there are others, as well -- they just don't talk about it. And why would they? You don't see games studios talking about having use C++ or C or C# or whatever. It's not relevant. Word has it that quite a few games use it in the server side, as well, though I don't recall seeing much public talk about it (and it's not really what you're asking about). There are also plenty of Android games that are written in Java -- some using libraries like libgdx and/or lwjgl, so they may run on the JVM as well. Honestly, Java could be used to make virtually any game today, sort of the latest and greatest 3D action games or VR. The main issues at this point are network effects; to much existing code and too many of the available libraries, tools, and middle-wear only (or primarily) support C++, and maybe C.
Java technically has multiple inheritance with 'default methods' in interfaces now. 
For me, the biggest problem in writing games is the non-real time nature of Java. So what if a web page takes 200 ms longer to render because the GC just kicked in. If it is a game, 200ms means just getting fragged by a enemy. Java is great for throughput. But, the timing required for AA game titles, you just need to do manual memory management, and forget about expecting the GC to help you out. 
What's your game? Or a link to a similar multi-platform game? Do you use a wrapper in iOS to run the html5 or ? 
The article, while meandering and short on useful analysis, wasn't nearly as bad as the post title. Where the hell did you pull *that* from? 
&gt; Not sure how I should take that other than an an evaluation on my coding style and character. Again you have no idea what I do or don't do. My bad, I incorrectly expressed my thoughts. I am actually awaiting for type inference in Java. I didn't want to offend in any way. Sorry. &gt; When some one is evaluating new tech do they immediate comprehend that Java EE supports all these new modern languages? No, typically they stop at the "Java". I maybe wrong, but when people evaluate new tech they're looking at performance, popularity and diversity of platform, number and quality of tools available. There is more to Java platform than Java EE, there's Spring (where Kotlin is a first-class citizen along Java), there's Grails(Java/Groovy), there's Play(Java/Scala). &gt; Heck there are still tons of folks that can't distinguish Java from JavaScript. I thought we were talking about programmers? &gt; since the current programing trend is more expressive and less verbose languages I suggest that might be a stumbling block to Java. I still don't see this as a threat to Java. Look at PHP, for example, with all the negativity in the Internet about it, it's still thriving, companies still use it. And Java is by an order of magnitude more powerful than PHP. 
A more recent argument against Java game dev that I've heard of is that when the garbage collector runs, it causes a slowdown.
&gt; Then what's the linked article about? Ask Gartner - you can't buy a Gartner market guide, that's not sponsored by anyone. Anyone that hints otherwise is simply spreading FUD and revealing their ignorance publicly. What's the report about? I think it's pretty obvious - Gartner can no longer ignore the reality of Cloud Native Platforms. Concurrently, they are seeing the IBM/ORCL revenue decline since the layered products atop weblogic/websphere are finally starting to erode. SOA Suite, EBusiness suite revenue and the like can no longer be used to obscure the declining application server revenue which started declining in 2004 due to the arrival of spring/tomcat. My personal guess is that these market dynamics forced their hand. 
That's only a problem for java developers who don't know what they are doing.
&gt; you would need a commercial license if you made modifications to the OpenJDK itself IANAL. The "Classpath" part of the license makes this unnecessary.
Declaring local immutability isn't that useful anyway.
Possibly, but sometimes there are business reasons to use Java. As the space between Java and a certain style of Scala (though obviously not all of it) narrows, this will become an option more often. But for now, there's a still a space for using a library in a more popular language than switching over to Scala completely.
Not sure this micro-optimization will be useful for many, but I appreciate the author's willingness to take reader feedback and write proper benchmarks.
Sadly, in my experience, Programmers don't make the decisions at a corporate level and it is exactly the perception argument that will sway upper management. A CEO/CIO isn't going to pound keys to test features in languages, he is going to read sources, like Gartner, and be done. "A programmer is smart. Leadership is a bunch of risk-adverse, panicky, dangerous animals and you know it." I think that's the quote from MIB right? That's really what I am getting at. When it comes to Java, I have heard the things I listed raised as objections multiple times, that's all. As far as other JVM languages go... A good example (admittedly on the .NEt side) is that I, personally, like F#. It has some interesting application to certain problem domains. I haven't had a chance to implement anything because, in the corporate sector, if there is only one guy who knows it you typically won't get approval to do it. PHP is an excellent example. Java is the superior language in any direction you can measure scientifically, like Betamax to VHS (for all the old-timers, like myself, out there). Why, would you say, PHP became so wildly popular?
Certainly, a design pattern / architecture can be accomplished in nearly anything, but that doesn't offer a lot of value to the developer / operator. Java EE does little to support that architecture / design with tooling, just to name one area of deficiency. That's why so much of the initial Java EE 8 roadmap reads like the Spring Cloud feature list. 
Ain't nobody got time fo dat. I don't want aaaaalll details. A TL;DR is enough.
I'm Junior Dev, so I'm kinda new on the market, so I might be wrong in few things. Earnings for programmers overall in Poland are very, very attractive, while comparing to other jobs. As Senior Dev you can get up to around 20 k PLN which is around 4.5k euro and it gives really good standard of living in Poland. Java seems no 1 lang here, there are 2 big markets, Cracow and Warsaw, but Wrocław is growing pretty fast too. There is quite a lot maintenance jobs (mostly finance sector), but more and more startups and software houses (at least in Warsaw) show up. To sum up, it looks decent, but best devs often try to leave PL anyway to try their best in US (big 4 etc.).
&gt; Wasn't string concatination already optimized by automatic replacement of "+" operator with StringBuffer by the compiler in Java 7? I remember seeing this in Java 5. Any statement where more than two strings are concatenated got this treatment, but only within the expression doing `+` concatenation. In other words: `aString + "static string maybe" + anotherString;` &lt;-- automatically optimized at compile time since forever to something like `new StringBuilder(aString).append("static string maybe").append(anotherString).toString()`. It's only an optimization within a single statement though. This was never optimized: for(...) { aString += anotherString; // not optimized, you need to use a StringBuilder } 
&gt; A good example (admittedly on the .NEt side) is that I, personally, like F# Heard it was inferior to Scala in most ways, but don't quote me on that, haven't heard anyone using it in production. Even Scala positions are hard to find. I'm not an expert in PHP world, but with recent release of PHP7 there're massive improvements, so I heard. Performance is on par with Facebook's HHVM, improvements to standard lib and so on. Personally, I don't like PHP only because of it's syntax, and would never use it. But maybe for people who are invested in it, or beginners, it's gonna be a deal breaker. Heard people even return from Python because of the new PHP.
Very much appreciated, thanks. That explains why I'm hearing both stories!
Companies like BigPoint, Innogames, GoodGameStudios and Jagex have had Java positions opened for years. It's definitely used in the server side.
Actually, Hotline Miami was made in GameMaker 7. For RPG Maker, you might be thinking of LISA or To The Moon as recent, successful and acclaimed games made with that engine.
The fk u talking bout?
Right. When notch was making the game, there were a lot of things he did just to get it to work. And a good bit of that code still is in the game from what I've gathered when looking into modding. And I guess their mentality with it is just not to fix what isn't truly broken at the moment.
java's tendency to stop all execution for a few ms, while GC happens. its not usually an issue......but, for games it is.
you can use the official plugin, but at the expense of a larger more verbose build file. and i also believe the official plugin doesn't do the code signing for you, so thats more shit to add to your build. without the second plugin you are going to have to log into the sonatype web interface to promote your uploads manually. all of this can be avoided but just using maven. a bonus is the plugins to upload and promote your artifacts are much superior and more maintained. tbh, i could probably make a better plugin for gradle that what is available... hmm...
Shouldn't dish out simplistic advice like these. As a rule of thumb, you shouldn't pool simple objects. Also, unless your VM is single threaded, there's no point in designing for something like single loop efficiency. If you're looking for shortening gc cycles, look for advice on zero garbage java, there are lots of good resources. If you're looking to improve your performance, look into inlining and how it's applied. The latter also helps with gc, as long as you're designing for it. 
p.s. &gt; there really isn't any value in paying for a Java EE server anyway, I don't need to pay for JBoss, GlassFish and TomEE and depending on the project not for Liberty. What's your point?
also, you might be surprised how little effort the gradle team puts into maven publishing.
How does this prevent decoration? I'm not suggesting changing anything about how interfaces work. Inheritance is useful when you want to reuse code in an unmodified way. This is a fairly uncommon use case, but it does happen and you might as well support it (in this limited way, which avoids pitfalls) EDIT: I guess I can understand that inheritance becomes superfluous if you have better syntax for delegation. So yeah, either way is fine with me.
GC pauses should already be in the 100 million items as it can't keep all that in the heap. If the array is 92 bytes that's already 9.2 GB of garbage per second. It does, if I understand JMH correctly, run for 2.5 seconds so that's 23 GB of garbage.
I mean if all methods are final then you can't decorate them for outside calls, from the child class through inheritance.
**NB: I am not a lawyer, nor do I play one on TV.** I believe your use case is exactly what Oracle intends to be covered by "non-general purpose computing". IOW, yes, I believe they expect you to pay royalties. Given that Oracle's ARM is in the process of being merged with OpenJDK 9, perhaps you would be able to use that? Assuming your project's delivery is out around OpenJDK 9's release date, and that Azul continues to do their builds of OpenJDK.
----&gt; /r/HailCorporate 
Yup. Seems like an easy optimization to do and to prove out, if not from hotspot then from the compiler's bytecode output. I've had to use the authors trick myself on several occasions, unfortunately. (admittedly that was in java 6 that this was a big problem. I've not seen the enum thing come up as a slow down in java 8).
What's sorely lacking here is a static iterator() or foreach().
eh, I don't know if that is necessarily true. Java can do virtual dispatch more efficiently that C++ can because it can fiddle around with the types and avoid vtables in many cases. However, C++ has a better memory model than java does for high performance computations. Java has to do extra work to try and prove whether or not something can be stack allocated vs heap allocated (with it usually ending up on the heap). C++, on the other hand) puts almost everything on the stack with the heap rarely being touched. Further, C++ does a better job of grouping together like data in contiguous blocks of memory, which is really important for cache efficiency. Java will be comparable if not faster in things like virtual dispatch and graph based objects. However, C++ will be faster for basic objects with no virtual dispatch (which is how most games are written, with no or little virtual dispatch). Hotspot is good and fast, but I've yet to see any sort of benchmark that really puts java ahead when it comes to performance. With that being said, I've never felt limited by java's performance. Generally I find performance problems due to code problems long before I find performance problems due to the VM. I've never seen a Java app whose bottle neck was network/db time/ or someone doing n^3 algorithms. All of those things would significantly impact C++ just as much as java.
(Un?)fortunately language choice isn't always up to the developers. 
Yup, all good examples. Thanks for listing 'em! I don't have solid examples, but I've heard that some of the bigger names use Java on the back end, too, at least for some subsystems.
&gt; Set colors for Javadoc You mean I don't have to read dark blue hyperlinks on black anymore?
What's wrong with Clojue and OpenJDK on ARM? If you are planning on selling this device or using it for commercial use you would need to license the Oracle JRE if you chose to use it. If performance is the problem maybe try Zulu Embedded from Azul (open source, based on OpenJDK but a lot more performant on ARMv7/v8 than the standard OpenJDK is right now.
Money-wise it's pretty accurate. But if you are not a fan of authoritarian government, catholic sharia law and intolerance against pretty much everything, I would seriously reconsider moving here.
oracle, eat shit and die.
Why copy it in the first place? Memory pressure is a thing
Swing is the "windows forms" of Java. I really hate it.
Don't forget Hyper Light Drifter is made in GM!
Server (bukkit/spigot/nms) or the client?
Oh yeah, definitely. I worked on a now-defunct server wrapper that would deobfuscate the code at runtime, and apply bytecode transformations to add event handlers and such for a modding API. I can only imagine how much more intense it would have gotten had I kept going.
&gt; and people use that just fine. not really, I always complain at unity's shitty performance. Even in the 'best' unity games like KSP, or CiSky
The problem with OpenJDK is that it is 2-10 times slower than Oracle JDK on ARM, depending on task. I think it's mostly related to memory management. I didn't know about Zulu Embedded, will give it a try. Thanks.
I was just gonna say "well...it's called final" and I see them say it works. Non-issue imo
It's the client and server, but on the server side just the nms stuff, bukkit and spigot are just patches and apis to make interfacing with the server less awful
Because then you could "break" an enum with a simple: MyEnum.values()[2] = null;
[removed]
Does the RH OJDK support Webstart?
LingPipe is very nice and well documented. You can also take a look at: • OpenNLP • Stanford NLP • Apache UIMA • GATE • FrameNet The last one specifically might be of interest to you, although I don't know whether there are any readily available Java implementations (and maybe that's too big of a gun for your problem anyway :-) For other JVM languages see • Scala: Scala NLP - Breeze and Epic (related spark-project.org ) • Clojure: clojure-opennlp If your looking for any [Application development services](http://www.cygnet-infotech.com/application-development) I would like to suggest a good company like Cygnet infotech thanks 
You are one of the reviewers of "Java 7 concurrency", aren't you?
It is Java related. This motor gives the possibility to be controlled directly out of Java, or any other language who is able to deal with sockets. There is no other motor you can command that easy out of Java! This is my first account on reddit and the purpose is to find out if my product has a market and to get in contact with many people as possible to collect their needs. 
I guess this was my misconception then. It thought "Ooh, a new supported API, I will just use this one as I'm sure it will be awesome soon." Maybe I have to revisit that decision...
Off the top of my head I can only think of two occasions where I've had to heavily optimise some code. One optimisation introduced a difficult to find bug (which was later fixed) the other resulted code that still wasn't fast enough after the optimisation process (it then got a top to bottom rewrite with a new design). Maybe I've just been lucky but my experience is that having a good understanding of the problem and coming up with a half way decent design is worth ten times more than worrying about how quickly you can join strings together.
But it's very close :)
Despite common belief, reddit is **not a self promotion platform**. The reddit rules state that **one** self promotion in every **ten** contributions is acceptable. The sole purpose of your account is to promote your product and this is not allowed per the reddit rules for self promotion and spamming. Consider this a **formal warning** - further spamming will lead to a ban.
I guess it depends on what kind of game you're making. I think the choice of game engine drive the choice more than the language. And, if you want to write a scalable efficient game engine you want to control the memory and that leaves Java out. That being said many games does not require that level of optimization. I would argue that there are many games written in Java if you include android. 
Thank you! 
If that is the case, Spring is probably not very popular in enterprise application development, right?
Yeah, because every AAA game is a shooter. You can delay GC until the end of match, for example.
Wait for project panama.
I originally used reflection too, then I got it to inject interfaces into the code so I could call it directly. Much faster :)
*Head scratching.*
you're free to look for jobs or projects that do use the language of choice
libgdx now supports [Intel Multi-OS Engine](https://multi-os-engine.org/) or a [RoboVM fork](http://robovm.mobidevelop.com/) as Microsoft Xamarin bought and extinguished RoboVM.
Are there opportunities for newbie JavaEE/Android developers? &gt; Source: I live in Krakow for 2 years now. Care to write your story? Pm me, if you could. Where are you originally from? What was your expertise when you moved to Poland?
Anyone use String.concat() to optimize join of (only) two values? It's used very rarely even in JDK source itself...
Isn't slick2d discontinued?
Would be really nice if at some point they introduced an annotation like @StringBuilderify that would automatically overload concatenation to use SB.
Here's a number for you: 0x3817af7c. Good luck collecting some more of them!
If y͚ouͣ r̻éal̷l̨y wa̻nt ̯͞ţ̩͐o, ̾͟y̬o̓u͝ ̣ca͡ǹ ̑a͝lͬr̞ͧe̜aͫd̺̓y̍ d̴̝ͥŏ̀ ̼̓s̹͢î̩m̧̮ĩ̼͞l̩̀iͥa̸̱̒r̸̆ ͡t̗͜h̶͔ͥḯ̦͞n̜̉̕ģ̼̈ş̥̐ ̡͍ͮw͍̉͠ȉ͕t̢̠ͨḣ̩͝ ̵͉r̹ͯ̕e̚͡ͅf̣͆͢l̬͐͜ĕ̞́c̸̘ͯt̻̍́i̵͎ͮơ̯ͣn̸̹ͨ.͕̃.̴͓̅.͆͏̭
8?
Just curious what specifics? I've actually done about 90% just from having a general Java development job.
Excellent choice. Now how about 267914296?
Glad it worked for you! Oracle is merging their AArch32 support up into OpenJDK as a result of Azul's efforts on supporting it, but Zulu is in a state to work *right now* and is pretty damned fast.
I'm out of my realm here, but I'm pretty sure all entropy is collected from hardware, so it's quite likely you're going to need a native lib. Or try to access /dev/urandom if you're in a hurry.
/dev/urandom is still secure. See [Myths about /dev/urandom](http://www.2uo.de/myths-about-urandom/).
And that's numberwang!
And how does that imply that a Spring application will have 2-day outages or something like it?
I like to use SecureRandom to generate a seed for a more heavily used Random.
new Random() will take entropy from the clock. That's good enough for most people. Are you most people? 
&gt; Unreal Engine 4 uses GC, as well, even though it's a C++ engine. GC isn't a problem, people, it's a memory management mechanism that must be used correctly -- that's all. With Unreal, you decide explicitly what's a GC managed UE object, what's a UE struct, and what's just a plain C++ primitive you're managing yourself. And the manual *warns against creating thousands of objects, as it might affect GC*. Every algorithm works just fine when you're using it in a highly restrictive way, at a small scale. The problem in Java is you can't choose a less granular approach, because absolutely everything is a garbage collected object. So you'll be creating (hundreds of) thousands of them in a complex engine, like it or not. Of course, you could just allocate a large byte buffer and start managing things manually in there. But at this point you're no longer programming in "Java" but an inner platform within Java, a language within the language. At this point you might as well use C++.
Well, I'd like to think I'm special...
In this case I believe the number of objects is actually the same. The "slow" version creates 1 new array each time, and the "fast" version uses JDK iteration, which creates an iterator (new Itr() in AbstractList). If we did what /u/deep_fried_eyeballs suggests below and make our own forEach() we could get rid of the object creation. 
&gt; Of course, you could just allocate a large byte buffer and start managing things manually in there. But at this point you're no longer programming in "Java" but an inner platform within Java, a language within the language. At this point you might as well use C++ I get so tired of hearing this bullshit. You wouldn't say that using a GC means you're "no longer programming in C++ and might as well use Java or C#", so why the hell do you think the opposite holds? In addition, selective use of object pools and appropriate sizing of GC regions are also tools to reduce latency spikes and variation. With advances in GC (see Shenandoah for OpenJDK, C4 from Azul, and in the non-Java world, Go's new collector), the picture will continue to evolve. I'm not saying that Java (or other managed languages) are better than C++ or C for game development -- that would be absurd for many reasons. I'm just saying that managed languages, and GC in particular, are not an absolute non-starter.
Would add CDI to the bright spots. 
If you have to constantly do rain dance interpretations around the GC to "manage" it, then the problem is in the GC, not in the developers. The "you're just not trying hard enough" / "you're doing it wrong" excuses are often used as a way to deflect blame from the real culprit.
Also it would be interesting to benchmark both JDK 9 and 8 implementations (StringJoiner in JDK 9 was optimized and does not use StringBuilder)
?
doesn't exist on game consoles (and with indies having much greater access to them, this becomes something worth noting). engines like unity, unreal and cryengine have become very accessible. jni still seems like an unloved ghetto. i haven't looked around lately, but i don't think there's mature/stable directx or metal libraries.
that title is a bit of a word salad :)
Of course. Modern GCs, though, work just fine unless you're being extremely careful. No need to constantly micromanage.
https://groups.google.com/forum/#!topic/mechanical-sympathy/jQGahuzJKM4
True story.
wtf? I had to look this up http://www.urbandictionary.com/define.php?term=ingalls What was that word supposed to be? ... Now that I looked up the link, that poor soul has an unfortunate name.
*Here's the Urban Dictionary definition of* [***ingalls***](http://www.urbandictionary.com/define.php?term=ingalls) : --- &gt;One who munches on the dingleberries of another male. --- _I want to ingalls my swing guy all night long._ --- [^(about)](http://www.reddit.com/r/autourbanbot/wiki/index) ^| [^(flag for glitch)](http://www.reddit.com/message/compose?to=/r/autourbanbot&amp;subject=bot%20glitch&amp;message=%0Acontext:https://www.reddit.com/r/java/comments/5jwbhf/spring_data_release_train_ingalls_rc1_released/dbk9l3d) ^| ^(**Summon**: urbanbot, what is something?)
That is a very good question since it has been an open bug to switch to /dev/urandom for almost a decade. NativePRNG and SHA1PRNG should switch to seeding from /dev/urandom by default
Because this is contribution. Just because you're nostalgic for eclipse it doesn't make it abject trash software. My post is worthless because you don't agree with it? Nice
/r/titlegore
seems like noone ever cared
but the latency until you eat is still the same even if you managed to set the table and clean the bathroom in the meantime. My particular system was not limited by concurrency, but when user facing operations take 10's of seconds, there is a problem. I should be clear here, By blocking I literally mean that the device itself blocks. So even if the api you use to access is a "non-blocking" API like that which might be found in NIO or Node, the system will still be waiting until /dev/random decides to finally deliver you some bytes. More power to you if you manage to convince the CPU to do something else in the meantime.
Sorry, i meant the user is a spring fan, it is known, no? Known just means it's no secret and people know. Hope is more clear now.
Ah yes, "cloud-native". A new buzz word to replace "webscale".
For this survey to be of any use the answer should include where you are located.