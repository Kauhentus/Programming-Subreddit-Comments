most aren't that great. i like rust's, from what i've been exposed to.
Your code does not make any sense and is invalid Java code. You likely have the wrong sub-reddit. 
This is freemarker...a template engine for Java FYI
It would be better to post in /r/javahelp since that is where you can get help with Java programming since /r/java is not about getting help (and questions like this are likely to be deleted). Remember to tell your problem, what you use, and explicit details so people can help you better.
Very cool! I like that it supports Python, Javascript, &amp; Ruby and that it allows reading and writing. I wonder how it does with supporting recursive structures like .zip files? Edit: There is a [formats library](https://github.com/kaitai-io/kaitai_struct_formats) available for this too. Archive formats are mentioned, but none are in there yet.
I'm wondering the same thing. The book is excellent, written by an established expert in JavaFX. However, I wouldn't recommend it for learning JavaFX from scratch, because it's really only about the innards of controls, which is just a subtopic in the larger subject.
Outlines steps to share classes created in test branch of a multi-module Maven project with other modules. 
The way I learned event sourcing, each "State DB" from the diagram are called "Projections", which emphasizes the fact that there's no "one true state" - each stream is internally consistent, but events between streams are not transactional, so a given projection must make certain data-merging decisions if it's going to aggregate multiple streams (which is common). The impression I got from the post was that he expected to have one canonical State DB. I completely agree with the conclusion though - don't go creating tons of projections for one-off things - first wait until a feature needs to be implemented, and then use the simplest method to get there (with one option being querying the Event Store directly, as he mentions). Even better - not every event stream has to be collected into an entity, sometimes you can just read the event stream directly to answer certain types of questions (I think alluded to in the article, but not fully articulated). Anyway, it's good to see EventSourcing becoming more mainstream!
enough with the speedment spam. seriously.
I like the method that you added at the end. I prefer to create a seperate module and then have both modules depend on that for scope=test. It just seems far more clear to me, otherwise it's side-affecty You still got my upvote though
Hah, I *just* had this same question and settled on this solution today. Gotta poll Jenkins for some crap. EDIT: A link for those who come here from search: https://github.com/rholder/guava-retrying
Check /r/programmingprompts or the [Programming Challenges](https://www.reddit.com/r/learnprogramming/wiki/faq#wiki_where_can_i_find_practice_exercises_and_project_ideas.3F) in the /r/learnprogramming wiki.
Haven't tried it yet but I think it looks awesome. I have thought about something similar but I wouldn't have used an external format but rather annotations on classes akin to JAXB or Jackson with the compilation step being optional. Do you have any plans for that or are you only ever supporting the external configuration files?
Why not isomorphic templating with Nashhorn and Spring Boot. Best of both worlds.
Bitstream support is coming up soon in next major version. We're currently considering to do some automated converters from other similar formats like 010Editor's templates, Preon annotations, etc, to ksy.
Yeah, that's true. What's even more ridiculous is that spec is pretty vague and many tools have their own ideas on what a zip archive is. I've tried a few semi-broken archives that work perfectly fine when treated with InfoZip, but it totally breaks Windows Explorer unzipping functionality.
As someone who has used almost every Java build tool going (and those from many other languages too), I really like and appreciate Maven. In the Java world I've tried out Maven, Gradle (Going back to Beta), SBT, Leinengen, Ant, Make and even just shell scripts. No matter what, I always end up going back to Maven because I know how to use it, it works, and it's usually relatively easy to actually make it do what I want it to. Gradle always seemed like a good idea, but it always had too many things wrong with it - missing features, bugs, errors in documentation, plugins that just didn't work any more, etc - for it to be real-world usable. To note as well - Maven doesn't do Artifact or Binary hosting at all. It works in terms of defined Artifact repositories, and it has support for uploading artifacts to those repositories, but how they are hosted is completely separate. As long as they expose the correct file system structure over an appropriate transport - normally HTTP - then all is good.
Generated-on-the-fly code also has its cons like it's pretty much impossible to debug ;) One of the goals of KS was to maintain generated code readable and debuggable, if required.
cf [concursus](http://github.com/opencredo/concursus), which provides quite a nice `EventSource` API for pulling events out of an event store, on the assumption that often what we will want to do is replay events directly to suitable handlers.
From my experience as a self-taught junior programmer, Maven is a great and powerful tool but it's not very easy to get into and the documentation is solid but not easy to read, hence many newbies tend to have problems learning. Generally when working with Maven you need to have a pom.xml in your project root (or more if you use modules). The pom is quite simple once you get to know it, don't get scared by the documentation which often loads a lot of unnecessary stuff to the examples. A basic pom only has two things: required parameters (such as groupId and artifactId) and a *dependencies* section where you define your dependencies as others have instructed in this topic. Once you have this, you launch a command line where the pom is and you run commands, for example *mvn clean install* will remove your target folder (the *clean* part) and then compile your artifact, place it in your target folder and install it into the local repository. That's pretty much everything for the basics. Once you understand this, it's easy to expand and use the power of Maven. Oh and the dependencies Maven downloads and uses are to be found in your user directory under .m2 folder (on Windows), so if something is missing you might want to check there to see if it even downloaded.
Thanks for the reply, that's really good news :)
I'm interested!
Why sure!
1 year though, what will i do next year after experiencing ultimate for a year???
what's up with that ? looking at your post history, you had 1, one month ago, with many post offering it since, and you still have it ???
Pay for it if you like it, go back if you don't?
I'll have one please!
Sure, would be nice to mess around with :)
Please sir, I'll take one! P.S.: I am the only person to use manners... Just saying ;)
I am interested. The student licence is about to "expire" as I am about to graduate next month. 
Enroll in a college and use the free student license
Actually won these coupons in a competition sponsored by JetBrains, and considering I won't be using them, might as well sell them for cheap, win-win for everyone. 
what "proclamations"? what's "significantly off"? maybe you should pay more attention, engage in a little more skepticism, and engage in a little less crass punditry. also, you apparently don't know jack about rust, or cargo. not that i'm an expert.
&gt; maybe you should pay more attention Pay more attention to "I like rust's", please enlighten me. &gt;engage in a little less crass punditry. Don't be a hypocrite. &gt;you apparently don't know jack about rust, or cargo. And yet you still don't provide any support to your ecosystem or maven criticism holding up (for three exchanges now) some "yet to be disclosed" build / dependency management system.
&gt; Pay more attention to "I like rust's", i don't know much about it to tell you anything. you pointlessly asked for some other "platform", which is a weasel question. rust seems cool from what i've toyed with, last year. so your silly question received a silly answer. then you whined that specifically "cargo" was a "a dependency manager", even though it's also a build tool, test runner, etc. you're trying to argue in bad faith, but you're not even doing that well. &gt; Don't be a hypocrite. case in point, this is part of the weaseling. &gt; And yet you still don't provide any support to your ecosystem there is no "my ecosystem". i'm not advocating anything, and i'm not making some relativistic or comparative claims that you hope to goad out of me, just so you can dodge and snipe. &gt; or maven criticism holding up can you even articulate what my "maven criticism" was?
&gt; you pointlessly asked for some other "platform", which is a weasel question wait, so you pointlessly imply the ecosystem and the tool are inferior and when I ask you for a reference to a non-inferior example which you won't even back up and you claim that's I had a "weasel question"?! &gt;then you whined that specifically "cargo" was a "a dependency manager", even though it's also a build tool, test runner, etc. Finally some useful information. I admit I made a mistake, I just dug further and see you're right about it being more than a dependency manager. &gt; i'm not advocating anything, and i'm not making some relativistic or comparative claims that you hope to goad out of me, just so you can dodge and snipe. LOL, you declared there is something wrong with the java ecosystem or the maven tool. I'm not dodging a thing. You pointed to cargo which is: * Not secure for dependencies in any way * doesn't have a plugin system * will have you stitching imperative per project spaghetti scripts instead of any sort of plugin system and I'm sure more... I'm not digging any further as you just appear to be another person that happened to sling shit and got called on it. at least you have the courtesy (to the forum) to back away from pursing the criticisms of the environment. But you continue to try to evade being called on your initial claims by your personal attacks. 
What's out there? 
I recently came across this library for async retry, which seems promising: https://github.com/nurkiewicz/async-retry. It also supports exponential backoff to gradually delay further attempts of executing the action if it fails.
Doesn't java supports zip out of the box? Why did you write your own?
Let's do this!
One: **wrong subreddit** - this should at best go to /r/javahelp as is indicated in many different places here. Two: **no rewards** Three: **no do my homework posts** neither here, nor in /r/javahelp - such posts should go to /r/DoMyHomework **Don't** post this to /r/javahelp either - will be removed there as well. You should do your own homework and not delegate it. **Post removed:** multiple rule violations
All the examples in the article would have been identified by IntelliJ. 
Static analyzers have some common ground now, but Sonar does so much more. Also, IntelliJ can use Sonar analysis too.
The problem isn't so much syntax, it's the philosophical musings one has to go through to determine what you're to do with the exception as a consumer of an API. `IOException`? Ok, easy, disk/DB/network failure. `SomeAPIViolationException` -- less easy to contemplate. If we had pattern matching then exceptions might be less cumbersome to use, and our thinking around them might shift to one of "how do I deal with this eventuality?". Either way, I still think it's less about syntax and more about thought process/API design. 
Removal of the "try" keyword would actually complicate processing of the compiler in an area. An entire block would have to read first, stored in a queue, and then determined if it is followed by a "catch" or "finally". So instead of generating code in pretty much a single pass when it comes to code, you would have to keep going back. When it comes to the JVM there are no checked exceptions, they are all unchecked. Also, if one wants PL/SQL, perhaps one should program in it instead of Java? PL/SQL reminds me of BASIC. 
Are you joking? There are thousands of open-source Java projects, most of them open-source and open for contributions. https://www.apache.org/ Lots of stuff on github. Lots of BigData engines/servers. Some of them are part of Apache. Build tools, IDEs, web-servers, app-servers, tools, etc. What are are you interested in specifically? Java is very broad. Do you want to do Android development? BigData? Frameworks? Back-end? Desktop? Games? Web-servers? Networking?
The problem is, that code is read more often than written. All the clutter damages the signal/noise ratio.
I can't even tell if his accent is real.
Wouldn't the parser find the nature of the block as it processes the code before compilation?
The last example goes too far, you can't tell if the catches are all on the 'something' statement, or nested on the log statements inside the catch block.
I find try-catch blocks really nice for this. I know to mostly ignore them, whereas when the catches are interleaved with the if-else ladder, it takes a lot more effort to 'skip' those blocks.
It would have to handle the exceptions thrown by the f() block for consistency reasons with versions that use the `try`keyword. Which means that `catch` would be "left associative". Good point. There are probably a few caveats to resolve with associativity in connection with other statements, e.g. like `if else`.
Indeed, but the complexity of this additional feature hardly competes with the complexity added by [generalized target type inference](http://openjdk.java.net/jeps/101) in Java 8
I've got one. It's an artificial life simulation, runs in Java, deploys to web for visualisation. I'd be happy to delegate some coding tasks if you're just looking for projects to get experience on. www.github.com/juckele/vivarium
https://github.com/chriscamacho/LogicEdit a logic network editor with plugins for node types (like AND OR etc) uses JavaFX isn't too complex - real life in the way, while I'm not directly coding for it at the moment I will administer any pull requests with pleasure....
Can't we just have sum types in Java and get rid of checked exceptions? At that point unchecked exceptions could be used as intended, to catch *unexpected* errors at the last moment.
The "disclaimer" is about the road map. Who can predict the future 100%? May it be allowed that we spend time on other stuff if we think it is more worthwhile or react to user requests and change the road map? Anyhow, may be the text should be easier to read :)
Thanks for the explanation.
Just a thought: Volunteer to provide an app for a non profit, or to mentor someone. Unrelated... give yourself deliverables and milestones so u don't slack off. Take the Java certification, or some free structured online program that is appropriate for where u wanna be.
How'd you get Eclipse to identify the first example?
&gt; Could you please help me understand what you mean here it's a bit idiomatic, expressing the notion that the "ecosystem" isn't all that amazing. another way to put the idiom (though typically in terms of people) is that it's rather easy to stand out from a mediocre crowd. &gt; To me it looks like you disagreed with me, and went further to challenge the foundation of what I was saying. you said "I haven't found anything declarative that's better (...)"... which is strictly speaking a personal, subjective and qualitative statement. there's nothing brooking disagreement or debate, the only person who could "disagree" is you. only you can say whether you did or did not "find anything better". &gt; Inform and/or support /r/java readers &gt; My effort was to learn, which clearly turned out to be wasted effort if this is actually true, perhaps a better approach would entail being more genial and hospitable, rather than insulting and narcissistic. &gt; Stop to think you're not being coherent or clear? perhaps, feel free to explain. all i know is that you keep talking about all my hostile proclamations, wild claims, and how i have so unjustly debased your fair maven. as far as i can determine, such things never happened; so what's there to say besides "wtf".
I think u may be doing him a disservice. At least use ant. Maven or gradle are better, but a batch file is not pretty decent, nor is an ide specific build.
So... the tl;dr: version is... use var if it helps you solve a business problem and your team is cool with it... right?
I worry only that var makes exposing concrete implementations of interfaces easier than explicit declarations, and muddies the diamond operator for generics: var namedPersonMap = new TreeMap&lt;String, Person&gt;(); vs... Map&lt;String, Person&gt; namedPersonMap = new TreeMap&lt;&gt;(); 
Your terminology is a bit off. In this line: TreeMap&lt;String, Person&gt; namedPersonMap = new TreeMap&lt;&gt;(); /\ this is the interface /\ this is the implementation Yes, they have the same name. But the first `TreeMap` is a public interface, not an implementation. You can see this more clearly by changing the code as such: TreeMap&lt;String, Person&gt; namedPersonMap = new SuperTreeMap&lt;&gt;(); /\ this is the interface /\ this is the implementation When we examine `SuperTreeMap` we see that it actually implements 4 interfaces * `SuperTreeMap` * `TreeMap` * `Map` * `Object` Of those four, the variable `namedPersonMap` exposes the `TreeMap` interface. **** Edit: I swear, talking about API design with Java-only programmers is even more painful than trying to explain to them the difference between pass-by-value and pass-by-reference. 
SonarAnalyzer can run on server side and analyze all your source everyday. Check https://nemo.sonarqube.org
*Your* terminology is a bit off, in the context of Java. [`List`](https://docs.oracle.com/javase/8/docs/api/java/util/List.html) is an interface, as is [`Map`](https://docs.oracle.com/javase/8/docs/api/java/util/Map.html). [`ArrayList`](https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html) is a class that *implements* the `List` interface (and is thus an implementation), and [`TreeMap`](https://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html) is a class that *implements* the `Map` interface (and is thus the implementation). In this line: Map&lt;String, Person&gt; namedPersonMap = new TreeMap&lt;&gt;(); /\ this is the type of the variable /\ this is the type of the variable's current value But because the *variable* is declared as a `Map&lt;String, Person&gt;`, it is constrained to only those methods that are defined on the `Map` interface, even though the actual *value* is specifically a `TreeMap` (which may have more available methods/fields than are available on the `Map` interface).
The catch is associated with the block, so yes, this code would be equivalent to: for (int x : myRange) try { doSomething(); } catch (Exception e) { handleError(); }
But presumably the author would claim that static typing is still good (not just using javascript and never declaring types). So is something like ML the optimum? -- statically typed, but the programmer never *needs* to declare the type; the compiler infers the rest. I'm guessing the author's stance is probably closer to "always declare the type when it's easy, and don't mention it when it's complicated / distracting".
I can only speak for java and c++, the paradigm there is that upcast will never disable dynamic function binds, only super does. so ((Treemap) new SuperTreemap()).foo()) will always call stm's foo function given it exists 
please post questions in /r/javahelp 
Thanks for digging into it. This is a bug, I have fixed it on the master branch and will include it in the next release. Thanks again!
That's not the best way to do that. It wont allow transitive test dependencies. See the official maven docs, and pick method 2: https://maven.apache.org/plugins/maven-jar-plugin/examples/create-test-jar.html Also, this is something gradle handles a little better than maven. You can just include the test module as a testCompile dependency... but thats a different conversation.
&gt; I agree it's noise and that the code should be simplified. regardless of APIs and occassional false positives that you could squelch with annotations, overall I'd rather have it there for the 99% of the cases and go through the extra effort to clarify that in code with the 1% that is a false positive.
Unless there's a specific reason to use Eclipse, I'd highly recommend the community version of IntelliJ instead. I find it significantly easier to get setup and running, even as a more experienced developer.
Around year 999,999,990 Oracle will mark it as @Deprecated, but won't remove it because it's needed for backwards compatibility... (it's probably referenced somewhere in com.sun.corba so can't be changed)
Call me a stuffy old traditionalist, but I don't see any need to support years beyond 2038
C# needed var to support anonymous classes, which enabled Linq. But as seen in C++, Scala, kotlin and many others, var/val quickly becomes the common idiom once you learn to use it.
THANK HEAVEN for the JSON support and terminal bug crushing. 
Will they EVER learn? - Max date 99: Broken. Y2K bug. - Max epoch `Integer.MAX_VALUE`: Breaks soon (2038) - Max `Year.MAX_VALUE`: Just you wait. Come on. Write sustainable software, folks!!
/r/programmerhumor 
The JSON support is not coming. It was dropped early into Java 9 development. I don't know why these poorly written articles keep telling people it's coming in Java 9. http://mail.openjdk.java.net/pipermail/jdk9-dev/2014-December/001731.html
Once gain, the main issue with var is that it does not solve any problem at all and it introduces some problems. Therefore, it is useless. If you do not like type, please use another language without types. 
I imagine it's a bunch of people with dynamically typed/dynamic binding language backgrounds like python or javascript.
Beyond it's relevance to the debate, this is just an amazing example of clarity in writing and argument.
"modernising any language" like C++ where all loops use auto nowadays? You never mention ONE problem which is solved You never mention that it increases the difficulty to learn or to teach the language (because sometimes it is possible to use var and sometimes it is not). You never mention the increase of the complexity of debugging You never mention the fact that types are given by the IDE You just mention that we have to be modern. No we do not have to. The strength of java is it slow evolution. It is really a strength. For instance I'm ready to bet that C++ is dead BTW you example are bad. 1) Nobody writes the first code due to implicit conversion and any good programmers will decompose it to make sure there is no issue with the division 2) The second code is very special and code using string are not important in general. 
Because, unlike 15-year-old canned tomatoes you find in the back of the pantry, people rarely throw out 15-year-old software.
[proof](https://s9.postimg.org/4jeciazhb/eclipse_ten_tego.png) [configuration](https://s9.postimg.org/avths52jj/eclipse_ten_tego1.png)
 int compareTo(T o) ??? But every time I implement it it is an Obje.... OH! Comparable has generics. Wow I feel silly.
You're definitely not worng.
The reason this just won't happen is that this will put them into liability with Oracle due to the ongoing Oracle/Google trial.
...and it is a really solid IDE - IMO better than Eclipse.
Glad I went with Cordova and at least our server use Java.
It removes the cruft so that it is easier to see the business logic. The vast majority of the time the actual type doesn't matter, just the methods that it exposes. P.S. In C# we also have the dynamic pseudo-type, but Java isn't considering adding it.
Might as well use IntelliJ then =D.
once you went with the "shut up and sit down" approach, there was nowhere to go.
&gt; &gt; &gt; You never mention that it increases the difficulty to learn or to teach the language That's because it makes it easier to teach. I start out by using `var` and then later add the concept of explicit types. 
Sounds interesting :) 
Sadly, my hope the "new and wonderful" Microsoft would do good by Robovm was unfounded. The Register has an article on it ... http://www.theregister.co.uk/2016/04/15/microsoft_discontinues_robovm/ RIP Robovm.
Thanks. How much coding,experience do you have?
sounds cool, what exactly were you thinking the group would do though? set up an irc and just chat, or meetup weekly and go over problems or something? whatever it is, i'm interested.
Not the other guy but I'm a beginner and interested. 
Hey! I'm interested. I think maybe this should be a group chat thing on Viber or Skype. I'm doing an interactive course on core java, finished 10/40 levels. They tell me I've learned the basic syntax. So I'd say advanced beginner. PM me and I'll give my contact information.
Sometimes the problem is, your program is not executing where you think it is. It can be helpful to have your program print out the directory it's in, [here's a link that looks to be helpful](http://stackoverflow.com/questions/4871051/getting-the-current-working-directory-in-java/7603444#7603444). Maybe you'll find the reason it can't find your file is because the file is in one directory while your program is actually executing in another.
I'm in! Just started udacity's java course and playing around with the language in spare time at work. 
Thanks for the help! :)
About to finish my first Java class in college. Professor wrote, and teaches out of Pearsons' "REVEL." I have also been using "codeacademy" as a supplement resource. Basically, I'm new too and a group sounds like another good resource to have at my disposal; I'm in! Let me know OP!
Me
Glad I switched to ReactNative due to laggy Ionic/Cordova. 
I feel like we should do something like Skype or TeamView if everyone's comfortable with that. I'm honestly open to any suggestions As for my coding background I'm not anywhere near saying that I can code, but I learn really fast and I'm willing to work with a group of people to kinda build this into a great way to learn how to code.
more contrast between text and background would be highly appreciated.
I think this would be pretty cool. Count me in
im a beginner and would like to join ... :)
Heck yeah, add me to the list.
Also interested, doing Java on Treehouse, Midway through. Lemme know of you guys start a group learn.
I'm a somewhat experienced Java programmer, and would be more than happy to pitch in and help where I can. Let me know if you have a Slack channel, or whatever else, and I'll drop in.
Beginner here, extremely interested as I never got beyond the basic syntax. 
Beginner here, interested in learning from and helping others!
 There is the daily programmer challenge. Get a few easy ones and start working. Try to find a forum to share thoughts and questions. Maybe create your own subreddit with the current weekly challenge that links to the actual challenge and info that say. We can all join fj dash coder dojo on irc freenode and chat at 7pm this day. Then you can use pastebin to share code. Even if you didn't finish people can help you if you just explain your thoughtprocess. 
I have little experience. It would be nice to be in a group to work on things. Count me in. 
Sounds awesome, count me in too!
Hey man I am starting tomorrow (well later today as its 1am here in the UK!). My copy of Intro to Java by Liang (10th ed. comprehensive) will be arriving so I will be working through that. PM me and we can exchange contact details or arrange IRC meet up. 
Count me in also
**Slack**. Code snippets. No awkward encounters. History is fully saved. Couldn't recommend it enough. 
I want to relearn Java! lets do it!
Count me in!
Sounds fun. I've taken a couple java classes and have an associates degree in programming, not much confidence yet though, this would be great to help out and I'm sure learn and relearn
I'm in, you got a group set up or something?
I'm up for it, but I don't have any professional experience. I've just been learning on my own and have made a couple of programs to make my work easier. Most complex is just a simple graphical program to recreate air-to-air fighter tactics and record .avi's of them. I'm sure any professional would cringe at my code though lol.
Replies.* I have C# and Python academic and intern experience but the apps that I support at work are all in Java.
I'd like to join as well!
im in...I could set up an IRC server...if people can refrain from trying to kill it.
I don't think any of them open a security vulnerability just by being installed.
If you don't mind my asking.... Why Cordova and not Codename One if you are a Java guy?
A solution for having your own var/val without changing the language: use a plugin of the IDE An example: https://youtrack.jetbrains.com/issue/IDEABKL-7086 A lot of thing could be done through the IDE 
I really feel for you. 
No doubt that introduction of generics complicated the language. Annotations arguably complicated the language. Introduction of lambda syntax complicated the language. Introducing local type inference will most definitely not complicate the language. If anything, it will make the code simpler and more pleasing to look at by removing unnecessary line noise where explicit type annotations are not adding any new information. And what's up with the whole "developers are too stupid to understand it" attitude? I was under the impression that ours is the industry of knowledge workers and engineering, not menial labor. I happen to believe that the job of writing software requires some level of intelligence and ability to learn and adapt to the constant changes around us. Give us some cred please...
Incompetent government is not the same thing as too much government.
The further I do more "functional style" things in java using Option&lt;Foo&gt; and the like, or hell , even List&lt;Foo&gt; I tend to extract whatever I might put in a loop working on a single Foo - makes things easier to unit test - if there things that need testing slightly in isolation of the rest of the situational boilerplate. Tiny methods for the sake of tiny methods can pointless tho, altho they can sometimes bring a bit more clarity/readability to stuff as well. I think it's all about context - like pretty much everything in code.
So, what's the advantage of Ehcache compared to Apache JCS? Speedwise they've been at parity for a long time (AFAIK) and JCS comes without the dual licensing headache (i.e. off heap caching). I've used Ehcache in a few frameworks and JCS as my main caching solution in an app, seem very equivalent to my cursory glance.
You either did not read or understand what the lawsuit was about. It was simply about the false claim that installing the newest version fixes security problems, which it not always did by leaving very old and vulnerable, still executable versions behind. Having bugs in your code is not a problem at all but telling customers "it's fixed" without fixing it is.
How many times more are you going to spam the same post? * https://www.reddit.com/r/java/comments/4emx34/intellij_ultimate_ide/ * https://www.reddit.com/r/java/comments/4e169g/more_intellij_idea_ultimate_coupon_codes/ * https://www.reddit.com/r/java/comments/4b4p6j/anybody_want_a_license_for_intellij_idea_ultimate/ * https://www.reddit.com/r/java/comments/4b32n3/anybody_want_a_license_for_intellij_idea_ultimate/ And there possibly were some more that got deleted, e.g. this: https://www.reddit.com/r/java/comments/4cyjig/intellij_idea_ultimate_license/ And that's just the posts in this subreddit, not others. Just stop, please.
Agreed, but some people like this other IDE more P:
It's also capable of delivering atrocious font rendering on Linux.
It is called SceneBuilder [1]. All major IDEs have SceneBuilder Integration if you enabled the JavaFX plugins. --- [1] http://gluonhq.com/open-source/scene-builder/
I don't see a mods section on the sidebar. 
It's at the bottom.
Why not something like unity
You could write the whole thing in C? *don't actually do that*
In my experience "var" is useful with literals, for example: var a = "hello"; var b = 12; but not for methods like: var m = thisMethd(); Because when reading code you are not sure what thisMethd() returns and with literal you now the value of the variable in the moment you see it.
No, we don't exist. We are just figments of your imagination.
Happy Cake Day, This is an excellent post, I don't know why it is voted down. The OP just needed to read the side bar and see what is already available. I think one of the best automoderator filters for getting the maximal removal of confirmed garbage content, with the fewest false positives, and the least effort is to have automoderator remove content from accounts with less than 0 comment karma. That is the default amount of a new account. If people have negative comment karma, they aren't on reddit to have a genuine conversation. --- # Filter out anything written by a user with a comment karma of less than 0 type: any author: satisfy_any_threshold: false comment_karma: "&lt; 0" action: remove action_reason: Account less than 0 comment karma score modmail: Negative Comment Karma Content Removed message: Your post to {{subreddit}} was removed. All content posted to {{subreddit}} must come from accounts with comment karma scores of at least zero.
http://j2objc.org/
Do browsers even let applets still run? 
You should have been moving away from applets for at least 5 years. This shouldn't be a shock. No place I ever worked really invested in it.
It is pretty much already, so jdk team will have less crap to care about - which is a good thing.
applets? you can still do those? 
The incubus doesn't exist either.
thanks for the offer, I may just take you up on that.
I have been doing this... normally when i run into something that I know I can use on one of the projects I make note of it. I have trying to read both the classes book and other sources. 
Thats a really good idea, getting my hands dirty with the syntax seems to be the best learning tool. Reading is one thing but actually doing it is where you find if your understanding it or not.
The goal is to write an app's non-UI code (such as application logic and data models) in Java, which is then shared by web apps (using GWT), Android apps, and iOS apps.
+1 for this
Your existing applets will continue to run using whatever Java runtime you currently have. And applet support is only being *deprecated* in Java 9; they won't actually remove support until at minimum Java 10, which is several years out. In the meantime, bake some virtual machines that you can keep around "forever" that will let you run your applets. And if you can, convert your applets to JNLP. 
I assume the funny part is being the video inserting apple images instead of using a textual representation.
Oh, and by the way, I did finally ban that particular spammer. They'll probably come back with a new account though. :-/ We also have programmed AutoModerator to hide help posts that contain some keywords. Even with that in place, some get through. When we mods are busy, you see them.
Flash is still around. At least applets are dead for non-company stuff.
We're ignoring it because we've already moved away from applets. What limited support remained in browsers has been removed from browsers in the past few years, and it hasn't been a good idea for about 5-10 years before that.
damn.
I disagree. Too much government inevitably leads to incompetent government. and Incompetent governance breeds more of the same.
Unless the incubus is dynamically special and statically virtual.
I'd like to join :o
WebAssembly will be worse.
I was Looking into this a few weeks ago. I recommend netbeans with scene builder. I tried getting it to work with eclipse and netbeans was much faster
Sure you do, it could still mean you are an ungrateful bastard, depending on what that someone did wrong and how you criticize. But what op did was like someone trying to keep 200 hyenas walk in special patterns and then one hyena runs off and op goes "so is ANYONE attending to the hyenas?" Do you see my meaning? Unmoderated channels are like youtube comment section, do you really think that is comparable to this subreddit?
I have no idea about the quality of j2objc, but that reasoning is very flawed. Comparatively, natural languages are much much *much* more complex than programming languages. 
Flash is dead, applets are dead, ActiveX is dead, HTML5 has won. Understandably, all vendors slowly remove support for these technologies. Clients had enough time to anticipate these moves. Of course, you don't have to upgrade. You can run your system in a dinosaur ecosystem on Windows XP VMs that still run IE6 (or better: NetScape), Java 5, Clippy, etc, and never again touch the running system. Good luck!
And too little government inevitably leads to megacorporate dystopia. Incompetence is *way* better than that alternative.
Applets talking to the browser is why my company waited as long as it could before finally moving away. We ended up having to integrate a push framework into the product to accomplish the same thing. So, now instead of the applet simply talking to the browser to pass status messages (it's a connectivity thing), we send the message to the server, then the server goes and finds the user's web session and then the web session uses long polling (cause, you know, websockets aren't 100% - long story: Jboss + legacy IE support) to send the message back to the popup window. It's completely understandable why Applets need to go away, but they had their uses outside of Calculator apps in CS101. 
Pretty sure Safari still allows applets, at lest it did the last time I tried it. Chrome is the only browser to my knowledge to completely remove support.
Maybe a year from now, but this is not true today. Source: my company still supports applets (at lest for another couple of months.)
On Linux, applets in "my" bank worked only with system locale set to `ISO-8859-2` (LANG=*.UTF-8 was not supported - text encoding garbage)
Hey, if I can never code in fucking javascript again, it will be too soon. I would sooo much rather write a good language than javascript. WebAssembly is a necessity for us to get away from that garbage language.Yeah, things like typescript, clojurescript and scala.js fix some of it, but we need native.
this article seems to misunderstand what static is in java. It would make no sense to allow override static as static is not really a part of the class at all but more a global variable with package/class as a namespace. Java didn't get anything wrong its intended
I liked the original version more than the DI version. The original version is more compact, clear, avoids the use of streams and map/reduce. Even Google gave up on mapreduce (finally): https://www.quora.com/Why-did-Google-stop-using-MapReduce-and-start-encouraging-Cloud-Dataflow Streams should be removed from Java. DI shifts programming complexity and then adds to it; it doesn't make things better. The DI version of the WeatherAggregator in the example doesn't let the compiler know if the objects are null which means the compiler can't let the developer know so the problem can only be detected at runtime (at least with the old Spring approach and no annotations). This introduces the need for configuration management which adds more complexity. DI reduces the effectiveness of the compiler/developer relationship. 
That date is a lie to increase sales. Canned tomatoes are non-perishable indefinitely.
I don't understand why DI seems to be executed so comparatively poorly in Java.
Can we please do something about these fucking bloggers and their bait titles 
A new question. Are all java developers poor? Because this comment deserves gold.
This looks incredibly promising. I'm not sure that I'll need 2D spine phisics since I'm making a top-down dungeon crawler though :P Do you have experience with this? 
&gt; Even Google gave up on mapreduce (finally) Damn, did not know that. Thanks.
&gt; Even Google gave up on mapreduce (finally): &gt; https://www.quora.com/Why-did-Google-stop-using-MapReduce-and-start-encouraging-Cloud-Dataflow I'm not sure if you understand the article that you've linked to because that is about MapReduce in distributed computing and has nothing to do with using functional idioms in single-threaded code. &gt; The DI version of the WeatherAggregator in the example doesn't let the compiler know if the objects are null which means the compiler can't let the developer know so the problem can only be detected at runtime (at least with the old Spring approach and no annotations). The compiler doesn't help you find when objects are null. Either you're using special tooling for that, or it is always a run-time problem so I don't see how that is relevant to DI at all. And DI frameworks like CDI will fail to deploy if as dependency is unsatisfied, so you would never just end up with a null. &gt; This introduces the need for configuration management which adds more complexity. Again there are declarative DI frameworks (like CDI) that require no or minimal configuration.
I'll be sad to see freely available information go. Everything will be locked into these binaries. Corporations will love it because finally they will assert full control over their content and be able to thoroughly defeat ad blockers, and I guess developers will like it out of spite of Javascript.
Then use an adapter to standardize the API from your application's perspective.
So I did in the imaginary Spring Weather example. Before I meant something like a REST API when you have to write some code yourself to use it. Probably I could have made it clearer :)
I've been looking for some sort of java newbie community. PM sent for Slack invite.
&gt; Also, we can now add as many APIs as we wish and WeatherAggregator will remain untouched. Pure awesomeness! Congratulations, you've invented a collection. 
lyk dis if u cray evrytim
Yes, if you add a ".0" to the end of a number Java will interpret that as a float and conduct floating point division rather than integer division. Adding the "f" just makes it look nicer, and also explicitly makes it clear that the decimal is a float and not a double.
&gt; private WeatherApi1 weatherApi1 = new WeatherApi1(); What is this? It's not an external dependency because it has no connection strings or other external dependency issues. That's why I hate these kinds of examples. They are so far from reality as to be useless.
My biggest problem with annotation based injection is that it generally replies on public getters and setters. I really, really don't want that. When properly designed, most high level service objects are shared across threads. That means I want to make them immutable if possible, something that naturally comes from constructors. 
TIL! :)
Yep. When I first started to really understand IoC I found that my designs naturally began to tend toward immutability and composition. And oh the increase in testability... 
We are a Java shop and declaring that our next project is going to be an applet has been a running joke for years. No one should be writing applets. No one should be supporting applets.
Hey OP, open the slack to everyone without invite.
Or look at Cocos2d. You can use same C++ code for both platforms.
depends on what you mean by "shit job" and "criticize". the volunteer also has the "right" to tell you to shove it. also, moderating a forum is qualitatively different.
To actually help the mods: when people post questions that should go in /r/javahelp it would help immensely if people would just point them there instead of answering their questions here. If you give them valid answers not only will they not learn but others also see people here helping them and post their questions. I understand people just want to be helpful but they get very good help on /r/javahelp too.
"I don't get it so it should be removed". It's a typical knee-jerk reaction of developers who can't deal with change. 
&gt; Your existing applets will continue to run using whatever Java runtime you currently have. Your applets won't run at all anyway without forcing your users to use non-default / insecure browsers. So in this sense the dropped support for applets by the runtime is way behind the dropped support for applets by the browsers. 
Not quite. By default most browsers don't allow it but sill let users turn it on. Only recent (as in: since somewhere last year) Chrome versions completely removed the NPAPI support. 
Yeah I am, I guess I asked my question wrong, I really meant to say what are some good beginners open source projects I can work with / on. I am really interested in networking / databases. I used to be really into game development however I'm more serious about getting a job right now.
Are microservices bundled into one executeable .... which kind of reverts the separation into single microservices? - or am i missing some vital feature here?
I was thinking the same thing
I read a lot of the documentation and I still don't understand the point of this. Why in the world would I want to deploy microservices in a monolith?
Could you give some more information on how it solves the versioning problem? I read [here](http://openjdk.java.net/projects/jigsaw/spec/sotms/) that: &gt; A module’s declaration does not include a version string, nor constraints upon the version strings of the modules upon which it depends. This is intentional: It is not a goal of the module system to solve the version-selection problem, which is best left to build tools and container applications.
What are the other features? All I see is different syntax for things Spring already provides. 
Wow....such simplicity...Thanks a lot for this :)
Intresting project, can you add your project to my project: [useful-java-links](https://github.com/Vedenin/useful-java-links/blob/master/readme.md)? It may be helpfull for both projects ...
1) it does matter. Package protected (class) vs. public (public class). For all intensive purposes, you won't need to worry about this until you start organizing code into packages. 1) Doesn't matter. However, I've always seen it as "String[] args"
*sigh*. Just because something is a monolith, doesn't mean its a big--ball-of-mud, difficult to maintain etc. Microservices are not always the solution.
Java as a whole is definitely still in use, I personally feel it's supported a lot more by other technologies and it's not sufficient to just know Java. But that could be attributed (in some degree) to the failure of JavaFX and because there are so many other useful tools: Ruby, Pyhton, Grails, PHP. There is a heavy focus on web development now and sadly Java is only a relatively small part of web development if you choose to use it. IMHumbleO. It's worth Learning Java at least as much as it's worth learning the basics of Computer Science. You don't need to master it necessarily but it'll really help and give you another tool in your arsenal. If you do decide to learn myself and a few developers created this App for testing you Java knowledge or to learn something new: https://play.google.com/store/apps/details?id=com.testmaster.se7.oca
This should either go in /r/learnjava or in /r/javahelp (which is indicated in many places here on the page). What you obviously lack is basic understanding of [*visibility modifiers*](https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html) (`public class` vs. `class`), and *variables* (`arguments` vs. `args`). The former (*visibility modifiers*) determines from where a class (method, variable) can be seen in the whole project (at the very beginning you don't really need to worry too much about that), the latter being just naming. There is no difference between `arguments` and `args` (again lowercase - definitely, because uppercase is indicating a constant), other than the name by which it can be referred to in the program. BTW: Java is *case sensitive* so, `public class` is valid, while `Public Class` (as you have) is not. IntelliJ will definitely not have `Public Class` but `public class`. I'd recommend that you use a different resource than your book to learn java because you seem to struggle with basic understanding and the book seems to lack key information (or is badly organized). Some extremely good free courses are: * **University of Helsinki MOOC** [**Object Oriented Programming with Java**](http://mooc.fi/english.html) - text based with exercises that need be completed and submitted before being able to proceed. (Uses Netbeans as IDE) * **Java for Complete Beginners** by John Purcell (probably the best and easiest entry into Java) - video based (Uses Eclipse as IDE) - the three links below lead to the same course hosted on different servers. I would use the Udemy link because it has an active community where you can ask questions and get answers. * [CaveOfProgramming link](http://courses.caveofprogramming.com/course/java-for-complete-beginners/) - John Purcell's site * [Udemy Link](https://www.udemy.com/java-tutorial) * [YouTube Series](https://www.youtube.com/playlist?list=PL9DF6E4B45C36D411) * **Derek Banas'** [**Java Youtube playlist**](https://www.youtube.com/playlist?list=PLE7E8B7F4856C9B19) with the accompanying site [Newthinktank](http://newthinktank.com) And, of course for quick reference: the official [Oracle Java Tutorials](http://docs.oracle.com/javase/tutorial/).
20 JavaFX real-world applications: https://jaxenter.com/20-javafx-real-world-applications-123653.html
How not to push ahead with anything in 2016: By introducing more annotations.
Maybe. However, considering Java EE 7 specification was officially completed mid 2013. Yet Oracle only managed to get WebLogic Java EE 7 certified in Nov 2015. https://blogs.oracle.com/theaquarium/entry/weblogic_now_java_ee_7 
I figured, it was a joke, and apparently a rather bad one at that.
It was worth reading comments on thread. Nice link. 
1. They're static configuration. They're not even real code. 2. They're a very poor man's declarative programming language toolkit. 2. No other language / platform has ever abused annotations as much as Java (EE). The only other thing that was never abused as much were checked exceptions. 3. Functional APIs are much more versatile for the same thing. 4. http://www.annotatiomania.com
@Mods: it's these kind of users that would be targeted with a [minimum karma rule](https://www.reddit.com/r/java/comments/4f1pgj/does_rjava_have_any_moderators/d2593no?context=3).
&gt;As professionals we care for what we do, and we always strive for the best. There is no room for mistakes, no room for bugs. Just recently, we have reduced the errors in our code by ~60% using a brilliant invention: The @CatchNullPointerException Annotation. Comedy gold
&gt; Yea, that sucks. I think I understand your general point, but I don't understand why this example sucks when they're removed. Can you elaborate?
Abstract interfaces have lots of disadvantages, but in this specific case lets look at code duplication: private double toCelcius(double temperatureFahrenheit) { return (temperatureFahrenheit - 32) / 1.8f; } Every Fahrenheit based weather source needs to reimplement that conversion function. Had WeatherSource been an abstract base class, it could expose that as a protected function to be used as needed by subclasses. 
/rjavahelp
If you're not watching it fullscreen, the slides are to the right of the video, updating in real time with the talk. It also auto-resizes the feed during code examples, so you can actually see them. There's also a `Slides` link under the video, but I haven't tried it since it needs registration (and the method described above worked just fine).
I just had to dig through the source code, which is a mess. Look at other open source maven plugins. I think Maven is dying as a build tool. Though Gradle, SBT and others piggy back on it's artifact repository and transitive dependency definition language. Probably that sonatype book is your only actual documentation. Maven 3.x uses Aether which is largely the work of the eclipse foundation. Aether code looks pretty clean in comparison.
Sidebar question: I am more concerned with packaging templates in a JAR. Is it possible to keep templates (thymeleaf or JSP) outside JAR file? (I understand, then Continous delivery might become little weird then)
Care to explain?
Yes I don't like XML format. its a pain in the butt to write a complex build script. but my team is very very deep into maven. i don't think they will ever be able to get out.....
Old IE exploits were rampant around the time we're discussing. Browser makers got the auto-update religion before Flash/Java guys did it's true, and deserve credit for that, but all these apps are giant rats nests of exploitable C++.
You're not *supposed* to write a complex build script. Complexity goes in plugins.
You: "What languages do you use here?"
&gt; a complex build script Ant showed us how bad that is and Maven protects us from it. That's the whole point, and the point Gradle missed.
if it makes you feel any better, we're trying to do the opposite. gradle to maven
What is it that you're hoping to read in this thread? Pro tips for not being lied to?
There is no magic answer. You have to ask a lot of questions during your interview and try to watch their faces/emotions as well as listen to their responses. Ask them a lot of technical questions about their products and the project they are hiring you for. Ask them about their tools, accessories programs they use with their products, what those things are written in, what parts of their system get the most work, etc. Talking to coworkers right after you get hired helps too. If things aren't to your liking you can still leave cleanly. You can simply not put the place on your resume and you will likely still have job inquiries coming back to you from your job search if you leave early enough 
No one is going to hire you to not write Java. Closest thing is they will hire you for adapting legacy solutions but adapting usually means support because you will leave before they ever get close to greenfield. I just did some digging for a contract and pulled out at the last minute because this was happening. Best way to make sure you're not being misused in a tech stack is to competitively price yourself.
Thanks for being "that guy" because that was my first thought too. We are a Python,PHP,React shop, but have some legacy Java. We hire Java developers and teach them our languages, but we are very up front about that. Most are very eager to get paid to learn more languages and architectures.
[removed]
I once got a job in "Java" that was primarily VBScript. Luckily I already knew VBScript.
“Dynamic typing: The belief that you can’t explain to a computer why your code works, but you can keep track of it all in your head.” — @chris__martin
&gt; Isn't ColdFusion a JVM language these days? Yes. I don't know about the "developed and supported"-bit. Sincerely, Richard Nixon
Languages are a component in career paths. If you're skilled in Java, and seek a job programming in Java, and after getting hired at this supposed Java job you're assigned Cold Fusion, that's just not cool. Now you're stuck with working hard at a new job to learn a new language, while *somehow* spending the free time you have left job searching for the job you thought you were taking in the first place, prior to the bait-and-switch? I think in programming that's what we call a "non-trivial problem."
Java still doesn't auto update. Not as such. It asks the user, "Hey, you wanna update now? Pretty please?". Now if you look around reddit, you will see a lot of users getting annoyed by that and clicking no. Very stupid? Definitely. But it's a thing that happens. And these weren't even IE exploits, I already clarified that. They were exploits in the JVM used to execute supposedly untrusted code. I can't believe it's 2016 and people are *still* defending applets. God.
I have never tricked anyone I was interviewing as to what language they would use. I say: "We are a java shop, all of our enterprise development is in Java and this position is for Java. I will be asking you questions to understand what you know about Java." Never heard of the bait and switch in a programming interview before...that's weird.
It happens. There might be a part of a system in Java, but many other parts of that system that are written in other things and it is those other parts that require maintenance or development. Employers, especially ones in shops where they have homgrown languages, homegrown frameworks etc will lie to potential hires, spinning the position as a Java development version. The job might actually involve opening a Java file once in a blue moon and the rest of the time is futzing with other parts of the system or their homemade stuff. Potential employers spin it as they know applicants otherwise wouldn't come to them. 
There are shops that have systems composed of multiple parts, some written in Java, some written in other languages, some in homegrown artifcats ( their own language, their own homegrown framework). Some of these employers have the Java development/maintenance reserved for people already there and they really want people to maintain/futz with the non-Java parts of the system. These employers want some with a Java *background*, but the job they are filling, the work to be done is futzing with their homegrown crap or other parts of the system. They know Java developer will not be interested in that so they spin the position as a Java position when it really isn't in day to day reality.
Multiplication doesn't go out of style and become a career dead end. If I'm working on one of those dead technology stacks my salary should reflect the risk I'm taking by devoting my learning energy to it rather than to something which could further my career. 
Would porting say Python to Java fit your description?
You can't have it both ways though; either programming languages (like Java or OCaml) go out of style and become career dead ends, so it's better to learn concepts from many different languages (like OOP domain modeling and functional type-safety/state-isolation) to better equip yourself for whatever languages replaces the ones that exist today, or languages stick around and are worth learning, even if only because it opens more career opportunities. Y'know what else is a dead technology stack? J2ME. And so is COBOL, which people that was too entrenched in enterprise to ever die (despite the fact that it has, in fact, died in all but the tiniest niches of the most painful legacy code in the most change-reticent industries).
Also Sent OP a PM! Waiting on My email to be Confirmed :)
Hrm. Usually I'd expect it to be the other way round. Here we use a lot of "really cool language". The legacy stuff is in "the not so cool language which we barely use." where cool = Scala and, not so cool = Java
Learn Spring, avoid Play. Spring may not seem "lightweight", but especially with new projects like Spring Boot its extremely easy to get started and only include what you need. Play is more akin to the "convention over configuration" style popularized by Ruby on Rails and works ok if you develop your app exactly like the framework authors intended. Deviate from the One True Path of Play and you're stuck in the bowels of source trying to figure out why it won't let you.
Same here, except it was ECMAScript 1.0.
[One day ago](https://www.reddit.com/r/java/comments/4fduuy/generics_and_javas_evolution/). 40 upvotes. 
&gt; Deviate from the One True Path of Play and you're stuck in the bowels of source trying to figure out why it won't let you And most of the sources are in Scala, which is fun to write but not that fun to maintain/understand
I think COBOL vendors just did a hell of job to let everyone think it is true. But when you think about stock exchanges and HF trading then it must be huge lie. 
You get a job programming in Java and take them at face value. Give them the benefit of the doubt and provide a little trust. Don't worry about it. There are bigger concerns to keep in mind, like "can I get along with and succeed with my manager?", "will I get paid on time (or at all)?", "is my organization profitable or sustainable?", etc.
Speaking that "spring boot is lightweight" is a lie, just step a side and you'll see a bummer like this: http://pastebin.com/x5CMXVmp I'd go with Play! 2 (not 1), it is not that headache compared to the spring(mvc). Also I don't understand what the problem with the documentation in Play!, the docs are pleasant to read and there are lot of examples to start from. 
wow, this is a big list !
This is a really good point. Thank you.
I'll give a shot, cheers. We won't be moving to JDK8 for a while unfortunately. 
&gt; Program in what you enjoy, not what is the new "hotness" ... &gt; I felt a great disturbance in the ~~Force~~ JavaScript community, as if millions of voices suddenly cried out in terror, and were suddenly silenced.
From the way my teacher explained in college, most bank transactions (payments and the like; debit purchases, etc) do go through old COBOL architecture and probably always will, considering its just way too expensive to change it. For example the Canadian government had to cancel a failed COBOL modernisation project after it greatly exceeded its budget and the project was scrapped
Not if each of those has a COBOL exchange (or twenty) on the backend as well.
Nice. I used the student license while in school and have been working on management since I started at my current job. They are setting up a license server now after the POC went so good. It does help that we were using IBM RAD before STS which was something insane like 5k/license/year so IntelliJ is nothing compared to that.
Nice welcome to 2003. 
I think his main concern is that most Java job and contract descriptions these days want some experience with current Javascript tools and libraries. He's concerned about his long-term employability. His front end experience is all SWT and Swing, and he wants to get up to date in that area. A year or so working on rich Javascript UIs couldn't hurt. He's also actually interested in learning that stuff, so that's a bonus.
Agreed regarding RAD - we use that as well. This is way cheaper (and better).
perhaps merge with https://github.com/akullpp/awesome-java which is in the side bar --------&gt;
Fair enough. Good luck to him!
Also when people talk about "enterprise java" on job ads they are talking about spring + hibernate 99.9% of the time. And since this is for his resume, that should be his pick.
&gt; And the biggest headache we had to deal with was that minor versions were not backward compatible. Play's version scheme is epoch.major.minor. 2.3.x, 2.4.x, and 2.5.x are all major releases. 
Spark http://sparkjava.com/ - A micro framework for creating web applications in Java 8 with minimal effort
&gt; I'm forced to use a crappy Lennovo T440 as my work machine. Ha I still use a T420s as my *only* machine. Works like a champ though :)
I've done a fair share of interviewing, hiring, and managing developers over the years, and I can't imagine familiarity with a particular IDE giving any significant edge to one candidate over another. Tools change. It's knowing the concepts that matters.
it's already fork of awesome-java, plus new links and info (licences and github stars) and new structure 
tl/dr; When starting a Java Application from IntelliJ using Gradle integration, and killing the application, some obscure finalizers are not called (jvm is killed). In Maven, shutdown has a different API that is more graceful. My opinion: Without a doubt both Maven and Gradle have numerous bugs, and IDE integration is slightly better with Maven, but this one bug is probably not a good reason to choose one over the other.
I bought a subscription to their IDEs. I love JetBrains.
https://blogs.oracle.com/security/entry/april_2016_critical_patch_update
Every time I've tried I've never been able to be productive in intellij. I have no idea why but the application just makes zero sense to me. I hate the file system over project layout. I hate the scm integration. I'd be happy to get on the bandwagon; I just can't make it work for me. I'm glad you love it. :)
Isn't the filesystem layout the same as Eclipse? As far as scm integration - it's done through a plugin so you don't have to have it. I do everything with git on the command line except resolve merge conflicts.
I bet you're great craic at parties.
What parsers do you suggest? Should I install "urban dictionary" plugin?
Makes your own then, it'd be super easy
 "BAZ".equalsIgnoreCase("baz") returns true. I think gets you what you're looking for on ignoreCase(), but I'm not sure what use you're thinking of for toAnyCase().
I'm pretty sure that the new 2016.1 releases run under their own OpenJDK 1.8 now.
Boot! Ftw! 
Last year I bought a subscription to all the developer tools jetbrains offers and I haven't looked back since. It's especially useful when I want to do some db work, just grab DataGrip and I'm good to go (my new favorite JB tool)
Funny, they're willing to pay beaucoup bucks for IntelliJ but then won't spend a dime on your Lenovo laptops.
I didn't say it was. I said in this particular scenario Maven is a winner compared to Gradle. Need another weakness in Gradle compared to Maven? [Here you go](https://youtrack.jetbrains.com/issue/IDEA-154222). And it is not restricted just to these two properties: See [this](http://imgur.com/iry1l1b) for another current problem with Gradle/IDE integrations. But looks like IntelliJ guys have committed a fix for the stop problem to their repos so a fix shall be released soon.
Not sure why the downvotes, you make a very legitimate arguement. There really isn't anything of value from OPs post.
There isn't any point in yours either. /thread
I'm not the one who made a thread over it.
There wasnt any point on your comment so why say it? To get your opinion out? That's the point of the thread idiot
ok
Management was probably egged on by someone like the OP, someone looking for something to get excited about and when it comes there's no way he's not going to like it and convince himself there's no way he could possibly not use it. I like Intellij fine, I don't really see a difference between it and Eclipse except it costs money and requires more install time. I had been excited about moving, but then we moved and Intellij had as many if not more bugs than Eclipse, just different ones. Every person I've known like the OP in a professional setting has honestly made our workplace a living hell. A lot of times it's just change for the sake of change, leaving the entire team stressed out trying to keep up with things that don't make any improvements (or improve one thing but make another thing worse so they even out).
I'd say it's more about the right tool for the right job. Static typing for example doesn't work well for scripts and glue code, but it's fantastic for larger code bases or libraries. I really wish there were more in-between languages though - stuff that has *optional* static typing, which is IMO ideal for glue code and enabling abstractions that are reasonable but might not represent cleanly under most common type systems.
&gt; All the chained methods return a type. It is not important to the reader to see explicitly what this type is. The reader still understands the semantics. The problem with that argument is it's only true if your goal is to skim it and get a high level basic understanding of it. When there's something wrong with it, it becomes a big hassle because the stack trace just says "it happened somewhere on line 1" basically. When it's not a simple StringBuilder example, but involves several different kinds of objects, it can become a real nightmare. For someone who's actually having to dig into the code and figure out the exact details, it's far better to only do 1 operation per line. Stack traces tell you the operation that caused the problem, you're not looking at 3 operations wondering which it is. You can step through the code much better in debug mode - it's far clearer, if you've jumped between a whole bunch of method calls in one line you know what I mean. Breakpoints are also a whole lot easier to setup. And it's easier to dig into the specific method being called which is often important.
I have no idea what you'd expect these to do. Can you at least provide hypothetical code examples?
Just FYI this appears to be the closest I can find to what I think we need? http://activemq.apache.org/jms-bridge-with-remote-broker.html However seeing a "real" example with two servers and two sets of external IP addresses would be great. 
congratulations!!!
YOUTUBE. 
IntelliJ is way cheaper than RAD
Thank you!
&gt; ExitOnOutOfMemory Finally! Instead of `-XX:OnOutOfMemoryError='kill -9 %p'`.
So what? Just take the damn paycheck, stumble around the codebase a bit, then leave and say it's because you have no idea what you are doing and don't really care to know because ColdFusion sucks. It's their waste of money, not yours.
&gt; Which IDE is better suited for me learning java / what is your favorite and why? I prefer IntelliJ IDEA, but many people are more happy with Eclipse, or even NetBeans. Try each of them and choose the one you feel more comfortable with (but 2 major are Eclipse and IDEA, NetBeans seems to be marginal, AFAIK) &gt; i have a 2 week break and my buddy and i want to make a program together that is fun and challenging and will help us learn Take a look at coursera, they used to have some free Java courses. Also get some books: * Effective Java * Head first Java * Head first design patterns and more advanced * Java concurrency in practice by Doug Lea * Java generics and collections Book by Maurice Naftalin that is some required stuff to be an industry-qualified Java developer. Once you get through these - start with Spring / Hibernate and all the related bloody enterprise - that would be helpful in your career, if you'll decide to go in that direction As for 3-rd question, the main directions to explore are * UI (Swing, GWT) * Server-side HTTP-related stuff (Spring-like, REST frameworks, Servlets basics and so on, up to EJB and microservices) * Android - there are many differences, but it's hot, you can create games and there are plenty of tools to help you out with that. Good luck!
Board games can be a fun beginner project to work on. You'll learn a bit about logic/algorithms, state management, graphics/UI, and since the ruleset ("requirements") tends to be quite precise and limited in scope, you can clearly see your progress in getting the game to function. Pick something like Checkers or GO that has a small ruleset. Or maybe a Rogue-like; it's more open-ended but getting something simple working shouldn't take long. And keep it *simple*. Don't spend hours tweaking something to perfection when you still have major pieces of the game left to finish. As for IDE, since you're a student you'll probably be wanting free, and that means either Eclipse or NetBeans, either of which will be fine. 
&gt; Can anyone help or is it better to use something other than ActiveMQ? What about RabbitMQ ?
&gt; but I'm also trapped at a school that thinks unstable, poorly configured Eclipse and Visible Analyst will produce competitive CS grads. If you think the quality of your CS program is measured by the computers, programming language, IDEs, or latest nosql data store then your CS program isn't teaching you CS.
Perhaps something has changed. A couple of years ago I'd got a whole bunch of problems with OpenJDK, and somebody from their support suggested to use Oracle. Good to know, thanks!
IDEA CE is free and opensource, just to mention.
You can use a different JDK/JRE for IntelliJ than the one you compile and run a project with. You can even have a different JDK/JRE for every project. It's under "project structure"
The #1 thing to spend a lot of time on is learning all the keyboard shortcuts (for indenting code, turning lines into comments, etc). Once you have that down, it's *much* more efficient.
While I'm 100% with your statement, I keep thinking about that JDeveloper/ADF course they have as a "database" course at my school. They're basically just teaching a framework but label it as an advanced database course. But even there, my example isn't totally accurate because the issue isn't really with the software but the curriculum itself...
We've come full circle
Actually, this question should go in /r/javahelp (as is outlined in the sidebar). + IDE: [Eclipse](http://eclipse.org), [IntelliJ Community Edition](https://www.jetbrains.com/idea/), or [Netbeans](http://netbeans.org) all are free, so, try all for some time and use the one you like best (IMO IntelliJ is the best, followed by Eclipse) + Programming ideas: [Programming Challenges](https://www.reddit.com/r/learnprogramming/wiki/faq#wiki_where_can_i_find_practice_exercises_and_project_ideas.3F) from the /r/learnprogramming wiki or /r/programmingprompts + Java capabilities: Java is a general purpose language that can do basically everything. Where Java falls short due to it running in a Virtual Machine is low level system tasks, drivers, or anything that interacts directly on hardware level. Some great, free courses to boost your learning: * **University of Helsinki MOOC** [**Object Oriented Programming with Java**](http://mooc.fi/english.html) - text based with exercises that need be completed and submitted before being able to proceed. (Uses Netbeans as IDE) * **Java for Complete Beginners** by John Purcell (probably the best and easiest entry into Java) - video based (Uses Eclipse as IDE) - the three links below lead to the same course hosted on different servers. I would use the Udemy link because it has an active community where you can ask questions and get answers. * [CaveOfProgramming link](http://courses.caveofprogramming.com/course/java-for-complete-beginners/) - John Purcell's site * [Udemy Link](https://www.udemy.com/java-tutorial) * [YouTube Series](https://www.youtube.com/playlist?list=PL9DF6E4B45C36D411) * **Derek Banas'** [**Java Youtube playlist**](https://www.youtube.com/playlist?list=PLE7E8B7F4856C9B19) with the accompanying site [Newthinktank](http://newthinktank.com) And don't forget to work with the [Oracle Java Documentation](http://www.oracle.com/technetwork/java/javase/documentation/index.html) as it is the go-to reference.
There is a project view in intellij as well, try alt gr+1. Granted, in some project types like static web, it's identical to a file system view 
I got promised that they want to change stacks soon. Ended up never happening and I had to continue writing PHP. But I knew this was a distinct possibility, so they didn't trick me either.
Jetbrains tools are free for students anyway.
Right now I'm working on a project that includes a number of maven based codebases, and one ant based codebase. Any guesses as to which causes All of the problems? The maven builds just work. They do the right thing every time, and when it doesn't work it's trivial to fix. ("mvn clean install -U" does the trick 99% of the time) The ant project is a mixture of ant and shell scripts. It only builds on Linux - which means that we all need to use VMs for building it. It requires dependencies to be committed to svn, and when that doesn't happen then the build fails. It's generally speaking just a nightmare to maintain. (And this is from one of the few people in the company who Does work on it this closely) and this has been the case on every ant project I've ever worked on, of which there have been quite a few.
Same here. The only confusing part to me was relearning shortcuts. I used Eclipse for 9 years and did everything via shortcut, but luckily IntelliJ has ctrl+shift+a to type in what you want to do. For example type "Type Hierarchy" and you can execute that command there and also see the shortcut. For those still using Eclipse, ctrl+3 does the same thing.
&gt; At the risk of being that guy, what's the opposition to learning another language? The problem is that if a company has to lie to get people in general it won't be a language you'd enjoy learning. I got bait 'n switched at a Coldfusion company (the bait and switch was not on CF, it was on me doing any development, they said it would be 10% of my time but it was closer to 99%) and trust me it's not something you want to use. I started looking for another job 1 month in.
You can use Eclipse shortcuts in IntelliJ.
So like, String.equalsIgnoreCase() which has existed since pretty much always?
[removed]
I totally agree. I use it every work day, and it's fine...but I don't see why it warrants this level of commentary. Maybe we should create a /r/IntelliJCircleJerk subreddit?
RAD can go ahead and **** and then *********
Two new JVM flags have been added: * ExitOnOutOfMemoryError * CrashOnOutOfMemoryError
Unfortunately. That is about the only thing missing. Yet, that lack is easy to counter by using any of the `toUpperCase()` or `toLowerCase()` methods in between.
I'll give it a shot. Thanks.
You can import your projects as modules within the same IntelliJ project, but you will still have PHP separately I guess, since it's a different program altogether. 
Should be called /r/IntelliJerk
I don't use the defaults. My point is that the defaults don't match any other software I've ever used, and I'm not sure why.
Other than the 75% of other applications that decided that CTRL+Y is redo...
Is there any way to have this deployed on a local server and not have to use this over the internet?
Yeah, that's right. But I'm curios what mnemonic is applicable here ... 
I would use Camel in between the two brokers to accomplish this. In fact I do this very, very frequently in integration projects I work on.
I'm not really a fan of this article. It doesn't really do a good job of explaining the problem and then just jumps into specific solutions immediately. Any beginner article on concurrency should introduce the concepts of optimistic and pessimistic concurrency and give examples where either strategy can be applied. If I was a beginner reading this article I feel like I'd come across with the impression that synchronization is the way to solve my problem, but in actual practice if we want our application to scale synchronization should really be a last resort.
&gt; Servlets are very straightforward with Spring Boot What kind of Servlet is this??...one from Tomcat v4 ? Can you access Spring beans from within a servlet with @autowired or @inject ? Can you define what requests are handled with @WebServlet ? Or do you have to jump through hoops to get this working.....and if you have to jump though hoops, then there is no point in using Servlets with Spring boot. QED. 
Version 0.3 was released just now. It brings scala.js compatibility - so KS compiler can be used on a web page, compiled as a JavaScript library. Example page coming soon. Aside from that, lots of minor fixes, introduction of `process: ` over user datatypes and `process: rol/ror` for circular shift transformations.
Is it talking about TomEE or Tomcat? Those are two different things. I don't see the word "TomEE" in the article but it clearly says Java EE.
Since Tomcat is not a full JavaEE container comply this tells me how many projects are still using all JavaEE technologies, looks like most of the work is now focused on JSP and Spring MVC.
As a relative novice with Java, especially with concurrency, could you perhaps explain why this should be used as a last resort when scaling an application?
There is a proposal to get off of the 1.X scheme where 1.9 would actually be 9.0. http://openjdk.java.net/jeps/223
Not a rewrite. But cut another branch off (lets say 1.9.x) and remove backward compatibility related changes. As recently, I am learning java8 new features etc, you can see, how much effort java team gone through, so that your jdk1.2.x code still compiles with compiler of 1.8. I am kind of assuming, because of requirement of backward compatibility, * Their compiler code will huge and pain to maintain * Developers are being lazy to force themselves to think in Generics way or use latest coding conventions etc since 1.5. So theoretically, if jdk 2.x.y release is available, as developer I can decide to use that release and make sure, my developers are coding using latest libraries etc. (Instead of forcing extra code-review cycles/tools). Now if jdk 2.x is available, then applications around java, like tomcat/spring framework can evolve easily and more lean. 
Sorry to disappoint you, but TomEE's market share is smaller than statistical error (from my own different statistics, their results are more or less the same as Plumbr's)
It's just naming. Internally, it's still 1.8.x or 1.9.y (Think of branding or easy to market practices)
It's a different way to obtain the numbers, but this one puts TomEE at the 4th place: http://arjan-tijms.omnifaces.org/2015/03/the-most-popular-java-ee-servers-in.html Putting all Tomcats together would put them at the second place. With different sources numbers can be different, but often we see largely the same ranking. When looking at both Java EE and Servlet containers, it's almost always as the following (each bucket is unordered, and the real order varies per survey) * Tomcat, JBoss, GlassFish * TomEE, WebLogic, WebSphere * Jetty * Geronimo, Resin, JOnAS, ... 
&gt; Nope up there it says Tomcat not TomEE, as you can see jetty is also there. The fact is no one uses Java EE anymore, thats why even Oracle think to discontinue it ... and TomEE market share is so so tiny so it is in the "Others" section
&gt; No one forces you to chain methods on a single line. People tend to put each Stream method call on a new line, for instance: That's an interesting point, and example. &gt; And I really doubt that you've lost a lot of time to this problem :) Well I doubt you've spend time fixing bugs in other people's code then. :-P I wasted a huge amount of time at my last job with people who liked to write code "cleanly" as they put it, cramming as much into one line as possible. Even a long string of getters is annoying as the debugger insists on going into each one, but if you need to check the return value it's a real pain. Putting them on separate lines can help, but it's still hard to get the debugger to show you the return value in the middle, and a lot of times difficult to get it to debug properly on a line in the middle of the statement. Like in your example above, imagine you need to check the value of the 2nd .map() call and compare it to the result of the .distinct() call. It's a real pain as written, whereas if each line returned it's result into it's own var it would be fairly easy. I actually spent quite a bit of time dealing with it at my last job.
[There are](https://wiki.openjdk.java.net/display/Adoption/JDK+9+Outreach#JDK9Outreach-Removed) incompatible public API changes ;)
Probably Ctrl+D - Delete that line! Ctrl + Y - "Y did I do that?"
Very interesting, thanks! :)
\1. It is not a solution. You still missing one level in the hierarchy. In Eclipse I can have multiple workspaces with multiple projects in each all in the same window. So it is 3 levels: window/workspace/project. In Idea there are only projects and modules: window=project/module. There are cases for which Idea sucks. There is nothing wrong with admitting it: I am happy the tool works for you, I am not trying to convince you to switch. If it works for you, stay with it and be happy. But don't quietly downvote anybody for whom Idea is not a right tool.
I guess you are replying to me. I said that I'll bring it up just for fun: something so small and trivial that it should not be even a thing in 2016. Note that nobody dared to defend Idea on this count. Just a few quiet downvotes. There are other problems with Idea. But I won't spend time listing them. What's the point, if all the response one gets from Idea funboys is quiet downvotes?
The end of the video recommends to avoid Gradle until this minor inconvenience was fixed. That's ridiculous. And nobody needs any weakness of one over the other. A comparison is here: http://gradle.org/maven_vs_gradle/
There isn't a better product in my opinion. I guess I'm a fanboy. 
I moved back. First there were 5 years of Java+Scala, then 1.5 years for pure Scala and now I am back to pure Java (well, we do have a few Groovy scripts...) One big change is that I had to type a lot more. Another was a rudimentary type system, which leads to lots of `instanceof` checks and unsafe casts. But in general the transition back was not too bad. One advantage was that I could stop checking some library release/update status. I'd say it was a boring to transition. There is not much "cool" stuff happening in Java world. But hey, I still have free time, and I learned Rust in it :) And I ~~(obviously)~~ did not unsubscribe /r/scala Not sure if my random thoughts are of any help to you. It is still your call at the end of the day. Edit: noticed that I am replying in /r/java :)
May I fix it for you? Instead of "in my opinion" you should've put "for me". People have different needs and tastes. It is the best product for you - great. It does not mean it is the best product for everyone.
I'm not a Scala developer, but I do know that one of the core ideas behind Scala was to improve the Java developer experience. Specifically to remove verbosity, remove the Strict adherence to cumbersome OO design, and other all around improvements. So I would say that switching from Scala would be similar to switching to an old (some would say dated) developer experience as a whole. I can tell you that I have been writing a lot of Go in the past year and a half or so, and it's pretty horrible to write Java afterwards. This is really because Go has made me very resistant to the entire OO model. Though the core authors of Go weren't Java developers, the language improves upon the approach to development as a whole. In addition to the language itself, the modern standards, practices and tools utilized within the Go ecosystem make it very compelling. But i'm guessing that this isn't as much of an issue with Scala since a lot of the tooling is shared with Java. But it's definitely a main reason why it pains me to write Java code compared to Go. Despite all of that, I would stomach using Java to develop cool products, at a cool company with a modern tech culture (whatever that means to you). To me, focusing on doing cool new things is the most important thing. The language is really just another tool to do that. Hope that helps
Isn't that the case with most things related to programming though? If there's one thing I've learned it's that most of the time, there isn't a magic bullet. Many roads lead to the same destination, no?
&gt; The ant project is a mixture of ant and shell scripts. This sounds like it's your problem, once you put different kinds of scripts in there it all get fubar'd. On new projects, I set things up in the IDE, then use the IDE to export the project to an Ant file. It's worked nearly flawlessly, the one drawback is when people change something in the IDE config and don't remember or don't know to export to Ant - but it's quick to fix. In contrast, for a Maven project, you have to: - Have each developer remember to do a Maven update when the project config changes - Setup a local maven server - Have each developer install extra maven stuff on their machine - Deal with Maven bugs in the IDE (run into them in both Intellij and Eclipse) - Setup another separate server for encrypting their network password - Each time the developer changes their corporate password (every few months according to company policy) they have to reencrypt their password and update the config file - If someone puts in custom compile tasks, the time wasted by developers running them goes WAY up compared to the IDE, because the IDE can do a good job at incrementally compiling Usually at this point, you'll (whoever is pushing maven) will start making personal attacks and excuses. But I don't have to do any of this if I keep the jar files in the repo where they belong, and just export the IDE config to an ant file (I don't really care if it's ant or maven as long as no one is customizing build scripts separately from the built in IDE config). It's way easier, way more stable, and a lot less pointless hassling around.
No :( still waiting. It's okay though. He probably hasn't check his inbox or something 
instanceof = code smell. Not saying it's not correct, but if you do it a lot, I'm reaaaaalllly curious as to why.
If by "internally" you mean as defined internally in the implementation, then no, it's really not. Internally, it's 9 now. If by "internally" you mean it's still basically 1.x, then yeah, they are not really breaking backwards compatibility. 
And just wait till you get to those programs using `sun.*` packages...
Are you saying they're improperly/not using generics?
To be honest that was not the original title of the article (as can be seen from the URL). I got a suggestion from a commenter and then changed it
XBOX leaped to a massive 360 version. 
My experience with switching from Scala back to Java is that you can simulate case classes with interfaces and sub-classes, but in order to simulate basic pattern-matching (i.e. on the sub-classes) you either have to use the (clunky) visitor pattern, or instanceof.
Just another non-realistic report that mislead users to believe that represents the market share of application servers and servlet containers.
Maven 9000 - Gradle 0 ;-)
I do not understand why it is forced on you. Couldn't every dev just choose the tool they want? I've been working on projects where every dev used what he wanted and we haven't run into any problems. 
I believe backward compatibility is their main priority. Check [this video](https://youtu.be/2y5Pv4yN0b0) for in depth language design trade-offs discussion.
Glad to see JBoss/Wildfly hitting record highs. I hope that translates to more users using the platform.
Yes. A lot of weird stuff happens because backwards compatibility.
The people that I know have preferred moving back. If their team knew actual FP and stuff, maybe not as much, but since Scala can use Java classes you're likely suffering a lot of the side effect problem. Meaning that at least in Java it's explicit (if you read the code). 
For analysis locally I use https://github.com/chewiebug/GCViewer 
Former Scala programmer here. Spring is a pleasure to program in. Much nicer than Play and waaaay better documented. Reactive libraries are showing up in Java and are not bad with lamdas and streams. Java 8 was a huge advancement. I'm currently looking at Kotlin. 
Played with Scala out of curiosity for a few personal projects. Didn't see the appeal to it. It's fine I guess, more of a ... meh. Doesn't offer anything more that Java, just a bit differently.
&gt; In addition to the language itself, the modern standards, practices and tools utilized within the Go ecosystem make it very compelling Would love to hear elaboration here.
JVisualVM provides some features like that, if you've got Java you've already got it. 
I've used jprofiler to do monitor method invocations. You can get a trial license if you'd like. Edit: jprofiler not jmeter
This! It means your class should overwrite the method's implementation OR you should have used an interface instead. 
Java 9's release will be a gem shattering experience if they assume `x.y` format, gems such as: String s; int v; checkJavaVersion((v = ((s = System.getProperty("java.version")).charAt(0) | s.charAt(2) &lt;&lt; 6) - '0') &amp; 017, v + '0' &gt;&gt; 6 &amp; 017); EDIT: To clarify if this is confusing, '0' through '9' are `0x30` to `0x39`. So lets say with the latest JDK release the version string is `1.8`, this results in `0x31` and `0x38`. First the system property is obtained and assigned to `s`. The major version is ORed with a 6 shifted to the left major version. Since `0x3n` is `0b11nnnn` this is so the values do not collide. After that '0' is subtracted from the value so that the `0b110000` is removed from the top. This is then stored into the variable `v`. Then the result is AND with `017` or `0xF` which returns the lower number. The result would be in range of `0` to `9`, this is then passed as the first argument of `checkJavaVersion`. The `+ '0'` is not actually needed at all, but I suppose it looked cool in practice and provides a unique balance to the code. The lowest 6 bits are shifted away and then the value is AND with `017` or `0xF` which the result is then passed as the second argument of `checkJavaVersion`. Then the method call is made. 
&gt; I bet you're great craic at parties. I'm so sorry, geez, why would I come to these forums to learn something. Let me fall in line *2... 4.... 6.... 8.... WHO DO WE APPRECIATE, INTELLIJ! INTELLIJ!*
Go to your safe zone you delicate little flower. It will all blow over soon.
&gt; Couldn't every dev just choose the tool they want? That's not really how it works, it's mostly an all-or-nothing thing for the project.
Just normalize to uppercase or lowercase and if it matches then pass the original string to whatever you want to do with it. Strings are immutable so when you call toLowerCase() or toUpperCase() you're getting a copy back and not modifying the original.
thanks for sharing link. 
Thanks for the reply. Is Camel easy to install and set-up? I assume it is an additional package to install alongside ActiveMQ? 
JVisualVM or lately my favourite Java Mission Control with Flight Recorder. 
Hell no. 
[jMeter](http://jmeter.apache.org/) is a load testing tool. Also it's free and doesn't require a license. How did you manage to track method invocations with it?
Been there, done that.... I have no interest in ever doing C# again
No way. I have worked some in C#/.NET and it was fine. As languages, C# and Java are similar and there's not much to choose between them in the grand scheme of things. Where Java clearly wins, and why I use it, is in (a) variety of third party libraries; and (b) breadth of supported platforms. For (a) I like knowing that for whatever task I need (e.g. web framework, database connection pool, medical image processing library), no matter how specialized, there are going to be several good open source choices available. For (b), I need my server components to run on Linux, and my desktop components to run on Windows and Mac. And not as experiments, but as first class platforms. I know that there is a port of the CLR for Linux, but it is just too rarely used to risk my business on it. I want all my small business's foundational technologies to be rock solid, mature, widely used, and easy to hire for. My business's product has enough complexity and interesting challenges without making life hard on ourselves by being one of the pioneers for CLR on non-Windows. Edit: Fixed typo
Uhm.. Why? 
No. I do some C# when working on the Windows port of our tool. It reminds me too much of C++ which is awful and is a perfect example of the situation where adding features actually removes usability. Visual Studio is years behind NetBeans/IntelliJ for basic stuff. The libraries are remarkably unintuitive and worse of all they are incompatible even when you stay inside the realms of the Windows ecosystem e.g. UWP is totally incompatible to desktop, phone etc. I won't even get into Xamarin and the related incompatibilities. Comparing this to WORA in Java the contrast is huge!
I liked Play! more when it didn't have that stupid gui-frontend-deployer-container thing. (It's name escapes me at the moment..)
Interesting that you mention java web applications, we're actually working on one now for a school project. Any tips on that front perhaps? We were supposed to do this next year instead of now, so we've been pretty much figuring everything out from scratch.
You can't be an expert in any ecosystem, as much as people sell themselves as such. When people say they are an expert in language X, usually they leave out that they only know a subset of the libraries, only use one specific IDE/editors available and target a subset of OSes supported by the language. Since this is /r/java, I doubt any Java expert will be an expert in Awt, Swing, JavaFX (both as user, control writer and IDE tooling integration), JEE, Spring, J2ME, Embedded, Android, GC, JIT, JDKs from Oracle, IBM, Altego, Aicas, MicroEJ.... What matters is to have a good enough knowledge of the areas that matter for the customer and most important have a good understanding of product and market areas. Many customers give more value to the domain knowledge than programming languages, as long as you can speak at the same level as their internal developers. Also, you don't become an expert overnight. I have been doing this for a few decades now and know both ecosystems since the early days.
After using Scala for a longer time, many things in Java are annoying. For example, if you want to reduce mutability, you have to write a lot of builders and the like. But most of the time Scala's named params with default values or the the `copy` method would be sufficient. On the other side, there are some things in Scala that I really dislike: operator methods, scalaz, some usages of implicit conversions. Maybe Kotlin is a good alternative, but personally I don't want to start new projects in Java! I would prefer Scala or Kotlin.
It is not hard to write such a tool yourself actually. I have a tiny project that does that and exposes a simple text-based API to export the data: https://github.com/voronaam/berta Not saying you should use it as is - it is not production grade code. But look at the code - it is fairly trivial.
It probably comes down a lot to personal experience. For example: &gt; - Have each developer remember to do a Maven update when the project config changes What kind of Maven update? I've never had to do more than get IntelliJ to re-import the project. &gt; - Setup a local maven server This is not needed, but if you want to do so - it's no bad idea - then it's trivial to install Archiva or similar. &gt; - Have each developer install extra maven stuff on their machine What extra Maven stuff? The only thing I've ever needed was Java and Maven itself. &gt; - Deal with Maven bugs in the IDE (run into them in both Intellij and Eclipse) This is always the case no matter the tools. Maven in IntelliJ 15 has been pretty bug free for me so far though &gt; - Setup another separate server for encrypting their network password Why? I've never once needed to do this &gt; - Each time the developer changes their corporate password (every few months according to company policy) they have to reencrypt their password and update the config file I've never once needed to do this &gt; - If someone puts in custom compile tasks, the time wasted by developers running them goes WAY up compared to the IDE, because the IDE can do a good job at incrementally compiling If it's something the IDE can easily do then odds are Maven can easily do it out of the box. If it's something you need a plugin for Maven to do then odds are either the IDE can't do it, or else the IDE needs plugins too, and in the case of plugins for the IDE you need to have every developer install them manually. Maven plugins are defined in the pom file and every time anyone checks out the code to build it then all of the plugins are downloaded and are already correctly configured.
How about looking at the generated class major.minor version and use a lookup table? We're already at 52.0 for Java 8, but apparently that doesn't sound marketing-sexy enough.
If Kotlin didn't exist, yes. I'm not a particularly dogmatic person, so all things being equal between Java and C#, I'd pick the syntax and semantics of C# over Java, but not over Kotlin or Scala or maybe even Ceylon.
Why, in the first place? I mean, couldn't the very same question be asked for every other language? Would you move to C/C++/Python/Go/PHP... given blahblahblah?
Edit: Changed because I thought I was replying to a different comment on a different topic. Everywhere I've worked everyone uses the same IDE. I've never worked everyone is expected to use the same IDE. 
Can you explain a little more about "data captured during tests"? http request examples? How are you importing these into documentation?
I've worked 3 places and every place did all of this, and the boss read off the same maven script of what to say about it each place. I don't believe you. Maven makes things that were simpler more complicated and more work.
Big typed functional programming fan here, but have recently returned to Java from Scala. In the real world Scala codebases worked on by several people often end up being a train wreck of different coding styles and practices. Some write their Scala like "Java ++" and some write it like "Haskell Lite". In trying to support every conceivable language feature it's much more difficult to keep all the concepts in mind and understand other people's code and reasoning. Going back to Java 8 I find it has just enough functional programming capability so that I don't get incredibly frustrated trying to do something basic, but the language is simple enough that pragmatically getting stuff done and refactoring and generally making your code nice and readable is fast. I feel more productive in Java 8 than I have in any other language (my domain is services and big data btw). Also, the perfomance of Scala code is usually noticably slower (I'd take a random stab in the dark of about 2x) because it's taking functional code and trying to translate it into a virtual machine designed very much for OO. Haskell's compiler, for example, is very good at making this efficient, but Scala's compiler is bound by Java/JVM bytecode interop and there's only so much it can do. TL;DR: I like Scala academically and for fun but for real world applications going back to Java has been a massive relief.
Your list doesn't include installing the IDE, but if I leave that out of mine as well you know what I did before Maven? - Ensure Java is installed - Check out the code That's it. No maven install, no maven updates, no running extra maven tasks. At one of the places like I said they had different maven targets, so simply compiling took way longer than with just the IDE, what was a few seconds before turned into a few minutes with maven. And like I said, I've worked in 3 corporate environments with maven, for all of them the list was a lot longer. Maven takes something that was simple before and makes it far more complicated without adding benefit. 
TL;DR: follow the example project from swagger2markup (https://github.com/Swagger2Markup/spring-swagger2markup-demo) Start with the springfox swagger annotations: https://github.com/springfox/springfox Then during integration testing, use Spring restdocs: http://projects.spring.io/spring-restdocs/ Our integration tests are just JUnit tests that start the app using @WebIntegrationTest, and use MockMVC to invoke controller methods. Basically you add a JUnit rule to your tests, and some extra assertions to your MockMVC object to capture the HTTP request and response from each test. These are output to the build directory. Swagger2Markup then marries the two together, providing the description of each endpoint, along with the example captured during the integration test. Finally AsciiDoctor takes all the markup and spits out a single page HTML document, which you can host externally, or even include it right in your JAR, and serve it from your web app. Once we got it all setup, it's been very nice to have tested documentation examples output with each build. I also like copying the examples from the static docs directly into swagger-ui to do some ad-hoc testing. 
wut ? why would anyone do that ?
No i would rather stick pins in my eyes, sell my children to satan and vote for hilary clinton
As someone who did C# for 7 years and now just starting on a Java project I totally agree. C# is a better language, less ceremony, some nice constructs that feel sloppy in Java, and linq iterator support is so much cleaner than Java 8 streams. When I realized I had to jump through hoops to make a Set a stream to do simple filter or map functions I felt like it was half baked (although I'm new and trying to find cleaner ways). With that being said the ecosystem of tools and libraries is AMAZING. C# has tons of paid for libraries that 3rd party vendors build, Java seemed to embrace the open source culture more. Also, gradle blows the pants off msbuild.
So, if you'd bother to read my response: &gt; Not saying it's not correct, but I use instanceof. It's a great operator! Using it when typing things creates safety (and a point to spot a failure). Using it in a factory makes a lot of sense. But, doing it a whole lot in your code is just... well, wrong/unmaintainable/bug-ridden/etc. The times when I see it and shake my head usually involve a "base class" (or several of them chained together) where someone needed something to happen "but only on XYZ class". That's the stuff that gets littered across codebases by junior devleopers which is... not acceptable (or maintainable, which is really the reason why it's not acceptable).
I think the desktop lost the desktop war :)
C# itself is a slightly nicer language, but the wider .NET ecosystem is pretty dismal. In the Java world, much if not most of the community doesn't care about about Oracle beyond the JDK itself. In the .NET world, ***everything*** revolves around Microsoft. They've sucked all the oxygen out of the room for too long. I'm optimistic that recent changes in strategy and attitudes can alter the landscape long-term. But really, that ecosystem is almost 15 years behind. They're moving fast, and a year from now they might be only 10 or so years behind. But still... at *some* point a community outside of Microsoft will have to materialize out of thin air.
In the .Net world, people more often than not use the libraries, tools and frameworks as Microsoft expects. In the Java world, well, community typically makes a better option whenever something is not right. We choose Joda over java.util.Date or Calendar, Log4J over java.util.Log, Spring over J2EE (at least until J2EE became more Spring like), and so on
Thankfully smartphones and tablets are winning it back.
Written in Java?
Without knowing a little about your project and stack and what you're having trouble with, all I can offer is generalities that you can just as easily Google. But if you'll PM me with specifics I'll be glad to answer as best I can. 
Interesting. I'd love to have a breakdown of which parts are done in what language, if you have that handy (can't find anything in JetBrains github repo).
Kotlin gives me almost all the Scala I really miss in Java 8. Once in a while I'll pine for higher-kinded types, but the power/complexity trade-off feels about right in Kotlin.
Because I meant jprofiler.
The Resharper backend is written in C# and the frontend is written in Kotlin/Java. EDIT: &gt; As such, the backend continues to be ReSharper written in C# running on .NET or Mono, and the frontend is written in Kotlin, talking to the IntelliJ Platform’s APIs.
Its always the most unsold aspect of Java and its libraries, they really are exceptionally well documented. If you spend any time with the latest hotness in Javascript or Scala you soon appreciate that documentation in Java. I would say that the quality of the documentation is one of the reasons it is still such a widely used language and helped it become popular to begin with.
I would, because most of the work in my area is .NET and I'm not sure where to find a java shop after I move on from my current job. That being said I don't plan on moving soon.
Some things are more obvious in C#. C#: var pList = new List&lt;string&gt; {"Hello", "World"} string joined = pList.join(); //"Hello word" Java ArrayList&lt;String&gt; pList = new Arrays.asList(new String[] {"Hello", "World"}); String joined = pList.stream.collect(Collectors.joined(" ")); //Hello world C# List&lt;Employee&gt; Employees = new List&lt;Employee&gt;() { { new Employee() { Id = 1, Nombre = "Mary" } }, { new Employee() { Id = 2, Nombre = "Bob" } } }; Employees.OrderBy(x =&gt; x.Nombre); Java: ArrayList&lt;Employee&gt; pEmployees = new ArrayList&lt;&gt;(); pEmployees.add(new Employee(1, "Mary")); pEmployees.add(new Employee(2, "Bob")); pEmployees.stream().sorted((x, y) -&gt; x.getName().compareTo(y.getName())); 
No idea why you are getting down voted, spark is a pretty fantastic library for putting together an api server. 
I don't recall spending one penny to develop C# applications. Visual Studio is free, .Net is free, SQL Server Express is free. A debugger? Free. A decompiler? Comes with .Net. Sorry there is nothing that you need that costs money. There are programs that are nice to have that aren't free but they are certainly optional. The rest of your argument maybe right but it certainly doesn't cost money to develop. 
&gt; ... is a perfect example of the situation where adding features actually removes usability. Indeed, I'm currently collaborating with large remote team which operates on different timezone. It's such a pain in the ass to maintain code standard / quality across the teams. The cleverness in C# code is really annoying sometimes.
Told you yesterday to check your spelling, it is horrible. **seuentail execuation** - should be **sequential execution** Really, **your tutorials are not ready for publishing**, **STOP IT** or face a permaban.
Which majority of its apps written in Java :)
This is common knowledge for any non-junior Java developer who is competent. And I'm not sure I'd blame Java for doing anything crazy, because the Javadoc for HashMap and HashSet specifically mention these requirements.
I actually like static typing for glue code. You have API-A and you want to transform into APIB. With static typing, it's tedious but you're almost positive it's going to work. With dynamic typing, you might get it right the first time, but then have an ongoing worry that something might change and break it in a non-obvious way.
Not the ones that are portable across mobile OSes. There C++, C# and JavaScript rule. Apparently Oracle doesn't care that Java lost their WORA story in mobile OSes and the only answer is that stupid framework to package ADF applications.
I'm not sure why you needed to consult a "designer of the Java language" for this. Nitpicking, HashSet iteration order is entirely deterministic given the environment. It's just that you should never assume it to be so because it is not guaranteed and as you experienced, is allowed to vary by environment. There is nothing in there that decides it should shuffle itself randomly.
&gt; I know that there is a port of the CLR for Linux, but it is just too rarely used to risk my business on it. Microsoft's next release of .NET is officially cross platform and open source. 
We don't run Windows in production. Period.
I have, because I could not find a job I wanted to do in Scala, so I found a job in Java. The syntax is annoying, but at the end of the day it's all the same stuff. Reading code is what I hate the most, as there is so much language fluff I need to skip past to get to the actual algo... but meh. The language you code in doesn't fundamentally change if you like a job or not. So many other things are what matter, even if Java is not what I pick for personal projects.
Does that include Windows CE and Windows 3.1?
It was entirely non-obvious that the ordering mattered.
It turned out to depend on the ordering, but this was an error in and of itself, since the ordering should not have mattered according to the specification.
If you know how a hashmap or hashset works (which is a general computer science subject), then it would seem more obvious.
Sure. I just mentioned it because I've seen lots of terrible solutions for how to deal with the fact that HashSet is unordered. Most of these come about because people are simply unaware that the collections framework already contains Set implementations that are ordered.
That's exactly what I mean ;) Time goes by, MS still at alpha...
Yep it's their strategy to release their basic offering so that people start deploying apps in azure. 
Agreed, although Java could produce good hashing functions for arbitrary objects. Project Lombok generates Equals and HashCode methods on demand and in most cases they do exactly the correct thing: https://projectlombok.org/features/EqualsAndHashCode.html
Intellij will perform a million times better when you run it from a SSD.
I was considering C# for a time since it can be run on Linux now, but after Kotlin hit 1.0 and I started using it, I haven't looked back. There is cooler stuff happening in the Java community anyway. VERTX + Kotlin FTW.
&gt; Java 5 added generics Really? I thought it just added syntax sugar resembling generics, and at runtime you just deal with `Object` again?
TBH, I prefer writing mobile apps in its native API. Maintaining xamarin apps, especially after os upgrade, is a nightmare in its own. Not including the cost of finding and maintaining developers who understand both xamarin quirkiness and the native API quirkiness combined. 
Your first example does not even compile. 1. The first line does not end with a semicolon `;`. 2. `string` has no instance method named `join`. 3. `string` has a static method named `Join`: `string.Join(" ", pList)` Your second example does not compile either: 1. Too many braces in the first line. 2. No semicolon at the end of the line.
Kudos on going against the trend of no in the answers ;-) I do a lot of C#, Objective-C, C and some JavaScript etc. as part of my current job (in a single project) but I still answered no. I agree with your point, we should learn everything and try to be pluralists, but we should still have a strong preference and bias otherwise our specialization becomes too diverse. E.g. don't fear touching C#, learning it and working with it. Don't fear doing mobile if you are an enterprise developer. But if you keep bouncing around you lose some focus.
I just know that's the way they've done it, and as long as they use something decent (eclipse, intellij, etc) I don't feel that one is vastly superior to another so I don't have motivation to argue with it. 
Lombok as mentioned, or the Apache Commons tools http://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/HashCodeBuilder.html
This is a really shitty bug when you have it. I've had it, yet one more reason I am a fan of immutable objects.
Me too, but I also value portability. Java is only a thing in Android not on iOS, Windows Phone or Windows Store. And let's not forget Android Java isn't proper Java, rather a fork that supports some parts of it.
My theory is that they're saving it for when they actually delete all the deprecated APIs.
I moved from Netbeans. IntelliJ does quite a few things better but I miss opening multiple projects with ease. The maven window does not compare.
Well yes it is syntactic sugar for base types, however the class file includes all of the generic type signatures. The type signatures are used by the Java compiler along with classes in `java.lang.reflect`. If you were to remove reflection like as in Java ME, you do not need any of the signatures at run-time.
A few have commented on this but I'm not seeing the issue. I can add projects with the Maven Projects window and they appear in the Project window. alt + 1 will show/hide the project window. It works fine for me.
The window is clunky to me. I just prefer the Netbeans style. That being said, I still use IntelliJ the majority of the time.
Enumerations are only good for the simplest type of case classes. I've been using [Immutables](http://immutables.github.io/) to generate immutable value classes, but it's still short of what I really need.
&gt; a version of BASIC and can be customized with Java http://i.imgur.com/TnQRX6v.gif
How is: window/workspace/project different from: window/project/module Modules are just directories... Projects are just Eclipse workspaces with a different name...
hashset documentation does not say the order is random . It just does not give any guarantees. Each implementation of hashset can have its own order. Example : LinkedHashSet returns data in inserstion order
probably just because Y precedes Z.
seems like you just enjoy being contrarian. you rebel!
*DISASTROUS*!! void foo(List&lt;String&gt; list) { var newList = list.stream().map(s -&gt; "Hello " + s); System.out.println(newList); } s/newList/stream Fixed. Next problem.
Don't mistake your observed correlation between unmaintainable/etc code with `instanceof` usage. There is no causal connection.
This is just some random guy who doesn't even put his name on it. Plus he doesn't make any convincing arguments, this is fear mongering. The java designers I have much more trust in than random dude on the internet.
Same with arrays: int array[] = new int[0]; array[0] = 1; // DISASTROUS effect here! Those horrible horrible arrays
&gt; The .net full framework **will always get more features, support**, and stability while remains Windows only. Citation needed.
&gt;n the .Net world, people more often than not use the libraries, tools and frameworks as Microsoft expects. In the .NET world, people use JSON.NET over the default JSON serializer. People use Autofact or Ninject over Unity. People use xUnit.net over MSTest. Anyway, a lack of serious knowledge of .NET in /r/java is to be expected.
I take it you don't have a lot of Java experience. For a fairer comparison to your C# examples: List&lt;String&gt; pList = new Arrays.asList(new String[] {"Hello", "World"}); String joined = pList.stream.collect(Collectors.joined(" ")); //Hello world should be List&lt;String&gt; plist = Arrays.asList("Hello", "World"); String joined = String.join(" ", plist); // "Hello World" and the second example should be List&lt;Employee&gt; pEmployees = Arrays.asList(new Employee(1, "Mary"), new Employee(2, "Bob")); pEmployees.sort(Comparator.comparing(Employee::getName));
What a god damn shit example.
Just for giggles, let's try explicit typing: void foo(List&lt;String&gt; list) { Stream newList = list.stream().map(s -&gt; "Hello " + s); System.out.println(newList); } Huh, I just got the same bug with the same lack of compiler warning. Maybe the title should be ## Allowing `System.out.println` to accept `object` as a parameter can be disastrous.
A bit, I admit :) Should've ignored this thread...
&gt; Enumerations are only good for the simplest type of case classes. I've been using Immutables to generate immutable value classes, but it's still short of what I really need. Yup for sure, that's why I mentioned the other two solutions. But yes, Immutables is a good one too.
"activator", i think
Problems I have with this. * Author is relying on toString. I mean. Come on. How often in your code do you ACTUALLY rely on toString and the formatting of toString in order to get correct behavior? toString is one of those things that should ONLY be used for debugging information, never for logic and flow control. If you have a major bug due to toString, you have some pretty terrible code. * Authors example includes an example where java snuck in type inference (without disaster!). Lambdas do type inference for the parameters and I've seen pretty much nobody complain about that (even though all of these "problems" exist there). * This is simply a contrived example. Very rarely are you relying on Object methods in order to do things, which is about the only place where the compiler won't blow up in your face. In every other case, you are going to get exceptions because methods don't exist or things don't convert properly. * The author doesn't appear to realize that there are actually a ton of places where type inference can be a boon to refactoring and maintenance. Renaming classes, moving packages, even things like changing return parameter types (TreeMap to Map to ConcurrentHashMap to ImmutableMap). I personally subscribe strongly the Rusts and C++'s [AAA thinking](https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/) (almost always auto).
Using an `interface` it would not work and the compiler would not care because `Object` implements `hashCode` and `equals`. The only way to have it so that a sub-class is required to implement it would be to have it extend an `abstract class Hashable` class instead which declares `hashCode` and `equals` to be `abstract`. If using an abstract class is not viable then the interface would need new methods which potentially duplicate the functionality of `hashCode` and `equals`.
I think /u/bob90211 s point is that the methods .equals and .hashcode in the Object class were a mistake. If one would design Java nowadays, this would probably be done using interfaces. But there were no interfaces in Java 1.0, so there wasn't really an alternative. 
Yeah, I've used both. Intellij was about the same as Eclipse. Just as buggy, just different bugs. I don't hate it (I hate RAD), but it was mostly just a move sideways.
&gt; For (a) I like knowing that for whatever task I need (e.g. web framework, database connection pool, medical image processing library), no matter how specialized, there are going to be several good open source choices available. This is actually why I would consider switching. I'm really sick and tired of having to deal with the conning, manipulative, and bullying from people trying to get some new framework inserted into the project. 
&gt; But there were no interfaces in Java 1.0, so there wasn't really an alternative. I'm not entirely sure where you're getting that from, but [interfaces were a part of the Java language specification from the very beginning](http://web.archive.org/web/20000816200843/http://java.sun.com/docs/books/jls/html/8.doc.html#34031).
Have you worked with J9?
This comment has been overwritten to protect this user&amp;apos;s privacy. It was done to help protect users from doxing, stalking, and harassment.
Which would lead to a disaster even bigger than the infamous Python version conflict. 
Windows 1 only
Huh you are right, I thought they added them in 1.1 or so. Then they could have made Hashable an interface. This would probably have saved several thousands of hours spent debugging; Even if you know the contract, it can be very easy to forget to implement the hashcode() method and the bugs this causes can be subtle. But in my opinion, many things from the early version of Java are not very well designed from a modern view point, the heavy use of (often unnecessary- e.q. AuthProvider being a Map, which caused security bugs when adding new methods to Map) would be considered an anti-pattern my many developers nowadays.
Isn't it a problem caused by the people who wrote the API? Therefore: ###ALLOWING PEOPLE TO PROGRAM CAN BE DISASTROUS
What would be the top 2 reasons for not going back to .NET, if you don't mind me asking?
You're missing the point. The confusion was *not* over how HashSet or HashMap work, in requiring equals() and hashCode(). The confusion was over why each of the three environments behaved self-consistently but different from each other. This is far from obvious. 
Of course not, Java came first. What's more important is when it'll be mature enough. EDIT 1&amp;2: Maturity isn't the be all and end all, COBOL is also mature.
I'm just a hobby programmer, but would it _technically_ be possible to refactor those methods into it's own interface without breaking too much shit? I'm 100% sure somebody thought of the upcoming idea already, so instead of asking if this would work, I'll ask "Why wouldn't this work?": Let's say a new `Object` superclass, call it `Something`, is created that has all methods from Object except `clone()`, `hashCode()` and `equals(Object)`. `Object` now extends `Something`, but also implements 2 new interfaces: `Cloneable` (which defines a `clone()` method) and `Hashable` (`equals()` &amp; `hashCode()`) All classes ~~compiled~~ created with the new Java version would superclass `Something` (and therefore miss `Cloneable`/`Hashable` implementations), but all "legacy" classes still extend Object, so old collections aren't broken (and any classes depending on object equality/hashes would ask for `? extends Hashable` in it's type parameter, which is now implemented by the legacy `Object`).
Haha, downvotes for all reasonable opposing views! It's like they prefer agreeable misinformation over facts.
I spend far more time on the desktop, why would someone want to be hunched over a phone all day.
lambdas and completable futures have literally changed the way I write java. They are amazing features.
Scala val pList = List("Hello", "World") val joined = pList.mkString(" ") val pEmployees = List(Employee(1, "Mary"), Employee(2, "Bob")).sortBy(_.name)
Agree.
JProfiler, been using it for 10+ yeas, works like a charm: http://www.ej-technologies.com/products/jprofiler/overview.html
Written in Java and Kotlin :)
This would break a whole lot of things that assume `Object` is the supertype of all reference types, that all objects define `equals` and `hashCode`, etc. There will be pain.
Yes. The enterprise is quite found of using IBM stacks.
You are still missing one level, since there could be more than one window of Eclipse as well.
Semicolon critiques in a plain text forum seem a bit overzealous...
Plain text? It was marked and formatted as code.
I thought I addressed that. The only way to do that is to have a literal random function inside, which it doesn't.
With Idea you can have a C++ module, a Python module, a Java module, a JS module, a GWT/Java all open at the same time (in the same Project, in the same window). You can even intermix these languages within modules using Facets, or simply appending the multiple SDKs to the modules dependency list (Project Structure -&gt; Modules; pick module; Dependencies tab). A module is just a directory on your file system, and Idea keeps track of that directory using a .iml file, that is akin to Eclipses' .classes/.settings. It's really not that different. Everyone just confuses the relationship between Projects/Modules.
The community around Java is much more developed. There are third party libraries for everything. The Java community is very opensource oriented. The C# community in comparison isn't.
What if `newList` was an instance or static field of a class or super-class? How would the compiler know if you want a new local variable or setting the value of a field?
I'll do my research, thanks! I was looking for the big ones so I could use them later while hunting for a job, but I'll definitely look into this.
Well I guess that doesn't show up in the app I use. Looks like plaintext to me!
SourceForge nuked their malware installers so unless the Hibernate developers put malware into their own installers then there should not be any. It should also be noted that SourceForge was bought by another company which quickly reversed course on the previous owner's misdeeds. EDIT: Source &lt;https://sourceforge.net/blog/sourceforge-acquisition-and-future-plans/&gt;. The DevShare program was the malware program. 
&gt; How would you meaningfully define object identity without taking object content into account? x == y System.identityHashCode(x) That's exactly what `equals` and `hashCode` in `java.lang.Object` do.
&gt; maven (packages) Isn't Maven renouned for being a headache? I've never had any trouble with NuGet, it's always worked perfectly right out of the box.
He didn't make forgetting equals and hashCode seem like an unexpected edge case; this was stressed repeatedly in one of our very first courses on Java. Instead, what we were so intrigued by was the fact that the different environments behaved self-consistently but different from each other. This caused us to learn how the default implementations of hashCode apparently rely on memory layout, which I thought was a nice anecdote to share.
Maven, or gradle. See http://search.maven.org/#search|ga|1|g%3A%22hibernate%22
&gt; That's interesting. They haven't done a very good job of getting the messaging out there. I still avoid SF as much as possible. So do I; didn't realise they stopped doing this. Never trust them again to be honest.
&gt;In the Java world, well, community typically makes a better option whenever something is not right. The .NET world does the same thing, I feel it happens less though because the Microsoft option is usually well designed and supported. There's no drive for the community to come up with alternatives because there isn't the demand. Whenever the official option does end up lacking there always happens to be a strong community driven project available. A useful Date datatype is something you shouldn't have to shop around for.
https://github.com/btraceio/btrace
grepcode?
&gt;It should also be noted that SourceForge was bought by another company which quickly reversed course on the previous owner's misdeeds. You have a source on this? Cause like most people here, I had no idea this had happened. 
Maven Central or JBoss repository. https://javalibs.com/artifact/org.hibernate/hibernate-entitymanager
Check my edit.
I think you're misunderstanding what I'm talking about w/ Nuget. It works fine to consume packages, but pushing them to private repositories (i.e. internal) is very complicated and expensive. Furthermore, consuming private packages is a huge pain if you want source-code and debug symbols. All this works pretty well and is free in the Java ecosystem. It's expensive, woefully undocumented, and really hard to get working on .NET. As for Maven, its annoying for build automation (it's been replaced by gradle), but the package format it pioneered is still top-notch and the defacto standard. 
&gt;embrace and extend That's 15 years ago now. Not defending it, just sayin' &gt;and being open source is no guarantee of success. they'll still have to compete and win in the market for developers [I think they're doing fine with developers](http://stackoverflow.com/tags?tab=popular) Mostly in the less glamorous SME space but there are also very large companies using the framework. Seems like this is their attempt in breaking into the current generation of web devs, right now even primarily .NET devs wanting to launch a product will go with another language simply because of the operations costs. I think all this is really to get the devs to come back, they're realising that losing the devs is the first stage towards losing the market and now they're hoping to undo some of the damage of their lock in strategy. 
But isn't that exactly the same? java -version &gt; 1.8.0_77 - with 8 being the major version, and 0_77 being the minor version.
Ctrl-Y is a Windows oddity. Ctrl-Shift-Z becomes the norm across all platforms.
Hmm. Have you read the javadoc? Assuming ordering like this is what prevents a lot of projects switching to jdk8 from earlier jdk because it would break a lot of unit tests.
By posting this on /r/java you're going to get a lot of useless knee-jerk "hell no" responses. Yes, there's a trove of open source libraries for Java, but having built a business on C# on the past I can tell you that I've never had trouble finding open source C# libraries for things I've needed. More does not always equal better. There's plenty to choose from on NuGet just like there is on Maven for Java, so that's not a compelling argument to me. For those touting Java's open source community, there's a rather sizable one for C# as well. Sure there are a lot of commercial interests out there, but most of us on this sub-reddit make a living selling software to other people so I don't hold much stock in the open source "pure blood" argument. Prior to Java 8 I actually *preferred* C#. Lambdas, Linq, and support for asynchronous programming, to me, made it significantly better before Java 8. The only downside was cost of deployment because of windows and visual studio licenses. I got accepted by BizSpark and most of that was no longer an issue. Being hosted on AWS, the windows servers were a bit more expensive than Java on linux, but the $100/month difference was well worth my productivity at the time. Now that Java 8 is here, though, I don't know if I'll go back. Yes there are things in C# that I miss like introspection of generic parameters at runtime and modules so I can better manage dependencies, but none of it makes up for the raw power and beauty of the JVM. Now that I can deploy linux servers my hosting costs are slightly down. And I find Intellij much better than Visual Studio. I liked VS but Intellij is in a league all of its own. So... I think there's a lot of misplaced hate for C# just because of the Microsoft connection. It's a really good language, the tools are good, and there's lots of pre-made libraries. Nowadays I just find Java moderately better in all of those areas so given the choice I'd use Java, but well-architected C# projects are not bad at all.
and majority of time spent on the desktop is just using web browser
If you don't use Maven or similar tool for dependency management and look for a ZIP / TAR.GZ distribution bundle, we provide them on Bintray, too: https://bintray.com/hibernate That said, the installer issue with SourceForge only concerned actual installer file types but not pure archive files as we distribute them, so AFAIK the Hibernate distribution files were never affected by this practice. (Disclaimer: I'm part of the Hibernate team)
I like IntelliJ. I really do. I find that when I have ONE project to work on, I enjoy it the most. But if I have to switch off projects, and one is not necessarily a dependent of the other, it's project management sucks. Please, IntelliJ: give me project management as good as Eclipse had in the 1960s? It's that reason and that reason alone that keeps pushing me back to NetBeans.
Likewise for hashCode, equals, the synchronisation stuff, ... in fact can we just get rid of Object entirely.
Lombok is pretty much mandatory for me now. It's the only thing that makes JPA bearable, for one.
JavaScript for sure. Don't get me wrong Python is fun as hell but learning JavaScript will help you if you want to be a full stack developer.
It's not really all that interesting, and I don't know how it's captured the interest of so many on this subreddit, I almost suspect there's a bit of astroturfing for the language going on. I had a interesting discussion about it not too long ago on this subreddit [here](https://www.reddit.com/r/java/comments/4an7xb/kotlin_a_new_jvm_language_you_should_try/d11tspf?context=3).
I have used CN1 (CodeNameOne) for a handful of years now, both personally and in the enterprise. I have been around the java language for some time, know other languages (including Objective-C), used other platforms, and continue to always find myself coming back to CN1. I find the support to be excellent, the APIs to be intuitive, the community helpful, and the progress that they are making to be incredible. I highly recommend it!
I'm in a similar position trying to get up to date with the modern web frameworks. I picked Angular2 as Angular is the most popular one and the second version is really nice, especially with a Java Background. You write in typescript, a superset of JavaScript which has features like a type system, lambdas, ... The code gets then compiled into regular JavaScript, so you can use it even with older browsers. In case you want to look into it, I'm using a course from Mosh, which I can highly recommend so far. You can get an idea about his teaching style and a nice introduction to angular at https://www.youtube.com/watch?v=_-CD_5YhJTA (I'm not affiliated with him/Udemy in any way).
Python is widely used, and it's therefore good to learn, but generally a given project is going to be written with either Java or Python, so there is not a lot of synergy. Java and Javascript, however, are often used together. On a Java web project, being comfortable with Javascript will allow you to write front-end code, or debug other developers' front-end code. For the same reason, if you're a Python programmer you should also learn Javascript. Same goes for C#, Go, Ruby, Scala, PHP, etc. They are all are used to develop web back end systems, and they will be paired with Javascript on the client side. So the way I look at it is that for working programmers today HTML, CSS and Javascript are pretty much mandatory learning, and then you decide what other languages and frameworks you're going to be proficient in. Good luck!
Fun? Just use jquery.
I used to work with Java and now I work in Go. Nearly all back end stuff. Even when I worked in Java, I rarely used any js. I have found Python and Bash more helpful for whipping up quick scripts that are needed to do ancillary tasks. Verifying the integrity of test data or integration testing for example. Of the two, I would choose Python. Regardless of which one you choose, it's always a good idea to pick up another language. It teaches you new ways of approaching a problem. I also agree with the comment on functional programming. Using different paradigms to solve similar problems will make you a far better engineer in the long run.
Awesome, thanks for the reply. This is helpful. Have a great Sunday!
[removed]
Neat. Thanks so much for sharing. I will certainly be looking further into CN1. Have a great weekend!
I used java a lot. I still do - it is great. I initially took up python as I got tired of compiling code and then sftp/uploading large binaries just to run it. I just love python now. The best part of python is that there probably a library exists for what you want to achieve. If you are CS student, as you take classes on machine learning, natural language processing or statistics - you will notice it is widely used everywhere. Several courses on coursera etc will use python. If you are into data science, its an important tool. It also has great web frameworks. However when it comes to browser, javascript is absolutely must have. You should probably learn both (eventually). 
Except that is the point... Kotlin isn't trying to be "interesting" by doing new things like Scala. It's trying to be interesting by smoothing out the warts actual people who use Java a lot deal with.
I would recommend JavaScript for sure, but learning at least one of the major scripting languages (Perl, Python, Ruby) will certainly be beneficial if nothing else, to learn a new coding paradigm. 
Everything on the client side is JavaScript or compiles to JavaScript so knowing it is extremely valuable.
Everyone's first comment has to be about something.
You can use it for writing the backend of an application, but you generally either use Python or Java for that task (or another language). OP said he wants to make a career out of Java, so it is very unlikely that he is going to use Python for his backends. Python is not used in the frontend (at least not widely used, there might be a python -&gt; JS transpiler). For the frontend, pretty much everyone uses Javascript (or a variant of it, like Coffeescript or Typescript). OP could still learn Python for scripting/automation/etc., but he will probably not use it as part of his stack.
Really? I'd say less than 20% of my time is spent in a browser. Most of it is spent in Netbeans or sublime or bash if I'm working, and Lightroom or xcom if I'm not. 
Thankfully? Try implementing a native cross platform mobile app (iOS, Android, Windows) and then report back how "thankful" you are :)
There are cloud versions for .Net too - nuget.org, myget.org, symbolsource.org. And frankly, having installed and configured artifactory, I found the nuget installation both easier and quicker (though obviously it has much less functionality than artifactory - but if you just want somewhere to push packages, it's fine). And yes, it can do mirroring, filtering etc. 
Learning Python is invaluable. There is always value in knowing a great scripting language. JavaScript won't really do since you need to basically run it in a browser. Python on the other hand comes preinstalled on most platforms and you can interface with all the hardware.
I've used both Nexus and Artifactory for quite a few years, in enterprise settings and I'd be really surprised if any Nuget installation can scale both in terms of usage and installation complexity like those 2 can, on premise. I'm not arguing that their installations aren't complicated, but the installation took something like 30mins, while their usage was for years, by multiple teams with a ton of developers across multiple time zones. A quick Google search for "nuget server" doesn't fill me with confidence: it's probably doable but it is tied to IIS and it definitely doesn't seem as slick and feature-full as those 2. For simple scenarios both ecosystems should be just fine, though.
Exactly. I was in a smallish company of 20 or 30 developers, and nuget was more than sufficient. It also takes about 5 minutes to set up rather than 30. My main point, however, was simply to refute the claim that a package repository with symbols is expensive and complicated in the .Net world. It isn't. It's trivial and free. 
Could you give some concrete examples? You can write crappy code in any languages.
It can be a matter of expectations. Taken at face value, it's FUD. But if you dig deeper, quite a few Java developers have experience from working in huge Java shops, on enterprise projects. And I don't mean "enterprise" in the "ha ha AbstractFactoryFactory" derogatory kind of way but rather in the "we have 100 devs working on this project because it is incredibly complex and has as many features as Microsoft Windows". As a result, when they look at a project they want to see that it can scale up to those requirements, because some day they might need it to. And all major Java OSS projects can do that, they've proven themselves. .NET OSS projects on the other hand... sometimes it's debatable. Sure, you can make it work, but how confident about scaling up when your first problem is "making it work" for simple use cases? :) The general impression from the Java community (and I wouldn't say it's totally wrong) is that in .NET land if you want something to scale up to enterprise you go for either Microsoft stuff or for a small handful of battle-tested OSS library. But, as I said, things are changing and that's good. Java &amp; the JVM could really use a run for their money across all platforms! :)
Let's get back to this conversation in about 20 years :)
With the job market in mind, you've got the back end down and now to focus on front end to be full stack, JavaScript is the way to go... you will have skills in the market preferred technologies for those two realms. Once you have those down and a good stream of income, don't hesitate to play around with other technologies such as Python, Scala, etc. which will expand your knowledge of programming in general and help cross-pollinate ideas between technologies.
Binary coupling between micro services is a terrible idea! Strong decoupling is the most important benefit of micro services in most scenarios. A minor issue is the API design. `restCall`is such a bad name to define a service method. default Descriptor descriptor() { return named("helloservice").with( restCall(Method.GET, "/api/hello/:id", hello()), restCall(Method.POST, "/api/hello/:id", useGreeting()) ).withAutoAcl(true); } 
But the thing is... add Nancy and Mass Transit to that list, and you've pretty much enumerated the entire .NET open source ecosystem in a sentence. In the Java world, the Apache Foundation has more new libraries in incubation than the .NET world has in existence. And Apache is only one of hundreds of major open source providers. However, it's not just that C# lacks 20 different library options for string manipulation. The bigger problem is that it lacks presence in the new generation of open-source *infrastructure*. Probably the best mass-scale database today is Cassandra, initially developed by Facebook. The future of pub-sub message queuing seems to be Kafka, developed by LinkedIn. Large-scale data processing is moving to things like Spark, from UC Berkeley data scientists. Etc. Most of these things don't have first-party .NET drivers at all, and the "community-provided" drivers are typically written by student hobbyists and aren't production-ready. The enterprise trend right now is toward microservice or service-oriented development, backed by DevOps-style deployment and management. Yet Docker on Windows is a horrible hack, meant for P.R. purposes rather than actual use. The bottom line is that Docker containers are a Linux platform from the developer perspective, and C# is only in its infancy of Linux platform support. So on and so on. Whatever open source community the .NET world has today, it would have to grow by three or four ***orders of magnitude*** just to merely catch up with where Java is.
https://github.com/quozd/awesome-dotnet/blob/master/README.md Cassandra client: https://github.com/datastax/csharp-driver Kafka client: https://github.com/Microsoft/CSharpClient-for-Kafka It's a bit of a stretch to call DataStax and Microsoft 'student hobbyists'. Regardless, while it may well be true that java dominates in truly large-scale deployments, most deployments *aren't* truly large-scale. There's nothing worse than looking at the codebase for a starry-eyed startup that has a multi-datacenter Cassandra deployment, when it turns out that any conceivable growth over the next 10 years would fit comfortably in a medium AWS instance running postgresql. Also, docker on Windows may well be a hack, but we're talking about .Net, not Windows. You can deploy .Net in docker on linux quite happily. 
For some old reason, I think JS is "fun". I actually enjoy it. 
Funny we tried to do the same five months ago and it was a pain in the ass. The project you are referring to has been abandoned, and doesn't work with packages created for new versions of .NET (it does some bytecode (MSIL) fiddling and encounters an unknown bytecode symbol, and blows up). 
Are you sure? According to this it was updated just over a week ago https://www.nuget.org/packages/NuGet.Server/
No they're not. 
So... annotate your constructors? If your ultimate goal is code reusability, then make sure that your objects can be used both using injectors and with constructors. 
The author states that annotations are bad and these we should not use them, but what about annotations such as `@Deprecated`, `@Override`, `@SuppressWarnings`, and `@FunctionalInterface`? Is having a `@Deprecated` flag on a class, field, or method absolutely horrible to have? Also, Java ME lacks reflections so all annotations are source time attributes and not run-time ones.
No, those are compile-time annotations.
I've been using CN1 for years, currently I am writing this app in it www.raffler.co, the best thing of course is getting 2 native builds from one java codebase. It is a bit niggly getting the GUI right sometimes because the simulators are not always as close to the real device as you would like, but you can send off for a native build to cloud and test in no time at all. I'd recommend learning CN1 if you like Java and want to code for both android/ios. I even make JS builds of my apps so they can run in a browser.
Yes I know this, however the author believes that adding annotations to the language was a huge mistake due to their high potential for abuse. However, does the author truly hate the non-abusive uses for annotations?
@Deprecated is declared as [run-time](http://docs.oracle.com/javase/8/docs/api/java/lang/Deprecated.html) annotation ;)
&gt; There are no static methods, no magical conventions, no easy shortcuts. In our opinion, developers should always keep total control over what's going on, even if that requires a little bit more work from their part and some extra lines of code. Well I agree but what's so special about that framework ? Don't get me wrong, I'd like to try it but I can't see any advantages over any other web framework. Could someone sum up the benefits ?
Neither. If you want to learn something different compared to Java or C# try any of the functionally slanted languages. Scala if you're targeting JVM or F# for CLR. Or try your hand with Erlang (or Elixir if you favor more modern feeling syntax) Google's Go language is also a very interesting alternative. If you want to get closer to the metal, try Rust or D language ... or Swift ... that is if the thought of picking up C++ frightens you...
You need Javascript.
I love to code!
I can appreciate that. What's your ultimate goal with the project? Are you doing it for professional reasons, fun, or something else?
Javascript will most likely be of better use to you. Everyone has said that. I'll advocate for Python (after learning JS) for automation. When I started my position, there was a lot of talk of dead code. I downloaded a plug in to find dead code and generate a report. The issue was that this plug in didn't search the entire code base for references, so I'd have to grep these additional locations for references. No references meant that the code could go. This could be a very time consuming. Thankfully, it's all very formulaic. Enter python. I automated this entire process. I'd kick off the plug in. The python script would run once per day to check for a new report. It would handle the searches that the plug in couldn't. Then it'd generate a new report removing any false positives. Lastly, it would delete the corresponding code. Python was not necessary for my position, but being able to automate a task saved the client a lot of man hours. I can almost guarantee that you'll have some repetitive task that can be easily (relatively speaking) automated. 
Okay. I would suggest abandoning this and finding a project with an active development team you can join. It's a lot more fun working on a team than it is alone.
You're welcome on the project if you want.
I wanna own a late model German luxury sedan and a large brutalist house.
Word!
Dude, that other guy is being a total downer. Keep on coding and having fun. The things you will learn from your project will be absolutely invaluable and you'll apply those lessons to your future projects and revisions to this project. Never stop having fun with programming!
I think either or both would be good. JavaScript is definitely going to be useful when it comes to being full-stack with your Java/Spring knowledge. The Spring web frameworks such as MVC tend to focus more on the backend (which is totally cool to me), and a little less on the front-end, and having that JS knowledge goes a long way to architecting modern, elegant, easy to use websites. That said, do also look into Python as it can be a nice tool in your toolbox for system level stuff, especially compared to Java, which is just a little bit too heavy for low-level stuff (like, you might knock out a quick Python script to do something that you wouldn't really want to do in Java...). Also, Python knowledge could eventually intersect nicely with Java when it comes to say, using Jython, which is the Python language running on the JVM, and might offer some cool possibilities down the road for you in terms of integrating scripting into something or just using on its own. Another option you might look at is Groovy, which would also sort of weave in to your Java knowledge and complement it.
That would be the ideal, but I think Spincast mostly targets developers who already have coding experience and who know that the best way to learn a library/framework is to add a breakpoint and start debugging.
Well, that is the best way to learn the internals of a framework, but it might not necessarily be the best way to attract a set of new users/coders. Anyway, good luck with that - and i love your treehouse goal. I share similar sentiments.
I have a POJO with JAXB, Gson and JPA annotations, gets pretty ugly. But I can't think of a very appealing alternative.
Only if you survive. The horrors of those languages may drive you to suicide...
I doubt you've used a lambda in hash-based collection - the results [can be surprising](https://www.reddit.com/r/java/comments/2r31tq/instances_of_noncapturing_lambdas/).
Optionally uses, not built on top of. If he has worked with Spring already, this will be a comfortable pair of shoes. http://camel.apache.org/spring.html 
Some thoughts and ideas: * Don't name your interfaces `ISomething` but `Something`. Just call the interface like the thing it is an abstraction of. If there is no abstraction, don't use an interface! (`Something` with the only implementation `SomethingImpl` is only slightly better). * Why the `save` method? It doesn't make sense if you read it. * I would prefer to let the actions return an object, which get then transformed and sent by the framework. * The context seems to be too much. It is used for communication (send...) and for templates and perhaps other things. * If you think about HTTP and how it would be used best, it would be useful to have some kind of "resource" in your model. The path could then be bound to a resource and not to a single action, what would reduce redundant paths. * Have you ever seen the great ["Clean Architecture" talk](https://www.google.de/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=video&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwiMtNfy_KfMAhXLVSwKHci5BbkQtwIIHDAA&amp;url=https%3A%2F%2Fvimeo.com%2F97530863&amp;usg=AFQjCNER-HBOp6g6igj584ErXZQDVo0GDA&amp;sig2=yBaMoJQGewDLMfVQRt5Eug&amp;bvm=bv.119745492,d.bGg) by Uncle bob or read the ["Clean Architecture" blog post](https://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html)? You'r next exercise could be to decouple your Framework from Guice. There is no good reason for this kind of coupling. It should work with (almost) any DI container. Try to make Guice itself a Plug-in. 
Equally curious, have you used anything other than spring for a big project ?
I and impl both suck.
Have you considered replacing JAXB and GSON with Jackson?
Then you can create Jackson Mixin and your POJO is free of annotations (except they are in Mixin).
Haha I thought exactly the same thing. I stopped reading when he talked about the book as if separation of concerns was an anti pattern.
I've been using Spring for pretty much everything for the last few years or more. Before that I had various efforts that had me spend time with Java EE, Guice, EJB, and others. I am really happy and comfortable with Spring, Spring Boot, Spring MVC, and others in the Spring family. And in case there was any confusion, the spirit of my question wasn't "Dude, Spring is the absolute best thing ever, you are wrong for not using it" -- I was purely curious if he evaluated it and what his thoughts were, especially given that's my main jam these days.
You're welcome! I didn't see anything that immediately looked like I could improve on it or that you should be doing differently. My first thought on the main router example was "well, gosh, what happens when there becomes a lot of methods here?", like is it going to be super cluttered? One of the things I like about Spring MVC, for example (and I guess this is technically true of modern Java EE which seems to be at least somewhat inspired by it) is that methods map to handlers, so instead of declaring them all in one code block, for example, that are just nice one to one mappings, such as one method for a particular URI endpoint and combination of HTTP verb and other parameters. But that's geared more towards traditional server-side apps, not necessarily your case being aimed at single page apps.
Fair enough. And again, purely out of curiosity and not because I'm defending it, in what particular way did you find it too fat? In my mind it's 'fat' with regard to lots of dependencies and startup time, for example. Did you happen to look at Spring Boot too? (Again, I'm mostly asking because these are the technologies I've settled on for the last few years, they work for me but my needs are relatively basic...)
The feel I got from the video is that they are trying to provide an all-in-one scaffolder. This gets you up and going quickly. If you have more advanced needs, then you can move stuff around and break your compatibility with the tool Scaffolding tools can only do so much. It seems like they expect the tool to be out grown.
Yes. If you select the microservices option, it will, among other things, put the front and back ends into different code bases. 
Any JVM-compatible language, including Scala, should be able to interact with APIs implemented in other JVM-compatible languages, such as Java. Though knowing pure Java can help you understand some design pattern choices.
I'm not sure how that's relevant. Your comment ("advice") earlier for him to completely abandon his project was unnecessarily dismissive and condescending. 
I highly recommend to use this simulation platform http://enthuware.com The questions here are harder but it is great for preparation. 
Yes, I used those mock tests for both OCA and OCP 7. Unfortunately, they don't have specific version for the upgrade certification. I already sent them an email about what is my best option, and they just plain told me that they don't recommend themselves for that upgrade. Fuck my life.
To bubble exceptions through lambdas the functional interface's signature must include the exception you are wanting to throw. You may roll your own or find a library. You could wrap the exception in a RunTimeException too.
Yup on the why. RuntimeException is not a checked exception, and as such isn't really a 'solution' to the problem I mentioned, just a way to avoid the problem by also avoiding the entire computation.
Yes, that or MOXy. Gson is on my to-do list to remove, but for now it's still around and with MOXy there's supposedly less annotations. It's just a general thing that I wish I could separate the simplest of things, the POJO, from any way it might be serialized, but I do like the simplicity of annotations, so I'm torn on the subject.
The only thing we don't have an unlimited supply of on this planet is time, and you're trying to waste a lot of his. Don't do this; it's a dick move. 
&gt; That's 15 years ago now. The shitty anti-OS sentiment isn't. That anti-linux FUD where some company on the paycheck of MS write crap about Linux having a high TOC was somewhere in 2008 for example. That's 8 years tops, not 15. And if anything is hard to change it's company culture. I see it here (large Dutch bank) as well: we're now a completely 'agile' company. Yeah right: there's tons of people here, especially in management, that are as anti-agile as heck. 
Nice blogspam
Why go through that much hassle? Just install the Oracle JRE with the Ask Toolbar. It has a similar effect.
Agreed, and besides, book is not a smart actor, book is a book, it contains pages, but it shouldn't define what it self looks like when converted to xml.
Fortunately Senior Developer Jesus has experience and not such a black and white view as his more junior counterpart. 
You're comparing with Scala here...
How does this compare to (u)Micro and Induction? Induction is a MVC framework with injection as second nature. See http://www.inductionframework.org Micro is a modular MVC framework (MVC pull) and it was solely designed with *simplicity* in mind!
haha, too true. It is funny that people would downvote a post that simply expresses a fairly common opinion on annotations. Social Java Warriors, unite! :P
According to one guy, who is maybe a little too optimistic. It's not just complaining, it's that nothing is happening for months on end now. Even if people stop "complaining", then there won't be someone instantly who magically picks up all the work that needs to be done. The complaining is raising awareness that someone, be it individuals or companies and best of all Oracle again, pick up the work and do some serious coding. We can all be enthusiastic and supportive and vote up whatever, but at the end of the day people would need to devote serious resources to it, and few are willing or capable to do that. Read David Blevin's excellent article about feeding the fish. We can't all take and never give back forever.
Liking the look of the Omega theme, will definitely be giving this a try ahead of the final 6.0 release.
I used to swear by Java EE. IBM WebSphere servers and/or GlassFish and/or JBoss. The servers were always very heavyweight and difficult to develop against but I always thought the struggle was worth it for the power of Java EE's libraries. Then I recently joined a new company that does everything with Spring and four load-balanced Tomcat instances. I have to say Spring+Tomcat is much easier and nicer. I don't miss Java EE in the least. 
That is true, but this can be an actual impediment to productivity. Random pauses while coding can knock you out of your flow.
I realistically evaluated project feasibility using the criteria he set forth.
https://www.spincast.org/documentation#static_resources
The it/network guys handle the load balancer, I think it's a hardware appliance of some kind. It's not too smart, it just iterates through the four tomcat servers as requests come in.
[Well...](https://imgur.com/m5T4JYK)
What you call "view engine" is called "templating engine" in Spincast. Please look at the [Pebble plugin](https://www.spincast.org/plugins/spincast-pebble), which is the default engine.
People do not understand that one strength of java i that it changes very slowly and is very consistent with old codes. This is really a strength. People look at the C++ evolution and think that this is good to evolve in that way. It is not. Look at the data of Tiobe and you will see that old objective-C developers move to Java and not C++ Nowadays in C++, you can express an array with int[], int*, vector, array, array_view. What is the advantage of that ? None. 
I see, do you guys make a lot use of JSTL and EL, how much do they pay if anything?
[Stop saying heavyweight.](https://blog.sebastian-daschner.com/entries/stop_saying_heavyweight) Maybe these problems originate from pre JEE 6, because I can't spot anything overly heavyweight in a current environment. Also saying something is heavyweight feels like an empty platitude to me, whenever someone is unhappy with something.
A Markov Chain generator. Nothing too outstanding, but it's interesting seeing how my code has changed since I started it a little over a year ago when I was still in college to now when I'm a "real dev". 
"Best" is relative, but the one that always brings a smile to my face is one I've mentioned in a [previous comment](https://www.reddit.com/r/java/comments/3r25j7/whats_the_most_interesting_thing_youve_made_with/cwkcx35). &gt;https://github.com/Omnicrola/FcsGraphics &gt; &gt;It converts image files into a different format that is read by software used to analyze data from a [flow cytometer](https://en.m.wikipedia.org/wiki/Flow_cytometry) . A flow cytometer is a medical device used to count or sort the individual cells in a biological sample using lasers and photodetectors. &gt; Data from a cytometer is usually viewed on 2d graphs. Using this, it will display a picture instead of clusters of data points. It serves no practical purpose whatsoever, other than to amuse myself and certain research scientists.
It was either that or I had to drop out. I like college :( 
ok, sorry about that :) 
I have a cast-iron skillet. How in-demand is that?
I built a game in &lt;12 hours with a fully working tile map, collision; with interchangeable tile rules, maps, character movement rule sets, for a company to demonstrate my knowledge of MVC, DI, and experience with TDD, including integration tests and mock data for the models and the controllers. The original problem was to develop a CLI program that took in a set of inputs, and produced the move list and output a final destination of a theoretical map; of which it still fulfilled that criteria. The view component was added in and was more for user feedback. With an hour or so more of work; I can have pathfinding fully implemented. Radio silence as well.
Probably the [BitPOS Platform](https://bitpos.me) It's a Bitcoin payment processor / merchant services platform. Wildfly/GWT/Postgres/Bitcoinj. I'm the only Java dev on the team, so maintenance tends to get a bit heavy, but it's been a lot of fun!
An infix expression parser to parse single-variable mathematical functions (and expressions) for evaluation and plotting. Probably one of my proudest accomplishments, but the graphing part is still a work-in-progress.
My HTML5 game. It was on the App Engine and I never got it ported to the new distributed database model.
reddit's a clown app.
Why not use `BitSet` for bits for a much more space efficient pack? What's with the try/catch(Exception)/log/exit(0) pattern? Rethrow as IAE or ISE seems much more appropriate.
i built a game in java applet.. with the name alien shooter. aliens will be coming to you vertically and you will be moving horizontally to shoot them. java applet is now deprecated :P
Or they had better candidates from which to choose.
Never hearing back is pretty harsh though. 
A BitSet packs into long[] and you'd still have to use an array of them. Just seems easier to delegate and compose than reimplement.
It has always been the small tools/apps that you build (on the side) to assist creating a much larger app.
Some suggestions: - Remove all the static void main() methods. Refactor those into unit tests. - Don't commit the jar into your repository. Libraries should be consumed from artifact repositories. There are various ways to do this but something like https://jitpack.io/ is a good way to start for something like this. People don't copy jars around anymore (or at least they shouldn't) 
A POS system for auto detailing (car wash) business that my cousins and I co-owned, using .net (visual studio lightswitch). I'm thinking about making the source code available for everyone out there to build their own POS https://m.facebook.com/story.php?story_fbid=374748525988704&amp;id=343135402483350
What do you mean it takes the city map as a text file? That part really intrigues me! 
This is so true.
https://github.com/aro-tech/interface-it/ It's a tool that generates wrapper code in Java 8 to convert static methods into default methods in a mixin interface. I use it in my https://github.com/aro-tech/tdd-mixins-core/ project to keep up-to-date mixins for AssertJ and Mockito to use in test fixtures. It can also be used to ease the transition of procedural code to more testable code in line with SOLID principles.
They have plans in the future to remove the binary coupling which is great to know. Regarding the API design, note that you have multiple call identifiers available, see http://www.lagomframework.com/documentation/1.0.x/ServiceDescriptors.html#Call-identifiers. 
100% alone, it would be two projects I did for college a long time ago. The first one would be a program that, if you had a mobile phone on your bike while you went around, would map possible problematic spots in the city, like holes and roads in bad condition. By the end of the ride it would submit the results and you could chose to report the problems to your local City Council. The second one, would be a system that would crawl foursquare and gowala for Twitter id's and then use them to feed a server farm that would abuse the twitter api limits for information. Kind of an orchestrator distributing work and fetching and compiling all the gathered information. In the end I'd have all available user details (name, city, etc) and location information, which could be used to map out the habits of anyone that did not bother to turn their profile private. The second one was an eye opener for me of how much can be done by crawling publicly available information. 
I'm on asp.net mvc @work, and Spring MVC / Play! at home for personal projects and for freelancing. &gt; Framework wise, I don't think .NET has anything to compares to Spring for DI. I agree but there are a few useful tools like [Ninject](http://www.ninject.org/) for DI. &gt; However I really like Razor as it is type safe, it is much nicer to catch HTML / View issues at compile time rather than runtime. Agree again and that's the reason why I love Play! &gt; C# has some features such as properties and LINQ that would be nice to have in Java. You could try [Jooq](http://www.jooq.org/) What bugs me the most is that asp.net mvc is still vendor locked even after being open sourced. The current state of deployment options are just bad on linux. There is also no parallel universe where I'm willing to deploy on a windows machine. At the end of the day, we just have to decide with which stack we get something done. 
That's pretty poor form on the company's part. If I issue a technical test to a candidate, I figure if they've taken the time to complete it, they deserve thorough feedback on their solution, and the feedback process is usually more useful than the test itself, because at the end of the day I care less about how they solved the problem and more about the process that led them to the solution they came up with. Often they will be thinking about some angle on the problem that I hadn't considered.
How did the first one determine the problematic spots? Accelerometer?
Yes. And Speed. Got this algorithm based on speed variations (GPS speed) and sudden movement on the acceleromerter (everything was logged and then signal analysis was done in the end, processing the log files for the ride). It wasn't fool proof, but by the end most false positives were filtered out (like climbing onto the sidewalk, stopping and putting the bike away, etc). The worse thing about it is that the phone would have to be on the bike and not the person (ex: a bag on the frame or a gps holder). People would add too much noise and serve as a brilliant shock absorver (masking possible spots).
I wrote a game in Java called The Dungeoning, it's about 35 thousand lines of code and runs on Linux, OS X and Windows. It was my first Java program though so the architecture is a little.. Naive, unfortunately, and has made it hard to refactor. It's on steam though :) It's got a lot of algorithms I'm quite pleased with, like procedural level generation, fast collision using buckets, animation, modular AI and other game type things. 
So as a relative newbie java developer, I never understood this discussion. Isn't Java EE just a set of API's or even specs for api's and libaries to implement? How can a spec be heavyweight? What does all this heavy even mean here. That you run your EE deployables on a heavy app server? I mean, tomcat can run EE and that can start up pretty quick. I have experience working with full IBM stack, and that is very heavy. However, just because Websphere is slow as hell, that doesn't have that much to do with Java EE or what? That said, I really prefere Spring, and even more so, Spring Boot. But doesn't spring also use some EE specs, like jpa?
An archiving client and server which has a queuing system and a client/server protocol which is implemented using a state machine. It also can handle network interrupts and stores huge amounts of data packaged and encrypted in a tape vault. It was written to handle lots of small files.
Just wanted to say Supreme Commander is an awesome game and I have sunk many hours into it. That's all.
Yeah at least a courtesy, thanks but this is why we didn't hire you would be nice. 
Not even possible. He is on the java subreddit
Nice! Are you still making games?
You should probably care for your child more than just a few years before putting them out on their own 
What kind of structure would you have used?
My recommendation: Head First Servlets and JSP Book by Kathy Sierra
I'm really, really sorry to rain down on you, but I want to save you some time and future headaches. I think when I first learned about unit tests I read somewhere that every single method "needed" to have unit tests. I wasted so much time asserting things that amounted to 'proving' that the compiler and core Java libraries worked correctly. It sounds like you're in the same place I was. It took me a long time to learn some things because no one pointed out that I could be doing things better. So 1. Don't use setters, use immutable objects with `final` fields. (You can't do it all the time, but when you want to mutate have a good think about whether there's a better way.) 2. Use `ReflectionToStringBuilder` from Apache commons to auto-generate your `toString` value. 3. Testing a getter/setter is just proving that the compiler generates the correct code to set/return a field's value. You could be setting/returning the wrong field -- but that kind of logic error will be exposed by other unit tests. 4. I really, really hope your `hashCode()` methods always return the same value! Also, use `HashCodeBuilder` to generate your hashcode. 
It's kind of funny actually. It's an ASCII town. Various characters equal certain things. Nothing special. BUT if you were to expand that thought and create and actual file where it really was a town, then you would know where to start. 
Feedback was all I really wanted at the time. I had so many questions. Lots of bright people worked there too.
I don't know what I can actually contribute at this point seeing as I am only about to finish my first year as a CS major at a school that teaches java specifically; but is there anything I might be able to contribute towards or if not, maybe something I could at least review for my own knowledge?
I was merely a fish in the sea. No hard feelings, but a simple email saying no thanks would of been nice. Especially with me making it through 2 other interviews to the testing stage. Skype interview a few states away, drove down to do an in person interview. Moved there a bit later (for another shabby job that didn't even start! but that started the eBay journey) Then had the test program because I atleast made it that far.
[Here's](http://descriptor.com/self-study/webapps/index.jsp) a free self-study JEE Web apps course.
[Here is the full file link.](https://www.dropbox.com/sh/xvvou8s66uboucg/AACJgMBAPxLGOY3xH_wwTjS5a?dl=0) You have the entire source file. Then a jar file to run the program. Use the TownTest txt files to upload into the executable. One thing I guess is I didn't build the simple layout. Looks like I used some program to build the simple GUI. It saved time. Can you blame me haha In the file you will see some commented out print.out sections that use to debug incase you run the code you can see it parse and identify broken logic when parsing the town. The meat and potatoes starts at line 380 of the src file. My proudest moment was that my code didn't account for power being generated from the Southern side up. So I had to reverse everything and go right to left bottom to top!
All I wanted was to discuss it with someone who cared and knew how it was suppose to work. Besides family members who just saw me locked away for a week. "Yeah Mom, it's great, the train stations that start from the South weren't even being parsed because my search pattern would skip over them!"
I second this recommendation. It's a bit dated, but is a very good resource. I used this to study for my Sun Certified Web Component Developer many years ago and passed with ease.
So the RTS itself is closed source and you're just developing a JavaFX client for it? I just pushed my group at work to start using JavaFX so I'll check it out. 
Professional Java Dev reporting in. Gimme somethin to kill.
[removed]
FWIW, Eclipse already has something like that built into it. http://nzpcmad.blogspot.com/2005/11/eclipse-writing-java-snippets-in.html
[removed]
I would love to join you. I have finals next week but after that I have very little to do.
Thank you so much. I'm still learning Java on my own and seeing someone else's conceived work from the ground up is a great learning opportunity. thanks.
Same boat. First year of CS degree, however I'm flying through the course. The only issue I know I have is JavaFX because I know I don't know all the API's or uses for it. Currently I'm at the point where VBox is love and HBox is life.
I feel the same way as you, but team standards. I would try the reflection to string builder but we want custom to strings that truncate text and hide data and print out array sizes. I am of the same mind that generated code shouldn't be tested. 
I'm open to helping with this. I've got about 17 years programming experience, but the majority of that is with C#/.NET. I've spent the last couple of years developing utilities in Java &amp; Python, but have done nothing with JavaFX. I'm always open to learning something new and JavaFX looks interesting.
Hola, mates! I just released this today and will be more than happy to receive some feedback. Also, if you know about some helpful and valuable libs that are missing, feel free to add them. In the end, more goodies are coming soon - like links to context tutorials and tracking trends.
This is great, I think. And I love the design and smoothness. Are you the author of LibHunt overall? If yes, I would love to see the sources :) Thanks!
Actually you can take a step further and run in a debug context in the display view. That means you can sit at a breakpoint and play around with instantiated framework objects for example. It is simular to the evaluator in idea. Super powerful tool.
According to the post you will be compensated with a mentor.
As the project progresses you will have to change code already written and often there will be opportunities to improve it then. While it is probably worth reviewing code for optimisations so you can improve your skills, there are many factors other than just code quality to consider and thus often the best solution is one you can do quicker even if code is inferior and it is slower – so don't get too hung up optimising things for perfection,
&gt; the design [of the old client] is flawed. You repeat this two times. Could elaborate on that? Also how would you prevent that for the new client?
Yeah, but that means I have to reach that breakpoint through any execution path first. That's not always obvious. A scratch pad (or REPL) can execute standalone "scripts".
I find that strange to hear. The wtp adapter from JBoss is one of the best ones out there. The "integrated" one is the from JBoss tools I hope. The entry is there in servers view, new server by default, but it installs on first use. This particular runtime (connector) starts up JBoss in the same second it takes on the command line. And it stops in the same time too (graceful is a second or so, hard stop via the red button is instant). I'm particularly puzzled about your hot code replace story. I too love Tomcat, so I don't want to say much negative about it, but the build in WTP adapter in Eclipse for Tomcat always restarted the app fully for every little change. Whereas the JBoss tools one has done hot (incremental) deployment for years, at least since ~2008 when we started using it. Resources like Facelets are perfectly replaced; edit file, refresh browser, see change. Same thing for Java files as long as you keep to the limited changes the jvm allows (in short, code inside methods). This limitation is because of the jvm and has nothing to do with JBoss or Tomcat (if you do incremental deploy for Tomcat you have the same limits) No GlassFish server run times for Eclipse have been hit and miss. Some versions were quite buggy and the server would hang at 69% all the time. In some other versions the debugger would lose the connection all the time. From a befriended Netbeans shop we heard Netbeans never had an issue with GlassFish. Latest versions seem to be stable again (knock on wood). WebSphere has always been horrible. Big 2gb install taking hours, doesn't run on OS X and didn't have server runtime for regular Eclipse. We did a few projects with its replacement Liberty and that works perfectly. Unzip like install, starts up in 2 to 3 seconds, straightforward Eclipse server runtime, etc.
Make it clean, run it through visualvm, draw the algorithm on paper.
http://imgur.com/2YeDA
On mac, have jdk8 installed and getting error ... You must be using a JDK. where can I set this ?
Looks like you're on a mission to create an entire series of such overviews. Very nice! What's our goal? Writing a book about the Java library landscape?
Those will get removed. I've never used junit in a serious project before, but I know I should here. And oooh, I wasn't aware that existed. I was planning on submitting it to maven central eventually, and was just putting a .jar in the repo in the meantime so people wouldn't have to compile it. Thanks for that. c:
I'll make the fields final, seems like a good idea. And yeah, letting it cut down on the segment size is definitely something that should be added, it's been on my mind but I haven't done it yet. It would be pretty bad to have the allocation fail because it can't allocate a big enough contiguous chunk of memory. Thanks!
OP hit me up! cs student, loves to code java, recently learned Mvc on swing and looking to learn something new
Dude, thats amazing! Thanks for sharing your code xD
I wait for actual user feedback before wasting time optimizing unless the optimization is stupidly obvious and simple. Same thing with overly generic code. I used to do that a lot then I realized I was never using half the abstractions I was inventing, my coworkers were frustrated by the complexity of my designs and APIs, and that project requirements were changing things faster than the abstractions could handle. I think a very important zen moment in every software engineers life is when they accept simple is better and that working code trumps perfect code.
Java developer here. Would love to join this project. I also have another co-worker/friend who would be interested in joining as well probably. 
Might as well deprecate add() for Set and change it to addWhenAbsent() so the name reflects better to what it actually does ;) I don't see what point this proposal would bring. If anything, I believe the method should just be removed all together. The whole point of Optional was to remove NullPointers and checking for them. The if-then-get defeats this entire purpose. But alas, we must stick to backwards compatibility, eh? Edit: Apparently my assumption on their purpose was misguided. But still, my point stands on the naming.
What's the error? Worked for me after chmod +x jpad.jar Edit: Sorry now I see... the error you get IS "Could not find java compiler, you must be using a JDK"
&gt; The whole point of Optional was to remove NullPointers and checking for them. I remember doing code reviews for people who were using `Optional` for the first time. Most of them used `get()` incorrectly. I told them something like "You shouldn't use this method, it should have been called `orElseThrowNoSuchElementException()` because that's what is happening here, you're really looking for one of the other methods." After seeing this email thread I got curious and checked back on those projects. Pretty much everywhere an `Optional` shows up it is immediately unwrapped with `orElse(null)`. *sad trombone*
I don't think spring boot is a microframework. 
I'm still stuck on Java 7 and haven't really looked at Optional yet. How should a case like that be handled if not using isPresent() and get()?
Sure!
I'd love to get involved. I'm still pretty new to programming and Java. i'm about half way through year 2 of a CS degree. I just completed a course in Java where we completed a partially implemented Android app. We worked in IntelliJ and also learned JUnit testing. Hopefully I can contribute and also learn some new things along the way.
You are correct, I used a wrong term. That was supposed to be "Working Set"instead of "Workspace". That is a unit into which projects are grouped and Eclipse may have more than one working set open at a time.
Nice. Would you include [JsonP](https://jsonp.java.net/) ? 
Well, I have plans to set up an Android specific site. Although, that could be a subsection here... not sure yet. Do you think it makes sense to add an "Android" section?
Why would someone need Rails sourcecode ? curl -IL java.libhunt.com X-Powered-By: Phusion Passenger 5.0.27 
Good job OP !
I thought optional was meant for streams.
Nice article. I try to be pragmatic about TDD. There are always extremes, like no (automated) testing at all and full blown TDD where you don't even implement a getter/setter without first writing some test for it. For me there is a middle way, and the most important thing is, that there are automated tests that cover the main functionalities and regressions. This discussion on youtube more or less concludes with "we all agree, that automated self testing software is necessary for high quality software": https://www.youtube.com/watch?v=z9quxZsLcfo
It's a pretty good language for teaching you by example that parts of Java are indefensibly clunky.
I didn't actually know this. The way I've been using them is as a return type when the return value could be null for my everyday code. If they were truly designed to only serve the Streams API, it seems quite limiting for such a useful way of handling nulls.
Same here. They make it much easier to reason about your APIs, and to know what's going on. Before, if an API returned null you either had to notice that it would do so in the Javadoc and handle it, or else you get errors. Not, an API shouldn't ever return null. It should either return a concrete value and never null, or it should return an Optional if null is a possibility. That way, the caller is forced to think about it, and it's obvious from the signature what's happening.
Test your public interfaces. If you have a private class used by a private class, you don't really need to write tests for its getters and setters. 
1. I take your word for it, as I've read recently different opinions. 2. So is possible from other JVM languages, and, especially, from… Java itself. 3. I really try to avoid having mutable objects, so I don't see a point in properties. 4. Still it's null which I prefer to not have at all. 5. Looks great, but it's not their discovery. Home many other languages have you fall in love recently? 6. See point 5. 7. See point 5. 8. Which is out of discussion, unfortunately… But I wish you best programming in Kotlin.
Dunno, but I think that Scala does great with providing support for Java standard collections but still maintaining full immutability even on API level. I can say that learning Scala changed a little my Java coding style. For example I started using instanceof when I would use case classes with pattern matching.
We use various Java libraries on a very regular basis from within Scala, you just have to be careful with null handling (eg. wrap stuff that can return nulls in Option) and conversion of collections returned from Java APIs (I mean, you could just use the Java ones, but then you can't use the "normal" Scala methods on them. Automatic conversions are available via an import though, but it's something to be aware off)
I can't think of a single occasion in my 15 year career when syntax was holding me back. Brevity is nice, but that's all it is. What is essential is design, code reuse and maintainability. Maintainability meaning that you understand in some fine detail what happens once you push the deploy button. I did have to work in Scala, Javascript, Perl, shell and a lot of other languages too, but can't remember ever thinking back how I would prefer to do something in anything but Java. I hated Scala the most, as I found it very confusing that I had to keep going back to see if a variable was a function, a class, a primitive or an instance. What also annoyed me was that I understand fairly well what happens to a piece of Java code once I deploy it to the VM, having spent such a long time with it. None of that with the others.
Me too. Java interoperability (by design) is really good features, really better than Scala and Xtend. You can easy mix Java class and Kotlin class in same project without any issue. Kotlin may be the Java killer, really.
Correct me here, because I just fleetingly looked at Kotlin, but isn't Kotlin typesafe? Doesn't it have top-level functions? From what I see you don't have to declare types on variables, right? How does both of my arguments against Scala not apply here?
Maybe use the optional type declaration on variables you know that might be easy to forget which type they are. Or just use it everywhere
The main criticism towards Java that came to me from the Scala camp was that Java had overly elaborate types because it wouldn't allow lambdas/top level functions. So, are you proposing that we get back to "abstractInstanceFactoryConstructor", just not in the type declarations but in the variable-names? Where's the benefit in that?
Scala is done from someone who works in academia, Kotlin is done from guys who know the industry. If you love powerful type systems, take a look at Scala. If you love KISS, take a look at Kotlin.
You don't have to, but you can. I think sometimes declaring types introduces noise, but sometimes it's helpful. Kotlin gives you choice. Also i think type after colon is more readable. Java: final Random random = new Random() final float result = currencyCalculator.calculate("USD", "EUR", 15.5) Kotlin: val random = Random() val result: Float = currencyCalculator.calculate("USD", "EUR", 15.5)
I didn't even know what these things were I had a look and it's not very user friendly. You think reading this will help me be a better programmer more efficiently than a book?
I don't think that reading will help you right now. Start writing code. It won't be the best code, but you won't truly understand what you're doing until you design and implement some software without the book holding your hand. After you've written some software, more advanced books will be appropriate.
&gt; I take your word for it, as I've read recently different opinions. About Kotlin's IDE support? In IntelliJ the support for Kotlin is excellent - perhaps not quite as advanced as their Java support, but close to it. &gt; So is possible from other JVM languages, and, especially, from… Java itself. Yes from Java itself, and yes languages like Scala can interoperate with Java, but Kotlin really go out of their way to ensure bi-directional interoperability in a way that no other JVM language does. &gt; I really try to avoid having mutable objects, so I don't see a point in properties. It's good practice to avoid mutability if you can help it, but sometimes it's necessary. And if you like immutability, you'll love the "copy" method in Kotlin's [data classes](https://kotlinlang.org/docs/reference/data-classes.html). &gt; Still it's null which I prefer to not have at all. The reason people don't like null is that it causes runtime exceptions. If the type system is protecting you from runtime exceptions then there really isn't any reason to dislike null. Kotlin's approach is equivalent to an Optional or Maybe construct, but without the overhead of a wrapper object. &gt; Looks great, but it's not their discovery. Home many other languages have you fall in love recently? Just because a language feature isn't unique doesn't mean it doesn't benefit the language. &gt; See point 5. &gt; See point 5. &gt; Which is out of discussion, unfortunately… But I wish you best programming in Kotlin. If you haven't already you really should take a bit of time to review Kotlin's documentation. It really does have a lot of nice features. Many of them aren't unique to Kotlin, but Kotlin brings them together in a really nice way.
Couldn't agree more. The more I try these other languages, the more I appreciate Java. And this whole push for val/var makes me cringe.
Groovy is not type safe, Kotlin is. 
Groovy is not type safe which is a no go for a lot of Java devs. Also performance is not great. 
Pick anything and just try to code it. See an existing project and try to copy it. Maybe a small desktop app.
Most definitely. Write software the best way you know how. Don't be afraid of making mistakes. You're only going to get better by doing it.
yes
&gt;&gt; Why the save method? It doesn't make sense if you read it. &gt; How would you call it? I think it should be more declarative like `handle.GET("/path").with(...)`. The thing with returning and converting objects is quite nice with JAX-RS. You can let the framework handle the conversion, provide custom converters, or you can pass a certain object directly. Explicit configuration would not conflict with a concept of a resource. But such a concept would represent one of the most important concepts of http. A resource has a URL and one or more methods like GET, POST etc. To have such a concept would reduce redundant path declarations and allow to send appropriate headers to list all allowed methods for a resource.
This reminds me of Scala. - great IDE support in IntelliJ Yup. - i can use every Java library Yup. Just call the method. - i can use getters and setters from Java classes as properties in Kotlin There's a Javabeans getter/setter annotation in Scala. - null safety Scala uses the Option class (Some or None) - SAM Conversions ( val runnable = Runnable { println("This runs in a runnable") } ) I don't think that Scala has this. But you can do: val functionObject = new Function1[String] { val toReturn = "A String" def apply(): String = { toReturn } } - data classes Case classes. Implements Serializable automatically and comes with a copy/modify-copy method. - destructuring declarations (val (name, age) = person) Kotlin is straight up copied from Scala. Person is just a tuple that gets decomposed into two variables
&gt;No, I'm not suggesting you put the types in the variable names. Whaooou! Back to the 70's. Come back to the Hungarian notation! Please have a look at the disavantages in Wikipedia pages about this notation.
&gt; I hated Scala the most, as I found it very confusing that I had to keep going back to see if a variable was a function, a class, a primitive or an instance. &amp;nbsp;&amp;nbsp; You press Ctr-Q in the IDE and it pops up and says if it is a pattern/val, Class, Trait, etc. That being said, it doesn't matter if it is a function, object, a primitive, or an instance of a class. [If it has no parenthesis, it is either a getter or it is the functional equivalent of a getter](https://en.wikipedia.org/wiki/Uniform_access_principle). Even if it is not a getter, all of the computation it may do just helps it get the value - it's not allowed to modify any external state. &amp;nbsp;&amp;nbsp; The thing about Scala is that it is at its core not an object oriented programming language - it is a neo-functional programming language, like Haskell or F#. If you don't know functional programming in Scala or if you never learned Haskell, you're going to struggle and not understand why.
Scala is much more perl-ish. I've just started a kotlin project after working mostly in Scala for two years. I know Scala pretty well and that makes kotlin feel pretty lacking. For better or worse, it definitely doesn't have a lot of the fancy features that Scala has. I fully recognize that Scala is complicated and has a relatively high learning curve, but I also believe that it is worth the effort. I don't know, I love Scala. Maybe it's Stockholm syndrome.
&amp;nbsp;&amp;nbsp; Dude. Scala is by far the hardest programming language I have ever mastered. Harder than C++. It has nothing to do with how elaborate the types are. Simply put, you never actually learned how to program in Scala. A benefit of programming in Scala the right way is that like Haskell, there is virtually no mutable state (except in total isolation) In Scala this mutable state is acceptable: def mutableStateFunc: String = { val toReturn = { var left = "left" left = left + "right" left } toReturn } &amp;nbsp;&amp;nbsp; Notice that "left" is mutable, but it is isolated to a little scope and nothing can access it. This is called a functional facade. Also notice that it has no parenthesis - it is effectively the same as a getter or a constant instance variable. Other than that, there is no mutable state (unless you really need a deep and unchanging hierarchy of things like "Animal &gt; Mammal &gt; Rodent &gt; Rat" where it doesn't make sense to put an instance of "Animal" inside of "Mammal". Even then you can use "lenses" which allow for copy-modifying of nested things). &amp;nbsp;&amp;nbsp; In Haskell, the language on which Scala is based, there are no mutable variables whatsoever. All functions are values.
&gt;vastly better than Scala That might be a slight over statement. I've been a scala dev for a long time now and just barely started using kotlin so I'm probably still fairly misinformed. That said, I think there's a lot to love and a lot to hate in both languages. Kotlin trades expressivity for simplicity. That's a reasonable trade off, but it's not the clear cut better decision. I understand why people prefer that, but I still disagree. :)
Thank you for your answer. Since i have no experience do you think i should go with javaEE or spring? 
Groovy can also be used to develop Android apps and has first-class support on Spring Boot. IIRC, the New York Times recently rewrote their Android app(s) using Groovy. 
Fine, I'll bite. Show me a big, working, production quality infrastructure project, which fits the FP blue sky thinking. I only know Kafka intimately and that uses FP anywhere it can, it's just that mutable state is essential. I'll happily overlook you calling me incompetent for a single example of pure FP bliss. 
You can use any Java library in Scala just fine. Roughly the same rules apply as if you were using it in Java. That mostly matters around nullability. Java libraries tend to return null more often than Scala libraries. You just need to be aware of that.
I guess that depends on what kind of company you want to work at. In my personal experience of working at very large corporations I have not found a high amount of Spring usage. I see a lot of Websphere, Weblogic, and Jboss EAP. However, Spring is very widely used, and things like Spring boot, and Spring Cloud are very attractive projects that do not currently have equivalents in JavaEE. A lot of people seem to have the opinion that developing in Spring is a more pleasant experience overall. So I can't really tell you what you should learn, but like I said before, I think that either one of these technologies in the hand of a skilled practitioner can be valuable to many companies.
I see Kotlin as being the true heir to Java. Java wasn't created as an ivory tower language, it was a pragmatic language created by working programmers, for working programmers. Kotlin is the same. It's not interested in evangelizing ideologies like functional programming, although it does give you the flexibility to use functional paradigms if you wish to. They just looked at Java, and improved all the things that annoyed them about it in a thoughtful and consistent way, much as Java did with C++.
Pretty sure you misread my comment.
What's wrong with type inference at variable declaration, and encouraging programmers to think about whether a variable is mutable or immutable (rather than defaulting to mutable)? Both are entirely beneficial so far as I'm concerned.
Thanks, I was mainly asking about scala, I've been meaning to learn it for a while and wanted to see where people use it.
You could of course use the Guava implementation if you really wanted :)
Your sad is well placed, thank you for reminding me of the rest of the api functionality - I've been largely ignoring it
I think whats missing from alot of discussions are the design reasons behind kotlin. Jetbrains needed something to work within their existing large java codebases with their existing java devs (like many other big firms) and also as a standalone language. Its taken alot from other languages because many other languages have great features but none particularly prioritised interoptibility with java code, few prioritised learning curve for an existing java team or even things like compilation performance and few tried to improve upon runtime exceptions like null pointer exceptions or provide things like backwards compatibility. This [blog post](https://blog.jetbrains.com/kotlin/2015/11/the-kotlin-language-1-0-beta-is-here/) describes the history + some of the reasons better than me My impression, its easy to learn and has many of the things I like about Scala and doesn't have many of things I hate about scala. The type system with nullable types is brilliant, collections have a sensible compromise for interopt with sugar for effective immutability in kotlin (no dodgey implicit conversions / wrappers...) and as noted above, a sensible selection of features actually thought out rather than a bucket of everything. All the while guaranteeing some backwards compatability, great IDE support and keeping a java like feel to it.
I agree its not flawed, but backwards compatibility fundamentally restricts the language to change. Change is good sometimes.
Honestly, they is us in a few years. The more useful bits of FP are coming to Java, just like they have been to .NET.
I studied Scala for a long time before Kotlin got any real traction, so i have a hard time understanding why i should care about it. The two languages seem to have a lot of feature overlap, and Scala seems to be getting somewhat established.
Kotlin is more java like, so the adoption for Java developers is easier. Also kotlin isn't a functional programming language, so you won't do wrong with your OOP mindset. In my opinion it's an attempt to hit the group of developers too intimidated by Scala, but who stills wants language with more features. So to answer your question, you shouldn't. 
You're not listening. I didn't say there were no pure FP APIs. I'm saying there are no real world pure FP implementations outside of academia. Kafka has a very clean FP client API, it's code under the hood is global states all over. Are you saying that the Kafka developers don't know FP well enough (since you obviously have no trouble insulting my capabilities)? 
You didn't say anything about a pure FP API. You said "Give me a single example of pure FP bliss." For people doing big data processing, map/flatmap/reduce/filter is bliss. Maybe it's not 100% pure, but it's a lot better than what they used to do. 
&gt; I fully recognize that Scala is complicated and has a relatively high learning curve, but I also believe that it is worth the effort. I don't know, I love Scala. Maybe it's Stockholm syndrome. I find this perspective to interesting. I read an article (I believe it was written by Guy Steele of Common Lisp fame) discussing the relative power of various languages regardless of the fact that they may be Turing-complete. So, my question to you is: Did using Scala allow to solve more difficult problems more efficiently with a higher level of abstraction than using Java? Were there ideas and concepts that were trivial to implement with an expert understanding of Scala compared to the difficultly of expressing those same ideas in Java?
Oh no, the blasphemy! Are you saying that FP can't do everything oo can and sometimes you need to code Scala the way I explained? Can you please explain why you told me earlier that I must have been out of my depth when I said this? 
Well, I've never seen a FP fanboy cry uncle in the fashion you describe. I'd love examples. :) And FP is coming to mainstream Java. Lambdas are going to see to that if nothing else, and you'll see LINQ-like libraries for Java crop up, if you haven't already. Those are simply FP in library drag. It's nothing new when you consider libraries like Guava have been going this direction for quite some time. Now, that's not to say that we'll all adopt pure FP. I'm not saying that at all. But we will see a lot more FP DSL style libraries in Java, and possibly even a return to a more actor centric model like that which Quasar enables. That's all good IMO. As for FP, "it's too complicated": I agree that it's mostly BS, but seriously sometimes it's true. The metaprogramming facilities in the likes of Scala and Elixir make me simply want to cry when I'm trying to understand what a particular library is doing within an expression. Combine that with type confusion and the rigor that can go around typing in general, and it's WAY more time consuming than I have time for. Could I understand it? Sure, given enough time. Will I? Life is too short. I suspect we agree on that last point. Anyway, I haven't closed the door on languages like Scala and Elixir, but I'm definitely going to need to have some major epiphany before I go after them wholeheartedly. In the meantime, something like Kotlin looks like a very nice compromise.
Wow, you are really open to new technologies and best practices. You must be a excellent developer with your open mind.
Software guild
&gt; If you don't know functional programming in Scala or if you never learned Haskell, you're going to struggle and not understand why. I suspect the difficulty is not learning functional programming (which at its very core is not that complicated), so much as dealing with whatever baggage you're coming into it with. This is purely circumstantial, but friends of mine who have done relatively little Java coding seem to find Scala easier or more approachable than Java veterans.
Do you think they're also hoping that if they make the sweetest programing language ever it'll drive more developers to use IntelliJ?
Depends on the quality of the developers on the project. 
I never had trouble mixing java and scala together. Though, I have always had a hard rule: NO THIRD-PARTY SCALA LIBS. lol. It was the only way to stay sane with scala.
When someone loves Kotlin a new Scala user is frustrated :p Kotlin is a threat for Java, not for Scala.
What does it have over Groovy?
Well, to get a deeper understanding, you should start doing things in java, join a project, start your own and make an effort to rack up experience with the problems you would encounter while working with java.
You can't hold back adoption for that. Haven't we learned over 30 years this is not a reason to forego good features?
You'll likely get your app up and running faster with PHP. But if your goal is to become a professional programmer, learn to do it with Java. You could build it from scratch (without any frameworks) using a simple JSP and a Servlet and some Java classes to connect to and execute scripts against the db. In fact, I recommend you do that just for the learning experience. Then you might look into Spring (or Java EE) to create a web service and an ORM layer.
Are you sure? http://blog.codefx.org/java/dev/design-optional/
I've said this a bunch now, but type inference should only be used when the brain is capable of it. In Haskell, we have top-of-the-line type inference, and yet we still explicitly type *every single* exported function, because of clarity. Type inference should be used only when it's *painfully* obvious what the type of an expression is (for example, when adding two ints, your brain just knows the result is an int). If it isn't obvious, put a type on it! But having type inference is super valuable for those expressions where the explicit type is just tedious boiler plate that's hard to write *and* read.
&gt; Scala is done from someone who works in academia, Kotlin is done from guys who know the industry. I dislike this kind of anti-academic inverted snobbery. Java was designed by James Gosling ([Computer Scientist](https://en.wikipedia.org/wiki/James_Gosling)) and Guy Steele ([Computer Scientist](https://en.wikipedia.org/wiki/Guy_L._Steele,_Jr.)). Python was designed by Guido van Rossum at a Dutch research institute. C++, designed by Bjarne Stroustrup ([Computer Scientist](https://en.wikipedia.org/wiki/Bjarne_Stroustrup)), F#, easily the best programming language that MS has ever produced, designed by Don Syme ([Computer Scientist](https://en.wikipedia.org/wiki/Don_Syme)), Haskell - Phil Wadler ([Computer Scientist](https://en.wikipedia.org/wiki/Philip_Wadler)), ML - Robin Milner ([Computer Scientist](https://www.theguardian.com/technology/2010/apr/01/robin-milner-obituary)). Meanwhile, in the industry-designed languages column we have Javascript, Visual Basic, and Perl, three of the most badly-designed languages ever to grace a computer.
He just needs some sanity.
That could just be a category on it's own.
Check out [Vert.x](http://vertx.io/) (the web version) and [Spark](http://sparkjava.com/), both are extremely lightweight and a total breeze to work with.
Null safety is not "syntax"
The original post, which is entirely about the use of Optional in streams, should give you a clue. 
I second everyone who says to look into Spring. However, recognize the difference between Spring &amp; Springboot. All be it they are the same, Springboot require almost zero configuring to get up and running. Understanding how everything works behind the curtains is important to employers, as well. You won't see anyone saying "Experience with Springboot framework preferred." They're always asking for Spring. Play is another nice one but personally, I live in a Java shop city and I don't see anyone (especially the larger corporations) using Play.. but it's still great. Spark was also suggested, this was the first MVC (Model View Controller) I learned to build Java web apps on. It gets the job done but after learning Spring and then discovering Springboot - you'll never use anything else. Seriously though, if you go down the boot path - please learn it's parent first. Springboot will be THAT more much powerful if you do. @Annotations in Springboot allow for seamless injection of classes, methods, beans, everything.. but understanding how they do it is what will get you that job. If you're not comfortable parsing JSON yet, you'll need to also look into Thymeleaf/Mustache to inject into your HTML. They work in harmony w/ your Java..
Wouldn't that be considered bad practice since you're naming your custom object after a stdlib object? 
No, in Scala you can rename stuff using imports. You give stuff simple names and disambiguate later. import java.secure.{ Random =&gt; JavaRandom } import com.myCompany.{ Random =&gt; MyRandom } import org.apache.outdatedsecuritycommons.{ Random =&gt; ApacheRandom } JavaRandom.nextInt MyRandom.nextInt ApacheRandom.getNextIntBuilder.configure.getNewNextIntGeneratorInstance.nextInt
Yeah. It has eclipse support and maven support. But really, kotlin works best in an Intellij environment (netbeans is way out). The maven support is a little dodgy, I'm not a big fan of "you have to put this configuration in the right order in the right spot" sort of things. I haven't tried the eclipse support. And netbeans has no hope of supporting it, which is too bad because netbeans has better maven support than Intellij IMO. That said. It does a fantastic job of integrating with java projects. The side by side support of kotlin is better than pretty much every other JVM language I've seen. Even my critique about maven is weak as it has been a bear to get other languages to even sort of pretend to play nice working side by side with java. (groovy, javascript, etc).
Hey, if it's not too much trouble, when code blocks are retrieved from websites could you do syntax highlighting?
Look into Dropwizard as well. Really easy to quickly get up and running. 
I think a combo of stackoverflow previews (already a feature) and javadoc previews (not just the JDK, but as many open source projects as possible) would go a long way. I tried searching "java threadlocal" and didn't get a preview, but the example for "java accessmode" did give a preview.
The lack of operator overloading is one of the things that makes Java great! This useless and confusing feature adds very little if any value at a great cost.
That's a good idea - thanks. I've filed a request for it here: https://github.com/duckduckgo/duckduckgo/issues/190
Don't know of any resources off the top of my head. You might want to find a beginner book that covers JSP, Servlet, and JDBC connections. Or google for a "hello world" JSP/Servlet tutorial. Then google for a simple JDBC tutorial. Then figure out how to get your Servlet object to talk to you JDBC object. Try and when you get stuck, ask questions here and on stackoverflow.com It may seem hard at first, and it helps if you have an experienced buddy to learn from, but what we're talking about here is all in a day's work for any software developer. Learning to do new things all the time. I've been a programmer for 20 years, and I recently had to start with "hello world" examples for Apache Solr and Bootstrap Javascript UI stuff. It never ends! Good luck! 
This. I defended Java until I started using Kotlin every day. Now I can't go back to Java without getting frustrated. 
Compile time is currently the biggest limitation of Kotlin IMO, but significantly faster compilation times is one of the primary goals for the upcoming 1.1 release. Performance is virtually identical. 
You said if before I could, but you can definitely explicitly declare the type in Scala.
I think you should learn about it, but briefly, in case you'll be using it in the future career. The trend right now is geared more towards Spring related technologies, and other JVM web frameworks. But honestly in terms of working freelance, I think you should go for lightweight Java web frameworks instead of going for heavy ones that have steep learning curve. Good luck. 
I'd agree, except (as an example) Java-8's FP features are incomplete with various oddities, and they show no signs or interest in actually implementing FP features on a level that would actually be competitive with something like Scala. I donlt really see Oracle making things like Scala or Kotlin obsolete any time soon. P.S. I haven't really used Guava, but is it really obsolete?
 &gt; Is there already a project like this in existence? I have been unable to find one.
You're welcome
+1 for Spring Boot and Dropwizard.
I love DDG and apparently never realized you guys focused on anything other than a non-windowed search experience.
It will fixed in 1.0.X http://blog.jetbrains.com/kotlin/2016/03/kotlins-android-roadmap/ in my opinion in Kotlin night before Google I/O :)
The diamond operator is one of the most *flavourless* syntactic sugar ever invented! IDE will help on the right side, the left side is waiting for easing the burden 😉
You don't use a String "+" concatenation?
&gt; Might as well deprecate add() for Set and change it to addWhenAbsent() so the name reflects better to what it actually does Anyone who thinks a Set does anything different when you add an element, doesn't understand what a set is.
https://imgur.com/1Q3JSpL.jpg i'm sold, this is awesome. 
DuckDuckGo staff here. The regular search results don't give priority to programming results as such (unless the query is clearly a programming query), but the instant answers we show are mostly created by the community and, being developers, there's a programming bias. All answers/results should be relevant, however, so if you find something that isn't, there's now a "send feedback" button at the side.
Thanks for the specific example. I've filed an issue for this: https://github.com/duckduckgo/zeroclickinfo-fathead/issues/201
&gt; I guess my question would be is Java a good choice for a small-scale web application? It is actually. If you use something like Spring Boot you can easily set up something in a day. We used a Spring Boot / AngularJS in a 4-man hackathon team (which we won) a couple of months ago. It requires pretty much no configuration and you can have a Spring Boot REST API running within minutes. 
I think you're misunderstanding something. You have no developer experience. So what you want to learn is the basics: Java. Start there. Java EE is basically an extensive 'library' (or actually; it's a standard that other libraries implement) that helps you solve 'stuff' that you typically encounter in large organisations. Another well known 'library' (or library of libraries) is Spring. It basically does the same thing. It doesn't really matter which one you focus on right now because with Spring experience it's not hard to learn Java EE and vice versa. But none the less you should start at the basics. Become a programmer first before you try to work on large complex enterprisy projects.
You forgot about industry-designed Golang ;-)
&gt; The next thing is also fairly straightforward: we expect Kotlin to drive the sales of IntelliJ IDEA. http://blog.jetbrains.com/kotlin/2011/08/why-jetbrains-needs-kotlin/ 
"I think you're misunderstanding something. You have no developer experience. So what you want to learn is the basics: Java. Start there." - http://codingraptor.com/java/java-lesson-50-learn-basics-core-java-49-lessons/ ?
!maven junit
Kotlin's "FP" features are also incomplete, being as it's not trying to be a FP language. I personally think guava is obsolete and a poor choice to add it as a dependency to a project. It's a bit of a nightmare when 8 of your dependencies all depend on different versions of guava because it tends to release new versions frequently. And for what? Better collections? FP-style API you can now do better in java 8?
&gt; Scala doesn't differentiate very clearly between fields and methods. This isn't true, because there are no fields in Scala, not that it's immediately clear why should there be a differentiation, universal access is a good thing. &gt; Scala does a lot of weird shit with classes and traits and stuff that makes it exceedingly convoluted to understand. What exactly are you referring to? Linearization? Kotlin does that as well. 
Well, at least SourceForge is no longer on the evil side of software.
What I like in Kotlin is it's **fun**ny functions keyword :)
I know nothing about code or programing i have no experience at all and i was thinking about getting head first java 2nd edition to help me start my journey to learn java. Do you recommend it knowing that i have 0 experience.
That's covered by https://javalibs.com
I used to visit java.net multiple times a day, but it has been hardly updated in the last couple of years.
Thank you for such a detailed response. I will attempt a Java project first and I have effective Java and clean code on my reading list. Will grab them after I get more coding in.
Java is not the right choice for *small scale* web applications. You can play with PHP if you want to get something up and running quickly, but Node is what I would really suggest. There are so many legitimately awesome things you can do with Javascript these days.
The article does a good job of trying to ground some of the arguments around TDD with research, but the main issue preventing real decisions is the following: How do you measure short-term vs. long-term effects? For instance _how much_ higher quality will your code be? What does that mean for the business? How many bugs will you prevent? How many bugs will you have in the first place without TDD? What will the extra bugs' impact be on the business? I don't think any of these questions are very answerable unless you're really on an extreme end of the spectrum (i.e. "prototyping throwaway code" vs. "mission-critical life-saving software"). Therefore, I think the only reasonable option is to pick a set of practices and heuristics that balances quality with delivery speed, and not try to do the guessing game with projects that fit in the huge grey area between "extremely temporary" and "lives forever". Write unit tests. Try out your APIs. Automate at least some higher-level code. Try out TDD for a while, and use it when it makes sense. Don't use TDD when it feels stupid. I feel the same way with "functional programming" principles. I am a huge proponent of immutable data, pure functions, and composition. However, when I feel like I'm inventing a whole new DSL in a language that is hostile to that environment, usually that code ends up being overengineered. If I give in and use some mutable state and side-effects, the code can sometimes shrink dramatically. However, just being aware and familiar with the principles makes all my code better.
You're welcome! Our community is very important to us, so thank you!
Thanks, /u/arajparaj! 
I remember very old JAXB and SOAP snippets of information hiding out there. I got lost in those sites multiple times trying to find largely undocumented pieces of enterprise-ish code. Good to know those answers will be forever lost to time
Guava has this exact method. I've never thought the concept was confusing. Anyone who uses Optional should understand this.
TicTacToe with GUI and AI xD
Perhaps we're operating under different understandings of "QA" here - I'm thinking of people who do either acceptance testing or run through suites of acceptance tests to serve as regression testing.
It is a safety thing. If a set threw a "duplicate item" exception whenever you tried to insert a dup, then I might agree with a rename of the add function. As it stands. Optional#get throws an exception. Whether or not that is acceptable, I'm not sure, but really most people should be using something like the "orElse" method instead. Honestly, though, I think this could all be caught with static analysis and the IDE. Something like "You are calling 'get' on an optional without first checking 'isPresent'". Same as the nullability annotations. At least with Optional it is more apparent that you should be concerned with the value not being set.
Please take me as your disciple,think i can contribute to it and improve my skills,i was just looking for something like this.Studying java for over a year now,can devote a lot of time to it.
None of the arguments made against it that I've heard so far have made any sense at all. I'd like to hear yours :)
&gt; And this whole push for var makes me cringe. Why?
"The best code is working code" Honestly, if you know PHP, why not just use it ? The second quotable bit of verbiage is "throw away your prototype" Once you build the prototype, you will have things you will want to do "better" If you're still excited and motivated by the project, then use that as an opportunity to redo it whatever technology seems right at that point. FWIW, I'm not a fan of PHP. But for truly small scale stuff it works fine. From your description of project, it would be too big for me personally to build in PHP, I would move to node or java. I would avoid C#, great language, shitty ecosystem unless, perhaps, you have an ongoing love affair with all things microsoft. 
This why I recommend to members of my team to only use Optional as input to methods we expose to other teams, never as the return type. :|
Isn't that typically automated? ie. integration testing?
I'm in a graduate job doing Java and would love to get some open source development under my belt
That makes sense but is unfortunate, since I think Optional as a return type is where it shines. If a method can sometimes not return what was requested as a normal and acceptable action, I think it should indicate that in the type. For example if you request an element from a map/cache/database, it perfectly reasonable to expect it's not there
https://xkcd.com/979/
To a point, but there are cases where, perhaps, you're dealing with legacy systems that predate good testing practices and you can't prioritize funding to take time away from rolling out features to retrofitting the tests. There may also be times where automation just isn't quite up to the task (e.g., you may not have the hardware needed for a full browser stack test via Selenium with visual comparisons to catch regressions in visuals).
The problem with ifPresent is that exceptions cannot be thrown from the lambda parameter, and there's no second Supplier parameter to allow some kind of error to be logged if the Optional is empty. You can use orElseGet, but then you'd have to create type-specific nulls for most of your objects (ew); you can use orElseThrow, but then you're losing the monadic advantages of Optional over simply null checking all your parameters in the method before using them; or you could flatMap a bunch of calls all the way to what is, in the end, an empty Optional with no idea which call failed and why you're ending up with an empty Optional. In short, the whole reason why NPEs are terrible is because the null assignment happens somewhere in the code not where the NPE is thrown - and getting an empty Optional after twenty flatMaps is the exact same problem. isPresent and get are ultimately needed as workarounds to the problem that you can neither throw exceptions from the parameter lambdas nor can you bundle an exception with an Optional to explain why the Optional is empty.
Not being able to throw exceptions is a legitimate problem. Swift solves this by having most functions like `map` rethrow exceptions thrown by the lambda. But Java, for some dumb reason, doesn't do this, despite being a highly exception-focused language. As for solutions, both your problems could be solved using an `Either&lt;A, B&gt;` type. In Haskell, we use this to essentially represent values of type `B` that may have failed and thrown exceptions of type `A`.
Why did you decide to keep some classes as java and some as kotlin?)
I think you might want to take a look at pippo - https://github.com/decebals/pippo The routing is very flexible http://www.pippo.ro/doc/routes.html and it also not imposes a certain template engine or DI framework. My personal preference is the low memory footprint or war size. Until pippo I thought we are cursed with only have the serverside in nodejs for a low memory footprint for IoT(RaspberryPi-s). No longer. 
&gt; A much better approach to handling properties is to use a few configuration classes annotated with @ConfigurationProperties Can anyone explain how keeping your configuration inside a compiled class is better than keeping it in a text file on the filesystem somewhere? I always reference a properties file that is external to my app. That gives me the flexibility to make changes at runtime, without rebuilding and redeploying my application. This really seems like it would make things a lot harder to me.
Can you still make changes at runtime? I have changed properties on a handful of occasions when things like external API URLs have changes, or database passwords, etc. I ask because I'm not a Spring guy. I live in JavaEE land.
I think *you* actually may be confused, not your interviewee. It is totally normal and expected to use an optional even when it will only be used as a null test. `Optional` is a way of *explicitly* saying, this method may return a null, and you need to handle it when it does. Sure it has some useful methods that aid in your programs general fluency. When you use things like `Optional#or` and `Optional#map`, it really feels *right*. But it's definitely not wrong when you're just using it as a null check like this: Optional&lt;Integer&gt; maybeGetInt() { .... } void doSomething() { Optional&lt;Integer&gt; maybeInt = maybeGetInt(); if (maybeInt.isPresent()) { doStuff(maybeInt.get()); } else { doSomethingElse(); } } I may have misinterpreted you but is that what you're saying your interviewee did? To me that is clearly superior to having `maybeGetInt()` return Integer, it being the caller's responsibility to handle a null without the method signature making it clear. Better to be explicit IMO. `Optional.empty()` is just a purposeful `null`. If the caller needs to handle a null return, it's better to wrap the return value in an `Optional`, unless maybe you're doing something fairly intensive / low level. All the other nice methods that `Optional` offers are great, but even with the most basic methods (`get` `isPresent` `empty`), it's better than doing null checks.
Personally speaking, certification does not mean that you are actually a competent programmer, only that you passed a specific set of requirements. The only real way to improve is to actually work on Java projects, there a wide number of projects you can contribute to and ones you can start yourself. Today we live in a very open source environment where you can easily show your skill to potential employers.
He doesn't really mean people in academia are worse than in industry. What he means is that Scala was designed by PL researchers as a vehicle for PL research, as was Haskell. Java was designed specifically for an industrial use case (set top boxes) and its evolution was guided by what industry needed. Hence the fact that the cutting edge R&amp;D in the Java space all went into the JVM rather than the programming language.
IntelliJ does that, but agreed on the compilers part :)
If Optional.get() is deprecated, then everyone will move onto Optional.orElse(null) I think the problem is that people aren't used to using optionals in the new stream workflow
skip OOP and go straight to FP
Just deprecate null as well.
Can you expand on your point? Don't really have a lot to go on with just what you posted.
Studying for a certification is really rewarding. You can see all the strange and weird things Java has to offer. Reddit hates certifications, but It doesnt hurt to get one. 
Where is vielga or agleiv_289 when you need him?
I think he's joking. He's joking... right?
I'd love to see them "solve" this with an enhanced match syntax. Even if it was a special case of `switch`, something like ( off the cuff, no real thought - full of peril and bad design ): switch (something.returningOptional() ) { case actual: System.out.println(actual.toString()); return; case null: System.out.println("nothing, move along..."); return; } Guava's `Optional` at least has `asSet()` meaning you could do trickery like: for ( actual : something.returningOptional().asSet() ) { System.out.println(actual.toString()); } which would only run on the Some case - but is also some form of god-awful-sin like code. My favorite option would be to add some form of unary deref, almost clojure like going `@optionalThing` which is concise, but obscure enough that reading it you'd have to go "huh, what does @ mean" and learn. 
Hell, even having `NullPointerException` report the type it was EXPECTING to get would help so so so much. I do like your used/caused tho, to save the runtime cost you _could_ do that with some bytecode mangling at compile time, or on class load time?
Is there an up to date version of this? One that uses the flyway gradle plugin? Does every compile run flyway and jooq? Does that affect incremental builds?
&gt; Is there an up to date version of this? One that uses the flyway gradle plugin? Interesting, I suspect you could write a comment directly to the author on the linked blog. &gt; Does every compile run flyway and jooq? Yes, they're both *run* every time, but... &gt; Does that affect incremental builds? ... Flyway only runs increments, and jOOQ can be configured to read Flyway's schema version using the `&lt;schemaVersionProvider/&gt;` setting in the code generator: http://www.jooq.org/doc/latest/manual/code-generation/codegen-advanced &lt;!-- A custom version number that, if available, will be used to assess whether the above &lt;inputSchema/&gt; will need to be regenerated. There are three operation modes for this element: - The value is a class that can be found on the classpath and that implements org.jooq.util.SchemaVersionProvider. Such classes must provide a default constructor - The value is a SELECT statement that returns one record with one column. The SELECT statement may contain a named variable called :schema_name - The value is a constant, such as a Maven property Schema versions will be generated into the javax.annotation.Generated annotation on generated artefacts. --&gt; &lt;schemaVersionProvider&gt;SELECT :schema_name || '_' || MAX("version") FROM "schema_version"&lt;/schemaVersionProvider&gt; That way, jOOQ's code generator depends on a previous Flyway generation. If that is not specified, jOOQ will still generate only classes whose content has changed, to support incremental building.
Or refactor your application to encapsulate all the @Value injections in some config class and inject that into your components
People are always so happy to see competitors of their favourite toy go away. Until one day their favourite toy is the only game in town and they stop innovating. Anyone remember Internet Explorer 6?
Regular projects may have not used Java.net for some time, but many of the Java EE projects have their home there. What'll happen to those?
This should be, if anywhere in /r/javahelp as is outlined in so many places in this subreddit. Yet, neither of the subreddits is a mirror or second opinion for stackoverflow and generally, linking to SO posts is frowned upon or forbidden.
No, you should use concurrent data structures and eliminate shared state. If you're writing your own spin lock you're almost certainly doing it wrong. 
He's banned from this sub. Such a shame :) Perhaps it's better. I'd expect him to get a brain aneurism from a topic like this. 
agleiv and all his successive accounts were banned here because he was *massively trolling* the sub (which they did in plenty other subs as well).
Spring Boot is a great example of convention over configuration. You can get a web app up and running with no prior Spring knowledge in about a weekend, working at weekend speed. It is well documented and for my money a pleasure to work with. I especially like how everything relatively easy to test.
All this bikeshedding just reminds me of the great movie [wag the dog](http://www.imdb.com/title/tt0120885/). I wonder what scandal they're really hiding?? ;)
Checking my history, I see that Haskell evolved out of a commercial FP language in the 80s, so that bit is wrong. But if you look at the people who have driven it since the start, they have all been academics, and it's not like they built Haskell to make their biology research easier. They were computer scientists doing PL research. Since then Haskell has been driven forward by the academic community, hence the complaints about compiler speed and such which can be explained as "you don't get to publish papers if you just spend time optimising code, unless it's a fundamentally new algorithmic optimisation" 
&gt;I can't think of a single occasion in my 15 year career when syntax was holding me back. Brevity is nice, but that's all it is. This is so naive. The majority of language advancements in the last two decades come down to "brevity." Developers aren't migrating towards higher level languages for the sake of it - they experience tangible productivity benefits and improved ergonomics.
The world has seen too many "uninformed developers", and my opinion is gut them and move on. One day some one will come along and say that why is mixing primitives and their corresponding object wrapper slower? They should have more explicit names like "integerDontMixWithInteger" class. IMO, draw a line at language features, or do not draw any such line at all. Either way optional is something one should learn.
I say “good riddance” because java.net *sucked,* not because it is a competitor of what I use. There are quite a few perfectly good code hosting sites out there. Nothing of value is being lost by java.net's demise.
Certification doesn't accurately portray programming skill, but it does show a valuable personal trait: That you're willing to make an effort to learn and improve yourself.
Android app. What a mess of an API...ughhh.
&gt; Nothing of value is being lost by java.net's demise. The JIRA trackers and mailing lists for Java EE RI projects?
It certainly isn't something I do a lot, but one of the prime examples is passwords that expire for database connections. In my company all of our database accounts have policies that require the passwords to be changed periodically. I have also changed passwords for accounts that authenticate to external REST APIs using HTTP Auth. I certainly agree that it's not something that you should really be doing a lot, but there are definitely times where it is useful. As far as disk access, I'm really not concerned, all of our disk is on a massive fiber channel disk array and it can handle reading a text file.
Ah, no, you're right. That should just be a null test for sure. I thought you meant he defined a method as returning `Optional` because the value could be null.
A [cross-platform system tray](https://github.com/dorkbox/SystemTray). Technically not JNI since I used JNA to avoid having to ship binaries, but it's practically the same thing.
How many more times do you want to spam that link? It's more than enough. Seriously, reddit is not an advertising platform.
Editor vs author.
I took an assembly language class last semester and we had a project that required us to call code written in x86 assembly (MASM style!) from a high level language. He said no one had even done it in Java for his class (most people do it in C). I did it using the JNI. It was terrible. 
That is definitely the best free Java OOP course. I love when people link that. :)
Used OpenCV that in turn uses JNI
If you're using JNI then you should be using Dropbox's open source Djinni. It makes the pain of writing JNI go away. https://github.com/dropbox/djinni
Wow, this kinda takes the cake... * 0-effort shitpost * Just some messy code with some highlight * No description whatsoever * Yes we can see it's Java Also: please read the sidebar and its roles before posting. There's hint's **all over** this sub: &gt; Please seek help with Java programming in /r/Javahelp! Edit: seems like [your last submission](https://www.reddit.com/r/java_programming/comments/4b7xnb/why/) wasn't better, either. At least that was in an appropriate sub. 
Congratulations! This post is so wrong in so many ways that the only appropriate action is to remove the post and ban you from /r/Java. First, /r/Java is **not the place to ask such questions**, that's what **/r/javahelp** is for. Second, just an **imgur screenshot**? Really, it's not possible to spend less effort. Screenshots are **never** acceptable for code. Third "Java Error" is hardly an acceptable title. Fourth, no description whatsoever Should you make such a post in /r/javahelp as well, you will be banned as well. 
Android app
Adding a feature to the compiler specification to support an API choice is a pretty OTT solution though... The only way this would be a rational approach imo is if we (please Oracle, one day) get some standardised pluggable type checking framework à la The Checker Framework which supports generating warnings like this. That way the feature would be effectively demoted to an API change itself, instead of a weird bespoke compiler feature that is either clogging up the spec. or not going to be reliably present across build environments.
To be fair Brian Goetz is *constantly* moaning at people to quit with all the bikeshedding on the mailing lists... I guess it's pretty inevitable with so many developers wanting to weigh in on stuff though.
I have no professional interest in it, I could see it for hobby programming but Groovy is closer to what I'd prefer even in that case, maybe because it looks closer to Python to me which is a good language.
What's wrong with streams? Linking me to an article on the difficulties of MapReduce has nothing to do with being able to do work on collections with methods like map, fold, filter, etc.
Agree overall. I've not used Thymeleaf/Mustache. I've used jQuery's parseJSON, it seems to work well.
How is this link straight from Oracle? http://www.oracle.com/technetwork/articles/java/ma14-java-se-8-streams-2177646.html That shows mapreduce in all its glory and then you can refer back to my previous link on mapreduce. 
That's what I was about to say. Everytime someone brings up certification they're ripped to pieces :D
Not super-recently, but needed to read barcodes on scanned images. The best library we could find was written in C. Admittedly, they provided the Java classes for it, but I still had the joy of trying to make it all work as expected.
&gt; you can do it with JNA Or with JNR, https://github.com/jnr/jnr-ffi 
I remember that class, except I used VB to call the assembly routine. I never understood why Java didn't offer the same "dummy" mode for easy cases.
I think working on a side project is one of the best investments you can make professionally speaking. Not only does this add experience to your resume, being in a singular project can damage your vision of technology.
Yeah I mean I can see their point. For example: Getting Java SE certification doesn't mean you can build anything. So it seems like a waste of time. But, I thing the real value comes from studying for the certification. You can see all the strange things that could happen in real code. Especially in the OCP. That shit is just difficult
Related discussion over at /r/scala: https://www.reddit.com/r/scala/comments/4gz3mv/deprecating_optionalget_in_java_should_scala/
Facebook!! No, seriously.... Go and make a Facebook game. I have made one, and the experiance it gave me, and lessons learnt from making it was invaluble. Oh, yeh, and I still get a few $ from it every month so am very happy. 
To be fair: In this particular case, Brian Goetz is asking for people to bike-shed this particular topic. He's wagging the dog, so to speak.
Java Programming for Android Developers For Dummies 
Would love to see the Maven/Liquibase version of this
Used it within the last two months at work. We have a shared library written in c/c++ that we want to support on iOS and Android. I wrote the Android portion of the code. It wasn't fun, but it gets the job done.
I had to interface with a product written in C++. Sending notifications to and from each application was a pain in the ass. Not to mention to think about memory leaks and not cleaning up code. Ugh. While it was fun to write in a different language, I did not like pushing out a plugin for our product that would crash the jvm if the product I interfaced with changed something internally. Even though I worked with the product's API, if the internals behind that API ever changes, that could crash the JVM. But hey! A check box for the businesses and marketers out there.
I use it with GWT nearly daily, though it is an overloaded interface with GWT. It is just a marker for compiling javascript. 
Nice to hear such efforts from your side. Concentrate more on codings, try to know how to connect applications using JDBC drivers ,MS Access and Java Threads.Click to learn advanced topics in Java https://intellipaat.com/java-training/
Just curious, was /u/theplhk's [post in javahelp](https://www.reddit.com/r/javahelp/comments/4h0tp0/help_for_project_java/) the same no-effort and you removed it, or did he delete it himself?
Thanks I will keep the link
This post should either go to /r/javahelp or to /r/learnjava according to the rules of this sub. **Post removed:** wrong subreddit - not rule compliant
I think there's a balance of breadth and depth when you're growing as a developer, and you want to be in a place that will allow you to grow in the ways that you want to. There's no problem learning new languages, but you'll have a hard time gaining seniority if you're spread too thin. Also, there are some people who have other priorities than work and would rather coast instead of learning new skills.
Yep, that's rather handy, one I've missed ( which is available on javaslang's Option and elsewhere ) is an `orElse(Supplier&lt;Option&lt;T&gt;&gt;)` that you can use in absent case, returning _another_ optional value but may now be a `Some&lt;T&gt;` ( like a flatMap but for the negative ) - useful for chaining: findUserByTwitterId(..) .orElse(findByEmailAddress(..)) .orElse(findByPhoneNumer(..)) .ifPresent(user -&gt; ..... ); Regarding using `get` itself, or the above crazy ideas - there are times where, you DON'T want the overhead of the lambda -- or more, the code between you and that lambda, so using isPresent/get is an optimisation _at that particular use site_ ). 
Isn't [graal](http://www.oracle.com/technetwork/oracle-labs/program-languages/overview/index.html) still going? They claim they can run node right now it seems.
Why would they even bother? Is there some great failing of node.js that warrants the time, money and opportunity cost? 
Hi, first, it's interesting what direction Java takes. Second, you might find this opinion interesting https://medium.com/@tjholowaychuk/farewell-node-js-4ba9e7f3e52b#.45zsxcoas
Thank you for the link. :) But the product you mentioned is from Oracle, and the suspended is from Red Hat.
Yeah, I know. I'm saying that RedHat probably gave up because of competition, not because it's not possible.
It's Microsoft's fault for not supporting a standards compliant c and c++ compiler. Npm and nodegyp developers have already gone out of their way to make it work at all on Windows. 
Apparently they don't have any issue that OSes besides GNU/Linux, *BSD also don't. 
Java 9 adds `Optional&lt;T&gt; or(Supplier&lt;Optional&lt;T&gt;&gt;)` which is what I think you were asking for. http://download.java.net/java/jdk9/docs/api/java/util/Optional.html#or-java.util.function.Supplier-
Gonna look into #1. I've been testing it for a little bit, so far, so good!
So the solution in that case would be to put a Java wrapper around node? Either node is not the right tool, and you need to rebuild your whole stack from the ground up, or the developer is just unwilling to get comfortable with Javascript. 
Groovy has an annotation for static type checking, @TypeChecked (I assume that's what you mean by type safe). So you can use it fully type checked
The day node.js dies I will be dancing on its grave. I still can not to this day fathom why people use it over any web service, other than a desire to not learn a language besides js.
Not sure I follow. Are you suggesting TJ was unwilling to get comfortable with JS?
Is the section on requests/responses really needed? Web developers should know this already... 
Thanks!
Thinking in Java is my all-time favorite: http://www.amazon.com/Thinking-Java-4th-Bruce-Eckel/dp/0131872486/ Also, if you have resources, do take both OJCPs, you'll never need to read anything on Java again. HTH 
[removed]
I used JNA to experimentally paint Swing/JButton using native Qt (Oxygen) style (I still can't believe it sort of worked ;)
Node doesn't have web workers?
web workers, service workers, and anything similar are based on the notion of message passing between processes which do not share memory. They are a useful paradigm to allow javascript to use more than a single CPU to get work done, but are by no means as powerful or useful as java's concurrency tools.
Java programming doesn’t have to be multi threaded. We use Vert.x where I work and pretty much everything we do is single threaded. 
Or that node was the wrong tool. I wasn't there so I wouldn't presume to know one way or the other. My stance is just that wrapping *entire tech stacks* is an exercise in futility. 
Oracles official tutorials are great: https://docs.oracle.com/javase/tutorial/ You can download them in ebook format from (for free) http://www.oracle.com/technetwork/java/javase/java-tutorial-downloads-2005894.html
While we're at it, apparently, Dependency Injection is also a big mistake.
Your documentation should explain how to do everything described in your "about" section. How does this let me scale horizontally? This isn't bad. I might be harsher if I was in the market for a web-cache. What does this tool do that other web-caches don't? Your documentation should be split between what does it do/why should I use it and how do I use it. HTH.
Experienced developers Google everything before doing it. There's a Java library for everything. For this kind thing, Apache Commons or Guava have you covered.
Thanks, this are great suggestions! Let us work on this, we should get it done shortly. Please be harsh :-)
12 years and none have written a patch, must not be very easy/relevant.
I agree, people asking for it could just as well try to write a patch. This is what happens far too little in open source, unfortunately. At any length, 12 years and it's still severely missing, while almost every other IDE does have it.
This is when you fork Eclipse and have a virtually similar fork with just this added feature. EDIT: Grammar. 
Pretty sure that's covered by [Eclipse Oomph](https://projects.eclipse.org/projects/tools.oomph). I know I'm getting prompted in my Mars.2 setup on Windows to store settings in a central space, and they magically apply across new workspaces.
This plus some CDI lib like Guice.