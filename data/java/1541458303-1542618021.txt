Which is probably why that's exactly what it says in the last section: &gt; In your business logic? Probably not. Your business logic is I/O bound, mostly because of the database. 
TL;DR Functional programming shouldn't be used except for secondary roles. Good.
Why and how is that good (or bad)? 
I still maintain: What performance penalty. You haven't shown me one yet. 
actually, functional programming should be used primarily, and you should use profilers to find hotspots in your code before dropping to imperative loops
but not prematurely optimized. getting a 6.5x speedup of code that constitutes 5% of the common runtime of your code is not worthwhile. use imperative loops when you know something is a hotspot (preferably, by testing for them with profiling tools and benchmarks), but use streams for your prototypes
Because old dogs don’t want to learn new tricks.
&gt;prematurely optimized How is this not a tautology? Of course you shouldn't do *anything* prematurely. By definition. &gt;getting a 6.5x speedup of code that constitutes 5% of the common runtime of your code is not worthwhile If something takes 45 seconds to code and saves $1000 over five years, it's not worthwhile? Your time must be really valuable. Sounds like you should be outsourcing optimzation to Asia. &gt;preferably, by testing for them with profiling tools and benchmarks That sounds like it would take longer than 45 seconds, which as we've established is very expensive. &gt;use streams for your prototypes, and use imperative loops when you know something is a hotspot Use streams for prototypes if you find it helpful and use imperative loops when you do it for real. &gt;streams may be faster in the future than they are now Anything's possible
&gt;What performance penalty. You haven't shown me one yet. So you're saying that 8.08 is *not* less than 9.31? If I make the benchmarks more comlex and they show the same penalty, you'll say that they're not complex enough. Shouldn't FP acolytes have links to benchmarks in their favor at the drop of a hat (or at least within a few days)? Kind of suspicious if you ask me. New science has to prove itself before it demands adoption. All the evidence points to FP being niche af.
actually, Python should be used primarily, and you should use profilers to find hotspots in your code before switching to Java /satire
This is fundamentally wrong. You cannot use an executable script to modify the environment in your shell. It has to be sourced.
&gt; How is this not a tautology? Of course you shouldn't do anything prematurely. By definition. and yet you spend the rest of this post arguing that you should prematurely optimize
Hurr durr it's not *pure*. So it's not functional programming! Nope, no religion here. I wouldn't be so against FP style in Java if there weren't loads of people (including on this very subreddit) spamming that we should all just switch to FP style and if there's a performance problem to sort it out later Better???
&gt; Hurr durr it's not *pure*... so it's not functional programming! Nope, no religion here. Functional programming requires referential transparency. That's the entire *point* of functional programming. Vomiting lambda functions all over the place in an imperative language and patting yourself on the back doesn't make it functional no matter how much idiots writing blog posts on medium.com want it to be. &gt; I wouldn't be so against FP style in Java Just so we're on the same page here. Java is a terrible FP language. It's an imperative language with a few poorly bolted on FP constructs. There's a horde of idiots advocating functional programming Java that have no idea what functional programming is, but just assume anything with a Lambda function is FP. Functional programming in Java, as the language exists today, is stupid. In that, I'm pretty sure we're both in complete alignment. But regardless of the merits of FP, or how well Java handles FP, Streams and FP are completely unrelated concepts. The implementation of Streams in Java are optimised for imperative programming. They don't really work very well for functional programming. They fill the same niche as Iterators, which a few extra bells and whistles. Trying debate the pros and cons of Streams by debating the pros and cons of Functional Programming is pointless. 
Exactly. Java is an imperative language. Trying to mix in the latest FP fad is I guess a marketing gimmick. I mean, why the hell do we have Kotlin and Clojure and Scala and the rest for? Aren't those languages supposed to be the shiny thing to distract the crazies from shitting up Java proper?
And threading and networking and probably cryptography
I am trying to run a program provided by my professor. I am instructed to move to the directory where the jar file exists and run: java -jar CSC251LabAlgorithmComplexityRunner.jar The program initially runs, but as soon as I enter an input for the first prompt, I get this: E:\Documents\School\CSC251\Unit12&gt;java -jar CSC251LabAlgorithmComplexityRunner.jar Some operations will require searches. How many searches shall we do for this run? 10000 Exception in thread "main" java.lang.UnsupportedClassVersionError: Utils has been compiled by a more recent version of the Java Runtime (class file version 54.0), this version of the Java Runtime only recognizes class file versions up to 52.0 at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(Unknown Source) at java.security.SecureClassLoader.defineClass(Unknown Source) at java.net.URLClassLoader.defineClass(Unknown Source) at java.net.URLClassLoader.access$100(Unknown Source) at java.net.URLClassLoader$1.run(Unknown Source) at java.net.URLClassLoader$1.run(Unknown Source) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(Unknown Source) at java.lang.ClassLoader.loadClass(Unknown Source) at sun.misc.Launcher$AppClassLoader.loadClass(Unknown Source) at java.lang.ClassLoader.loadClass(Unknown Source) at ProgramRunner.main(ProgramRunner.java:25) Even though I know I have Java 11 installed, when I run java -version I get: E:\Documents\School\CSC251\Unit12&gt;java -version java version "1.8.0_191" Java(TM) SE Runtime Environment (build 1.8.0_191-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode)
This is some of the most ridiculous stuff I've read in a while. There are many cases where if I need 6x as many EC2 instances to handle the processing I might not have a sustainable business model.
What code of yours is constantly processing in a tight loop 24/7? If it's not, you can save a ton of money converting to lambdas that go away when quiet, and evn the code running 6x slow is still quicker than the minimum billing increment.
said every functional programmer who can't write proper object oriented code ever.
Hard to read, refractor, modify, etc. &amp;#x200B;
* Long release cycles (3-5 years between major Java releases) cause problems * New shorter Java releases may not have many changes in the release * OpenJDK is equivalent, technically, to Oracle JDK * LTS is provided by Oracle on Oracle JDK for a fee, but you have to pay * Others (e.g., RedHat) say they'll provide free LTS support on OpenJDK * Here are some proposed improvements ....
You are making a big fat assumption that "prematurely optimizing" will actually save you money in long run. Sorry, but this assumption is false. Let me explain. The code is not just about performance. It's about a large list of non-functional requirements that include "testability", "flexibility" and even "maintainability" along a long list of other "ilities". Nobody cares about saving $1000 on electricity over five years, when in five years it takes you a month to decipher the hyper-optimized code that some great hacker wrote five years ago to make it a tad faster. Nobody cares about saving $1000 on electricity over five years, when the code is impossible to unit-test correctly therefore leading to holes in the code coverage that nobody dares to fix. Nobody cares about saving $1000 on electricity over five years, when to a slight specification change required full rewrite of your hyper-optimized function. I could go on and on with the list, but I hope you get my point. Yes, Streaming API is worse for performance, but the fact is it forces to break your code into fine-grained logical units while keeping the orchestration of those units clean and readable. Even the most complicated stream is much easier to understand on the first glance than an attempt to replace that with an "$1000 saving" imperative loop.
&gt; If it's easier to write fast code than slow code, write the fast code! The only thing worse than premature optimization is premature Rube Goldberging -- spending extra time and effort to purposefully write slow code. Oh god, I really hope you do not write mission critical systems with that viewpoint. I already explained in my previous post, but if my "slow code" would take me 10x time to write, but is easier to test, maintain, explain and read by other developers - guess what, I will spend that 10x time to make it slow. &gt; Also, assuming you have a boss, if you get your code barely running and passing tests, intending to profile it and optimze it at that point, your boss walks by and asks for an update, chances are he is going to say time is money, don't optimize that code. Welp, there's your problem. Try working at a company that actually takes pride in delivering quality software and your boss will actually (wait for it...) allow you to refactor your code when needed! &gt; Also, waiting until the end to see if you've met the performance objectives is a recipe for disaster. You might end up having to redesign the entire thing. You know what would really help in the case of a redesign? A set of nice reusable/rewritable components and a way to orchestrate them in a different way on demand, kind of like what Streaming API provides on a low level. &gt; No premature optimization is a tautological slogan that is accepted as some kind of argumentative trump card. I agree that it's abused a lot. But you need to always think in a context of your project. If I'm building a application centered around complex domain (think of insurance for example) I would sacrifice 1000x performance just to make my code and architecture and system in general as easy as possible to understand as performance is usually not a concern and any attempt to hinder domain model by improving performance is usually a premature optimization. If it's a data-processing application, I would try to optimize it much more straight away but I would not go into bytecode level optimization as that would be premature optimization in this context. But if I'm writing a code for an embedded controller in a factory robot - sure, even some ASM could help occasionally without being called premature optimization. 
Because the java executable is not actually the java executable for any specific version. When you run `/usr/bin/java` it just runs `$JAVA_HOME/bin/java` So swapping $JAVA_HOME is enough. Or you could just run the actual executables right from `$JAVA_HOME/bin/`
Thanks for the feedback, let me know if you run into any issues
Your false assumption is that optimization necessarily negatively impacts testability, flexibility, and/or maintainability. That is an absurd claim to make. That would imply that the more inefficient your code, the more testable, flexible, and/or maintainable it is. No one should actively strive for inefficiency. Your argument is some form of relative privation and tu quoque.
Bless you 
Sorry, Oracle finally got around to uploading their final Javadoc. https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/module-summary.html
Yep, I messed that up. Thanks for pointing out my mistake!
What about switching to parallelism? https://docs.oracle.com/javase/tutorial/collections/streams/parallelism.html
You’re arguing against a straw man. Nobody is suggesting doing things intentionally to slow down the application because performance doesn’t matter. The idea is not to sacrifice readability/understandability for performance until you know you need it. Engineers, not programmers, know that there’s lots of “shitty” code that provide a lot of value for customers and makes lots of money for businesses which is ultimately what matters. Engineers are notoriously horrible at guessing what “good enough” is. I once worked on a project which had a rather large comment about how null checks for things that’s shouldn’t be null were omitted for “performance” reasons in a CPU bound part of the product. That’s the kind of thing that the JVM would optimize away anyway and made it difficult to catch issues when a value that wasn’t supposed to be null accidentally was. 
Different cost centre (ops vs dev)
Is that something proven, that a developer has better performance with streams? Because everybody understands simple loops and ifs and collections are really basic knowledge. Now if you were doing some legacy java app and you look at a modern java, you're really lost. I think there's even a presentation about modern trend of abusing streams.
Be very careful with parallelism. As with every great power, it requires great responsibility
&gt;This is the first TomEE release that provides support for Java EE 8 I'm not trolling or anything, but is there anyone who still uses Java EE? Especially in the light of Spring Boot 2.1 releases with Java 11 support.
I get what you are saying but the study is pretty extensive. Of course there is the possibility of these being cherry picked scenarios. He welcomes PRs tho, so While no one else does any Benchmarks that prove him wrong his numbers seem pretty valid. 
&gt; If it's easier to write fast code than slow code, write the fast code! but the stream API is easier than manual looping, for a number of reasons. your argument is that manual looping is easy enough, so you should go ahead an prematurely optimize and **not** use the stream API
yes.
with RedHat now being IBM, will the free LTS support go away?
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I appreciate that this is a advertisement/tutorial for otka, but ... Has anyone produced/seen a version of this tutorial on using jwt for security instead? I'd rather not depend on an external company for security.
Library code is different regarding optimization. With application code you run it, see that it is too slow, profile it and optimize the relevant parts. With library code, you may not be the one writing and running the applications - it can be users you've never heard of that found your library and tried to use it. In that scenario, the profiling-optimization cycle requires the user to: 1. Identify that the bottleneck is in the library code. 2. Understand that the library code can be optimized. 3. Optimize the library code. 4. Send a PR and get it accepted. 5. Alternative to 3&amp;4 - open a ticket and wait for you to fix it. 6. Wait for the next release of the library. 7. Alternative to 6 - use the bleeding edge version. 8. Alternative to 6 or 7 - depend on their own fork of the library. 1-3 require the user to get familiar with your code - which is not always trivial. 4-6 require them to wait for you do to something - which can take who knows how long. 7-8 are maintenance nightmare. So for library code, the bar for optimization should be lower. You don't need to wait for actual performance issues (which will happen in other people's projects) - recognizing a piece of code as a potential bottleneck is enough to justify optimizing it. I'm not saying that all library code should be hand-optimized assembly, of course. But choosing the more performant API is a reasonable "premature" optimization for some library code.
&gt; I hadn't heard of Cettia before Same here. I think it's pretty neat how it's framework-agnostic. I haven't run into issues where I'd need it yet, but it's good to know it's available. 
I never said that, and your argument is some sort of straw-man fallacy. What I did say, was that spending time on performance optimizations does **not guarantee** savings in project budget over long terms. And I never said anything about "striving for inefficiency", I merely provided few examples of how trying to optimize for performance **can** result in losing money in long run. Again, different projects mean different priorities and optimization goals. Basically, the main thought I tried to convey (and probably failed), is that if you are on a crossroad of either adding "*ility" by losing performance, or adding performance by losing some of the "*ilities", you can not just claim, quoting: &gt; If it's easier to write fast code than slow code, write the fast code! That's absurd. You need to write the code having in mind all of the non-functional requirements at this phase of the project. And if performance is not a top priority for the given project, given use-case at given point of time, why the hell would you still choose to spend your time on "easy to do performance optimization" versus "more difficult, less performant, but much more readable code"(as an example) ?
Yep
IBM is listed as sponsor of AdoptOpenJDK, so I'm optimistic there.
Yes. Not only is it possible that scenarios were cherry-picked; from the descriptions in the readme of the bifurcan project it becomes clear that statistics of its lesser-performant components are ignored and avoided, while those of the better-performant ones are being advertised. This is common behavior for someone advertising their product. It is not common for someone publishing a study that is as fair and unbiased as possible. And no, Tellerman is hardly the only one comparing collection performance and publishing statistics. I would pose that every publisher of a collection implementation has done so. Of course that requires that I back up that hypothesis. And I would. A different time. 
Yep
Angular has a yearly, or bi-yearly, release cycle, I can't really remember which. So the version number is incrementing quite quickly.
Of course he picked the ones that Show his product in the best light. Totally agreeing with you. Just wanted to put some context to your comment for the people who wont click/read the whole thing. It read like He just put some random numbers on his github. The last sentence was badly worded by me. It should read more like 'His numbers do not Look like He forged the results completly'. 
How much of this is because the lists are small? The article does call out these are rather trivial use cases. I wonder how this would look with list size of 100 or even 1000. 
ParrallelStreams are a mixed bag. They can be faster, and they can also be much slower. Experiment and decide as appropriate
&gt; you can do this with library code too. jmh benchmarks for library code is a plus as well The problem is that you don't know how the users will be using your code. You could be optimizing something your users will end up running 10 times per process while neglecting something they'll be running 100,000 times per second. You don't even know what is acceptable and what isn't - you could be optimizing a 1s long function that doesn't really need to be fast while neglecting a 10us function that could have saved thousands of dollars if it was 9us. You can make educated guesses, but you can't know for sure - not like the actual applications that are actually running and have empirical data on how they are running. This is why I say the burden of proof should be lower. &gt; it isn't because the time and effort you spend prematurely optimizing your library can be spent instead on testing and profiling your library By the time it takes to debate whether you should refactor a `Stream.forEach` as a for loop or to write a small test you could have done both.
Yep, obviously.
Yes. Just Tomcat though
It is just your opinion, just based on the fact that you like it. Why do you use Java? Why not another language more functional programming oriented like ML? &amp;#x200B;
Spring Boot can generate executable JARs with its maven plugin but it prepends a bash script to the JAR, allowing you to run it using ./myjar.jar Not sure if it’s something you can replicate any other way.
It looks like in your [submission](https://www.reddit.com/r/java/comments/9upzm4/java_web_crawler/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Google used Apache Harmony as its Java for Android. Most of the work building Apache Harmony was provided by IBM. Harmony was under an acceptable license. No field of use restrictions. Sun would not license JDK or JRE for phones -- without paying them a lot of money. Harmony was an independent implementation effort without any of Sun's (now Oracle's code). Later, during Oracle's lawsuit, one function (9 lines of code) was discovered to be from Oracle's Java code. Since this wasn't worth billions of dollars, Oracle morphed its case to argue the merely re-implementing the APIs is a copyright infringement -- which flys in the face of how everyone understands APIs. &amp;#x200B;
I made a couple pics from Google searches but hot nowhere, hence I came to Reddit. All the "self executable" results eventually lead to configuring the executable class in the pom.xml.
I'll take a look, thanks.
All you need, on any OS, is to associate the .jar filetype to launch as: java -jar %0 or somesuch. In fact, that is all you need to do on Linux if double clicking a JAR doesn't launch it. I tend to NOT "install" java. Just have multiple Open JDK folders lying around (Linux / Windows). I could change the file association once, and all JARs run using my selected Java. &amp;#x200B;
Is something like this not what you’re trying to achieve? https://steveperkins.com/using-java-9-modularization-to-ship-zero-dependency-native-apps/
Looks like it. Stuck on jdk 8 atm though but will give that a read through.
I use scala already, and I put exactly what I advocate into practice on the regular. I use our equivalent of the stream api first, and if I have a hotspot related to said usage then I switch to an imperative approach. Debugging such code is not hard unless you’re trying to do far too much in a lambda. Breaking my code into methods makes that a non-issue 
The logging groups is an interesting feature I hadn't seen mentioned before. 
*Maven Executable Jar](www.baeldung.com/executable-jar-with-maven)
&gt; The problem is that you don't know how the users will be using your code. first, i dogfood my own libraries so there **are** actual applications using them, and I do get empirical data on what issues I'm running into in actual use. second, i have some idea of how they are meant to be used as i specifically design them to be used certain ways. what you're trying to argue is that i optimize my libraries for all possible uses before those uses arise, instead of me putting out a library, a user saying "well this is nice, but i'd prefer to use it this way" and me saying "oh you're right, i'll improve it so it's easier to use that way" or "no i don't think that's a good idea, there's better ways to do that in this library". &gt; By the time it takes to debate whether you should refactor a Stream.forEach as a for loop or to write a small test you could have done both. nah, you're oversimplifying to an insane degree here. i can do much more than Stream.forEach with the streams api, and a majority of the implementation is handled for me, as opposed to me using a bare for loop, which only easily maps to a Stream.forEach. Any chaining, or more complicated Stream usage results in a much more complicated for loop. One that I have to debug too. 
That still required you to run it with `java -jar`
Where did I mention sacrificing anything? They are not mutually exclusive, yet I must pretend that they are, else I'm cast out and branded a heretic
I'm saying that Java is an imperative language and should be used as intended. Using the streaming API by default is like using operator overloading in C++ by default. If you're prototyping, by all means use the streaming api. But code is read more often than it's written and it's run more often than that. Yes, in the extreme case of a horrendously complex series of operations in non-performance critical code, maybe reach for the streaming api. Convenience in writing code should not outweigh understandability or performance. Code should always be rewritten iteratively until it shines. Code is always garbage the first time through.
Agreed.
Someone who optimizes for performance as they go would know that it very often improves readability because it very often reduces the size of the code. It's a lot harder to maintain 100 lines of code than it is 40. Sixty of those lines were removed as premature optimization. Using FP style in an imperative language is almost never acceptable, unless you're porting code from Haskell, working directly with math equations written functionally, or writing online algorithms. The streaming API is just like `var` -- well intended, but ripe for abuse. Junior engineers are going to start replacing every instance of `String` with `var` and hunting down loops throughout entire codebases and replacing them with functional silliness for no justifiable reason other than the syntax is newer so it must be better!
How do you do that? 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Yes! Day in day out! 😚
people using operator overloading in C++ are using it as intended because that's a part of the language proper &gt;you're claiming that the streaming API can simplify complex operations, but that it's harder to understand Streaming API will make a simple nested for loop opaque and difficult to maintain. It's not made for that. It's made for big data number crunching like stream()map()filter()reduce()collect()forEach() If you're inclined to rewrite the following simple, elegant code with the streaming api you should have your head examined: for (int i = 0; i &lt; 10; i++) { int big = i * 10; for (int small = 0; small &lt; 10; small++) { System.out.println(big + small); } }
&gt; people using operator overloading in C++ are using it as intended because that's a part of the language proper i'd like to know what anti-pattern you think the streams API constitutes &gt; Streaming API will make a simple nested for loop opaque and difficult to maintain. It's not made for that. It's made for big data number crunching like stream()map()filter()reduce()collect()forEach() nah, it's p easy to understand &gt; If you're inclined to rewrite the following simple, elegant code with the streaming api you should have your head examined: ... that's elegant? for a guy who's been ranting about how easy for-loops are to write, you seem to have not realized you could have used 1 for loop to achieve the same effect.
It looks like in your [submission](https://www.reddit.com/r/java/comments/9urcra/eli5_what_do_build_tools_do_and_why_should_i_use/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Decoupling of JavaFX from Oracle JDK turned out to be the best thing ever happened to it recently. Now we can use JavaFX in OpenJDK just fine, and the development isn't tied to Java roadmap and release cycle anymore.
Been under a rock for a few months, eh? Check out this for all the relevant info: https://docs.google.com/document/d/1nFGazvrCvHMZJgFstlbzoHjpAVwv5DEdnaBr_5pKuHo/
&gt; . what is a buffer, anyway?
Is google down? https://en.wikipedia.org/wiki/Data_buffer
**Data buffer** In computer science, a data buffer (or just buffer) is a region of a physical memory storage used to temporarily store data while it is being moved from one place to another. Typically, the data is stored in a buffer as it is retrieved from an input device (such as a microphone) or just before it is sent to an output device (such as speakers). However, a buffer may be used when moving data between processes within a computer. This is comparable to buffers in telecommunication. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
&gt; Seriously, people who advocate for functional programming in java seem to have a really hard time writing proper code. Instead of trying to force other programming styles onto Java, how about you actually learn Java? Why do you think I advocate for FP in Java? ;) I think our programming education has a problem. It's heavily biased towards the imperative style and the functional style is largely neglected as "academic". There are good reasons for this, because ours brains are particularly good at doing imperative stuff. Thinking in a functional style requires to develop thought processes that take a while to develop. Seeing why this is important on the long run is not easy to understand nor easy to explain. But people are starting to see the practical value in FP.
By the recent large surveys done. Many many thousands.
LOL a nested lambda! Such elegance, HAHA! And you had to use multiplication. You can't figure out how to do something as simple as +=10? But the worst part is all your APIs are obscure. No one knows what the hell you're doing unless they want to take a tour of the javadoc. They're not keywords like `for`. You even used `var` instead of int. That is true autism. Why take a performance hit just to write something so ugly and esoteric? Makes you feel superior, doesn't it? Like a mom with an ugly baby who tells him he has superpowers.
Thanks so much 
&gt;Why do you think I advocate for FP in Java? ;) You don't advocate for something else in another language that isn't the way that language is made for. Go back to Python or whatever, please. &gt;I think our programming education has a problem. It's heavily biased towards the imperative style and the functional style is largely neglected as "academic". There are reasons for that. &gt;There are good reasons for this, because ours brains are particularly good at doing imperative stuff. Thinking in a functional style requires to develop thought processes that take a while to develop. What "thought process"? The code does the exact same thing, just in a more lazy and brain damaged way than normal. Christ, let's just program in emojis at this point since ya'll don't wanna type those few extra key strokes. &gt;Seeing why this is important on the long run is not easy to understand nor easy to explain If it isn't easy to explain then there probably isn't a good explanation to begin with. By contrast, are *many* good reasons as to why you would want to do things the old object orientated way.
&gt; You can't figure out how to do something as simple as +=10? Sad! Better start a research project into how to accomplish basic arithmetic, because, ask anyone, it's not obvious how to refactor the multiplication out of this in any elegant way. Trivial if you use a for loop. tell me why i should care. oh right, you can't &gt; But the worst part is all your APIs are obscure. No one knows what the hell you're doing unless they want to take a tour of the javadoc. They're not keywords like for. You even used var instead of int. Now you have autoboxing, no? That is true autism. no, why would you think var causes autoboxing? it's not a generic. &gt; Also, you changed the range of big. In my code it's 10-110. In your code it's 1-10. Which isn't big. It's small. So your variable name is now wrong and constitutes a bug. dude, you already made a fool of yourself when you used a nested for-loop for printing 0-99 and patted yourself on the back, [but now you're making a bigger fool of yourself?](https://ideone.com/9o8kCz) Clearly you should switch to the Stream api as you could clearly see what my code was doing, but were totally unaware of what your code is doing. Your code does not go over the range 10-110, it's 10-100. Message me when you figure out how a for-loop works &gt; Why take a performance hit just to write something so ugly and esoteric? Makes you feel superior, doesn't it? But you're the equivalent of a mom with an ugly baby who tells him he has superpowers. cause the intent is way clearer, as can be seen from you understanding my code better than you understand your own code. &gt; Oh, and by the way, your code only works on Java 11! Good luck getting anyone to use it! My code runs on Java 5+ and is more efficient, easier to modify, and dead simple. apparently not so dead simple that you could avoid getting a bug in your code since you intended on doing the range 10-110. Congrats on proving my point so well 
Good find...I'm having this issue with the webapp for docmagic. I tried deleting all .lnk files they had in their public and profile desktop but still no luck. I've even deleted all .lnk files from the entire users directory. How were you using procmon to determine what is causing the error?
What would you like help on? The concept of recursion?
The worry when writing domain specific plugins is that you're resorting to powerful techniques that transcend typical features to potentially mask a design issue. Not passing judgement on the article or the use cases raised, but just something to think about.
This question is better suited to r/learnprogramming (read the rules). That being said, it's difficult to help you without knowing what you've tried, what you know, and where you're stuck. For example, you teacher said to start by writing: ``` public static int factorial(int num) { } ``` That seems like the right starting point to me too. Does it make sense to you why that's what you need to write? Even more basically, do you know what the factorial is? Have you ever written any recursive function? When you move your post to r/learnprogramming, you'll get much better results if you answer the questions I asked above (and other, similar questions). 
&gt;10-110 Who gives a shit. It was 10-110 before I made `&lt;` into an `&lt;=`. My code is trivially modifiable. That's what's so great about it. I can tweak it wherever I want, whenever I want. If you're salty now, you're going to be a lot saltier when I inform you that you fell into my trap. You didn't realize you couldn't throw InterruptedException from inside your shitty forEach(); Your code only runs on Java 11+ and *doesn't even work correctly* Oooh, that's got to sting
I am familiar with factorial, but this is my my first recursion program. To be honest, I don’t understand why he recommends this starting point. I’ve reposted to r/learnprogramming , thanks for the heads up.
So here's a simple function to give a taste of what recursion is like public static void main (String[] args) throws java.lang.Exception { printHello(0); } public static void printHello(int count) { if(count != 4) { System.out.println("Hello "); count++; printHello(count); } } This program will print Hello Hello Hello Hello You'll notice that that the program calls itself, performs the action and calls itself again. Think "Inception" in the sense that you are diving into deeper and deeper layers. So at the end of this, we are 5 layers deep. (Meaning we've called the printHello function 5 times). So if we were to add public static void printHello(int count) { if(count != 4) { System.out.println("Hello "); count++; printHello(count); } System.out.println("exit"); } Outside of the count block, the output will be Hello Hello Hello Hello exit exit exit exit exit We went 5 levels deep, but on the 5th level, the count fails so the function finishes it's execution by printing exit and returning. Then level 4 prints exit and returns and so on. Probably not the best explanation :D but the important bits are there. I can clarify if needed
&gt; I mean, if you really think about it, CRUD functionality is at the core of most applications. So demoing different ways to do CRUD apps provides lots of variations on a common pattern. I don't see "cool" in those sentences
Not at all, we all start somewhere! If you look at public static void main (String[] args) throws java.lang.Exception { printHello(0); } I'm calling printHello in the programs main method and sending it a parameter with the value of 0.
`public static int factorial(int num) {` `if (num == 0)` `return 1;` `else` `return num * factorial(num - 1);` `}` or `public static int factorial(int num) {` `return num == 0 ? 1 : num * factorial(num - 1);` `}` &amp;#x200B;
&gt; I changed it from 110 to 100 to make it beautiful, you mong. and then tried to berate me for implementing the behavior you wrote down instead of the non-beautiful behavior you apparently had before but didn't post? are you stupid? &gt; And sorry I'm not as autistic as you. I'm not going to go back and check the exact range uh, that's kinda part of being a programmer. especially when you're using a for-loop like you were. guess we know to avoid your bug riddled code huh? &gt; when I'm having too much fun beating on you about your variable name bug. there isn't any bug you've demonstrated &gt; Let me know when that code of yours compiles. [it compiles](https://i.imgur.com/H7fE1k7.png) about the same [as yours](https://i.imgur.com/XVPJQBD.png), by adding a try/catch block around the Thread.sleep. I didn't bother to include it in my code, cause why bother when you neglected it in yours?
&gt; Go back to Python or whatever, please. You misspelled Haskell. &gt; If it isn't easy to explain then there probably isn't a good explanation to begin with. By contrast, are many good reasons as to why you would want to do things the old object orientated way. "It is the bias of modern Western language and culture towards objects, rather than towards relationships, that assigns precedence to objects over morphisms ." - [JA Goguen, A Categorical Manifesto (1991)](https://www.cs.ox.ac.uk/files/3395/PRG72.pdf). I'm not going to enumerate reasons why functional programming matters, since I don't believe that you will listen anyways. 
No, it was 110 on my scratch paper, you crackhead. You repeatedly jump to conclusions. No wonder your code sucks. Sorry, but making fun of you on the internet about your variable names is not programming. It's just as fun, though. My code doesn't need to catch it. I can throw it. That's my entire point. Good luck figuring out how to handle exceptions with your nested lambdas.
Isn't that mostly normal behavior? Having to toss like primary annotation on one to prevent it?
Here, try [this Reddit post](https://www.reddit.com/r/java/comments/9uswg4/recursion_help/) it might help.
If you can compile your game into a jar, you can make that jar available to download to your classmates, via Dropbox for example. That's one possible way of many... 
You can look into Java Sockets, NIO, or RMI if you want to create a client application that connects to a server. Or you can get into Servlets and present a game through HTML pages. Either will require a server of course, so if you aren't familiar with setting up your own then you can probably get a small linux box for cheap from DigitalOcean or Amazon Web Services. There you can install Java and then run your game. The issue is how you want your players to connect to your game, which is where the first few suggestions come in. It's possible to just let them SSH into your server and run the game through a java command, too, though not really ideal.
What is it with people and DTOs, why would you add another layer of complexity. 
The "download and delivery" issue for Java is one that [Java Web Start](https://docs.oracle.com/javase/8/docs/technotes/guides/javaws/) partially resolves. That *only* covers the "how do you get it down to your machine and run it" issue - it doesn't resolve the "there's a server out there somewhere to maintain game state and make sure clients aren't cheating" Note that this is a fully functional stand alone Java application that exists outside of the applet sandbox. To that end, it makes me personally hesitant to run any JWS application.
Sample is what if you were sending this back as a response, maybe the consumer doesn't need all the fields from the DB. You send only the fields needed.
It's the modern day version of the EJB crowd from the 1990's and the Hibernate crowd from the mid 2000's. More layers must be better.
can you elaborate? 
Awesome, thanks!
It looks like in your [submission](https://www.reddit.com/r/java/comments/9uwaba/java_web_crawler/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Unfortunately, Java Web Start is gone starting Java 11. Depending on OP's university, it might still be okay to use Java Web Start as the university computers may have Java installed. &amp;#x200B; Another route, depending on what OP is allowed to use, writing with a library like libgdx will allow the game to be packaged into a webpage powered by JavaScript and all that is needed is standard hosting.
It looks like in your [submission](https://www.reddit.com/r/java/comments/9uwouf/error_messaage/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Adding Primary to one is not enough, they have to have different names.
Make sure to check the public desktop too. Anyway: I simply filtered the procmon output to just show me everything from "jp2launcher.exe", opened the .jpnl file, waited until I got the first error message, cleared the procmon output, clicked "OK" on the error and as soon as the next error message popped up I stopped procmon from logging. So at that point I had exactly all that happened between two error messages logged. Then I simply filtered out all "SUCCESS" entries, because who needs those when checking for errors, right? :p And what I got was a quite small list with one sore thumb sticking out. A few "ACCESS DENIED" entries to a path one "broken" shortcut was pointing to. That was because the user didn't have the right to access that file or path. Removed that shortcut and everything worked fine.
&gt; LOL, you did, dummy. You forgot to rename the variable to something that made sense when you converted +=10 to * 10 because you didn't know how to do +=10 you were just talking about autism, and you're saying my code sucks cause i left big named big? wow &gt; What's the bug in my code? It throws an exception. That's what it's supposed to do. it doesn't compile. also both small and big's ranges are off (according to you) &gt; Add public static void main etc yourself. that doesn't get it compiling stop making a fool of yourself
The problem is not DTOs, but how domain classes are designed. They should have properly typed properties rather than use base types like `String`. DTOs are interface dummies with raw types for deserialization that still need to be translated into the domain. However, many types have automatic conversions from `String ` so more often than not, you might as well deserialize into the domain object most of the time. 
Aside from Java Web Start you can also use [JLink](https://steveperkins.com/using-java-9-modularization-to-ship-zero-dependency-native-apps/) to ship a 'native' application, assuming you're on Java 9 or later. 
Yup. It's actually very hard to come up with a production scenario where you're doing tight in-memory loops on anything. And in these types of situations where it actually does matter you should just benchmark the different implementations with JMH. 
It's not so simple though. I tested a couple of few variants of a simple for loop that sums a whole bunch of integers into a single long value, trying to change only the way the iteration is performed. The test implementation was as follows: private static void test1(List&lt;Integer&gt; list) { long[] obj = new long[1]; list.forEach((x) -&gt; obj[0] += x); } private static void test2(List&lt;Integer&gt; list) { long[] obj = new long[1]; for (int i = 0; i &lt; list.size(); i ++) { obj[0] += list.get(i); } } private static void test3(List&lt;Integer&gt; list) { long[] obj = new long[1]; for (int i : list) { obj[0] += i; } } I got identical performance out of all 3 routines regardless of the size of the list, down to just 2 elements and up to 1000000 elements. I warmed the hotspot for some time for all of these, and I guess it can figure out that these particular iterations all mean the same thing. For most of the values, the classic for-of loop in test3 was a bit slower, though.
I just tested it and at least on jdk11, I think streams optimize better than the for-of iteration loop. Simple iteration like `list.forEach(x -&gt; { ... })` seemed to execute some 30-40 % faster than `for (T x : list) { ... }`. I was careful to avoid a few pitfalls, like I let the JIT warm for some time, I did test that lasted several seconds to execute, and I chose the minimum time for iteration of test to report, though it may be the case that some methods produce more garbage and it would be fairer to factor that in by using the average runtime after a warmup period and it would make sense to test performance in multiple heap sizes. Still, I can't say that I agree that functional approaches immediately are much slower, and certainly not by some huge number like 7x. It all boils down to how well the JVM manages to optimize whatever the loop body is doing, and for at least some cases there won't be any noticeable difference because it figures things out. A particularly suspicious fact of the article is that the list lengths were quite short, such as just 2 or 8 elements. I examined the behavior on lists of 2 elements myself, but saw times for iteration that differed very little between the chosen idiom of iteration, so I can't agree that streams have huge setup costs. Again, this is probably all about letting the JIT have a chance to figure out what the stream is actually doing. The fastest iteration method was this according to testing: `for (int i = 0; i &lt; list.size(); i ++) { ... }` but it was only slightly faster than a stream.
&gt; Debugging such code is not hard unless you’re trying to do far too much in a lambda. Breaking my code into methods makes that a non-issue What does it mean "too much in a lambda"? Functionnal programming is a style of programming independant of the quantity :-) Therefore there is not too much &gt; Breaking my code into methods makes that a non-issue Oh my god! You are so good at programming. The earth is listening to your advice! Functionnal programming is so gooooooood. Why you do not use pure functionnal language? Like Lisp or ML? 
Do you know what etc means? It means et cetera. It's Latin. Or you don't know how to write a method signature? I'm not going to write your boilerplate for you. Take a class. Ask your Intro to Java professor. But, no, you can't be that stupid. I guess your computer is the retard. Stop using JDK 1.4 and upgrade to at least 1.5 (you know, from 2004)
Nice. Though in `test2`, doesn't `.size()` get called unnecessarily every time through the loop? It does when I'm running the debugger at least.
But with different names , the qualifiers don't will be necessary, right ? The same as well @Primary annotation use..
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
JavaFX has a process for creating executable installers for different OSes but it's kind of bloaty. It's too bad that you are stuck with java 8 because with java 9 you can create a trimmed down version of the jre that which you can then do a self-extracting zip hack to create an executable that will run your jar file upon extraction. &amp;#x200B; So the trade-offs you have are: Java 8 (using the JavaFX-like generation process): "easy" generation, large file size (a simple hello world app would be about 78MB) &amp;#x200B; Java 9 and up: somewhat-convoluted generation process, small file size (a simple hello world app would be about 13MB)
You still would need the Primary or qualifiers if you autowire the beans via common type (either having more beans of same class or common interface).
Yayy, another difficult-to-test-without-writing-a-harness-for-both-sides glue code class. Not sure about others but I tended to using tools like DI so I could stop writing and maintaining those. I do see why you might like it, esp if you only have a small handful of instances you want everyone to get easy access to. 
For a small app or ecosystems, it is probably a waste. However, it is about contracts and the ecosystem. I prefer DTOs at my application boundaries for 2 reasons. * So long as I can make my DTO, I know I've got the same object model contract I previously had. Which means it should serialize the same and look the same at the boarder regardless of what I do on the inside. * Something called a "DTO" should give me and other devs much longer pause before deciding to add/remove/rename fields. That can inform decisions related to code refactoring and restructuring. Now, both points can be addressed by careful conscientious programming. In fact, with a clean code base, it probably isn't a necessity. But for my legacy systems that I'm dealing with, it is about the only way to sanely move forward without unwittingly breaking a bunch of things. I have the unfortunate pleasure of dealing with a inheritance tree nightmare project where seemingly minor changes have profound effects on the contract. Unfortunately, through the 7th circle of hell, one object does everything from being a marshal to implementing core business logic. This is where the DTO comes into play. I can put that at the boundary and have at least a semi reasonable guarantee that I won't break my companies external consumers of my APIs.
I use final on constants, and implementation classes/modules that are not public/protected/exported that I know I won't be extending. For visible implementations I use final at the class declaration level usually to prevent developers from overriding methods that should not be overridden as well as preventing accidental field hiding (where you have a field in the subclass that has the same name as the field in the super-class). Essentially, I use final for developer purposes only, IIRC it is possible (at least in versions of java before 9) to reassign final fields using reflection, so don't expect final to make things immutable. The only type of object that has inherent immutability from the perspective of the JVM are strings in the constants pool which end up in the string pool at runtime. If you want things to be immutable you'll need to return a new instance of that object any time some "modifying" operation occurs on said object with modified data (which there are many many ways of doing this). Also keep in mind that you can't proxy a final class. Lots of frameworks use Proxy objects (hibernate, mockito, spring,...etc) so keep that in mind. 
Don't use a DI Framework; reimplement your own using singletons and static methods.
Ah yup. This "pattern" is what I've seen some at my company cling to. It is disastrous when it comes to testing.
I am seriously wondering if I'm doing something wrong with DI or if it's everyone else, because I don't understand the hate for them. I like having all the class's dependencies listed in one place (in the constructor), and annotated with `@Autowired`. Sure, Spring can be slow to start up, but I don't do it that often.
Don't use singletons.
And there's no reason why you can't mix both with Spring. 
I think you misunderstood my comment and/or didn't read the article.
There's nothing wrong with doing DI by hand. Same constructors, no @Autowired. But whenever I do that, it takes like 5 minutes before I start to miss all the nice things Spring offers. @Transaction, WebMVC controllers, meta annotations etc pp.
I guess I missed the /s then.
&gt; Sure, Spring can be slow to start up, but I don't do it that often. Apart from that you can really tune Spring startup if you pay attention to the kind of Proxies spring has to create. AOP proxies can be an overhead. But even normal classes can kick Spring into creating cglib based proxies. Basically whenever Spring has to deal with bean injections based concrete implementations and not interfaces. Just creating interfaces for your spring beans can really speed up startup. 
Presumably there's nothing stopping Spring or Guice implementing their own annotation processor to get compile time errors too? That's the only thing that's special about Dagger, right?
Personally I think its an offshoot of a common programmers dilemma of the devil you know (your crap) vs someone else's. Most devs feel more comfortable if they understand how things work but DI is implemented 1000 ways and documented in ways that assume the reader knows both DI and the DI system at hand without many great primers. This coupled with a couple bad experiences with DI (really how many shops do you see violate SOLID rules ALL the time making DI a shit show and a bandaid for all things bad?) and I can see a younger dev being gun shy on DI, maybe even hating it. I would suggest to anyone with little DI experience that has a hate on for it to do some deeper looking at it. Not just because it is helpful but because use of DI has become so common that unless you are writing your own stuff from scratch you are going to have to live with it, like it or not. 
Yeah, sorry about that.
&gt; Seriously, people who advocate for functional programming in java seem to have a really hard time writing proper code. My experience is exactly the obvious. The people who kept refusing to use the new functional constructs in Java 8 and later were the ones that were really stuck in their ways and pretty much refused anything new. 
I'm not familiar enough with spring, but for Guice it isn't possible. The problem Guice has is that it configured/used at runtime. The reason dagger can validate the dependency graph is because you define injection entry points as interfaces (Components) which have the modules that will be provided along with the classes that will be injected. This allows Dagger to search the tree and say "You'll ask for a Foo, which require a Bar, which is provided by module Baz". Guice doesn't know if you'll ever inject a Foo or add module Baz. For example, you can create child injectors at anytime in guice. Maybe that child injector adds module Baz and injects Foo. That is fine. Maybe a child of the child of the child does it. Etc. Halting problem would need to be solved to figure this one out. My suspicion is that Spring is the same way, but I don't know that for sure having never used it.
Instead of using Alpine and then adding glibc, I'd suggest to just use a minimal image of one of the established distros, e.g. registry.fedoraproject.org/fedora-minimal:29 or the RHEL/CentOS counterparts. Clocks in below 100 MB and you got a very mature base, even with support if you like.
I tend to agree. Unless your code is fairly simple and do not want to deal with the complexity and/or bulk of a DI framework this is a solution for a problem that does not really exist. For me, having a DI framework that does all this for me with hooks pre-built for testing is worth the weight. My code never stays simple for very long so this approach would tend be be throw away code at best.
&gt; My code never stays simple for very long Every professional dev should always remember this! If what you are writing is useful it wont be simple for long, either start with tools like DI or shove them in as quick as you can the second it looks like you are going to live with this code.
great bundle of books, it contains a bit of everything. basic java, EE, spring, android, ...
if you never programmed before i would learn the basics with python, because the language is very minimal in syntax that could otherwise confuse you. once you get a hang of the basics, move over to java.
It looks like in your [submission](https://www.reddit.com/r/java/comments/9v0oxe/java_web_crawler/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I will check it out. Thanks
Full of sarcasms! Hahahaha
Interesting concept, too bad it doesn't seem to have caught on. Heads up - the article is from 2001 and many of the reference links are broken.
I'm curious whether the plan is to create Solaris builds for both sparc &amp; x64 or is it for sparc only?
This article is 17 years old. The patterns may be the same, but surely there must be better and more modern libraries for this out there.
Yes. Still, test2 is already the fastest of the tests. It could be made slightly faster yet. I think that Java's memory model should allow inlining the method, because there should not be any synchronization in the hot path, and this should allow the JIT compiler to cache the value, I think.
A more modern approach would use annotation processing to generate the code at compile time. /u/nfrankel wrote [this article](https://blog.frankel.ch/programming-by-contract-jvm/) recently. There's https://github.com/nhatminhle/cofoja, but I don't know if it can generate documentation. I tend to use Guava's `Preconditions` for, well, preconditions. They have a `checkArgument()` and `checkState()` for checking, but as this is in your code, it can't be used for documentation and it can't be disabled at compile time or runtime. 
Sure. Still, you made it sound like as if use of streams anywhere is a mistake that you will pay for in terms of performance, when in fact streams appear to be capable of running faster than for-of iteration, based on the testing I performed today, at least in some cases. Of course, the tests form Angelika were done in 2015 using Java 8, and it's not unthinkable that there have been significant improvements in performance of streams at C2 compiler, or elsewhere. Or it may be that the methodology used in testing had neglected to account for something important.
Both once we get the hardware
[removed]
Just my opinion: Spring DI is not very good, and might explain why you don't like it. Try an alternative DI library (like Guice) and you might see how good it is.
Nope, I most definitely did not make it sound like that. That's what you're reading in the article, or perhaps in the title? Also, about your benchmark 1) Can you maybe run that with JMH just to have more reasonable results? 2) You're not comparing the same thing as in the article. You're using `ArrayList.forEach()` whose implementation is a simple for loop. I haven't checked for any intrinsics. Again, please use JMH Notice that I think Angelika at the time also didn't use JMH.
I personally think, that Java is not the best language to enforce that. There are languages designed around that like [Eiffel](https://en.wikipedia.org/wiki/Eiffel_(programming_language)). Though looking at cofoja, I see one of the best implementations I have seen so far.
You realize that your method signature is wrong? It won't work unless you change it. I'll give you a hint. It needs something on or about the right side... Write your boilerplate like a good little boy. Hint number two (since I know you're having extreme trouble): you need a reserved word and a non-reserved word. The reserved word is not very long and the non-reserved word is longer than it.
&gt; You realize that your method signature is wrong? it isn't. it was a pregenerated hello world main method signature by intellij. it wasn't even written by me. the ```System.out.println("Hello world");``` at the end should've clued you in to that again, stop making a fool of yourself. right now you look like the dumbest programmer i've ever met, and it's entirely cause you can't stand that you fucked up your argument and are madly scrabbling to try to get a win in. stop digging that hole and smarten up
Java friendly scripting: use Groovy.
Coding in comments instead of actually coding it. Useless, event at an academic level.
So are you asking how to package up a java application so other people can play it? Or are you asking how to make a web based game?
The use of DTO's don't bother me, the use of stupid libraries like MapStruct and Orika to map DTO's to/from Entities drives me nuts. 
So what you are saying is a developer needs to have a deep knowledge of the inner workings of Spring to get good performance? 
First, you missed the sarcasm in this comment. Secondly, singletons have a place and it is just dogmatic nonsense to avoid them.
This singleton approach is straight out of the early 2000's.
&gt; Secondly, singletons have a place and it is just dogmatic nonsense to avoid them. .. say the people who rely on them as a crutch..
For optimal startup performance. Overall the performance is good as it is as the runtime overhead is negligible. 
Take a look at CBOARD. Its easy to use and drag n drop functionality. It can connect to any JDBC compliant DB, NOSQL etc . You will be able to build any reports/dashboards as long as you can have a query to fetch the data. &amp;#x200B; [https://tuiqiao.github.io/CBoardDoc/#/](https://tuiqiao.github.io/CBoardDoc/#/) &amp;#x200B;
No Java SDK that I'm aware of has any kind of license key like you are describing. There is no need to activate them. However you should check that the version of the Java SDK that you use is allowed to be used in production. Use a Java SDK from [https://adoptopenjdk.net](https://adoptopenjdk.net) and you are guaranteed to be able to use it to do whatever you want, for as long as you want.
Yup. Jax-RS is awesome (what dropwizard is based on).
No updates from Oracle on Jdk8 after January. 
Why don't you think it's any good. Why is Guice better?
The article links to a page on oracle.com. If you follow the link and scroll down it says: &gt; Oracle will make available to Commercial Users and Personal Users updates to publicly available versions of Oracle Java SE in accordance with the table below. Once a Java SE version reaches “End of Public Updates”, any further updates will be available only to Customers and accessible through My Oracle Support and via corporate auto update where applicable (Visit My.Oracle Support Note 1439822.1 - All Java SE Downloads on MOS – Requires Support Login). In other words, to get updates for Java 8 from Oracle, you need to be an Oracle customer with a support contract.
You might take a look at AdoptOpenJDK if you are stuck on Java 8. You have a choice for a bunch of different versions as well a choice between Hotspot and OpenJ9
"No more security updates from oracle" to be more precise. /u/Carl_Byrd I recommend reading https://medium.com/@javachampions/java-is-still-free-c02aef8c9e04 
As far as I understand it, there is not going to be ANY sort of free LTS releases from Oracle anymore. That includes JDK 11. Free support will end in March next year for 11. Only paid licenses get extended support. There are, however, a lot of open source stakeholders that are saying they will continue working on free releases for JDK 8 and 11. IBM and RedHat for instance. So, it should be fine sticking with 8 for a couple more years. A great summary here: https://blog.joda.org/2018/08/java-is-still-available-at-zero-cost.html?m=1
Thought the same...
His use of Boolean makes no sense. This is why Optional exists.
Backwards-compatible in a technical sense yes, you still can't drop it in and run unchanged as certain modules are removed - yes it just needs addition dependencies added to the classpath and that means the code is compatible both source and binaries, just not deployment compatible. That alone can still cause people problems.
By default Spring services are singletons, are you saying Spring is doing it wrong?
Pre-conditions are an important piece of documentation, as are invariants. Code can not be easily be pulled out into the documentation, meaning either they're not documented or the information is duplicated (and possibly out of date). A modern approach would use annotations, but they didn't have annotations 17 years ago.
We're taking about two different things. Spring singleton beans are not GoF singletons.
The modules were only dropped in 11, two versions after jigsaw was introduced. I can't use 11 with EE stuff now because nothing has included those missing parts in their code yet, while 10 works fine (but already out-of-support)...
I thought 9 and 10 shipped them but they were disabled by default? So you'd still need a bit of runtime tweaking..
That article is so long and full of nonsense. Rather read this one [https://developers.redhat.com/blog/2018/09/24/the-future-of-java-and-openjdk-updates-without-oracle-support/](https://developers.redhat.com/blog/2018/09/24/the-future-of-java-and-openjdk-updates-without-oracle-support/) by Andrew Haley, current lead of OpenJDK 7 and most probable lead of OpenJDK 8.
It's a common mistake to think that Spring creates proxies for everything. It does creates some proxies when you ask it to - with @Transactional annotation for example. But if you doesn't use aspects there will be no proxies at all - just reflection created objects of your classes.
Do you guys have tests?
&gt; Unfortunately Why?
Yeah, but then again there are a lot of situations where it suddenly starts to create proxies where it didn't use to because you just created a circular dependency.
What is a singleton in Spring?
Are you sure you don’t mean switching to java 9? The class loader strategies and modularization have drastically changed, compared to java 8 and earlier versions.
I've never had a problem moving from one JDK release to another before Java 9. Usually it means "we don't want to go through the hassle of installing new JDKs on the server and configure the app to use them". If you have tests you should have no concerns about migrating to Java 8. Releases after Java 8 have extra challenges, but they are usually fixed with adding a missing dependency. You can mostly ignore the module pay for now. Mostly. There was an issue with Java 9 changing an exception (but not the documented API) which might affect some people. You also need to be vigilant about deprecated classes and methods because they may be removed. (Going forward, you should regularly run your tests on the most recent release of the JDK so you have less work to do) TL;DR? Upgrading JDKs is significantly less onerous than with many other languages.
Yes, you're talking about GoF singletons and almost certainly shouldn't be used. /u/wildjokers is talking about singleton scoped beans, which bear no resemblance to GoF singletons.
It is just adding a dependency to your pom.xml or build.gradle. :)
I upgraded a very large commercial software product from 7 to 8. For the most part it is a drop-in replacement, you will only face an incompatibility if you are using very specific features. See Oracle's adoption guide: https://www.oracle.com/technetwork/java/javase/jdk8-adoption-guide-2157601.html For my case, later versions of Java do things to be more secure, so some things that were allowed in 7 were not allowed in 8 (security manager and certain network functionality come to mind). I HIGHLY recommend migrating to 8 and beyond. Besides your need for security updates and bug fixes, lambdas alone are worth it!
They are almost always slower. You have to be doing quite a bit before you brdge the thread management/context switching overhead. Only cases I've seen get faster with parallel are streams involving IO.
&gt; IBM and RedHat So just IBM. 
Apart from what others have mentioned, you can have entirely silly things break, like code that tries to parse the Java specification version string and expects it to be of the form 1.X - which was true up to Java 8, but since Java 9 they dropped the "1." part. That even happened in Apache commons-lang. Then you can have bugs introduced, e.g. Java 1.4 added a sanity check in the date parsing logic of java.util.Calendar that assumed daylight savings time could be at most 1 hour - which is true in *most* timezones but not everywhere always. Java 1.4 also overhauled the focus subsystem in AWT/Swing, which caused some code in my company (which may or may not have depended on unspecified behaviour) to get into an endless loop. So yeah, any version change in a complex component like the JDK can break your code in many ways. But "everything will break" is a ridiculous exaggeration. There might be an issue here and there, and you need extensive testing to identify those. But you need that anyway for your own releases.
Meant to reply to him, not you.
Docker ftw
Let's recapitulate the discussion /u/dpash and I had down there. The Spring singleton scope is the default scope because you most often only need one spring bean of a type in your application. The bean implementation itself however is not a singleton implementation in the "Gang of Four" singleton sense. The spring singleton scope is about *usage* and not an intrinsic property of the implementation. The GoF singletons are instance controlled java classes with a private constructor and one static instance. If you use these and suddenly need more instances of something, you're fucked. Same goes for not using factories where necessary and creating all kinds of objects all over the place. These questions of state and object creation are very fundamental to a good application and choosing singletons etc will bite you in the ass more often than it actually helps. And we haven't even started talking about testing. 
Why would you move to 9 when 11 is the LTS release?
A lot of the time the difficulty lies in third party libraries that you're project depends on. You can't upgrade your own project without upgrading all third party dependencies. Upgrading third party libraries can be a beast on their own if they aren't backwards compatible, etc. Agreed that upgrading to Java 9 is a different animal because the foundation has been changed in a big way.
In some cases you might have a third party product that depends on bytecode modification or other post-processing that might not have been updated to the latest version, but in those cases you should be very much aware of that. Also, other "minor" changes can trow you for a loop such as when they switched how mergesort worked in Java 6 and it broke quite a few pieces of software. As always. Good tests will help you find problems.
or if you're using limux just switch to your inbuilt openjdk
I don't understand the Hibernate hate. All non-trivial abstractions, to some degree, are leaky. It doesn't solve all data access problems, but it works great. And, if you take the time to understand _how_ it works, you can tune it the round peg to fit in most square holes. ;)
No they aren’t. If you want paid support, you pay for a license. Otherwise you use OpenJDK or another free distribution. I don’t understand why people are still confused by this. 
Usually it's an ops issue. There's a specific version installed in the datacentre and nobody is willing to pay to update it. Until JDK-8, Upgrading was for the most part, a simple drop in replacement. Now that Oracle seemingly hell bent on pushing people away from Java, not so much. - Lamdas suck if they're over used. - Now the change to the license - The new release cycle is not particularly viable for a mid-large size legacy application. I've seen testing phases run longer than 6 months. And they wonder why Node et al are gaining traction. :-(
I find it odd how you mention these gripes and say how it is driving people away from Java but then suggest Node as an alternative like it fixes these problems. Setting aside the languages themselves, where’s the difference between using a free, open source distribution of Java without paid support and a free, open source distribution of JavaScript, also without paid support? They even follow a pretty similar release schedule, with a major release approximately twice a year. 
I work in a big company in the finance sector and we maintain a company internal application. We recently upgraded from JDK6 to JDK8 (jokes on us with JDK11 having come out... but well). &amp;#x200B; The big issues are when you are using other third party software / libraries in your code that hasn't been updated to use the new JDK version. In our case this one third party component is a huge and highly essential part of our application. Changing the JDK meant that it basically didn't function anymore. The whole migration actually took around 1 person year of work involving multiple team members. &amp;#x200B; The problem comes form newer JDKs removing certain features which then break existing older code. You don't really have such huge issues if all your code is written by yourself. But if you use other libraries from 3rd parties that don't even support you anymore then you are kind of stuck with fixing and patching software you don't even fully understand. And as always. The bigger the company the more work you generally have with such changes. We actually just rolled out our JDK8 version for the first time and there are already issues arising. 
I never stated Node solved anything, It's just what came to mind. Also, Applications done in Node aren't the same type of beast as a mid-large scale Java application. 
You’re correct. My comment was about the possible wrong version the author mentioned. I was simple pointing out the first jdk that introduced cutting changes. Java 7 and 8 are pretty much interchangeable. From 7 to 9 it’s a bigger hassle.
Yes, I’m aware of that, which is why I thought it odd when you said “And they wonder why Node et al are gaining traction”. If Node isn’t being used for the same type of applications as Java, then your perceived issues with Java aren’t driving people to Switch to Node in the first place. 
They're on Java 7. Docker wasn't even a glimmer in someone's eye at that point. I use Docker for choosing between different JVMs, but Docker is not going to help OP at all.
You can just change to Java version to 8 and watch what happens. In this case tests would help you a lot to see if anything still work.
Building a docker infrastructure is arguably more involved than upgrading from Java 7 to 8.
Because it's convenient for them to say: "Evil Oracle forces enterprise to pay fees" -&gt; "Another reason why Java sucks"
The RH article has _no_ substantial information. What's wrong with "Java Is Still Free"?
Your statement is a sideline to the problem. A lot of us cant change our JDK/JVM and we are being forced into a license schema. Not all of can change.
&amp;#x200B; Suppose I have a Java 11 build for Linux from either AdoptOpenJDK or Open JDK Build. &amp;#x200B; [https://github.com/AdoptOpenJDK](https://github.com/AdoptOpenJDK) [https://github.com/ojdkbuild/ojdkbuild](https://github.com/ojdkbuild/ojdkbuild) &amp;#x200B; NOTE: there are other places to get prebuilt Java: [http://www.azul.com/downloads/zulu/](http://www.azul.com/downloads/zulu/) [https://jdk.java.net/11/](https://jdk.java.net/11/) [https://developers.redhat.com/products/openjdk/download/](https://developers.redhat.com/products/openjdk/download/) [https://github.com/SAP/SapMachine](https://github.com/SAP/SapMachine) [https://bell-sw.com/java.html](https://bell-sw.com/java.html) &amp;#x200B; Now suppose the path to these two Javas are in my home directory at: &amp;#x200B; /home/danny/Java/AdoptOpenJDK 11/jdk-11+28 /home/danny/Java/OpenJDK build 11/jdk-11.0.1-ojdkbuild-linux-x64 &amp;#x200B; I try double clicking on a JAR, and my Linux desktop opens it in the archiver instead of launching it. &amp;#x200B; First: right-click --&gt; Properties, and make sure it is executable. &amp;#x200B; That still doesn't fix it. &amp;#x200B; right-click (on jar file) --&gt; Properties, (In Linux Mint) I pick the "Open With" tab, I put in a custom command: &amp;#x200B; "\~/path/to/java" -jar % &amp;#x200B; (note the double quotes because of spaces in the pathname) &amp;#x200B; Then I click Set As Default. &amp;#x200B; Now double click the JAR file and it launches. &amp;#x200B; &amp;#x200B; There are ways on Windows to associate a file type, such as \*.jar with a specific executable to open it with. &amp;#x200B; Now if I suddenly want all my JARs to launch with a different Java, I can simply re-associate it with a different java binary in a different path. &amp;#x200B; I DO NOT have java "installed" on my Linux system. It is just lying around in a folder. Furthermore, my associate of JARs with a particular java runtime affects ONLY ME and not other users (if there were any) on this Linux system. &amp;#x200B; &amp;#x200B;
Why can't you change your VM? Come 11, there is no difference between Oracle and open jdk.
You aren’t being forced. You can choose not to update and stay on Java 8, as long as you are happy with not receiving security updates. If you want the updates, you need to pay for the support. The same is true for plenty of products - if you want to use an old version that is no longer the current LTS release, you either do so at your own risk or pay for the support. I don’t understand what is controversial about that. This also has exactly the same outcome as ever other Java major release. Java 7 was end of lifed in 2015. Companies that still wanted security fixes can pay for extended support through to 2022. So if you can’t move from Java 8, it seems you are in the same position with the new changes as if you couldn’t move from Java 7 four years ago.
Yes there is gwt that is compiled to javascript 
Dont fix it if it aint broken brother. 
For security updates AFTER is EOL. OpenJDK still provides updates for free
I guess it depends on how many applications and servers need upgrading, what technology stack you run on, and what sort of risk tolerance you have. If you are in a fortune 500 company, - Do thousands of applications that need regression testing across dozens of departments? - Do you have an automated regression suite to run against each environment? Is there any level of manual testing? - Do you have dozens of operations teams across different departments - Are you running on a mashup of various Linux flavors (Alpine, RHEL, CentOS) or various versions of each? - How automated your platform is: - Are you using AWS, Google Compute Cloud? - Are you automating your own infrastructure through Docker, Ansible, Chef, etc? - Are you manually configuring your VMs almost 'by hand'? - How risk-tolerant are you? Do you run medical software? Billing software? Stock exchange software? I wouldn't be surprised if there were a lot of companies that size still running 5-year old versions of RHEL with java 1.6 on VMs built with custom settings from 10 years ago that people are simply afraid to touch because there isn't a point of contact for whatever software is running on it.
Scala.js with your choice of backend(I'd recommend http4s) is hard to beat. Only clojurescript comes as close to having the ecosystem Scala.js does.
i'm waiting for /u/lucaseder to make joojs or jooDOM !
Be aware that it isn't until Java 11 that the OpenJDK and Oracle JDK are essentially the same thing. For prior releases like Java 7 there were some proprietary bits missing. May or may not be an issue depending on the application...
"I love Java because I don't C#"
/r/programmerhumor
Relatively much stuff can break when updating from 8 to 9 or higher because 9 introduced modules which prevents lots of unsafe access to internal classes by default. It also introduces some changed behaviours, for example when reading/writing XML with preserving whitespace. Other than that, I don't expect breaking when updating from 7 to 8 or from 9 to 11 or something.
Vaadin is based on GWT.
When upgrading an application, I found out the hard way that Oracle Application Server doesn't run on Java 8 or newer.
Ktor
Don’t download Java from there. Those are the Oracle JDK builds. The free, OpenJDK builds are available on [](jdk.java.net).
Try the [search function](https://www.reddit.com/r/java/search?q=Java+Packt+book&amp;restrict_sr=on&amp;sort=relevance&amp;t=all). This exact question has been [asked a few days ago](https://www.reddit.com/r/java/comments/9t21s0/is_the_current_java_humble_book_bundle_good_for/). The initial submission &amp; discussion [is here](https://www.reddit.com/r/java/comments/9sfnvz/humble_book_bundle_java_by_packt/).
Another option to look at is using a language + web framework. Elm for example is a really great ML style language that includes a web framework inside of it, so you don't need to manually do HTML and CSS.
Good question. I dont know either lol. If you want to make sure your app will run everywhere the best bet is to ship JREs or use modules in Java 11.
Or just use sdkman. They clearly say which download is which version. ➜ ~ sdk list java ================================================================================ Available Java Versions ================================================================================ 12.ea.17-open 11.0.1-zulu * 11.0.1-open 10.0.2-zulu 10.0.2-open 9.0.7-zulu 9.0.4-open 8.0.191-oracle 8.0.181-zulu 7.0.191-zulu 6.0.113-zulu 1.0.0-rc9-graal 1.0.0-rc8-graal 1.0.0-rc7-graal 
I'm talking about general, non technical users. Thos who don't know what a JDK is
Wait, vaadin as gwt steering committee member abandoned gwt? 
They will either have to download the OpenJDK build or rely on the application to include a JRE. I remember hearing that Oracle is working to fix the search results issue.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Apache Wicket could be one. It's has limited HTML requirements. 
As of Java 11, there is no longer a JRE, and Oracle's recommended method for distributing a Java application to end users is to bundle a stripped-down JRE along with your application into a single installer. The Java 8 JRE will continue to be supported for a while (I think till end of 2020 IIRC) and will presumably remain available for download on java.com. (Java 9 and 10 aren't in the picture either, since they're not LTE and are both EOL already.)
So no more “write once run everywhere” It was nice to just distribute .jar files
&gt; Oracle is working to fix the search results issue oh really?
How is 11 unstable?
Well, at least no more "compile once run everywhere", probably :/. I feel your pain -- I'm in the same predicament, lone developer of a niche application used by people who definitely do not have the skills to start unzipping JDKs and setting classpaths. From what I understand, jlink can in fact do cross-platform builds, so maybe it's still possible to maintain a "build once run everywhere" model, but I haven't tried it yet. Basically my plan is to stick with Java 8 for as long as it's supported, which is a shame since there's a lot of nice stuff I'll be missing out on. But at the moment there seems to be a lot of work-in-progress around tools for bundling Java runtimes, so I'm going to stand back and wait for it to shake out. Hopefully by the time Java 8 is EOL there will be some decent mature cross-platform bundling tools.
I felt like it died with applets . . .
You can still do that. Just instruct your users to download OpenJ_DK_ instead of OracleJ_RE_. There is no longer a separate JRE, but the JDK contains everything the JRE did, so that's not an issue.
If you don't know what a JDK is then why would you be downloading a JDK?
Wicket is definitely a good choice here. HTML/JS/CSS can be provided by web designers, and Java developers write code that control the components without deep binding between client/server side.
Did you update your JDK? It does not work with anything newer than JDK 8, at least in my case. 
Ubuntu Cosmic already has java 11 as default, and it will be the default on Bionic soon. If you have a Mac and use homebrew, it’s also the default java install. I can’t speak for windows since I haven’t used my windows laptop in years. My company skipped 9 and 10 and will be writing all new apps in 11. There’s also currently an annoying “bug” with the java 11 distros on Debian and Ubuntu that cause jlink to barely minimize the JDK (when I used it in a docker container the resulting jdk was actually bigger than the original one..), but if you install by downloading the package from java.net then jlink works fine
Um okay. I'll do that when i get a chance tonight
We still use Java 8 where I work. Anything that powers financial software will changeat a slower pace purely for risk mitigation.
One year
It’s not that crazy to still be on 8. In terms of major releases it went 8 to 11. 
I'm using 10 but in compsci I'm using 8. At home I'll probably switch to openjdk soon.
why should I give a shit
My shop is still using jdk8 as the default, with no switch planned. JDK11 packaging isnt mature enough yet, apparently.
You don’t have to, but don’t blame us when Oracle comes asking for money because you didn’t listen to us or them.
&gt;I feel your pain -- I'm in the same predicament, lone developer of a niche application used by people who definitely do not have the skills to start unzipping JDKs and setting classpaths. From one lone developer to another, I suggest you ship your application with the JRE and bundle it all up in an installer. Customers just run the installer and they don't even know the application uses Java. Until jlink becomes more popular and more tools integrate with it, I'm sticking with my "ship all dependencies" approach. Very customer friendly this way. PM me if you want some help with this.
Indeed. We run Java 6 for our web applications, and ship desktop applications with Java 8. Java 11 isn't even on the roadmap right now.
(late reply but whatever) Agreed, this is often a large factor in me choosing it for a product Sometimes I wish I could try C# or Swift, but I code and deploy on Linux, so it's not really an option. Sometimes I write some Python on one machine and try to deploy it on another distro, but it uses some library that calls into a C binary and `pip` can't install it easily and it's not in that distro's repo On the other hand, it's usually very easy to get at minimum a Java 8 JRE running on almost any platform I'll be using, and then I just make sure all my dependencies are in the jar and I'm good to go
The faster Java dies the better for me.
Ha! Java isn’t going anywhere. [Project Amber](https://openjdk.java.net/projects/amber/), [Project Panama](http://openjdk.java.net/projects/panama/), [Project Loom](https://openjdk.java.net/projects/loom/), [Project Valhalla](https://openjdk.java.net/projects/valhalla/), and [Project Metropolis](https://openjdk.java.net/projects/metropolis/) will only increase productivity and popularity.
Never said it would. And btw no one cares about those since 95% of devs will use the Oracle version.
If users dont know what JDK is, but still need to download it, I would reckon there are bigger problems than versioning. 
Hmm? The features will be added to both builds.
Good for you.
You can also download it from https://adoptopenjdk.net/
cloud foundry ftw
If you still have JDK 8 lying around (most likely), you can set netbeans\_jdkhome inside netbeans.conf (inside "NetBeans 8.2.app/Contents/Resources/NetBeans/etc/") to point to an older JDK, e.g.: netbeans\_jdkhome="/Library/Java/JavaVirtualMachines/jdk1.8.0\_181.jdk/Contents/Home"
Isn’t oracle jdk still fine to use as long as you stay up to date? Also you can always switch to open jdk later.
No, it cannot be used in production without a license.
It’s not the worst thing. What features past java 8 are really that important? 
They, were literally installing toolbars alongside Java. They were out to get people. 
Only netbeans 10 works with Java 11 out of the box. 
I am running OpenJDK 11 on Netbeans 9 with no problems. I am also still running Netbeans 8.2 with Java's JDK 8. Legends never die.
A very clear and concise guide :) I did not realize writing an IntelliJ plugin could be so simple!
Proper docker support if you're using containers, TLS 1.3 for security ( I don't believe this is being backported ). Some library improvements I'd really love to use (mostly in streams) even without the language changes.
Also, a lot of tests I've seen were simple performance tests, not load tests. What happens to a parallel stream when everyone else is saturating the default ForkJoinPool instance already? Universal scalability law kicks in and the whole system degrades *because of* parallelism. Nothing wrong using it in single user systems though (e.g. batch, ETL, migrations)
The caveat here is that most OpenJDK builds don't have a nice user-friendly click-through installer like the old JRE, so it's not a good solution if you have non-technical users. However, your comment reminds me of the existence of Azul's Zulu JDK builds at https://www.azul.com/downloads/zulu/ . I haven't tried them out myself, but they do seem to have straightforward GUI installers for Windows, Mac, and Linux. Currently looks like the best option for anyone seeking a drop-in replacement for the old JRE that they can point users at (albeit at 2-3 times the download size, but 200 MB probably doesn't count as "big" these days).
Thanks for the offer! For now I'm going to sit tight on Java 8, but I'll take you up on it if I go down that route.
But honestly, distributing jar files wasn't the norm anyway. Most Java applications are either big enough to have their own installers anyway, or are distributed company-internal (either to desktops or servers) where the platforms are pretty homogeneous anyway. And what you *do* get is assurance that your application runs on the JVM it was developed for, which is especially important with the new deprecation rules.
If the JVM is distributed with the application, you need separate packages per platform.
I think Java 8 will be quite different from that though. Sure, there's still people on Java 1.4, but there will be more staying on 8 than on any other version in the long run.
Ahhh... thank you. I didn't realize optional added so much overhead. Personally, I think C++ optional is poorly implemented compared to other programming languages that have optional or an analogous concept.
Well, don't jump to conclusions either :) Again, Optional may add overhead (through allocation) in infrastructure logic (algorithms, libraries, etc.). It may be perfectly fine for business logic.
Work on jpackager is underway: http://openjdk.java.net/jeps/343 
The problem would goes away if windows users would finally start using a package manager. Linux users are covered. Mac users are used to [homebrew](https://brew.sh/index_de) by now and for windows there is [choco](https://chocolatey.org/) (or steam for games). All three have OpenJDK available. I don't get why downloading a zip, unpacking it, clicking on an executable and then on a 'next' button a couple of times, is still considered user-friendly and the default on Windows. 
I'm glad it's being worked on, but for me personally it's not an ideal solution because: &gt; There will be no support for cross compilation. For example, in order to create Windows packages one must run the tool on Windows. The tool can depend upon platform-specific tools. Currently I develop on Linux, but most of my users are on Mac and Linux. Maintaining three build environments on three platforms would be a lot less convenient than just cranking out a single jar. Not to mention that I'd have to drop quite a lot of money on a Mac just to get OS X legally.
&gt; The problem would goes away if windows users would finally start using a package manager. Agreed, but I don't know of a way to make my users more rational so I have to give them what they want, rather than what they ought to want but don't.
I don't really understand the question here, but I *assume* you are looking for mock tests. If yes, I recommend https://enthuware.com/
Because it's visual, you have GUI. Installing through package manager requires you to type something into console, you don't GUI, just TUI. It's not very user-friendly for most of the people.
There are GUI package managers available.
I can see how that might be a dealbreaker. In that case jlink solves part of your problem (of creating a custom runtime image), but not the last step of creating an installer.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
no longer based one, but still using it for client-backend communication
try [https://jsoup.org](https://jsoup.org) :)
[GIFV link](https://i.imgur.com/e0XikJO.gifv) --- _^I ^am ^a ^bot. ^[FAQ](https://www.reddit.com/r/livven/wiki/gifv-bot) ^// ^[code](https://github.com/Livven/GifvBot)_
The new deployment model moves away from the "system/desktop JRE" and the new [recommended practice](https://www.oracle.com/technetwork/java/javase/javaclientroadmapupdate2018mar-4414431.pdf) is that every application would bundle its own custom JRE, so there is no more need to install one. The idea is that only developers would ever need to be aware of a Java runtime -- or, in their case, an SDK -- at all.
Or to fund their immense investment in OpenJDK, which costs tens of millions of dollars a year, and involved hundreds of full-time employees.
That isn’t even Java...
The answer is: __NEVER__. The notion that end users download java directly (a so-called 'JRE': Java runtime environment) is __deprecated__. There will never be a Java 11 JRE. The new way of distributing desktop java applications is for the one doing the distribution of the application to include a custom downsized JRE-esque binary, created with jilink. They are responsible for maintaining this minified JRE-esque concept, and keeping it up to date.
It looks like in your [submission](https://www.reddit.com/r/java/comments/9vkiiq/how_can_i_fix_this_program_bugs/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Try /r/processing But don't post this there, this is some hello-world level stuff
If you are interested in using OpenJDK 8 with OpenJFX on Windows, have a look at my stackoverflow answer: https://stackoverflow.com/a/53205949/917
What I did was to create a shaded jar, wrapped that with launch4j and supplied the jre from OpenJDK (just as a subfolder).
A someone involved in producing the Java Champion article I would be grateful if you could elaborate on what 'nonsense' it contains. Martijn Verburg, who put this together, spent a lot of time getting all the relevant parties involved (including Oracle) to review this and ensure its accuracy. It is long, but there is a lot of information to provide and there is a summary at the beginning. I don't think your criticism is really justified. 
There will be updates to JDK 8 after January 2019, but these will only be for non-commercial desktop users (e.g. someone playing Minecraft at home). These will still be distributed via the current JDK 8 update process. For users wishing to continue using the Oracle JDK 8 binaries with updates a Java SE subscription will be required: [https://blogs.oracle.com/java-platform-group/a-quick-summary-on-the-new-java-se-subscription](https://blogs.oracle.com/java-platform-group/a-quick-summary-on-the-new-java-se-subscription)
FYI, 11 is the latest designated LTS release. There is no difference between "Oracle JDK" and "Oracle OpenJDK", or for that matter "AdoptOpenJDK", in this respect. The only difference is that Oracle will only provide updates for "Oracle JDK" _past the initial 6 months_; "Oracle OpenJDK" remains "LTS" in principle but not, meaningfully, in practice. Instead, if you don't want to pay for the "Java SE Subscription" required to use "Oracle JDK" in production, you must look to another distributor, for instance AdoptOpenJDK or RedHat, the will attempt to fulfil the remaining 2½ years of advertised updates.
You are a long term redditor with plenty contributions here, so, I expect you to know and respect the rules of this subreddit, which clearly state: + **Do not post tutorials here!** These should go in **/r/learnjava**. **Removed**
You're right. I was depressed by the length of the article when I've tried to read it full (multiple-times, never reached the end). It certainly is not "full of nonsense" and I'm sorry for that. It's just so bureaucratic and hard to read. Short version is ok though. I'm probably just overloaded by so many articles and rumors, that was released last few months, about Oracle support of java.
It is Java because *Processing* is a Java library/framework/system. Still, the post is just plain, useless spam.
Interesting. At first glance it looked like the Arduino IDE.
Windows is so old school :P
No, this is Processing: http://processing.org It is a graphic/sound focused library on top of Java (or JavaScript in case of Processing.js) that is increasingly popular in academic environments. Processing looks and feels like a completely different system than Java, but all Java libraries can be used since it builds on Java.
I strongly recommend buying this bundle. If you would like to learn Java 11, the below books are written by good authors and highly recommended: Java Projects (Java 11) (Java 9 programming by example is also by the same author) Mastering Java 11 Java 11 Cookbook &amp;#x200B; If you would like to learn Java EE, begin reading in this order : Java EE 8 Application Development, Java EE 8 and Angular ( If you are not interested in angular, you can just ignore that part because this book is written in two parts the first half is all about Java EE and the second half is blending angular to JavaEE. So, it is easy for readers to skip the angular part if they are not interested) Java EE 8 Cookbook (This book has very cool recipes that helps improve your understanding on Java EE, after you finish reading the above two books) Architecting modern Java EE Applications (After completing above said books, this books helps in making design decisions. The book title says it all) The above listed books are worth purchasing and you wouldn't regret for the money you are spending and in addition you are getting other books/videos too. So, Just go for it. &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B;
Yes, and the packaging is not cross-platform anymore. Same way you can write cross-platform c++ apps.
There's actually a blocker with Java 11. Java 10 with NetBeans 10 seems to be the best match.
Thanks for the link!
True. Not doing it anymore.
Check these links out: [https://www.oracle.com/technetwork/java/javase/downloads/jdk-netbeans-jsp-142931.html](https://www.oracle.com/technetwork/java/javase/downloads/jdk-netbeans-jsp-142931.html) [https://netbeans.org/downloads/](https://netbeans.org/downloads/) &amp;#x200B; Good luck!
https://www.playframework.com/
My two cents: If I have a lot of objects that need to have a single instance, I try to put them all in one single object that is globally accessible. Sometimes that's a traditional singleton with a static getInstance() method, sometimes it's something else. But that way I have that single, accessible core of the application. &amp;#x200B; I do find them to have some value because sometimes you want a single source of truth type of thing for your application.
correct. no UI components of gwt are used.
Not abandoned, but GWT is no longer being used by vaadin for it's UI components. They are now using polymer for the front end, IIRC.
&gt;Mac users are used to homebrew by now &amp;#x200B; No they aren't. Most mac users have probably never heard of homebrew or used the terminal at all.
Windows won't ever have a package manager. Instead it will just have an "App Store" :/
https://adoptopenjdk.net/ What about this place? Seems straightforward to me.
In my opinion, the real issue was Java 9 and its module system. I have never been happy about it and have yet to see any personal benefit from it. I feel like the language designers took something which was some people's problem (large binaries, large jdk, etc) and solved it by making a new problem for EVERYONE. It really broke the ecosystem in a way that Java has successfully avoided in the past.
Our big app on wildfly 11 did just start on Java 11, no problems, no modifications. Just skip the module system.
AdoptOpenJDK is also great!
We migrated without too many issues. Then again we do keep our dependencies pretty well-organized and up-to-date, since the day Java 9 was released we kept a list of compatibility issues. 
What is a JRE?
well, you have ofcource to include all the packages in pom, that are no more included in J11. Then all the things should work again. I assume you have a maven project ? 
That's a great way to approach the problem, but I feel like that's something which shouldn't be necessary for everyone. Java had the precedent that new versions of Java don't break existing code. The language designers have put a ton of effort into making that the case so we can avoid (or at least minimize) the effort that you describe. It's just a shame that they blew it with Java 9
Yeah, we suspected it's going to be trouble when tooling took a while to catch up (it still hasn't, we dropped a couple of dependencies because of it).
I completely understand your frustration. For me the most egregious issues were with the removal of JAXB and JavaFX. Imho you shouldn't need a separate library for processing XML files in 2018. Introspection is also completely fucked until you add exceptions for almost everything. I do hope that this will get better in the future as libraries adapt. I spent about a week migrating a large JavaFX app to Java 9. The migration from 9 to 11 was done in like 10 minutes. Jlink is also a joke right now. It breaks on anything more complex than "Hello, World" apps - for example apps that use the reference implementation of JAXB break hard because its JAR is multi versioned - enabling multi versioning makes it break on other stuff. At the end of the day I don't think the module system adds enough value to be worth the trouble.
&gt;Most mac users have probably never heard of homebrew Not sure about that, given those who buy a Mac (and can justify the price) most likely are using it for advence usage (i.e. not only for surfing the web and streaming) &gt;or used the terminal [Cakebrew](https://www.cakebrew.com/)
it's in oracle's financial interest to break as many things as possible - that forces companies to stay on the older version and purchase support. you've hit a few of the big things, but under the hood they're reworking the internals with the intent of breaking things. and java 12 and later releases are looking to be worse yet 
\&gt;given those who buy a Mac (and can justify the price) most likely are using it for advence usage (i.e. not only for surfing the web and streaming) &amp;#x200B; Basic usage overwhelmingly dominates advanced usage of pretty much any consumer good besides niche, specialty gear. Macs are a chic luxury good, not a computer for advanced usage. &amp;#x200B; \&gt;Cakebrew &amp;#x200B; I'm not sure why someone who doesn't use a terminal is going to care about a GUI frontend for a utility primarily for managing command line utilities.
&gt; Macs are a chic luxury good, not a computer for advanced usage. How do you mean? Maybe 'advanced usage' isn't the correct way to describe what I meant. If your average person would look for a new computer to manly browse the internet, why would he consider a Mac? As oppose to a designer or a programmer, which has specific use for the OSX operation system. &gt; I'm not sure why someone who doesn't use a terminal is going to care about a GUI frontend for a utility primarily for managing command line utilities. You're correct that Cakebrew providers a GUI interface. For a user who've never used Homebrew but would like to install packages, why dose it matter that Cakebrew uses Homebrew underneath? With Homebrew, you can install packages that contains a GUI as well, so your point in: &gt; utility primarily for managing command line utilities. Is partly correct, since any package manager can only provide the packages that it's indexing (and exists.). Homebrew index a large number of packages that has UI's
80 columns is the way as it was given to Moses 
I'd be interested to see a diff between your style guide and the Google style guide. Saying that, I'd be interested in a diff between the Google and Sun style guides. :)
You uh, forked an entire guide to change one number? Also, this is an interesting terminology grab: "A Java source file is described as being *in Java Style* if and only if it adheres to the rules herein."
That's why he needed two tablets, shit couldn't fit on one.
I certainly plan to run a parallel CI job with Java 12 very soon. Fortunately, it just requires switching the docker image used for building (from `maven:3-jdk-11` to `maven:3-jdk-12`). 
I see you don't care about security updates. Java 8 will stop in two and a half months, and Java 11 will stop in four.
I just migrated a code base that was designed for Java 4 to Java 11 (Seriously, it still doesn't use generics). I think it took an hour.
Really??? I would like to know how you did that... Maybe you are not using any library and you coded everything in house with no database connectivity and no GUI. You might not use XML either, for that matter ... Probably that and you don't mind to install and configure your java env path manually, package your code with the cli/ jlink, etc...
Not really, some libraries are going modular and others are not, with the same dependencies ... That is where the nightmare start .
A JRE actually wasn't released for Java 11. It is only the JDK, which of course still requires a license.
actually, if you go to adoptopenjdk, they have JRE builds of java 11. it's crazy and weird
The application uses XML heavily, given that it's from the "XML ALL THE THINGS!" era. And it uses a database, although JDBC directly. It's a war, so it'll be installed into a servlet container.
Starting with Java 11, there will no longer be releases of a JRE. Only a JDK. And that's fine.
&gt; It is only the JDK, which of course still requires a license. The JRE is bundled into the JDK (always has been) and OpenJDK doesn't require any special licensing to use it.
Yes. I was referring to Oracle JDK since that is what the OP mentioned.
Interesting! I was only talking about Oracle JDK.
AdoptOpenJDK said that Java 11 would be LTS, although the support will be given by the community and not Oracle as far as my understanding goes. I dont get the "have more money than time". &amp;#x200B; The beauty about C is that you are the one that gives LTS to your creations, nothing funnier than having your own bugs bite your booty down the line.
Ill leave programming and move to a forest in the middle of nowhere. Apparently mentioning "C" caused some mixed emotions.
Sorry if this sounds like a dumb question but what do these security updates entail, is it just loop holes in the source?
How does that even work though? Don't you need a JRE to run the software?
The JDK has always need a superset of the JRE.
I despise GWT. Why would you willingly give up all the very powerful tools of the modern web development in favour of writing everything in Java? 
From JDK 11 on, the Oracle JDK needs paid license if used in production environment. However, Oracle has made the commitment of OpenJDK being "fully compatible" with the Oracle JDK starting on JDK 11. That means that you just won't get the support from Oracle. Regarding security updates for OpenJDK, looks like Oracle wasn't already giving them and groups from other companies were giving updates for it. A quick Google brought me to the next link explaining this last point: https://developers.redhat.com/blog/2018/09/24/the-future-of-java-and-openjdk-updates-without-oracle-support/
By the way you can use jlink to create a trimmed down version of JRE for your app.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt; If your average person would look for a new computer to manly browse the internet, why would he consider a Mac? - Brand recognition. - Vendor lock-in (iPhone, iTunes). - Silver! - Ad-hoc bread slicer when you don't have a bread knife. You are vastly overestimating the amount of critical thought that goes into typical consumer technology purchases.
Which kills one of the main advantages Java used to have: the ability to compile a Jar once and run it everywhere. These new changes seem designed to remove all advantages Java used to have over competitors.
I predict Java 8 will be the python 2 and Java 11+ the python 3.
For Oracle JDK 11. Java 8 is just EOLed.
The standard examples of JDK security updates are security manager and serialization vulnerabilities. If you rely on neither of those features, staying on old versions is *usually* reasonably safe.
Same here, I have been using Javafx properties all around since jdk8 and now I am regretting it big time.
And with the new agreement on jdk idk if I can still use JavaFX on production, well is a good thing I'm using swing. If all this situation endup being clear at all I'll consider using JavaFX again if it's still free or freeish 
That you did not bother to at least assess the impact of Java 9 after it came out is 100% on you. Sorry. I've spent the last few weeks migrating a lot of Java 8 services to 11 and the only thing you typically have to do is grab the latest version of Lombok and add some old dependencies to Maven/Gradle. "Hundreds of man days" is a ridiculous overstatement.
Could you be more explicit on what libraries you found that exhibit this error? It would be very interesting to investigate.
Nice !
Yes. I have a plugin that does exactly this. It allows you to execute a jar without the \`java -jar\` and instead \`./fileName.jar\` or even \`./fileName\`. You can also embed flags, parameters, and pass parameters to it. &amp;#x200B; \[selfexec-maven-plugin\]([https://github.com/paroxayte/selfexec-maven-plugin](https://github.com/paroxayte/selfexec-maven-plugin))
&gt;If your average person would look for a new computer to manly browse the internet, why would he consider a Mac? Wow, you don't understand how brands work, do you? &amp;#x200B;
Then why did you even bother with it in the first place? Why not just continue using the classpath? 
JavaFX is not part of the Java 11 standard library. Just import like any other third party library.
Now I wonder if my seo suite based on Java works with openjdk. As a freelancer I don't have the resources to pay Oracle for licences.
Security fixes are asking for you.
Edx
Except that 2 line blurb they snuck in about how you can’t use the jdk free in a production environment. Google it bro. They have a line where they say you can’t use their JDK in production.
JDK 11, not 8.
A large part of programming is figuring things out for yourself as much as possible. Have you tried Googling on "Learning Java" ? You might get more useful answers asking this question in /r/javahelp 
Use Fat jars people, it's 2018.
Ok sorry I misread 
Check the sidebar in /r/learnjava, in particular the *Free Tutorials* section (they are in order from most recommended): &gt;**Free Tutorials** * MOOC [Object Oriented Programming with Java](http://mooc.fi/english.html) from the University of Helsinki * [Java for Complete Beginners](https://www.udemy.com/java-tutorial) * accompanying site [CaveOfProgramming](http://caveofprogramming.com) * [Derek Banas' Java Playlist](https://www.youtube.com/playlist?list=PLE7E8B7F4856C9B19) * accompanying site [NewThinkTank](http://newthinktank.com/) 
Idk how to do that 
What does "won't get support from Oracle" mean?
\&gt;without touching JavaScript, HTML and CSS How do you want to make websites without HTML and CSS? DSL on Java?
Look at Vaadin or ZK for example.
As far as I understood, you won't be able to ask Oracle for support, neither for a bugfix if you have one. With the paid license you can do (never had one though :D). 
I'd like to use Vaadin, but I need to develop in offline environment (without internet access) and Vaadin seems to be very tied to Maven, it seems that there is no single JAR that I can download by hand and add it to my project. Maybe I'm not getting something right about it, I'm new to Java ecosystem, sorry. Havent look closely at ZK as of yet.
Correct. You can keep using the last January release of Oracle jdk 8 in production, it's just not a good idea to operate without an avenue for security updates.
&gt;Just skip the module system. As in, just don't create `module-info` files, or what do you mean?
Which is exactly what I said.
You said it in the narrow context you were thinking about ("just don't upgrade") and I replied in the context I assumed OP was asking about (ongoing maintenance).
What security fixes? Applets are dead and whenever people tell me why Im gonna die because of security fixes they never tell me specifically what security issues are fixed with new updates. And they still want me to evolve as a human being and update as soon as a new release comes out!
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Ill do them myself buddy. I do not depend on anyone for my code, at least if I do not want to.
A JavaFX application for instance doesn't work out of the box on the classpath.
Yes, jlink is currently unusable if you have 3rd party libraries. You can't just use it on the application jar as promised. I ended up copying all dependencies into a folder with maven (30+) and then I called jlink on each one of them manually. Sometimes they need more options, e.g. with multi-release jar. Forget the OpenJFX jars, jlink just doesn't work with them. I had to look at the module-info.java on the github repo. Certainly this could be automated, but I didn't have the time. The official maven-jlink-plugin only reports on jdk.unsafe access. I found another plugin on github, but it run into the same issues as described above. It's frustrating and I'm still not sure if I got all of the required jdk modules. Atleast they are bringing back a packager: http://openjdk.java.net/jeps/343
Fat jars are just a deployment option. How should this help in migrating to Java 11?
Having modules does help with maintaining a clean structure. But I'm convinced this works best when starting a new projects and not so much when migrating AND not with the botched up JPMS modules that can't even handle versions. We have had OSGi in the Java community for years and in most areas it works way better than JPMS.
Someone needs to make a simple graphic to explain this all, because I keep getting confused about it, and I've been reading about it for the last 6 months.
if maven is the only problem, it can download files while connected or on another machine and store them in a local dir. it's the `dependency:copy-dependencies` plugin
Yes. If you use the old classpath argument the module system is deactivated.
You are in complete control of your dependencies, not some application server you can't control. You can also upgrade your java services one by one so it doesn't have to be a massive company risk that you have to spend days on. 
That's the thing. You actually have to spend time understanding it and even then it will cause you trouble. I've never met anyone who said they understand hibernate and at the same time didn't ran into some complex mindfucking bullshit with it. Meanwhile you still have to write jpql all the time (can't avoid learning SQL) and you still have to think through everything so your (hibernate's) queries won't be slow. Meanwhile, there is SQL which everyone understands and there are great libraries nowadays that enables you to use SQL while you don't have to do the mess of jdbc. Examples: jooq, jdbi
Wrong subreddit. Programming help goes in /r/javahelp. You need to repost there. **Removed**
Wrong subreddit. Programming help goes in /r/javahelp. You need to repost there. **Removed**
New to this still thanks
It looks like in your [submission](https://www.reddit.com/r/java/comments/9vxevd/data_types_in_java/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Oh! I never stumbled across this when initially researching this project. Looking at I see they solve the problem. There are some differences in implementation and syntax. My plugin does not require an external script to be present in order to customize the run command for instance. He creates a or copies a script and appends a jar to it, whereas my plugin constructs a new file and populates it with the script then the jar. The stream for appending the jar in his implementation is unbuffered whereas mine is buffered. I'm biased, but I think my syntax is a tad less complex. 
Fat-jars are also a deployment option for/with application servers, e.g. embedding Jetty or Tomcat, so I didn't get what meant by the term alone.
/r/processing Processing, even though the very core of it is Java, is quite different from Java and you will need the help of the processing specific subreddit to get the appropriate advice.
Oh, my bad. I hadn't thought of that. \+ I didn't know Processing wasn't ACTUAL Java. Thanks!
Processing is a library/framework/system on top of Java, pretty much like Android is a framework/system/library on top of Java. You can use all of Java's methods, but Processing has a completely different approach to graphics, sounds, etc.
I see. I don't think we're actually going to learn raw Java then, but it makes sense that we're using Processing because my education revolves more around audiovisual stuff instead of pure coding.
The best gigs, for me, have come through referrals. If you're trying to get work from strangers you'll be competing with tons of people willing to work for less. So, without a good network it is tough.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Tomcat and jetty are servlet containers, meaning they mostly deal with serving http requests. An application server provides you with the whole JEE stack and a lot more. Application servers are for example Weblogic and wildfly. To get the best out of app servers you deploy your application as a library (called EARS usually) onto the servers and then manage your app from the server interface (like distributed caching, amount of instances for each ear, message queues, etc). Therefore you can't deploy app servers as fat jars, only servlet containers.
I am author of the really-executable-jars-maven-plugin. Some clarifications on your quick analysis: * you don't need an external script to be present, it just allows you to have one :-) * I don't think the buffering matters, maybe it does. Awesome that you did same. Did you find a way to fix the zip offset warning? I started writing a better zipfile editor (or just generator) which would allow for it, but never finished as nothing I have found cares. &amp;#x200B; &amp;#x200B;
If I am understanding you correctly I believe the fix was to preface the launch invocation with exec. If you just append `java -jar ... ` you will get errors about the zip, if you instead use `exec java -jar ...` you will not get such errors.
Give up? GWT is a pretty powerful platform, but yep, if you are going to develop a client-side app and you have a JS team makes no sense. GWT is useful if you have a Java experienced team, maybe a team coming from JSF and you want to create an SPA. Even if this is the case, is important that you share code, this is IMO the major advantage in GWT. The code might be libraries or logic, for example, if your company have a complex algorithm that you enter some parameters to calculate something, maybe a mortgage calculator, you can just transpire it to is and use it in the browse using GWT. Note also that GWT is thought to be used in big projects, so at first it might be a bit complex because it already forces you to do all those fancy things that modern client framework does (although GWT exists since 2006), like obfuscation, inline resources, i18n, code splitting, code pruning, CSS isolation, HTML sanitize, and much more. So again, if you are creating a six-month project GWT is again probably not the best option. If you want to see it in action, this is a small example of an algorithm developed and tested in java (during the "global day of code retreat 2017"), later on, I applied GWT and created a UI in the Simulator class, so the logic already developed in java was shared "for free". https://github.com/ibaca/gameoflife
Thanks, I have a satisfied client roster already, but when it comes to satisfied clients that know other vendors looking to hire Java consultants that seems like an unlikely match. We'll see though! 
Did Android do async wrong?
Why they would spend time writing this and not mention Project Loom once, I have no idea...
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I think this whole shift in JVM licensing will bestow a lack of confidence and spell the end of Java as we know it.
No, just a mindshift from "Java is from Oracle" to "Java is from OpenJDK; Oracle is but one supplier". No one has a lack of confidence in Linux just because there are multiple distributions.
When has Amazon ever gotten along with anyone? There's lots of examples of NIH in the company. Amazon Linux vs Redhat/Ubuntu/Debian. Amazon not supporting Chromecast because they want you to buy a Firestick. Kindle Fires not supporting the Play Store, etc etc. Amazon will run their own JVM distribution.
One supplier of a "standard" JVM. We all know how multiple implementations of standards turn out.
A very nice article! I completely agree with the conclusions that one shouldn't just jump to using Stream API if performance is important. Having said that, I **strongly believe** the version with `return` is better than the version with `break`. Let's repeat them here for comparison: woot: if (something) { for (Object o : list) if (something(o)) break woot; throw new E(); } and if (something &amp;&amp; noneMatchSomething(list)) throw new E(); // And then: private boolean noneMatchSomething(List&lt;?&gt; list) { for (Object o : list) if (something(o)) return false; return true; } There are four aspects of why I favor the `return`\-based code: # 1) Separation of Concerns The `break`\-based code makes it really hard to immediately see the **big picture**, which is: **throw-conditionally**. When you try to find out this big picture (i.e. **what** the code does), you're *forced* to plow through the details too (i.e. **when** the code does it). On the other hand, the `return`\-based code is *beautifully* separated: there's the condition + the conditional action. And only if you need to know **when** the code does stuff, you read the inside of the `if` clause (and potentially navigate to the method that is called - but only if the method name is not self-explanatory enough). # 2) Unambiguity The `break`\-based code is problematic because such a construct (a label, two `if`s, one `for`, a `break`) can potentially do many different things, depending on the order, number of `if`s, etc. It's like the difference between `for (i = 0, size=items.size(); i &lt; size; i++)` and `for(T item: items)`. The former can do many things (e.g. `i = 1` or `i &lt; size - 1`), and it takes more time to make sure that it does the "default" thing. # 3) Flexibility If you needed to add a third condition (executed at the end) in the `break`\-based code, it'd definitely be non-trivial. But with the `return`\-based code, it's easy and still very readable: if (something &amp;&amp; noneMatchSomething(list) &amp;&amp; anotherCondition) throw new E(); # 4) Familiarity Last but not least, /u/lukaseder is right that people are rather unaware of (or at least unfamiliar with) the break-out-of-if construct. So using this construct incurs a cost of *unfamiliarity* for others (e.g. for the developers that Lukas will be employing as jOOQ inevitably grows :) ). If this construct provided a *clear* gain, I'd be for using it in order to promote it. But as it is, I believe the cost is greater than the gain. &amp;#x200B; Finally, as to the problematic cluttering of the code by the extracted private method, I sometimes (but only if the class is large enough): * extract a package-private helper class (e.g. `SomeObjects`) * move the `noneMatchSomething` method there * change its signature to `static boolean noneMatchSomething(SomeObject someObject, List&lt;?&gt; list)` * call it as `SomeObjects.noneMatchSomething(this, list)` The main drawbacks are that: 1) it's quite verbose, 2) it requires making the `SomeObject.something` method package-private.
Nice write up! Nice plugin! Does it support Kotlin? Is it possible to change the output? Some prefer to postfix DTO classes with the word Resource or Value rather than DTO.
Except most Java distributions share the same implementation.
In my experience it's quite easy to get Java software engineering freelance jobs here in Holland, but a lot is done through recruiter companies who try to get a rather big percentage of your hourly rate. So while you often can get 90e/hour by going direct, recruiters often offer the same gig for 75e/hour taking 15 e/hour for themselves for doing literally nothing. So definitely try to go direct via your network. Getting a more lead/architect oriented role is harder though. While these do pay more, they also obviously attract more people and they are more rare. Most companies try to use internal employees for these as much as possible. 
Correct. As far as I understand it,`-XX:+UseContainerSupport` is enabled by default on Linux servers.
Perhaps you're looking for [vert.x](https://vertx.io/docs/). 
Yeah I can tell people aren't happy with what I'm saying, and I know it's unreasonable, but I just see this as a vulnerable time for Java, and I'm worried other people will come to the same conclusion.
No, now you *can* do it this way, and this is the recommended way because this is what most people seem to prefer, but you can still do it the old way if you like. 
Android has several ways, none of them are 'wrong' but neither are they ideal: AsyncTask, handlers/loopers, rx, rx2... You could do it yourself with new Thread() if you wanted. I'd really like to use Project Loom's fibers but as Android is stuck on old JDK versions for many years that might not be realistic. I usually use rx but if starting a new project I might consider kotlin's coroutines.
Nah the new android jdk is based on the openjdk so the gap gets shorter. Also because of oracle
That's not going to affect old/cheap devices which are a huge proportion of the installed user base.
I do. I wanted it to work, but it wouldn't. 
Makes sence.
Also the TCK means that they're all compatible.
Loom isn't here yet.
That all sounds good except for all the bug reports of, e.g., OpenJ9 or OpenJDK behavior varying from the Oracle version. Maybe improve as of v11, but you certainly can't fault people who have been burned in the past.
You know what the TCK is, right? The Technology Compatibility Kit. It's literally designed to prevent behaviour varying.
Say you have two clothing objects and you want to see if they are equal, you can’t use == because that will just compare their memory locations. Instead you need a method in the clothing class that would be called like clothing1.equals(clothing2) . It will take in a second clothing object as a parameter in order to see if it is the same as the clothing object the method is called on. 
You may find /r/javahelp and /r/learnjava more useful.
ok I can understand what you mean but then how do I define the objects? would it be something like public boolean equals(?) { if(?.equals(?)) { return true; } } I am not sure how to define this objects. like how does it know what clothing1 and clothing2 are? 
has anyone managed to use this ? ``` Could not resolve dependencies for project de.osoco:coroutine-demo:jar:0.9.0: Could not find artifact org.obrel:objectrelations:jar:1.3.+ in jcenter (https://jcenter.bintray.com/) ```
OpenJ9 is not OpenJDK. Oracle's JDK is.
All that would take would be for Amazon to start contributing significantly to OpenJDK, a platform they rely on so much. [Here's](https://blogs.oracle.com/java-platform-group/building-jdk-11-together) the state of contributions for JDK 11: &gt; While developers employed by Oracle resolved 80% of the JIRA issues during the development of JDK 11, 20% were fixed by developers working for other organizations. Developers working for the five next largest contributing organizations, SAP (7%), Red Hat (5%), Google (3%), BellSoft (1%) and IBM (1%), collectively fixed 17% of those issues. Independent developers contributed 2% of the fixes in JDK 11. Last but not least, the remaining one percent of the fixes was collectively contributed by developers from a wide range of organizations including Alibaba, Amazon, ARM, Azul, Intel, JetBrains, Linaro and Qualcomm Datacenter Technologies. 
True, but OpenJ9 is not OpenJDK. Oracle's JDK is. The TCK is free for OpenJDK to use, but as a JDK based on OpenJ9 is not OpenJDK, it is not allowed to use it. 
Is it allowed to legally call itself Java if it hasn't passed the TCK?
Probably not, but I'm not sure. It is [clearly](http://openjdk.java.net/legal/openjdk-trademark-notice.html) not allowed to call itself OpenJDK (or an "OpenJDK variant), though.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [Java 11 in Alpine Linux containers \[x-post from r\/java\]](https://www.reddit.com/r/programming/comments/9w6zre/java_11_in_alpine_linux_containers_xpost_from/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Are they backporting security updates in the OpenJDK repository in general or just for their JDK on Amazon?
Oh I see now. That’s makes it very clear thank you very much. Could I use my getter? And say if (this.getType().equals(x)) blah blah?
Reposting the same link after just four days? https://www.reddit.com/r/java/comments/9usmnp/java_11_in_alpine_linux_containers/ 
Sorry about that. Normally, if the link has already been posted, I get a warning and don't force-post it. I didn't get any warning for this one.
Yeah I've been programming with java for over 20 years.. hard not to get attached!
Looks like it to me! Always make sure to test it though!
Thanks once I am able to finish my main method up I will for sure test it. Thanks a lot
Yea I should have looked at the sidebar first but whatever I got some help anyways. I'll take my downvotes
But you are using JDK 12 here... There's no easy way (if any) to get JDK 11 musl variant...
Linux Java is built on glibc. Alpine uses musl. It is highly unlikely Oracle will expend the resources to port Java to musl. The existing AdoptOpenJdk alpine images use a glibc to musl adapter layer, which is currently maintained by one guy. As awesome as Alpine's small images are, I sleep better running on containers that are &gt;150MiB larger knowing they have been properly battle tested in that configuration.
I'm aware of all of that as is clearly stated by my previous post. Also, Oracle *is* building musl-based JDK 12 images right now. Which is what this article uses, and again states very clearly. See https://jdk.java.net/12/ My concern was pretending this is JDK11 when really it uses JDK12 + jlink.
Thank you for clarifying. It appears the person I spoke to from Oracle this past week was misinformed. FWIW, he was skeptical that Project Portola would land even by JDK12 or even 13
[kilim](https://github.com/kilim/kilim) is actively maintained (in part by me) and kilim 2.0 was pushed to maven central friday (might make an announcement and reintroduction in the subreddit this week). [here's the release note](https://groups.google.com/forum/#!topic/kilimthreads/a7IquWSDwpU). supports java 11 via ASM 7.0, runtime or ahead-of-time weaving, jshell, continuation, message passing, actors, etc loom isn't stable yet and is slow in the uses cases i've tried it with. when performance improves, kilim will integrate with it 
No worries. yeah overall it's very not ready for anything but PoC at the moment. Hopefully they figure it out but might be a long way. Surprised (and sad) they didn't use a Graal base for that anyway as well...
I want to learn Java, i have no programming experience and i want to eventually make android apps. Do i need to buy the $15 pack or is just the $8 bundle good enough?
Are you drunk posting?
Still is, just creat a MANIFEST.MF with a Main-class attribute and a Class-path attribute if you don’t create a fat jar.
Just ship a shell script with your app that executes java -jar.
It took me about 10 minutes to add the required dependencies to my gradle build. I'm not sure the software industry will collapse over it.
Modules were to address the pain points of smaller devices. The idea is to build only including what you need, thus shrinking memory footprint.
Of course you'd like other companies to do free work for Oracle (you need to sign over your code to Oracle to contribute). I hope these companies fork Java and cut out Oracle completely.
Thanks a lot for the feedback. Like most people who like bikeshedding the style of some logic, you're overengineering this IMO :) It's just a simple loop and everyone who will stumble upon it will survive. Maybe richer with experience about `4) Familiarity` &gt; e.g. for the developers that Lukas will be employing as jOOQ inevitably grows Stay tuned. The first contract has been signed. I've seen some of his code and he has seen mine, obviously. I'm positive, he won't worry about my coding style at all :) (formal announcement is still due) &gt; But as it is, I believe the cost is greater than the gain. Again, while you're gauging the cost/gain of some 0.02¢ thing, which is a single loop, I tend worry about the multi-billion dollar problems. ;) In this particular case, just leave the loop alone and direct your attention to something more important. &gt; Finally, as to the problematic cluttering of the code by the extracted private method, I sometimes (but only if the class is large enough) [4 steps] By that, you will introduce: - A lot of indirection, that requires the reader to jump around in the code - Naming, which is hard - Breaking the history of the code, which makes changes less trackable. For no apparent gain IMO
That should work, I just tried it in a new project (I'm the author of the library). The objectrelations dependency in published correctly on JCenter. 
I recommend taking a look at 'jib' by Google. JRE containers based on distroless images. All built locally with a simple Maven plugin, no Docker installation required!
I am the author of the framework that is presented in the article and it was intended only to introduce that particular project. Unfortunately, the DZone editor changed the title (all articles there are moderated) to the very generic "Using Coroutines in Java" which causes some irritation among readers. So, project Loom is not mentioned because it isn't the topic. The Fibers that will be introduced with Loom are quite interesting and when they're generally available we'll probably adapt the framework to use them.
As a clarification: I am the author of the framework that is presented in DZone article. The arcticle was intended only to introduce that particular project. The DZone editor changed the title to the very generic "Using Coroutines in Java". It has now been edited to "A Coroutines Framework for Java" (the change hasn't passed moderation yet). Maybe the creator of this Reddit post can edit the title accordingly. The framework presented in the article provides a pure Java solution for suspending cooperative concurrency (aka coroutines). "Pure Java" means that only a dependency needs to be added to the build but no other tools at compile time and/or runtime. The framework also implements structured concurrency similar to the recent redesign of the Kotlin coroutines. It is based on standard Java elements like thread pools and CompletableFuture.
What is jsk11?
Please see my other comments regarding the intention of the article. Regarding project Loom, the framework presented is not intended as an alternative to Loom but as a simple API for suspending concurrency. When the Fibers of Loom become generally available the framework will possibly be adapted to use them instead of CompletableFuture which it uses currently.
Yes, but all alternatives (that I know of) require either additional build and/or runtime tools (bytecode manipulation) or references to non-Java code via JNI. The presented coroutines framework is just a simple Java dependency that can be added to a project easily. It is based on existing and proven Java concurrency elements like thread pools and futures but adds suspension (e.g. channels and asynchronous I/O) which isn't available in the standard library. It also implements structured concurrency (like the latest iteration of coroutines in Kotlin) which I haven't seen in a Java coroutines solution so far.
Pretty neat!
Yes, there's plenty of evidence, but if you wish to have more influence over Java's direction, you're welcome to join OpenJDK. But we've been through that before. You called Java cancer or something, said you'd never touch it again, and I agreed that Java is a really terrible fit for you and wished you the best of luck. Why do you keep coming back? 
thanks!i will lookinto.
&gt; You most certainly do not. You most certainly do. You need to give Oracle a shared copyright on your code, and a license to all your patents that might cover the code. &gt; Why is it for Oracle? Because Oracle owns Java. I.e., they own copyrights to all of it (some shared copyrights, but still). &gt; You mean cut out the one company that's willing to fund the vast majority of the development Yes. The company that famously does not care about anything but money (and not in the sense of "every company only cares about money", but in the sense that they truly do not care about their customers or technologies or anything other than making money). The company that has pushed all these changes to Java that provide me with ZERO value, but force me to either significantly increase my developer costs or pay Oracle for LTS. Yes, I say cut them out or Java has no future.
Thanks for your answer. While I agree this issue is rather minor, I disagree it's inconsequential. It's not only about `break`\-based constructs - it's about all similar constructs where there's too much going on in one place (I've seen it often enough). But the general idea is not mine, it's Uncle Bob's (*Clean Code*). That said, if my argument did not convince you, then it's not worth dicussing it further (lest it truly become bikeshedding). However, note that you evaded the core of the argument (i.e. separation of concerns, unambiguity, flexibility), yet you responded to my minor remark about a helper class :) As to my directing attention elsewhere - I didn't spot any major problems (here or elsewhere). I noticed a minor but significant enough problem here so I wrote about it (at length, true - guilty of that!). Finally, I did not imply anyone could worry about the quality of your code in general. Quite the contrary, I think highly of it (especially of APIs). Yet, this *particular* thing is something I consider a code smell (and it's something I wouldn't like to work with). &amp;#x200B;
&gt; You most certainly do. No, that is not what "sign over" means. &gt; Because Oracle owns Java. But it's not the main beneficiary. &gt; The company that famously does not care about anything but money I am sorry that all other companies don't seem so eager to fund the development necessary to give you the value you want, but I've told you twice before that if you feel so strongly about a company that funds and gives you software, I understand why you cannot, in good faith, continue using it. Yet you keep coming back here. If you want to make a difference and have real influence, you're welcome to join OpenJDK.
I dont see any android books in this bundle. So, If you would like to learn core java go for $8 bundle and start reading Java Projects book. It is written for beginners pretty comprehensively on Java 11.
Maybe OP means JDK 11?
I find that most of the missing libraries can be restored through adding a new maven dependency. Unless you're doing fancy classloader modifications at runtime (which my company does... Fml) most of the problems are fairly easy to overcome. Source: I did my company's migration from 8 to 11.
I haven't watched the video, but I guess it's talking about graalvm. I thought that it isn't ready yet for things like reflections. I can see some limitations still here: https://github.com/oracle/graal/blob/master/substratevm/LIMITATIONS.md And Spring for example is waiting for some graalvm updates to support AOT: https://jira.spring.io/browse/SPR-16991 Is Micronaut working despite these limitations? I will watch the video later so maybe my questions are answered there
Maven is only meant to be part of the build process the code you deploy to any servers or clients should have all the dependent jars delivered with it.
I think it's not actually about java ahead of time compilation. It's about doing some annotation processing during a build step to avoid doing it during the runtime, e.g. generating usable classes from just interfaces with annotations.
Security patches address a wide variety of common vulnerabilities and exposures CVEs that affect Java. This is not limited to issues in the JVM, bytecodes or libraries. For example, Spectre and Meltdown are potentially significant security exploits and the JVM requires modification to mitigate these. These are (or will be) included in the regular critical patch updates (CPU).
JDK 8 is not EOLd, nor will it be in January. January 2019 is when the last \*public\* update to JDK 8 is released that can be used by a commercial user. There will be subsequent updates to JDK 8 for non-commercial users (like those who play Minecraft at home) until December 2020. Oracle (and others) will provide commercial support for much longer.
here's my pom (changed the group and artifact): ``` &lt;project&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;dummy&lt;/groupId&gt; &lt;artifactId&gt;dummy&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;jcenter&lt;/id&gt; &lt;url&gt;https://jcenter.bintray.com/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;de.esoco&lt;/groupId&gt; &lt;artifactId&gt;coroutines&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; ``` i'm still getting the same error 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
In the case of meltdown and spectre, as long as you do not run untrusted code on your jvm (eg Javascript, or using a security manager), you're fine. I am not aware of any recent cves that resulted in anything worse than dos for a jvm running no untrusted bytecode.
[kilim](https://github.com/kilim/kilim) is also "pure java" - just add a single dependency to your pom for that matter, i think quasar is as well (it uses a javaagent)
&gt; there's probably better **free** resources online, for **free**. It's contagious, stop reading that! 
Interesting, would this be the place to address how hard it is to build the JDK on Windows?
&gt; require either additional build and/or runtime tools (bytecode manipulation) this is FUD. under the hood, lambdas use ASM to generate the code, which is the same tool that the alternatives use 
Right, but given OP is talking about "production environment", I was assuming in a commercial situation.
&gt;No, that is not what "sign over" means. I'm forced to give a shared copyright and licenses to all my patents to Oracle, it means they can run off and do anything they want with it. That is absolutely 100% "signing over" my work to them. &gt; all other companies that famously care deeply about other stuff don't seem to care enough to fund the development necessary for them to hand you the value you want Yes they do, which is why we're moving to their platforms and away from Java. And I have to point out that in all these posts you spam all over /r/java, you still have not been able to provide a single hard technical argument for the changes. It's always some vague hand waving about how some mysterious, unnamed "others" think these are great changes. Based on everything I've seen, the only conclusion I can come to is that now that Oracle failed to sue money from Google (i.e., the primary motive for buying and keeping Java), they are coming after the Java developers for money. They do this by imposing a great additional development costs by breaking backwards compatibility ("deprecation"), moving to a six month release schedule and refusing to backport any fixes, and forcing the developer to re-compile and distribute in every release by getting rid of the JRE, and then selling the LTE version to get rid of those costs.
&gt; I'm forced to give a shared copyright and licenses to all my patents to Oracle A patent license is required for open source. *Shared* copyright/perpetual license is common practice in many open source projects and is not "[signing over](https://idioms.thefreedictionary.com/sign+over)" anything. &gt; you still have not been able to provide a single hard technical argument for the changes Those hard technical arguments have been given and discussed *for years* in the appropriate channels (not Reddit). It seems like most developers are happy with them (see e.g. talks by non-Oracle people like [this one](https://vimeo.com/289852355#t=712s), which also discusses in some length the technical necessity for the changes, or [this one](https://youtu.be/yUFqLkzD7WE)). However, even after years of discussions, as with every change to a platform with over 10M users, some will be displeased. &gt; they are coming after the Java developers for money. While OpenJDK's development needs to be funded somehow, we obviously see things differently. You are perfectly entitled to your opinion.
&gt; it's about all similar constructs where there's too much going on in one place (I've seen it often enough). And I've seen such discussions often enough :) &gt; But the general idea is not mine, it's Uncle Bob's (Clean Code). He has a lot of valid points only to invalidate them by being dogmatic about the points. In other words: "it depends" is not in his vocabulary. Just like everyone who sees a single `break label` statement automatically derives the end of the world from it &gt; However, note that you evaded the core of the argument (i.e. separation of concerns, unambiguity, flexibility), yet you responded to my minor remark about a helper class :) I don't reply to unnecessary escalations &gt; I noticed a minor but significant enough problem here so I wrote about it (at length, true - guilty of that!). Precisely my point :) &gt; Finally, I did not imply anyone could worry about the quality of your code in general. That's not how I meant it. &gt; Yet, this particular thing is something I consider a code smell (and it's something I wouldn't like to work with). *That's* how I meant it. It should definitely be possible to work with the occasional `break label` statement in code. How do you even manage to look at / debug JDK internals?? :)
Depends on type of tests. We do API automated tests using postman to build api calls then Newman to run a collection of them. Works great for api testing and avoids writing more code plus u can publish and share the postman collections as part of your developer api docs. 
Jeah its pretty simple and straightforward - I once wrote a plugin which allowed the user to type in a problem description, press enter and get a list of solutions from stackoverflow. 
So in 2023 OpenJDK isn't being supported anymore?
It looks like in your [submission](https://www.reddit.com/r/java/comments/9wgp0z/company_wants_to_pay_for_java_certifications/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
It sounds like Integration Testing is what you want. Unlike pure unit testing, ITs test functions that may include multiple classes, even full interaction of MVC layers using an embedded database. Once you have written them using JUnit, look at Jenkins as a way to automate their execution and reporting 
As an intern learning is a bit far of your job. But you should be familiar with mocking / stubbing tests, and probably end to end with selenium.
&gt; That is "signing over" no matter how you try to spin it. I'm sorry, but shared ownership is not transfer of ownership no matter how you try to spin it. &gt; This is why Java should be forked away from Oracle and the future code rights assigned to a non-profit foundation. Great, but who will fund it? &gt; Again you provided zero arguments why my conclusion is wrong. I am trying very hard to keep my cool, as I have explained to you over and over that Reddit is not where OpenJDK conducts its technical discussions. I have also linked to a precise moment in a talk by a non-Oracle speaker who summarizes the technical necessities and benefits of the various changes, which you clearly have not watched. For the benefit of those who are interested to follow the real discussions and engage with them, here is a list of those that I believe you have issue with, namely the module system and the release cadence: **Modularization** Proposals: * [The massive, monolithic JDK](https://mreinhold.org/blog/massive-monolithic-jdk), 2008/11/25 * [Packaging Java code](https://mreinhold.org/blog/packaging-java-code), 2008/11/30 * [The Modular Java Platform](https://mreinhold.org/blog/modular-java-platform) 2008/12/01 * [JEP](https://openjdk.java.net/projects/jigsaw/) Discussion: * [Ten years of discussions](http://mail.openjdk.java.net/pipermail/jigsaw-dev/) **New Release Cadence** Proposal: * [Moving Java Forward Faster](https://mreinhold.org/blog/forward-faster), 2017/09/06 Discussion: * [The OpenJDK Working Group](https://community.oracle.com/community/groundbreakers/java/jcp/executive-committee/openjdk-working-group/content ), 2017/2 and on * [OpenJDK Governing Board Minutes](http://openjdk.java.net/groups/gb/minutes/2017-08-24), 2017/8/24 * [Mailing List Discussion](http://mail.openjdk.java.net/pipermail/discuss/2017-September/thread.html), 2017/9 * [JCP Executive Committee](https://jcp.org/aboutJava/communityprocess/ec-public/materials/2018-04-10/JCP-EC-Minutes-April-2018.html), 2018/4/10 * [A nice summary for the lazy by a non-Oracle speaker](https://vimeo.com/289852355#t=712s) 2018/9/13
Hi redeso, nice framework, thanks for making it. For some reason, I cant edit the title nor access dzone article :-/ Im leaving here 2 links, your(?) article on medium [https://medium.com/@esocogmbh/coroutines-in-pure-java-65661a379c85](https://medium.com/@esocogmbh/coroutines-in-pure-java-65661a379c85) and the nice concept of thread nursery [https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/](https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/) Also , project loom: [https://cr.openjdk.java.net/\~rpressler/loom/Loom-Proposal.html](https://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html) Sorry any mistake, typing this with onscreen keyboard.
I'm probably not experienced enough to comment on this manner, but I think logging system is one of those things you don't need to build from scratch. At least for me. I usually just end up using some built-in or 3rd party library, because the non-customizible parts are responsible of the security. I'd rather not expose authentication to my own mistakes.
Not OP, but we're using docker to spin up two databases, some JMX infrastructure, a Kafka instance - all from within the application test classes. Those then spin up the application which connects to all of the above, and the test classes then send messages or do API calls and verify the results (in all external systems). And this all runs during `mvn verify`. Or, just point your IDE at a specific test method and run that. 
Thank you, man. I will take it there then.
No problem! I'll try to help over there.
That's a lot of global variables....
JUnit itself is a large well tested project. It's interesting to see how the authors themselves have used their own platform.
https://openjdk.java.net/projects/portola/ Definitely seems like work is happening in the direction
Find something using mockito and wiremock. Unit tests are best when the unit under test is the only variable not under the test's control.
What sluggishness are you referring to with spring boot? The startup time?
JUnit coupled with mockinng frameworks like Mockito and Powermock should be enough to write effective unit tests. In java context, you have to keep in mind though that unit test is focused towards a specific Java method. You can also do integration testing to cover more code. Since you have a large code base, I would suggest use a combination of both Unit and Integration testing. Unit testing for the core functionalities and Integration testing for components that make sense to test mostly when they are wired together. For example, testing a Rest/MVC Java controller seems better off with integration testing. Popular Java frameworks like Spring have their own testing libraries that are very suitable for Integration testing.
Regarding the side note - true, but you can grab a few bugs, that the devs didn't think about. It's better to have a little coverage, than to have none at all. And most companies hire new people to do tests, since it isn't destructive - you cannot fuck up a test so bad, that 'skip tests' stops working.
This is the second time you post **Processing** programs on /r/java. This subreddit is **exclusively** for **Java** as well as **tutorials** are forbidden here. Next violation will earn you a permanent ban from here. 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
It's a compiled language.. you can fine tune base spring boot to startup in 2-3 seconds. Check the documentation of boot 2.1
[Yes](https://bytefish.de/blog/jdk8_files_lines_parallel_stream/).
More specificaly, yes since Java 9.
Incidentally, I have actually read that. But it doesn't help me understand the whole stream appears to block on the I/O calls? 
Because lines() is eager and will read all lines in memory first. 
What version are you on? A small Spring Boot 2.1 service starts up in 1.5 seconds on my machine. Do you use Hibernate?
It looks like in your [submission](https://www.reddit.com/r/java/comments/9wngko/does_fileslinesparallel_create_a_parallel_stream/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Perhaps, if there's some proposed strategy to make life easier. For more immediate concerns, such as suspected bugs and getting some help setting things up you might be better off browsing and asking questions over at the build-dev openjdk mailing list. A common issue is that devs install the latest version of visual studio or gcc and expect it to work, while often other, more stable versions are used internally. The JVM code base by necessity and/or historical reasons does things compilers sometimes take issue with, so upgrading to work as intended on the latest toolchains is sometimes non-trivial.
There are release notes and issue tracker is also available. If security is important to you, you will find whatever you need to know about which security issues are fixed in a certain Java version. But it sounds to me that security is not that important to you :)
My recommendation is: 1. Understand the difference between tests and IntegTests. You don't want to test other systems. 2. Make sure you're not pointing to your production instance for ANYTHING. Not even a comparator! 3. If you're not 100% sure what the method does, isolate methods to test in a test project and walk through it. Think of things that could break it. Are they checking maximum length? what if it's an empty array? If using generic, does it account for a different object, etc. 4. Understand the inputs and outputs of the method 5. Write a working unit test, don't repeat yourself. There is no point in testing "ABC" then "CBA". Test scenarios, not inputs/outputs. Don't forget about testing for nulls, too many, not enough. Each field and variable should be tested separately (that doesn't mean a test method for each). 6. Write unit tests that chuck exceptions, and except them. As a side note do watch this: [https://www.youtube.com/watch?v=nf2xpqcZouY](https://www.youtube.com/watch?v=nf2xpqcZouY) &amp;#x200B;
Oracle provides completely free JDK builds at [jdk.java.net](http://jdk.java.net/) that require no licensing of any kind.
Thanks for trying again. I built a Maven project and noticed that Maven doesn't support Gradle's wildcard version notation which causes the failing dependency download. But there is a workaround, just add the additional dependencies to your pom: &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;de.esoco&lt;/groupId&gt; &lt;artifactId&gt;coroutines&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.obrel&lt;/groupId&gt; &lt;artifactId&gt;objectrelations&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;de.esoco&lt;/groupId&gt; &lt;artifactId&gt;esoco-common&lt;/artifactId&gt; &lt;version&gt;1.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; This worked for me. In a future version I'll change the dependency to a fixed version so that it'll work with Maven directly.
Hibernate, Flyway, Quartz, 20 services, 25 repositories, 10 controllers.
I wish it said "Java EE 8" or 'Jakarta EE 8'. Saying Java 8 seems as if it just enabled support for an EOL Java.
came here to say exactly same thing
If you read the release notes it is just now providing support for Java 8 (not java ee or jakarta ee). Before this release you had to use Java 7. &amp;#x200B; [https://www.tomitribe.com/blog/tomee-an-overview-of-the-tomee-7-1-release/](https://www.tomitribe.com/blog/tomee-an-overview-of-the-tomee-7-1-release/)
&gt; The monolith is appropriate only for a very small application, if at all. Sorry but calling BS. Microservice architectures have nothing to do with the size of the application. They are a solution for large *organisations*. If you're going to be spending 2 years building an application with a team of 4 developers sitting in a room together, I would still strongly urge you to go for a monolith. Microservice architectures work for large organisations with multiple teams working on the same 'application'. You can't scale a team larger than what you can feed with 2 pizza's, so you need to break the org up into separate teams. There it makes sense to have each team be responsible for a few applications and have those applications talk to each other via some agreed upon method. Back in the days these were enterprise integration patterns via a stateful service bus, and that was a shit approach. Now they communicate directly via HTTP (and we call it microservices instead of SOA) and it's slightly less shit. It's still complicated as heck and easy to fall into the trap of building a distributed monolith if your team is not up to par (and frankly; most teams aren't), but at least that's better than building an undeployable monolith. 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
That's much too generalising a statement. Aside from that, it's not about HTTP versus non-HTTP. It's about synchronous versus asynchronous (or event-driven) architectures. I'm definitely in favour of employing event-driven architecture principles in a system, but it's often not possible to just make the entire system event-driven. A simple example is an architecture that supports a mobile application: it's generally not advisable to make the part between your mobile app and the api-gateway asynchronous (customers don't like websocket connections that are kept open). So you have to carefully mix the two paradigms. And this is something every team 'doing microservices' runs into. 
The convention is to reverse a domain name you own. So if you own the domain name something.com.mx, the package would be mx.com.something. 
&gt; It's about synchronous versus asynchronous Indeed, I should have used the word "synchronous HTTP" in my comment.
Hah, maybe it's not simple in microservice world, I have most experience in financial and medical industry with code bases for &gt; 5k classes ;)
It looks like in your [submission](https://www.reddit.com/r/java/comments/9wqpmr/java_beginner_where_to_start_first/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt; If you're going to be spending 2 years building an application with a team of 4 developers sitting in a room together, I would still strongly urge you to go for a monolith. But I wanna do what the cool kids are doing!
What I learned is that in practice many people don't really care, even though the standard is to use a domain name. If you care about the standard, use `mx.com.something`. If not, just use some name that is unlikely to clash. There's no enforcement. An example is Scala, which just uses `scala` for their package name, even though `scala` is not a top level domain. [https://www.oracle.com/technetwork/java/codeconventions-135099.html](https://www.oracle.com/technetwork/java/codeconventions-135099.html)
That defeats the purpose of what I was trying to achieve.
How is executing `./myapp.sh` or `myapp.bat` (for windows) any different than doing `./myapp.jar`? 
Two files instead of one? Nothing else, but if I wanted to "ship" an sh file along with a jar I would've not asked the question.
Java 8 has javapackager which was added in java 8 and is a great tool. It has been stupidly removed from java 11. (although looks like it is coming back https://openjdk.java.net/jeps/343) There are examples at the end: https://docs.oracle.com/javase/8/docs/technotes/tools/unix/javapackager.html I think javapackager was removed from the JDK in 11 because it was part of JavaFX, although it could create non-JavaFX apps too. Think it was kind of overlooked in the JavaFX separation and then everyone started to complain about that great tool being removed, so the JEP was born. (this is my take by following the JDK and JavaFX mailing lists)
You're right; the lesson here is convention isn't always correct. As you say, the reccomendation to use domain name reversal is to ensure that packages, aka namespaces, are unique. People have miscontrued this to be "ALWAYS USE REVERSE DOMAIN NAME?!?!" The reality in practise is that it's very possible to end up writing a 15+character package name, which becomes simply too beastly.
I want build times less then 12minutes. I want to solve domain problems instead of fighting against monoliths complexities. 
If you want short build times, microservices are often the wrong way to go. I've seen projects where changes can ripple through a dozen services, each having to be built and deployed before the next in the dependency chain can be updated. 
I'm taking about local branch. With MS I'm only building one project at a time
The primary porpoise of package names is to achieve is a collision with another developer's classes. As long as your package name is something that other developers are extremely unlikely to use, then your own project is safe. If you are building a library for the general public to use (eg, on github), then you would want to be more careful in your package name choice. For personal code you might have: name.JohnDoe.\* name.johnDoe.util.\* name.johnDoe.api.\* &amp;#x200B; For a company name Killer Foobars Inc, you might have: killerFoobars.\* killerFoobars.util.\* etc, or . . . mx.killerFoobars.\* Maybe the "com" is unimportant. &amp;#x200B;
That sounds more like a distributed monolith rather than a microservice architecture. If you end with tight coupling like that you've fucked it up. 
Magical thinking. Dependencies don't just disappear because you invoke "microservices", "SOA", or whatever the fad of the day is. 
For personal projects I often just use something like com.github.username or the gitlab variant.
Scala is not really an example because the `scala` prefix is used for the Scala standard library. Language standard libraries are exceptional (like `java`) as the packages are under the control of those who make the compiler, and this helps ensure uniqueness. Even if there are two JVM languages by the same name, it's unlikely that *both* standard libraries would be used in the same project. Anyway, for public projects it's best to follow the convention unless there is a very good reason not to.
They're working on Java 11 compatibility for TomEE 8. 
Lambdas are a built-in feature of Java. I do not nead to add build tools to use them or execute Java Agents to run in parallel with the application code. I'm not saying that such solutions are bad. But I personally prefer solutions that can be be used as simple dependencies if possible.
The kilim documentation mentions a "weave" execution necessary to be performed in the maven build. Isn't that an additional build tool? And from the documentation I cannot derive how I would apply that from Gradle.
It's a strategy that has pros and cons like any other; just like microservices are a strategy. Just like serverless is another. Can't wait until all the microservices get rolled into bigger services and we'll just call it macroservice architecture.
It's also atypical to use upper case in package names, because it can be confused for inner classes / fields. In the [Oracle Java tutorials](https://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html) they suggests you use snake_case even (so, `killer_foobars`), but I also haven't seen a lot of `_` in the wild. What is often done is simply concatenating the words without anything and keeping it lower case (`killerfoobars`)
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
the maven plugin is optional, eg see [the battle royale demo](https://github.com/kilim/kilim/tree/master/demos/battle) 
Monolith until Microservice, is the best strategy I think.
ah - i should have thought of that (i'd noticed the version number looked unusual). might be a couple days before i have time to try this code out again but look forward to it - thanks for the help 
Lessons learned: they both suck large moose wang
**Error 503 Backend fetch failed**
[https://www.cs.mcgill.ca/media/tech\_reports/42\_Lessons\_Learned\_in\_Migrating\_from\_Swing\_to\_JavaFX\_LzXl9Xv.pdf](https://www.cs.mcgill.ca/media/tech_reports/42_Lessons_Learned_in_Migrating_from_Swing_to_JavaFX_LzXl9Xv.pdf) — should be a PDF render of the same content.
Works for me
Topical.
Using Log4j 2 behind slf4j is not such a good idea, since Log4j has separated the API from the implementation and the API is something like slf4j, but with more capabilities. Actually it is possible to use Logback or other loggers behind the Log4j API. In other words: Log4j API is the better slf4j.
Fine on my end. Same for the PDF link.
&gt; Java10 is outdated; java 8 is not yet. Damn, what a weird world we live in.
José Paumard's SlideShare: https://www.slideshare.net/jpaumard/presentations Sadly, this presentation has not been uploaded yet, but there's lot of material there.
Oh wow, I worked on the original Swing version of this for an Undergrad research project! Really happy that Professor Robillard was able to modernize this awesome UML tool. You guys should check it out: https://github.com/prmr/JetUML
The simplest way to describe it is as an array of arrays. For example, Int[][] A = new int[3][4]; Yeilds 3 arrays holding 4 values each You can initialize one like so: Int[][] B = { { 1, 2 , 3, 4 }, { 5, 6, 7, 8 }, { 59, -48, 42, 8 } }; Which I find visualizes it in a way thats easier to understand
Please, post such questions in /r/learnjava or in /r/javahelp.
You can save posts. 
No.
Please stop helping people that post here. It's appropriate to redirect them to /r/learnjava and /r/javahelp.
It's about how long they're supported for, which is an arbitrary decision. So despite 8 being a lower number than 10, the support duration is longer for 8. This isn't unusual - Ubuntu 16.04 is still supported by 17.10 is not.
Why not have a separate controller on the service where you can POST that CSV to and have the service deal with the data itself? That way you don't have to worry about database schema changes breaking the import for example. 
No. I'm in Canada and it's broken for me too. Server is down right now.
Part Two can be found [here](https://youtu.be/2c_KNH3s2S0).
 &gt; All apps that use java should take care of shipping their own java, starting with java 11. Hurray! Finally bugs/security vulnerabilities for everyone! Short explanation: If the app author does not update the app and the bundled JRE, no JRE updates for you! So we've finally reached the Windows-Default-State "bundle everything you need, never touch it again", which is great when it comes to security vulnerabilities.
Are you on OSX ?
&gt; I didn't get such an impression when I was reading it (but it was some time ago). Could be. I've never read the book. I was referring to his ranty blog posts. &gt; That's why I provided specific arguments which you chose to (mostly) ignore :) Not because they were invalid *in general*, but because they were overengineered *in this particular case*. See, your 15 minute attention span is met by my 20 second one. :) &gt; Good point! I admit I don't know why some of JDK is written in such an intricate matter. Maybe it's about performance (good, then). Maybe the authors of JDK are so proficient that it hardly slows them down? Maybe it's just a matter of style? Like 2 or 4 space indentations? Sure, pick one across a subset of a codebase, and don't mix them all the time. But that's about it. There's no one style that clearly beats the other. The assignment expression is one of the things that is used so often inside of the JDK. And inside of jOOQ. It's just extremely convenient, and I don't see any drawbacks. If no one uses it across a code base, fine. Forbid it if it's that much trouble. But there's nothing intrinsically wrong or difficult about it. It may just be unusual for some audience. &gt; Besides, I can definitely understand and debug such code. But, it requires more effort from me. So what I'm trying to promote is writing code that requires the least effort while meeting all other requirements (e.g. performance). That "effort" is an arbitrary unit of measurement. I recently introduced a SQL `UNPIVOT` where it made total sense, because it reduced a funky query with tons of `UNION ALL` to a few lines of concise code doing exactly one thing and doing that one thing exactly once. Of course, quite a few people at that customer site were against it, because they've never seen `UNPIVOT` and now have to bend their minds around it. They preferred the verbose copy paste approach. What can I say. It's so random. Everything "new" and "obscure" requires effort, but who gets to judge what is really "new" and "obscure"? By that unit of measurement, no one should ever use an `ArrayDeque`, merely because no one has ever seen one and it causes them "effort". Let's use only `ArrayList`, right? Yay :) I've used [`NATURAL FULL OUTER JOIN`](https://blog.jooq.org/2017/03/07/impress-your-coworkers-with-a-sql-natural-full-outer-join/) to solve a very specific data type problem in PL/SQL, again to remove tons of redundancy (and bugs in accidental copy paste errors). I think the obscure syntax should be seen as causing *less* effort, because it produces *less* bugs. No? &gt; As I see it, there's currently a hype for readability (people choosing readability no matter what) that you seem to fight (which I appreciate) Yeah, don't get me started on the crazy obsession with having to name all things because it's more readable. The good old nominal vs structural typing discussion. &gt; But let's not fall prey to another hype (e.g. for brevity) :) I wish that was a hype
Does anyone a link to specific enhancements made by Amazon's version versus others? 
Is there any comparison between them? Why should someone use one JDK vs another?
https://docs.aws.amazon.com/corretto/latest/corretto-8-ug/patches.html
Not a full comparison, but gives more info than a plain list of JDKs: https://blog.joda.org/2018/09/time-to-look-beyond-oracles-jdk.html
Some basic performance testing here: [https://blog.hackeriet.no/pgadba-performance/](https://blog.hackeriet.no/pgadba-performance/) And an basic example application built with spring boot here: [https://github.com/alexanderkjall/pgadba-example-application-spring-boot/](https://github.com/alexanderkjall/pgadba-example-application-spring-boot/) Performance is promising, but it hasn't been a primary focus yet, there is a large amount of low hanging fruit to be done. There is still lot's of the proposed ADBA specification from the jdbc-spec group left to implement, but I felt that it could be fun for other people to get a more hand-on look at how the new API looks like, so an alpha release was in order.
Does anyone know of a FreeBSD Java 11 build out there? Due to "it's my job", I need to acquire one of these things and I'd rather not build it myself (been down that road before and it sucks to maintain).
OP made [this comment](https://www.reddit.com/r/java/comments/9x0rzs/_/e9om9wr) 50 minutes before yours if that helps.
Nice. Being able to do async postresql processing would remove a weak point I currently have in my Java web applications. I run web services with very few threads, typically something between 4 to 8. That works OK as long as request reading and response writing are offloaded from the request processor thread. Database queries, however, must generally be very fast, or I end up tying a thread for long periods that could otherwise do useful work elsewhere. This is arguably the weakness: you find a single part of program that's kinda slow and just send bunch of requests for that, and the thing soon can do nothing else but serve those requests. It would also help to be able to send multiple unrelated queries out at once and let the DB do them in parallel in whatever order it sees fit and pick the results afterwards. I have numerous situations where something like 10 queries must be sent out to assemble a complex response, and doing them sequentially is probably pretty slow compared to being able to start processing all of them in parallel.
One thing to note is that, [unlike Red Hat and SAP, Amazon has not been a significant contributor to OpenJDK so far](https://blogs.oracle.com/java-platform-group/building-jdk-11-together). Their [FAQ](https://aws.amazon.com/corretto/faqs/) says that they plan to increase their involvement. 
That's what Kubernetes is for; taking your ridiculously fragmented architecture and trying to making it look like a monolith.
Monolith can have a lot of code and be manageable through modules/plugins. It depends on language but from Java perspective - you can have multiple jars which can be replaced/reused. There is no best architecture, every has it's purpose.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I think this is the main usecase of the new ADBA api. One thing that maybe would make it better would be to have some form of back pressure mechanism in order to handle the usecase where a user requests a stream of objects from the database that is larger than available memory. But that would also make it a lot more complicated.
What's the point? When a computer has to switch threads, a few things happen, but most notably is the memory limitation: A bunch of different memory pages (and a stack!) have to now be used. The actual 'hop on over to this chunk of code and go run that for a bit' part is trivial, that's 1 jump, it's basically faster than jumping back to the top of a while loop. It's that memory context switch that really nails you; these days on a CPU switching pages takes 500+ cycles worth of time. But here's the thing: async platforms _are no different_: Instead of hopping to a different page due to switching stack, you... hop to a different memory page because your async code ran out of bytes to process and is now going to jump along to the next active web connection in the async hopper, reading a the bytes that arrived in the packet or two of this particular TCP/IP conversation. The major difference is primarily in memory management: Stacks are at least 1MB (on JVMs, at any rate) and you can't dynamically grow or shrink them. You can't even pick a stack size when creating threads. With async, you've got however much control you'd like: You make the ByteBuffer; you decide how large it has to be. This is a real source of performance: If you have 8000 simultaneous web connections, you can absolutely do that with 8000 separate threads. People who like to write libs like OP here think 8000 threads are going to murder your server something awful but it really won't, modern CPUs have no problem with this. But it does imply _at least_ 8GB worth of stack, and then you also need heap and classes and the like. So you do need a server with plenty of RAM if you wanna do this. With async you can have bytebuffers that are much smaller. Usually this means it actually runs slower but can run with less RAM. Mostly, performance suffers. Which gets us back to OP: What's the point? Studies done by the guy who runs mailinator show this: async means less memory needs but it's not really faster especially on linux and very modern windows, as they have excellent thread handling. The odds you have a use case where async is any faster than sync is rare. The odds you have a use case where the async is not only faster, but definitely worth the serious headache it introduces when writing code.. very rare. 
you're welcome
It looks like in your [submission](https://www.reddit.com/r/java/comments/9x2lho/login_theming_with_fusionauth_and_apache/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt;Not because they were invalid *in general*, but because they were overengineered *in this particular case*. See, your 15 minute attention span is met by my 20 second one. :) Fair enough :) &gt;Maybe it's just a matter of style? Like 2 or 4 space indentations? Oh, come on - you can do better than that ;) The difference between 2 or 4 spaces (or tabs, for that matter) is *purely* one of ^(4\))familiarity (and myself, I hardly even spot this difference). But the difference we're discussing here is one of: ^(1\))separation of concerns, ^(2\))unambiguity, ^(3\))flexibility, and - last &amp; least - ^(4\))familiarity :) So please, do not reduce my argument to the least important aspect! &gt;The assignment expression is one of the things that is used so often inside of the JDK. And inside of jOOQ. It's just extremely convenient, and I don't see any drawbacks. The main drawback is potential mistaking it for `==`. I rather avoid it (in Kotlin, it's not even there). But I don't have strong feelings about it. Sometimes, it's the *best* thing to use, e.g. in `while ((next = inputStream.read()) != -1)`. &gt;I recently introduced a SQL `UNPIVOT` where it made total sense [...]. Of course, quite a few people at that customer site were against it, because they've never seen `UNPIVOT` and now have to bend their minds around it. They preferred the verbose copy paste approach. I can understand it (people generally don't like changes; in a way, we're lazy by nature). But I could bet that - given *enough* time to get familiar with it - they wouldn't want to go back (due to the same laziness). So, if you managed to capture a complex *enough* logic in a new but consistent *enough* feature, I'm **all for it**! If I wanted a language where I have the lowest number of instructions to learn, I'd program in assembly ;) OTOH, I specifically chose jOOλ over StreamEx because the latter seemed to have too much unfamiliar functionality. In other words, there's this sweet spot where you only introduce features that are complex enough, consistent enough, important enough, etc. Incidentally, that's why some of my feature requests to jOOλ are still pending, isn't it? :) &gt;I've used `NATURAL FULL OUTER JOIN` [...]. I think the obscure syntax should be seen as causing *less* effort, because it produces *less* bugs. No? I totally agree! It may be obscure, but it provides separation of concerns, unambiguity, reliability (hence, fewer bugs).
In theory you could also use Applets for that purpose, all though I wouldn't recommend it 
As the other commenter pointed out, you can, but it’s probably better to use Maven or some other build system.
To be honest I haven't done enough performance testing to have any good opinions on context switching and threads, I have to leave that to those that have more experience. I can give you one very concrete performance improvement that's easier with an async api, and that is what's sometimes called query pipe lining. If you limit yourself to a specific subset of the postgresql wire protocol, then you are guaranteed to get one answer for every query that you send. This means that you can start sending query number 2 over the wire before you have received the answer from query 1. This can have a big impact, imagine that you have a 1 ms latency between your application server and your database server, this means that the max limit on number of queries per connections per second is 500, even if your database answers instantly. &amp;#x200B; This can be handled by starting more connections to the database, but since the postgresql database forks for every connection that is made, it's not recommended to have to many connections. This can of course cause other issues down the line, if some queries are super slow you don't want fast queries to get stuck behind slow ones for example, but that is more of an application problem rather than a library problem.
Commenting so I can reply later
they're not even truly concise - there are fewer characters but a larger alphabet. for most usages, the total complexity seems pretty much the same
Speed difference compared to what? Brian Goetz talk about the representation of lambdas [here](https://youtu.be/MLksirK9nnE), which is dynamic.
[Called it]. Absolutely called it.
&gt;I don't really know how I would go about implementing unit testing into a much larger project. Any advice? Use Eclemma to check your unit test branch coverage as well as line coverage before checkin. Learn how to make your tests cover as many branches as possible. Set up unit test reports in the pom.xml using Jacoco. Set up a SonarQube server and start tracking unit test coverage reports over time on the production build. Set up quality gates using rules and coverage requirements agreed upon by your team.
No win 10.
Ok this makes sense.
Looks like they have had it for while but just not sharing it out
I wish maven would either drop XML, allow XML imports so my POMs could be split up, or allow other file formats. There is a maven plugin to allow other languages to be used, but I wasn't able to get it to work. I'd use Gradle, but IntelliJ's integration seems poor. It keeps presuming I'm building for android.
There is an outstanding issue for allowing the use of attributes in pom.xml, which would drastically reduce the verbosity of build files, but it won't happen before maven 4.
That's what you would use lambdas for.
Thank you very much for the answer, I’ll look into them.
The problem i face is while assigning to “test” the value of the return of the method, java also executes that method, i’ m now looking into lambdas as suggested to prevent the method from executing while still assigning its value to the variable.
That doesn't make any sense. How can the method return anything without executing? do you have an example of what you are looking to do? What do you think would be assigned to test if object.method() didnt execute?
&gt; Gradle That's not normal behavior. What's in your build.gradle file?
One way to achieve it: Supplier&lt;Double&gt; testSupplier = () -&gt; object.method(); double test = testSupplier.get();
 double test = object.method(); return test;
Use a functional interface reference of the method like Supplier, Consumer, ir Function. Idk why people are mentioning lambdas...those utilize FIs you just want a reference. Supplier&lt;ClassName&gt; method = this::method Or ClassName::method if it's static. This will effectively give you pointer ish access which is what you want it sounds like
Keep playing with grade! I switched from maven and I’ve never looked back. I’ve never had IntelliJ think I’m building for android. I started with using grades directly from the command line and it really helped. Ask me any questions you have!
Charmingly awkward.
Is a fiber the same thing as a Kotlin coroutine 
Conceptually I think kotlin has the language built to support it. Not sure how fiber will integrate with jdk
IMO, it's more than coroutines. You don't need any special adaptation for any the blocking java APIs. Blocking operations will park the fiber and the carrier thread will be released. That means, most of the known blocking java APIs will become non blocking in Fiber without any change. That's a huge deal IMHO. No more blocking jdbc :)
Next time, please follow the rules of this subreddit and post programming related questions in /r/javahelp.
I can tolerate the verbosity of Maven as somehow pom.xml files feel statically typed, especially in IntelliJ but Gradle quickly becomes messy for large multi module projects. 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt; So please, do not reduce my argument to the least important aspect! [...] Of course I do and will continue to do so. It's just a simple loop. It doesn't deserve this attention, let alone 4 categories of code quality classifications! &gt; Sometimes, it's the best thing to use, e.g. in So, why does this judgement not apply to `break label`? I tell you why. Because these code *style* arguments are purely subjective. They originate from a matter of taste, and evolve into analogies with much higher level architecture principles and classifications. &gt; OTOH, I specifically chose jOOλ over StreamEx because the latter seemed to have too much unfamiliar functionality. In other words, there's this sweet spot where you only introduce features that are complex enough, consistent enough, important enough, etc. Incidentally, that's why some of my feature requests to jOOλ are still pending, isn't it? :) You're now pretending that an API and its implementation are the same thing. The implementation is hidden and you don't need to care how it's written. But the API is an entirely different story. You've read my [recent blog post](https://business.jooq.org/the-many-hats-im-wearing-as-a-founder/). The API design's main focus is UX. So, your classifications most definitely apply here. They do not apply to a very local, internal algorithm.
There is no need for language integration when the construct is powerful enough. From the perspective of the user, a fiber is a thread; there is no need to distinguish between methods that run in fibers from methods that run in threads. From the perspective of the OS, however, a fiber never issues thread-blocking operations. Any call to a blocking operation becomes fiber-blocking rather than thread-blocking.
Do you have some good links for reading about the things in your first sentence? I'm gonna try to Google but hoping you have some on hand. =]
It looks like in your [submission](https://www.reddit.com/r/java/comments/9xap3s/help_with_this_code/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
[Records](https://cr.openjdk.java.net/~briangoetz/amber/datum.html), [Fibers](http://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html), [Value Types](https://openjdk.java.net/jeps/169), and [Generic Specialization](https://openjdk.java.net/jeps/218).
Hi, Did you solve the problem with junit-jupiter? without adding deps for junit5 - as it's not used in your (and mine) project
You should definitely take a look at Laconic POM https://plugins.jetbrains.com/plugin/10580-laconic-pom
&gt;&gt;So please, do not reduce my argument to the least important aspect! [...] &gt; &gt;Of course I do and will continue to do so. It's just a simple loop. It doesn't deserve this attention, let alone 4 categories of code quality classifications! Well, it's sad :( You may be right that it doesn't deserve this attention, is overengineered, etc. As a result, I accept that you can ignore it or treat it superficially. But this in **no way** justifies your *intentionally* distorting my argument (see [strawman fallacy](https://yourlogicalfallacyis.com/strawman)). &gt;So, why does this judgement not apply to `break` label? Because in comparison to `break`, concerns are easier to separate there, it's less ambiguous, and it's flexible. In other words, I don't see a better solution there (I mean, you could wrap it up in some custom class, but it'd be such an overkill). And I *definitely* disagree that "the implementation is hidden and you don't need to care how it's written". I assume you just oversimplified it in haste. Because if you hadn't then: - extra private methods wouldn't be a problem (you said they would) - extra package-private classes and indirection wouldn't be a problem (you said they would) - even `goto`s in code wouldn't be a problem (not that you mentioned it) So, we *do* care about the implementation. We simply care about it *much less* than about the API (and it's good because implementation is easy to change, and API isn't). I've read your post (which I liked a lot, truly!), and I agree with the UX perspective. But what about the DX (Developer eXperience) perspective? It's much less important than UX, but (especially in business code!) it *is* important enough to care about it to *some* extent.
It takes two seconds to add Guava to Maven. It's like "super simple". Just go to [search.maven.org](https://search.maven.org) and copy-paste the XML provided in the dependencies: &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;27.0-jre&lt;/version&gt; &lt;/dependency&gt; &amp;#x200B;
Well, all native applications have this property, too. But even looking just at Java and comparing the current recommended practice (a bundled custom runtime) to the old one (a shared "system" runtime), I'm not sure the security compares unfavorably. 1. The packaged runtimes are minimized to contain only the modules the application requires, so they have a lower attack surface than a full, shared runtime. Similarly, as the runtime is not shared, you are not affected by bugs in code the application doesn't use. 2. Most vulnerabilities (not counting the many related to the old and removed deployment mechanisms, applets and Web Start) are in the applications (and their libraries), not the Java runtime. 
I think it may have something to do with Gradle. I updated to the 5.0 release candidate and now my tests work without the extra dependencies. wrapper { gradleVersion = '5.0-rc-3' distributionType = Wrapper.DistributionType.ALL }
The strawman reproach often kills a discussion that has been taken too far anyway. So let's just agree to disagree. Cheers!
Just to check, have you considered frameworks built on top of core GUI libraries? E.g. Eclipse RCP. This is the one we are considering right now with a view to get a lot of functionality out of the box.
It looks like in your [submission](https://www.reddit.com/r/java/comments/9xccku/working_on_a_class_project_and_i_cant_figure_it/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I have watched the video yet but from what I know about other implementations you’re basically putting thread scheduling into the JVM with fibers. This can improve performance because threads are relatively heavy weight. Performance is generally limited to how good your scheduling algorithm is and how well it’s tuned to a particular workload. Coroutines are quite powerful in the sense that they give the developer that ability express relationships between data allows the work to automatically get executed in parallel. Both are solving different problems IMHO 
Loom fibers are scheduled in the JDK *libraries* (and implemented in Java), not by the JVM. What the JVM provides is delimited continuations (coroutines), and fibers are implemented on top of them.
This isn't the right place to start. Ask in /r/learnjava
This and if you don't already know programming, you won't master it in 5 months. Sorry.
look up derek banas on youtube.
I've known Java for 18 years, which for context, has been 2/3rds of my life. I am not a Java master. You are not going to master it in 5 months. If you want to learn how to program in Java, I recommend you find a teacher or some good books, and expect to spend at least a few years until you feel comfortable with the capabilities of the language.
"I have no chemistry background but want to master O chem in 5 months" lmao You will have the basics "down" by then if you go hard
yeah dude. the verb definition of 'master' is: &gt;acquire complete knowledge or skill in (an accomplishment, technique, or art). I'm a native english speaker and I'm not 100% confident I've 'mastered' english. More seriously, 'mastery' shouldn't be some impossible feat though. Would senior level correlate roughly to 'mastery'? Probably, especially if you're talking to people outside the industry. I suppose it depends on how much you use that specific language on a daily basis as well. Or you could make it percentile-based, maybe the top 10% are 'masters'. Hard to measure though. Personally, I got 'expert' in C# on pluralsight, so I consider myself a super-ninja master at my coding dojo.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Good info to have. Sticking with Java 8 regardless.
Been flying on planes for decades. Want to learn how to master jet engine design in 5 months.
I didn't mean to be reproachful - I named it for what I believed it to be. Still, I found much value in this discussion. Thank you for it!
Lol
Huh I've never heard the term snake case.. cool
Haven't checked out Eclipse RCP yet, maybe I should. I'm struggling with JavaFX, JDK11, Kotlin and modules currently so I'm considering switching.
Use JPA, @Column(name = 'column_name') private String columnName Otherwise rowmappers
Or, use an automatic solution which applies the same rules consistently to all JPA mappings.
I'm still using 1.6 :(
You won't be able to *master* Java in a lifetime. The system is way too large to even master a fraction. This subreddit is not for questions about Java programming nor about learning Java. /r/javahelp is for the former, /r/learnjava for the latter. There is a *sidebar* (old reddit only) with plenty good tutorials.
Alternate solution: use the same case in both places (I use camelCase in databases, despite warnings as to the horror of capitalization in DB names, it's mostly a legacy concern).
We need more articles about JavaFX like this one.
Great effort. thanks for sharing. how is this compared to [https://github.com/reactiverse/reactive-pg-client](https://github.com/reactiverse/reactive-pg-client) &amp;#x200B; &amp;#x200B;
&gt; I'd use Gradle, but IntelliJ's integration seems poor. It keeps presuming I'm building for android. ??? IntelliJ has spectacular Gradle support. It just works. 
I really like typescript, but imo it has some...major problems I've had to work around. One major example for me is using refs in react, and calling methods from the ref. It doesn't let me cast or anything like that it just treats it as a generic object and acts like it's methods don't exist. This basically makes react unusable. As far as using it for general dev yeah sure it's good, but why the fuck would you use it for your backend? Just use Java. If you're gonna use typescript your development will BARELY be any faster than Java if it even is. The fact of the matter is there is still no IDE for js that's worth half a squirrel fart much less ts. Everyone seems to hate Eclipse, but even it's intellitype is infinitely superior to any kind of js plugin for sublime. IntelliJ I can only assume from most peoples' perspective has even better intellitype. So..why use TS? This blog post doesn't seem to make any compelling arguments so much as show a basic typescript tutorial.
https://en.wikipedia.org/wiki/Snake_case
When one block is empty it sets according to the data given to it. Here total items are given so Rows and Coloms will automatically set itself
Looks like Java 8 will be the new Win XP.
 &gt; Well, all native applications have this property, too. On Windows...and it sucks. &gt; ... I'm not sure the security compares unfavorably. You always get away worse, because you don't have the possibility to solve bugs in *all* applications at once. You simply lose that ability, and that is worse. Because it means that security fixes in the base libraries are now up to the app maintainers. The worst example regarding packaging all required libraries is having *any* public facing system as such. Imagine the following, you have three services which bundle their won libraries, an SSH server, a web server and a SMTP server. All these bundle their own version of the crypto-libraries. Now if there is a security vulnerability you have to get all three updated instead of updating the base libraries. Of course that is a little bit unlikely in the Java world, but this is one of the worst-case scenarios for bundling runtimes and base libraries. Of course, the current situation isn't *that* much better given that we already bundle all needed jars, but at least the JRE was so far separate and all Java applications could benefit from updates to it. Not anymore. How much worse you get off, I can't say, it depends. But you're always getting off worse when bundling.
Does that mean you took the black pill?
You dont have to choose between OOP and FP. Competent and Pragmatic programmers use them together, with OOP as the main paradigm and FP complementing OOP in areas where it fails to address(ie. use FP's closures to replace imperative loops). 
Not sure what you mean.
How modern can it be if it's still using an app server?
It sure as heck is an easy way to judge potential employers. A simple "what Java version are you on" reveals a ton. 
&gt; You dont have to choose between OOP and FP. Didn't watch the video did you?
&gt; IntelliJ I can only assume from most peoples' perspective has even better intellitype. IntelliJ is very nice actually, but you need Ultimate. The JavaScript plugin you need doesn't work on CE. 
There's no use case for JavaScript (or TS) on the back-end. Compared to the JVM I can't find a single benefit that the JVM can't also bring (async model is brought up often, but that's what we have) while the Java ecosystem has huge benefits over the generally immature (to put it kindly) NPM ecosystem. The tooling is better. The libraries are better. And the community is better. So it's rather curious that us Java devs are described as 'cranky'. Maybe, just maybe, JavaScript devs should try and listen to us cranky old farts instead of making mistakes (like the left-pad mess) that were solved over a decade ago. 
https://www.baeldung.com/hibernate-naming-strategy
For Java at least I very much prefer Eclipses system. It just seems to work better for me as far as showing the base interface, the implementation, and the class, as well as method params+names etc. The moment I hit . all that shit pops up with every method
&gt; For Java at least I very much prefer Eclipses system. I think you're nuts ;) But that's fine, to each his own :)
Wait till you learn about kebab case. ;) 
&gt; threads are relatively heavy weight. Processes are heavy weight: Threads fftw. Threads are heavy weight: Fibers fftw. Fibers are heavy weight…
Fibers biggest benefit is that you can use them with blocking IO and not pay the thread stack size costs (huge benefit really).
continuations ftw
"Fuck it; three words is enough to comment on" - /u/Hall_of_Famer Is this how bad our attention spans has gotten?
so the context switches ONLY on blocking operations or can switch at other points as well? Like in Go? Because in Go, you still have to worry about data races and atomicity of operations. Coroutines, on the other hand, are safe in this regard.
so the context switches ONLY on blocking operations or can switch at other points as well? Like in Go? Because in Go, you still have to worry about data races and atomicity of operations, because the context can switch on any function call. Coroutines, on the other hand, are safe in this regard.
&gt; From the perspective of the user, a fiber is a thread threads have other disadvantages, not only performanse.
it is a benefit only when working with legacy libraries.
I think this talk would have been a lot more englighting if he had illustrated any of claims with actual examples. The 'drawbacks' and 'downsides' he mentions for FP for example sound very much like strawman arguments. His examples around Erlang for example are really in bad form since it's probably the only FP language which has the drawbacks he mentions and it's because Erlang was not designed or intended to solve the problems Goetz is describing. I am very happy to see Java finally (after the decade+ stagnation after the Oracle acquisition) adopt the functional techniques that are widely considered by now to be mandatory. But merely enabling these features is not going to address any of problems of OOP Goetz outlines in his talk. Introducing Lambdas is not going to stop people from using POJOs the way they have been using them for 20 years. I do think however, it is very commendable of him to at least point the problems out and begin the dialog for the Java community to learn from other languages. I think if you followed Goetz's prepositions to their conclusions you'll find that other languages already have these problems solved and his (what seems to be from the video) obsession with Erlang is blinding him to how those languages address the OOP problems and the FP problems he outlines. 
you don't need massive concurrency for working with a database. A thread pool is enough. The number of concurrent connections is limited anyway.
I dont know for sure.. but I thought JEE 8 was out or coming out soon and would be based off of Java 8. Been out of the loop a little bit on that area as we were using Spring for the past few years. Now that Java is in 6 month release cycles, I am curious how they will do JEEs. Probably be best to base it on LTS only releases.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
With green threads, I don't think so. However, Rust's Future implementation is pretty fantastic. Mind you this was early so it may have changed, but at one point they built a state machine at compile time. http://aturon.github.io/2016/09/07/futures-design/
&gt; context switches ONLY on blocking operations or can switch at other points as well I think only on blocking operations (I am not sure if the continuation object is exposed in the fiber to do the explicit yielding). I think this is same for go also, Places where Goroutines may yield to others are: Channel send and receive operations, if those operations would block. The Go statement, although there is no guarantee that new goroutine will be scheduled immediately. Blocking syscalls like file and network operations. After being stopped for a garbage collection cycle. 
&gt; built a state machine at compile time Isn't this the case for any coroutines implementation (Eg: in Kotlin Coroutines)? 
..probably didn't set the project as using gradle?
Java's lambdas, at least the way they are integrated with the rest of the system, are horrendous, especially when your lambdas might throw checked exceptions. If they fix it, no problemos but they have no intention of doing that: https://stackoverflow.com/a/27648758/309683.
You are correct, dependencies happen. How strong the dependencies are is a different matter all together. 
Not sure why you're being downvoted. You don't come across as someone who didn't read the title or watch the video. You're just agreeing with its premise with a succinct example. I agree btw. Whether I code TypeScript, C#, or Java, which see my three most used languages, I always gravitate towards a bunch of small classes with functional style bits of code in the methods to help with things like avoiding verbose loops. I'm also likely to favor immutable bits of data instead of changing state held by classes.
I find the idea of strong/loose coupling to be mostly a myth. People slap on some indirection and pretend it's somehow solves the dependency problem. It is possible to have dependencies that really are optional, but it requires far more work than most people are willing or able to pay for. 
https://www.reddit.com/r/programming/comments/9xbqjr/project_loom_fibers_and_continuations_for_java_by/e9shzzi/
&gt; `invokedynamic` was released with Java 8 Java 7, actually
&gt; The one advantage I'd say JS really has is the ease of using it. It's very easy to write a couple of one-off applications when you're starting out. I'm mainly referring to production scenario's. What people do in their own time is completely up to them of course. But having a production service written by a complete beginner in Node.js is a recipe for disaster. We're actually in the process of rewriting two microservices from Node to Java in our current project, and at least these two were written by experienced developers. 
You are trying to asmify a source file of groovy, you need to compile the groovy source file into bytecode first with [groovyc](http://groovy-lang.org/groovyc.html)
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
the things waiting for the connection don't block thread. Only things waiting for the result are waiting in the thread pool. Like this https://github.com/RazerM/sqlalchemy_aio . In python, it is common to use asyncio for socket connections in combination with a thread pool for relatively fast blocking database operations.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Definitely curiosity.. A module system seems to be standard for JavaEE implementations (I haven't seen a server without OSGI), and JPMS seems applicable to this use case. 
It will depend on the scheduler you choose. Loom fibers are built on top of continuations, and continuations yield when their `yield` method is called, and a fiber calls `yield` on its continuation when it blocks (on IO or synchronization). However, we plan to add a mechanism that allows the forced yielding of a continuation, which would allow a fiber scheduler to choose to forcefully preempt a fiber. It's unlikely that the schedulers you get in the JDK would make use of forced preemption, but if you like you could write one that does. But that may not matter because fibers (and coroutines) can run on multiple cores concurrently (again, up to the scheduler). Also, because yield points are not marked explicitly, depending on that for data safety may not be the best idea. Rather, the many synchronizations constructs in the JDK should be used.
&gt; the things waiting for the connection don't block thread Yes they will. If you try and get a Connection from a JDBC Datasource and there are none available, it'll block until one is ready. &gt; In python, it is common to use asyncio for socket connections I'm referring to Java here. Python AsyncIO is doing roughly what they're proposing in Java with Loom. &gt; File operations cannot be really non-blocking on unix anyway Yes they can. The two most popular Unix flavours - Linux and MacOS, both support non-blocking IO. (As does Windows). &gt; In typical websocket application, you have thousands of clients connected, while only few of them making queries at the same time, I suppose that depends on your use-case. There are plenty of apps handling millions of messages per second.
JPMS solves the problem that is also covered by OSGi, namely defining the exported API of a JAR file (instead of implicitly exporting all public classes in it). However, OSGi is much more about dynamic bundle loading and service discovery, that is \*not\* solved by JPMS.
That's a lot of hyperbole. Checked exceptions are the main issue with Lambdas, and you can solve the verbosity of wrapping the exception in an unchecked exception by refactoring the lambda into a method and using a method reference. 
Ah, right. Maybe someone starting from scratch would consider using the JPMS, but at the time it's still fresh. Also consider that OSGi has a broader feature and is arguably a better module system.
Also OSGi covers versioning, IMO a very important part of modularity.
You can do dynamic loading / service discovery with JPMS, although I imagine it's more hands-on than with OSGI.
I have no way of knowing if anybody did.
&gt;**decade+** stagnation after the Oracle acquisition Oracle acquisition happened on 2010. It´s been only 8 years. &gt;decade+ **stagnation** after the Oracle acquisition Java 7, which gave us try-with-resources, better type inference (`&lt;&gt;` operator), multi catch, etc. was released on 2011. Java 8, which gave us Optionals, Streams, lambdas, etc. and is arguably the best thing to happen to Java since Java 5 (notice the \[surge in popularity in late 2014\]([http://46zwyrvli634e39iq2l9mv8g-wpengine.netdna-ssl.com/wp-content/uploads/2016/03/s2ydtzect7xea5afbcd66rrlknw9uxxgagdwmgtkz9lzhb4pj1wwlvi7rtp1etz8jqqqxwb-hpbqau5zk\_vseybdgq8bhszu1jdu348lui1mwe70v61jybcydg-bmxccvtuvbogy.png](http://46zwyrvli634e39iq2l9mv8g-wpengine.netdna-ssl.com/wp-content/uploads/2016/03/s2ydtzect7xea5afbcd66rrlknw9uxxgagdwmgtkz9lzhb4pj1wwlvi7rtp1etz8jqqqxwb-hpbqau5zk_vseybdgq8bhszu1jdu348lui1mwe70v61jybcydg-bmxccvtuvbogy.png))), was released on 2014. Oracle is not exactly the best company ever, but **to say that Java stagnated after Oracle bought Sun is complete and utter bullshit**.
You have one issue and claim that they're poorly integrated. 
There is literally the same question and the answer at the end of the presentation - [question](https://youtu.be/vbGbXUjlRyQ?t=2618).
Or Python 2
Agreeing with the video causes a downvote? Strange. Well I upvoted you.
It looks like in your [submission](https://www.reddit.com/r/java/comments/9xmswa/system_of_linear_equations_over_finite_field/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Odd... thanks!
If you can't find a single benefit from using typescript/javascript on the back end then you are either not very experienced in using it for a back end or haven't thought for very long. I have worked writting Java for 10+ years and have written Typescript for a couple of years. I have set up a variety of Tomcat+Jersey+Guice servers and just getting them set up initially and remembering how they are strung together is a pain. Express is significantly easier to reason about. Using javascript collections with lodash or even the built in map reduce operators are way easier that the semi-abomination that is the java streaming api. Interop with a javascript front end is eased by avoiding goofy JSON deserialization issues that a JSON to java object conversion will invariably will run into (Here I am thinking json number to java int doesn't work, JSON collections with types need goofy type defs when using either Jackson or GSON). There are definitely pros and cons to both. I like java, but I would disagree that it is a slam dunk that java is always a better fit for a backend especially if the front end is a S.P.A. where much of the application logic resides.
I mostly write plugins for e.g. Eclipse, SonarQube and stuff like that, which don't support running on higher versions last time I checked, so I guess I'm locked at the moment
Nice simple concise article. Imo you should add a bit about the specific levels of application logging and how that works with something like SLF4J
There are a few more important logging types IMO worth talking about, like audit logs, usage/billing logs (which is a thing most any SaaS service that has a multi-tenancy stack needs) etc. A lot of these have very different requirements in terms of latency and consistency
Nailed it. 
I expect that all maintained popular components would support 9+ soon enough.
&gt; Vavr. This is nice but also comes at a cost of having to port back and forth between vanilla java collections and Vavr collections and training every new person on the team that your project is using special collections instead of the normal java collections. &gt; This works just fine. If anything the lack of distinction between floats and integers in JavaScript in itself is a huge reason to not use JavaScript I disagree that this works fine. It is extraordinarily verbose to get deserializers and type defs setup for anything but extremely simple objects that are passed between client and server and the thought that not having integers is a "huge reason to not use javascript" in the first place might be a good point except for the fact that you are all but forced to used javascript as your front end tech so working across those lines is something you are going to do anyway. My point isn't to say that javascript &gt; java I actually like both but I think it is silly to think that there aren't scenarios when javascript/typescript as a backend doesn't make sense and in a lot of scenarios the choice is going to come down to language preference and familiarity. &gt; the Java ecosystem has huge benefits over the generally immature (to put it kindly) NPM ecosystem Also the point that the java ecosystem has huge benefits over the immature npm ecosystem is true in some ways and in other ways the java ecosystem is antiquated and the javascript ecosystem is getting far more attention and development on it. Unless this trend reverses you are going to see better library support for javascript and node that you will for java if that hasn't already happened. &amp;#x200B; &amp;#x200B;
I hope so, I'm eager to use some java 10/11 features :)
The community for javascript is very active: [https://githut.info/](https://githut.info/)
хорошо!
Wrong subreddit. This subreddit is not for help with programming nor for code evaluation. Should be posted in /r/javahelp. **Removed**
This worked thank you so much
&gt; I'm still using 1.6 :( I'm still on Java 1.1 but have to make it run on Java 11 as well.
&gt; If you're writing a traditional "thread per request" web application, that thread cannot be yielded until the entire request has finished. I am talking about a websocket application running in an event loop which uses thread-pool for blocking calls, so the event loop never blocks. In Java, it would be something like Spring Reactor for the event loop and TaskExecutor for the blocking calls. I have never used this approach in Java, so maybe I am incorrect. &gt; The two most popular Unix flavours - Linux and MacOS, both support non-blocking IO. (As does Windows. I was referring to something like I/O Completion Ports in windows. Most file operations in linux are synchronous, blocking. 
For SPA's you can have a wholesale application, instead of a Java backend app with a React (or w/e) / TS app embedded. With all TS you can server-render your client app and the whole thing is type-checked and tested natively. Now all that needs to happen is for TS to compile directly / to web-assembly and you'll have the performance to boot
Do they need to fix it? I'm not alone in writing my own [utility](https://github.com/nullterminated/trylambda) to handle this. From the question linked, List&lt;Class&gt; classes = Stream.of("java.lang.Object", "java.lang.Integer", "java.lang.String") .map(className -&gt; Class.forName(className)) .collect(Collectors.toList()); Which is easy enough to handle like, List&lt;Either&lt;Exception,Class&gt;&gt; eithers = Stream.of("java.lang.Object", "java.lang.Integer", "java.lang.String") .map(className -&gt; Try.either(() -&gt; Class.forName(className))) .collect(Collectors.toList()); Now you can get your classes and handle any exceptions in your stream too.
Java is used everywhere. It's in your sim card, card, AI project, banks, on a plane, in GPS satellite, in your phone... it's everywhere, it's ubiquitous. We don't know what your friends told you, 10_000 lines of code is nothing, I worked on a project that had 5_000_000 of files, XML, JSON, .sql and Java files.
I use Java for data integration and transformation. I take product and inventory information from our ERP to feed 35 web shops across 7 third parties. Then we download orders, and translate those for import into our ERP, so that we can ship our goods and invoice our customers. Then we push shipping notifications back to the web shops, to get our customers notified. We communicate hundreds of thousands of data messages daily. 7 Java-based application suites set up as micro applications, nearly a million lines of code. Mostly running Java 1.8, slowly migrating to Java 11.
We use wildfly, adn its been pretty good so far
Your PROFESSOR wants to know? What university do you go to?
Not the best thing if you aiming for production. This approach doesn't support triggers, specific native sql features, indexes, data migration. It's literally OK for hello world or single developers projects. For team project you need to consider using something like liquibase or step-by-step sql files in the folder with clear application sequence + manual JPA mappings
Similar to Scala's Try monads. To be really useful, it will need the upcoming pattern matching syntax additions. Anyway, this proves my point. Without workarounds, Java lambdas are not designed with proper integration with checked exceptions in mind.
The project I worked on from 2010-2016 was around 250,000 lines of code, and was not all that big of a project. You start thoroughly testing things and the lines really build up fast. 
I thought the article was going to be about application logs vs access logs vs audit logs etc. 
I can also recommend using gRPC but you will need http/2 support. The Java gRPC library uses Netty underneath and it’s one of the fastest, if not the fastest, implementations among the other languages.
Option 2 is what ESBs are made for, that's where I'd put your effort. 
Liquibase + maven + any extensions into a custom maven plugin to build / manage a DB = gold.
You're looking for /r/javahelp.
How much load do you expect from this new service? For a client that wouldn't call on your application much, there's nothing wrong with option 1, especially if you don't expect to do any more favors for other clients. Point to point can get ridiculous to maintain, but a simple RESTful abstraction layer probably wouldn't add much tech debt. But like you said, REST APIs are new and sexy, and it may not be the last you'll hear about it. Fortunately, even two or three more applications to integrate over HTTP shouldn't require a big overhaul with enterprise integration designs. If you have an ESB already, and the client is internal to the company, why haven't they already connected to it, rather than come to you directly?
Ron, congratulations on getting it this far. I've used this in other languages and it's an absolute game changer. I can't wait for this to be generally available in the Java ecosystem.
There is nothing human readable about json once is a couple levels of nesting deep.
I would go with 3. The message transformation promises of ESBs never really panned out. Setting it up, testing, and especially maintance was/is an utter nightmare. 3 will let you move to modernizing your app while still using the ESB pretty much like a load balancer/message router, they are ok for that. (And in my experience keeping the ESB in the loop will keep the executives who fell for the ESB marketing presentation happy). 
XML is far more human readable and writable than JSON once nesting is in play.
Just want to address the points you have here; hopefully they help clear up some of the misconceptions you have. &gt; It doesn't let me cast or anything like that it just treats it as a generic object and acts like it's methods don't exist. Typescript allows you to inform the typecsript compiler using [type assertions](https://basarat.gitbooks.io/typescript/docs/types/type-assertion.html) for these exact scenarios. &gt; One major example for me is **using refs in react**, and calling methods from the ref. It doesn't let me cast or anything like that it just treats it as a generic object and acts like it's methods don't exist. **This basically makes react unusable.** Even if you weren't able to use type assertions to correct this issue, this statement is also wrong. Refs are used sparingly in react. They are an escape hatch for viewing size of a dom element, interacting with non-react libraries, etc. If you find yourself using refs a lot, it's likely that you are not understanding how to create react components. I am not saying you fall into that category; I am just saying that refs are a pretty small part of the react API, and you could easily write an entire app without ever needing to use them. &gt; The fact of the matter is there is still no IDE for js that's worth half a squirrel fart much less ts The other poster addressed this, but I just want to reiterate that even VS code (a 100% free editor) is on par with IDEs like intellij. It's a little more setup to get debugging up and running, but it is very full featured with great intellisense. If you really miss the "full" IDE experience, intellj/webstorm are great with both javascript and typescript. &gt; So..why use TS? This blog post doesn't seem to make any compelling arguments so much as show a basic typescript tutorial. The reasons are pretty straightforward (I didn't read the full article but here are my opinions): 1. If you are writing REST APIs, you probably have a front end somewhere. Having a single language across the stack is massively helpful for hiring/onboarding, and it makes it even easier for developers to work on all parts of the code. Constantly having to context switch from Java to Javascript/Typescript does have a cost. In my experience, it leads to shitty front end code written by java developers and shitty backend code written by javascript developers. 2. Typescript is much less verbose than Java. I don't think anyone would argue with that, but if you disagree I would love to learn why. 3. Typescript has 1st class functions, opening up an entirely different way of solving problems outside of strict OOP. You might say this is a bad thing (too many different patterns). However, consistent pattern adoption is important even in a language constrained to 1 programming paradigm. I also prefer having a toolbox full of options instead of being forced to use a hammer as a screw driver. 4. Handling asynchronous logic is much less complicated than in Java. I could go on, but hopefully that gives a taste of some reasons why you might want to consider using Typescript on the backend instead of Java. I'm not saying one is definitively better than the other, either; I am just stating that there are plenty of valid reasons why you might want to use Typescript. There are plenty of reasons to use Java (or Kotlin) as well, and depending on what you are doing, that might be a good idea. If you have a bunch of strictly OOP developers, and you have clearly separated team structures between front end and service developers, Java might make a lot more sense to use.
What? 
You clearly haven't looked at the sidebar. &gt; News, Technical discussions, research papers and assorted things of interest related to the Java programming language &gt; NO programming help, NO learning Java related questions! &gt; PLEASE SEEK HELP WITH JAVA PROGRAMMING IN /R/JAVAHELP! &gt; Upvote good content, downvote spam, don't pollute the discussion with things that should be settled in the vote count. &gt; Do not post tutorials here! These should go in /r/learnjava. &gt; No programming help questions here! These should be posted in /r/javahelp &gt; No surveys, no job offers! Such content will be removed without warning. Could it be any clearer?
Umm, you don’t think this qualifies as a “technical discussion”?
No, not at all. It’s a high level architecture question that doesn’t even relate to Java. Just because OP is using Java, it doesn’t make this a Java-related question. Replace the word “Java” with “Python” in this post and it doesn’t change the discussion at all.
Why?
Why?
It seems site is down at the moment
We use it all over our project. We use it for our UI Rest interface and several background data processors. This week I used it to write a tool to send tcp/tls data for some testing. If you need 10k loc then yes you will need 10k loc. If you need less it will be less, if you need more it will be more. Use an IDE for code complete. Being java does not mean you now have to wire more loc.
"the point of json is human readable data exchsnge". Holy f#@k, like XML. What a coincidence! #ironyOn
Expose dumb rest service that pushes de message to the ESB, transforms it and sends it to the old service. The dumb service just acts as endpoint, the ESB transfirms and wires, you keep the logic were it belongs, the old service. Check that it is feasible from design point. This is, many SOAP services are designed like single call RPC, while ReST style is more like CRUD which requires multiple interactions to achieve the same goal as RPC.
I’d go with the ESB, it’s what they are made for. I’d also expect it to make the solution more scalable in the future and it puts the ownership on them. Alternatively you could use something like IBM App Connect as a lightweight integration solution but given you already have an ESB it’s probably not worth going down that route. 
George Mason University. My professor teaches game design from an artistic view point not a scientific one. He also doesn’t necessarily have enough experience with java to know something like this, as the games he has worked on coding weren’t written in Java. 
I think it should come down to what your existing architecture looks like and what your plans are for this application going forward. Are the existing clients connecting to the application over the ESB? If so, plus one for using ESB for this client Do you plan to connect a bunch of new clients to the application over the ESB? Another plus On the other hand if your application is not connected to the ESB in any way today and the only reason it's going to be in the future is to support this one client, then I don't think the added configuration complexity is worth it. 
I feel like that "The most growing" metric is a bit deceitful. Growing from 10 to 30 is 3x. Growing from 10 000 to 15 000 is only 1.5x, but still much more prevalent. I'm curious about the data behind these metrics. Interesting nonetheless.
yup number 2 on that list is HCL which is a configuration language by hashicorp
A lot of companies are replacing ESB with Apache Kafka to achieve better performance.
I'm very suprised at this but also encouraged because I just started working somewhere with Java as the server-side language and was worried
It's fine that you're building your own microframework. But please don't claim that now this is the 'start' of something new. You're in a long line of microframeworks like Ninja, Micronaut, Dropwizard, etc. Claiming this is the "start of a modern Java web ecosystem" is just arrogant and off-putting. 
I welcome any new ideas in this space but I don't see any difference to the pre-existing offerings, such as Javelin (the example code even looks almost identical), SparkJava, Jodd, etc.
Double brace initializer. new ArrayList&lt;&gt;(){{ ... }} No. No. No. &gt;Every time someone uses double brace initialisation, a kitten gets killed. [https://stackoverflow.com/questions/1958636/what-is-double-brace-initialization-in-java](https://stackoverflow.com/questions/1958636/what-is-double-brace-initialization-in-java) I've seen the one and only example, and not quite sure what it actually does. What is QUERY1 and QUERY2, what is their purpose? How is this easier than writing raw SQL queries? &gt;Easy way to create and control SQLITE instance insted of class inheritance for every SQLITE DB. Why would you need class inheritance to use SQLite?
Worried about what?
Don't have any mayor experience with that library to be honest. It's obviously a totally different api.
Worried to be wasting his time with a language that is losing terrain because of its verbosity and questionable vicinity with a software company with a terrible reputation, maybe? I’m not saying that’s what I think, but many think these factors don’t outweigh the security of the jvm.
BigInt.
Javelin also does servlet API now. Does this new one?
As opposite to what language?
Where in the article does it state Java is the most used server-side language? I’m delighted if it is but I can’t see any mention of it (at least when viewing on mobile).
JS? Rust?
Here's a report that proves my point, if you prefer to believe in data. https://dl.acm.org/citation.cfm?doid=3152284.3133908
JavaScript on GitHub is comprised of mostly duplicate code, and front-end code. One can conclude that Java is more adopted on server-side than JavaScript (Node.js). Here's a report that proves my point, if you prefer to believe in data. https://dl.acm.org/citation.cfm?doid=3152284.3133908
Rust is too immature for now to be considered as a back-end language. Simply said you won't find developers. And JS caps with its single thread [source](https://www.techempower.com/benchmarks/). Also, dynamical languages are not well suited for big projects, as it gets hard to maintain and collaborate. 
I’m using node and I like the flexibility of js. I’ve used java for a decade and I’m still using it, but getters, setters, builders, streams (why use .stream() when you can just add methods to the interface? haven’t seen that in any other language), having to create an object just to pass data around (vs using json) is really too much for me. In node you also have async code by default. Java forces you to write verbose code and sells it as safe, but with node you can choose how much you want to be safe depending on the application requirements. It takes a while to learn what not to do because it’s risky, but once you get going it’s really fast to write an application in node. All java alternatives on the jvm (scala, kotlin, groovy) seem to address this issues, which java tries to sell as strengths. Maybe in the 80’s. Plus the community is not so active or interesting anymore. Whatever this sub says, Oracle and corporate dominate java, so good luck having them decide for the future: https://youtu.be/HpbchS5kmio
&gt; Did you assume that only half of it is server-side? There is no way at all to measure those kinds of usage figures and literally every dev (myself included) who comes with anekdotal evidence (for example in our project we're migrating two Node.js services to Java) has to be aware there will be a huge selection bias. As a Java dev you'll mostly be working on Java projects so there it makes sense that you're not seeing a lot of JS on the back-end.
com.something should be fine according to me. Why add unnecessary levels.
Right. So how is the "Java is the most used server side language" conclusion confidently reached?
Perhaps, but it's been top three in that category pretty much since it was created, so the rapid growth isn't slowing down (yet).
The best you can do is get a good cross section of 'the industry' and do a survey. But that is a lot of work so most surveys will have a strong selection bias. I have no issues believing Java is used a lot in big enterprisey applications, but there's an awful lot of PHP wordpress installations out there. 
Lol, you must be new to the industry. Java is THE most popular language on the back still today. 
I’m using java 11. Performance what? Hardware is cheap today, and if I need performance I use c, c++, go or rust. Node can perform as good as java, you just spin up more than one process. I’ve never associated java with performance... it takes 1-2 minutes to spin up a spring application, everything needs the jvm to be up, so scripting is not a thing with java. Node is a layer on c/c++ libraries in the end. 
You shouldn’t pass around streams *or* json blobs just like that. You can have a stream of any object. Interfaces don’t make sense for that, at all. Async by default is just silly. It barely matters, but when it does, it matters with libraries. And libraries already have async functionality. See Vert.x for an example. Java doesn’t force you to write verbose code. Vert.x is amazing. The community is incredibly active. In what ways is it not? As the post title shows, there is no other community that compares. Node (V8) is very much controlled by Google. Meanwhile, I can download and use PowerJ9 or another JVM easily, as a drop-in replacement. Node isn’t exactly the most community driven language. And just curious, what’s the largest JS project you have had to maintain or work on?
Agreed. My point is that the evidence posted in the OP does not back up the headline.
1-2 minutes for spring? Hahahah. Oh man. So glad that's not true since I use Spring Boot everyday. More like 20-30 seconds. 
Yes, I prefer controversial statements to be backed by data. Especially when the linked article doesn't seem to do that. That's interesting, thanks. The conclusion is open to interpretation though; a copied/minimally modified codebase still suggests an increment in adoption of the language. Maybe popularity too. Does that report show the front-end vs node.js JavaScript split? 
Don't worry, as u/zeek979 mentioned, Java is the most popular language on the backend generally speaking. In fact, the JVM itself has an even better chance of outliving Java the language due to languages like Kotlin depending on it (the JVM). Anyhow, on Reddit people often get the sense that languages like Python, Ruby, and JavaScript will totally replace old (but proven) languages like Java, but nothing could be further from the truth (and this is coming from someone who loves Python). From what I've seen, once one of those languages become a bottleneck in performance or maintainability, the application is usually rewritten in pure old Java.
Run a server with node or python, it’s up in 2 seconds. Also consider how faster integration tests run if you don’t need 20-30 seconds for each.
That's totally true. No one argued that. From supporting things in production and reliability and maturity of ecosystem, I'd personally choose Java over node or Python anytime. Spring is there to help you deliver business value faster instead of working on the plumbing. If that just costs me a few seconds on a build server or during standing up the container... I pay it gladly.
Try express and let me know if if you need more plumbing than spring.
I'll take a look. I've actually been interested in a lightweight service for exposing some data in an API and was leaning towards Python and flask but node could be interesting.
The point is that OpenJDK and the JVM rule the server side. It's your troll mind making you believe I am here trying to "brainwash" anybody.
Plus, Kotlin also runs on the JVM, ye? I've been working as a BI dev for a bit now, mostly using TSQL and a little C# but I picked up Java recently (finishing college at night) and I'm really starting to consider picking either Java or Kotlin (or both) for real and look to work with'em in the future (just feels a bit unsafe when you already have a career in something else, I guess).
As always: All programming language metrics suck. All platforms have bias for and against certain languages. There is no representative survey of what the "most used" programming languages are.
devil's advocate: go
It looks like in your [submission](https://www.reddit.com/r/java/comments/9xyk7l/java_not_working/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Yep, Kotlin runs on the JVM. You can also transpile Kotlin to JavaScript or compile it to native code. But I think most people use Kotlin in addition to, or to replace, Java on the JVM. If you're learning for professional work, then I'd definitely recommend learning Java since you already know C#. Learning Java should be decently easy since they're so similar. As for Kotlin, I would honestly learn that *after* Java since it's nowhere near as widely used as Java is in the business world. However, if these languages are for personal use, then I see no issue with going straight to Kotlin if that's your preference.
If you are more productive in node, then good for you, do more node stuff. That doesn't mean, however, you should be trying to start a flame war :v Back on topic, serverside java is so prevalent you would have to find a list of companies that *are not* using it. Also I don't buy the paypal story at the face value. It seems more likely that they had an application that grew and grew, then at some point, after that one dude/dudette that understood how it actually worked quit, it turned into a lovecraftian horror, so they used "the speed" as an excuse to start over. After all, years upon years of short deadlines will skyrocket technical debt, no matter the language. 
I wonder what framework they've used. Once again, Vert.x is faster than node. And I believe they are starting to integrate with Graal, which will optimize code even further. But again, interesting to know paypal story. Was not aware before.
I don't think that's fair, other than the part about hiring. go is being used in tons of production environments right now as a alternative to nose et al, not just experimentally or incrementally like rust. 
I mean the single thread argument is only good for computationally expensive tasks. Otherwise, you just run an instance of your server for each core (or whatever is optimal usage of cpus) and use something like pm2 to load balance between them on that machine. If you are doing computationally expensive calculations, then sure JS is a terrible choice. Typescript is also a great choice for making more developer scalable projects (compared to plain JS). It's worth trying out if you like the javascript language but miss having types.
Go's type system is a joke. No bueno.
A pity it isn't seeing so much love on desktop and mobile. I'm probably going to have to use Electron for my next project… 😞
&gt;new JavaScript servers like Node.js (launched in 2009) were making it possible for developers to use the **same code for the client and the server** Same language, not the same code.
Q: "Why are you sitting here instead of coding the Valhalla project?" *pfft*
My Either already has pattern matching. It's a closed class hierarchy. Either can use(), map(), and reduce(). Example, Either&lt;Integer, String&gt; either = Either.left(1); Integer i = either.reduce( left -&gt; left + 1, right -&gt; right.length() + 1); 
They describe NPM as being the primary culprit behind there being so much JavaScript on GitHub (and why most of it's duplicate code). I'm not sure how often NPM is used for something besides Node.js. The PDF is free to download. Section 6.4 covers Javascript and starts with this: &gt; JavaScript has the highest clone ratio of the languages studied. Over 94% of the files are file-hash clones. We wanted to find out what is causing this bloat. After manually inspecting several files, we observed that many projects commit libraries available through NPM as if they are part of the application code. As such, we analyzed the data with respect to the effect of NPM libraries, and concluded that this practice is the single biggest cause for the large duplication in JavaScript.
Thanks, I do have a fairly good knowledge of Java(android and desktop), not just for web servers.
XML contains lots of extra non needed information, ie ending tags. Json has a neater syntax. XML wasn't even designed as a data exchange format it was made for document markup! There's a reason why json is much more prevelant. 
why not
I would agree with your statement if you added "within the same class" to it.
You can use JavaFX
For a given price, node servers returning Graphql from a relational store has very similar performance to java servers doing the same.
I mean, it's *possible* to use the same code on both ends. A project I've been working on does this in a few spots actually, we have some functionality that both ends need to be able to support and we have a single library that the two ends share that implements it. It is generally more important that the same language is being used though. 
Agreed, as have I, but in general node servers act as HTML, REST, or Graphql servers.
Kotlin brings coroutines to the JVM as well.
&gt; This is what it will look like in JDK 12 The 2nd string is completely different due to garbled whitespace (missing \t indent and \n at end of string)
Jesus Christ yes please
Right! And the example output doesn't even show the indention with the tabs on each line. This is a bad example.
have fun with that
It looks like in your [submission](https://www.reddit.com/r/java/comments/9y0ctz/struggling_to_level_up_from_beginner_to/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Which second point? In any case democracy does not fit debate.
How do you measure "moved faster" ? I think you can rightfully say that the improvements in JS during the last 5-7 years have been pretty quick. But just the clusterF that Python has been trying to transition from 2 to 3 is enough to ask exactly what "moving fast" means.
Also, Spring development with Kotlin (if you're lucky enough to be with an org that is willing to try it) is heavenly. The interop between the two languages is damn near seamless, as opposed to trying to do any Spring or EE stuff with Scala. Case in point, my current "big" project involves converting a hastily slapped-together legacy Spring MVC 3ish financing system over to Spring Boot 1.x. The original developers are long gone, and it seems like every damn thing in this application is hard-coded, from database references to user names. As a result, dev/staging deployments are not A Thing, so any time a bug report comes in, there is no way to really verify the fix in an environment other than Prod. For the most part, I've been able to just lift the old code and drop it in the new Boot project. The major only issues were with deprecated features, like VelocityEngineUtils bullshit that had to be migrated to Thymeleaf. We're using the Spring Kotlin plugin, and any extracted/refactored sections are being redone in Kotlin, e.g., data classes for JPA entities, some SOAP integration code that had to be ported over from an EE7 service, data classes with vars for config properties, and so forth. Once that's all dealt with, the plan is to get the whole DB under Liquibase control for incremental migrations and refactoring into a halfway sane structure, migrate a bunch of JSP-and-jQuery frontend garbage to Vue or React, and basically turn the whole service tier codebase from an unmaintainable mess into something that, when the CFO barges in with a list of demands, I can pretty much just give an affirmative shrug and mumble something about "couple of weeks." **TL;DR:** Kotlin isn't just for Android monkeys.
If all you're doing is CRUD then most of the time is spent on IO anyways, your application is likely not CPU bound, and you should probably use whatever language you are most productive with.
 - fast - great with numbers - strongly typed - solid oop foundation + libraries - ridiculous [names](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/ejb/access/SimpleRemoteStatelessSessionProxyFactoryBean.html) What's not to love? 
Yea, but coroutines in kotlin are not really fundamentally different than threads under the covers. That is not to say that a coroutine == 1 thread. But it means that they still execute in the underlying thread. Instead, java fibers will allow for millions of small threads per jvm process, since they wont map out to OS threads. Kotlin (any other jvm language) will obviously benefit from fibers since it runs ontop of the jvm. 
&gt; Yeah, I am new. &gt; I do have a fairly good knowledge of Java Does not compute.
Have fun with *what*? One of the most comprehensive and well-thought GUI frameworks?
To be honest, the "clusterF" of Python 2 to 3 is a prime example of what I meant by "moving faster" -- making "breaking" API changes to advance the language. It was indeed a cluster f*** -- and maybe they could've handled things differently. However, the end-result is that they advanced the language as intended. Don't get me wrong though, I prefer to use Java whenever possible. My original comment of other languages "moving faster" is that to a lot of users on Reddit they seem to have the "perception" of those languages moving faster because: 1. In the case of Python and Ruby, many "modern" features were been built into the language (sometimes at the cost of breaking APIs -- I believe this is especially true for Ruby). 2. Java still has a lot of language "baggage" due to the traditional focus on backwards compatibility, but thankfully this is changing with the faster releases.
No, that would be too sensible. Much better to waste one of the few remaining unallocated punctuation characters on a niche need that is useful a tenth as often as string interpolation would be.
You're confusing matters. There are 2 almost entirely different situations: [A] You have 8000 simultaneous incoming connections you have to deal with; the vast majority of them (possibly even every single last one of them) is currently I/O-blocked; they've sent half of a HTTP request down the pipe, or, you've answered the http request by loading a template, applying some fields picked up from a DB query, and sending it out, and right now the server is still working on getting those bytes out the door. If you were to point a debugger at your server, just about every thread is stuck someone on the underlying socket outputstream's `write` method. [B] you have 8000 simultaneous incoming connections you have to deal with; the vast majority, possibly even all of them, are doing active calculations. Let's say you're an authentication server and every single last one of those 8000 active connections has sent all the data they are going to send, and your server hasn't gotten around to sending even a single byte's worth of response, because you're trying to apply bcrypt to 8000 salt/hash combos simultaneously. My point is this: For scenario [A], it... really doesn't matter. If you go via the async route, you have 8000 active handlers, backed by 8000 active bytebuffers in various states of load, and a server which waiting for one of the 8000 active handlers to get a headsup ping from the I/O pipeline that more data is ready to read / ready to send, at which point the active handler is awoken to go do something. If you go via the synchronous route, it's the same story. There is no relevant thread starvation going on here, as all threads but a handful are asleep. Yes, you're down 8000 stacks in the sync model and that's very likely to be significantly more memory than what the async scenario has got going on with the bytebuffers it needs to work, but as far as advantages go, whilst real, you should consider throwing some money at it. It's real easy to mess up async (introduce 1 slightly synchronous call and your server's performance is completely in the toilet; it's hard to test for making this mistake. In general programming async is tricky, especially in java as it has no await/yield mechanics built into it. Languages that do have await/yield aren't exactly taking the market by storm, so whatever competitive advantage it provides, it's clearly not enough to make a dent). For [B] it surely does matter: Your async solution is going to accept about 16 bcrypt challenges and then just blithely __does not pick up the phone__ anymore; the remaining 7984 incoming requests sort of hang there, bytes stuck in some router's cache or perhaps a bytebuffer if you have a framework dedicating a core to at least queueing up. Eventually your async server does get to all 7984 in a long time, or more likely you realize __this server is incapable of dealing with this amount of traffic regardless of programming model__, and lots of clients simply disconnect, tired of waiting, or hitting some sort of timeout on server, on client, or any router in between. That sucks, but it's actually much better than the sync model, which, __depending on configuration__, picks up all 8000 requests and then in the worst case scenario spends 4 hours flailing away, at which point it answers alll 8000 requests more or less simultaneously. The async model at least serves _some_ of the clients. Well, 16 out of 8000. Not much better, but, you can make a case, I guess. B does happen. And it's relatively annoying to try to configure your sync-based server to do it right (which is: Flat out deny incoming requests). But note that even in the async case, configuration is required and complicated: You want to configure both sync and async servers to eventually intentionally give up (send some sort of 'I am far too busy!' error) because that's better than either having hopeless thread contention, or having an incoming request held up in a queue for 3 hours. So, whilst async gets the nod here, it's.. barely noticable. Contrast this very meager win against the serious hardship involved in writing async code correctly, and it's clear that _at least_ java needs to become _a lot_ better at giving you handholds for writing code async style, and given how much of a change is required in your language to make that truly work well, I doubt this minor niggle is worth that incredible amount of pain. One specific case where async truly hurts: I've read this before and just can't remember who wrote it, but it's apt and I apologize for the ripoff of the notion: Imagine methods are either red or blue. You cannot mark a method as what it is (you can document it, of course, but the compiler cannot enforce this). Red methods can call blue methods, no problem. But, if a blue method calls a red method, you have written a bug, although it is tricky to test for this. Seems like the answer is easy: Write only blue methods. Except: Many of the core library methods are (not consistently documented) red, as are many commonly used third party libraries. This sounds like a completely idiotic language to program for and yet __that is exactly what you turn java into when you go async__. Red = '(potentially) blocking', blue = 'non blocking'. 
JDBC supports this. It's called batching. If it's gonna make a real difference, it tends to be in repetitive operations, such as bulk-adding a bunch of data. Generally you should try to use DB-specific concepts for bulk adding of data such as COPY, but if you can't.. batching your INSERTs is a good idea. But, if it's a repetitive task, writing some code that batches is not difficult at all. 
At the end of the day both are swapping light weight threads' execution between OS threads, how is that different?
Just use replaceall
I marshal all of my table rows into a Document then use selectors to filter the rows.
Pretty much everything you said about Go is wrong, though I agree with your overall point with respect to web servers.
Why do these vendors keep coming up with their own config languages?
Thanks for the answer. I am looking for more information, especially pros and cons of each option. You ask: If you have an ESB already, and the client is internal to the company, why haven't they already connected to it, rather than come to you directly. The answer: They cannot just connect to the ESB, we would still need to develop something on the ESB if we went that option which would be Option 2 in my question.
They should be calling the `String#align` method, but the output they show would still be different. Awful example!
&gt;Anyhow, on Reddit people often get the sense that languages like Python, Ruby, and JavaScript will totally replace old (but proven) languages like Java System.out.println("Hahaha")
Makes sense. Developers are lazy. Or maybe they fear the next leftpad (https://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/). So when comparing language popularity it's not fair to discount JS because of duplicate code in GitHub repos.
I don't find this useful. I'd rather see exactly what's in the string - in the given example, how much of the whitespace before a day's name is part of the string and how much is formatting workspace? Do I have to select whitespace with my mouse to find out what's in there??
Oracle?
They haven't ruled out interpolation; they'd rather get this out now rather than delaying it for interpolation too. Much like how they're putting out switch expressions rather than waiting for pattern matching. 
If they get this out now then add interpolation later, the interpolation update will break any existing code that contains raw string literals that happen to contain character sequences that are also valid interpolation syntax (whatever the syntax turns out to be). Or they will have to make interpolation less convenient, e.g., by only doing it if you explicitly mark a string as interpolation-ready. Also, "raw string literals," from a conceptual point of view, are the opposite of interpolated strings, which are basically little template expressions and thus not raw at all. Adding interpolation to raw string literals pulls the feature in two opposing directions at once. Will they rename it, "Raw and/or non-raw string literals?"
Whose dick we need to suck for this to happen? It's a part of most languages out there, and yet it seems like we'll never get this.
Even JavaScript has it now! 🤦🏻‍♂️
Citations please?
&gt; I’ve never associated java with performance... it takes 1-2 minutes to spin up a spring application Stupid flat out lies like this si why you're downvoted. A Spring Boot 2.1 app starts up in 1.5 seconds on my 2014 MacBook. 
Much less actually. If it's 20-30 seconds I'd look into what you're actually using. My guess is Hibernate. 
String.format? Not questioning, just curious why it doesn't count.
Same, I actually thought I understand raw string literals until I read this article, now I don't understand how any of this whitespace stuff works there or where did the tabs go.
You get access to the current scope without needing to pass in arguments, and it's also clearer which variable is being substituted when you have many. Java: String someVariable = "hello"; String formattedString = String.format("%s", someVariable); Kotlin: val someVariable = "hello" val formattedString = "$someVariable"
Kotlin coroutines vs project Loom coroutines asked in Devoxx. **They are not the same**: [Ask the Java Architects](https://youtu.be/YR7ulGzerMQ?t=388) [Project Loom Presentation](https://youtu.be/vbGbXUjlRyQ?t=2618) 
This makes me wonder why people still wait? This attachment to Java with the comments like that just looks like some unhealthy kind of relation now. Leave Java behind already. We have Kotlin now. Finally, you can have a cake and eat it, too.
It's stated in the raw string literal JEP &gt; Raw string literals do not directly support string interpolation. Interpolation may be considered in a future JEP. https://openjdk.java.net/jeps/326 
I've scrolled through some of the more interesting bits in my various db-heavy projects and having a series of queries that need to be run where both 1. It's not one of those repetitive things and 2. The next query in the sequence requires zero information from the one before it.... Is non existent.
If your college is anything like mine was, it doesn’t prepare you very well. The good news is, most companies don’t expect you to come in and know everything. They usually want you to understand the foundations like OOP and then they work with you to build your understanding. My advice is to find personal projects to work on outside of school that will help you to develop your skills as a programmer beyond what school teaches you. I am really into Pokémon and would try to develop utility applications with java. Even though those applications sucked and I didn’t know much that helped me more than anything because I learned WAY more through that than any assignment I did for my classes.
This is great. I'd also add that you can go check out Processing, it's a Java wrapper of sorts that lets you easily program graphics. It has its own IDE and precompiler that wraps your code into one Java class. It works great for working out program flow and developing games in Java.
They're not unaware of the need for interpolation. They will get around to it eventually.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You’ll be fine.
I get that. Moreover, in many cases Java is just fine. But when reaction on missing features in Java gets this emotional it tells that something should be done.
Go out on your own and learn. I've known plenty of CS graduates that were complete trash. You've got plenty of time to sharpen those skills. Just do a little coding a day, slowly increasing in scope, and by the time you graduate you'll be solid. Also...learn Spring, Hibernate, and React. At least for the moment that's the hot shit Java technology, and you can build VERY useful things very fast. Not the easiest of things to learn though.
I would expect a junior fresh out of school not to know anything beyond what you learned in school. That’s why you get paid less, you learn on the bosses time. Don’t start learning frameworks etc, you don’t know what will be the hottest skills by the time you graduate, and the fun thing about juniors is that they don’t yet have years of baggage. Its even too soon to decide you’re going to be a java dev. 
Yes, but building a frontend in pure java doesn't really....work out well. I've tried...a lot. And you really need a spring compatible frontend in your skillset. Backends aren't useful without frontends, and you want at least basic familiarity 
Thank you, that’s a big relief. I was thinking of working on a java application on the side, am for sure taking that up now.
Scala also makes it really easy to make different kinds of interpolation for different purposes, like normal interpolation with `s"..."`, formatted interpolation with `f"..."`, quasiquotes for macros with `q"..."`, or what 3rd party libraries do: `xml"..."`, `sql"..."`etc.
They certainly dont teach you how to be an expert in language X in college, at most they give you a "for dummies" level of expertise. But that's fine, what we want you to know is basic computer architecture, memory management, data structures (and their runtime properties, and some solid general math skills. Your future employer is almost certainly using tools and languages you are not trained in. So focus on learning the stuff that applies across languages.
Realistically no you're not "prepared for the industry" but that's not something to worry about because nobody else is either. So ... in that sense ... yes you'll be fine.
Well there are plenty of roles for pure backend developers. You don’t have to be a one man army if you are working for a company. That said it is good to know some front end technologies like React or Angular 
Nope! Nobody is prepared, and nobody with half a brain will expect a new grad to be a great programmer on day one. Probably the biggest difference is that you’re rarely building programs from scratch. That makes some tasks easier, and some harder. Either way you’ll read more code in your first year, than you did for your entire undergrad. And reading code is how you git gud. Try to find a first job where people care about developing their juniors, and that first couple years can make a huge difference in your skill level. (Assuming you put in the effort, and it sounds like you will.) In job interviews, get a feel for how much training and mentoring they plan to do. Structured training/mentoring would be best. Anything else might just be lip service. 
Weirdly string interpolation is one if those things the Java++ languages (like Kotlin, Groovy, Xtend, Scala, Ceylon) all agree on. But Java fails to adapt this no-brainer. I mean it's just syntactic sugar. Why are we still waiting for this? 
Most likely no. You'll not have exposure to working in a team. You won't have exposure to testing. You won't know how to set up a production ready project. You won't know best, or even good practices for structuring projects. You'll have had a lot of practice with javac, but most certainly not Maven or Gradle. I seriously doubt you'll get to learn a framework that is used in many companies. Spring Framework for instance, I learned while working at a non-java shop on my own time, by reading, and reading, and reading. Also in my own time I learned how the heck to produce an iOS app (back in the Objective-C days), and I didn't even own a Mac at the time to actually use Xcode to develop and compile my app. Maybe you will have some practice using JDBC, but probably not in a way that will translate well to a company and production ready code. The things you will be prepared for, is learning how to find the relevant information you need to continue learning with the guidance of a senior engineer at a company you join. It would be even better if you can do some internships before you graduate, so you will get an idea of what real-world projects look like, how they operate, and how teams work together on them. For now it will be important to look at some well maintained open source projects, try to contribute, and ask questions on project chat or just some kind of general forum. You will also take away understanding how a statically typed language works and how to read and understand code, and understand the complexity of a specific piece of code. This by far is the most valuable thing you will have learned from college courses. Learning how to read and reason about code. Even reading something written in a language you don't know, you'll be able to recognize patterns that you learned from school, you'll notice loops, and control flow (if's, error handling, etc...). Again, the logical reasoning that you learn from school is really going to be your biggest takeaway and the thing that will benefit you most in the long run.
&gt; Leaning Toothpick Syndrome (LTS) That's awesome! It's right up there with popular anti-patterns like Shotgun Surgery and Sumo Wedding
The code in use by most companies is not complicated. It's not written by some math genius who developed a groundbreaking (disruptive? ugh) new algorithm. It's usually been written mostly by outsourced programmers who graduated from a diploma mill and know even less than you do. Don't let imposter syndrome get you down. Yes, some projects are very large and complex, but they can all be broken down into tiny little bite-sized methods which will (hopefully) have clearly defined input and output specifications.
Does this preclude adding string interpolation at some point in the future? Is this an improvement for the language?
Thanks!
My second year in CS I realized that what I was being taught was what a programming language is, not what popular programming languages and frameworks are being used. I used Java, C/C++, Lisp, SQL, and Python in school. A good foundation, but I also wanted to learn PHP which was more popular then than now. So one summer I checked out a PHP book from the library and worked my way through it. I gave myself a challenge project (e.g. make an e-commerce website - yeah "e-commerce" was somewhat novel back then). It became clear how what I had learned in the context of Java/C/C++ was applicable to PHP. I realized that what school was doing was making me fluent in learning programming languages. That exercise gave me the confidence to go get an internship for the last couple years of school. That internship taught me full stack: front-end html/css, middle-tier PHP/Ruby, back-end MySQL, and ops with Unix/Linux administration - along with CVS (git didn't exist then). When I was graduating this internship was a tremendous help to my getting three solid offers right out of school. I've taken this approach of finding gaps in my skillset and taking the time to fill them by challenging myself to learn new languages or frameworks. This has lead to my skills now in BigData/NoSQL (Hadoop, Spark, Hive, Cassandra, MongoDB, etc) and cloud (Google &amp; AWS) along with experience in machine learning - which has accelerated my career (now 12 years out from graduating).
All of this is true. In college, I was certain I would be a C++ dev, but in my first job (for a C++ dev position), they ended up needing Java devs more. I’ve been doing stuff on the JVM for 10 years now. 
As a concrete example, my college taught me nothing at all about Java EE, which is the bread-and-butter, breakfast, dinner and snacks of every Java corporate system in one of the biggest worldwide IT industries, in my country. Anyone familiar with Java EE knows it could be an entire college major in and of itself, so that gives you an idea of how barebones you are out of college. That being said, don't despair: check out the latest trends (for example: Stack Overflow and NetBeans yearly surveys) and that'll give you a pretty decent idea of what to study before going into interviews. One of the good things about the IT industry is that usually there's more positions open than there are qualified professionals to fill them so as long as you can show that you're not a total conman and that you're solid on the basics and that you can learn at a decent pace, you're often good to go! Of course, that doesn't mean you can get a Java Senior placement straight out of college but other than that, recruiters tend to be very lenient and accepting, considering they must take what they can get.
Every time I visit Baeldung website I'm disappointed. I certainly wouldn't pay so much money, if any, for anything this guy/these guys make. &amp;#x200B; Their instructions are often incomplete and they make a lot of mistakes too. Looks professional but he's really not experienced or something.
You're just as unprepared as all of your classmates who will also get industry jobs. It's not a big deal, you'll learn on the job.
The current proposal is that `` `Hello $planet` `` is a raw literal. Thus you would *have* to add an extra character to string literals (raw or not) to activate interpolation. IMO having to add something is kind of by definition less convenient than not having to add something. My basic beef with this is that string interpolation is almost certainly going to be a far more commonly used feature than raw string literals. The syntax for the commonly-used thing should be more concise than the syntax for the less-commonly-used thing. They could, and IMO should, go the other way around with this: put a prefix on a string (either interpolated or not) to turn off escape sequences and allow line breaks. That approach works fine in Python, for example, and it avoids using up a punctuation character. I am also not a fan of how they deal with indentation of multiline strings in this JEP but that's a separate complaint.
It looks like in your [submission](https://www.reddit.com/r/java/comments/9y6zgd/need_help_getting_average_i_have_to_read_from_a/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Search for any `.class` and `.jar` files. That'll give you a good start.
so college usually teaches you java, but work is java with a bunch of spring annotations. if you can supplement your education by learning how to write your own spring boot rest controllers, that'll go far in an interview. Probably do some junit with mockito too. But if you don't have the time, that's fine. 
They are optionally stripped by a library function, which part of that is confusing?
Ew no thanks, that sincerely looks awful. I'd much rather constant folding of library functions (or user functions for that matter), rather than trying to duplicate those functions with a clunky annotation description that might not capture my use-case anyway. And correct me if I'm wrong but annotations have never before directly guided the behaviour of javac, however much they may be used to guide secondary byte code generation. I think this would be a step too far in that sense too.
Econ major here - didn't do any 'CS' in my degree outside of a tiny amount of Stata in an econometrics class (which wasn't CS at all, just writing ~100 lines of data manipulation statements). Did have calc, logic, game theory, and some other courses which definitely help with the CS 'way of thinking' though. Worked finance for a bit, took over managing our handful of workbooks with VBA (4-7k lines total, I'd guess) when that guy retired. Had already begun learning CS/programming on my own, but this gave me an excuse to spend more time on it while on the clock at work. ~3 years of self teaching + ~1.5 years of vba was enough to get me into a software dev job. Of the three juniors at my shop, only 1 has a CS degree, and I'm super jealous cause that dude is 23 and has no idea how far ahead he is in life lol (compared to the vast majority of people). He's a good guy to work with.
Usefull information. https://blog.gceasy.io/2017/05/31/gc-log-analysis-use-cases/
Echoing others have said, work on some side projects - that'll fill in a lot of the gaps. Whenever I hire entry level devs I'm not expecting them to be "industry ready", you'll learn most of that stuff on the job. You're definitely not alone :)
If you take a course in designing a Latin based natural language, that will not automatically teach you German or Spanish and others knowing those languages will have an advantage over you. However, your skill and acquired knowledge will allow you to learn those languages faster and over time, give you a huge leg up over others, if you ever end up in a job needing mastery over multiple languages. Your college course is the foundation. What you build on it is up to you.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
To add what /u/dmeadows1217 's post; when you go looking for a job, most interviews are actually going to grill you on what you learned in school, and not on good software engineering principles. So make sure you pay attention in your Object Oriented Programming, Data Structures, and Algorithm classes. Knowing those well will help you get past the interview and land the job.
Learn to read code. To start, take a look at the source of projects like Apache commons and Spring. Pull down a project and try to follow how things work. Read the unit tests .Most IT work is modifying and enhancing existing code. If you can jump into a large codebase and quickly learn it to make fixes and changes, you’ll be off to a great start. As you read through code, think about how easy it would be to modify. Readable code that is easy to change is the big difference between a journeyman developer and a craftsman.
You will learn the basics eventually. Don't bother too much with it until you master whatever you are using on a daily basis. Be curious, read up on it, but don't think you _have_ to be a full stack dev to get a job.
I just did this in a codetest for a Java programming job
College should be teaching you the technical foundations that you need to start your career, but it cannot teach you everything that you'll need to learn. A ton will come with on the job experience and continuous learning on your part. I've been doing professional java development for over 10 years and as part of my job help with training and mentoring interns and new hires. There's a ton of ground all new hires need to cover that just isn't part of most college curriculums: - best practices - specific tools and frameworks - how to work on a large team/project - company specific practices In addition to technical skills, there's a whole world of soft skills that need to be mastered as well. In my opinion, a good employer should recognize the value of investing in their employees and will help with a lot of this.
mainly its your knowledge of the important stuff but I also get asked how ive kept my skills relevant since my schooling which is just a opening to talk about the personal projects I have been working on. Ive seen it go both ways but most of the time they see my side projects as me developing skills and learning more on my own after getting the basics from college.
Do you mind saying what company you work for? That sounds amazing. All too often these days entry level positions are looking for 3 years of experience and they don't expect to offer any training. No company wants to train their employees anymore. 
I remember asking a professor in college about how useful what I was learning (CS major) was going to be and this was basically what she told me. If you want to be successful (read: stay relevant) I think you have to love learning new things (syntax, patterns, languages, etc) and keep at it.
You should definitely work on Java application on the side. I don’t know how it works in the US, but, per instance, in Ukraine **none even cares of your college education - they want you to prove your interest in programming**, to prove that you have some skills. **Having a GitHub account with your pet projects is a must**. You can add anything there. But make sure your projects are specified with attractive descriptions including the idea of the project, requirements to run it, build steps etc. Say, if you’re going to work with Spring - implement a REST API and cover it with tests and document everything. That will be a good starting point. 
Ditto - I *really* hope Kotlin avoids the fate of Ruby getting so tied to one specific subset. At least JetBrains is trying to diversify the language's usage potential with KotlinJS, KotlinNative, and then KotlinDSL coming out in Gradle 5. Fingers crossed!
It looks like in your [submission](https://www.reddit.com/r/java/comments/9y9ggr/where_can_i_download_java_se_jdk_1002_i_need_the/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
\[I don't know why it is spoiler tag but I can't change it now\]
Glad to hear there's somewhere in the world with a rational brain left.
We are in total agreement. :-) 
Comp sci prepares you for academia. If they were concerned about job skills they would make you write code in IntelliJ every day
In a nutshell: if all you know about programming comes fro college courses, you don’t know anything about programming 
Records are on the way with project amber, if that's what you mean.
The two things can be orthogonal. If interpolation were added as a feature it could be marked by a character preceding the string, so it could apply to both types of string literal delimiter.
In all likelihood, not at all. If you haven't got any side projects, now would be a good point to spend some time on that sort of thing. Seeking an internship would be a wise move as well. 
Is Jetty good?
School. 
Well, *"it's complicated"* ;-) In short: no - you don't and won't have to pay for java. You will simply use OpenJDK (which has parity with Oracle JDK). LTS versions will be provided by non-Oracle providers. Relevant video with (IMHO) nice explanation https://www.youtube.com/watch?v=wHoRBvt3U6o
Asked a similar question in r/javahelp. [Here’s what I got](https://www.reddit.com/r/learnjava/comments/9ud9wk/career_advice_sortve/?st=JONJF72O&amp;sh=38b0931c) - I would advise poking around in there too. One of the most valuable resources for me has been the [MOOC](http://moocfi.github.io/courses/2013/programming-part-1/). 
Don't really. You have two options: 1. Your application is not too big and complicated, so you can(and want) migrate to the new Java version each 6 months in accordance with new GA releases schedule. In this case you can continue to use free Oracle JDK builds([https://jdk.java.net/11/](https://jdk.java.net/11/)). It will be just different site to download binaries, builds and updates still made by Oracle. Oracle will guarantee full compatibility and the same functionality which provided under their paid JDK version(except for paid enterprise profilers, support and other specific tools). The only difference - they stop providing updates to the previous version after new release became GA. 2. You want to stay on LTS versions and don't want to migrate frequently. You can choose between Adopt Open JDK([https://adoptopenjdk.net/](https://adoptopenjdk.net/)) and any other 3rd party implementations. I at least heard about one from Amazon([https://aws.amazon.com/corretto/](https://aws.amazon.com/corretto/)), will be useful if you hosting your apps with them. Adopt Open JDK project supported by big tech firms, so you don't need to worry about it's quality or ability to retrieve updates. The same about JDK from Amazon.
Yes. It is very much like this in the US. Look at books like "Cracking the Coding Interview" if you want to understand what a software engineering interview is like here. It's insane; like really, really insane.
Certifications books are a nice source of what java has for you to use, also not only related to java, you should check things like patterns, clean code, refactoring, best practices and software engineering topics, it isn't just to code but to create nice code :D I like courses from [https://www.coursera.org](https://www.coursera.org) since they supported by universities and their academical structure
I've never seen a new CS grad learned how to make stuff in college.
Learn Git if you don't know it. And then really try to master it. I'm always amazed how bad seasoned developers are at the basics, and many are utterly oblivious when it comes to the more advanced usage. If you can become a wizard at git then it will definitely be a feather in your cap. Start playing around with Intellij, most tech shops worth their salt will use it instead of eclipse. It will feel like upgrading from a push bike to a self driving car. Apart from that, as others have said - spring. It's a steep learning curve and there are so many sub projects now, but just start off learning the basics playing around with the bean factory. There are some good introductory tutorials here: https://www.baeldung.com
Gosh where is all this FUD coming from? I feel like we’ve had a weekly thread on this for at least six months. 
Looks the same as some existing frameworks. And using cutesy names for the various parts of the framework that have nothing to do with what they are used for is going to be confusing to new users.
I think the transition to senior developer is usually more about soft skills and delivering value in other ways than writing code. Good advice, planning, architecture, business value awareness, methodology...
I forgot to touch on that so I’m glad you mentioned it: companies love an engineer with business value awareness. 
Will Fuse remain independant from Websphere products?
Just putting this out there but [Amazon Corretto](https://aws.amazon.com/corretto/) is an open JDK distribution that is free of cost. I really don't know much about it but just throwing it out there. 
Find the fortitude to tell the higher ups how things should be done. If they don’t fire you, congrats! You’re a senior developer. If they do, they don’t really want senior developers. :)
Coretto is JDK 8. Open JDK is 11.
&gt; I dropped out of college because I didn’t see it being beneficial for me at all, I wanna work full time have a good income &amp; develop on the side for a year or two, and rail into the industry with some projects behind me and knowledge. This kinds of questions should go on /r/cscareerquestions. You're asking a question that is a lot broader than just Java.
Or, what I feel most companies will do, option 3 is stay on an old version of Java and forgo any updates. 
May be we should have sticked post, i mean Oracle just set Java free and we get complains like every day. 
Lamp
For what I understood they are being discussed but no yet on their way.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/javahelp] [Jdk 11 migration: How to deal with split packages?](https://www.reddit.com/r/javahelp/comments/9yey55/jdk_11_migration_how_to_deal_with_split_packages/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
out of interest, what didnt you like about kotlin?
Don't bother with certificates. Read design patterns, and effective Java, write lots of code. Upgrade to intellij.
It looks like in your [submission](https://www.reddit.com/r/java/comments/9yf3wv/kodilla_bootcamp_yup_or_nope/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*