I see this sentiment a lot but as a very heavy Kotlin user in a Kotlin shop I have not experienced this difficulty or encountered other devs experiencing it so YMMV at least. IntelliJ formats vars differently from vals which I find handy.
Have used Kotlin since 1.0 came out. I do not experience this problem at all. In fact I think it's great because it means writing immutable code is that much less annoying.
It wasn't a very large application, but especially final parameters will add to the noise. Before enforcing this at your company I recommend converting a medium size project to see how it feels working with it. When we enforced finals I used to actively avoid extracting methods, because the signature would often exceed the line-length of the style guide. If your style guide is 100 chars, you could do this: private String getSomething(String username, String email, List&lt;String&gt; somethingElse) { // ... do something } With finals this line would become 107 chars instead of 89 chars (18 bytes of finals), and would have to be written like this: private String getSomething( final String username, final String email, final List&lt;String&gt; somethingElse ) { // ... do something } 
This discussion pops up every now and again. I like to make classes final by default, so opening it up for inheritance has to be a deliberate choice as the problem can often be solved more elegantly using composition. For cases in which inheritance makes more sense, the final can be removed with a commit message or comment providing an explanation. For re-assignment of parameters, I would rather use a linter.
&gt; This forces good devs to do more unnecessary boilerplate however True. But I've been in projects where these practices were enforced and it didn't bother me in any way. It just becomes a habit. Heck; I have seen worse habits. One was that every member var would be prefixed with an underscore. I was on that project for almost 2 years and you see that habit in my personal projects in that time too. Took me a long time to get rid of. I didn't agree with it, but as a consultant it's just something you have to deal with. Every team has their own habits. Good and bad.
I get that this is just explaining Java's parallel implementation of MergeSort, but it offers insightful comments as to why is it implemented that way. Nice read, thanks.
Thank you :)
I really hate the x() and y() methods instead of getX and getY ... no one will write a RECORD/DATA object like that...
&gt; It is a little sad Java has been very slow to adopt newer language features, but historically it's always been this way. And this is what probably makes Java so appealing for enterprises and governments. Such entities want to build and maintain heavy-duty system that last for decades. Keeping track of dependencies is challenging enough already. They don't want to also constantly chase after the newest language features.
wait ... going from one core to seven cores, you get less than 2x speedup?
Sometimes mutating parameters is the perfectly logical thing to do: public static double ldexp(final double x, int e) { long i = Double.doubleToRawLongBits(x); e += (int) ((i &gt;&gt; 52) &amp; 0x7ff); i = ((e &amp; 0x7ff) &lt;&lt; 52) | (i &amp; 0x800fffffffffffffL); return Double.longBitsToDouble(i); } or: public static double hypot(double x, double y, double z) { double s = x = Math.abs(x); if (s &lt; (y = Math.abs(y))) s = y; if (s &lt; (z = Math.abs(z))) s = z; // s = max(|x|, |y|, |z|) if (s == 0) return 0; x /= s; y /= s; z /= s; return s * Math.sqrt(x * x + y * y + z * z); } 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
If you don't care for the point about the preferability of immutable objects, especially in cases where they're hard-coded collections, perhaps this will convince you: for a given interface, there are many more mutable data structures than immutable ones, as there are many more decisions to make about a data structure that supports mutation. Therefore, it makes sense to make the "simple" case immutable, and allow mutable choices on top of it. If you want an array list you do: new ArrayList&lt;&gt;(List.of(1, 2, 3)) if you want a different kind of mutation, you do: new CopyOnWriteArrayList&lt;&gt;(List.of(1, 2, 3)) 
Yes because it is not linearly scalable, obviously. Moreover, the more elements we sort, the bigger is the difference.
&gt; Developers would need to be really junior to mutate method params. There are rare use cases... (e.g. param value normalization)
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
serious question: who cares about a 2x speedup for 8x the price? i have a hard time coming up with a usage scenario for this. is there a problem domain where you have to sort such vast amounts of data crazy fast, but don't care about clogging the machine for a marginal improvement?
A quote from [this](http://cr.openjdk.java.net/~briangoetz/amber/datum.html) proposal: &gt; Without rehashing the properties debate, one fundamental objection to automating JavaBean-style field accessors is that it would take what is at best a questionable -- and certainly overused -- API naming convention and burn it into the language. Unlike the core methods like Object.equals(), field accessors do not have any special treatment in the language, and so names of the form getSize() should not either. Also, while equally tedious, writing (and reading) accessor declarations are not nearly as error-prone as equals().
I actually like that. It's a nice way to distinguish immutable records from classic bean or classes while reading code.
Use them where needed. Generally only for constant values, to enforse initialization and otherwise when you're sure a reference should not be charged. Within a class or method, the concept of encapsulation means the developer is in full control. If you feel that within these spaces you're having trouble controlling them, it's probably because you're changing them too much. Close your classes to modification.
That's a good question. First, I don't think it will be 8x the price than a single-core machine. Moreover, for my you are taking the problem the opposite way. Today, every CPU is multithread. For example with Intel hyperthreading technology, every core is able to two threads in parallel. So for me, the question is rather, how can I optimize my application in regards of the underlying hardware? Multithreaded application should be the standard, not the exception. Last but not least, it not only a question of average latency but also of resources optimization. If you application is running faster it may also increase the overall throughput. Hence, for example instead of having to deploy it on 4 nodes to achieve a given goal, maybe you can only use 2 nodes.
I don't follow. If multiple nodes are involved there is already something inherently parallelizable about the problem. As a concrete scenario: * Use single threaded sort, run 8 nodes on a single machine. Throughput 8 tasks/timeunit, Latency 1 timeunit. * Use parallel sort, run 4 nodes on 4 machines. Throughput 8 tasks/timeunit, Latency 0.5 timeunits. This is such an obvious waste that I think people should be actively discouraged from doing it in almost all situations. TBH, I was hoping for a real world example, not generic "it's useful because I tell you so". 
I'm not downvoting you sir. I rather upvoted your comment because I found the discussion interesting.
Sorry, I meant reassigning the method parameters. If you need that, you can copy the parameters to local variables just to make it clear what happens. 
You're a bit dense.
I don't think I'm angry. More... puzzled. Lower latency does not mean higher throughput. They are two different numbers, and in my experience the relation is often direct, and not inverse as you claim. For instance TCP is high latency high throughput, UDP is low latency low throughput. I think it's a general phenomenon: If you can buffer (=higher latency), you can optimize (=higher throughput). 
A tldr question here since my post was removed by the bots: Does openjdk have plans to support LTS versions themselves?
Your benchmark ought to have output not just the elapsed wallclock time but also the total CPU time across all cores, a statistic that at least the Linux kernel is able to gather for threaded programs. I suspect that your problem probably just has most of these threads sleeping rather than doing work, so there probably isn't a big difference between the wallclock time and the total cpu time.
Not sure what you mean by "themselves." OpenJDK is a community effort, led mostly by Oracle (~90%), followed, I believe by Red Hat, as well as other companies (Google, Intel and more). Oracle developers will continue contributing most of the security patches to OpenJDK but have not committed to backporting them to LTS releases after the next feature release comes out, and likely won't do so. I think Red Hat developers said they will do the backporting, but I don't know if they committed to that. If someone does the backporting, various organizations will provide builds. I know AdoptOpenJDK has committed to building update LTS releases. I don't know if Oracle will provide builds as well. (I work at Oracle on OpenJDK)
For clarification, it is good to know other groups will support backporting, but if any companies do backporting will they make it back into the fork from openjdk or will they be hosting it independently? New tldr: will any backporting by companies be put back onto openjdk for everyone to pull and build?
Yes. None of the OpenJDK contributors want to fork OpenJDK. Also, I don't know for sure if anyone has fully committed to backporting just yet.
Do you want to know what OP tells you? The goal was not not to optimize the results it was a way to introduce how it is handled under the hood with ForkJoinPool and the underlying scheduling strategy. Why are people on this subreddit so contemptuous...
I personally think final is mostly a noise keyword. It had use case back in the days of java 1.7 and before where an inner class required values to be actually final rather than just effectively final to be used within the inner class. In java 1.8 and later, values assigned once are treated as final without you explicitly making them so, and that removed the only reason where I actually had to use the keyword. Sure, declare things final if you think it achieves a tangible goal. E.g. a class member declared as final requires that there must be a value written to it during constructor, so you can kind of guarantee that in every constructor, an added member will get initialized because the compiler will complain until you do so. I sometimes also have a switch-case that computes a value and I declare the value as final to guarantee that there is only at most 1 assignment to that value in every code path, which helps with stuff like forgetting to "break" the "case" statement or something. I would definitely not mandate use of final. I think it's better to allow code to evolve, and final everywhere has little practical value. For instance, I see no reason to force it with method parameters.
Thanks for your insights. I'm slowly reading the "everything you need to know about memory" pdf and i'm already learning about many surpring things I had no idea about. It's insane to me how deep this optimization rabbit hole goes. 
Thank you, that's about the answer I was expecting but wasn't hoping for.
There are better ways to show how those things work than with an actively pointless use case. You then defend it by talking crap about reducing latency and how you can reduce the number of nodes. If you had originally said “hey this is just to explain how parallel pools work”, you wouldn’t get so much hate. If you want a useful scenario, why not just create a simple producer-consumer example? Say a naive web server where it generates a task for each connection and how that isn’t as efficient as using a pool and segmenting the tasks. You don’t have to write an entire web server, you just have to focus on the parallel part. Then you wouldn’t have to defend it and say how everyone in the forum who doesn’t like your work is clearly just out to get you.
That’s great! One thing to remember that is often mistaken. Running in parallel is not optimization. Optimization is generally doing more with the same resources. You wouldn’t call a V8 and optimized V6, nor should you say “I optimized this code by using more resources”. You can say you made it run faster, but that’s not necessarily optimization. Now, you can optimize parallel workloads by reducing overhead, reducing blocks, bubbles, etc, but there’s a lot to it as you’ll find out delving into this stuff :)
It's not the point of liking or not my work. I'm more than open to constructive feedbacks/remarks. In your case you're just rude so I don't care about what you have to say. Being polite is not an option on the Internet. It's not because you're are behind your computer that you can say whatever you want. So I don't even read your comment, even though I'm sure that was somehow interesting. Bye.
I don’t believe I was rude, but ok.
We are talking about two different topics. So, whatever.
\&gt; and which ones are mutable `final` only tells you that fields / variables are not reassignable. It has nothing to do with immutability.
In Kotlin you rarely use var at all, so this is not a real problem.
Do you have any real evidence?
What the heck dude? You're right! Just kidding, this is just some high-level bullshit. Have you ever fucking heard of internet scums and trolls? They just copy some stuff and post it, besides if this was the companywho did it, they would at least better English. Down you go, my friend.
I think garbage collection is the best way to refresh your memory for java. Garbage Collector is a program that manages memory automatically. Garbage collection in Java happens automatically during the lifetime of the program, eliminating the need to de-allocate memory and thereby avoiding memory leaks. [Different types of JDBC Driver in java with example](https://www.javastudypoint.com/2018/07/types-of-jdbc-drivers-in-java.html)
The reviews are probs written intentionally in inaccurate English to sound more believable. Go check for yourself the link I posted to /u/oweiler :s comment, it's the real site
what makes you think it's fake? 
All we can say here is *someone* did this. As a side note, does anyone really trust product reviews on company sites? If I'm looking at product X the last place I feel like I'll get any relevant reviews is on the company that owns product X's site. Point this out to jetbrains and see what they say. 
it's powered by a third party service, could it be that the 3rd party service is duplicating reviews intentionally instead of jet rains? 
Either some user copy-pasted the stuff on different profiles or there was a copy-paste mistake when publishing it on the Jetbrains site. I don't think Jetbrains would fake a post that criticises its pricing model: [https://www.g2crowd.com/products/intellij-idea/reviews/intellij-idea-review-160723](https://www.g2crowd.com/products/intellij-idea/reviews/intellij-idea-review-160723).
That's an interesting find! Although there's no way to view the rest of the review in the download site, and they made the review sound extremely positive by only including the "what do you like best?" -part... 
Good read indeed. I continue to find it surprising the amount of elements (or N w/e it is) we need in order for parallelism to speed up. I know parallel tasks creates overhead of creating the thread, context switching etc but it’s still a surprise to me how much that cost which results in needing bigger tasks (increase N) to make up for it. In this article N is 8192! 
So what JRE should we use in production (say for running a Tomcat) to avoid paying Oracle? 
If you don't want to buy support from Oracle or any other vendor, don't use the commercial builds for customers but the OpenJDK builds at [jdk.java.net](http://jdk.java.net/) (or, if you prefer, from another organization that provides OpenJDK binaries). He addresses that in the talk [right here](https://youtu.be/MFfTqUQxFTs?t=883). 
Thank you for your answer. I watched the video, and from what I understood, there is no more "JRE" only JDK. I, however, couldn't start a Tomcat that previously run on Oracle 1.8 JRE, with OpenJDK 11. Moreover, I can't find a OpenJDK 1.8 JRE build, only Oracle ones on [jdk.java.net](https://jdk.java.net) 
There are no more separate JREs. The recommended practice is to create a custom JRE using jlink from the JDK, and distribute it with your application (or install it on your servers).
Thank you again. I will look into that. Any chance OpenJDK will have a "full version" runtime built with jlink hosted on their site for ease of use?
Come on mate... even if we assume the worst of JetBrains and assume these reviews come from them, a fake review hardly 'scams' anyone into doing anything. Tone it down a few notches. It's free to evaluate. Who would be being harmed by trying it out from a fake review, even if it came from JetBrains?
Where's the evidence that *JetBrains* posted the reviews?
At university I was taught to start every member variable with the letter m: mPrev, mNext... Because my professor only used vi without syntax highlighting and expected us to use vi our whole careers.
Each of them address such a crucial upgrade to Java, that it cannot get any sooner. Loom is gonna be great on servlets, Valhala is insane in high computation software. Panama will push Java out of being "boilerplate" language. Really looking forward. 
What a horrible post. I'm not spam or JetBrains or anything. I'm a professional developer who has used Eclipse and IntelliJ, and today I pay for IntelliJ that's how much I love it. Just because someone found a few garbage reviews really means nothing.
It only starts to get suspicious if this occures many times. Just two reviews like this does not give enough evidence.
I've been on both sides of the debate. I wanted to use `final` everywhere, but it just cluttered my code. Effectively final is good enough, just use static analysis to enforce immutability for parameters. I only explicitly declare final for fields. 
Oh sorry, I had forgotten to repeat the question. Ivan Krylov had asked whether there was a way to turn off randomized iteration order, and my answer was “Nope!” The room monitor was waving the “out of time” sign at that point. They needed to clear the room and check people in for the next talk in 15 minutes. I get irritated when I want to set up for my talk and the previous speaker is hanging around on the stage, in my way of setting up, so as a courtesy to the next speaker I always try to end promptly and clear off the stage as quickly as I can.
&gt; Panama will push Java out of being "boilerplate" language That's Amber. Panama is all about interfacing with native (C/C++) libraries. As far as I can tell, Amber (language features), Loom (lightweight concurrency), and Valhalla (data locality, primitive generics) will be much more widely applicable than Panama
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
What version are you using?
Where I like my finals to be ? * CONSTANTS * Immutable classes * variables for inner classes. I personally feel making **local variable final is an overkill**. We should focus more on limiting the scope of the local variables. Having large blocks where the variable is anyways not good for maintainability.
Yeah. Who makes software purchasing decisions based on reviews found ON THE PRODUCT SITE of the software you are purchasing? That is like trusting a car dealership because have a "best car dealership in the world!"
Could you stick it in a finally block?
It looks like in your [submission](https://www.reddit.com/r/java/comments/9rohsv/bbx_bbj_business_basic_vpro/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I saw it and I do not agree if I would want to read something I expect to be accessible via get/is and this is already in the language and is what everyone will look for and will expect. I think I will stick to Lombok and will probably never gonna upgrade past 11 or maybe it is time to fork it .... yup maybe even from 8th everything after that is just not as it used to, I miss Sun Microsystems :(
I am just a beginner too, but my guess is that the **return** key word acts similar to a **break** in loops. The code after you return a value never gets executed.
[1] Don't close the scanner. Scanner is a so-called 'filter' I/O object: It wraps around another, in this case, System.in. Closing a filter closes the thing you wrap, and closing System.in is no good. [2] as veradux_ said, the 'return' statement ends the method, and thus that close call is never reached, hence the error. [3] The solution is to just not call close at all here, but if you ever do get into the situation where you have a resource that you should close, use the [ARM](https://www.infoq.com/news/2010/08/arm-blocks) construct.
\*grabs popcorn\*
&gt;Why are people on this subreddit so contemptuous... Because you did a poor job explaining that this article is not actually about a mergesort. Title, some history amout mergesort, then suddenly start talk about ForkJoinPool.... It is a rather poor combination. 
&gt; maybe it is time to fork it .... yup maybe even from 8th everything after that is just not as it used to And who's going to fund the fork? Oracle employs hundreds of developers to develop OpenJDK. It would cost far, far less to contribute to OpenJDK and influence its direction if it's not to your liking. As Mark Reinhold [says](maybe it is time to fork it .... yup maybe even from 8th everything after that is just not as it used to): &gt; Just like in every open source community, the first rule is that you have to show up... Every participant on OpenJDK participant on every OpenJDK mailing list, every individual on the internet, even, whether employed by a large company or not, has the opportunity to influence the direction of the platform. That degree of influence is determined by the extent to which you show up and contribute here in the OpenJDK community on a meaningful ongoing basis.
I actually did this the other day.. but it was a day later than when I wrote the code. My thought was "why the f*** did I do that?!!"
I don't give a f*** about your opinion.
(Presenter here.) Thanks! Yeah I had really bad luck with audio this time. Both of my sessions had issues. The other session was _Collections Refueled_: https://www.reddit.com/r/java/comments/9rbxuy/collections_refueled/
That's right! I found both sessions to be incredibly valuable, and obviously any issues with the venue was entirely out of your control! I'd definitely rank your presentations in my top 3.. and that's going against some pretty tough competition like Venkat S. The DevOps side of the conference, however, was extremely lacking in quality presenters. That's another topic of conversation entirely though. Thanks again! 
Hell if you just need a basic Java tool set you can use community edition in perpetuity. I think if anything we should just assume it is a software defect. 
Readability, you say
No unit showing in the charts… no explanation on whether higher or lower is better, the text doesn’t really explain it also... So we’ve learned nothing. 
Jersey and MySQL - see you in an hour 
the verbage says exactly what the units are &gt; Each RESTful service is being called 1,000 times in a loop, by three different RESTful clients in sequence, and the results are being displayed in the bar charts. The charts show the time taken in terms of microseconds for different servers and client services 
Do you have any sort of evidence that this was Jetbrains? Sounds like a huge leap in logic here
&gt; Each RESTful service is being called 1,000 times in a loop, by three different RESTful clients in sequence, and the results are being displayed in the bar charts. The charts show the time taken in terms of microseconds for different servers and client services &gt; Three figures are shown to build a perspective on how framework performance varies at different times 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Oops my bad. Sorry I missed that part even though I read it two times. I’ll leave it there so you can downvote me at will. 
Here's a real life JetBrains user telling you I didn't look at these reviews at all. I used the free evaluation to decide, and what I decided is that I freakin love their IDEs.
 joonas_davids, your Veneta is pitiful.
Lol. Theb lack n of evidence is proof of the conspiracy.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You'll just have to switch to OpenJDK like everyone else. Nothing bad will happen to you.
Well that's a nice video.
If he had explained this a year ago we wouldn't have those myths in the first place.
What exactly mean security at java?
If you want to know the difference between Oracle JDK and OpenJDK going forward watch this Oracle talk. https://youtu.be/MFfTqUQxFTs?t=577
Software vulnerabilities. If you don't know what these terms mean then it's probably not your job to worry about this stuff.
Security in this context means not being vulnerable to people trying to attack your application - trying to get access to your data or computer remotely. People will try to attack your application in hundreds of different ways. Being supported means someone is watching for new ways to attack your application, and modifying Java so that these attacks do not work, and giving you that new version of Java.
1000 iterations is nothing at all. This probably is the reason your results make no sense. The difference between clients should not be that big and they should be consistent between the different frameworks your testing. You should also show idiomatic framework code. For example this certainly is **not** how you send JSON responses from Spring: @RequestMapping("/rest/springboot") public String greeting() { JSONObject data = new JSONObject(); data.put("java-home", System.getProperty("java.home")); data.put("data", "Hello World!"); data.put("time", LocalTime.now()); data.put("rest-service", "SpringBoot"); data.put("server", "Tomcat"); return data.toString(); } You really should retract this.
Now it is clear. Thank you!
You are going to fork Java, so you can use getX() instead of x()? Ok...
Assigning to a reference variable has no visible effect on the caller.
I see some ideas from Scala which I like. 
I'm sorry, but this is terrible. What a pretentious, click-baity title. The article provides no help whatsoever in choosing a framework. A more proper title would be "something you can safely ignore when choosing a framework", i.e. some completely meaningless "performance measurement" that has nothing to do with any real-life scenario and is completely inconclusive in itself. 
We will switch to OpenJDK as default. Clients that want to pay extra for Oracle Java can do so.
If you develop "Hello World" applications, you don't have to worry about security. But the Java API contains functions to download files, handle certificates, encrypt and decrypt things and so on and there can be obviously security issues. In addition to other bugs, for example a possible bug might be that java executes random code when you add to many items to a hashmap or whatever.
Bof. It looks like people begin to understand it was not really a good idea and now need to justify the introduction. 1) when you need to justiy a new feature it rarely means that it was a good idea to introduce a new stuff. 2) C++ has a kind of 1000 pages guidelines on the right usage of the language, this is why it is no longer usable. 3) The justification is mainly: use good variable name. Ok, intead of MyComplexClass x=new MyComplexClass, we are going to write: var myComplexClassObj= new MyComplexClass. Great advantage Of course, nobody tries to see if it helps or complexifies the learning of the language... In conclusion, var seems to be definitively a bad idea...
1. Oracle has *also* open sourced the entire JDK. 2. OpenJDK is mostly developed by Oracle, and the copyright on OpenJDK is owned by Oracle, whether you use binaries built and hosted on Oracle servers or on Azul's. So you're using their free software either way. 
[He did](https://youtu.be/x7pkWlost64?t=515).
Yea, it's 5 I have an issue with - oracle wasn't very forthcoming with how long support intervals would be for which builds
I have been a JetBrains customer for about 5 years. I love all of its IDEs and so as millions of other developers. I can't imagine any incentive for JetBrains to use "fake" reviews on its own site when "real" positive reviews are in abundance all over the internet. 
I actually don't buy that part. They're already breaking applications in non-lts releases in ways that they didn't before the versioning change. These breakages are mostly prohibiting access to internal apis (they're expanding their reflection blacklists) but they still break things and require workarounds. In my opinion, people will just stick to lts releases for this reason, and won't bother with those annoyances every 6 months. The most important advantage to the new model is that there are no release drivers anymore (like jpms was, or like lambdas were) so major / lts releases won't be delayed by years anymore.
Thanks, very useful to me!
The caller is also not involved when passing primitives.
OpenJDK and Oracle JDK [are now the same software](https://blogs.oracle.com/java-platform-group/oracle-jdk-releases-for-java-11-and-later) released under two different licenses: a commercial one for those who want support, and a free one for those who don't. 
Assignment for the caller is save, but unnecessary. Just use another local variable.
I think that most of the impact is still the long tail of gradual migration to a modular JDK, and we know there are changes still to come (e.g. Unsafe). It's just important that even those who deploy only on LTS versions still develop and test with all feature releases. This both reduces the cost of upgrades and eliminates surprises (behavior can and will change without warning in an LTS release).
I think I was unclear. Perhaps "their commercial software" is more on-target. And make no mistake, that is not because of the quality of the products, which are generally rock-solid. It's the licensing, and the reputation for aggressive, expensive enforcement of even accidental infringement. I don't really care about it being "their software" if it's in the OpenJDK, as distribution under the GPL means that neither Oracle or anyone else can place additional restrictions on use (e.g. revocation of the right to run the software). I have no problem with Oracle's OpenJDK builds. I am of the opinion that serving up constrained-use binaries from the same, no-registration page that people have been getting their JDKs from for years is a mistake from a trust perspective, but that's up to Oracle. The links to the OpenJDK builds are right on the page, but I'm willing to bet that very few people read more than it takes to download an update. Perhaps it is a bit heavy-handed, but I'm happier keeping the possibility of license infringement at more than arms length.
both your initial comment and this one are higher voted than my correction ... it's a rough time to be factually correct in america ! 
good work! although the lazy evaluation (sharing) is not guaranteed in multi-threaded context since there is no synchronization. Also using a trampoline to implement foldLeft is a bit wasteful. Also a lot of work could have avoided, if derive4j would have been used.
"security" in the context of java is such an overloaded term. many of our vulnerabilities are based on executing **untrusted code** for most other languages, security is limited to untrusted input conflating these two concepts has led to the public thinking of java as less secure than other languages, when in fact it's much more secure 
Thanks! I'm aware of your project derive4j, and I think it's very impressive. I only learned about it after I had already finished most of the work on this project, but the truth is that I did this mostly for my own edification, so letting derive4j do all of the hard work for me would have defeated the point! Can you elaborate on the issue with multi-threaded lazy evaluation? I'm not sure that I follow. I don't talk about it in the documentation, and I really need to, but I think I've addressed that with [`Functions.memoize(Supplier)`](https://github.com/gdejohn/procrastination/blob/235bf490388be978486ba620cd77b0343986d55e/src/main/java/io/github/gdejohn/procrastination/Functions.java#L44-L79), which you can see in action [here](https://github.com/gdejohn/procrastination/blob/235bf490388be978486ba620cd77b0343986d55e/src/main/java/io/github/gdejohn/procrastination/Maybe.java#L458-L479). As for the left fold implementation, I'm planning on writing some JMH benchmarks. I'll compare trampolines to the imperative approach and see how big a difference it makes.
Fair enough, but to complete the picture, Oracle's JDK previously also contained commercial features, and also had or potentially had use restrictions, so it's not as if it was all clear and now there's an issue. Instead of commercial and free features bundled into the same software, all commercial features have now been opened (or ended), and you have a separate distribution for each license; I think this is clearer (except for the fact that there's been a change, and it takes time for people to get used to changes). 
var is nice to cut some obvious boilerplate (like when you have `new` on the right) but yeah spamming it all over the place is as bad as it sounds. 
Not I but even the var thing is a crap everything after modules is just useless :( 
I think you do not understand the idea of a form, you can fork it and keep it updated to the main stream however change the changes in the language especially the syntax sugar ones which are actually hell of a weird.
Community edition?
it doesn't support spring natively or tomcat
Bad robot
Personal license can be used for commercial purposes. It can only be used by you though
agree. or just use community edition
You could buy personal licence for about 120EUR per year and it gets cheaper every year. I think that's pretty reasonable price for a year of amazing product if it boost your productivity. You can use it for both personal and professional coding. I bought it myself they even have some discounts if recently graduated from a school.
If you still have your school email you can use it to get a free professional license for a year. Then you can get a personal one after
Take a look at this: https://sales.jetbrains.com/hc/en-gb/articles/207241015-Can-I-use-my-personal-license-for-commercial-development- It says: "Yes, you can use your license for any kind of development. However, only you may use your personal license; you may not share it with others. Also your company cannot pay, reimburse, or in any way finance your personal license." 
Explain to your manager that the time wasted not using it costs much more than the license. 
I work for a huge multinational company and I am using my personal license at work. I have a monthly subscription now (with discount because I've been subscribed for over a year) so I have to register the new license at work every month, but that's okay for me.
Use the Community version if possible. 
My last employer was a university, so I had an academic license for years. The very same day I submitted my resignation, I purchased a personal license. 
I use the Community Edition to work on Spring Boot apps at home. Honestly I don’t find the Spring features of Ultimate to be that necessary. 
interesting, i didn't know they gave a discount on the monthly after a year as well. I did monthly for a few months just to see if I truly thought it was worth it or not.... it definitely was.
Even ultimate is worth it imho, but yes the community edition is also pretty good
Why are you bringing this up in /r/java? It has nothing to do with Java. Go tell it to /r/intellij. Personally, IntelliJ sucks, Eclipse rocks.
I'm a junior dev without degree/experience, so i'm not really well payed. I can't afford it (and there are other things outside my job I wanna prioritize), and I've calculated that given the time I lose when switching tab, if I switch tabs more than once every two minutes it would be cheaper for my company to buy IntelliJ. But I don't switch that many times.
Eclipse is really terrible. Have you given Netbeans a try? IntelliJ is my first choice but if that is out for you I would try Netbeans. Both are worlds above eclipse.
Does it do code completion etc with spring/jee on the CE edition? 
Could I convince my company to participate in the costs ? 150€ is okay, but my job isn't everything, I need to upgrade my PC buy a videoprojector etc
I didn't graduate, so I can't and it might be interesting in a few months, but not now
Make a business case for it. If you get paid X a month and put out Y features per month but with IntelliJ you can put out 1.5 Y then you are saving the company 0.33 X a month if that number over a year is equivalent or higher to the cost of IntelliJ it would be a bad business decision for them not to pay for it.
against the license terms, they cannot contribute at all - however it is unlikely jetbrains could find out.
Good to know - I might actually buy it for myself in light of this.
Unfortunately no. Have a look in the mid of [this](https://www.jetbrains.com/idea/buy/#edition=personal) page though. Maybe you are eligible for a certain discount
I just calculated I would need to be switching tabs every two minutes to make it cost more than the license cost. Not impossible but not sure if it is indeed the case
Option BOYC. If this is a BYOC (Bring Your Own Computer) environment, get a personal copy of IntelliJ for yourself with your own money (not reimbursed) and you've got IntelliJ. That's $150. You've got it (Horray!) and its on your machine that you have at home (Horray!). ---- Option "Persuade the manager". Let's talk about a $500 (yearly billing first year) cost. You work about 2000 hours per year. Having IntelliJ means that you've got a $0.25/hour cost in the first year for IntellIJ. Will you be $0.25 more productive each hour with IntelliJ over Eclipse? That's fairly certain. $500 is a rounding error when it comes to compensation in most places. Note that it will be cheaper next year and the year after that. Get the 30 day trial for the ultimate edition and sit down and show the features that really make a difference. Some examples for me professing my love for IntellIJ in Slack... [spring configuration](https://slack-files.com/T0VD96U9G-FD4AQB5T2-15aa3aedef), [property file introspection](https://slack-files.com/T0VD96U9G-F95LBHRA7-775cd9e76d), [jsp link suggestions](https://slack-files.com/T0VD96U9G-F219HAKNZ-dce9e1c8f4)... and then [sql suggestions](https://imgur.com/bnpgG0m) I'm sure you can find more that you love. When doing that demo, have a can of soda from the vending machine with you. What do they cost? $1.00? $1.50? Point out the cost of IntelliJ at $0.25/hour compared to the soda. ---- Option "Ok... Eclipse sucks and we're stuck on free" Give NetBeans a try. It doesn't get much love from the developer community, but it does its job (personally I feel better than Eclipse) and has a lighter foot print than Eclipse.
Or you can start Tomcat programmatically from a Java class. The IDE support is practically useless.
None of that is necessary. Also, you can use Ultimate EAP version for free.
Why don't you fix your Eclipse? This is not normal.
It's not 600, but 150 for me. For my company, the engineer heading us thinks it's overpriced too. But yes compared to the costs for an entreprise it's not that much
I tried. I downloaded eclipse runtime, added the minimal plugin to start my project and it still is lagging like hell
Use Ultimate EAP when available, report bugs, get a free license. When EAP is not available, use Community, at least you will see that the Spring/Tomcat support is totally unnecessary.
I use the community version of IntelliJ at my job and it generally suits all of my needs. The big problem is that it doesn’t have syntax highlighting for certain things (e.g. JSP), but all in all, it’s got everything I need for java development. 
Use another ide and the command line. What you need in the ide for Java is ctrl+click navigation and auto completion. All the rest can be achieved by command line easily. IntelliJ is very slow and does much more than is needed. Atom/sublime/vim/emacs/... there’s nothing special about IntelliJ. Did I mention it’s mysteriously slow and drains resources on a desktop occasionally making it freeze/crash? Don’t waste your money. Java apps on the desktop are slow.
Eclipse isn’t getting older. Eclipse is lacks many of the fancy features in IntelliJ, but I have used eclipse largely without complaint for 8 out of 10 years of my career. I like the features of IntelliJ, but it’s terribly slow when on battery power (on my nearly brand new 2018 mbp)
Antivirus, antimalware, SSD?
I too love vim and emacs, but for java no way. Baf suggestion.
&gt;but 600$ a single license is a no go. Why not? It's probably what you cost the company in wages for only a few days anyway. 
It’s your absolute right to choose that it’s not your priority, but trust me, there is nothing like it yet. For me it was an investment in my future and it payed back for it already a long time ago. 
Is your workspace on a network drive? 
Still a bit expensive for now
Windows defender only, excluded eclipse folder. Running only on a SSD
Its more common these days for people to bring their license with them. Intellij is literally indispensable. Its like a contractor with a really good toolset. Also, unlike Eclipse you can really use it for everything. I spend all my time in it.
It's not super hard to unlock without a license I can't support paying a timed subscription for software If it was a flat amount and I own the license, then sure. One time pay.
&gt; For me that reduces cognitive load I've had to work with code like this and I feel it **greatly increases** cognitive load. - Reading the code - "final" scattered all throughout your code creates a lot of visual noise you have to mentally parse out - Increased cognitive load in trying to figure out what it's doing: final is inconsistent in what it means. final makes your reference immutable but not the object you're referring to. So final int is immutable, but final User is a User object with mutable properties, you just can't assign a new User object to it. Did that make your head hurt to read?, that's my exactly my point. It makes things more complicated to read, not less. - A nightmare when you get past simplistic cases and into objects that refer to other objects that refer to other objects...and then you need to change a variable at the bottom of the tree. The business doesn't care about your ideology on not changing data, they want the data changed. Now you have to manually copy the entire tree of data...you know how much higher the odds you'll have a bug in your code that copies large graphs of data is? Trying to parse that does this is a huge headeache. 
I would use Visual VM to look what is eating the time.
OP can't - JEE isn't supported in the community edition.
Or: public boolean validateUser(String username) { username = username.trim();
Hey, thanks. It’s probably because the restaurants and bars around conferences are so noisy, one has to shout a lot. That deepens my voice by several notches. Usually my speaking voice is a tinny, high-pitched whine
Keep in mind, the license include perpetual fallback . . . so you only have to pay it once. The only thing you gain from paying it again and again is access to updated versions.
Yeah, it takes a bit to set them up and get used to it but some people like to code that way. Nothing is faster than that in any case, both because the code doesn’t run in a jvm and because you don’t use any mouse. I used IntelliJ but dropped it some time ago because it froze my desktop while “indexing”. 
&gt; This sounds like 'magic thinking': That by merely following extremely simple, easily lint-able rules, that this small step will somehow lead to a team that writes code that doesn't suck. It never works. Coding is hard. It just is. You can't dumb it down like this. I think it's much worse than that. In simple cases it makes no difference people pat themselves on the back that they put their own imprint on the code and the code is slightly messier to read and they move on. In complex cases it is an absolute nightmare. You have a 3 level object graph and you need to modify something at the bottom of the graph. What do you have to do? You end up with writing manual code to copy every object in the object graph over. There's a lot of potential bugs in that code when it's written. I literally just found a bug in a simple 2-level object graph where they missed 1 property. But long term it's much, much worse. You add a new property somewhere in this object graph, and now every manually-copy section of code has a bug where it drops the new property. In contrast, making objects final is a "solution looking for a problem" thing - I've never seen a bug that wouldn't have happened had the object been immutable. I'm sure in the whole world there's somewhere where this has happened but like I said...I saw a bug because someone was copying data from one object to another and missing a property just last week. 
Set aside ten bucks a month and you'll be able to afford Ultimate by next Christmas. $150 is a very small investment to make in not hating your job. Also, you'll have a perpetual license for the version you buy, and can take it with you to your next job.
Turn off the features you don't use in Eclipse and get some performance back. [Details](http://www.beyondlinux.com/2011/06/25/speed-up-your-eclipse-as-a-super-fast-ide/) * Validation * Spelling Also make sure you're using a reasonably recent version.
If $600/dev is too expensive for your company then I suggest you find another job. The place you work at either doesn't care about it's employees in the slightest or is doing so poorly they wont be around much longer. 
Slow tab switching in eclipse is usually caused by corrupted meta data. You should probably be using Spring Tool Suite anyways. 
well it is cheap compared to 3000 bucks for visual studio enterprise
I got the full toolbox license when it was on sale for like $125 for the year this summer. Very pleased.
not a problem, you lose some features, but you are still productive with it. If the IDE is the productivity bottle neck, I think he has a bigger issue.
All classes package-private and final by default unless they can't be (for instance for generating proxies at runtime). All fields final. But We don't mark parameters or local values as final for several reasons, mostly because: - reassignments should be fairly obvious in well-written code (small method bodies) - most of the time it's just noise which brings fairly little value (same goes for final classes, but the consequences are usually more severe with inheritance, which stands out in review) Apart from that most of the objects we use are immutable (We've been using Immutables, although there are other viable solutions)
Well, it is a flat one time pay. You get a license for the existing version and as a bonus a one year trial of upgrades.
Jetbrains also runs sales every so often. I saved $25 on a “all products” renewal with a promotion they recently had.
I've said for years that IntelliJ Ultimate is worth every penny. Their support is amazing, should you ever need anything. Also, just email them with your predicament and they'll give you a quote. Maybe they'll give you a discount on a personal one? I only pay $89/year now and that's less than the cost of one lunch per month. Enjoying the time I spend writing code, querying databases, etc is easily worth the cost of the software.
I think you're reading it right, although I meant it as a simple fact more than snarky. I don't know how else you want me to say it. I can buy a lot of things that I don't buy, but I don't blame the price. If I feel it's worth it, then I will reprioritize my budget, and if I don't, then I won't. The post comes across almost like Java developers require IntelliJ, and that's not true, there are many alternatives.
Then update your Eclipse to the last version. Eclipse may not be as fancy as Intellij, but it's definitely not old...
Last I checked it was $149 a year. Did they change it to a one time payment?
*shrug* Bad pricing models aren't cool either
Spring boot will auto configure embedded tomcat. Just click 'run' in IntelliJ (community) and it runs fine. What does Ultimate do that I am I missing out on? Sometimes I don't, though, because for some reason IntelliJ's auto build is disabled whilst it is running, so I run it in a terminal and let Spring's devtools auto reload when IntelliJ rebuilds a class.
I got my first Jetbrains software [when the world was ending](https://blog.jetbrains.com/blog/2012/12/20/jetbrains-end-of-the-world-clearance-sale-24-hours-only/).
You can code JEE with the community edition. It just doesn't have all the fancy features that Pro has.
doesn't appear to have anything to do with java
I wouldn't use the community edition either, I'd bet eclipse is more productive than trying to work around the lack of web support in the community edition. 
I've also used both for project and slightly prefer eclipse, so opinions vary I guess.
The thought a company like Jet Brains needs to post fake reviews is hilarious. I'm an iOS developer and even in that space their IDE is the best
Seeing as Enterprise Visual Studio is like 8 grand I dont think 600 is bad at all......
Easy. Calculate the time it takes you to do X with software A and with software B. Multiply the difference by your hourly rate. Check if the accumulated cost of your wasted time per year is higher than the cost of a license per year. If it is, then the license is worth the money. It's called a business case.
The point of microservices is that they can be [deployed independently](https://erikbern.com/2018/06/04/missing-the-point-about-microservices.html). Using REST doesn't imply you're using microservices.
not sure how much of your productivity is tied to the intellij feature set vs the speed (eg, switching tabs), but if you don't need all the features of the commercial license you could try: * intellij community edition * netbeans * a fresh install of eclipse (i'm not an eclipse user so i'm not 100% sure what this would entail) 
Using the educational license for commercial purposes is against the terms afaik
$50/month for a tool for a highly paid professional like yourself is not a significant amount of money. It probably costs more to get bagels for the morning meeting. If your company won't invest in tools for you to be productive, it's time to find a new company. BTW, you should just get the all tools package, it's $649 for the first year but goes down to $389 or something after a couple years. I'm a few years into subscribing and it's great, I use 3 or 4 of the tools and it's so worth it.
Because some times the project is so closely tied to the IDE (plugins, add-ons, etc) that it's a pain in the ass to switch IDEs and getting it to work, not to mention that you're on your own when you've got a problem and get stuck while using a different tool that the rest of the team. It sucks to use an outdated set of tools because your productivity falls to the ground and your morale goes with it, but it's not that easy to be the only one using a different set of tools. Source: I was that guy and there were days when I almost quit my job out of frustration because both alternatives were shit.
It is. I bought a professional license when I graduated because of that.
It's not especially different than having to buy an upgrade
If your company is not operating at a loss and pays any taxes whatsoever, this is a tax deductible business expense. Free IDEA. 
Not to be a dick, but if you can't figure out how to get Eclipse to run properly you're probably not gonna make it as a Dev very long...
&gt;Use Ultimate EAP when available, report bugs, maybe you will get a free license. You actually know someone who got license that way? I use EAP extensively and many times I find more or less annoying issues. 
Even if it somehow weren't free, it's still software. So yes, it can be free if you want it to be.
How? People did JEE development way before IDEs with JEE support were available. 
Sure, it's possible, just as much as it's possible to write Java using Notepad++ as well, but switching between one program to do task 1 and another to do task 2 gets to be a pain. The whole point is that OP was looking for something to get the whole workflow done, and if the recommendation is to go with a version of IntelliJ that forces the use of other programs to actually run the application, I'm not sure it's much of an improvement over the current setup.
So “dead in the water” was a fairly significant exaggeration then. 
Thanks for the response. I'm the senior in the team that I've joined. This team consists of one mid level developer and 5 juniors (4 of which came from a 4 month coding camp, with no java experience) I'm taking control because I can and I've been developing with Java for 5 years. I've ordered several copies of Effective Java and clean code for the team. I want my team to do well but most importantly learn! 
This seems like the sort of thing you would use object capabilities for. That is, you'd keep the "global" UserService under strict access, and then you'd pass an object was scoped automatically to the specific user, and couldn't access anything outside of its scope: ``` UserService userServiceOnlyForUserId = userService.refineByUser(userId) ``` 
I do, yes. Not by specifically using the EAP, but by reporting bugs in general. Surely you'd be able to find more bugs in the EAP though :)
The benchmark will be interesting in any case, right. I will try to have a closer look and comment on github, I think the main issue is the implementation of [Lazy.principal](https://github.com/gdejohn/procrastination/blob/235bf490388be978486ba620cd77b0343986d55e/src/main/java/io/github/gdejohn/procrastination/Sequence.java#L235) that looks like it does not actually memoize the result (repeated calls of `Lazy.principal()` will duplicate work each time).
Also the commercial license is transferable to new employees. The personal one starts with OP.
Yeah, I definitely need some more documentation explaining my decisions. So basically, when you set up a big pipeline of operations on a sequence and then call some eager method and actually start processing it, I want memoization to happen automatically for the intermediate stages in case anything needs to be reused within the bounds of that computation. But for a particular sequence that someone actually holds a reference to, I don't want it to be memoized unless they explicitly ask for it, because I'm worried about space leaks. Does that make sense?
It certainly requires taking more care with your variable and method names. Also not having 100 line methods.
Upgrade was never included. And no, it should not. If it was, you would not support the company anyway - because you would not need to buy anything from them anyway. So why should they support you when you do not support them?
Just pirate the damn thing, nobody gives a shit anyway if you live in a third world country. 
Try Linux.
It does normal code completion like any other Java API. There will not be special support for things like DI or SQL code completion
Use a college email for the free student subscription :) 
Are you mental? A decent java developer can pay for the license with 1-3 hours of work.
Move away from JEE then and go full on Spring (Boot) more fun any way
Is anyone else bewildered by that claim that $50 is a big amount? Like, for most of it oriented companies it's a quite negligible amount. 
Worth every penny. CE is really sufficient for most things though.
NetBeans is not that bad indeed E lipse and SWT are dead.
What's so great about IntelliJ compared to Eclipse? I've used both and have barely noticed the difference really, just details. Is it that big of a deal? Perhaps I'm missing something
&gt; Try Linux. Man, get real. This is the single most infuriating thing to be told. I run Linux everywhere I can. But some places insist on Windows, for the VPN, Outlook, whatever. Sometimes, you can't run Linux. Also properly tuned Windows can be quite all right on a daily basis. 
Pretty sure something you're saying is literally important to your livelihood, e.g. your ability to continue making money, is way more important than nice-to-have luxuries. If this is something you really think you need to do your job properly, sounds like you may need to take a second look at your priorities.
Maybe it is your CPU that is downclock ? Are u on Windows, if yes, then it's the probably the case by default, you should check Windows control panel.
Dunno, Eclipse is not slow at all for me. In fact, IntelliJ feels heavier nowadays.
Then use one of the free ones and stop complaining about how much worse they are.
There's also a monthly subscription model and once you have 12 consecutive months of this sub, you get a permanent license for the version which was available 12 months ago. So if you were to sub right now and keep paying til october 2019, you'd get to keep 2018.2 forever. 
To make Eclipse faster: - Using new Java versions might help. You can always configure Maven and your projects to use other JDK's and JRE's. - Disable some of the code recommenders. I'm pretty sure you don't need the one for SWT... - Disable validators, or set them to manual mode. - Remove decorators you can live without. - Be really strategic when editing certain config files. Saving a `web.xml` file usually hangs the event handler thread... Switching to IntelliJ should be considered carefully. - If the workflow of your project is specific to Eclipse or doesn't use a tool like Maven or Gradle, you'll hit big issues. - If you hit bugs or shortcomings of IntelliJ, your colleagues might not be able to help. - Setting up IntelliJ and getting used to it will occupy some of your schedule. Your manager might or might not be fine with that. Definitely don't do it close to deadlines or similar busy times. - Depending on your industry and the paranoia level of your company's sysadmins, you might have to justify installing IntelliJ.
It's a valid suggestion, sure its not for everyone, but might help some. &gt; quite all right All right is not ideal, when your work flow is interrupted because Eclipse decides to hang for a second because you want to do some operation then it's both frustrating and time wasting, even just that second. Especially if it's a regular operation.
You've something broken. I'm using Eclipse all the time. Switching windows and tabs is instant. On win7 and above where aero is always drawing windows to buffers, there's no window "redrawing" as such. Yes sometimes it lags, like after a whole week without a reset when I've around 30 file tabs opened and gc kicks in. I admit it isn't perfect and it's good to reset it sometimes. Wish java ides worked like good old native borland ides..
Find a mentor in the company, if they don't provide you with one. This will be invaluable, of course it helps if you provide value to your mentor. I would look to someone they hired somewhat recently before you, as they will most likely relate to being new and more willing and knowledgeable to what is necessary for someone who is very green onboarding.
LOL, They can't participate in paing for your personal license but... you can always ask for a raise. Let's say... €14.90 per month raise :)
Netbeans is ass
I know this isn't what you're asking but I highly recommend taking a look at VS Code. Intellij is great but has some profoundly annoying problems (constant re-indexing among them). 
It looks like there is a plug-in for CE called "smart tomcat"
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
It is, but "object is owned by org it belongs to" is an authentication concept, whereas a capability is primarily about authorization. What you would do is hand back a capability which has a killswitch attached to the user's membership in that org -- if the user leaves the org, that triggers a callback which revokes the capability and renders it inoperable. This prevents "time of check/time of use" attacks, where the capability is handed out but then the authorization is revoked. Same principle as in real life -- when someone leaves, you ask them for the keys back and change passwords etc. I wrote a [guide on this](https://wsargent.github.io/ocaps/guide/index.html) that explains capabilities in more depth.
That moment when universities cant even explain java so they need to do something online lel
Netbeans is the best when you are working with JavaFX
`param = Objects.requireNonNull(param);` is an established pattern in the Java standard library. I don't really understand where the dogma not to modify parameters comes from.
/u/jbgi, take this, for example: static &lt;T extends Comparable&lt;? super T&gt;&gt; Sequence&lt;T&gt; sort(Sequence&lt;T&gt; sequence) { return Sequence.lazy( () -&gt; sequence.match( (head, tail) -&gt; concatenate( sort(tail.filter(lessThan(head))), cons(head, sort(tail.filter(greaterThanOrEqualTo(head)))) ), Sequence.empty() ) ); } An eager version of that would definitely be O(n log n) on average. But if `Sequence.lazy()` were implemented like this: static &lt;T&gt; Sequence&lt;T&gt; lazy(Supplier&lt;Sequence&lt;T&gt;&gt; sequence) { return new Sequence.Proxy&lt;&gt;() { @Override protected Sequence&lt;T&gt; principal() { return sequence.get(); } }; } Then that lazy `sort()` would be horrible, because it would keep doing the same work over and over. But because `Sequence.lazy()` instead reevaluates _and_ memoizes the principal sequence each time, the lazy `sort()` does indeed run in O(n log n) on average. My testing verifies this. What I didn't want to do in `Sequence.lazy()` was evaluate the principle sequence once, memoize it, and hold on to it. Because that would produce a lot more space leaks. Like, in this situation: var sequence = sort(Sequence.from(someCollection)); var x = sequence.element(5); var y = sequence.element(10); I don't want `sequence` to be automatically memoized there. Each call to `Sequence.element()` should force the sort to happen again. I don't want the sort itself to have to redo work, but I do want the user to be able to choose whether or not they want `sequence` memoized there. If they want to trade space for time, they can explicitly ask for it: var sequence = sort(Sequence.from(someCollection)).memoize(); var x = sequence.element(5); var y = sequence.element(10); And then the sort only happens once. Because sequences are lazy, it's very easy to pass around enormously long sequences, or even infinite sequences. Automatically memoizing everything would just end up being a huge foot gun.
What features exactly are so important on the ultimate edition for EE development ? 
&gt;If your company won't invest in tools for you to be productive, it's time to find a new company. BRB gotta tell my employer that I gotta find a different job due to a lack of IntelliJ.
That very much depends on where you are.
Do you still have the 75% discount? Really cool promotion, though.
I use vscode with their Java extension pack. It works great for me.
&gt;I need to upgrade my PC buy a videoprojector etc No, you don't *need* those things.
netbeans is great for java dev. WAY better than eclipse.
small or not, not granting you the tools for you the to do the job is just... wow...
You should also try tweaking the amount of memory you're giving Eclipse. You can find tutorials all over.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
http://xidea.online/
I like Java because of JVM.
The rich and diverse ecosystem of tools, libraries, documentation, training, conferences, etc. The wide choice of interesting projects done in it, and companies you can work for. The language itself is ok, I neither love nor hate it, but what you can do with it is great. 
I like that it runs on everything.
The scanner class. Just about perfection for parsing input, in my opinion!
Job opportunities.
I get paid for it. 
I like how explicit and strongly typed the language is, that most features are quite well thought, the overall performance, how it mixes declarative and functional programming, the huge amount of high-quality libraries, the static analyser and profiling tools, the annotation system, how simple you import classes, packages and modules isolation, the project management tools, the IDEs...
I don't like the language (coming from Python and C#). But I'm using it because of the ecosystem (devs and libs). It's by far the most used language for web- and business-apps. Wait, I actually like Lombok! For personal and fun stuff I've started using Kotlin, which is in my opinion the very best language out there.
The price for the annual subscription is only $150: https://www.jetbrains.com/idea/buy/
I used to love eclipse and thought it was the best thing ever.. I guess around 2005 or so
They are making some solid additions to the language lately! It's definitely headed in a positive direction.
Simple syntax, simple feature set, not over-engineered, the OpenJDK process.
I like that it has no breaking changes. That might change now however, but still.
Great opportunities for the development of the language, extremely versatile, an extremely helpful community and not to mention, highly developed frameworks like spring 
I like having the control and object oriented features without going super low-level.
Why Java/C# are always treated as an enterprise language? I mean can't you use them to create simple/lightweight stuff yet it will be fine?
Java is a general purpose language and I do lots of my stuff with it, even "simple" stuff but denying it is the default language for many huge enterprises and that they influence the language is a sin. &amp;#x200B; Just today I wrote some nasty code to scrape some websites and write the data down into a database. Took me like 5 minutes and I did it in Java when generally these "simple" issues are often left for "scripting" languages.
I like that it's a very 'pure' OO language and, via the JVM, generally successful in it's 'write once, run anywhere' philosophy. Unlike some others I do not see its verbosity as a strength however; Kotlin is the way to go on the JVM now.
New GC in the new java! 
1\. Lots of jobs with it. 2\. Before Java 8 it was straightforward to read, unless you really went out of your way to write obscure code. 3\. Most the valid complaints about the language are still minor to work around. getter/setter stuff is annoying but it's just straightforward extra time it's not stressful. 4\. No language is really offering significant improvements. They offer hype, then 2 years later they fall out of favor and another new language offers more hype, etc. Java stays pretty much the same which is nice. 5\. Compared to C/C++ java is way better at letting me focus on solving the problem rather than solving computer issues. Garbage collection and no manual memory management is fantastic. I really prefer static typing over dynamic typing because no one documents anything except static typing forces you to document all the types. 
&gt; aioobe What the fuck is that meant to be? Code is read more than it's written. Make it clear what your variables are. 
On everything that have a JVM
I shit on Java every chance I get. But tbh I like compiler feedback if I fuck something up. Java might be verbose and ugly. But it's still good. And pays the bills
That just says RHEL 7.6 will get OpenJDK 11. They don't say anything about long term support for it. OpenJDK 11 is no different from 10 or 12 or anything else. Only Oracle treats OracleJDK 11 as a long term release and will backport fixes etc. to it. Red Hat would need to do that same work for OpenJDK 11, but so far I have not seen them promise to do that.
 &gt; There will be no support for cross compilation. For example, in order to create Windows packages one must run the tool on Windows. It is still mind-boggling to me that anyone would find this limitation acceptable. Do I really need to keep 3 development machines just to get installer packages?! 
Oh boy, you're talking about C# for sure :0
This is nonsense. I did a JEE project before I had my Ultimate license and it works just fine. 
The community is what I like most. Ages ago it fully embraced the open source mindset and now, more than two decades later, we have a very strong ecosystem of mature high quality libraries and frameworks. 12 years ago or so when I did both C# and Java at the same time, even though I preferred C# as a language I always gravitated towards Java because it was so easy to find 'stuff' to do work for you. No mucking about writing your own CSV parser; just use a great Apache Commons one for example. 
&gt; how it mixes declarative and functional programming Pick one. You don’t get to have a closure as semantic sugar and call it “functional programming.” 
Do you really believe Jetbrains has to 'scam' anyone? It recently went over a 50% market share (something like 40% eclipse, 10% netbeans) and it's only growing. They barely need to do marketing; Java devs themselves are doing it. 
IDEs should not make a language. If one has to create a project by selecting from a drop-down menu, the language is over-complicated. Visual Studio and IntelliJ being the necessity for development of each, suggests that C# and Java are more similar than people think, and arguments between which is better are relegated to fan-boy mentallity.
I normally have a schema.sql and data.sql in the test/resources dir. Some frameworks pick this up automatically (Spring Data JPA IIRC), but you can easily do it yourself too. 
Even the talks that were given were often unspecific, especially on how openjdk would fare. And those talks are to a limited audience anyway. There's a reason why everyone wrote about the new release model, including that java champion document (and myself). Oracle could have prevented all this mess with a single official post with the same information a year ago.
I would say, after JAva 8 it is more easy to read. It is harder to write untill you become used to it :)
Strong typed, the vast majority of library is well documented, good tooling, great IDEs, easy debugging, JVM let's you interoperate with other JVM based languages
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
strongly typed, standard lib is rich the synatx is not complicated (unlike c++) if you care about your coding style then it's easy to write a code what outher ppl can easily read javadocs &lt;-- for your own code and for standard lib too just makes life sooo much easyer, thats what i really miss from c++
No? I just ran TomEE in my IDE?
JIT
Huge job market. Eco system. Decent salaries.
It's also important to state that after your subscription has expired, you get to keep the software at the last version available when you had your subscription active.
I like they syntax. Before Java8 especially, you could just see everything, now with lambdas it relies more heavily on you knowing what it does without being able to see it, but it's brought some useful additions. Most of all I like the enterprise frameworks, Spring and Java EE (sorry, I meant, place in Indonesia starting with a J, EE) Everyone knows a bit of Java, it's huge, there's libraries for everything, write once run everywhere. What else would we use without it? 
All I wanted to said has been said. In order not to duplicate any of the positives. I just came to say I like the pronunciation ‘Java’ easy, sweet and I can spell it!
We have the best IDE! (IntelliJ)
Types. Libraries/frameworks/APIs that are battle tested and won't go away in 3 months. Open source. (Well, ish. At least compared to its closest strongly typed competitor)
No pointers 
Pub/Sub is exactly the method I was thinking about. You could also make sure that any caching happens using something like Memcached/Redis rather than an in-process cache (or use pub/sub to invalidate it).
Sarcasm is sometimes hard to understand :S
People often don't understand the powerful combination of strong typing and great IDEs. Your classes become this logical language that the IDE can 'understand'. This allows extremely intelligent suggestions, analysis and refactorings that give you immense power. The result, done right, is code that does what it says, is easy to understand because of the verbosity, but still easy to modify - the cost of verbosity is completely negated, and it becomes an advantage.
I didn't like streams code until I started writing it; now I wouldn't be without. I didn't like it because I wasn't familiar with it.
Yeah, you have to pick your spots with it on the Internet because you can’t use tone to make it obvious. The “/s” can help too. Otherwise it can come off as a little trolly like it did this time. 
I came to say this. The IDE spotting errors as you make them and suggesting potential fixes is the kind of shit I would dream about back in the old mainframe days.
To be fully fair, I don't like the language. I came from learning C# *(****Learning****)* from a solid Javascript background and let me tell you something that might annoy most people here, Java is just so verbose and so...well, outdated from a Javascript/C#'s view. Javascript might be complete huge mess compared to Java but at least it isn't as verbose or outdated, I mean seriously, I got surprised that how the fuck it is almost 2019 and there is no sign of String interpolation which is a very common feature that got already made in most of languages, and more and more(like getters and setters, they are basically just normal methods that you will have to make yourself, there is no syntatic sugar no anything unlike C# and there are surely more and more like Linq that honestly feels like cheating when you use it) I know that Javascript is not fully OOP but C# is and it makes everything Java does much better. I only think of learning it because it is cross-platform(.NET Core is cross-platform too but it might take little more time for WPF to be that too) and because of the ecosystem(C#'s is smaller than Java's but after thinking, it might not matter because you will use like 20% or 10% of the whole ecosystem anyway) Let's be honest, Java is just popular because of historical reasons when it's obvious that languages like Groovy, Kotlin, C# are way much better. 
&gt; IntelliJ being the necessity for development I've been making a living developing in Java for years and have never even installed IntelliJ.
Oh come on on loosen up. You can perfectly well have an isolated piece of code in your solution which uses functional programming to solve a problem, where the rest of the solution is declarative 
Strongly typed, garbage collection, object oriented programming 
Try to do the services without state, and hold the state in a queue, like Kafka
First thing that comes to my mind is Apache ZooKeeper. It is a strongly consistent distributed storage, that is primarily built for coordination/ synchronization between various services in your infrastructure. 
&gt;What the fuck is that meant to be? Code is read more than it's written. Make it clear what your variables are. The funny thing is, if you change "variables" with "types" the same thing could be said for var. 
Stability.
Hold on, why did y'all downvote this, actually? Isn't that just.... accurate?
As a library vendor, I mostly value the forwards and backwards compatibility of the language and APIs, and obviously, being a vendor, the size of the market. The runtime is really great. Its spec (just like the JLS) is very thorough and well done, which has allowed for competing implementations to innovate. Just think of the fact that a company like Twitter can "easily" replace hotspot by GraalVM, experiencing only a few minor hiccups. While the language is not as modern as others, the runtime has allowed other, more modern languages to interoperate with Java on top of the same runtime, helping Java to evaluate which features to integrate. So, from an ecosystem point of view, to put it in the words of [Tina Turner...](https://youtu.be/6UsFjXF0GJg)
Some Germans pronounce it as "iava"...
Huge library supported. Large community. Comprehensive docs. Explicit code. Even java is multiplatform
I prefer languages that are easy to read. Easy to write is a second priority. Java isn't the easiest to read, but it's one of the easiest to read, if you don't go crazy with inheritance, and a lot of people know it.
You probably mean the “combination of *static* typing and great IDEs”. While Java is still strongly typed, it’s the static typing that makes it work so well with IDEs. Static typing means that types are checked at compile time. Strong typing means that types cannot be subverted at runtime (unlike in C++ for example with reinterpret cast).
Short answer for me: you don't. In a distributed architecture, the goal is eventual consistency typically over a pub/Sub model as others have mentioned.
But why is that?
I guess it's sort of implied so it's downvoted? I agree with him, but yeah if your language doesn't compile for TempleOS explicitly it won't run there either. JVM supports just about everything, and certainly everything you'd need. I'd love to hear a system JVM doesn't run on which is actually a surprise. 
Do you honestly think $50/month is a lot to ask for the proper tools to do your job?
Didnt do that, didnt say that
Hot code replace is my #1 feature. Adjust running code practically on the fly, no compilation, no linking step. Just a debug link where IDE sends the updated class file over and it immediately gets invoked the next time that class's methods get invoked.
IMO JetBrains definitely need some anti-greed pills :))
I suggest etcd which is much easier to use and is more modern 
Lambdas are often overused resulting in hard to read and impossible to properly test code. If you lambda is more than a few lines, break that shit up.
I think we both mean *iterative* and not declarative. Either way, it’s not correct. Functional programming requires immutability from the top down, and this is never achievable in Java (nor is it achievable in languages like Javascript and others that claim they are “functional”, contrary to popular opinion). This is a very important core aspect of a functional language, else all you have is some hint at a functional style, which is really nothing more than syntactical sugar.
One of the stated goals by Mark Reinhold is that Java has a simple and consistent mental model, so that new features are easy to understand by existing developers. This is one of the reasons that new features take a long time to add, if they get added at all, because they want to get them right.
I would suggest avoiding lambda blocks altogether, using named lambdas or method references. This has the added advantage that the added name increases readability.
Buffered reader is better in some situations
For me it's nostalgia. Java is the first programming language I ever learned back when I was a kid
underrated answer
I like how each command is intuitive. Unlike other programs where the commands can be quite obscure.
There's two basic options: offload to client or offload to data store. The client can hold on to a cookie or JWT with some state data although transport is expensive so only for small amounts of key data. Otherwise, you may just use your JWT to store a token that points to a DB or persistent cache that contains the state info for that user. Something like redis or any SQL DB is purpose-built to synchronize data across a cluster. Any pub/sub system is just an abstraction on top of a database anyway.
IntelliJ is dirt cheap. Developer hours are super expensive. No organization with more than 3 Java devs should bat an eye at investing in an enterprise license.
Nice.
PHP and JavaScript come to mind 😉
Definetly. How else do you want to UnitTest it.
I like the jar/war packaging. Makes it easy to have a completely self contained package.
Libraries and tools. I've switched from a Java job to a C++ job and every day I'm amazed how crappy it is in some areas (e.g. packaging and deployment - with Maven it's mostly a breeze. In C++ world you have a dozen of tools, none of which is considered an industry standard so you have to do stupid things like copy all DLLs next to your .exe on Windows etc.). Also all the automated refactoring any decent Java IDE (Eclipse, IntelliJ, ...) can do out of the box is much more than e.g. a CLion can do. &amp;#x200B;
You should definitely give it a try, it's pretty nice.
It's not free tho'.
dude, there's been plenty of talks discussing this posted to youtube. it was not a limited audience at all.
there are no edge-cases with openjdk builds that you can hit that you wouldn't hit with oraclejdk
Dont have an alternative to what you/people have already proposed (i.e using eventual consistency for state propagation via either a common datastore or a message broker) but i would be curious to know how do I even prepare for such interviews if you haven't created such systems before? Appreciate your input.
Is eclipse the "standard"? Or do people pimp out vim or something?
Surprised they don't call it Kava.
I really love that i get paid to use it and then i can use that money on goods and services
It's not about the cost.
Not everyone watches those talks. I did, maybe you did, but certainly not everyone. There was also talk on the mailing lists, but again, nothing you can really reference. The community had to step up and make the actual written blog posts on the topic because oracle failed to do so.
Any operating system that isn’t Windows, macOS, Linux, or OpenBSD doesn’t have very good OpenJDK support. Game consoles, etc. are pretty mich off limits.
no. They just Google it or copy the basic html that was already written before they got on the project. html is really, really easy. Css is the hard part. 
It's actually in the freaking name. 
Not to mention embedded
Best answer here has all the downvotes :(
Who are you trying to convince, you or me? I don't support their model. I'm not paying to use their software. It's an option we all have. If you don't like it, that's fine, but it's still an option nonetheless 😊
Except that kafka is async which means it is eventually consistent. it's also very easy to misconfigure and lose data or play events multiple times. It can be a great tool but it has many tradeoffs you need to understand as well.
or just use an ACID compliant database?
Either don't actually have this. I'm talking about something like running a simulation in a window, and you change some physics rule and the objects going around respond to the change you just made. There is no reload of the application, no state was lost. The old equations just got swapped out and replaced with new ones because the class that implemented them changed. I know that Webpack can supposedly do something like that for JavaScript but I've not once had hot module reloading working for me yet. It's always just refresh page or stuff like that.
The problem with that answer is that microservices typically each run on top of their own dedicated database; it's considered an antipattern to share a database between services. So you end up with several services each doing their own thing in their own ACID compliant database, but still isolated from each other. Business goals usually require multiple microservices to cooperate towards a common end, and so the meat of the question is, how do you ensure that some desired sequence of events indeed occurs in multiple services (either right away, or sometime in the future), and if you decide that things happening sometime in the future is OK, how do you then deal with some other program concurrently querying these services and potentially discovering the partially applied updates, which makes the system state as a whole look inconsistent. A monolithic service, of course, can be written against a single database using some high isolation level like serializable, so you can guarantee that all updates will have been committed before any other transaction can see or make use of those values that did get updated.
Naw, I've been working with it for 6 months, it's still a pile of obscure mystical symbols. 
There's nothing unclear about `catch (ArrayIndexOutOfBoundsException aioobe)`! And `BufferedReader br` is certainly not less clear than `BufferedReader reader`. Code and comments should be written for people who know Java, not the general public.
That's because you're writing new new code with it. Trying to read some else's code it's pretty bad to try to read.
Yeah, all of our lambdas/streams/completable futures are all inline and often take up a screen or two of code. It's a mess to try to read.
Be explicit! Except with types. Then use `var`!
Nothing about a system of microservices neccessitates pub/sub. Nothing also neccessitates that any particular one needs the current state. What does "has the current state" even mean? I can make a totally synchronous call through 15 services and nothing holds onto the state other than the contents of the thread stack in each service. Does information being on the stack count as state? How would pub/sub even change this. No state is still actually being stored neccesarily, could still just be sitting in various stacks at any given time.
It looks like in your [submission](https://www.reddit.com/r/java/comments/9s62fd/announcing_the_official_public_release_of/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
What are your favorite Java surprises?
Article doesn't once mention Java. Belongs in /r/programming.
/r/Wellthatsucks 
I learnt the other day that you can start variables with a dollar sign.
I wonder how many bugs does it take. I reported like 20, many critical (and some still not fixed, mainly in Scala), yet not even stupid stickers :/. Also their approach is very often very lazy. They let bugs rot for months and then, when I get pissed and complain on Twitter, suddenly in matter of hours or a day someone comes to at least test and confirm it (not fix it, that would be too great).
It amazes me sometimes that IBM is still around, or has this much money. This is a lot better than the speculated Microsoft-RedHat deal, though.
None of the coverage and press releases I've read so far mention Java. I wish they did. Both companies have made big investments in Java tech over the years, so I wonder if together they might become a strong counterweight to Oracle.
perhaps ibm's openj9 will become available in redhat and fedora's repos by default alongside openjdk
Hey Daniel, there a couple times when you use "empathise" (or some variation) when you mean "emphasis." Nice write up though. 
If more than one service depends on some state, then create a new service encapsulating that state, and access its state exclusively through the public API of this new service. In microservice architecture, every piece of state is owed by exactly one service.
Maybe this is to make a move in the cloud computing space.
Written a command line multi project source merging across multiple projects at once. Then wrote a release tool to use the same system and do builds from source (this way no accidental release of admin or custom development tools). Also written several of my own custom IDE's (and have done so since the Amiga).
Not sure how I feel about this yet. Always seemed Red Hat was the anti Big Blue in some ways.
There's a bunch of overlap though. IBM has invested massively in their new Open Liberty server, while Red Hat obviously has JBoss (which is also marketed as WildFly). Eventually one of those has to go. Might be a year, might be two years, might be three, but I've never seen any company either big or small that maintains two individually fully overlapping products.
I wonder what impact this acquisition will have on JBoss vs Websphere – Application servers and other projects.
&gt; It's just important that even those who deploy only on LTS versions still develop and test with all feature releases. A major reason why many people deploy on LTS is that they don't have the resources to keep up with fast release cycles. If they could do that, then there would be no reason to deploy on LTS.
&gt; Double braces initialization of collections Never, **ever**, use this. It creates an anonymous subclass, and since all internal classes keep a reference to the parent instance it can and will fuck with garbage collection if these collection objects are referenced by more objects than just the declaring one. Use the convenience methods `List.of`, `Set.of`, and `Map.of` introduced in Java 9 instead. They're also faster and more efficient than the double-brace initializer.
I merely pointed out your hypocrisy.
That's the big question. We all know that eventually after an acquisition the competing product ALWAYS goes. Oracle said it wouldn't drop Solaris, GlassFish, MySQL, NetBeans, but they all have been dropped. My gut feeling says bye bye JBoss, although that seems hard to believe now giving that it's the most popular full Java EE server (Tomcat is more popular than JBoss, but it's in a different category).
Thanks for the insight! I will update the article to warn others :)
Java has constantly made breaking changes between major versions. I had to facilitate updated to codebases between 6 to 7 and 7 to 8. This is generally very true but not completely
Solaris and mainframes even have JVMs. Consoles not supporting it isn't terribly surprising; video games haven't historically been Java based. That's definitely a sore spot for it though. 
Or OpenJDK developers at Red Hat. 
It's not a single license, they would buy it for everyone or none 
&gt; If one has to create a project by selecting from a drop-down menu, the language is over-complicated. gradle init --type java-application
It's pretty worrying for competition/options in Jakarta EE. There's also OpenJ9 vs Red Hat's OpenJDK spins. The official line is that Red Hat remains independent, but I don't doubt the landscape will be markedly different this time next year. 
Ah, many thanks for pointing this out. This is probably muscle memory from writing a lot about empathy of late :-) I've made the fixes now
Both companies already have cloud offerings though: IBM Cloud and RedShift
Not quite accurate. The updates to JDK 11 will not be (AFAIK) like the semi-annual update releases to the major JDK versions, which no longer exist but used to occasionally contain major features (not affecting the spec). OpenJDK and Oracle JDK will continue to be functionally equivalent, and Oracle will provide its support customers with backports to security and major bug fixes but, again AFAIK, no new features like the update releases under the old model.
Agreed. The press release mostly talks about Cloud software, but there is so much more overlap in both companies products. AIX vs RHEL comes to mind, too. 
IBM are slow and I fear stagnation.
One recent change, though underscore is still valid in identifiers it is no longer legal to use just an underscore as the identifier. Java 8 this was legal: Object _ = new SomeObject(); 
Correct. They are planning to use the underscore in pattern matching. It was disallowed starting in 9.
I've been through several mergers. Initially there's the shock of most staff who had no idea this was happening. Then the disbelief that the former competitors, department by department are now co-workers. After that comes the realisation that you're now doing duplicate work. Maintaining two transaction engines, maintaining two certification servers, maintaining two... For the first couple of months little will change as things still have to be actually merged and some contracts still may have to be signed, but it's nagging in the back of your head. Then the uncertainty starts setting in. I'm working on the TX engine, I know it's better, but will it continue? Some of your co-workers are annoyingly relaxed, since they happen to be working on a project for which there is no duplicate one. But your managers assures you: nothing is going to happen to your product. Meanwhile seniors start to leave. You stil say to yourself: seniors leave all the time. And while that's true, it are remarkably many. Some six months small mutinies break out, as people want to know where they're standing. But little happens. More people leave. A year later there's the command from 'their' HQ: we're going to migrate to their platform. But don't worry, their platform is much better and X, Y, Z that we have been struggling with has already been done by them. The next year and a half after that you write what must be the most boring code on earth. Tons of "connectors" to temporarily bridge functionality from your platform to that the other one. It's all very brittle since the APIs you have to use are all internal and not documented and full of flaws. You therefor visit their HQ to talk to their devs directly about some bridge component. The first thing you notice is the atmosphere of victory. Yes, they are the victors and you are the losers. Your product will be dismantled, theirs will continue. You also see a number of HR and marketing people from your original company. They are all very eager to migrate customer data. They are sitting behind HQ's systems, learning the new tools, making nice looking plans for how to contact the customers, keep schedules and overview of how many have been migrated, how many still have to be migrated. Another nice job comes in for you. Your company is using product X to store customer data, they are using product Y. Please write an export tool, oh and for the first year it has to be bi-directional keeping X and Y in sync until all customers are migrated. So for a year long you're working an another brittle migration connection, this time between two web APIs. Of course, they upgrade their systems at will, since for them it's just business as usual, and that includes updating systems. Every time the connector breaks though and someone is angry at you. After approximately 3 years, most everything has been migrated. The HR and marketing staff that had been most eager to help during the migration are kindly let go. The astonishment and sheer disbelief on their faces is disheartening, but at least you can stay since you still have to do maintenance on the now legacy project (even though it's still technically ahead, even after not having directly worked on it for nearly three years). Instead of working on exciting new features, the next year you only work to fix the occasional bug requested by the most conservative customers. You see your co-workers dropping out one by one. Some are transferred to HQ to work on the victorious project, but many aren't. Eventually the last active customer migrates or leaves to use another vendor, and your project is going into special legacy maintenance mode. It's still there, but deep within the bowels of HQ on some server, in some almost hidden hallway, somewhere in an obscure closet. The budget is about 16 hours per year, just to do some CVE scanning. Eventually, that too stops, and most everything from the original company is just gone. 
Are Payara and Tomitribe the winners of this operation?
I have. It's better than trying to understand the equivalent iterative code. 
corporations with legacy mainframes are willing to pay a lot of money to keep the "if it ain't broke don't fix it" mentality. plus cobol developers are hard to find.
I'm not sure that's quite what Mark had in mind for Bug #1.
Tell us more about HR people getting sacked.
Plz no.
Well...fuck.
Having spent the last 6 months on both, I completely disagree.
Why IntelliJ over Eclipse? New to Java 
And then your code is inconsistent and hard to read. GG.
Depends on where you work, especially in emerging markets
I heard they're running COBOL in VMs or something similar that's a bit closer to metal. Is that true?
They should deprecate AccessibleObject::setAccessible. So awful since it messes with JVM optimization.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
well fuck
My recent surprise: Single class can contain multiple `static { ... }` initializer blocks
Checked exception
You mean free software like emacs?
Because Intellij IDEA is simply awesome. It can look Visual Studio in the eye and not blink. Perhaps Eclipse had improved since I last tried it but there was simply no comparison a few years ago.
Does `thousand` get unboxed or does `t` get boxed? `b` will be true if it's the former and false if it's the latter. But both will be true if you did the same thing with 100. There's also a system property you can use to make 1000 true.
Here, have an upvote. We need stories like this to be told too. 
It basically creates an anonymous inner class with an initialiser block. If that gets returned to somewhere external you are leaking the class where the object was created. That means the class creating the insurance can't be GCed and (in some cases) can prevent efficient serialisation. All this, for what basically amounts to a 10% throughout reduction because you are forcing the class loader to do extra work to get your code to JIT compile. This can also do things like badly affect inlining if you aren't careful as well. Source: https://blog.jooq.org/2014/12/08/dont-be-clever-the-double-curly-braces-anti-pattern/. There's also a SonarQube rule for it if you use that. I highly suggest you enable it.
A couple of examples, please, course it's related not only to double braces initialization but for any anonymous non static class object creation.
The link now shows a 404.
You can return from finally like this: ``` try { return 1/0; } finally { return 5; } ``` will catch exception "somehow" and return 5. :D 
MySQL and Oracle are not fully overlapping. Have you seen a wordpress on Oracle? 
Have you tried the community edition?
Do I have to install IntelliJ if I want to build it myself? And not a single test in the project?
&gt;**Edit:** According to JLS 5.6.2 unboxing happens. That is `int` comparison happens. That's kind of what I thought, but thanks for the confirmation! 
Remains to be seen. Possibly, but at this point hard to tell. At least one of the Payara guys on twitter doesn't seem to be overly happy about this. I too fear that there will be less competition now, and less competition means less innovation. 
I hear you, but Liberty really is not that bad. Actually, it's quite good. Don't start about the Rational and WebSphere products though, as they were horrible indeed.
I see. The last time I was working with server logic where that is useful, it didn't work too well on active state, so page refreshes were still needed. Or, perhaps, our state was needlessly complex. Great that it works for you!
True, Oracle costs money. That must be the reason they keep MySql.
No, you can build it with other IDEs as well, it should work with netbeans, eclipse, etc 
I don't know if I've understood your question completely. Yes you're right each microservice should have their own database. &amp;#x200B; If the states and actions need to be done in the transactional flow. Then http request would be required among all the microservices. But one day it will create a mess. &amp;#x200B; So here we can use some queuing system(pub/sub) .e.g kafka. Every micro service will be pushing the event done against a requestId in the queue. And each individual listener will be doing the next action. &amp;#x200B; Kafka is better when you've to store/log something or you've to replay the traffic again. For background activities(not transactional) you can use kafka.
https://stackoverflow.com/questions/13098143/why-does-the-behavior-of-the-integer-constant-pool-change-at-127
Thank you, really helpful. I will work on these asap 🙂
Then buy it yourself? Honestly, if I would be forbidden to use my favourite IDE, I would be seriously considering quitting. I value my sanity and it's not like there is overflow of developers where I live - not that hard to find a new job. Companies are so desperate they are hiring future potential developers while they still study.
I basically meant what dpash has already said. Sorry for not being clear. Use build tool like Maven or Gradle. And write some tests. Are you familiar with testing frameworks in Java?
Unfortunately not yet, and I haven't even realized that they are this important, but next thing to do with my project to write the tests. 
so, if you want to not pay for java, do not use oracle jdk 11. it is free only for development purposes. openjdk is functionally identical to oraclejdk, but is gplv2 + cpe, meaning you can use it for free and without making your code/game gplv2 as long as you are not modifying the JVM to make your game. the difference between the openjdk and oraclejdk in java 11 is that oracle jdk has support from oracle (as in, you can contact them for bugfixes, help on your project, etc). if that's not important to you, then openjdk is fine.
Yeah, it's what I assumed too, but had to check just to make sure. If I wasn't on my phone I would have whipped out `jshell`, but a reading of the JLS is always fun. :)
I think things could get rocky too, in the 12-24 month timeframe. Think of MicroProfile and how the main contributors (in terms of numbers of people) are Red Hat and IBM. Now, rather than 2 big players, there is just one. Will the same amount of effort be invested? Perhaps for Jakarta EE there will be someone like Fujitsu to step up with the resources to drive it forward as well, but fewer choices for vendors is going to be damaging. 
Mohamed Ali still alive, a very old commerical.
From what I understand, they get merged into a single hidden static method called `&lt;cinit&gt;`, along with any non-constant RHS for static members, in the order that they're defined in the source. There's also a `&lt;init&gt;` method that's run before constructors for doing the non-static stuff.
IBM offers commercial support for OpenJ9, though (they're the only company doing so).
There is no "vanilla OpenJDK." There's OpenJDK and a JDK that combines the OpenJ9 JVM with some of OpenJDK sources (most of the class libraries and tooling).
I think you and I have worked at the same companies.
I remove all shortcuts from both the user's and the public desktop that were pointing to targets that either did no longer exist or where the user has no access to.
Order is on a partition level not a topic level so you cannot assume messages are processed in order for a given topic. Which means your code has to handle events coming out of order even if you use exactly once message delivery. Or you could use a single partition but then you are limited to a single consumer.
For game dev, switch to OpenJDK (11) and use jlink to build your own stripped down distribution of the JRE, bundled with your game. This is the way to go now. It's free, legally save, and convenient for your users, as they do not have to install java anymore.
Ideally you should start with the tests. :)
I'm glad I posted my project here, I'm just learning Java by myself and never really had the chance to talk to experienced people and get advices. Thank you so much!
&gt; Or has this much money They supposedly acquired Red Hat for $34 million. That is literally nothing for IBM or any large tech company. IBM has a marketcap of 114 **billion**
&gt; So you end up with several services each doing their own thing in their own ACID compliant database, but still isolated from each other. If your services are decoupled then problem solved. If not you can still use techniques such as two-phase commits across services each using their own data stores. &gt; and if you decide that things happening sometime in the future is OK, how do you then deal with some other program concurrently querying these services and potentially discovering the partially applied updates, which makes the system state as a whole look inconsistent. This problem exists regardless of using a pub/sub system or any form of an eventually consistent process even if it's backed by ACID databases. If lots of your actions require writing to many services transactionally maybe the teams prematurely split their systems into microservices because its the cool thing to do. Businesses goals should rarely influence your architecture unless it's related to scale or SLAs. &gt; A monolithic service, of course, can be written against a single database using some high isolation level like serializable, so you can guarantee that all updates will have been committed before any other transaction can see or make use of those values that did get updated. Read committed which is the default of pretty much every SQL database guarantees that other connections of the same isolation level will not see any updates until they are committed. You do not need a higher level isolation level.
You might find /r/learnjava useful too for getting advice. This sub is more for news and technical discussion than learning. 
It cost them 34 *b*illion. I'm not sure if that was a typo or not, but 1/3rd of a company's marketcap is nothing to scoff at.
&gt; OpenJDK and Oracle JDK will continue to be functionally equivalent There are no guarantees of that after 6 months since both will be independently developed and hence will have divergent codebases.
The answer for any question regarding Java licensing is always "OpenJDK". Oracle's OpenJDK builds are functionally identical to the Oracle JDK.
Of course
It looks like in your [submission](https://www.reddit.com/r/java/comments/9sd1ah/possiblyweird_question_locating_multiple_calls_to/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
We're not doing your homework for you.
&gt;Now, rather than 2 big players, there is just one. That's a main concern for sure. In the very least on the short term you can expect Red Hat and IBM taking each other's sides when controversial things are being discussed. I'm not so sure about Fujitsu. They should have the resources, but they largely keep to themselves. Haven't seen much from them in terms of contributions to either discussions or PRs. 
Nevermind I read it wrong, I thought it said million
/r/talesfromthedevelopercubicle should be a thing.
I’m scared...
Its multy function i can do desktop app in it 
2^31-1 is a Mersenne prime, the last one proved prime by trial division, by Euler in 1772.
I recently discovered that you can not only `break;` out of loops and `switch` statements, but also out of curly-bracket-blocks, if-blocks and even try-blocks. public static void main(String[] args) { test: { System.out.println("Hello"); if(true) { break test; // works } System.out.println("World"); } } public static void main(String[] args) { test: if(true){ System.out.println("Hello"); if(true) { break test; // works } System.out.println("World"); } } public static void main(String[] args) { test: try{ System.out.println("Hello"); if(true) { break test; // works } System.out.println("World"); } finally { } }
The tests are important first obviously because this is how you check the correctness of your app. But also they provide you a protection against potentially dangerous changes in future. As your project gets bigger you won't be able to re-check all its functionality every time you add a new feature or fix a bug. How can you be sure that fixing one bug doesn't bring couple new? But when your tests cover most of your functionality, you have a guarantee that at least you haven't broken existing features. Tests should always be a part of the build. So that when they don't pass your build fails. Maven or other build tool will help you with this.
&gt;the constructor that takes a double defines the pixel width and not percentage width so if the layout resizes it will not work. You are right. h -&gt; { RowConstraints r = new RowConstraints(); r.setPercentHeight(h); return r; } or private static RowConstraints toRow(double h) { RowConstraints r = new RowConstraints(); r.setPercentHeight(h); return r; } // moar code... DoubleStream.of(20, 30, 40).mapObject(toRow).forEach(pane.getRowConstraints()::add) Like before, no ide, just memory.
if anything, at least WebSphere should die
r/java &gt; things of interest related to the Java programming language I've searched for 'Java' in the article, and the only thing that popped up was 'JavaScript'.
I’d argue it’s related enough to java to justify a post in here. *shrugs*
As Kotlin started out being a JVM language, okay. But I think by going its own way by supporting JavaScript, Native, and others, it becomes less and less related to Java itself.. I might be just gatekeeping here, but I think we need boundaries about what contents get posted to each subreddits. IMO this content is more appropriate for r/programming than here. And after all, if we don't have boundaries for content, then every sub just becomes a dump of slightly related content.
can i get a non-youtube video link to the api?
Not only should this go in /r/javahelp as it is help with Java programming, but also will you need to include *way* more detail. As it is now, this is a low effort, "do my homework" type post that is not allowed on any of the learning subreddits. **Removed**
&gt; I’d argue it’s related enough to java to justify a post in here Long time ago, this subreddit has settled on being Java exclusively. Not JVM languages, not Scala, not Kotlin, etc. Every time someone posts something about other JVM languages we moderators get reports.
They will not be "independently developed." I can't make any official statements (I work on OpenJDK at Oracle) and speak only for myself, and in any event, I have no idea what has been decided, but Oracle's [Java SE Subscription](https://www.oracle.com/java/java-se-subscription.html) page talks about "performance, stability, and security updates."
Also worth mentioning: the term "better", in the context of which software will be kept during a merger, is an extremely subjective and political term. It by no means implies that the winning software has more/better features, works better, is more stable, or is easier to maintain. 
Free only for development purposes? Could you share the source of that information?
https://www.oracle.com/technetwork/java/javase/terms/license/javase-license.html
Anyone got any input on which of these is most worth the time? I'll assume it depends on what I want to actually make obviousl,y but are any of them "The best Spring 2.0 book available" for whichever topic they cover?
That was... enlightening. Thanks!
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Np. Just use an openjdk build if you don’t wanna pay for support 
not sure about now but a lot of other Packt bundles got reviews of Packt having a very low bar for quality. No Starch Press, Pearson, ADdison-Wesley have typically much better (and sometimes free!) content
Not really. An O'Reilly Safari account includes them all anyway, and Packt gives away an ebook for free every day. The quality of the books themselves are more or less one person's overview of the documentation with narrow examples.
Yeah I suspected, I’ve been going through Head First - Java for the last few weeks and loving it, won’t bother with this bundle
Just got this error at my office today, is this resolved by using a different version of java?
So it lets you drop in asm routines in java? Or byte code routines?
bytecode routines. though generally you're using it to modify a class instead of writing in bytecode directly * write vanilla java code * compile with javac * run asm to transform the class file * run java using the modified class file the last 2 steps can be combined using a classloader. kilim uses it to save and restore the stack, allowing you to return from a computation in the middle, wait for some data that you need, and then restart the computation without blocking a thread (ie, green threads or continuations) so the woven bytecode looks very similar to the original javac bytecode 
IBM Websphere JBoss application server.
Can you describe any practical use for bytecode manipulation? I've thought about looking into ASM for a long time but don't know where to begin and what to target.
Its very useful for reverse engineering.
There are some libraries such as AspectJ that use it to good effect. You tell AspectJ which packages/methods to target and it lets you specify code to run before/after these methods execute. Useful for things such as recording execution time of individual methods without having to add heaps of boilerplate to every method you want to instrument.
Can you give me an example where you used reverse engineering?
I don't think the controller layer is the right place to check access to entities. If you place it in the controller you could end up implementing the same access check many times. Because you will have several endpoints that needs to access to an organization, user or whatever. It is easier to forget security, the more places you need to implement it. Instead create a service layer that accesses, modifies entities and create the access check in that layer. This is also what Spring encourages you to do. The service layer can be reused in multiple controllers, such that you have one place for access control, and users of that service automatically gets security.
People from jetbrains selling and spaming their ide, sure is pretty hot now but its not better tan eclipse with some plugins
i gave an example above: https://www.reddit.com/r/java/comments/9se1z4/asm_70_released_official_support_for_java_11/e8omfaw/
&gt;Packt The few packt books (not necessary java) I've read have mostly been terrible. Is that typical or I just read the wrong books?
Generally, I find those Packt books to be pretty lame. Just barely enough to say you wrote a book.
The eclipse IDE has a plugin called SWT Designer (based on WindowBuilder) that allows you to design GUI’s using a visual editor, while generating automatic code in the background: http://www.vogella.com/tutorials/EclipseWindowBuilder/article.html
Np
Deobfuscating is a very big one. For games that often update you can also automatically refactor parts of the code
For example : "How can I find all the methods that call a given method in Java?" : [https://stackoverflow.com/a/931410/41953](https://stackoverflow.com/a/931410/41953)
Ha, that's actually fucking brilliant!
&gt;EDIT: my d was too big GIGGITY!
Unlike Manning or O'Reilly, Packt seems to have far lower standards, duplicate content, and just poor books. I would never pay $50 for a Packt book on some new technology, whereas I've paid Manning or OReilly numerous times. That being said, I subscribed to the Packt library for a year once for about $100 while I was consulting and just needed minimal references for a lot of different technologies where Manning just doesn't cover - things like Alfresco and other CRMs. That being said, for a few dollars no harm in this. But if you really need to learn Spring or something, better to get the Manning version used on Amazon. 
The traditional Spring *bible* (Spring in Action) is from Manning version, or at least it was years ago. But I have no idea if there is a new one with Spring Boot coverage. 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
We do something similar. Running a Spring+Hibernate "integration" test takes about 5 seconds on my laptop. Creating a small Spring context takes about 50ms and the rest of the time is whatever the hell hibernate does to connect to the existing database. It's slower than unit tests without the database layer but I believe the extra confidence is worth it.
You are implementing your own logger I would suggest to use slf4j or log4j2. If you use the apis only people can decide which logging framework they are using. Also the logging implementations are much faster. 
Every other version than 8u191/192 seems to be fine. Or simply delete all "broken" shortcuts (*.lnk files) from the user and public desktop.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [IBM to Acquire Red Hat: A Java-Oriented First Look \[x-post from r\/java\]](https://www.reddit.com/r/programming/comments/9sloeh/ibm_to_acquire_red_hat_a_javaoriented_first_look/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
&gt; Is OpenJDK as good as Oracle's JDK? OpenJDK **is** Java. So yes. 
Yes, Programs written for Java 1 (released in 1995) will still run on JDK11 (released a month ago). (Well, almost, but you're not going to come across those instances in your code) 
Some libraries were removed from the sdk in jdk 11, so it might not be. I'd suggest using jdk 11 until you find something that does not work, then ask for advice on how to proceed. There are pretty simple solutions to most of the problems you will encounter.
You have 4 options. All 4 of these options are binaries built from the exact same source repository, so they are basically the same thing. The major differences is basically in the installer. [1] OracleJDK. These are long-term supported at LTS releases (currently, OracleJDK8 and OracleJDK11 are LTS releases). The other releases are only supported for ~6 months. This one costs money, but entitles you to some support. [2] OpenJDK. Built by oracle too, just, free. The only downside is that you get no support, and releases are only supported for 6 months, __even the LTS releases__. So, you have to upgrade continuously as java is updated or your JDK download is not 'maintained'. This means: Bug fixes, even security fixes, will not be forthcoming if you're not on the latest version anymore. [3] AdoptOpenJDK. The best of both worlds: Free, and the LTS releases are long-term supported. [4] Various other parties, such as Azul, make commercial JDK releases with varying degrees of long-term support and tech support. They all cost money. I advise [AdoptOpenJDK](https://adoptopenjdk.net/). 
my only question is: is it really worth buying?
[removed]
Yeah, but O'Reilly subscription costs 400 a year, and Packt, I got for about 120. And yes, there might be some bad material out there, but it's just a matter of sorting (if possible). I will list books which I've read and found amaizing: - [Spring 5 Design Patterns](https://www.amazon.in/Spring-Design-Patterns-Dinesh-Rajput/dp/1788299450) by Dinesh Rajput; - Spring Security - Third Edition. It really goes into depth; - RESTful Java Web Services - Third Edition; - Mastering Java 9 By Dr. Edward Lavieri, Peter Verhas; - Docker and Kubernetes for Java Developers; These are just recent ones. Also, on top of that, they have "learning paths" where they suggest books and videos, which is a nice feature.
Thank you, I will definitely replace my logger with either of those, and get rid of the methods that aren't needed to be implemented again. :)
Freemarker is good, but lacks one feature that might be important for some projects: nested loops.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Yes (more or less) FTFA
&gt; Yes, Programs written for Java 1 (released in 1995) will still run on JDK11 (released a month ago). This is much too simplistic an answer. Many application that for example deal with XML or JSON use JEE stuff that has been deprecated in Java 9. Those applications simply won't start on Java 9 without an additional runtime flag. And they will completely stop working on Java 11. A JavaFX application that has not been updated for Java 11 also won't work IIRC. 
There's a simple tool, [JEnv](http://www.jenv.be/), that lets you easily switch Java Environments. So you can install both Java 8 and Java 11 at the same time and then, for individual applications/directories, easily switch between them. So use 11 as the default and if you run into problems with for example javax.* or com.sun.* packages missing switch to Java 8. 
&gt; In nutshell Haste gives possibility to 'time jumping' during tests so you can check whether the scheduled task has been correctly completed or not. Full description in readme file. Unfortunately the way you handle this, by having me spread your TimeService everywhere in production code, is not a way I want to deal with this. Sorry. 
You only need this where time issues are important and it's part of test cases but how do you want it to be done?
u/rufati are the books any good? Packt is very very suspect when it comes to quality. I've read a few of their books. Sometimes I wonder if the authors even know what theyre talking about.
I'm not sure if I understand you correctly. You are talking about something like TimeService.fromClock(clock)? Main problem with this is that Clock is immutable so when you use method to move time into future in order to invoke all scheduled tasks library need to override given clock with new with offset. But maybe I don't know something and there is a solution ;)
I'm using it now. We have a business requirement to process 50,000 rows from oracle, each row to be evaluated over up to 10 or so business rules that have been entered into a gui using a DSL. &amp;#x200B; Two ways of doing it. Either: Create an rule interpreter that examines the rule, and considers if the rule is applicable to the row or not. &amp;#x200B; Or: Create a rule compiler that turns the rule to bytecode class at runtime. An instance of this class can determine if its applicable to the row or not. So far I am getting performance of the order of about a billion rule evaluations / sec once hotspot has compiled the bytecode to native (on a core i7)..... Its standard interpretation vs compilation approaches to the same problem. &amp;#x200B; &amp;#x200B; &amp;#x200B;
My very unbiased opinion is that it should be Java.
I'm a newbie so every resource looks good enough to me. Someone commented that Packt is garbage mostly and that your can get most their books for free with enough patience. I haven't had a chance to look at this bundle of books as I've been at work for the last 12 hours with a little bit longer till I go home. Too hard to read and do my job at the same time.
None of those things you mention were in Java 1 though.
Understood! Hopefully their a good resource for you. Good luck and happy learning!
Python, believe me I am expert in java
Head over to codingbat.com and try both out. It's free, doesn't require an account, easy to use, and their practice problems are in both Python and Java. 
There can be several solutions. I prefer use subclass of Clock in my tests. It is like a singleton bean injected by DI with time modification methods. The fixed clock is used as a state and can be replaced with a new one after modification. And my implementation delegates to this state. 
Here's my mind : start with Python then Java. You said that you have very little pre knowledge, so assuming that you know "nothing" about algorithmic. To code, first you'll need to learn the basic of statement, expression, loops, functions, classes and WHEN AND HOW TO USE THEM (this comes by exercising a lot : first by achieving simple tasks then finding more "complex" algorithm like doing your own bubble sort for example ; it's not just simply knowing what a function does) . It's easier with Python as it's a higher level language. But as python is not a strongly typed language, Java will become really helpful to do bigger projects and being more precise (and it will let you understand deeper how computer works). Java is really great, but Python is, in some way, more designed for beginners. 
I prefer too Java over Python but learning basics is easier with Python. 
Python is more like a handy swiss army knife Java is full blown war Tank.
Forgot to mention there are also some video courses as part of this bundle.
harder to learn but once perfected more effective?
I learned Python First and later Java, but for me Java was a lot better to understand and more fun to write
Is anyone actually using ZGC in production now (or at least some extensive testing)? I can see that there is a development progress since Fosdem'18, but still long way to go.
Exactly. Moreover I realised you learn a lot about oops in Java than in Python. Also java is a standard in industry, so your job prospects would be better. If you can learn try learning basics of C too.
Python. Learned java first and am now learning python, and it's a simpler java. Java will most likely take more time to grasp (in my opinion of course) so if you do python first, it may save you time in the long run!
I started with Python. But when I needed to actually go beyond scripts, it was really hard to understand OOP concepts with Python. With Java, it was clear as day. 
That's kinda besides the point. 
Oh. I've been using 2.x with 11 already. I didn't know I was such a rebel.
I learnt Python before Java. I found the ecosystem around Python to be a lot more complicated. With Java you just need the JDK and and IDE (recommend IntelliJ community edition which is free) and you have enough to start. Later you will need a build tool (recommend Maven) and that's it. With Python you have a lot more options and power but that also means a lot more combinations. I found I was spending a lot of time getting things working together whilst reading many blogs from people with slightly different setups that weren't quite applicable. I didn't want that much choice whilst I was just getting started. I'm not sure if this is still an issue but the Python 2/3 split was also an unnecessary complication for a beginner that Java doesn't have. Lastly Java is a lot more verbose and explicit. I regularly found myself getting lost in Python. Where did this field come from? Where did this function get imported from? Nothing difficult for somebody who knows there way around Python but really tricky to keep track of whilst you are learning. In Java, there is also a much lower reliance on reflection as developers like to rely on the compiler to catch errors. This makes code much easier to move around and discourages "clever" solutions that are quite hard to read after a few months.
It's unfortunate that the library expects us to rewrite our applications to use the `TimeService` everywhere. The `java.time.Clock` abstraction is (should be!) already enough for this, it's a resource we're injecting into our classes where needed. The [`MutableClock`](https://www.threeten.org/threeten-extra/apidocs/org/threeten/extra/MutableClock.html) from [ThreeTen-extra](https://www.threeten.org/threeten-extra/) already provides a way to have a settable clock in tests. What would be useful is an implementation of `ScheduledExecutorService` taking a `Clock`, because `ScheduledExecutorService` is currently exactly the abstraction layer we're depending on, are injecting into our classes, and are mocking to have settable time in out tests. See e.g. [this Mockito article](https://github.com/mockito/mockito/wiki/Using-Spies-(and-Fakes)#case-study-2-to-test-a-jobscheduler-that-uses-scheduledexecutorservice) on how to do that nicely. It's not hard, but yes, there should be a library providing these things. If you're really thinking about getting adopted, please consider this way.
I would start with Java. It's closely related to many older languages, while being entirely modern and up to date. So, if you need to do a project in C++ later, it will be an easier transition. Even C from Java will be easier. Going from Java to Python is much easier than Python to Java too. Python had a lot of eccentric things that don't apply to other languages. I think it's easier to learn an older, more structured, language first, and move from there to Python. It seems many of the people I talk to who started with Python can make a ppl program that does a lot, but they don't always have a firm grasp on why it works. That's just my 2cents.
Both. Though I might have had to bump a few dependency versions up a bit. That's probably most of what they did in their bom to get it to be supported on Java 11 
Depends on your task. Nobody using your application will care what language you choose. They only care about the finished product. Java is strong for database applications (jdbc), mobile applications (android), and it's faster than Python. Python is popular for things like command line scripts, data analysis (pandas, numpy), and machine learning applications (tensorflow). Both can be used for things like AWS Lambda, web applications, etc. If you're in this category, then it is really a matter of preference. Java typically has much richer tooling, with a learning curve to match. Python has dynamic typing, which is great for quick prototyping, but leads to more bugs as well. It all boils down to which end of the spectrum you fall on with decisions like these. There is an optimum answer for you that won't be the same as everyone else.
Hey r/java! We recently developed a VSCode extension to allow users to triage the results from our Java security testing technologies. Given that we use VSCode when developing our Java based applications, I thought this might be of interest to the group. Any feedback is much appreciated. Thank you!
Learn to program, don't learn languages. Having said that Python is easier to conceptualize OOP and easier to write. Java needs so much simple scaffolding to do anything it is a pain in the ass to work with. Have you thought about looking at Groovy instead? Groovy runs on top of the JVM is Concise and readable and requires Very little code needed for complex tasks
Congratulations! Now for the love of all that is holy, update your documentation to reflect all the new changes!
Thank you for great framework. May someone help me to start contributing in this framework?
https://github.com/spring-projects/spring-boot/labels/type%3A%20task there is a "first timers" label but its empty. These tasks seem to be a great place to start though. Complete one, submit a pull request, and take it from there.
Yes, but for OP, he probably won't be doing any JavaFX or XML parsing, so while it is good to know, he could code in Java 1 and run it in Java 11.
I used to use slf4j+logback all the time. However, after java 8, the java util logging library is not all that bad - the various overloads of the log methods takes functional arguments like `Supplier` which are only invoked if the log level matches, supports i18n logging with with `setResourceBundle` and `logrb.` 
[https://github.com/remkop/picocli](https://github.com/remkop/picocli) for annotation driven command line options. Makes things a breeze when you need a quick CLI tool.
It looks like in your [submission](https://www.reddit.com/r/java/comments/9sr9jm/top_challenges_for_java_programmers/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
*Subreddit rules*: + **No surveys**
What test framework do you use? Some don't work in 11.
I converted one project easily from 2.0.x to 2.1.0. The second one is giving me a lot of headaches. It complains about Junit 5 classes not being there. I'm not using JUnit 5 (just spring-boot-starter-test) so this was strange. Compiling with JDK Java compiler API. C:\Users\may\.gradle\caches\modules-2\files-2.1\org.springframework.boot\spring-boot-test\2.1.0.RELEASE\ec05836d27eb6d102e45f3927d53e4a4fe215f01\spring-boot-test-2.1.0.RELEASE.jar(/org/springframework/boot/test/context/SpringBootTest.class): warning: Cannot find annotation method 'value()' in type 'ExtendWith': class file for org.junit.jupiter.api.extension.ExtendWith not found error: warnings found and -Werror specified I noticed in the release notes this entry: &gt; All @…​Test annotations are meta-annotated with @ExtendedWith(SpringExtension.class) so this redundant part of the setup can be removed if you’re using JUnit 5. Spring Boot also uses a maven-surefire-plugin version that does not require any custom setup to use JUnit 5. I assume that is causing the issue. So I added a dependency to fix it: testCompile("org.junit.jupiter:junit-jupiter-api:5.2.0") testRuntime("org.junit.jupiter:junit-jupiter-engine:5.2.0") Now I get a strange error about Gradle unable to read a classfile. Execution failed for task ':test'. failed to read class file C:\prj\seerapi\build\classes\java\test\com\imsweb\seerapi\lab\executor\ApiExecutor$Builder.class Turning on --stacktrace gives this: Caused by: java.lang.UnsupportedOperationException at org.objectweb.asm.ClassVisitor.visitNestHostExperimental(ClassVisitor.java:158) at org.objectweb.asm.ClassReader.accept(ClassReader.java:541) at org.objectweb.asm.ClassReader.accept(ClassReader.java:391) at org.gradle.api.internal.tasks.testing.detection.AbstractTestFrameworkDetector.classVisitor(AbstractTestFrameworkDetector.java:124) ... 67 more Has anyone else experienced something like this? Is this an issue with Gradle? If I switch back to Java 8 (or 10) with Spring Boot 2.1 all works well.
I think they were waiting for stable ASM 7. It only got released very recently.
Yes. And more - there's absolutely more space for more convenient testing timing APIs. If we agree that the Clock is the main abstraction for receiving time, these are the things I'd sometimes use (and have actually implementations for most of them): - a Clock that gives a monotonically increasing time for every method invocation (returns 1 the first time, 2 the second time, etc.) - a Clock that is mutable and listenable - when I call set() and on it, I want its listeners to be notified (this simplified implementing more advanced ScheduledExecutorServuces) - Clock wrappers for Guava Ticker, Caffeine Ticker (sorry, am on mobile, you'll easily look them up if you don't know what I mean) and other APIs that have their own clock abstraction and are not yet aware of java.time.Clock - err, I'm sure I'll come up with more tomorrow
Many thanks, I will look. 
This isn't Upwork
Oh god yes. And supplier based delegates, and logging wrappers.
/\*\* \* This class is intended to model a 12-hour digital clock (e.g. 07:34:52 or 12:02:59). \* The clock is able to be set to a specific time and then accurately begin keeping time. \* When appropriate, the time rolls over to the next minute, next hour, or both. \* \* //Add your name after "author" below. \* @author \*/ public class DigitalClock { &amp;#x200B; //Fill in the necessary fields below /\*\* \* Constructor for objects of class DigitalClock \* Replace the constructor. \* Rather than assigning the fields with the parameters in 3 different statements, \* make a call to the setTime method using the constructor's parameters as the \* setTime method's parameters \*/ public DigitalClock(int h, int m, int s) {} &amp;#x200B; /\*\* \* Assigns the fields by calling the appropriate set methods. \* In order to set the time, you must set the hour, set the minute, and set the second. \*/ public void setTime(int h, int m, int s) {} &amp;#x200B; /\*\* \* Mutator method for the hour field. \* It should check if the parameter is valid. If the parameter is invalid, \* assign it a value of 0. \* Fill in below. \*/ public void setHour(int h) {} /\*\* \* Mutator method for the hour field. \* It should check if the parameter is valid. If the parameter is invalid, \* assign it a value of 0. \* Fill in below. \*/ public void setMinute(int m) {} /\*\* \* Mutator method for the hour field. \* It should check if the parameter is valid. If the parameter is invalid, \* assign it a value of 0. \* Fill in below. \*/ public void setSecond(int s) {} &amp;#x200B; /\*\* \* Update the hour field to the next hour. \* Take note that nextHour() of 23:47:12 is 00:47:12. \*/ public void nextHour() {} /\*\* \* Update the minute field to the next minute. \* Take note that nextMinute() of 03:59:13 is 04:00:13. \*/ public void nextMinute() {} /\*\* \* Update the second field to the next second. \* Take note that nextSecond() of 23:59:59 is 00:00:00. \*/ public void nextSecond() {} /\*\* \* Accessor method for the hour field. \* Replace below. \*/ public int getHour() { return -1; } /\*\* \* Accessor method for the minute field. \* Replace below. \*/ public int getMinute() { return -1; } /\*\* \* Accessor method for the second field. \* Replace below. \*/ public int getSecond() { return -1; } /\*\* \* returns "HH:MM:SS" \* Hint: You might find it helpful to create a local String variable and progressively add to it. \* Replace below. \*/ @Override public String toString() { return "game time"; } &amp;#x200B; }
If you're doing scientific stuff a lot, python, if you want employablility in the industry, Java.
I gotchu. Give me a minute. No payment nessesary
The sidebar for this Reddit specifically forbids asking for help. Please post in r/javahelp. But even there your question won't fly. You can ask for help, but you can't ask us to do your homework for you. Please ask questions and for help, but not solutions.
Are you really going to help someone pass their CS101 class for free? Maybe /r/javahelp is a better place for this request.
Well I'm a dumb fuck, I didn't mean to do that. Thanks bro. u/zioftw nevermind, you'll never learn if you outsource your homework assigments
I’m not asking for people to give me a written code :( I’m asking for people to help me understand what I’m supposed to do and what’s the reason. Like a tutor. I’d be willing to pay if it’s necessary. I’m just looking for guidance not someone to do it for me.
I'm not sure I'm reading this correctly, but are you saying java is older than python? because it's the other way around.
but are you a loner?
No, just that Java's syntax was based on C++, which evolved from C. So, just in terms of how it's laid out and syntax, it's similar to popular older languages. So, making the switch from Java to those might be easier. Also, because you have to declare each variable, and everything is enclosed in obvious code blocks, along with some other more verbose syntax, Java tends to be a little more on the page, and a little less inferred behavior. So, it seems after my decades of working with students, that people who learn Java know in more detail what's actually going on in their programs. Also, while you can create most design patterns in Java, you can usually do without them a little longer, and that allows you to learn a brute force means of accomplishing a task, then learn a design pattern that works better. Being 'Pythonic' is often hard to translate to other languages. I love Python, and it's not a hard language to learn at all. But, if I had my say on what to teach first year CS students, I'd choose Java over C++. 
We try to document new features as they’re added. Is there anything in particular that’s missing?
That first problem is odd. An annotation that’s not on the classpath should just be dropped when the class is loaded. The second problem looks like the version of ASM that Gradle is using is choking on some Java 11 bytecode. A Gradle upgrade might help there if you’re not already on the latest and greatest.
Neat. Always good to find something you really have the willpower to work on. I struggle with actually continuing to work on my own projects lol How much experience do you have with Java so far?
r/Java is for discussion, not commissions. There are plenty of sites available for code bounties. Look around a bit.
I believe IntelliJ also has a JavaFX-based form designer built in similar to Eclipse's SWT Designer. Not sure whether or not it'll do code generation for you, but if you want to start working with UI elements, JavaFX is the de facto framework for it.
Not having to deal with complicated dependency systems, for one. I'm currently trying to learn how to use C++ because I want to give OpenGL a shot, and library management is an absolute nightmare unless I'm on my Linux machine. With Java, I can have a program with a ton of different libraries up and running within a matter of 5-10 minutes regardless of the platform. IDE integration is another huge reason. My workflow is streamlined *so* much better in Java than it is in other languages. It's unbelievable.
As someone who’s only done big monolithic programs, each service having its own (probably poorly optimized) DB sounds insane.
Windows doesn't underclock hardware. I don't know where you got that idea, but it's wrong.
&gt; however it is unlikely jetbrains could find out s h a d y
r/programming
Immutable parameters also stop the JVM from creating a copy of the parameters before they get sent to the method, I believe. Probably makes some noticable changes at a large scale.
What did you try so far?
They might just be referring to all of the old tutorials and docs. I'm just at the point where I'm fully comfortable with Spring, but I have some new hires and finding spring tutorials that are up to date can be a pain.
Why not do both?
Is this what you mean? (Wait, is this not /r/pleaseDoMyHomeworkForMe ?) . /s There's nothing special about mutator methods. They're just the methods that read or write a value, with the arbitrary naming convention of get/set. So any method can call any other method. And those methods could do anything. ``` public class DigitalClock { private int h, m, s; public DigitalClock(int h, int m, int s) { setTime(h, m, s); } public void setTime(int h, int m, int s) { setHour(h); setMinute(m); setSecond(s); } public void setHour(int hour) { this.h = hour; } public void setMinute(int minute) { this.m = minute; } public void setSecond(int second) { this.s = second; } public int getHour() { return this.h; } public int getMinute() { return this.m; } public int getSecond() { return this.s; } } ```
Definitely looks like a /r/pleaseDoMyHomeworkForMe kind of post! Nice that you expanded your answer enough that OP should get a good understanding of what’s going on
Do you understand the difference between **Python** and **Java**? This subreddit is for **Java** only. Also, there is a **"no tutorials"** rule here. **Spam** somewhere else.
It looks like in your [submission](https://www.reddit.com/r/java/comments/9swf8r/fairly_concise_doublebased_2dimensional_vector/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Downvoting but no arguments. As expected from this subreddit. 
What I usually tend to do is have multiple services access a single DB , e.g. 4 services access database A, 3 access database B etc.
He is a student, he has the paid version for free And for python you have Pycharm from the same guys
Or stick to Java 8. :( I guess I should consider myself lucky to have even that, in a corporate environment...
&gt; I would like to show you my new idea of time managing in java applications in order to improve testability. Needing a movable time source may also be an indicator that your code is not well structured, or, that the taken approach for testing is not suitable to catch all the variants that might exist. I saw projects not having unit tests, but depending on testing based on automated clicking through the (web) application. So, if you are only able to test a complete running applications, you need a movable time source, if your application is behaving differently based on the current time. You might not need that if you take another test approach and improve the structure of your application. I consider calling the clock in normal application code (aka "business logic") a general anti pattern. If the outcome of a program is varying depending on time, then the actual time value needs to be a parameter, not the clock to read the time from. In our business code, time lookups are generally disallowed. Every method that depends on the current time gets a parameter, e.g. `Date now`. Code that depends on time becomes testable, and it is obvious, by looking at the parameters, that the code outcome depends on the time. On the project page you say: &gt; In a few applications I was struggling with time aspect during tests. It would be interesting to know what kind of use cases make you "struggle" and discuss about the possible alternative approaches to solve the problem. Can you give examples what problems you are trying to solve? 
Given the circumstances around licensing, I'd recommend keeping a strong foundation up to java 11. It'd definitely be icing on the cake though to know 12 though.
Yeah, we just made leap to 8 from 7. 
The smart move would be to use the LTS if you need that stability, and add each new release to your CI pipeline so you can identify issues before you need to upgrade. 
It's hard tho, it really is. I was working on a little game inspired on the 80s movie Wargames, but the code turned spaghetti pretty quickly and I just kinda accepted I got bored of it and did this instead. However, I know I'll get back to it or probably just redo it entirely. I started studying Java about 2.5 years ago and so far the only experience I've had is school projects and stuff like this. I really wanna get more into it and currently in thorn between using my knowledge in a professional setting or developing stuff with friends instead.
I plan to develop for 11 (for now) but build against both on our CI server.
Why don't you try both and see which one you like best? When learning programming the most important thing is to have fun. So pick the one you feel like using the most. This choice is completely personal.
That's more a search engine problem than a spring problem though. The documentation is there, it's just that the old documentation is still there too and often ranks higher in google. 
We have very active communities on /r/javahelp and /r/learnjava where many people are happy to help with issues you might run into. 
Yep, I'm in no hurry to move on from Java 8. Personally, I liked the slower and larger release cycle. This new cadence just leaves me wondering why the point in upgrading is if I have to do it all over again and a few months. To be fair part of the problem is having old projects with terrible test coverage. If the testing was automated I'd be more inclined to try with newer versions of the VM.
I’ve moved to Java 11 already, and plan to only jump to the newest version when a new LTS is released.
Wanting to support Android with the same codebase means one of our major projects is still stuck with Java 6 class library. At least Google managed to port the language features form 7 and 8. Between Android moving towards Kotlin, Oracle messing up the Java release process just to make more money and IBM buying RedHat, I don't see us doing any new projects in Java.
Excel would probably be more efficient and effective.
Thread-safe - absolutely, yes. Immutable - not really, no, that does not matter too much in here. The "normal" system Clock instances, even though they are effectively immutable, are tapped to a mutable time source, and will therefore look to the outside world as if they had an ever-moving state (time). As an extra point, you could change the system clock during the run of the application, and that will change the system Clock behaviour... For testing, a `MutableClock` is invaluable. Case in point - the author of [JSR 310](https://www.threeten.org/), Stephen Colebourne, is also the author of [ThreeTen-extra](https://www.threeten.org/threeten-extra/), the library behind `MutableClock`, so he broke his immutability rule himself. All he's saying is that the clock objects must be safe for use, e.g. you should be able to share a Clock instance safely without the fear 3rd party code will mess with it. In tests, we kinda need that to test things, though.
WebSphere already died ;)
Can someone "Explain me like I'm 5" with Android's Java. As far as I know its butchered and Android's versions are missing features from OpenJDK official versions. Is this true or not?
I jumped the release train when java 9 was released and plan keeping to it. This is the best thing that happened to Java, it changes quicker, new features are added every 6 months. And library developers are already catching up, usually there is a support for next version before it is released. Stephen is complaining about it all the time. But he almost always fails to mention that there are more companies providing builds for non LTS java, not only Oracle. More over have you checked how often your company does minor version Java upgrades? Mine did that for Java 8, about 2 years ago, and now recently they upgraded to latest Java 8 release. My previous company was similar. So for majority of companies nothing changes, they won't do security/bug fix upgrades as soon as they come out. So the only sensible option is to upgrade to newest Java, not to newest a bugfix release. 
Correct. Android does not run a JVM, and on old Android versions, the class library was also a clone of Java 6 but not actual OpenJDK. The runtime has little to do with actual Java. The biggest similarity is that android apps typically are written in Java-the-language.
so you guys are gonna be paying oracle for support come next year?
that was my experience last time i did android dev
what circumstances? openjdk is opensource
java 8 will go eol next year. java 11 is LTS for 3 years
[removed]
You know, with Microsoft you can usually get a feel for which version to settle on for a while. it was the same with Java/Oracle for a while, and maybe Java 8 is the spot? But now? Egads... Tell me when this ride slows down. I'm all for progress, but the community at large can only move so fast. Maybe they could proceed at a pace which considers the overall community a bit more?
There is no need to pay for support of Java 8 until 2023. But I suspect you already knew that. https://blog.joda.org/2018/08/java-is-still-available-at-zero-cost.html
With Java, the releases to settle on are clear - the LTS ones, currently 8 and 11.
sadly, for me not yet 😭
I guess I don't understand the issue. No one HAS to upgrade every few months. The beauty of the new release process is that people who are interested in features can upgrade to each release, and start getting familiar with them. People interested in stability should probably NOT use each release, but only LTS release, of which Java 11 is the first since 8. That's still ~2 years between LTS releases.
Where can I find the latest documentation 
I'm not sure whether it is the best tool but [Jasper Reports]([https://community.jaspersoft.com/project/jasperreports-library]can cover most of the business needs.
[https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/)
Java 17, LTS releases are about to be released every 3 years
doesn't your link say otherwise stephen? or are you saying they should switch to openjdk 8?
1. Libraries for every case. 2. Plenty jobs. 3. JVM based languages. 4. Covers a lot of areas (EE development, Android, etc.) 
I believe it was due to licensing issues - OpenJDK is GPL - and because OpenJDK wasn't even a thing in the first days of Android.
How do you synchronize overall system state (like a “user exists”)?
For user specifically, I have a Auth server setup that issues user tokens. Those tokens are both available in the "User" database that services that have utmost need for users use, and in a Redis cache that services that don't need much user data use. 
Why you tell it to me? :)
&gt;Every method that depends on the current time gets a parameter, e.g. Date now. Code that depends on time becomes testable, and it is obvious, by looking at the parameters, that the code outcome depends on the time. &amp;#x200B; That's right but only when you are testing each class separately. I prefer BDD approach where you can create part or whole system working in memory (Of course you still can (and need) test some sophisticated part of your system but lets be honest, it is minority of typical application). In that type of tests you need some 'time source' or time-context &amp;#x200B; &gt; Can you give examples what problems you are trying to solve? Consider application for betting on matches. Here is simple test scenario in steps 1. Add fixture to system. Adding fixture shout schedule 'result fetch' task 2. Change time to any but after the expected fixture end time. 3. Check result You can test all those steps separately but from my (small) experience bug and problems appear at the contact point of test scopes. My test would look like this (in pseudo-code): `system.addFixture(fixture)` `system.changeTimeThreeHourAhead()` `system.getResult(fixtureId) == expected` 
If I remember rightly, they couldn't agree licensing with Sun at the time and adopted Apache Harmony instead. That stopped development back in like Gingerbread days. They're using the OpenJDK now though.
Thank a lot buddy :-)
The landscape will be fragmented with code/libraries built on specific versions. People building the libraries or tools or IDE's will have hard time following the releases. Which Java version the Netbeans IDE currently support? Last is checked it was a Netbeans 9 beta version from Apache, and was up to JDK 10, made me switch to IDEA community, although i was satisfied with Netbeans before that.
+1
try eclipse, they support 11.
It might be good to note that they’re functionally identical only for JDK 11 and onwards.
OpenJDK 8 will be available with security patches until 2023 via your package manager, AdoptOpenJDK, and other sources providing those involved do what they've publicly said they will. In most cases, moving from Oracle JDK 8 to OpenJDK 8 will be problem-free, but for some there will be problems. Those people either have to fix the problems, or pay.
What's supposed to be in 12?
i expect fragmentation to not be an issue in a year or two. people are still adjusting to the new release cycle, and a lot of software is just now starting to truly support java versions beyond 8. 
i'm of the opposite tack. my project will make use of project panama features as soon as they become available, so i will be hopping on the 6-month release train. the good news for people like me is that the non-lts releases are still stable releases, and should be of the same quality as releases like java 8, 7, and 6. I just have to upgrade more often, but that may well be worth the price if living on the bleeding edge of java gets me value types, better JNI, and fibers. 
Thanks. I'm using the latest version of Gradle (4.10.2). I even tried to update to the 5.0-rc1 and it didn't help. Still investigating but nothing has helped yet.
So would you depend on a lot of state being retained by (and passed to you by) the client while logged in? So client interacts with the user service once, and gets a token with account details (name, email, roles, capabilities, etc) that other services can verify.
Why don't you post the link directly? You copypasted the first paragraphs changing "I" to "He", which sounds quite hilarious. 
&gt; Oracle's claim is that because each release is only 6 months after the previous one, there won't be as much "stuff" in it, thus it won't be as hard to upgrade. While true, it is also irrelevant. What matters is whether the upgrade has the potential to damage your code stack or not. And clearly, **going from 11 -&gt; 12 -&gt; 13 has much greater potential for damage than 8 -&gt; 8u20 -&gt; 8u40 ever did.** What breaks code aren't *releases* but *changes*. While it's certainly true that a spec change has a greater potential to break your code than an implementation change, if every change broke every codebase out there we wouldn't have the robust platform that we do. Rather, *some* changes break *some* code. If, say, every 1 in 100 changes breaks your code, then you would expect every major release to break your code, but only one in every, say, 7 feature releases to break your code. So even if we assume (the untrue assumption) that a semi-annual update release under the old model had zero chance to break your code, while it is true that now every six months there is the *potential* of breakage, actual breakage would occur at the same rate it used to before (assuming you upgraded major versions). Similarly, the *effort* of upgrade is a function of the changes, not of the versions. If the total effort of upgrade to the changes in a major version under the old model (say, every 3 years), was 2 person-months, then the same amount of effort would be required under the new model, only spread out. &gt; If you adopt Java 12 and use a new language feature or new API, then you are effectively locking your project in to the release train. That is true. Perhaps the best course of action to the wary and undecided and is to adopt a wait-and-see approach: try the release train for a couple of versions *without* adopting new features. If they see they find upgrades hard, they can drop back to LTS. If not, they can consider adopting new features. The key is that there is *no need to make this decision right now*. Any speculation about the actual effects of the new model (including my own above) is just that -- speculation. Time will tell whether the new model helps (as I think) or is a genuine stumbling block (as /r/jodastephen thinks). In any event, while all change is scary, there is no need to panic. A responsible developer has all the tools to cope with the change in a cautious way and give it a chance.
The token usually only contains only basic data necessary to retrieve full user data needed by those services. 
Try to post the link directly and see what happens ;) Yeah, I to he... but otherwise people might have though I was me, if you understand what I mean.
I'm using the latest Eclipse, runs fine on 11. The new version is faster on 11 than Photon.
Oracle hasn't provided a separate OpenJDK and Oracle JDK before 11.
In the Enterprise, Long Term is often 10 to 20 years.
I've personally never broken a single drop of sweat off new Java versions coming out. Other than this "great removal" of JEE dependencies, the backward compatibility is amazing. If they were planning on breaking that tradition regularly, then yeah I could see an issue with that. IDE support, well I guess it sucks if you don't have one that keeps up with the times, but that's too bad. You might not get hilighting or something but that's about it. Since I use IDEA I'm all set. :)
Jasper Reports is the way to go.
The larger the leaps the higher the complexity of the moves. IMHO it's always best to, when possible, to go in smaller increments. 
I don't understand this sentiment. You can now move in smaller increments. We did not have to change anything from 9 to 10 or from 10 to 11 in our services for example. Longer cycles just mean you have tons and tons more complexity in actual migration. With the shorter release cycles we also have a much better reason to spend a small time upgrading. I remember how hard it was to 'sell' an upgrade from Java 8 to 9 to managers simply because the amount of work involved. I can't imagine having to 'sell' a move from 5 to 11 or so. 
what will happen with Jboss and Websphere? I assume they will end up picking one instead of developing two competing platforms?
A company I worded for 3 years ago is close to moving from 5 to 7!
Why would one want to move further from Java 8 anyway? Some module-based features that you probably don't care to use anyway? Serious, lazy question.
How does building on the current feature release with `--release=&lt;LTS&gt;` fit into the picture? I was surprised that wasn't proposed as a middle ground option.
There's a balance between "small and big", and I'm not sure Oracle is striking it right now. It's all a shot at making the free tiers more uncomfortable for serious work, and getting people into the paid licenses.
If one absolutely must make a decision now, based on no speculation without experience, then yes. But only time will tell whether settling on a specific version for a long time or jumping on the train would make much of a difference in practice. It is absolutely not the intention of the new release model to make life hard for people; on the contrary -- we hope and believe that for most people it will make life easier, whether they decide to deploy on the current feature release or deploy on the latest LTS version and only test on the current feature release.
Apparently many milineals never experienced the pay-for-support programs from Sun, BEA, IBM among others regarding Java.
This guy living in 3018 with Java version 5040
I think you meant /u/jodastephen not /r/jodastephen. I didn't think he had an entire subreddit dedicated to him! :-)
Sorry about the late answer but after some time and several commits I have applied most of your tips to my code. Thank you so much! this is one of the most useful comments.
&gt;&gt;At the very least, I image the question "Why choose JBoss Enterprise Middleware over IBM WebSphere?" likely won't remain on the JBoss page after this acquisition. that is a very dry wit.
What do you mean? I am a developer who usually uses spring and most of the time the latest documentation is OK.
Umm sure, I never experienced it, but I know it exists. I know that Red Hat offered paid support for JBoss and Wildfly, I know that IBM sells their 3270 emulation software with paid support, I know that Sun/Oracle offers paid support for their Linux distro and many softwares that they have. My question was about paying for Java support -- that is, language, JVM and possibly JDK. I'm no stranger to paid support on software, but I just don't see the point on paying for Java and JVM support and patches when the community material about Java troubleshooting is stellar and LTS releases offer more than enough time (6 months, in Java's case) for developers to migrate. I know that some businesses (like banks, transactional software, large-scale management software) would love to pay for that kind of support, but small-medium businesses shouldn't worry as much as people are saying they should IMO.
&gt; we hope and believe that for most people it will make life easier, whether they decide to deploy on the current feature release or deploy on the latest LTS version and only test on the current feature release. Having given this a little more thought, I think you're right. /r/nutrecht made the point that this allows us to upgrade more frequently and in smaller increments of change, and this makes a lot of sense.
What happens? Don't make everyone try to post the link to find out. You could have quoted the text by starting the paragraph with `&gt;`.
You should still regularly build against new releases so you can see what things will break (if any), even if you don't run it on that JVM.
Someone still needs to backport changes to the OpenJDK 11 tree, because AdoptOpenJDK won't.
The exciting things are due to be preview features that'll require a command line argument to enable, but they are switch expressions and raw string literals.
For things like their special implementation of feign until very recently there was insufficient documentation on the docs site. Beyond that javadocs aren't always published. Many many dead links. 
How would have a final modifier helped in a four level deep nested loop?
The official LTS is not free. The OpenJDK has no LTS unless a third-party backports security updates. Maybe Red Hat, but there is no guarantee
What I do is usually 3-6 months prior to the new LTS release becoming publicly available, I take a look at all of the new features and then try building my applications against the new release, and resolve anything that doesn’t work.
You could (and probably should) also start building on each release between LTS releases so you have more of a head start if/when you run into issues for the next LTS.
There are lots of improvements in later versions. For me personally I want to get onto Java 11 for the ergonomic memory config so I can worry less about OOMing in Docker/Kubernetes. The backported options for Java 8 have problems still.
Also don't use bloatware like Apache HttpClient and log4j. Many libraries bundle these, so you need to choose libraries that don't. &amp;#x200B; A good alternative to Apache HttpClient is okhttp.
&gt; and getting people into the paid licenses. How? There is no reason at all to not use OpenJDK.
If you are interested in reporting using Word or Excel templates then you can look into [Windwards](https://www.windwardstudios.com/) or [Templater](http://templater.info)
/r/unexpectedfactorial 
Indeed! I wrote this previous article exactly on this: [https://read.iopipe.com/java-libraries-are-your-lambda-enemy-6c9467321d2b](https://read.iopipe.com/java-libraries-are-your-lambda-enemy-6c9467321d2b) !
&gt; What happens? Don't make everyone try to post the link to find out. Oh, it's simple. Nothing happens. And then I literally mean nothing. You post it, and then it's like you pressed cancel.
The way things are moving I would assume Wildfly will be the direction they go. From the source code they can microservice servers (Wildfly-Swarm (now Thorntail) as well as the full blown EAP server.
The language name is Java, not JAVA. It's not an acronym. 
I tried to keep the article relatively neutral (for me). My goal is to get people to think before adopting 12, rather than just blindly doing so and ending up in a mess. For those willing to go for it, I say "great", and "good luck". Another key part of the article is to emphasise that the JDK is only one part of the stack of any application. It is an important part, but I do think Oracle employees overestimate its importance. The real effort in upgrading the JDK version is almost never due to changes in the JDK itself, but is instead due to the need to update the entire tree of code and build dependencies, something that can break swathes of application code, or the build. In your analysis above, you consider the cost of upgrade only in terms of development time, positing that 6 small upgrades will take the same development effort as one large upgrade. I disagree with the claim, as described in the last paragraph, but also because the development effort is just a small part of a bigger process in most companies. QA, deployment, rollout, training, etc don't scale proportionately to the feature release size. In addition, a single large upgrade from LTS to LTS can wait until many months after the LTS comes out so that code and build dependencies have been fixed and updated, making the upgrade lower risk. Whereas feature release upgrades only have a narrow 1 month time window if you care about security. Thus feature release upgrades mean a life lived constantly on the bleeding edge, always running into bugs with those dependencies. For example, my personal experience upgrading 9 to 10 and 10 to 11 is that both hit blocker bugs that needed changes in other tools, notably Maven, but there were others too. As a result, those two feature release upgrades took many hours spread over many weeks - they were in no way a good use of my weekends. Given my experience so far, I think I can speak with a little bit more than just "speculation". 
Using that flag means that would be producing Java 11 bytecode but using and testing against the Java 12 *implementation* of the methods/classes. It also doesn't help the key problem described in the article, which is that your dependencies (code and build) may well have problems with Java 12 even if your code is fine. As an example, many libraries use the `Unsafe` class for high performance, but methods have been, and will continue to be, removed from that class. If you depend on such a library (and the chances are you do), then the release flag won't help you if a method is removed. You would also need to update the offending library, something that may have knock on effects.
&gt; The real effort in upgrading the JDK version is almost never due to changes in the JDK itself, but is instead due to the need to update the entire tree of code and build dependencies, something that can break swathes of application code, or the build. I agree in general. I've recently modularized a library, and the Java module system was a pleasure to work with; but 99% of the pain (which wasn't trivial) was due to Gradle. Nevertheless, I think that the changes in JDK 9 were exceptional (albeit necessary) in their dependence on the rest of the ecosystem. Even for that I didn't need to upgrade the entire tree of dependencies (I did, as it was an opportunity, but only a few dependency upgrade were absolutely needed. &gt; QA, deployment, rollout, training, etc don't scale proportionately to the feature release size. But they're not all the same. QA and deployment had to be done for update release. Training doesn't at all need to follow the JDK releases at the same pace. You can upgrade your JDK just for security/performance/fixes and adopt the new features at a rate that suits you. &gt; Whereas feature release upgrades only have a narrow 1 month time window if you care about security. I don't think the train is for everyone, but 1. it's not 1 month, as we now have early-access releases well in advance, and 2. we don't know whether one month is narrow or not. There's just not enough experience to tell. &gt; For example, my personal experience upgrading 9 to 10 and 10 to 11 is that both hit blocker bugs that needed changes in other tools, notably Maven, but there were others too. If you just wanted to deploy. or are you talking about building with an 11 source version? Those are two very different things (and you still get the security/bugfix/performance improvements if you just deploy to a new JDK). Because of Gradle bugs I'm still building my library with a 10 target, but so what? It runs just fine on 11. 
Yes, that's Amazon Linux. Lambda doesn't support it yet though.
You are probably looking for what is called "Look and feel" which dictates how buttons, fields, scrollbars etc... Look. For your App to look the same as the OS apps you need to use the OS look and feel. 
Do I use this with like javaFX or something like swing? 
Exclusively for MacOS? I’m gonna go out on a limb and propose the correct answer - Swift and AppKit. If there’s an upfront and well defined requirement to be multi platform, then JavaFX is a good bet, but you’ll need to accept that without a Herculean amount of effort, it will always feel and act like a second class citizen on whatever platform it runs on. This is, of course, perfectly fine for internal or enterprise applications, but if you’re targeting a consumer audience, you’ll be DOA before you even release the first version.
I don't need it to be cross platform but I need the firebase API, as far as I can tell for macOS apps the API is missing a lot of features (such as firebase storage, ect), unless I am wrong about this. If I target just one os with javaFX will that make it easier to get the look and feel of a macOS native app? 
I can’t understand people who think it’s an acronym but have never been curious enough to ask anyone what it stands for!
&gt;IBM WebSphere Ugh...just when I thought I had repressed those memories...
Google is your friend. I only used look and feels on swing. JavaFX has .css sheets so I rely on those to make it look good. I am almost 100% sure that you can set the look and feel on JavaFX and Swing so its your choice.
Okay thank you for pointing me in the right direction.
Yes, jasper is always the first to be thought of and I have tried it before. Undeniable that it is very powerful. But I had to creat many sub reports which make me confused. Also, the reports are saved in XML in jasper, which means I have to program to generate the report design layout, or use GUI tools to visually design and save the report. It's something troublesome when encountering a particularly complex report design.
I'm curious what ever happened to AOT compilation? I remember reading about it about a year ago and how it would help this specific use case, but haven't heard anything about it since then. Is performing AOT compilation a valid optimization for lamda runtime?
I got it mainly for the Rx book and I like it so far, but haven't checked out the other stuff yet. 
Embedded Java is something that has always intrigued me. Is this using a Jazelle chip?
The magic word you're looking for is GraalVM. It's progressing well and should be production ready in the next couple of years.
and make your class names less autistic*
Recommand:[Finereport](http://www.finereport.com/en/). **First, use FineReport to make a template,you can replace N manual repetitive work Excel!** Why do you say this, first understand the principle of FineReport's watchmaking * 1, FineReport's watchmaking principle * 2, three types of report design methods, to solve all daily reporting needs, and a table reuse. * 3, parameters to achieve data query and filtering * 4, report **Second, not just reports, but also data visualization** **Third, summary** In terms of data processing speed, part of the performance depends on the database, and part of it relies on the line report engine of FineReport. Compared with the stand-alone efficiency of Excel, hundreds of thousands of lines of data are output in seconds. Furthermore, the enterprise database has various self-contained or third-party clustering schemes, and the heap machine can approximate the infinite increase in data storage capacity. &amp;#x200B;
You could try out swt. This is made to get the look and feel of the host. 
I was looking a lot I do not like Swift and Objective-C is a no go... so I as a Java developer were looking at JavaFX however it is not that great... so I basically give up. At the end I choose React Native [https://github.com/ptmt/react-native-macos](https://github.com/ptmt/react-native-macos) Reasons are many - better componenets, even a browser component, faster development.
Build your app with JavaFX, then compile it to native with GraalVM (using the `native-image` executable). You need to specify which feature you wanted to support. Never tried this before since I own no MacBook but its worth trying if you have one. 
you use jlink to generate your own jre. you can use the jdeps utility to analyze the jars for your app, and find what jvm modules you need. then you run jlink and tell it what modules you want, and it generates a small jre with only those modules
I'm not sure what you're asking about, the release model of Java itself or how users are supposed publish java applications? I'll assume the latter. You can always just have users install the JDK. Now that JavaFX isn't bundled with it any more the sizes are actually pretty similar (245MB vs 204MB for the Java 11 JDK and the Java 8 JRE respectively). IIRC the way of bundling a customised/minimal JRE with your app is using the jlink tool, I'm sure you can find information on how it works by searching for that. I think one of the interesting side-effects of this new model is that though apps can no longer assume the presence of JavaFX (which they never really could in the first place tbf) they *can* now assume the presence of the java.compiler module.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You can watch https://www.youtube.com/watch?v=MFfTqUQxFTs ("The Future of Java SE") for both your questions but here's a short story: * JDK release cycle is similar to (for example) Ubuntu - you have a release every half year and every third one is an LTS with support provided for longer time. (It's JDK 11 now.) * JRE will no longer be published. You can create your own java runtime to go with your program using jdeps and jlink tools.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
My name is Andrey and I’m one of the Product Marketing Managers for IntelliJ IDEA at JetBrains. Thank you for pointing out this issue. I didn’t reply sooner because I wanted to find out what exactly had happened in us ending up with a duplicate title. Some time ago, we decided to put some reviews of our products from G2 Crowd Website. A few quotes were selected, but for some reason, during the process (probably a copy/paste error), we ended up with the situation above. Apologies for that. However, your thread also raised another important topic, which is whether it actually has any value having random quotes on our site. Moving forward we have decided to remove these because ultimately we believe that our products should be evaluated by our users themselves who should make the choice, which is why we provide evaluation versions. In addition, we will make sure that any quotes we do use, can be verified. Once again thank you for bringing this to our attention
Regarding your statement that Oracle only offers JRE 8, true... but if you don't need commercial support for what you're doing, use OpenJDK instead. Take a look at [https://adoptopenjdk.net/](https://adoptopenjdk.net/) After the recent changes, OpenJDK is now completely compatible with Oracle JDK. The only difference is that OpenJDK will have \_at least\_ 3 year LTS (long term support) releases every 3 year (and as the keynote above mentions, each one might be supported longer) and will have STS (short term support) (6 months) releases in between. So everything that we ship will be using OpenJDK LTS releases... but developers are free to play with the STS stuff as they wish... as long as there is nothing put into our own releases that depends on features that aren't in the latest OpenJDK LTS (those would be caught by our build system since that will always use LTS releases too).
A programming language is a software product like anything else. Someone needs to fix those bugs, improve compiler code generation, GC algorithms,....
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt; It is far too soon to tell whether the new release model messes things up It already has messed things up (e.g., JavaFX no longer shipping with the JDK, no firm guarantees for any LTS versions, the inevitable divergence of OpenJDK 11 and OracleJDK 11 codebases, etc. etc.). One of the primary reasons we picked Java in the past was a thoughtful development process with high emphasis on backwards compatibility. Now it's just shoveling releases out every 6 months while introducing backwards compatibility breaking changes. I see no way in which it improves anything for me or my company. The only improvement I see is a way for Oracle to squeeze more money from OracleJDK licenses. Which given everything we know about Oracle is the primary motivation for everything they do. Can you give me a single example of how I would benefit from the new model? Because I've asked many times, including on these forums, and I've gotten nothing.
I didn’t have a problem developing with firebase for iOS - I wouldn’t have thought that the macOS libraries would be much different?
i agree with you. Java's key strength compared to C# is strong backward compatibility. This new release schedule was made for millennials. 
my pet library of code is Java 1.4 compliant. Does that prevent it from being used in Java 11 projects? Answer: No. you can use it.
Multi-platform
&gt; Work faster and go home earlier :D Companies usually work lake that: Work faster and get more tasks assigned.
... and a lot of problems, one of the worst SDK's ever.
First of all, here's some background about the ecosystem: 1. OpenJDK is bigger and richer (in terms of the standard libraries, monitoring tooling etc.) than any other open source non-mobile language/SDK/runtime by a very wide margin, including C/C++, Javascript and Node, .NET Core, Python, and Go. There are some closed-source and/or mobile SDKs that are of comparable size, but in all of those cases, the platform and ecosystem is under the close control of the maintaining company and generates them a lot of money. This is not the case with Java. 2. To provide that, Oracle employs several hundred developers who work on OpenJDK full-time. This cost tens of millions of dollars per year. Of course, because it contributes so much, it naturally invests more in the parts of the platform that are of interest to Oracle (e.g. more server-side, more Intel CPUs etc). I don't know whether Java is profitable for Oracle or loses money, but no programming environment generates a lot of money these days. 3. OpenJDK serves as the foundation for either the entirety of or a core part of the backbone of not only huge non-tech businesses, but tech companies like Google, Apple, IBM, Netflix and many others. However, their contributions to OpenJDK are quite small. One company (other than Oracle) that makes relatively significant contributions is Red Hat, which is by far smaller than the ones I mentioned. So I think that in general, instead of complaining why Oracle doesn't contribute even more, it may be better to ask why all those large companies contribute so little. &gt; JavaFX no longer shipping with the JDK JavaFX was never part of OpenJDK, and in any event, I don't see how including JavaFX as an external dependency is "messing things up." &gt; no firm guarantees for any LTS versions There are very firm guarantees. Oracle has committed to patches at least for the first six months. After that, there's paid support, but anyone is more than welcome to backport patches. But one thing is key here: Oracle does not consider (in terms of our development process) the LTS releases to be major releases by any means. We think that the new process will make upgrades easier than before, but no one knows for sure yet how this will turn out in practice. It is true that 1. this is a change and all change is scary, 2. the transition to "Chrome versioning" psychologically impacts people (certainly those use to the old versioning scheme) to think of the feature releases as if they were major releases, and 3. Java 9, the last major release, was a big change and requires a larger upgrade effort than before. All of these combine to muddy the picture, but don't confuse uncertainty with "messing it up." &gt; Now it's just shoveling releases out every 6 months while introducing backwards compatibility breaking changes. Oracle has always "shoveled" releases every six months, with possibly breaking changes. It is true that the possibility of a breaking change in each release has now gone up, but I disagree with your view of the impact and think it reduces it. I've written more about it [here](https://www.reddit.com/r/java/comments/9swg1z/should_you_adopt_java_12_or_stick_on_java_11/e8sbg0w/). &gt; Can you give me a single example of how I would benefit from the new model? It is not my job to convince you in particular. I believe that *in most cases*, companies using OpenJDK will benefit from an overall easier path to upgrade and faster access to new features.
The new release model should not affect the backward compatibility story. The nature and amount of change is not affected -- just the pace of introduction. The last Java major release, JDK 9, did have a relatively big effect, but it was both necessary to make the platform maintainable in the future and unrelated to the new release model.
Thank you! I appreciate, I surely will need the help in a bit now that I'm getting back into the whole programming thing.
Yeah, measuring software performance outside of production doesn't make that much sense when the JVM does so much adaptive optimisation.
This is the right answer.
If you're using gradlew to build, I noticed the version that spring initializer defines is 4.8, which doesn't work with Java 11. Run this to upgrade your gradlew: /gradlew wrapper --gradle-version 4.10.2 --distribution-type bin
If you like faffing about with whitespace and trying to do basic things arse end backwards, if you like to try to write a compiler in unit tests to make sure you have no typos, got an errant space, line break, using the parameter type, go with Python. Otherwise, if you want to get shit done painlessly go with Java. If just writing a 10-20 line script, python may be acceptable, but if writing any sizable program that will need to be maintained, refactored, added to and improved, save yourself lots of pain and go with Java. 
Nobody ever talks about Dynatrace. Does javit have any thoughts on that? I'm interested in second opinions.
Is this event he right question? If you are not going to pay there is not LTS for you. Only painful migration issues are removals of deprecated features. You do not have to adopt new features (i.e modules). Lock your compile target to java 8 if you want to remain compatible with it. 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I'm really excited that with the next Java version I'll be able to turn on continuous profiling for our apps. Could have technically done it sooner, but my company isn't about to pay for the commercial features of java.
It looks like in your [submission](https://www.reddit.com/r/java/comments/9tbac4/cannot_find_symbol_error_in_netbeans_ide_82/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I generally agree with most of your points but here is some of my thoughts &amp;#x200B; To be exact: by 'system' I consider only domain part of application ideally in pure Java without any frameworks influence. &amp;#x200B; &gt; I'd like the tests to cover everything and run within seconds. Most unit tests use Mockito to mock some dependencies and creating mocks requires time. When you use 'in memory version' of your system (if possible) you probably create your objects only by using \`new\` keyword which is pretty fast. Open question is when your application is too big to be created on every test. I believe that for micro-service scale and small monolith it's worth it. &amp;#x200B; &gt;Let's pick up your example. For scheduling the 'result fetch' we would use a scheduler library like Quartz. That means we end up with actually testing Quartz, which has tests that it is scheduling correctly anyways. Not exactly. We test whole scenario, where scheduler library is only one step of it. We still check if all connection between components are correct and if result is correct. &amp;#x200B; &gt; When doing more complex things, you end up simply passing down the time. This approach is generally correct but what if we treat time as normal external dependency like data base? (expect realtime systems but that's different story) Here is whole idea of my library. You just use the interface providing time-related operation like most of projects do with data bases. Instead of passing current time as method parameter (which is ok but escalate parameters number) you pass time source as system parameter (like in hexagonal architecture). I thing that some ideas are now consider as anti-pattern because we don't have proper tools to implement them correctly. 
&gt; They aim to support LTS releases (such as 11 and 8) for a long time. AdoptOpenJDK do not aim to support LTS releases. *If* people backport the patches in OpenJDK, AdoptOpenJDK will build and provide binaries. 
I'm experimenting with YARG: [https://github.com/cuba-platform/yarg/wiki](https://github.com/cuba-platform/yarg/wiki)
Why not cron jobs that stores the answers on database, another service that queries the database for those answares and pushes that response to client? 
Who in this case is responsible for task distribution? Yep, I can use an MQ for it. I can even push answers back to 'result' queue without any cron jobs. May be I'm wrong, but it is the wheel reinventing.
&gt; an overall easier path to upgrade and faster access to new features Can you explain how it's "easier path to upgrade"? I don't see how having to spend resource in upgrading every six months with higher number of backwards compatibility breaking changes can possible make things easier. And upgrading is something that *I don't want to do*, it's 100% wasted effort. I want my existing code to keep working and get benefit from security and performance upgrades to the underlying JVM without having to change anything. The new model significantly increases my costs in terms of keeping up with upgrades. Which, of course, is exactly how Oracle will make people pay them for the LTS. Basically the Oracle business model with Java now is to force a high and continuous upgrade cost onto developers with the 6 month cycle, then sell an LTS version. As long as the LTS version cost is less than the high upgrade cost, people will pay it (while moving to other platforms for new projects). As for new features, I used to choose Java because it offered a stable set of well thoughtout features. I don't want or need new features every 6 months. &gt; it's too soon to pass judgment on the new release model... there is no need to make any firm decision right now Wrong on both counts. I can, and have to, pass judgement on the platform's future all the time. I need to pick the languages and platforms for new projects all the time. And with these changes I don't see us starting new projects in Java. So once again, what are the *benefits for me* of this? I don't see them. I need hard technical arguments, not some vague fluff about "new features" and "easier upgrades".
Javadocs for all projects that I’m aware of are published as part of every build. That’s certainly the case for Boot. If you have examples of where that’s not happening please let me know.
Give Hazelcast a try, it's most open source, really easy to use with good docs and they have the exact solution for your scenario. You just drop some microservices with Hazelcast and they'll comunicate themselves under the hood and then just send the execution job, they'll balance the job themselves and give a result. [https://docs.hazelcast.org/docs/3.11/manual/html-single/index.html#executor-service](https://docs.hazelcast.org/docs/3.11/manual/html-single/index.html#executor-service)
Who really cares about true native look and feel in 2018? Haven’t people gotten used to web and browser-based (e.g. Electron) applications, which don’t look native anywhere? I think, functional, simple, and beautiful is what matters to most end users. These requirements can be satisfied with JavaFX.
\&gt; Tasks should be Serializable since they will be distributed. It's impossible in my scenario. I should have mentioned it in the post.
The LTS release only really exists for paying customers of Oracle JDK. Oracle's OpenJDK builds will all stop being updated once there is a newer major version available. So, once Java 12 is out, there will be no more OpenJDK builds of Java 11 from Oracle. They will continue to patch and provide Oracle JDK builds of Java 11, but that is for paying customers only. All that would be a problem* if only Oracle provided a JDK. Fortunately, IBM provide OpenJ9 (which has a different JVM to HotSpot), Red Hat and Azul both provide OpenJDK which will be largely the same as Oracle JDK. To get builds of either HotSpot-powered OpenJDK or OpenJ9-powered OpenJDK, you can look to AdoptOpenJDK: https://adoptopenjdk.net/support.html AdoptOpenJDK was spearheaded by /u/karianna and has a few big sponsors. You won't get the kind of support that businesses would need for mission-critical stuff, but if you're a business who just needs a recently patched JVM to run some internal, low priority workloads then it would save a ton of cash to use their builds (which are probably fine anyway, they just have less of a guarantee). HTH *for businesses who need guarantees which come from support around e.g. security and stability
Try [failsafe](https://github.com/jhalterman/failsafe): ``` Connection connection = Failsafe.with(retryPolicy).with(executor).get(() -&gt; connect()); ``` Comes with an awesome DSL where you can retry/delay/timeout/abort/etc.. 
Java, of course.
&gt; I don't see how having to spend resource in upgrading every six months with higher number of backwards compatibility breaking changes can possible make things easier. I explained it in the comment I linked to. The rate of breaking changes is constant. What is different is their rate of release. &gt; And upgrading is something that I don't want to do But you have to do it either way. You just now have the option of doing it more gradually. &gt; I want my existing code to keep working and get benefit from security and performance upgrades to the underlying JVM without having to change anything. Again, Java will remain largely backwards compatible, just as it used to. Java 9, the last major release was different, but beyond that the rate of things that *may* break your code is the same as ever. If you've never experienced breakage, you likely won't now, either. &gt; The new model significantly increases my costs in terms of keeping up with upgrades. I think it reduces the cost, and it was designed to do that. But, again, only time will tell what happens. There is no way you can tell for certain that a model designed to reduce the cost of upgrade will have the opposite effect. Don't confuse the necessary changes in Java 9 (which was still under the old model, BTW), with the new release model, which is something else altogether. &gt; I don't want or need new features every 6 months. That's great, but many people do want a particular feature, and this way they'll have the *option* of using it whenever it's ready. If you don't want new featues, don't use them. &gt; I can, and have to, pass judgement on the platform's future all the time. That's fine, but there is no way you *can* pass judgment on the future effects of some change without any experience which, frankly, no one has yet. And again, don't confuse the effects of Java 9 with those of the new model. &gt; So once again, what are the benefits for me of this? An easier upgrade story. &gt; I don't see them. They're hard to see because the ecosystem hasn't adapted yet, which is why I think everyone should relax, wait, and see what happens. &gt; I need hard technical arguments, not some vague fluff about "new features" and "easier upgrades". But the new model is precisely about a better upgrade story. Your counterarguments are of precisely the same kind.
Still crying about JavaFX. Just installed Java 11 on a Linux computer and tried to run an app I coded in Java 8, of course it didnt work... sad.
Correct - it will be up to upstream maintainers like Red Hat, IBM et al to do so. We expect that they will (certainly for security and stability, but probably not for “new feature X”)
just include the [openjfx dependencies](http://openjfx.io)
Doing that right now, still, I miss my bloated Java 8. God bless it.
Maybe I misunderstand term scalable but I just want to have an ability to add more workers on demand.
yeah... one nice thing about this though is you can use openjfx with openjdk quite easily now instead of hoping it was packaged with your openjdk. also, you might be able to use openjfx with openj9 (haven't tried this yet)
Only good thing about removing JavaFX from the JDK, now they force you to really make your app run everywhere lol.
Maybe a spring batch job(or whatever you want to use to fire off your job) that gets your data and dumps it in apache poi and then you can customize it to your desire.
You have a production server with an ACL open to google drive?
Onboard BI tooling? 
No, it worked great on JDK 8. It works like *heaven* on JDK 11.
You could use aws for this. A load balancer in front of a bunch of worker ec2 instances in an autoscaling group would give you distribution and the ability to control the number of workers. As for returning a response for long running tasks, a common "cheap" pattern is to return a response immediately with a link to where the result will be available and have the client poll that link meanwhile launch the processing asynchronously. 
Is that something like AppDynamics?
Depends on what kind of desktop applications you are developing. I have developed a VPN client for IOS and macOS . The only choice I get is objective-c and swift..
This is exactly what I was looking for. Thank you!
Could look at JavaFX if you want to make graphical applications in java. It has an almost familiar flow to Android but uses actual jdk java instead if android java. You could even use intellij idea which is what android studio is based on. 
If you can give us some more clarification of some areas you’d want to look into, more backend sort of work or a multiplatform application, there’s so much you can do
I would love to make an api... or something like that. I'm up for anything, I just enjoy learning.
Whatever is of interest of you, a reimplementation of something technically challenging, a desktop application interfacing with some sort of personal database, etc.
Maybe look into r/libgdx, make a small game. 
&gt; To be exact: by 'system' I consider only domain part of application ideally in pure Java without any frameworks influence. In our code base, in the domain part, there is no need for time lookups at all. I think we need to look more on specific usage scenarios and see what are the alternatives and the pros and cons. 20 years ago I started with code like that: ``` public class Event { public String name; public Date presaleEndTime; public Date presaleStartTime; public String getName() { return name; } public boolean isPresaleStarted() { Date now = new Date(); return !now.before(presaleStartTime); } public boolean isPresaleEnded() { Date now = new Date(); return !now.before(presaleEndTime); } public boolean isOnPresale() { return isPresaleStarted() &amp;&amp; !isPresaleEnded(); } } ``` That is nicely structured code with short methods for one purpose. But whenever the code checks `isOnPresale` the system needs to make two clock lookups. Chances are low that the time changes in between, so making two lookups is obviously redundant. If the time changes between the lookups, the result may become inconsistent. That's something that could happen with code like this, but you have a very hard time to test for that situation, even with a library. We have found two ways to deal with problems like this: - pass on the actual data and move the time lookups to some functions that are called when needed. Maybe even up to the user browser. - Most of the code, values change at specific point in times. So reevaluate predicates based on time, only when they about to change. &gt; I thing that some ideas are now consider as anti-pattern because we don't have proper tools to implement them correctly. Even with the right tool you can never test every situation, especially if you do more then one time lookup. If the clock lookup is allowed, the code is not deterministic based on its input values. To be able to test your code you make the time deterministic and fix it. However, that does not resemble the real undeterministic behavior of time (and the OS scheduler) in the production. Better make your code deterministic on its input values. BTW: In libraries that deal heavily with time that's another story. Early this year I implemented exactly the same library as you did to be able to test the timing behavior of cache2k. &gt; you pass time source as system parameter (like in hexagonal architecture). The idea of the architecture is that it gets events when there is new relevant input data for the application. Depending on the timer resolution, that would be an event, e.g. each millisecond. 
Can start with spring https://spring.io , it has many modules and don't anything else for the backend of an application, also there are many tutorials over the web of how todo start with it.
I've made 5 with libgdx. I want to branch out to utilizing Java (or C#) in other ways.
That sounds great, but what? I'd like tutorials that are structured more than "whatever you want" I'd prefer "We're going to make x " type lessons. Thanks.
I actually working in a finance company and we have pretty much reporting. Overall about 200 reports per day on multiple SQL Server instances and I can say - don't use Java for BO reporting. Java is a great solid language, I actually Java developer, but still - don't do that. My suggestion is some kind of script language. If you want my opinion - Python is a great choice. Let me try to elaborate and provide some insights. 1. Report usually requires not so many actions: pull the data, join it(usually on DB level, I have reports with 20+ join in one query to get plain data sets ready to process), reduce it and save result. You'll spend long time in Java doing not the report, but ritual around it. Create project, inject libs in pom, create DTO, dance around with setup of POI, spring, scheduler, write the result either injecting apache commons or by dealing with 5 layers of buffered writers. As a result for 10 rows building report you`ll write 500 handling Java. In Python you can start with report right away and write very little "infrastructure" code. Packages like csv coming built in and requires 1 row to start writing the file. Database connections handled in "base" script which is injected to all other ones. Just place it in root folder, put DB, mail, SMS, FS functionality here and reuse without rebuilding of all dependent projects when you decide to change one row. 2. Changing the report. With Python just go ahead, change the file, test it and that's it. It's not applicable to big companies with strict rules about touching productions, but for mid size businesses it gives you tons flexibility. With Java you'll need to at least rebuilt and move new jar. If you'll have "base" jar with common stuff just imagine rebuilding all the reports after each change in it. 3. "Do it other way this time". You will get request to run one off reports time to time and with Python just copy script to another folder, change it, run it, forget about it. No changes to models, no builds, no dancing around row mappers or JPA. 4. You'll never see 15Mb report which doing 1 query and write csv, but have spring and tons of apache libs inside. 5Kb scripts is your choice. 5. Use native windows scheduling. You will be able to run it as correct win user which is important for security, and changing schedule Wil be waaay easier. Just compose daily, weekly, monthly, quarterly cmd files and list scripts to run inside. After that just run cmd from win scheduler. Easy to add new script to schedule, easy to find schedule for script, because schedule is outside the script and not compiled. Easy to provide report on reports you're running(you'll need it as well, trust me) Overall, person who write your reports on shell was a wise person.
From your other comments, maybe you should try building a RESTful API of some kind. You should look up “building restful services with spring” or similar. Spring has a wealth of tutorials, but be warned that there are a lot of outdated tutorials out there due to how long-lived and popular the framework is. Josh Long is a well known speaker about Spring. I’d search for courses by him. 
Yes. I think we assessed those two and chose Dynatrace. Dynatrace is _very_ powerful, but it's also difficult and cumbersome to use and _very_ expensive, and now we face resistance every time we entertain auxiliary monitoring solutions, even highly regarded open-source ones.
In a cloud.
Won't a workers' fault lead to a task loss in this case? The "cheap" pattern is interesting anyway.
Apache Commons CSV Apache Poi for Excel Personally I'd say slap an ELK stack in there and get you some analytics. *\*Slaps a stack of Elasticsearch, Logstash, and Kibana\** *This bad boy can hold so many documents*.
You should work from the requirements down to the technology, not the other way around. What is the goal of those reports? You could for example just use something like Tableau which means all you would need to do is just push your stuff into a SQL database. 
Then tasks should be serialisable. 
You generally won't find tutorials at that level. As a developer you're the one who goes from "I need to build an MP3 player" to "I need a JFrame with JPanel and button X, Y and Z". Tutorials will almost always be in the second generic category. The process from going from A to B can't really be taught in tutorials; that's just practice. 
If all you need iz csv no third party libs are required imo. 
I mean I can't serialize the task's code (some of frameworks require that) only the task's description.
If you only want CSV, poi Workbooks have a lot of overhead. I really, really advise against that. And writing CSV is really simple, `Files.write(strings,target)` and your done. It's the parsing that may be hard, but that is apparently not the issue.
https://start.spring.io/ click the bottom full version and check out the options
There's no point arguing about this. You clearly have zero idea about how and why Java is used in reality and by real businesses. You're demonstrating everything that is wrong with Oracle. You have not been able to provide a single hard technical argument and keep telling me my judgement (backed by many decades of experience in software engineering) is wrong and not educated, while having no understanding of my business or requirements. There is a reason why Oracle is widely seen as the cancer of software industry.
We use [JasperReports](https://community.jaspersoft.com/) here, which integrates very simply with Java and allows you to template, integrate, and run reports with or without software intervention. It produces HTML and PDF from the same template, and lets you very specifically lay out your reports.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
" Is performing AOT compilation a valid optimization for lamda runtime" - no, you can't control JVM on AWS side.
Lots of good suggestions here. However CSVs can be slightly more complicated than some commenters suggest especially with special characters and values that contain a comma or new line. Only slightly but still annoying at times. If it’s specifically marshaling or unmarshalling of csv you want help with I have really liked Univocity library. It’s light and fast and usually worth looking at at least for consideration 
Still on Java 6 :D 
I am sorry you feel this way. I may not have many decades of experience in the industry, but I do have over two, and also think that while we could argue back and forth and each have different opinions, I simply cannot give you hard technical arguments without data, other than tell you that the rate of change in OpenJDK is not increasing; we're only releasing those changes in a more gradual manner (unless another company were to fund hundreds of more engineers). I cannot conjure further data about a model that hasn't been in existence long enough. Nor could I recommend a specific approach to your business, whose particulars you have not described, but if you're looking for some advice on your particular business needs, perhaps Reddit is not the right place to get it.
Not sure if this fits your usecase but since you mentioned you need to get a delta, try checking out tablasco. It analyzes differences and generated html reports for the breaks.
It really depends on what are you planning to do with that knowledge in future. If you're thinking about data science, scripting of any kind, tiny web dev - you should probably go with Python. If on the other side bloody enterprise is what you are looking for, then definitely Java. Since right know, you really don't care about such things as community, ecosystem etc, but it's more about generic programming, i would stick with Python. 
If you're talking about isolated integration tests(you launch you service with all dependencies and then there is some suite that runs, let's say REST calls, to verify correct working), then it's up to test cases. It mean's that they interact with system same way as user would, so no any kind of DB resets for sure :). So test would be like: 1) create users (returns id), 2) using that id -&gt; get user details etc. So basically test doesn't care about DB state, because it creates own. On the other hand, if we are talking about internal testing, then you can do whatever you want. In some cases you might want to just mock entire DB (when testing business logic). In other cases, when you want to test some query, for example, then the only thing you need is DB and some kind of service, and everything else is not initialized at all, or just mocked. In that case, there is no need to cleanup DB tests, it's just that a test itself is transactional. External services, better be mocked all the time in integration tests, since you don't want you tests to fail 50% of time, because of some non-determinism. Leave it for stage env, where you can test it manually, or implement some kind of schema validation/basic url and credentials (ping) testing.
That's a little bare bone. I advice you to try to do some I/O stuff and look at Design patterns. Also learn to use JUnit as this is probably the main thing you'll be doing at the beginning. I highly recommend the caveofprogramming.com guy as he is doing extremely "job oriented", practical tutorials.
I went to school for a CIS degree (college of business). I joined AITP (Association of Information Technology Professionals). I think having completed Java I &amp; II, Database I &amp; II, Systems Design I &amp; II was all they were really looking for. That being said, I didn't actually do any sort of specific programming test during the interview. I took a CPAB (Computer Programmer Aptitude Battery). Basically, it was a test that tested in several areas like quick math, vocabulary, and flow charting. They didn't give you enough time for any section (hence, *battery*), but I still think I did well. After a few interviews, I was offered an intern position. I'm still at that same company today (4 years later) as a Senior Software Engineer. Entry level programmers at my company aren't actually required to have a degree but it helps. They want you to be able to show your experience. Every company is different though. Just practice your skill set. Expand on Java (I recommend Java + Spring Framework + Gradle + PostgresQL + JUnit testing/Spock Testing). Join IT clubs if you can. Make friends and network in your courses and ask if they've had any luck with internships. Start a github account and upload some sample projects there. Create a good resume and practice your people/interview skills. I never had a great GPA and I really didn't know how to program until I started the internship and struggled for months. Just keep at it and don't give up. You'll get your foot in the door eventually. &amp;#x200B;
It depends on company, but mostly it's your ability to solve problems and basics(network, memory, FS, scheduling, etc) that gets you that internship. For that, basic data structures and algorithms that operate on them would definitely help (understanding how they work, instead of memorising is great). Also try to create something bigger using all that knowledge you have, that would help you to understand how to compose those 'lego pieces' into actually working software. There are tons of tasks for practicing like (tic-tac-toe, etc). It won't teach you how to build real-life software, but at-least you'll get that OOP concepts, which is a must in Java world :)
hmmmm, familiarity with the language is a great plus. However, banging out a hello world or fibonacci method is nothing like coding in the real world. My suggestion would be to get involved in an open source project, or even put together a simple web app on your own computer. That will teach you how front-end code, server-side code, and databases all interact together. It will also teach a little about deployments and packaging. Finally, and this advice goes beyond java programming, go into an interview with confidence. Know that the qualifications for an intern are not that you are an expert in all things, but have a thirst for knowledge and the confidence that you can pick things up quickly. 
&gt; I have familiarity with selections, math functions, characters, strings, loops, as well as single and multidimensional arrays # &gt; Java + Spring Framework + Gradle + PostgresQL + JUnit testing/Spock Testing Don't you think this is a little... excessive?
Both. For cross cutting concerns like database entity manager setup, the database connection pooling, executors, schedulers, etc. I use XML config. Then annotations in code for injection and java config for environment specific configuration (local, stage, production).
To be honest not much is expected of interns in terms of knowledge or experience. I was a sophomore when I got my first internship. I barely knew what a database was at the time... If you can show that you're willing and eager to learn, have a positive attitude, can work independently, and have a strong work ethic (no disappearing at noon, etc.) then you'll be fine. They're investing time in you by bringing you on board - so being taking the job seriously and being eager to be involved will go a long way. You may not even be doing code as you think of it at first (my first internship started me out doing QA) but don't despair - it can be difficult to bring even an experienced software developer up-to-speed on a project. Most young programmers don't realize that "knowing how to code" is about half of the job. The rest of it is working with others, understanding business requirements and translating them to code, troubleshooting problems, etc. And those are the things an internship would teach you. The best way to find out is to try. Go apply for things! Let them decide if you're qualified. Good luck!
Yeah - kid's a sophmore looking for an internship not an entry-mid level developer job. Knowing those things would help - but I'd be \*super\* surprised if I brought on an intern who knew them.
Hi, good article. The docker image for DynamoDB is public or do you have to run it in a AWS environment?
@Configuration annotated clases and application. yml files 
I guess you're right. I'm just thinking back to things I wish I knew a little bit more about when I started as an intern. I came in without enough knowledge and it was the most stressful few months of my life.
Stop pretending we don't dig this shit :P
I suggest two options.Firstly,It is open source named Apache POI. Second It is enterprise named Aspose. 
Modules have two advantages: strong encapsulation and reliable configuration. * Strong encapsulation ensures that no other module (unless its a "friend" module that you explicitly allow) can access your unexported packages, even with reflection, and that you don't accidentally use other module's internal classes, that may change at any time. * Reliable configuration helps you escape from "classpath hell." The classpath is sensitive to the order in which JARs are listed, and can cause mysterious problems in the event of the same package appearing in more than one JAR (AKA split packages), in which case classes can be loaded from somewhere you do not expect. This makes your deployment configuration brittle. Modules help ensure that every package exists in only a single module that your application uses. Both these benefits help you build a robust and well-engineered application. Code that will benefit most from modules is large applications/libraries, with lots of dependencies, or libraries with lots of clients.
The main thing you need to be as an intern: - be a quick learner - be dependable Everything else flows from that.
I'd say just apply and see. Spring, Design patterns, Junit and all that is all great and you'll most likely have to learn them sooner or later if you want to stick with Java in professional world but right now, just apply and see what kind of responses you get and work on that. You are applying for a programming internship as a student, I'd assume part time to work alongside your studies. If the hiring managers are sane, they aren't going to expect you to be too familiar with stuff - that's what the internship is for, learning as you go. Unless you are aiming for internships at the tech giants, most small to mid sized companies shouldn't expect you to know much. Oh, **make sure you know the basic usage of GIT** (push, pull, fetch, commit, branch, merge, all these should be familiar words to you) and the **basics of a build tool, Maven or Gradle**. There's no way you can avoid those, even if your task will be as simple as going through the code and apply style guidelines to existing code.
it's beginning to feel like your username is on point ... serialize a task that calls "the task"
Thank you! I'll improve it, for instance add tests
I don't think they want to start counting android phones.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [Java's Future-Looking Projects: Panama, Loom, Amber, and Valhalla \[x-post from r\/java\]](https://www.reddit.com/r/programming/comments/9tmz7o/javas_futurelooking_projects_panama_loom_amber/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
There is a bit more to CSV than that. What if your string has a comma in it? &amp;#x200B; Use Apache Commons CSV 
Seriously though, the (smallish) project at my work is currently tested on both 8 and 11. 11 support required just some dependency updates, unblocked when ASM 7 had been released.
I usually look into Oracle Enterprise Manager, and if I don't have that (or work on other databases), then I use some SQL scripts to find me the top statements. Most performance issues are SQL related from my experience.
Yeah same, not wanting any of that again. 
I wrote this for the company Nirmata a few years back - they're still using it. Note: it requires a ZooKeeper cluster so it may be too heavy weight for you. http://nirmata.github.io/workflow/
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
It would make sense that OpenJDK just add support for making native binaries at this point
that's what graal's AOTC is for
It is enough.. you would be an intern.. expected to do some tasks and learn as you go. Best to learn on the job as it will provide way more valuable experience than what you learn in school.
Because a 1h20m video is not the densest way to absorb information: * 7m30s Doing too much in a single lambda * 16m30s Returning a stream * 30m00s Not consuming a stream * 34m00s Mutable Objects * 46m30s Overusing `forEach()` * 51m30s Order of operations 
Yep. It was me about year and half ago. It comes with big pain first, but as a result you can use tool which is fit your needs way better. But yeah, learning Python after Java wasn't so nice and fun. I can relate. 
I'm the owner of this JEP - AMA! This is mainly about co-locating and integrating existing microbenchmarks of interest to OpenJDK developers, so I'm somewhat confused seeing this at the topof /r/java - maybe I've underestimated how many OpenJDK devs lurk here? ;-)
Maybe there are not so many JDK developers here. But its interesting for almost every developer how the performance changes between JDKs and that there is not a big performance regression.
What is the intended target hardware, especially what is the minimum core count?
You should be using OpenJDK instead of Oracle Java. 
This has been answered many times, but, essentially, OpenJDK remains free and without restrictions. Use OpenJDK and it’s all good.
thanks for the quick reply!
thanks!
Is the convenience really worth the performance penalty?
&gt;Build tools and IDEs: Will your IDE support each new version on the day of release? Eclipse **never** supports a new version on the day of release. It always seems to come as a complete surprise to them.
Books are great, but the more hours reading and writing code the better.
What performance penalty?
the overhead from the streaming APIs
Maybe for large collections, but for small ones it seems to be much slower
arrays ftw
Arrays are strict, so anything with multiple steps is going to require multiple intermediate data structures. Lazyness lets you skip that, which is dramatically faster. 
Local variables?
I'm just saying compare apples to apples. I wrote a lazy, on-demand decoder without any exotic JVM trickery. Between good coding and good compilers you have all the laziness you need. Don't do extra work is rule number one of writing efficient code
If it's a decent company they won't expect you to know anything outside of the stuff you get in a typical CS degree. It's an internship after all; not a job where they expect actual experience with actual production software. IMHO be careful to not dive too deep in all the Java ecosystem specific stuff. While it's great to get some experience using JUnit for example (unit testing is a skill you can apply in any job), I would not suggest you dive too deep into huge frameworks like Spring, and that's coming from someone who's using Spring daily. Focus on the stuff in our education first and foremost. You'll be able to apply that knowledge to almost any development job.
&gt;I wrote a lazy, on-demand decoder without any exotic JVM trickery. Just a few if-thens. Yeah fair enough, writing your lazy data types as needed makes sense. But streams don't rely on any JVM trickery - they're just library code like any of the multitude of lazy collection libraries out there. Writing your code could also just be not-invented-here syndrome. (Mind you, Java streams are shit, so I wouldn't blame someone for rolling their own or using a third party implementation) &gt;Between good coding and good compilers you have all the laziness you need. Don't do extra work is rule number one of writing efficient code. Well not really. Arrays are strict. If your function returns an array, it's returning a strict data type. Any laziness inside your method has been fully forced by the time it finishes, meaning you can't compose that laziness (Which is the point of lazy collections) &gt;I mean hell, assembly is as fast as it gets and that's dead simple I suppose that depends what your working on. Lazy streaming non blocking IO would be quite difficult to do cleanly in assembly, yet absolutely trivial in Scala. I'd wager the Scala implementation would be both dramatically simpler, and faster. 
Why, they said devices running java, and android for sure run java 
Only seems useful for online algorithms, honestly. Otherwise how does it get any lazier than this for (int x : integers) if (x != 0) return x + 1;
In that case by all means use JMH to see what is the most efficient way of doing things. But even there it generally depends a lot more on the algorithmic complexity of what you're doing than that approach you take. Like going from O(n) to O(log n). I have been on an interesting project where we did a lot of CPU bound stuff and that's definitely a place where you try to squeeze out as much as possible (and where going for for-loops over streams will make sense), but these situations are rare and should not just be applied to 'normal' code.
Assuming `integers` is an array, that's short circuiting, but not lazyness. To be precise, when we talk about lazyness in terms of streams or lazy collections, we're talking about lazy evaluation. Imagine that `integers` here is the result of calling another function, and let's say it returns a million values via an expensive calculation. Presuming `integers` is an array, in the example above we stop evaluating if we hit a non-zero value. But we still have to generate the entire collection of `integers` and allocate an array to store it first before we can iterate over it, even if we end up stopping on the third item. If instead `integers` was a lazy collection, a stream, or even just an iterator, the other function would only evaluate as far as needed to generate the values this function asked for. Basically like a coroutine. This lazyness travels all the way up the stack, so no matter how many layers you have in between, you're still only generating as many values from the original function as the caller needs, and don't have to allocate any intermediate memory for buffers along the way. 
[The license](https://www.oracle.com/technetwork/java/javase/terms/license/javase-license.html) states that you can use their commercial binaries free of charge "only for the purpose of developing, testing, prototyping and demonstrating Your Application". The exact definitions are up to lawyers to decide, but I don't seriously think that Oracle would be interested in your use of their commercial JDK if you're not deploying it in a production environment and making money from it. Be aware, thought (again from the license), that "Oracle may audit Your use of the Programs", so even if you're not using it in such an environment, but they suspect you do, you could get a knock on the door (again, not terribly likely, but they reserve the right to do so). The various OpenJDK binaries (including [those from Oracle](https://jdk.java.net/)) don't have these licensing problems, being licensed instead under the GNU General Public License. Which binary to go for depends upon your needs, but I don't really see any need for Oracle's commercial binaries unless you're a company looking to buy a support contract.
Typically you'll need at least one core.. :-) Most microbenchmarks are simple, testing that some method can be optimized as we hope. These should be as interesting to track on a single-core Raspberry Pi as on, say, a 256 core server. Some are about exploring and exercising scalability bottlenecks, so while they can run on anything, they won't be very interesting on anything but a multi-core machine.
I'm actually in the same spot. Although my knowledge is probably wider than yours (I know to work with all you mentioned, spring, databases, hibernate etc) but I dont have a degree. Pretty much self taught. I wanted to apply as an intern and actually work for free till I am actually worth a salary.
Nice article! While I agree that Docker is the way to go, I fail to see how it was easier to set up your example than using a local DynamoDB library - starting them up requires a one-liner in both cases but installing Docker on your local and build machines, plus adding a dependency in your build script vs just adding a dependency? Hmm, doesn't really add up :) Also, why not use a dynamic free port instead of a fixed 8000 port? Btw, if you're using a lot of AWS stuff, give localstack a try, great stuff for both integration testing and local development, bundles all the most frequently used AWS services into one library / container.
I think we often understate how many improvements and how few regressions there are in a typical OpenJDK release. Still, regressions do happen. Most of the time I think it's been when there are no benchmarks covering some library or feature (or when there's not been enough resources around to run some benchmark regularly -- or early enough). By increasing coverage we can reduce risk of regressions going forward, and by collaborating with the wider OpenJDK community with both authoring new ones and running more tests on more hardware, I believe we'll see better results over time. One intent of this JEP is to make it easier for OpenJDK projects to write new microbenchmarks when and where code is actually being changed (amber, valhalla etc), which will help getting early detection on issues as new features are being developed. A disclaimer: microbenchmarks are great tools to reason about changes in isolation, but they are typically bad predictors of real performance in real systems. This is due many reasons. Examples: caches fill up differently in a large, mixed environment; GC and other events will happen at completely different intervals and their extent may vary wildly; JITs will optimize differently depending on what classes are loaded and used at call sites etc... Some of this can be offset by writing _better_ microbenchmarks, but that's _really hard_ (and may make your micros less useful to use as precision debugging and profiling tools). That said, we do look at results in aggregate and feel some (false?) confidence that if we're improving in most micros we're probably moving in the right direction in "real applications", too.
Any contract, such as a software license, is as good as its enforceability. The problem with open sourcing your secret sauce under GPL or something similar, when you are a little guy and someone else uses that code as if they created it themselves, is that you will have a hard time chasing them down. Litigation costs are way too damn high and it's just simpler and easier to obfuscate your code and move on. A more realistic approach is to build fully free and open source stuff that you are fine with people copying and redistributing, and provide a "pro version" with more features for commercial customers.
We really need a "sticky", pinned thread in this subreddit with essentially this answer
&gt; While I agree that Docker is the way to go, I fail to see how it was easier to set up your example than using a local DynamoDB library - starting them up requires a one-liner in both cases but installing Docker on your local and build machines, plus adding a dependency in your build script vs just adding a dependency? Hmm, doesn't really add up : I wasn't aware that there were libraries to start DynamoDB embedded actually. I mainly did this because I was working on a service where a previous maintainer downloaded and installed DynamoDB locally on the machine. This one is more maintainable. But if there's a library where you can start DynamoDB embedded then yeah; definitely give it a shot! &gt; Also, why not use a dynamic free port instead of a fixed 8000 port? It actually uses a dynamic free port. The 8000 port is internal to the docker container. &gt; Btw, if you're using a lot of AWS stuff, give localstack a try, great stuff for both integration testing and local development, bundles all the most frequently used AWS services into one library / container Thanks! Will check it out :)
&gt; it's good to know about alternatives. Definitely agree there. Thanks :) I wasn't aware that this 'local' docker could be ran embedded. But I have some really bad experiences running embedded Kafka for example so I prefer using TestContainers. The only big downside is that you need Docker installed. 
The JDK distributed by Oracle used to contain a mix of free and commercial features. Whether or not you paid for it depended on which features you used. As of JDK 11, there are no more commercial features, and the complete JDK is distributed under two licenses: a commercial license for those who want to purchase support, and a free license for those who don't. The JDK with the free license can be downloaded on [jdk.java.net](http://jdk.java.net/).
It looks like in your [submission](https://www.reddit.com/r/java/comments/9tvbto/strange_synchronization_technique_in_java_8s/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Without going into too much detail: yes, we automate quite extensively. It'd be prohibitively expensive to run everything on every build, so we space out what we run over nightlies and promoted builds. When the system detects a potential regression we automatically do triage runs to weed out false positives: basically run the previous baseline and the current build again back to back on some machine. If the regression persists then we likely have something that should be looked at be an engineer. We can then semi-automatically do additional runs to zoom in on the exact changeset where the regression was introduced, run JMH `-prof perfasm`-style profiling, do JFR recordings etc, depending on what seems to be the root cause. 
Oracle and google have been in an ongoing lawsuit regarding Google's use of java in android. If they started counting that in their marketing material it may? weaken their claim. https://en.m.wikipedia.org/wiki/Oracle_America,_Inc._v._Google,_Inc.
What you're saying is laziness is recursive or repeated short-circuiting. So, yes you would short-curcuit in nested for loops or recursively
What about investigative journalism and reputational damage? And it's not just about people making closed-source versions. It's about the small-time developer having to deal with the burden of pages and pages of legal demands, having to understand the case law behind viral licensing, having to produce binaries, having to commit ahead of time to never produce a closed source version, even ten years down the line... Who wants to make such a committment?
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
How do you store data between runs? Also, is this public available somewhere now? 
&gt;What you're saying is laziness is recursive or repeated short-circuiting. No. Laziness has nothing to do with short circuiting. 
What a joke of an article, they dont mention Cobol.
not an acronym, but definitely a 4 letter word
It actually is very in demand. Not nearly enough mainframe talent available for fintech needs
Sorry, I meant VOLUME.
Basically any language would work in this space it's just a matter of organizational capability to learn and deliver. The industry was laaaazy and went with what the were plenty of: Java developers. Source: I work in FinTech.
You would be surprised -_-
The industry needs cogs. Cogs are replacable. Start using specialized cogs and it gets harder to find replacements. The industry went with what was proven and what they could find more of.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Java doesn't compete with Cobol, but rather with .net or other open system technologies. Cobol is primarily mainframe.
What’s the difference between a mainframe and just a really big server? And I know plenty of people running Java on IBM mainframes.
The mainframe architecture (and CPU) is optimized primarily for transaction management. It can handle tens of thousands of transactions per second (disk I/O) , which is crucial for businesses like banking for example. It's different from a super-computer, which can make lots of calculations in a short time. You can of course install Java on a mainframe, like DB2 UDB for example, for the purpose of accessing the data much faster, but you wouldn't necessarily want to install a (Java) web server on a mainframe. 
Or it just requires a lot more Java programmers to do the same work that can be accomplished in python or C#. Or those ads are confusing Java with javascript. Or Java's really popular elsewhere and the banks are having a hard time keeping their Java programmers while the far more numerous cobol and pl/1 programmers can't find any non bank jobs. Or the just like tacking on Java in the ads In addition to whatever they are actually using. You really shouldn't trust any chart that has more than 100%. The only question this actually answers is "Which skills increase my chance of getting a bank job?" And it doesn't even really do that because it doesn't show that you the pairings between Java and other languages. There's no point in learning Java plus SQL if everyone's looking for Java plus python.
There are super-computers which are really good at writing too.
Almost every mainstream programming language has a good library to manage currencies and numbers in general.
Almost every mainstream programming language has a good library to manage currencies and numbers in general.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I did a project at the largest Dutch bank a few years ago and they were telling Cobol devs to either learn Java or go into early retirement. They are actively getting rid of them. People on these subs are really overstating the demand for Cobol devs. 
&gt; Java BigDecimal manages currencies uniquely from other languages. Yeah, it's not like C# has a decimal type built in or anything...
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Thanks for the tip, apparently the fifth ed. covering Spring 5 was released just this week. I will definitely check it out. 
It also compiles into a WAR file then? So this would mean that in theory it should work on GCP's app engine now then. 
You can create a war with Javalin now if you want, yes! Javalin can be plugged into your current setup like any other library can, you just create a root Servlet and call `javalin.service(req, res)` in it.
Nice, thanks for the quick answer! Spring boot is a bit heavy on there regarding memory usage and the servlet API is a bit too low level as an option now. 
The feature is very new, so please file issues on our tracker if you run into any problems: https://github.com/tipsy/javalin
On HDDs ;-) No, it's all running on internal, proprietary systems that are unlikely to be migrated into the open. And some proprietary benchmark suites have license terms that make publishing results... complicated. 
**Subreddit rules** + **No surveys, no job offers!** Such content will be removed without warning. 
Applying +1 only to one element in integers, not all of them, is laziness then, if you don't want to call it short-circuiting
Well, plenty of countries don't respect our IP laws.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I distribute my software under the AGPL and under a commercial license. I'm happy to give you my code for free if you fullfil the terms of the AGPL. If that's not an option you can also pay me as alternative.
I’d say build tools you can learn on the job - I did that in mu first java internship. 
I think whats most important is to understand the 4 principles of object oriented programming. Objects are the real meat of java and if you’ll struggle if you haven’t yet got a firm grasp on how they can be used.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Is it though? Now they’ve got to have a new team dedicated to a new LTS every year.
Baeldung is a really interesting java blog. Very recommended. 
Thank you for saving me time :)
Does anyone actually use javadocs to learn? I mean they’re helpful when you want to know a little bit more about the classes you are using but I find it difficult to decode how to use a new library by looking at javadocs alone. Is there a secret to it I’m missing?
It’s just aggregator of blog posts. Sometimes they literally copy paste content from docs
It looks like in your [submission](https://www.reddit.com/r/java/comments/9u7nok/please_help_with_coding/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Generally? FP is basically a religion at this point. "It's faster!!!!1!" On what grounds? Burden is on FP to prove its benefits before asserting itself to be superior to loops. Lazy evaluation is as simple as short-circuiting`if(A || B)`or `if(A &amp;&amp; B)`. You don't need a *thunk* (LOL). If FP is trying to redefine the terms, then that's news to me
&gt;Lazy evaluation is as simple as short-circuiting No it's not. That's not lazy evaluation. That has never been a definition of lazy evaluation. &gt;FP is basically a religion at this point. Willfully ignorant then. Got it. 
what did they do to angular. 
Even the wikipedia entry for lazy eval says short-circuit is referred to as lazy. Is it faster or not? Why are you backtracking all of a sudden? Sorry I'm not part of your cult (yet. please convince me though, lol)
&gt; Even the wikipedia entry for lazy eval says short-circuit evaluation is referred to as lazy. Eh..... I mean if you squint you could say that the internals of an `if` statement use lazy evaluation, but the end result is still strict. You can't "return" that lazyness to the caller. It doesn't escape the `if` statement. In either case, trying to claim that an if statement gives you lazy evaluation is completely missing the point of lazy evaluation. &gt; Is FP and Java streaming API faster or not?? Faster than what? There are use-cases where a stream would be faster due to lazy evaluation. There are use-cases where it isn't. In the use-cases where it isn't, the overhead is generally not significant. &gt; Why are you backtracking all of a sudden? Backtracking on what? &gt; Sorry I'm not part of your cult I don't care if you like functional programming or not. It's not for everyone and that's fine. I'm not here to convince you either way. Lazy evaluation, streams, and thunks are commonly used in functional programming, but they are also commonly used in imperative programming as well. You don't have to buy into functional programming to use lazy collections. &gt; Of course it's faster than the naive approach. Everything is faster then a naive approach. That tells us nothing. At this point we're discussing convenience again. Round and round we go. At this point I'm just trying to get you across the idea that "Lazy Evaluation" and "Short circuiting" are different things. &gt; And please edit your insult back to its original form Which one?
Well don't be offended if I think that your inefficient software is exacerbating global warming. By all means use FP in specific domains and for prototyping, but don't claim it makes Java faster when common sense tells us it can't. Lazy eval is a ridiculously blunt tool for optimization. Low-level languages will always be faster and more verbose. Next time argue the aesthetics, not the performance
&gt;Well don't be offended if I think that your inefficient software is exacerbating global warming I'm not offended. I just think you're naive and defensive. You've already decided it's stupid and anybody telling you different is just some silly academic. You claim it's wasting CPU cycles, when it instead provides a very useful pattern for whole program optimisation. I've spent most of my career writing Java, and would drop down to C when I needed more performance. I have far more experience writing hand optimised low level Java and C than I do writing Haskell, yet still find it easier to write performant code in the latter, at least for the problem domains I tend to work on. To say that one is faster than the other is completely missing the point. It's like trying to say a screwdriver is faster than a hammer. It depends entirely on what task you're trying to solve. Functional programming is just another tool in your belt to solve problems, and it's ridiculously good at a lot of things. If you don't like it - that's fine. But why is it worth going to so much effort activity rejecting it instead of putting the same amount of effort into understanding it?
[jlink](https://docs.oracle.com/javase/9/tools/jlink.htm#JSWOR-GUID-CECAC52B-CFEE-46CB-8166-F17A8E9280E9)?
&gt;performant code Again, you provide no reference point. Compared to what? Making code easy to write is hardly the most pressing issue in computing. The cost-benefit doesn't seem to stack up at all. A world-changing transformation with no consistently measurable benefit to the end-user. FP reminds me of Python, which is a toy language. Amazing for prototypes. Would rather improve my code's performance by 10% than feel good about myself for making it so high-level it's opaque, nearly undebuggable, and its performance charactaristics divinable only by PhDs.
&gt; Would rather improve my code's performance by 10% than feel good about myself for making it so high-level it's opaque, nearly undebuggable, and its performance charactaristics divinable only by PhDs. *facepalm*
It looks like in your [submission](https://www.reddit.com/r/java/comments/9u9itk/help_wanted_bugintroducing_changes_research/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
 long start_, end_; List&lt;String&gt; items = List.of( "a", "B", "c", "D", "e", "F", "a", "B", "c", "D", "e", "F", "a", "B", "c", "D", "e", "F", "a", "B", "c", "D", "e", "F"); StringBuilder sb = new StringBuilder(); final int N = 10_000; /* AAAAAAAAAA */ // for (int i = 0; i &lt; N; i++) // for (String s : items) // sb.append(s); // start_ = System.nanoTime(); // for (int i = 0; i &lt; N; i++) // for (String s : items) // sb.append(s); // end_ = System.nanoTime(); /* BBBBBBBBBB */ for (int i = 0; i &lt; N; i++) { items.forEach(sb::append); } start_ = System.nanoTime(); for (int i = 0; i &lt; N; i++) { items.forEach(sb::append); } end_ = System.nanoTime(); System.out.println(((end_ - start_) / 1000000.0) + " ms");
Just write 18 files of front-end code using TypeScript and it should work. *cries in excessive amount of front end code* and **smiles at minimal amount of backend code**
It looks like it's more akin to Java 9 modules, but for things on the classpath.
What are you trying to demonstrate here? I don't see any usage of strings here?
The jre should be included with the jdk. I think they're trying to discourage the jre with jlink if I remember right.
Per [Oracle’s release notes](https://www.oracle.com/technetwork/java/javase/11-relnote-issues-5012449.html#Diffs), there will not be a separate JRE built from OpenJDK sources. There will only be a JDK.
There is no separate JRE anymore, only the JDK which includes all JRE parts (e.g. the `java` binary). Also, do not use OracleJDK unless you intend to pay them money. OpenJDK is the new default. 
It looks like in your [submission](https://www.reddit.com/r/java/comments/9ubgs7/what_is_a_scanner_in_java/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I don't see my favorite one: Immutable state You are storing any modifiable state data in an encapsulated field, and each thread retrieves its working copy before doing any work. The state objects are immutable. This can be very well paired with atomic access. public class MyState{ public final int i1; public final int i2; public MyState(...) { ... } } //this.state private volatile MyState state; @Override public void run(){ //the code for concurrent threads MyState s = this.state; //do something this.state = new MyState(...); } This was the multiple state data is always consistent. However! When you want to derive some data and update the state based on that, you might want to use CAS access to modify the current state at the end of the work. And if the state was concurrently modified by another thread, consider doing the work again. There are tradeoffs for this as if the work is very long to run, then you should just use some synchronization methods, not to do unnecessary work. //assume that state is stored in an AtomicReference. //or used with AtomicReferenceFieldUpdater this.state = state.updateAndGet(s -&gt; { //do work on s, possibly not too long return new MyState(/* new value based on s*/); })
Java now has a linker (jlink) and developers are expected to create an application specific runtime that is bundled with the application. So for plain old jars you need the full JDK.
Damn it, the backend belongs in the backend!
These aren't really patterns, they're more like best practices.
How is a CRUD app cool, though?
*"Concurrent read, blocking write of a shared map using `ReentrantReadWriteLock`"* is a pattern. Using said pattern is a best practice.
Everything is relative ;)
Not even that. They are shallow solutions for problems you should not create in the first place. 
You mean, compared to some other app being "hot"?
Well compared to some struts 2 app I can imagine it's quite cool :)
preferred Course for IT personnel
Always nice to see the producer of a tool supply the statistics to prove their tool is the bestest. Zachary Tellman of Lacuna is no different.
You quote a point to argue against that the author himself goes on to argue against. Why?
Because he's still pointing people in the wrong direction. 
Quite useful thing, thanks. Though I'm afraid it will only change your JDK within a session and if you, for instance, start an app via your IDE it will still pick the default one.
Is this necessary? Can't every jdk compile down to a previous version?
Or sdkman
angular 7.0? when the fuck did that happen?
Or jenv, though I have been meaning to look at sdkman 
Functionality is sometimes removed from the JDK. If you want to use that functionality, you need to switch to an older version. Also, while `javac` can target a byte code version, I am not sure that there is a way to target a *JDK library* version, so you cannot be sure you are compiling a program that will work with an older JDK when using a newer `javac`.
Kinda... Most build tools just emit corresponding source&amp;target/release flags, but this would compile against the JDK API-s in whatever you have installed still. A proper way would also add e.g. -bootclasspath to javac with the target jdk version, which means you at least need to install different JDK versions. One option is to switch java via alternatives, archlinux-java, jenv etc. or you can setup something like maven toolchains plugin. Also you may still need older javas to run something that doesn't work with 9+.
My point was that FP for FP's sake like `items.forEach(System.out::println);` is complete and utter vanity. So I decided to back it up with code. It's 80% slower. As for Collectors.joining(), I can counter with String.join(): long start_, end_; List&lt;String&gt; items = List.of( "a", "B", "c", "D", "e", "F", "a", "B", "c", "D", "e", "F", "a", "B", "c", "D", "e", "F", "a", "B", "c", "D", "e", "F"); StringBuilder sb = new StringBuilder(); final int N = 10_000; /* AAAAAAAAAA */ // for (int i = 0; i &lt; N; i++) // for (String s : items) // sb.append(s); // start_ = System.nanoTime(); // for (int i = 0; i &lt; N; i++) // for (String s : items) // sb.append(s); // end_ = System.nanoTime(); /* BBBBBBBBBB */ for (int i = 0; i &lt; N; i++) { var result = String.join("", items); } start_ = System.nanoTime(); for (int i = 0; i &lt; N; i++) { var result = String.join("", items); } end_ = System.nanoTime(); System.out.println(((end_ - start_) / 1000000.0) + " ms");
R/W locks are almost always the wrong solution. If the critical section is cheap (e.g. no I/O) then an exclusive lock is faster and simpler. The overhead of the lock is significant, often more than the work being performed. It's not wrong, except in all the examples and places where I've seen people try to use them...
If you're new to Spring Data JDBC before this better check one with introduction https://youtu.be/EaHlancPA14
Node.js is Java**Script**, not **Java**. They are completely different languages despite their similar name. You will want to post this in /r/javascript or in /r/nodejs.
&gt;Actually you should pretty much never ever even share variables between threads. Unless they're immutable, but otherwise agree.
&gt; Why did Java 11 JRE not install with JDK What makes you think the JRE didn't install when you installed the JDK? What doesn't work that you think should work? What is it that's broken for you? &gt; the Oracle site doesn't have downloads for Java 10 or 11 JREs As other people have said, there is no separate JRE any more.
This sets JAVA\_HOME - but how about the PATH variable? Will it update which executable you're using?
I hadn't heard of Cettia before but I browsed the site and liked the visual style and that the content I was looking for was easy to find. The API also seemed very elegant. I've put it on my list of things to play with. ;-)
&gt; In practical terms this means you can pass Typo: should be "can't"
Yep, it will.
The JRE is the `java` command and things like that. It's still in there, even in JDK 11. It's just not a separate package any more.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Can someone please TLDR it for us lazy asses? 
&gt;6.5x slower wew lad Worth mentioning that library code should always be optimized. Can't assume all your users are going to be IO bound
The JRE is just everything needed to run a Java application. Including `java` etc. but excluding `javac` and other tools for development. Typically and logically the JRE was a lot smaller than the full JDK. You don't get that anymore out of the box. Now the developers are asked to bundle a minimal runtime using `jlink`. If they don't, every non-tech savvy user can only download the full JDK.
&gt;My point was that FP for FP's sake like `items.forEach(System.out::println);` or `items.forEach(sb::append);` is complete and utter vanity. So I decided to back it up with code. Append is 80% slower in a basic microbenchmark. Well not really. `forEach` isn't really used in FP for anything except end-of-world side effects, which aren't going to be CPU bound. &gt;As for `Collectors.joining()`, I can counter with `String.join()`: I just followed your example. I wouldn't use streams for this example in the real world because. A) We already have the full list. There's no point steaming something if we already have all the values and we're only applying one operation to it B) There's a built in combinator, as you say. &gt;Higher-order functions are at best comparable and often much, much slower Agreed. Java really doesn't optimise these well. It can be hit or miss on performance, so you need to make sure you're profiling things. &gt;Oh, and if you use an array with the loop (like an optimized impl would), Yeah but... If you already have the whole array and you're only applying one operation, why would you bother with a stream? &gt;More than ten percent slower. That's hundreds of millions or billions of dollars worth of hardware R&amp;D negated by a "cool new api". Well no, because if you were using stream in a CPU bound operation you'd only do it if the lazy streaming let you skip work due to lazy evaluation. 
&gt;What performance penalty? Q.E.D.