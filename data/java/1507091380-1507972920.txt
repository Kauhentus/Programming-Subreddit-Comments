&gt;Kubernetes is ideal for those who are new to the clustering world; it is the quickest, easiest and lightest way to flex your fingers and start experimenting with cluster oriented development This is a joke, right? Getting a local production ready installation of Kubernetes was a nightmare last time I checked. If we want to talk about ease of installation, then Nomad from Hashicorp (which is not even mentioned in the article) is the clear leader here. The whole article is just marketing with no actual substance. I bet the author has not even used all the solutions that are discussed.
Have you tried Minikube, Kops, or kubeadm? All of them are super easy to try.
To add on to Minecraft, specifically, SpongePowered/SpongeAPI and Mixin. https://github.com/SpongePowered/Mixin/wiki Mixin gives you Mixins / AOP on the JVM, using abstract classes as a smart template to attempt to give you some compile time help. Along with https://github.com/minecraft-dev/MinecraftDev/ which is an IntelliJ plugin which adds better debugging support for mixins, and minecraft modding in general. MCP the coding platform MinecraftForge is based on has a really cool crowd based deobfuscation tool as well, which is what enables modding on the Java edition of minecraft.
I chose my words very carefully. I am talking about production-grade on-premises installation * Minikube is not production grade * Kops is for AWS and not on-premises * Kubeadm is in alpha according to their web page. Just take a step backwards and think. These are installers for K8s. You take as granted the fact that K8s is so complex that an installer is needed in the first place. Nomad is so simple that it does not need an installer at all!
See also Bruno Borges' tweet here: https://mobile.twitter.com/brunoborges/status/915302682939711488
Last time, 2 months ago, minikube had a DNS bug. It was barely usable.
I remember the talk from last year, good to see there is some progress on it. Blocking is only one of the issues with JDBC it will be nice to have a modern alternative.
Not OP, but several employers &amp; customers care about certs in general, and these certs specifically. 
Usually, if you have a portfolio (or even a GitHub repo) that is enough to get you an interview and from there you can show off your competency. Certs don't generally matter once you've got enough working experience. 
I hope they get this stuff rolling this time. We've seen the same thing last year. A talk about an async (not reactive) driver for Oracle, that's been sold as async JDBC (which it wasn't). Radio silence for a year since then. This time we've got an OpenJDK ticket, and a recommendation to get involved on a mailing list that hasn't seen a message since November 2015. I'd *really* love to see something moving there but it takes way more than what has happened so far.
Awesome, now Lukas just posted to the list and invalidated my claim. :D
Yeah, [let's see some examples](http://mail.openjdk.java.net/pipermail/jdbc-spec-discuss/2017-October/000096.html) and action. I've briefly reviewed the API this morning. From a high level, it looks quite reasonable. Of course, the new terminologies are a bit confusing right now, because they're, well, new. Things like "member", "aggregator" do not seem clear at first ([hoping to get clarifications on the list](http://mail.openjdk.java.net/pipermail/jdbc-spec-discuss/2017-October/000096.html)). [I've also raised other issues on the list](http://mail.openjdk.java.net/pipermail/jdbc-spec-discuss/2017-October/date.html) From a functionality perspective, however, I feel that the suggestion is already quite complete. I can see how any of these can be executed: - DDL statements - DML statements with update counts - SELECT statements with results (although I'm a bit unclear about how to receive results, thus looking forward to examples) - Batch statements with sets of update counts - Simple stored procedures with IN/OUT parameters - Statement batches and procedure calls with unknown update count / result set / exception streams (mostly for MySQL and SQL Server) And most importantly, all of this seems nicely integrated with the new [JDK 9 Flow API](http://download.java.net/java/jdk9/docs/api/java/util/concurrent/Flow.html) So, this API does look promising.
&gt; Usually Your experience is not universally applicable. In my local market, anyone with less than 5 years of Java experience (not Python, C#, C++, Rust, Elm, Scala or Prolog) is at a disadvantage without Java certs when applying for a Java position. End customers expect to see it. 
http://www.oracle.com/technetwork/java/javase/downloads/jdk9-downloads-3848520.html
If you use Linux, you should know how to upgrade. Or at least Google how to upgrade.
Anyone I have worked with who had certifications has been shit. I actively avoid them. My impression is it teaches you to paint with numbers, and people get because they are insecure, and people are normally insecure for a reason.
I would be able to act as a google proxy for you if you had mentioned which distribution you're using ;)
And this attitude is exactly why ordinary users aren't adopting Linux more.
Likewise, I'm using mesos and it's p nice. Certainly very barebones (have to write your own scheduler) but that barebonesness also gives you the ability to build a number of different cluster solutions. And yeah, it's a bit tough to get up and running, but it's no harder than akka for instance...
Fedora 
200 pages? When I read it a few years ago, it had ca. 1500 pages. 
You can just use the [RPM](https://www.youtube.com/watch?v=KX3V7LkmRBY) :S
Never underestimate developers having Stockholm syndrome :') 
good bot
You make it sound like you can't do the same in Java :|
OP here: this is a small library we did which adds small features and some glue code on top of Spring Boot and Hibernate Validator which you might find useful.
Thank you...I guess :D
Exactly. I was using Mesos for big data before Kubernetes was hot. I have been trying to involve into Kubernetes for microservices but scared to play with because of the reasons you specify.
Ty
Good to see GWT going in leaps and bounds.
Nice
Amazingly defined bot.
Here no one gives a flying fuck about java certs
&gt; What I've run into is situations where the RI strictly follow the spec, but do little else. That's kind of the point with having a spec though, no?
Yeah, I get that. That's been true most places I've lived too. 
Where are you that people are interested?
That ain't really cursin', bro's just using Street Jav, Hood Edition, y'all.
undisclosed location in europe. dev market's dominated by consultancies that sell to specific-experience and cert-obsessed customers who tick off lots of checkboxes on CV's.
Does anyone start new projects in GWT?
Yes, that's the point of the spec. But when I'm choosing an option to go to production with, I care less about standards and more about keeping options open.
Very well could be inexperience talking, but when I write Java, to appease the type gods things tend to get a little long in the tooth vertically. But as for the rest? Yes absolutely. Spark is responsible for 98% of my file shrinkage, a da one two punch of Spark with Kotlin has reduced my entire API to just over 300 lines (with comments) where previously just the php controllers file was about 400 lines with comments stripped 
But you're closing options as soon as you use non-standard extensions. Of course, I sympathize with having more features, I just think it's strange reasoning.
Not existing 
Backend java dev here, I've started to learn Rust last january, I don't regret it at all! Modern syntax, safe, fast, compiled, everything I was looking for!
That doesn't make it any less pointless.
=))))) this is a good one!
The most common !
System.out.println instead of Assert.
Nice! I like the new reactive stuff for Redis. Will we be seeing reactive crud-repositories for Redis as well? Like the mongodb and cassandra ones, those look really nice.
I've seen people writing code to test: 1. Whether the framework works, such as verifying that a Mockito mock is in fact a mock (or something like that) 1. `Assert.equals( ... some hashcode ... , obj.hashCode())` - I mean, what? 1. Verifying the `toString()` whether it really is the String containing something like `SomeObject[attr1=val,attr2=bla]`. 1. Testing getters and setters. Probably just to get that precious 95% coverage. Frankly I think this is retarded. I'm certainly no test zealot or whatever (I don't necessarily agree that you need 100% code coverage), but that certainly struck me as odd...
in fairness, nomad is a simpler product; kubernetes has several additional sophisticated features. https://www.nomadproject.io/intro/vs/kubernetes.html 
these nicknames used in spring projects are sometimes disorienting. i wish they would just use semantic version numbers.
We're still using version numbers but as the individual projects have to incorporate different paces, the modules' version numbers have diverged significantly: Spring Data JPA 1.11 works with Commons 1.13 and Spring Data MongoDB 1.10. *That* has actually caused quite a lot of confusion. We can't do much about the individual paces as we don't control when MongoDB ships a new major version of their driver, or any other of the vendors drops a new version of their database. Beyond that, sticking semantic versioning begs the question about what to version in the first place. We've usually been pretty strict about user facing APIs, but with a programming model on the surface even "user facing API" cannot be determined easily. On the other hand, over the years we've shipped a couple of breaking changes to internal APIs that have never bothered any user at all, which – had we followed semantic versioning – would have cause us ending up at version 10 or 15 for no apparent reason. All these aspects were reasons that we started those release trains, that allow users to refer to e.g. "Kay" or "Ingalls" from their POMs which then makes sure you'll get the right set of matching dependencies.
"""Unit""" tests that test functionality across multiple components, do persistence, etc. Because they don't really write testable code and thus the smallest testable units are enormous
Using a mocking framework when they should be using test doubles injected via constructor.
Tests that have nothing to do with a feature. E.g. asserting that a getter returns a non-null value.
I'll take my humour elsewhere then. I understand Java framework versioning schemes are of ultimately serious importance.
Tests that rely heavily on implementation details of the class under test.
Tests that have a lot of setup code.
Test code that isn't maintainable.
That's enough for now; happy upvoting and thanks OP for the question!
Mocking close to an entire application server.
Technically, yes, by just passing one certification you are not a Java SE 7 certified programmer. If you want to become Java SE 8 certified programmer, I would suggest going through Java SE 8 path, instead of taking Java SE 7 Programmer II certification, you will learn Java 8 better. Btw, I have shared some useful information related to Java 8 certification in my blog, you may find helpful, http://javarevisited.blogspot.com/2017/07/ocajp-8-faq-oracle-certified-associate-certification-1z0-808-exam.html 
Not being real unit test and test that don't mock. So they are making real http request or call to several other helper methods
The biggest mistake is unit tests existing at all. It's an unbelievable waste of time designed to give devs a false sense of security. I'm much more in favor of integration tests over unit tests. I know people say unit tests have a place by citing some anecdotal evidence, and I do agree to a certain degree. But the time spent on it is just not worth whatever "protection" it provides. I'm always a proponent of investing more time into integration testing instead.
I had severe issues trying to setup minikube on both Windows and a headless Linux box .. I've seen it work on MacOS, but that's it.
Thats a bold statement and I don't think it applies universally but it does have merits. Given a choice between X hours unit testing and X hours integration testing, the latter is likely more beneficial
I noticed that people who push more for integration tests than unit tests are the ones that cannot write the test before the implementation and don't do proper TDD.
I would say unit test custom data structures, complex / confusing logic or algorithms (within reason). Thats about it in my opinion. Integration tests should cover the rest.
Some annoying ones I have seen are - Overuse of testing for null parameters (mostly for constructors), in addition to that it checks that the exception thrown for a null parameter had some string message with the parameter name. So if the actual code changed the parameter name the unit test would fail even though everything still worked. - Verifying literal string values, a user facing text string change should not break a unit test. And another one that is an easy mistake to make so no one can get blamed for this. By default initialization should go through the happy path. For example testing an API that requires to be logged in for each command. Login by default so each unit test doesn't have to initialize that, the few times you want to test "not logged in" then setup for that case. This prevents having a test case where you test for some other failure and having a false positive. Did the test pass because what you were testing failed when it should have? or you forgot to setup the login and it failed on that and never got to the code you were trying to test.
Maybe a step in the right direction.. but still a pretty horrible startup time. If you aren't going to run a JVM for at least 5 minutes, I would use a different technology...
That's a bold statement, and completely inaccurate. Either way, you're looking at it incorrectly. It's about how many man hours you're spending writing unit tests and how many bugs it actually prevents. Compare these metrics between unit and integration tests. I believe that integration tests pays off more than unit tests. Also, I noticed that you're taking this personally. Wasn't my intention if you felt attacked.
I think that's completely fair with regards to what needs to be unit tested.
Forgetting to add "fail()" after calling a line which is expected to generate an error. Despite its obvious advantages I'm still trying to win the argument that we should use errorprone in our build process.
Did you try the SubstrateVM? http://www.oracle.com/technetwork/oracle-labs/program-languages/overview/ $ javac HelloJava.java $ graalvm-0.28.2/bin/native-image HelloJava classlist: 966.44 ms (cap): 804.46 ms setup: 1,514.31 ms (typeflow): 2,580.70 ms (objects): 719.04 ms (features): 16.27 ms analysis: 3,422.58 ms universe: 262.09 ms (parse): 528.44 ms (inline): 1,259.94 ms (compile): 6,716.20 ms compile: 8,817.97 ms image: 1,070.29 ms debuginfo: 672.64 ms write: 1,797.45 ms [total]: 17,907.56 ms $ ls -lh hellojava -rwxr-xr-x 1 chrisseaton staff 6.6M 4 Oct 18:35 hellojava $ file ./hellojava ./hellojava: Mach-O 64-bit executable x86_64 $ time ./hellojava Hello Java! real 0m0.010s user 0m0.003s sys 0m0.003s
I think all future features will be listed here: http://openjdk.java.net/jeps/0
 public void test() { try { //test the thing } catch (Exception e) { logger.error(e); } } Even better when the try block contains no/useless asserts.
Which is often a problem when you start mocking with something like Mockito. Suddenly, you've pried open all your code and changing anything means all your mocked setups of internal responses are no longer valid.
You can spot these when you see a lot of verify() :)
Exactly. If you're unit testing relatively simple code, you're wasting time. The number of places that really benefit from unit tests are relatively few, but they are *crucial* to do with unit testing. Integration test the rest because you have to anyway (not set of unit tests can prove your code works all together). Even though integration tests are a huge pain the ass.
Hi Chris! We looked into it a little, but as I understand it Substrate VM doesn't support reflection so it's a no go for our project at the moment. Happy to be corrected though, and it's probably a great fit for some stuff. 
It does support reflection now! As long as you know at compile-time which classes you will want to reflect on. I'm not the expert on it but join us in https://gitter.im/graalvm/graal-core if you want to try it again.
Ohhhhhhh cool. I'll be in touch. 
Sure. I mean, yeah it's not something that the JVM's renowned for is it? Then, it depends what you want to do. In our project, JVM isn't really negotiable. But anyway there's improvements to be made, and active research going on, which I thought I'd try to explain.
In the future we will all be bots. You apparently have a jump on the process. 
I really want to hear more. What is your task doing that NEEDS such a short running JVM. Like why could it not be closer to a worker pool model where 1 JVM is servicing multiple work units over time..
It's a FaaS platform - [fnproject.io](http://fnproject.io) - the current architecture is that functions are submitted as container images &amp; run on-demand. (actually docker startup takes way longer than JVM startup anyway). There's no way we could run different people's code in a single JVM because of the security problems. The ideal model for JVM functions is, IMO, pre-started JVMs which can load code dynamically and then be killed, or reused for the same function code. Experimentally this takes single-digit milliseconds to initialise and run but we're not there yet architecturally.
You should have the concept of a "User" at some level right? So all jobs for a given user could run in the same container (if you want to use JVM hackery to hack your own self, go ahead)... That would allow 1+ long lived JVM per User... but yah the user that submits 1 job per 5 minutes is a bit of a resource drain...
Fwiw, here's the DL4J site: https://deeplearning4j.org/ Here are the repositories: https://github.com/deeplearning4j And the Gitter community: https://gitter.im/deeplearning4j/deeplearning4j
Thanks for that article. Very interesting. While I don't have a use case for that, it is good to now nonetheless. And to be honest: I am surprised that the JVM starts that fast today. It has come a loooong way.
I know, right! Thanks :)
&gt; It's about how many man hours you're spending writing unit tests and how many bugs it actually prevents. Well, partly. But it's mainly about knowing that you aren't going to break things when you refactor. And I find that investment pays off quite well indeed.
In my opinion, it's always good to learn new programming language no matter if Java dies (and it will not). Every programming language has its own philosophy when it comes to programming and with every new language you can learn what could be done different or even better in languages you already know. You also get better understanding of programming languages you already know. In the end they all are solving the same problem and run on same computer arhitecture so every new thing you learn in one programming language is translateble to others. You might even discover some nice feature that is missing in Java. To summ it up, you are missing a lot if you limit yourself to one programming language.
My personal favorite was a test that I broke when refactoring some code. It was a very old and complicated looking test, I was concerned that I might have broken something important. After finally figuring out what was actually being tested, it turned out that it was actually testing the JVMs implementation of daylight savings rules in certain time zones. The test had broken because the author had hard-coded incorrect daylight savings rules for the most recent DST transition. SHIFT-DELETE.
So many ‘unit’ tests in the codebase I work on rely on the database, the file system, and 20 other fucking dependencies which also relay on the database, the file system, etc So much fail
While asserting on exceptions has its place, ExpectedException in its many guises is an anti pattern imho
Good to see it is still very active. I use GWT, indirectly I guess, with libGDX to allow my games to run in a browser. 
I think your opposition doesn't actually address where unit tests are useful. If you have a platform that is heavily UI-based and infrequently released, unit tests won't provide a return on investment as the time needed to create them will exceed the benefits. In this case, you're right that integration testing is the better option. It's a whole other story if you're talking about software that a) is frequently released b) performs some kind of backend processing (especially financial services) c) is an API consumed by others In these scenarios, a sufficient suite of unit tests is able to ensure that a code change does not cause a regression issue. As unit tests are performed at build time, this can prevent releasing a product that's introduced bugs to existing functionality. 
I kinda like how it is Eclipse Enterprise *for* Java, because it shows people that Java EE is not an integral part of Java itself, it's just a large, somewhat standarized set libraries. It's no longer "Java SE and Java EE, what's the difference?", because it doesn't use the same naming scheme as the most integral set of Java libraries.
Do you think that's an undesirable outcome? Your grandma is probably an "ordinary user" of Windows or OSX, and that's how paid support businesses get to exist. Barriers to entry can serve a valuable (if not existential) purpose for healthy communities.
how is ExpectedException an antipattern? How else might one assert that a specific exception has been thrown? Are you trying to say use @Rule instead or ???
I'd much rather have [fibers](https://www.reddit.com/r/java/comments/72qpz8/project_loom_proposal_fibers_delimited/) and get the benefits of async without having to rewrite everything. From the linked proposal: "Recent years have seen the introduction of many asynchronous APIs to the Java ecosystem, from asynchronous NIO in the JDK, asynchronous servlets, and many asynchronous third-party libraries. Those APIs were created not because they are easier to write and to understand, for they are actually harder; not because they are easier to debug or profile — they are harder (they don't even produce meaningful stacktraces); not because they compose better than synchronous APIs — they compose less elegantly; not because they fit better with the rest of the language or integrate well with existing code — they are a much worse fit, but just because the implementation of the software unit of concurrency in Java — the thread — is insufficient from a footprint and perforamance perspective. This is a sad case of a good and natural abstraction being abandoned in favor of a less natural one, which is overall worse in many respects, merely because of the runtime performance characteristics of the abstraction."
Long test methods are the most common mistake that I've encountered. That obscures the behavior being asserted because of the setup and teardown code. The test method itself should be small and instead extract the noisy code to helper methods. Then debugging is easier to grok and step through. There are a lot of tricks (framework methods, custom matchers, aspects, parameterization, etc) to scale testing code. I don't expect test code to be of the same quality as production, but it shouldn't be significantly worse. Poor quality leads to dismissive attitudes towards testing. Learning good testing techniques leads to better production code, and it takes effort to learn them. Most people start out assuming tests are easier to write, but in fact new tricks are needed that leads to better quality coding practices in general.
When someone tries to eliminate duplication in a bunch of tests by extracting a shared private method, and then the shared method ends up with conditionals in it to handle the setup or assertions for the various scenarios. There shouldn't be any cyclomatic complexity in unit tests.
just dont kill it like they just killed the r/javascript
Indirectly I use it through Vaadin.
Nice vid. ...it wasn't that long ago that I remember waiting *forever* for weblogic &amp; websphere to fire up. Great to see how quick they all are nowdays.
you will have more success asking in /r/Javahelp
Since this is help with *Java programming*, it should be, as the *plenty hints* on the page indicate, posted in **/r/javahelp**. Please, *read* and *follow* the [**Posting Guidelines**](https://redd.it/48eykt) there before posting. Also, please *format your code*. Instructions how to do so can be found in the aforementioned *Posting Guidelines* and in the *sidebar* of /r/javahelp. **Post removed:** programming help
&gt; I actively avoid them. That's just dumb. I personally feel getting these certifications has about zero value but there are a lot of employers that pay for them. Why would you say no to that? Because some rando "actively avoids them"? 
While we are not against changing the theme, we will definitely wait until reddit has finished their changes to how themes work to avoid duplicate and redundant work. We will keep the suggestion in mind, but ask for everybody's patience until the reddit theme change is finalized.
Ouch, my eyes. 
I wonder, could you have a kvm vm with a jvm already running saved, and clone and start it on demand? That should take milliseconds, and is also more secure than docker.
Do you know if using jlink to create a JVM with only the modules your application requires would decrease start time? 
You know, I think it might. I need to look into it more, jlink is on my future blog topics list. 
[removed]
Unit testing where integration/functional test would be more appropriate, leading to a lot of totally useless unit tests which only prohibits refactoring.
Yes! 15-40ms improvements on a Hello World on my workstation, depending on how hard I tune for startup (CDS etc). Entirely untuned I see about 25ms improvement on my machine when running on an image that includes only java.base. With a lot of tuning and a recent build of the latest jdk10 sources, I can get a minimal jlink'd image to do the Hello World thing in ~28 ms. Same for a full JDK image is ~43ms. Equivalent setups is about ~42ms vs ~57ms on JDK 9. My gut feeling is that SubstrateVM is bound to see similar gains from the startup optimizations we've been doing as of late, since it's mainly been about reducing classes loaded during bootstrap etc.. 
This should be at the top.
Go here instead: /r/javahelp /r/learnjava And don’t ask them this question either. Chances of an answer are very low. Make something you’re interested in. A blog, todo app, etc. Then ask your questions. 
Are there any requirements regarding complexity, problem domain or technologies? If not, then for example Conway's game of life is pretty fun to implement as a relative beginner, back at university I implemented it as a Swing application as the homework of our Java 101 class. A cell in the grid changed its colors according to its ages which I think looked pretty cool (yellow meant new and dark red meant dead).
Have you tried Excelsior JET? https://www.excelsiorjet.com This is Java SE compatible JVM with AOT compilation so it will be interesting to see how it performs in your environment compared to Hotspot's AOT.
`ExpectedException` and `@Test(expected = ...)` can lead to misleading tests: all the tests in this gist pass https://gist.github.com/anonymous/46a6f004273c90fe866cf56b655671e5
SubstrateVM can actually do something even more powerful for the initialisation phase of your application - you can run your application up to a certain point and then compile its state at that point. So you can do any initialisation you want during compilation and then when you start running the compiled program, the objects created during initialisation are just there in memory immediately.
When you do, please consider Night Mode.
Not sure what hurts more: JS itself or those colors
This, most subreddit css is unusable on night mode. Case in point, /r/JavaScript
Since this is help with *Java programming*, it should be, as the *plenty hints* on the page indicate, posted in **/r/javahelp**. Please, *read* and *follow* the [**Posting Guidelines**](https://redd.it/48eykt) there before posting. For ideas, you can check [Where can I find practice exercises and project ideas?](https://www.reddit.com/r/learnprogramming/wiki/faq#wiki_where_can_i_find_practice_exercises_and_project_ideas.3F) from the /r/learnprogramming wiki **Post removed:** programming help
FYI they dropped the `1.` prefix, it's now just Java 9. And the next version is... 18.3.
Wow
Cool! Same thing still applies in a way: as we reduce the number of classes we load on bootstrap, we also reduce the number of objects initialized, which I can only assume will lead to more efficient/smaller SVM executables as well.
Hackathon?
to put this into perspective, a swift hello: Hello! real 0m0.010s user 0m0.008s sys 0m0.000s and java for my sys: real 0m0.137s user 0m0.088s sys 0m0.104s 
Your bets is off
Angular guys gave semver a very bad rep, but publishing 2 different versions of the same library with the same version number should be severely punished.
This was a very interesting, approachable read, and taught me some JVM flags that I didn't know about (e.g. getting touched methods) Not sure if doing all this is worth the hassle, but I suppose in some situations it could be a good option. I guess the only risk is if the underlying environment changes and it causes your app not to start. 
You're missing the fact that unit tests can help design the code better. I'm not going to justify Tdd to you, but for me it's the only way to write code from scratch.
FYI - this video vindicates my position: https://www.youtube.com/watch?v=PbIBYxVyWNs&amp;feature=youtu.be&amp;t=23m
Really, JavaEE has lost. A long time ago, we should be looking forward to lightweight frameworks based around the Spring stack and stop wasting time on flawed tech. (Said the 20% who voted down this article)
**From the sidebar -&gt;** **NO programming help, NO learning Java related questions!** &gt;Please seek help with Java programming in /r/Javahelp!
Seems like a very contrived example to me. IMHO, all those methodologies are fine (programmatically catching, `@Rule`, or `expected =`. The issue with your example stems from a very broad catch of RuntimeException. This isn't bad in and of itself, but your 'misleading' example: @Test(expected = RuntimeException.class) public void expected() throws Exception { B b = mock(B.class); A a = new A(b, true); a.sometimesDies(); verifyZeroInteractions(b); // there were interactions with the mock, this test is misleading } is only misleading because you add a verify after ZeroInteractions(b). Just remove that line and it's not misleading. As for ambiguity in the catching RuntimeException vs. whatever else, that issue persists in both your contrived examples and `expected =`. 
themes? oh. i've had that disabled basically forever. plain reddit is best reddit.
It’s probably sarcastic ;) 
So Java 9 is only going to be supported for 6 months?
Yes. There'll be two releases next year - 18.3 (expected in March) and 18.9 (expected in September). The 18.9 one is the next long term support. 
Seems weird that they didn't pick 9 as a LTS and then pick 19.9 as the next one. Means another year before I can start using the nice goodies in 9.
It's just the same source built for a different target. A lot like how other software is compiled from the same source to multiple target platforms for example, it still being all the same version. The issue is not directly this because there may be need for targeting different versions while benefiting from a newer target in this case. The issue is more about the lack of transparency in this matter, that the two builds aren't explicitly noted as being different. This is what causes suspicions. Having worked with JSch I have to say it's one of the worst libraries I've had to deal with. It's severely lacking in documentation and trying to understand something from its source is impossible if the actual variable names are `a` and `foo`. Even more, the source is only published occasionally via their minimalistic site, no version control or anything. This doesn't look very trustworthy from a security perspective.
First, join the Tapestry mailing list, I find it to be a very excellent framework, there are some things I wish Spring could adopt.
I would probably start by changing your attitude (before joining their mailing list) as they might not like it if you describe it so 'nicely'
The presentation is answering the wrong question. I don't think that when people say that JavaEE is heavyweight they mean that it takes more RAM or has longer startup times (or maybe I have missed something) Unless I am the minority here, the reasons I believe Spring/Dropwizard/etc are more "lightweight/lean/fast evolving" is because of development complexity, compatibility and access to bleeding edge features.
The only thing that changed was that in the old days they loaded every possible subsystem in advance even if it was not used. Now they only load only what is really needed. Makes sense, but the question is why they did not do this in the first place.
probably makes sshj more appealing.
Yeah you're right, frustration got the upper hand
What things? Genuinely curious
Some of the IoC like the Local only, The parameter handling is quite intuitive. You can inject things into your HTML a lot easier, if you are working on something that uses a lot of JQuery, not only can you send back the pre-rendered HTML within a JSON response auto-magically and rebind all the handlers. Edit: Also if you know how to use it properly you can use it + Spring MVC, you can also use Spring as a backing injection provider.
Well 18.1 and 18.2 for the 2018 releases would be the less confusing naming scheme Imo... 
How do we explain to recruiters
:) I am a level 18.2 Java wizard. Oh sorry sir we require level 19
its been a long time since I've last used Tapestry, but I remember it being pretty good so I would say give it a (real) chance and don't judge it from what you know about other frameworks
Books, Google, and Youtube. If you need this class to graduate and are planning to drop/retake it, I would recommend taking in intro programming course before diving in. Frankly, I'm surprised it wasn't mentioned as a prerequisite for the course. 
Given the new scheme, making JDK 9 an LTS would have meant an end to public support for JDK 8 two weeks ago. Can you imagine how many users would have loved that!
1\. The biggest problem with tests is social and corporate politics. Most testing quickly devolves into an informal competition about who can get it "done" the quickest, which involves writing easy path tests that avoid testing anything important. 2\. The second one is the drive to test things from the devs perspective rather than the users. Test are much less fragile and more useful when you test things like "user does a b and c, gets result d". They're also easier to read. And more likely to be updated rather than commented out when changes are made. Compared to the typical unit testing approach of testing little slices of your code. 
Except there are actually more than two releases a year. There are critical patch updates (CPUs) that will happen in between feature/LTS releases so using the month makes sense.
What sucks is that this class is really required for the first year and has no prerequisites whatsoever. The other classes aren’t this confusing at all. Thanks for the tips, I’ll start digging around
**Sidebar** -&gt; **NO programming help, NO learning Java related questions!** **/r/learnjava** is the right subreddit for learning java. The **sidebar** there has lots of resources and the best beginner resources are in the **Free Tutorials** section. **Post removed** learning Java
Since this is help with *Java programming*, it should be, as the *plenty hints* on the page indicate, posted in **/r/javahelp**. Please, *read* and *follow* the [**Posting Guidelines**](https://redd.it/48eykt) there before posting. Also, please *format your code*. Instructions how to do so can be found in the aforementioned *Posting Guidelines* and in the *sidebar* of /r/javahelp. **Post removed:** programming help
**Sidebar** -&gt; **Do not post tutorials here!** These should go in **/r/learnjava.** **First warning** **Post removed**
I'd imagine most companies and job requirements will only care about LTS versions, so it's pretty much business as usual. But I feel we might have to deal with the "cutting edge" features during interviews though!
Java, Clojure and Groovy. You don't even need to leave the comfort of the JVM. 
Agreed - if they wanted to go with monthly releases just give up the pretense and call them 2017-10, 2018-01 or whatever. Trying to keep the convention for convention's sake when you're not following convention at all is just silly. However, that's pretty much the only negative and pretty minor overall. I like what they're doing by going all Agile on us (as much as such a giant cornerstone technology can go). Should be pretty exciting times for Java coming up! 
a corollary is unit tests setup where each file has it's own unit test file, and each test* class is trying to provide 80-100% coverage. I often argue that units are a package for most projects, but an individual class is often too small. 
it's one of the few places I think copy-paste is not just acceptable, but preferable. 
Along with your basic LeetCode easy/mediums, I would also really pour over Java OOP concepts. In my experience, technical interviews have started out with several of those questions, talking about abstract classes, interfaces, polymorphism, inheritance, etc. After those, it would be followed by some hands on coding questions.
No it wouldn't. They've committed to supporting Java 8 as they always were planning to. They still support Java 6, as they say in the video.
not writing them 
your unit tests would give you quicker feedback if your refactoring broke something 
Yeah, they would give me a compilation error... Not really helpful. Integration test (within the application - with Spring context, mocked outbound calls, and in-memory DB) would actually tell me faster and more reliably if I broke something or if something really works. And I am not suggesting that there are no places suitable for unit tests.
I've become a fan of deploying apps by docker. Mostly because they're a self contained block that knows how to execute itself, and the requirements are easily explained, and many tools know how to work with them. Plus they can be versioned well, and assuming you keep tags unique, you know that what you're running is what you tested etc. I've used Google's kubernetes service and AWS's ECS and I much prefer Google's. Mostly because load balancing and service discovery are integrated in the service (and block devices follow containers around)
Thanks for the input! Those seem like great concepts to review!
http://www.oracle.com/technetwork/java/javase/eol-135779.html
Explain them ee4j xd
Public updates for Java 6 ended in 2013, Java 7 in 2015. Java 8 public updates are currently planned to end with the release of 18.9. You can choose to pay for premium or extended support - it looks like the latter ends for Java 6 in Dec 2018.
If you like Eclipse use that.
[removed]
While I haven't used it, in the heyday of Java frameworks, Tapestry was generally considered one of the better implemented ones. So, as others have noted, give it a chance.
I wouldn't say critical. I have been a Java dev for 7 years and outside of JAX-RS I have never had to really deal with it. On side projects never.
that's what they're doing though? just with a . instead of a - and leaving off the 20 18.3 = 2018-03 
"Can you discuss a time when you incorporated a new Java feature in an existing, production system?" "Sure, I once misused the Stream API to slow our system down by several times."
To change your default .java program (in Windows 10), right-click on any **.java file** click "open with" select your program, also selecting "always use this program to open .java files"
I run a vm with jenkins on it which among other things perform releases and builds rpms. The same vm runs a yum server that these rpms are pushed to. All production VMs are configured to talk to that yum server so you can do yum upgrade from them. For auto-scale and such, you just need to include yum install (your app) in the startup script. I've been deploying java servers like this more or less for 10 years, across bare metal, public cloud and hybrid cloud. Never felt the need to change it up much.
Nice. I also liked boot apps on Docker. CloudFoundry also has an option to deploy containers. What do you use as base image. I used OpenJDK8 in the begining and it bulked to 800MB at the end of build, now using Alpine. I have been listening to GCP podcasts for last couple of months. Google seems to have invested alot on Kubernetes, and atleast one in two Podcasts mention about Kubernetes. 
Whatever you claim to know on your resume you had better know. If I start asking questions and get the impression that you don't actually know about something you claimed then that is what I am going to focus on to determine if you know it or not. Not knowing a single claimed technology isn't a dealbreaker but it will make me skeptical of the rest of your claims. If you do seem to know what you claim then I will focus on problem solving, team dynamics, engineering process, product lifecycle and soft skills.
Exploding zip file. Ftp zip. Unzip. Run .sh. Usually done by Jenkins. But you can also grab a copy and do it manually
Is it your infrastructure, or were you maintaining Yum server for your public cloud instances. This brings another question, will AWS takes care of patches for VMs with some downtime or how is it done.
We use similar set up for lower environments, is it same for your production too. 
I've been using managed instance groups for a web service cluster on gcp. You can configure minimum # of nodes in the group and put them all behind a load balancer. If the platform takes down a vm for any maintenance, it'd have to first spin up a new node. You define a startup script that makes sure your service is up and running before the new node is seen as 'live'. I think this has been pretty standardized across different cloud platforms for a while As far as running my own yum repo for rpm artifacts, I've done that on both bare metal deployments as well as public cloud deployments.
I just finished standing up a small 3 node cluster. Ubuntu, Consul, and Nomad serve as the foundation, and services deployed with Nomad are automatically registered with Consul where Traefik picks them up and proxies requests to the services via DNS name. No single point of failure and all free software. I love OSS.
Thanks, that clears my question. How do you like GCP so far? I've a lot of good things about Azure too.
Deploying with thoughts and prayers, mostly. Fortunately, my current situation has someone who really seems to know what he is doing-- that guy is making it happen instead of me, which has been wonderful. But, between Tomcat, Glassfish, and two different Websphere strategies... I liked the simple Tomcat and the more straightforward and decoupled Websphere that someone managed to not turn into-- well, I've seen websphere done differently and less well also. While I like docker, I'm still struggling with getting an equivalent box to what I can build with full distro installations on "machines" behind load balancers. PHP is just so much easier to scale horizontally. Same for deploying. I don't like Java or PHP for front end work. Literally just use them for APIs &amp; web services to spit out JSON responses the front end code requests to populate views.
Why not just it with year-month? 2018-03? Because you immediately know how old/new it is when you glance at the version...
We have a code reviewed "installer" script and more than one of our clients wanted "something more". Which resulted in an rpm, but if you're honest with yourself an rpm is basically an exploding zip file. So yes add a couple mgmt checks and permissions to the mix and our production deployments are glorified zip explodes 
Haven't really tried azure much. Gcp is behind aws in a lot of ways. Google cloud sql is I think most notably year+ behind rds. Google cloud datastore however is far ahead of amazon's hosted nosql solution dynamodb, which started as a kv store and is moving more and more towards a general document db. So I think the decision largely depends on what sort of cloud services you might want to use. Basic cloud services around provisioning VMs, asset storage, cluster management etc. feel pretty standardized at this point. Aws has better ecosystem as well, but gcp has feels more user friendly and there isn't 5 different ways to do the same thing.
18.1.6, etc
Kubernetes is nice to work with. I wouldn't want to install my own instance though. The openjdk8 image is ridiculous. Avoid.
Isn't this how Ubuntu does its version numbering? 
About bleeding edge features you are right. Can you elaborate about development complexity?
Another thing that changed is the introduction of netty.
Thanks for that. *Even* simpler :)
Which one weighs more for Jr. dev interview: Knowing OOP Java concepts/terminologies or solving algorithmic questions? I am going back and forth, but I feel like I am wasting my time doing that. I have an interview in a month and right now, I am focusing on OOP Java concepts. I feel so lost which direction to study.
Yea this sounds absolutely horrible. This whole "let's put the year in the version" is just stupid but tells you no relevant information. It doesn't convey any information about feature breakage or API changes. I'm all for more rapid development cycle but FFS this is like the worst thing they could have done...
The classic example that everybody knows is the complexity of EJB2 (Until Spring came along). No need to explain this here, there is ample documentation out there. Spring was essentially created out of this complexity. My most recent example was when JavaEE had 2 incompatible injection mechanisms at the same time. You had Java Server faces injection (with an XML file) and EJB injection (with annotations). The two mechanisms were incompatible! (even though they were both part of Java EE) So as a developer you had to juggle among * Java faces beans that could only be injected among themselves * EJB beans that could only be injected among themselves * Normal Java beans that could not be injected anywhere else. This madness lead to complexity for no reason at all. Spring on the other hand was designed from day 1 to support injection of everything against everything. The mess in JavaEE was fixed later with Seam (and with the CDI spec later), but it was too late and I had already switched to Spring at that point.
I would also ask basic data structure, immutability and concurrency questions.
And I used sorted on a parallel stream.
It's confusing because some companies / products do it with $year.$quarter (IntelliJ, Payara) and some do it with $year.$month (Java, Ubuntu)
[removed]
I wonder why they didn't go for semantic versioning. That would have given the version numbers some meaning, and also reduced confusion. 
It's not hipster enough. And clearly the only problem Java has is that it's versioning isn't hipster enough! XD 
example input (last param is the precision) assert(float, float, double); method used is assert(double,double,double); method overloading can make you test different things.
Currently working on a big project where we're using GCP's Container Engine, which operates using kubernetes. The code is structured as maven modules and it gets built into a number of docker containers. GCP cloud tools are actually quite nice and the project simply requires a couple of maven commands to build and deploy. Its a really nice setup. Essentially when we merge branches back into master our CI server runs the maven commands and everything gets tested and deployed. I've previously built projects using GCP AppEngine which I really don't like. AppEngine is comparable to AWS Elastic Beanstalk, you upload your packaged code directly to the service. AppEngine handles the lifecycle of the running application, auto-scales and does some other neat stuff. But you lose full control of ur App and have a number of restrictions on stuff like max response time (60 seconds). 
My measurements have shown a big **regression** in JDK9 compared to JDK8: JDK8u144: 59ms JDK8u144+CDS: 52ms JDK9: 156ms JDK9+CDS: 119ms I did not bother to fiddle with JDK9 AOT in these circumstances, but working for Excelsior I could not resist trying Excelsior JET 12 MP1 with Java SE 8u144 profile: JET 12 MP1 (8u144): 47ms Edit: formatting
Reproducing the last result takes no special compiler or VM options: jc HelloJava.class sudo perf stat -e cpu-clock -r50 ./HelloJava but there are dedicated startup optimization features for larger apps.
When we hire junior devs, it is also about the attitude, even if you are down a bit on skills, thats fine, so just make sure that comes across. And yes, the first code you write are tests :) Also, you would be surprised at bad some of the 'java contractors' are at some of this stuff. We have a really simple code pairing exercise. (its really simple) just to see how they think, work etc etc.. Some of the junior devs get much further and do far better then the java contractors. 
what are the implications (good, bad) of this?
I love how we've got half the world going to semver and half going to forced time based versions that have no connection to the significance of the features added.
How about writing class-specific mini-DSLs in order to write declarative tests, rather than imperative tests? What's your opinion on that? I've been doing it for some time now and I think it improves readability a lot, but I'd like to know whether other people use it or what they think if they see tests like these.
Using UrbanCode Deploy. Our install files are RPMs, so we tell UrbanCode to download our RPMs to the machine and run the rpm install command. It uses the same install process for all our environments, so if the install works on Dev it should work the same in Prod. It also has a feature called snapshots - so if we have 10 packages that need to be installed in Prod, we can add them all to 1 snapshot; run the install command on the snapshot, and it will install all 10 packages in one process, which is neat
.java files are simple text files and can be opened by any text editor. [IntelliJ](https://www.jetbrains.com/idea/), [Eclipse](https://www.eclipse.org/), [Netbeans](https://netbeans.org/) and many others are IDEs that help development
We package everything as a debian (with jdeb) or RPM (with https://ctron.github.io/rpm-builder/) file. Its easy, reproducible and also painless to remove again.
Why should we avoid the openjdk8 image? 
Full disclosure: I work for Red Hat. I would suggest having a look at OpenShift on AWS or GCE. The reason being is that you can integrate a complete DevOps CI/CD environment and take advantage of it's features which extend Kubernetes (e. g. Source-2-Image). There are publicly available Ansible playbooks/inventories to help install/provision OpenShift. Also, you get a really nice and simple set of tools for management. https://aws.amazon.com/about-aws/whats-new/2017/09/red-hat-openshift-container-platform-on-the-aws-cloud-quick-start-reference-deployment/
What's efficient depends on your size, but for larger sized deployments on AWS I would choose something like Terraform for scripting the environment, and either build my own Kubernetes setup, or use something like Tectonic. Terraform gives you platform independence, and is open source, and I would choose that instead of CloudFormation Templates. Keeps your environment nice and scriptable and reproducable. If you don't deploy micro services, or you have a smaller amount of apps, just use Terraform with EC2 managed Tomcat instances. 
Learn both by writing programs that utilize both. There is no better way to learn.
I'm not convinced TDD is the proper way to go about testing.
When I get handled an old Java project that needs a bit of refreshing, I like to start with upgrading dependencies, fix tests, fix build issues. This to get a feel of the state of the codebase. The older it is, the worse these things usually are. What ever things are built with doesn't really matter, just get a feel for it, and work your way trough the changes. If the app is without test coverage, at least try to implement sane tests for whatever you are changing. If you are allowed to do these things (aka refactoring), existing codebases are excellent places for learning... Oh, and Tapestry 5 is still maintained, I have seen far, far worse than that out in the wild...
Because it's massive. Every time there's a security update in the lower images you have to upload several hundred mb again. There are the slim and alpine variations that are smaller
Pity , there will be no Java X...
I would echo the Docker/Kubernetes sentiments elsewhere. The Docker format provides a really nice way to package up an application and all of its inherent dependencies in a host-agnostic way. Kubernetes gives the base platform on which we deploy those containers and manage them at scale. In terms of Kubernetes distributions though, we use Red Hat's OpenShift Container Platform, which gives a nice user experience, and helpful things like network multi-tenancy, inbuilt docker registry, source to image builds (so the devs don't need to actually KNOW Docker) and a bunch of other stuff. Platform instances deployed on prem and in AWS so we have a decent layer of agnosticism between our applications and our infra.
So, Oracle finally found a way to make money of Java updates? Good for them, I guess. Bad for everyone else, because if I interpret this right, we'll have to constantly jump to new versions to get rid of bugs except if we throw money at Oracle...which is most likely their intention.
So how do you deploy Java to your containers? 
you're wrong
Go on, I'm listening...or, maybe reading would be the better term.
the lts versions will be three years of free support, but customers who want to stay longer can pay. paid support will not be available for 18.3 on the other hand
Core JAva Program Learning
I just ship wars &amp; jars, whoever is packaging does whatever he needs to be done. On AWS you can just drop a war on ELB and that's it. If you're not working on hosted systems but a SAAS solution, you don't really need more than this kind of simplicity imho.
By using the slim or alpine variations
I wonder if this will also lead to faster deprecation / removal.
Use one the alpine-java images or [build your own](https://developer.atlassian.com/blog/2015/08/minimal-java-docker-containers/). Don't forget to make it [CPU / RAM aware](https://blogs.oracle.com/java-platform-group/java-se-support-for-docker-cpu-and-memory-limits). If you're willing to run it on Java 9, you can slim down the JDK itself to what your app needs. The smallest image running alpine linux and java.base should be around 20 MB. ([Video](https://www.youtube.com/watch?v=UNg9lmk60sg&amp;feature=youtu.be&amp;t=1h37m32s) of Mark Reinhold doing a presentation).
We use drone and Gradle to build an Uber jar and load it into a docker image. The image gets sent off to a repository. Then, we deploy the docker image to kubernetes, injecting any variables/configurations in as environmental variables using secrets or static configs. 
I couldn't extract that information from the video (that LTS versions aka Oracle JDKs will be free of charge), where did you get that?
well the biggest problem I still have with the API is that `Connection` is also a `OperationGroup`, that does not make too much sense since basically I understood that `OperationGroup` is some kind of `Transaction`. Basically from a aka-stream perspective it still looks nice. Basically an operation group can have a internal `Source&lt;OperationGroup, NotUsed&gt;` and then when calling `submit()` the `OperationGroup` source get's flattened into the connection. What I also found displeasing is that there is not a "High Level DataSource", I think it would make more sense to create a `OperationGroup` from a `DataSource` and don't care on which connection the actual operation runs. That would actually make `parallel()` more useful, since you can just spawn the queries on multiple Connections and the user does mostly not care about that. Most databases can't run queries in parallel on a single connection anyway. I'm really happy about the API and currently I'm trying to build a toy version with akka-stream on the current version. 
When I interview for potential new-hire Java developers, I don't concentrate necessarily on Java. This may vary between companies, but if you can code in C#, you can be a Junior Dev in Java. I'm looking for a mature understanding of coding. Anybody can read about O(n^2) vs O(n) algorithms. These are academic understandings of code. I'm looking for people who have some level of real experience with code beyond examples from a textbook. One specific question I ask is "Tell me about a time when you found a particularly difficult bug. What did you do to find and resolve it?". This can come from a school project or an internship. The bug isn't as important as how you found and resolved it. Basically, how do you solve problems using code and how do you break down where possible problems could lie. There are also basic questions I need to ask to make sure you know the basics such as "What is encapsulation" or "What is a stack" or "What is the difference between a statically (or strongly) typed language and a dynamically typed language". Then I typically have some basic coding problem such as "I need you to write a program that can play hangman. I will choose a word of varying length, your program will guess letter by letter, I will respond with either a position (if the letter exists) or a no". I'm not looking for you to write an entire program on the spot, but just give me the basics of what you would do. The level of this response will vary on interviewer. If they give you a problem like this, then leave you alone for 20 minutes, then they are expecting you to at least write some pseudo code. If a question like this happens while they are chatting with you, it's probably the kind of answer I mentioned. Think method names rather than programming details. If you can mention Java libraries or basic Java constructs (such as a HashMap or ArrayList), that lets me know that you can solve the problem in Java as well and is usually a plus.
How stable is the CPU/RAM (particularly the RAM piece with cgroups in your experience? I am currently implementing this solution but i get weary of using anything that is marked "experimental ", aka UnlockExperimentalVMOptions
I would rather simply go with first, second and third release opposed to month or quarters. I never even thought that Intellij did it with quarters, I thought it was simple increment.
Usually the face-to-face interview is the hardest because they will drill you, ask about algorithms etc. On phone interviews generally get asked about your experience, what projects you have worked/working on etc. if you say you know HTML5 and JSON, will you be able to explain a cors issue? If you say you know JavaEE, will you be able to tell me about JAX WS? During phone interviews, its more about explaining what you know is going to help them. Like I said, the face-to-face is when you're getting drilled.
Wow. Never came across this approach. Will look that up.
EAR -&gt; Docker -&gt; AWS
ExpectedException or @Test(expected) annotation are both poor, as you can't test for anything more than message and using try/catch inside tests just looks really bad as you might be catching test exception instead of "class under test" exception So obviously the proper way to go is to use junit 5 assertThrows or if you are stuck in legacy java versions, then assertj's assertThatThrownBy method. Also using verifyZeroInteractions(b) is nothing wrong as you are double checking that service wasn't invoked due to method being interrupted by an exception.
wow, basically 2 sentences and I only managed to finish one
Oracle jvm or openjvm are the most popular
Haha I thought I was taking crazy pills :)
We use Gradle's "Application" plugin to create a zip/tar package that is then deployed to S3/OpsWorks by a custom Gradle plugin (with a little Chef stuff to unzip/setup the services).
I've no experience with it unfortunately, but the blog post states: &gt; The -XX:+UnlockExperimentalVMOptions is required because in a future release transparent identification of Docker memory limits is the goal. From that I imagine it is only "experimental" because they intend to not look at linux cgroups - which docker uses, but actually query docker itself for what it uses (because that may change in the future).
I guess it is a consequence of many projects not respecting the actual semantics of semver.
Sounds like I'll be sticking with Java 8 for awhile.
Would you care to elaborate more about the Gradle and Cheff stuff. May be a link.Thanks.
What's the box that you are looking for? Base image for your container?
Well you won't guess it.. I have actually a business need to test the toString() methods... I'll just say: Json and elasticsearch
Interesting. So when you say Dev doesn't need to know Docker, OpenShift will take care of creating images based on? (your global specifications/Docker file)
Cool. Pretty straightforward I guess. Is it on premise Kubernetes or public cloud?
I haven't used Tapestry 5 in about 5 years, so my opinion is admittedly dated. I really like tapestry's DI stuff. I think constructor injection is clean, I like the design pattern builders (strategy builder), and the by default lazy bean init. I'm not a huge fan of the ui tier (as it sat 5 years ago). Prototype based js felt clunky, and there were some weird side effects (protected instance members were odd IIRC). The Ajax support felt dated in 2008, and it was fundamentally page oriented, so building anything "single page ish" was challenging. The 5.0.x series also had some glaring security violations, like being able to trivially access any file under WEB-INF with a browser. This got fixed but it was... stressful to find this in production. My biggest challenge with Tapestry, however, was the comparatively sparse (at the time at least) ecosystem. I had to handroll a bunch of integrations (spring security ACL for example) and I just found myself writing a lot of library glue code.
Yeah, this sucks: ```@Test(expected = NullPointerException.class)```. My coworker actually did this. 
Right. It seems at the moment the only real "out of the box" option for running java 8 microservices is to use these settings? I have also found a different docker base image from fabric8 which evidently uses a custom script that does the cgroup memory calculation and dynamically sets the jvm options. However im even more hesitent about using that until i fully understand whatthe script is doing. https://hub.docker.com/r/fabric8/java-jboss-openjdk8-jdk/ 
You can always specifiy the exact memory limits if you know the environment it runs in is never lower than that.
One issue to watch out for is that Alpine uses musc-libc, which may behave slightly differently to glibc, but as long as you're aware that any issues you have might be due to that, I see no issue with using alpine; just switch if you can't explain a bug during testing to rule it out.
Very true. If possible i would love to avoid thilese hard settings as its one more thing to remember for scaling/performance tuning but that may just be reality
Somehow I didn't know about jdeb. Thanks so much!
Well basically [Gradle's application plugin](https://docs.gradle.org/current/userguide/application_plugin.html) allows you to package your application into a zip or tar with the distZip and distTar tasks. After this, we wrote a Gradle plugin to copy that archive to an S3 bucket, change the path to the [OpsWorks application source](http://docs.aws.amazon.com/opsworks/latest/userguide/workingapps-creating.html#workingapps-creating-source) and trigger a "deploy" action on the OpsWorks application(can't share the code unfortunetely, but it's just a wrapper around [AWS' Java SDK](https://aws.amazon.com/sdk-for-java/), probably &lt; 100 lines of code). The Chef stuff is just what OpsWorks uses to deploy your builds. Again, can't share the code, but it's basically downloading/unzipping the archive from S3 and calling some pre-defined scripts found in the archive (install, start, stop, uninstall, etc). These scripts copy stuff around and start/stop services.
you could try looking it up? [mark rheinhold on the new release schedule](https://mreinhold.org/blog/forward-faster) [more from mark rheinhold on the new release schedule](http://mail.openjdk.java.net/pipermail/discuss/2017-September/004281.html) notice neither of those say that LTS releases will be exclusive to oracleJDK. in fact, when oracle jdk is mentioned in said discussions, it's for special features, while openJDK remains the reference implementation. he also talks about opensourcing more special features from the oracle jdk to make openjdk attractive to developers. it doesn't make sense for him to be talking about a new release cadence and system wrt openjdk, talk about LTS in that context, and then leave out that "oh actually LTS versions will be oracle jdk only now and also paid"
Our services are built, tested and packages as containers through Gitlab pipelines. They then get automatically deployed in our Kubernetes cluster. 
The slides from the JavaOne session "JDBC Next: A New Asynchronous API for Connecting to a Database" are available in the session catalog now: https://events.rainfocus.com/catalog/oracle/oow17/catalogjavaone17?search=%22jdbc%20next%22&amp;showEnrolled=false.
Everything is doable-- but it is a lot of super convoluted run statements. I use Debian most, except when another distro is clearly the better base-- like haproxy on alpine... This may be a bad example, but this is something more easily done on a full blown distro: cat &lt;&lt;EOF &gt; /etc/hosts 127.0.0.1 localhost.localdomain localhost 127.0.1.1 debian $IPV4 $HOSTNAME.$DOMAIN $HOSTNAME # The following lines are desirable for IPv6 capable hosts ::1 localhost ip6-localhost ip6-loopback ff02::1 ip6-allnodes ff02::2 ip6-allrouters $IPV6 $HOSTNAME.$DOMAIN $HOSTNAME EOF Granted networking is handled by docker, but you get what I mean. This is how I like to configure a lot of things that aren't networking as well.
I will give this a try.
JWT is easy to get wrong, and it pointlessly shifts secret information (albeit encoded) to the client, which you can otherwise retain on the server. So I'd say: yes, JWT is neither a general-purpose solution for authentication, nor it should be anyone's default. It has its purpose and application, but most people don't need the complete decentralization it offers. Decentralization is a drawback when you don't need it. The alternative is a simple random token key of *at least* 128 bits, where the payload is kept secure on the server. Also makes revocation much easier.
I believe the problem is when they are used for session management. For REST APIs they should be fine if used properly. https://www.owasp.org/index.php/REST_Security_Cheat_Sheet#Access_Control https://www.owasp.org/index.php/JSON_Web_Token_(JWT)_Cheat_Sheet_for_Java
This looks promising. A quick read through made me realize this is something what I was really looking for. Let me try this. Thanks for the resources again.
What if you have a Web Service (JSON) that needs to maintain session? User authorities, etc?
I understand the new scheme, but I don't understand who it benefits and how. It's more chaos, the version number no longer communicates if it contains breaking changes, and it no longer clearly communicates if it's supported. It just communicates when it was released, which is absolutely irrelevant to anyone.
often when you think you need to "maintain" user authorities you actually don't, you need to really make sure secure transactions are atomic, and if you can run an authority check per operation. in short use sessions as sparsely as possible. 
&gt; pointlessly It's hard to take this comment too seriously when it begins by offhandedly dismissing server-side statelessness as "pointless"...
But we can say *currently* JavaEE is not heavyweight, right?
Once you have OpenShift up, you can have a look at the seed we have for CI/CD. https://github.com/rht-labs/labs-ci-cd. It includes Jenkins, SonarQube, Zed Attack Proxy, etc... 
To have decentralized authorization is an explicit requirement, which was not mentioned by OP, so by default it's "pointless". Almost no service is actually entirely "stateless". So whether you get to benefit from "stateless auth", in specific, is dependent upon details of the service you implement, the architecture you choose, and the scale you must support. To push for such supposed "nice-to-haves" that complicate your security setup *without* explicitly benefiting from them in the concrete scenario is reckless and points to probable lack of experience.
It has something called Source To Image. It takes a base Docker image as provided by the platform, and will overlay your application artifacts onto this base to create your actual application image. As this is deployed to the OpenShift Docker registry by default, and is immediately consumable, the actual devs get to focus on writing code rather than how that code is packaged and run. The base Docker images themselves can be provided at either the cluster level, or by a user level (per project) if they know what they’re doing. A good example is the Wildfly JEE server. In a stand-alone VM you might commit your code to git, kick off a Jenkins build to create your WAR/EAR file, throw that into a Maven repository, and from there you can pick it up and deploy it into Wildfly. In OpenShift, you supply your git repo and your Wildfly Source To Image...uh...image, and OpenShift will clone your source code, do the Maven build internally, layer the resulting WAR/EAR over the top of the Wildfly image, and push the resulting container image into a Docker registry, from where it can be run just like any other Docker image. Which is all pretty cool. It doesn’t mean you can’t just bring a Dockerfile to the table and go nuts - you absolutely can - but it takes away a lot of the learning curve around developing container images and running them at scale. 
I recommend using intellij IDEA and its Tapestry 5 plugin.
It will depend on the interviewer. Everyone has their own approach to interviewing and there is a lot of variation. You can't prepare perfectly because there are infinite possibilities. Focus on what you understand the job requirements to be and expect that sometimes what you are asked in the interview won't be aligned with that.
We are having a custom mechanism based on JWT. It's very simple, basically some filters and some tokens that have very little information contained into them. Based on the token we are having some caches with other user associated data. The site we are working for is exposed on the internet, has lots of traffic and we were targeted by some malicious activities but until now everything was bullet proof. Also, even when the traffic is high the system ressists because it's easy to scale horizontally. The secret was to let a guy who really knew what he was doing to get it done. So short answer: we are using JWT. 
Once you take revocation into account, it basically turns into regular token auth, i.e. maintaining some kind of state server side such as user-specific signing keys, etc.
You really shouldn't be storing session state in a JWT. Session state is also not something that Spring Security is concerned with. JWT is perfectly fine when you are storing *authorization* information (such as user roles), which allows resource servers to authorize requests without having to go to a central authentication server. JWT should be short lived and used in conjunction with *refresh tokens* (which are just random strings). Session state is different from authentication/authorization. To keep session state secure, you really should keep it on the server. This is the easiest way to secure session state, through centralized control. This does go against REST, which suggests distributing state to clients for scalability and client independence from the server (in case you lose the network). Distributing state to the client does introduce security concerns, which means that the server will have to perform security checks on requests to ensure that the client doesn't get the server into a bad state.
I don't like the word heavyweight as I said above it seems to mean different things to different people. I also don't want to spiral this into yet another Spring vs JavaEE discussion (as the original video is not really about it). However I cannot resist to give you a small hint. The fact that *currently* the EJB subspec is called officially **EJB lite** will tell you everything you need to know. 
A simple key vending backed by a cache works pretty well. A bit like this: http://arjan-tijms.omnifaces.org/2014/11/header-based-stateless-token.html
Going overboard with mocks, so that eventually you’re mostly testing the mocks and barely any actual code. Things then fail in production, since obviously in production the real code is deployed and not the extensive mock system.
Maybe your issue was.... reading comprehension? Sidebar: &gt; Please seek help with Java programming in /r/Javahelp! But for real, try posting there instead. Also, be more specific with what you need help doing. Maybe some examples of what you got wrong, and or what you didn't understand.
Thank you!
Lol why don't you back of any of your "arguments" then, like in this thread where you're trolling your competitors and clearly have an agenda. I put my agenda in my username. https://www.reddit.com/r/java/comments/730jgf/spring_framework_50_goes_ga/ I'm watching you now.
Not OP too but i think it's a great way to force me to study, i learned a lot trying to get my certifications.
Spring's 'RememberMe' token. If its db-lookup-per-request affects performance you can use cookie based sessions; optionally redis-backed if you need scale or distributed servers. Because of the power JWTs give a hacker I wouldn't consider them unless I was sure there will always be *VERY GOOD* secret management. Like 'what's the worst someone could do if they could pretend to be an admin user without us noticing' level risk. Spring's RememberMe token is based on a hash of the user's password which gives the advantage (?) that the token expires when the user changes their password... If that's what you want.
&gt; redis-backed Redis is not a durable persistence layer (it does not make any Durability guarantees) - please do not use it for auth. (P.S. unless of course you really know what you're doing and can setup AOF and compaction)
&gt; To push for such supposed "nice-to-haves" that complicate your security setup without explicitly benefiting from them in the concrete scenario is reckless and points to probable lack of experience. The over-generalization and misrepresentation of a single straw-man requirement of all software in the world vs only a single straw-man benefit of a security mechanism **points to probable lack of experience**.
I'll be honest: I've no idea what you just said. 😄
The token lives in a proper database. I suggest Redis as an optional transient cache mechanism if needed for scale and performance. A Redis-backed session, like a normal session stored in RAM, should expire after not being used for x mins. After that Spring will automatically recreate it at the cost of the db query to verify the token. You get this pretty much for free with Spring and free with http clients which store and return cookies: always pass the token, if the session exists the request is authed with no db access, if not the token is looked up and session created and cached with expiry and cookie returned ready for next request. Another feature this enables: if you change a user's role just delete their session which will cause a re-query which will pick up the new role.
Like any tool when someone ya no idea what they’re doing it is insecure. There’s nothing wrong with jwt tokens if you know what you are doing. 
Javafx. It's easier to code and supports CSS. The only real advantage swing is that it supports native look and feel. 
JavaFX. Scene builder makes it a lot easier
I'll have to check out what the scene builder is. The name is very vague and non descriptive.....
Any good links to tutorials?
I've used FX in the past and while I cannot reccomend a good tutorial at this time, I found this article very helpful: http://code.makery.ch/blog/update-to-javafx-8-whats-new/ In the absence of Spring Autowiring, if you feel like you need DI, there is a great guice plugin for FX which will let you inject dependencies into your FX controllers. https://github.com/cathive/fx-guice
If you use spring security oauth, you can configure it to give you access tokens. You can then exchange this access token for your user info from the auth service. It still tries to give you that session garbage, but with the right configurations, you can still get stateless authorization with it. But answering the question in the title, I use auth0 for my personal projects (which give you the option of using both jwt id and secure access tokens). At work, I've made my own OAuth monstrosity that runs on AWS lambda behind API gateway. It gives you secure access tokens, and no JWT. For my other services, API Gateway is configured to add stateless authorization via a lambda, which exchanges your access token for your profile with the auth service, and then returns all the api gateway endpoints you have access to based on the grants in that profile.
I suggest don't look at what it is as its drag and drop GUI design which sucks. Easier to code UI IMO. If you do then here is the download http://gluonhq.com/products/scene-builder/#download I recently made a javafx app, there were no tutorials that were of value (most just silly hello world type ones) and generally was quite painful to learn. The only reason I picked it up a little faster was I knew a little swing previously so I sort of knew how to structure things. I found the most value in looking at oracle docs. Here are a few links from my bookmarks I did use. http://docs.oracle.com/javafx/2/layout/builtin_layouts.htm https://docs.oracle.com/javase/8/javafx/user-interface-tutorial/ 
&gt; 4) You can call static methods on null references This is one of the hidden detail of Java programming language that you can call a static method on null reference and code will not throw NullPointerException. This happens because a static method is bonded at compile time by using the class name only. Ha! I knew Java was based on Visual Basic.
Works great. Someone else said package as a .deb. That would work too. The overhead of dealing with Docker seems like a solution looking for a fix.
Perhaps check out Fernet.
I agree that an unit is not necessarily a class. An unit (system under test) is what you want: class, function, method, package, project, sub system, system, the list goes on... i think there is not a general rule (no silver bullet)
Part of the issue with JWTs as session tokens is invalidation on demand. Most are based on expiries. The solution I implemented was to have a randomly generated 'token version'. Upon receiving a JWT, check the token version against the user record for token version. If a user wants to invalidate their tokens, generate a new random token version and store it.
well stated.
My employer hosts all their application servers in AWS. My development environment lives there, too, in the same subnet. I spin up a new server, run a configuration script for application user settings, load it up with required libraries, have Gradle generate application runnables specific to the target server, copy the files manually, set up any cron jobs, and boom, I'm in business. Spinning up a new server takes about an hour with all the prerequisites. We do that only for a separate suite of applications, or to scale up our ability for simultaneous processing. Regenerating the application distributables takes seconds. Yay for Gradle! We use near-continuous integration. We don't use AWS' code pipeline, because I haven't gotten it to work yet. I deliberately avoid overwriting the currently-known good version by loading the new application version into a versioned folder, so I can run a full integration test independently of the production application, inside the production server (rather than a copy). After the new version is proven to work correctly, the old version is removed from the server. A copy is retained in our version control system. 
How can you ask what are the basics? I mean if someone graduated from college and passed the tests, there's no way he doesn't know the basics, seems like a waste of time.
&gt; I recently made a javafx app, there were no tutorials that were of value [This one](http://code.makery.ch/library/javafx-8-tutorial/) would have covered quite a lot. Doesn't prevent you from going through the docs, or looking up other tutorials, once you want something more challenging than basic office applications, but I like that tutorial quite a lot. &gt; I suggest don't look at what [scene builder] is as its drag and drop GUI design which sucks. I completely disagree. It lets you create fxml files via drag and drop, you can adjust most things in the code and layout part, it lets you easily link elements and code, and has a nice preview option. In short, it let's you get shit done extremely quickly, so that you can spend your valuable time on the code that actually matters. &gt; The name is very vague and non descriptive No, the name is very descriptive, actually.
2\.) You cannot use this and supper inside static method What about dinner? 
But Swing is no longer maintained, so even for this reason, it should be avoided.
In the sci fi book "A Deepness in the Sky" one of the main characters is a computer archaeologist. It was his job to look through thousands of years worth of code, piled layer upon layer to understand how his ship worked and to get his crew out of hairy situations. I always imagined him thinking of Java the way we think of Sanskrit.
We use keycloak with openid connect and spring security. Keycloak has a great documentation with lots of examples on how to set up spring and other frameworks.
Loved that book. I think I might dust it off and give it another read. 
So now you know how everybody else feels reading your comments
&gt; I've recently come across several articles claiming JWT is not secure Care to link these? Because I'm getting the feeling you might simply misinterpreted them (or the articles themselves misinterpreted something). Most important bit to understand when you're implementing JWT is that you have to know the standard has a [glaring fault](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/). TL;DR: the standard has a 'none' algorithm that some libraries accept by default. It's retarded to even have this in the standard but it's something you need to be aware of in your implementation. Other than that JWTs are not 'not secure' at all. 
&gt; JWT is easy to get wrong, and it pointlessly There is nothing pointless about this. The reason JWT is working this way because having every single service HAVE to go to a central authority to verify a token for every single request completely messes up your scaling. Every single service hits that same service that is hitting that same database on every single request. There is nothing wrong at all with having the client sending these claims as opposed to each and every service having to contact a central 'auth' service to retrieve the claims associated with a session ID or token. JWT only has one drawback and that is revocation. Which is why they are generally quite short-lived. So unless you for some reason need immediate revocation there are no real drawbacks to using JWTs while it does has benefits; decentralisation and ease of implementation, 
True enough, however on the flip side JavaFX doesn't come with all JRE releases(mainly an issue with Linux OpenJDK and embedded devices like RP3). So releasing a JavaFX application with intended support for Linux can be a minefield where Swing isn't. Well, you could just do a native package for each platoform - if you want to upload 200MB and users download that same file size.
JWts don't magically make your security setup more complicated. If anything using JWTs is less complex than having to go to a database or different service of every single request.
&gt; Upon receiving a JWT, check the token version against the user record for token version. In the database?
Exactly. The lightweight vs. heavyweight 'debate' is pretty nonsensical. Everyone has their own definition. If they want the EE4J imago to improve it would be simply a matter of making sure people can get started just as easily with EE4J as they can with Spring or any other microservices framework. 
**Sidebar** -&gt; + **Do not post tutorials here!** These should go in **/r/learnjava**.
What do you mean by absence of spring? You can use spring with javafx just like you using it with guice 
Yep, although one may argue it defeats the point of a JWT. You could use Redis as a cache for the token version
&gt; Yep, although one may argue it defeats the point of a JWT. It most certainly does. You'd be better off just storing the entire record then. &gt; You could use Redis as a cache for the token version You can also just use Redis to cache the entire record. You're just overcomplicating stuff.
Yeah, you're right. I'd argue the edge case though would be if 'users' have lots of tokens.
&gt; JWts don't magically make your security setup more complicated. - You risk your JWT library accepting unencrypted payload (this has been an actually vulnerability on at least several JWT libraries, as "none" is a valid encryption algorithm on a JWT). - You risk that at any moment your encryption be rendered weak or broken due to malfunctioning entropy sources (lots of example of that in the industry, even down to the OS level), incorrectly implemented algorithms, broken encryption algorithms etc. - Now you have to distribute manually and manage secrets to every server which will expire over time with a rollover period for existing keys, so you will have multiple encryption secrets that are valid at any point in time, and any incoming JWTs may use any of them. You better not get any of that wrong! - Just one line going wrong in your library after an innocent update, and suddenly signing is bypassed (again multiple examples of this in real-world JWT libraries and encrypted cookies in Rails and so on) so anyone can mess around with the payload and gain access. - Several examples of JWT libraries HMAC-ing the payload with the *public key* of the server, which means everyone has access to it = anyone can sign the payload. - You risk the operations guy being a moron and using weak secret keys that can be brute-forced. - You can't revoke tokens on demand. - You can't update the payload for all users in a central atomic way, instead you need to version your payloads and support old versions for as long as the token is valid (which can be an entire year on some setups). This instantly multiplies the complexity of your JWT payload handling code. Calling a database is not a complicating factor. Calling a database is easy. And the above problems are actual complications, either because they take away useful features away from you (central payload management, revocation), because they add lots of technical debt to your code (payload versioning, multiple secret keys with rollover) or because unless you control how you use JWTs very closely, you're good at cryptography enough to spot weaknesses and inspect the source of the libraries you use, you render yourself vulnerable to trivial attacks. If you think JWTs are easy, then you shouldn't be using JWTs because the chances are you have no idea what you're doing. 
Unless you really need Swing/AWT, e.g. because an employer requires it, you shouldn't waste your time with it. JavaFX applications are much easier to maintain. JavaFX makes use of the MVC design pattern and changes to the user interface don't necessarily require changes of the Java code. JavaFX uses its own markup language, FXML, to define user interface elements (controls). Controls can be mapped to CSS classes in order to specify their visual properties. Controls can be injected (DI) into a controller class and therefore don't need to (but can) be declared programmatically. [Gluon SceneBuilder](http://gluonhq.com/products/scene-builder/) makes it easy to design simple GUIs. It's also useful for learning FXML by example. The [official documentation](https://docs.oracle.com/javase/8/javase-clienttechnologies.htm) is all you need to get started.
&gt; There is nothing pointless about this. The reason JWT is working this way because having every single service HAVE to go to a central authority to verify a token for every single request completely messes up your scaling. Every single service hits that same service that is hitting that same database on every single request. New at programming, I'm guessing? Tokens can be cached, you won't "HAVE" to go to a central authority on "every single request", that's a terribly naive and biased analysis of the pros/cons of both approaches. &gt; ease of implementation There are countless ways in which you can accidentally open the JWT payload for access and forging by hackers, just Google up "JWT vulnerabilities". If you think JWTs are easy, you don't know enough about JWTs to be using them.
Nice to meet you, Everybody Else.
You're completely right on the "none" algorithm. It's retarded. I addressed that in another comment as a 'weakness' of JWT in general that developers need to be aware of. But I do feel you're bunching "JWT libraries" and "JWT" together too much. As a developer you can't just grab a random bit of code from the internet and assume it works; especially when it comes to security. Broken libraries are always a problem but not related to JWT itself. Aside from the "none" algorithm that should not exist (somewhat similar to how AES ECB should almost never be used) JWT itself only has one real drawback and that is that you can't revoke them immediately **without revoking all of them**. So there is actually a mechanism to revoke them if shit hits the fan, it just makes all of them invalid. This is however just a tradeoff. It doesn't make them 'insecure'. If not being able to revoke immediately is not an issue (and it rarely is; normally you would use tokens with a relatively short livespan of an hour tops) it doesn't really have downsides over using a 'normal' token. Also: &gt; Calling a database is not a complicating factor. Calling a database is easy. I am not talking about that SQL is easy. I was talking about having a cross cutting concern rely on a single store. If that database or service is down you have to handle it. A JWT mechanism is decoupled; you don't have to go to an external resource that might be down or overloaded on every request. So it's simpler to implement and much simpler to scale. Don't get me wrong: JWT is far from a silver bullet. But I feel it's simply wrong to claim it's insecure. Anything that's used by inexperienced developers is likely to be insecure. 
&gt; The secret was to let a guy who really knew what he was doing to get it done. Unfortunately not every JWT implementation comes with one.
&gt; New at programming, I'm guessing? Why would you do this? Up until now it was a nice discussion about the pro's and con's of JWTs. You ruined any chance of us learning something from each others by starting with a huge insult! Such a shame :(
Suggesting that highly cacheable data HAS to be fetched on every request means you're either new, or intellectually dishonest, or not very good at problem solving in general. I assumed the least insulting option. 
I've been interviewing for 3 years. You might be surprised. Just because you knew the answer to a test 3 years ago doesn't mean you've internalized the meaning. I ask the basics because I've had college graduates who can't answer the basics. This also provides feedback to our recruiters. If we get a number of bad I interviews with a particular major/school, we'll stop offering interviews there 
I feel obliged to put in the customary introduction to the valhalla project. bring it :P https://www.youtube.com/watch?v=CZ_VFJn2kJM 
In theory it will allow developers to use new features faster, obviously causing headaches for the ops department if they're still using a VM infrastructure: "Could you update all 100 VMs to Java 19.3 please? That's what our application currently requires." With Docker it's a lot easier, you could just update your image to be based on a newer version. So if you're using a modern infrastructure, it's a win for the entire devops team over the current model (1 giant release every 2-3 years). The danger with the train is that features get rushed if they're close to making it. Even if the loss of one half year is minimal, it's still a deadline and deadlines have weird effects on people.
I also learned from that tutorial, the rest I picked up pretty quickly on my own. Note that JavaFX also does simple 3D. Used to build [this](https://github.com/Nurtak/ObjectGraphVisualization).
will this help Java evolve faster as a laguage? like C# did?
Actually data preservation is a real issue. We already have stuff left over from the 80's that we can't read because the hardware, software or documentation is gone. And that's only 30 years ago, imagine 50 years from now. Will we still be able to play mkv files? Read docx files? Figure out the plethora of compression and encryption techniques? Will the media we use to store information now still be accessible, how long do hard drives and flash drives really last? Suppose another world war destroys much of civilization, will the people of the future even be able to figure out how the information is coded onto present day hard drives and flash drives?
I recommend JavaFX but instead of getting disappointed with FXML you should get into TornadoFX with Kotlin which provides a very nice DSL to replace FXML. [Guide](https://edvin.gitbooks.io/tornadofx-guide/content/)
Apache Brooklyn. Dev deploys to GCP, prod to our private cloud.
I'm inclined to say yes, Java is looking at language improvements such as project Valhalla, but it's hard to escape from the prison it put itself in. Language stability is huge for enterprises because it means that it's pretty safe to invest in Java. Compare this to a flavor of the month jungle like the JavaScript ecosystem. So it would be interesting to see what kind of features we actually get, whether it would be improved APIs or actual language constructs.
Same with old books, ink disappeared, book destroyed or burned etc, nothing last forever, at least we can now replicate data everywhere in the world without issues
How are you keeping your JWT secret secret?
&gt; JWT only has one drawback and that is revocation. Not a drawback at all because with non-JWT tokens you'd have the exact same problem: You need to ask a central authority (redis, db, whatever) on each request. Maintaining and scaling a DB/cache for a small number of revoked tokens is still way easier than doing the same for thousands or millions of valid tokens and their payload.
I often test toString if the implementation is non-trivial since getting NullPointerException (or whatever) from toString while debugging something else is really annoying.
Try Jasper Reports
Oh...i didnt realize you had autism. Sorry dude.
[You're a fellow sufferer?](https://www.reddit.com/r/programming/comments/74lwoo/reactos_repository_migrated_to_github_migrating_a/do0h9s6/)
I'd actually go with Dynamic Reports. It's built off of Jasper.
I didn't realise people thought about Sanskirt at all and I studied that for 5 years. 
Nice, I've been looking for a good scifi book to read
Especially when so much of our legal system's resources are dedicated to stopping people from having the ability to convert cultural artefacts to newer formats.
Sanskrit? "We" think of Sanskrit? I don't think of Sanskrit. I doubt most of the world thinks of Sanskrit or like me even knows what it is, what an odd comment.
I've tried it a bit. I tried building OpenJFX with it, but unfortunately there seems to be a problem with getting gradle to build it. I reported the problem, and the team responded quickly. They seem to be working on the issue. OpenJ9 seems to have some interesting features, so I'm hoping the project succeeds.
Yes and no. One consequence of the more-frequent releases is that there are more opportunities to make API changes. So if we decide to deprecate something, we can do it within six months instead of potentially waiting 2-3 years. If we decide to remove something, we can also do that within six months after it's been terminally deprecated. But we probably won't remove things that quickly if they're in use, in order to give people more time to migrate.
I think we've got better at using documented formats. And we've got better at using open formats. Formats with multiple independent implementations/documentation. I think we're certainly going to struggle with hardware though. How much data is on old tape formats, or on old SCSI drives. Look at the connectors that have come and gone over the recent years. FireWire anyone? 
I think you've missed the point. And kinda prove their point at the same time.
This only encourages me to continue writing obfuscated code. I want some guy from 200 years in the future to be like, "Who the fuck wrote this shit?"
Wait. Who said that Java is dead? I mean, it's Java.
You can do SAP Crystal Reporting in Java. http://www.javathinking.com/2011/09/using-crystal-reports-java-api-to.html It might not be able to use all the functionality you want though. No one can really recommend anything to you without knowing exactly what you need. Birt reporting is another good open source reporting tool use extensively in Java applications. 
If you have to write articles arguing Java isn't dead, it's _definitely_ dead. 
Correct me if I'm wrong, but as far as I know, Dynamic Reports is especially useful if you want to design reports using plain Java code. This is nice when you have very simple reports and just want to visualize some data. If you want to visually design complex and pixel perfect reports, I'd go with plain Jasper Reports in combination with Jaspersoft Studio (I don't know anyone who's masochist enough to want to write the jrxml files by hand). Like most visual editing, this is primary useful for static reports, where columns are known at design-time. If you have dynamic requirements (columns are only known at runtime), Dynamic Reports might be better. Another thought: wasn't there a Java SDK for Crystal Reports? Or is it not maintained anymore? If there is, it could be wise to use the technology you and your team are already familiar with.
I get the point you're trying to make about the point you say I missed and paradoxically proved. That only works if I had an inkling of knowledge of Sanskrit. It also only works if "we" as in all the readers of the comment also had at least an inkling of Sanskrit. That isn't the case. Therefore, there is an open in the circuit of logic and the paradox is broken.
I don't know about the complexity of your reports but a possible solution can be [NextReports](http://www.next-reports.com). It's free and easy to use. The suite contains the engine, client, server and a small Android application. Other option is JasperReports.
The JDK is a platform for application to run on, not an application in itself(well, GUI application anyway). You need to run or create your own Java application in order to use the JDK.
That is because people go overboard with unit(single class) tests. 
Use this only if you plan on doing simple things. Anything with strict positioning, tables and anything fancy, go with the alternatives. Also, the gui for building reports is based off eclipse, so prepare for a crash ready and extremely heavy editor.
Good thing you don't have to.
Ok let's kill the frog by dissecting it. This blog post was about the longevity of Java. However, it would be a point of hubris to say something like "Java will be an actively developed language forever". That being said, I don't think there has ever to date been a more widely used language, both in terms of varied use cases and lines of code written. Sanskrit is the oldest documented precursor of Indo-European languages. It would be a completely dead language if not for religious purposes, similar to how the Catholic church and scientific community prop up Latin. In other words, people know Sanskrit but no one /really/ speaks it or fully understands how an ancient native speaker would use it. In this imaginary universe, our protagonist has probably at times peered deep back into historic code to find some hacked together bits of Java still lying around, but at this point Java is literally ancient history. To someone very far in the future they would look back on Java as one of mankind's first primitive programming languages. He probably would gloss over the outdated references to JodaTime and poor brace indentation in the same way that current listeners of Bach would probably miss that his final Goldberg variation is a lewd joke; the cultural element is missing. Overall my comment was a sentimental framing of Java's current success against the inevitable march of time. I'm sorry if it was upsetting to you.
40% off some arbitrary number. Amazon's price is similar.
Not sure where you draw the line for "simple things". I have some experience with JasperReports to design PDF-Reports for a government in its corporate design (pixel perfection is key). Yes, it can be time-consuming to layout everything correctly, but I never found it particularly hard or had problems. I think JasperReports works alright for reports where the data structure is static (columns are known at design-time). Also I never really experienced heavy crashes with Jaspersoft Studio. But I never use Jaspersoft Studio as a plugin in my existing eclipse installation. I always use the bundled, official distribution from the website. As I always try to be open for new libraries/frameworks: what are those "alternatives" you are talking about?
Effective Java gave me my first big step from writing hacked together "it works" Java, into writing structured well-thought-out maintainable Java. I'm looking forward to this newest entry, because I've been slow to incorporate some of the new language features like streams into my work.
We migrated from crystal to Jasper. The main thing (and the complexity) comes from reports with lots of sub reports that depend on sub reports. We could never get things right and the clients would complain. Also, several times the xml would get corrupted and we'd need to restart ( we were using the official distribution too, by the, just on shitty thin clients that probably couldn't handle them) With crystal (payed license, that's why we were migrating) we never had those kinds of problems, even on archaic software. Also, besides the sub sub sub reports, we also had reports that went way into the hundreds of fields, and sometimes they would just fail to stay put on their margins. That could be due to lack of knowledge but, again, we all did it for crystal and it worked.
Is it? I can't even find the combo (for example) on Amazon. Found the paperback pre-order for $52.
Where's the discount? Do you mean that you can get 40% off the cost of buying the physical book and the ebook together or something? Cause that hardly counts. 
I haven't bought a java book in years. Just happily bought this one. Bloch knows his shit.
It's injected from a remote config server. It's not hard coded in a property file or in the code. 
But unfortunately, when talking about a unit test, people mean a class test.
I recommend you to install it with brew. 
In terminal: // Display the JDK version javac -version javac 1.x.x_xx // Display the JRE version java -version java version "1.x.x_xx" Java(TM) SE Runtime Environment (build 1.x.x_xx-xxx) Java HotSpot(TM) Client VM (build xx.x-bxx, mixed mode, sharing) // Display the location of Java Compiler which javac /usr/bin/javac // Display the location of Java Runtime which java /usr/bin/java
Only the ebook bundle is 40% off. The physical books is more like 20% off. But it is still cheaper than Amazon. Also, instabuy.
Thank you very, very much for this information. I've read the 2nd Edition a few years ago and so many things were right and useful. I will buy this book, when its released. One of the few programmer books worth its money! RemindMe! 2 months "Buy Effective Java 3rd Edition"
RemindMe! 11 weeks
I will be messaging you on [**2017-12-23 23:37:40 UTC**](http://www.wolframalpha.com/input/?i=2017-12-23 23:37:40 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/java/comments/74x9gv/finally_effective_java_3rd_edition/do1zipr) [**34 OTHERS CLICKED THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/java/comments/74x9gv/finally_effective_java_3rd_edition/do1zipr]%0A%0ARemindMe! 11 weeks) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! do1zj1e) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
fwiw, promo code IUGD45 brings the book only price down to $30.24
Injected at runtime so in-memory only? That's much better than most! I'd feel much more comfortable if I thought everyone using JWTs did that... Even if yours were breached (compromise a node and dump memory?) it wouldn't be of much use due to your content being non-obvious, but many implementations will have friendly 'username' and 'role' keys.
Yep, it's injected at runtime from a remote source. We also have the possibility to reset it without deploying everything. Basically it will invalidate all the existing tokens at once, and the users will need to login again. But I think we never used this feature. If you are only a little bit careful, JWT is perfect.
Why not post the link?
You're welcome :)
If you can't find it yourself, it may not be the book for you.
"ad" not "add"
Instant Preorder
Fixed, thanks, was typing in a hurry.
We're currently using [OpenHtmlToPDF](https://github.com/danfickle/OpenHtmlToPDF), it's been working much better than Jasper Reports for us. 
the ebook is a separate order? how weird and archaic. pearson is pearson.
What would be a good book to read after this one?
RemindMe! 8 Weeks
Java Concurrency in Practice is an excellent book.
&gt; Java Concurrency in Practice A bit old though and Brian goes berserk whenever someone asks him when he's going to update it.
He has also stated that any changes he'd make are almost all additive.
so the new certification mark won't be 'ee4j', but also won't be 'java ee'... okay then.
this isn't r/trees ...
It took me about 5 seconds on google to find [this link]( https://www.amazon.com/Effective-Java-3rd-Joshua-Bloch/dp/0134685997)
&gt; Sanskirt i read that as sans-skirt and i thought you were saying something else entirely
thanks for the regular driveby shitpost on your way to r/node. 
such is the age that people proudly brandish their ignorance
The combined powers of Oracle and Eclipse can only produce well designed, elegant pieces of software. 
I made an observation, you made a personal attack.
Where do you enter the promo code during the ordering process?
I entered it after starting the checkout process but before entering my shipping and billing address (there was a link on the sidebar that said "enter discount code") and it worked after the second try.
you attacked culture and civilization through reveling in ignorance. you also pointlessly projected onto "most of the world".
Guys! use JAVASALE discount code. The book + ebook bundle will come to $48.39 which is 40% discount on their list price of $98.98. edit: as mentioned in another comment, IUGD45 gives 45% discount on the list price, please use this .
Amazon link: https://www.amazon.com/gp/aw/d/0134685997/ref=mp_s_a_1_2?ie=UTF8&amp;qid=1507443844&amp;sr=1-2&amp;pi=CB192198896_AA75_QL70&amp;keywords=Joshua+Bloch
Thanks, worked for me
Anyone found similar deal for book + ebook from european shop? Shipping costs $25 plus taxes (20-30% in my country) is too much for me.
That looks definitely interesting. What I'm not so sure about is its stability: the library is only available as a version 0.0.1-RC11. In my current government related project, such a version would never be accepted. How is your impression about its stability and feature completeness? Do you know if there exists something similar for Excel and Word, in case I have to provide reports in different formats?
I'll buy it
Nice. I'd say what you've set up is more than 'a little bit'! I suspect the vast majority of JWT deployments will not be doing anything like this.
Step 1: don't use Java
Book comes out in December, Java 18.3 releases in March, I wonder if they will offer updates for new Java releases in an addendum or something like that.
I don't know how you got this code but it works. Thank you!
Exactly
&gt; A bit old though Still relevant.
Can I still buy the e-book even if I'm not living in the US?
Yes, it's nice. I like the fact, we've 2 free 'top' VMs now and that the J9 is not a one man show project (in fact the original IBM JRE runs the 'very important systems' on the mainframes of banks and such. They've also some 'new Cloud features', but i'm not sure what does it mean. Regarding memory and HotSpot, you can try to tune MinHeapFreeRatio/MaxHeapFreeRatio and also try G1. Also check this article http://www.stefankrause.net/wp/?p=14. But note, that releasing memory is useful only with special setups (for example desktop apps, multiple JVMs where they need more heap, but not at once, night batches where you can use some swap file or zram).
i tested against zulu9 (a packaged openjdk 9), so g1 should be the default
No reason not to, at least the ebook.
Good question. And why do we need new accounts spamming videos of the same youtube channel?
For EU guys who don't like $25 shipping fee - you can get it a bit cheaper at Amazon.co.uk: https://www.amazon.co.uk/Effective-Java-Joshua-Bloch/dp/0134685997/
I’m sure he goes berserk at any question he gets. I’ve been to several Brian talks, and all the questions he gets are the same (not that they’re that bad). It’s kind of what you expect in that job I guess. He has a great bedside manor despite it though. 
Most of what I read in this book first time wasn't news to me, but I *love* it, because I'm nodding my head at almost everything it says, and it straightens out a lot of bullshit I hear from colleagues on what "proper OOP" is. It's a solid part of my arsenal, to use when someone starts telling me how static factory methods are a "bad practice" etc.
Java 18.3?
I can't believe I am thinking this, but why buy the hard copy book at all? If I am going to be studying Java, it will be at a computer, trying the examples out, taking notes. All of that will be easier with an e-book, onscreen, instead of cranking my neck down to a paper book hoping it stays open. I also don't need another future obsolete text book taking up room on my bookshelf. Am I missing something?
An incredibly useful and informative comment, thank you.
Anyone have any idea what the additions are? I hope they cover all sorts of anti-patterns I see with Optionals and Streams. It would be much easier to justify things in code reviews if the “java bible” clearly laid them out. 
**Sidebar** -&gt; + **Do not post tutorials here!**
Have you looked at [Eclipse Che](https://eclipse.org/che/)?
Thanks for the link, I haven't seen that. Is it possible to test it without signing up? I don't want to create an IDE, just a service similar to glot.io that has some more advanced features.
Well, I'm pointing out that while some of the newer stuff may not be covered, the existing content isn't outdated and no longer applicable.
I will definitely be buying this. Effective Java 2nd edition is incredible
I think we need some instruction as to what he best way to use Java 8 is. It contains such a huge change to the language 
The alternative seems to be to run it locally, through Docker - I haven't done it myself yet. But based on your updates, it may be too heavy for your use case. If you dig deeper into Che, or maybe even [Orion](https://wiki.eclipse.org/Orion), you can probably find the pieces you need, and assemble them into what you're looking for specifically.
https://www.infoworld.com/article/3230507/java/whats-in-store-for-the-next-java.html
&gt; static factory methods are a "bad practice" They must be living in the 90's. I haven't heard that either ever or so long ago I already forgot I heard that. So many modern libraries use it like the new immutable collections `of` methods.
so when is he going to update it? 
Can't take an e-book to a deserted island. I, myself, haven't opened an academic physical book in ages. Just having ctrl+F is enough a reason.
The link I posted has a description with that info. &gt; New coverage includes &gt; &gt; * Functional interfaces, lambda expressions, method references, and streams &gt; * Default and static methods in interfaces &gt; * Type inference, including the diamond operator for generic types &gt; * The @SafeVarargs annotation &gt; * The try-with-resources statement &gt; * New library features such as the Optional&lt;T&gt; interface, java.time, and the convenience factory methods for collections
You can take your tablet, eReader, or lap top to a deserted island. Good point about Ctrl F :-).
Run for the hills! The versioning scheme for Java is being changed again!
I actually tried out Orion, but it doesn't seem to have error/warning markers or autocomplete, at least not out of the box.
I actually prefer using [wkhtmltopdf](https://wkhtmltopdf.org/). It requires starting an external process, but it's pretty stable and feature-full. 
OMG what did I just stumble upon? https://vaadin.com/docs/v8/framework/application/application-declarative.html Vaadin 8 has declarative definitions! :o 
Ignorance is vast and infinite, unfortunately.
Does anyone know if it is *actually* going to be released on that date? I pre-ordered on Amazon months ago and have watched the date continually slide from the middle of October to December 29th. Is there a real release date now, or is this just another estimate?
Just a recommendation: you might want to explain *why* people with this knowledge would want to work *with you*. What are you bringing to the project? From what you describe, it sounds like this person is going to have to do pretty much everything other than (maybe) the UI. So, are *you* going to do the UI? What else will you contribute? Do you have any previous work to show?
This forum is not for help with learning Java or learning programming.
Thanks, good point. Added some more info.
Like [Visual Studio Code](https://github.com/redhat-developer/vscode-java), you could use the[ Eclipse Java Language Server.](https://github.com/eclipse/eclipse.jdt.ls) That said, I don't see any need for an online java editor. Why would anyone use that when it can't be executed in an expected environment and performant.
This looks really promising, thanks!
Some 2017 surveys, be wary of the demgraphics: * [Zeroturnaround](https://zeroturnaround.com/rebellabs/developer-productivity-report-2017-why-do-you-use-java-tools-you-use/) * [Jetbrains](https://www.jetbrains.com/research/devecosystem-2017/java/) * [Baeldung](http://www.baeldung.com/java-in-2017) 
I run eclipse with these switches and they work...sometimes. I think the trick is a full gc, or to trigger it with System.gc().
That usually only takes 200 hours.
I don't get what the fuss is all about. Just etch your codebase into ROM and hey presto, it's immutable.
Maven enforcer can help with jdk and maven version If it's an android project, give up now
Honestly I believe that Effective Java is a book they every Java developer should read once every two or three years. 
Ask him...
Oh duh, thanks. I’m bad at reading full links on mobile. Looks like exactly what I’m hoping for. 
Yeah, i didn't bother with any tuning in these tests. I wanted to compare the defaults of both vms and see how they did. Maybe I'll do some more comprehensive benches where I test both the defaults and tuning the VMs to get the best possible performance on benches and see which ones are easiest to get performance from and which is most flexible wrt drawing out the most performance
https://github.com/theia-ide/theia Does what you want to, it's still under the radar &amp; not yet ready for widespread use but it's being build by IDE experts. Long story short, it's an extendable IDE that can run in the cloud or locally. These guys are well funded &amp; backed by several big companies so I think it will be hard to compete with that.
Looks good, but it's not anything like what I want to do. I don't want a full IDE, I want a website that will open in half a second, ready to use (no account or anything).
So https://github.com/TypeFox/monaco-languageclient + https://github.com/eclipse/eclipse.jdt.ls That's a nice weekend project :)
Yup, someone linked to eclipse.jdt.ls earlier, looks like it's exactly what I need. Thanks for the monaco client link, will check it out.
What does `java -version` tell you?
It's just preference. Nothing matches the portability of e-books, but with physical books people form emotional bonds as you keep reading. The experience is more fulfilling. They are also less distracting than e-book readers.
Spring boot is quite new for most companies. In real job, be prepared to piece together different systems and custom libraries. The important thing is to know how to troubleshoot things and be able to quickly address them no matter what framework is used.
spring boot is amazing but the catch is to learn that when you use an annotation, it usually brings in 50 different things, songs that have unforeseen consequences. it will be a nightmare hunting the down.
I love the sly jokes about Oracle that someone in the panel does every year.
Learn Spring core. Well make things way easier. Also read Better Builds With Maven.
Tried the local server version via docker. It's pretty nice. You get a dockerized wen application that allows you to spin up workspaces (also within their own Docker instances) which each provides a web UI for doing online development. Each workspace in these instances stems from a base recipe which provisions your applications software dependencies (database, message queue, base language resources, etc) and you add in your code through the web ide interface. Not perfect, but it's a pretty good idea that hope continues progressing and improving.
Hey, is this project persisting sessions even after it restarts? I haven't tested it but I have a very similar project and I use JPA to store users but sessions are gone on startup and I have to login again every time. If it does work, what section of your project handles that?
Spring Boot is currently used in many production apllications. You may find that it is usually adopted in microservices architecture but it is often use to produce rest api and even webapplications. As for anything going deeper in the details would be useful to better understand how it works, but really, it is not necessary since you are able to progressively learn all the details when needed (more important: if needed!) I have a good background with java webapplication development and found Spring Boot to be very effective. If you need a spring boot project skelethon with most common tasks and libraries already implemented you may check (SpringBootTemplate)[https://www.springboottemplate.com] (spoiler alert: i am the creator of SpringBootTemplate)
The main problem with spring is exactly this magic you talk about. Control flow in a spring application can be non-obvious at times and when you do have to do non-standard things it can take a lot of digging. However, for many applications this is simply not necessary. Spring is great at getting out fairly vanilla applications.
Export directly to Excel using Apache POI. We went through Crystal and Jasper and ended up on Excel.
Joshua Bloch says 20% but then the other guy Greg seems to have bought it at 40% discount.
Well as a recommendation: Either generate it via eclipse/intelliJ or use commons-lang [ToStringBuilder] (https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/ToStringBuilder.html) Those handle nulls correctly out of the box. 
As an aside, why is Spring Boot taking off everywhere over Dropwizard? Spring Boot is basically a copy of DW with Spring support. Dropwizard is fantastic but I see its use diminishing in favor of Spring Boot.
&gt; when you do have to do non-standard things it can take a lot of digging Just read the documentation, it is awesome. This is how I perfected my knowledge about the framework.
&gt; Spring Boot is basically a copy of DW with Spring support Because that is a winning combo right there. 
... and has problems working behind HTTPS reverse proxies - it cant handle redirects from HTTP to HTTPS ...
It sometimes just isn't enough. Especially in spring-security I had this problem
I think its that HS256 is not secure, but RS256 is.
&gt; I have always heard Java development takes a long time We learned from others, expecially Ruby. &gt; I'm aware that there is quite a bit of "Magic" happening behind the scenes Be aware of the annotation "magic". Sometimes certain combination of annotations don't work together well and it's not always obvious why and documented. Those are rare special cases though. Also the new reactive model does allow to work with fewer annotations. &gt; Also in today's job market does everybody use Spring Boot or should I learn something else? Always expand your knowledge. Take a look at the Java EE / EE4J specifications, like Jax-RS, Spring is sometimes basing it on them. They are very similar. Also other frameworks and models like RxJava, ReactiveStreams, Akka, VertX, Hibernate give you another view. 
&gt; The main problem with spring is exactly this magic you talk about. Sorry to be blunt but typically the developers who complain about 'magic' are people who didn't bother reading the documentation. The "getting started" is just that; a quick getting started guide. You can't really pretend you don't have to know what the framework does and does not do for you.
This whole time I had no idea you were suppose to sing annotations!
&gt; Also read Better Builds With Maven. learn gradle as well
Not all the magic in spring is documented
Where can I read more about WISP?
2 cents anybody?
Such as?
Annotations are worthy of song! Great deeds have been done by annotations. And when they die a warriors death, they will take their rightful place among the honored dead in Sto'Vo'Kor, as new annotations continue in their place.
@FusRoDah
Found it https://news.ycombinator.com/item?id=15431083 
Hmmm . . . Just wait until you try a more modern Java toolkit like SparkJava or better yet . . . [Vert.x](http://vertx.io/)
This. In my experience, dealing with a million Spring modules and interdependencies can be a total nightmare. I much prefer to put together what I need with simpler frameworks like Guice for dependency injection and Jersey for a REST implementation. 
Seems like they're somewhere in between a monolithic system and a more modern microservices system. They run a single customized Tomcat environment with multiple applications side by side, built with a custom JDK.
I can't recommend this enough. Gradle has been a boon for us.
| Better Builds With Maven Read: Gradle
Gradle is so easy and so well designed... I love it.
&gt;public class bubbles extends JFrame ***{*** HISS (implied /s)
On a Mac the JDK is installed in /Library/Java/JavaVirtualMachines Here is what mine looks like: /Library/Java/JavaVirtualMachines:507&gt; ls -l lrwxr-xr-x 1 root wheel 21 Jul 22 2014 1.6 -&gt; 1.6.0_27-b07-395.jdk/ drwxr-xr-x 3 root wheel 96 Sep 22 2011 1.6.0_27-b07-395.jdk lrwxr-xr-x 1 root wheel 16 Jun 17 2015 1.7 -&gt; jdk1.7.0_79.jdk/ lrwxr-xr-x 1 root wheel 17 Jul 20 13:58 1.8 -&gt; jdk1.8.0_141.jdk/ lrwxr-xr-x 1 root wheel 10 Sep 21 16:03 1.9 -&gt; jdk-9.jdk/ drwxr-xr-x 3 root wheel 96 Sep 21 15:56 jdk-9.jdk drwxr-xr-x 3 root wheel 96 Jun 17 2015 jdk1.7.0_79.jdk drwxr-xr-x 3 root wheel 96 Jul 20 13:57 jdk1.8.0_141.jdk lrwxr-xr-x 1 root wheel 3 Sep 22 11:14 latest -&gt; 1.9 I create the "latest" symbolic link so I can just use the link in JAVA_HOME and I never have to change java home i.e.: echo $JAVA_HOME /Library/Java/JavaVirtualMachines/latest/Contents/Home
Tried pretty much all of them. Found out that I would pretty much end up hand-assembling something close to Spring anyway. 
Oh dear... First: [Official Code Conventions for the Java Programming Language](http://www.oracle.com/technetwork/java/javase/documentation/codeconvtoc-136057.html) + **Classes** always start with an uppercase letter (*PascalCase*) ---- Normally, you don't *extend* JFrame. It is simply not necessary.
 public class X extends Exception { | } Caret at "|", Press CNTRL-SPACE to bring up suggestions. Suggestions: X() Why not this? X() X(String message) X(Throwable t) X(String message, Throwable t) If #Hacktoberfest peeps need something to work on, how about issues logged years ago, like this one? ;-)
Why should OP learn two build tools when still learning Spring Boot?
Gradle might be more powerful, but I think as a novice Maven is easier to get started with Spring Boot.
Try reading up on thread pools and see how easy it is to utilize all the resources on a machine. Java can scale horizontally as well as node of php but also scales vertically very well. With Spring, try digging into all the modules. See how easy it is to do fine-grained security controls, search, REST clients. Also, great at integration including legacy systems. If you want to be on the cutting edge, take a look at Spring with Kotlin instead of Java.
i'm too lazy to do that ;0
was following an old tutorial, maybe it was required way back when?
That is not good programming practice!
I've seen very little gradle adoption. Last place I worked that mandated gradle for builds, every project just used gradle to invoke maven. It's a nice design, but I've found it to be slow and hard to debug with far less documentation, plugins and community.
This is my first program https://github.com/JudgeGlass/Install_Builder_Universal/tree/master/src/com/JudgeGlass/InstallBuilder
To each their own I guess. Not sure why you would feel that way though. With Vert.x there is no need for IoC, Reflection, etc... Much lighter and easier IMHO. 
The slides say _millions_ of JVMs, so there's probably more than one tomcat. Maybe they group a collection of related services on a single instance? The amount of customization they have done is impressive, and must have a huge maintenance cost!
Agreed. I guess there's some real potential in having a programming language as a core feature of your build tool... But I've never seen a situation when it was actually necessary. Outside this I'm not sure what Gradle improves on over Maven, and certainly the community around Maven is more robust and mature.
And there is exactly where you go wrong. It is *extremely important* to learn and adhere to the standards as early as possible. Laziness has zero place in programming. Programming is a domain of precision.
We don't, applets are dead. It was an interesting endeavor though.
Is that where the garbage collector dumps objects too? 
To be fair, he kind of goofed by publicly stating that he'd like to update it, which is of course going to be interpreted as "HE'S GOING TO UPDATE JCP!"
Gotchas center around the sheer amount of dependencies pulled into a simple Spring Boot projects. We've tired of all that auto configuration stuff. Makes our Docker containers too damned big.
So you have more options and know when to use Gradle and when to use Maven.
It comes pretty damn close though! Lots of delicious documentation! Yum yum yum.
1. Use the Java naming conventions for variables and classes. 2. Don't commit the bin/ folder on github. 3. Extending JFrame is not wrong necessarily but you can break some things if you don't know what you are doing. So don't do it. Congrats for your first Java App.
Why? 
The issue is that that phrase is put out of context many times and I have many times heard Senior devs utter those words without proper explanation of when (not why) you shouldn't use static methods, factory or otherwise. Although it's a good book, I generally don't recommend it, or I recommend it with a grain of salt.
For us, the structure of the build script is much more intuitive and easier to work with (once you get over the learning curve). Additionally, the wrapper is awesome for ensuring easy, absolutely reproducible builds, which is critical for us. 
It definitely has its shortcomings, but I agree it's incredibly powerful and well designed.
Gradle is definitely slower. But, I think they've realized this and are continually improving speed. 4.1 is so much faster than 2.x is. 
good luck
Interesting as in “This food tastes... interesting“
Programmers work really hard to be lazy later.
Exactly that. Still, *while* programming, laziness has no place.
Thank you so much for this! I needed a good laugh to get me through this Monday.
If you buy the hard copy, you own it and you can resell it. If you purchase the ebook, you technically don't own it; rather you have a license to use it. It cannot be resold nor transferred.
I don't think he was being sarcastic.
The main gotcha with Spring Boot is that you won't enjoy using anything else in the future.
They keep telling me that Java 9 represents the most significant release of Java since the language itself. I just don't see it. Really underwhelmed and I don't think I will benefit at all from the introduction of modules.
Just checked out "Better Builds With Maven", 292 pages in total :O, That's quite the read! I didn't think there would be so much on the Build tool. I'll get started on it anyway thanks!
What we need is to port the OpenJDK VM to WebAssembly.
&gt; it will be a nightmare hunting the down. Never had a problem. Everything is open source with great documentation. With good debugging skills you can see exactly how Spring is doing its 'magic'.
I don't think they'll release "bits and pieces" of APIs, except maybe project amber.
It will increase your power level.
I've gone that route, but when your application grows a little larger you'll be happy you won't need to deal with interop of each of your slapped together components.
The simple fact is that this is precisely what you have to worry about with Spring. Because of Spring's size and their attempt to "do everything for you," you really have to start worrying about which libs are on your class path and whether they conflict with third-party libs you want. The day will come, *when your application is of sufficient size and robustness*, when you *will* need something outside of Spring's sandbox. 
Eh, Spring Boot has a complete list of all included dependencies that I regularly check. Either a library has Spring integration and it works fine, or it doesn't touch a framework at all and it works fine.
The catch is it's not trendy, amd makes you do things a certain. That's only a bad thing to the idiots that thing JavaScript belongs everywhere.
100% understanding spring core is the key! Theres no magic. 
They're not restricted to one place or another. Usually they appear alongside streams, meaning you can use them to filter collections, or turn elements into other things.
&gt; Makes our Docker containers too damned big. I get it, it's not optimal but with jlink it should be heavily mitigated. Bigger question is, wouldn't developer time be far more valuable than a few 10's of megs of disk space per build?
Any resources for spring core you can recommend?
https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html
what year is this?
Yes actually, when I have some time I will dig into this. It's something that really annoys me.
Extremely useful for set filtering or mutations 
Agreed. A lot of these changes seem pretty cosmetic.
Rhetorical question obviously, but I'm guessing circa 2011.
Good points. I think I might go with the ebook for the increased convenience of usage. I don't think I have sold a text book back in decades. The information just becomes obsolete very fast and leaves me with a paper weight to take to a photocopy shop, pull apart, and dump the paper in one of their big recycling bins.
Was my comment really amazing enough for him to possibly be sincere?
Literally everywhere.
I once took a look at my old code that was similar to this. It was full of some of the most ridiculous usages of APIs that you could possibly believe. I wrote a very sarcastic article on it, describing some of the worst practices as "best practices from an expert". I was shocked when some people didn't recognize the sarcasm and took it literally. This code is not great, but miles ahead of that old code.
Well, the C++ standar has a lot of pages, but you don't have to read those to write C++. Why do you want to read all that documentation?
Well suppose that you get to do a task , and you do it in a basic way but there is a command hidden somewhere that makes it faster/easier/more readable.What happens when they see your code? Also when it comes to interviews , won't they ask the most obscure thing they can find? E.g for C++ as you mentioned , they are not going to just ask you what templates are.Or am i wrong
Lambdas are just a tool in your toolbox. It is up to you and your skill if and where you use them.
My team uses lambdas with java's stream api probably every day as convenience methods. A very basic high level web example would be receiving a list of user names and getting some property of the user. You can make a one liner that's just (no bully over my codestyle please): return cachedUsers.stream().map(userName -&gt; cachedUsers.get(name).get(property)).collect(Collectors.toList()); Which gets you a list containing some property from each user. In another project of mine, I'll use them along with functional interfaces to instantiate objects based on text input (command pattern?). To be honest though I'm falling out of love with streams because in my experience, they're significantly harder to debug than more verbose methods.
Just read Spring in Action book. That will be enough for a first job.
you will do yourself a disservice, if you need to know something you can always look it up, if you want to explore things the direct documentation isn't the way to do it. the X in action books are great resources 
It's a distributed Tomcat system, and each JVM provides it's own bit of code with some redundancy and failover /s For real this is actually fucking awesome. 
That's great , thanks.The problem is the book is old , and spring 5 is out.
Even learning for a Spring certificate does not require that.
hmm.Perhaps i have overestimated the amount of reading required for a job
Ah i thought 5th edition was out but it's not out till summer of 2018 http://www.apress.com/us/book/9781484228074 this one looks pretty good, and of course you need to read Effective Java (the third edition just came out) 
Is there anyone here working for them in Madrid? They keep contact me but I don’t know what to expect. 
This kind of documentation is for reference. You typically don't need to read it all unless you are doing something unusual.
What do you mean? That they are much more difficult or much more simple?
Quick questions regarding Docker, it seems like Spring Boot has all of its dependencies, including the server etc, Does that mean really your Docker container is really just running Java &amp; environment variables &amp; mapping ports?
Having used both, I much prefer DropWizard. DropWizard seems to me a more neutral collections of some of the best tools for each job, Spring Boot is just Spring, Spring and more Spring.
Event handlers are usually built with lambdas in mind, a functional interface with a method called handle(). Listeners are the same, add one to an object and usually the resulting action can be defined in a lambda.
Much more simple, more performant, more readable, etc... 
Server side? For printing variable values! nah, jk.. Lambda functions are useful when using Futures (I use ListenableFuture mostly), in streams and in return statements. We have a strong culture of inlining complex shit in return statements, which I hate, so there's some lambda there. 
Then you don't need to work there. Readability is better that using some obsucre shorthand
This is why it doesn’t matter. By the time you read and study it a new version is out. 
Omg u so smart I wish I could cs as hard as u 
Stupid question but couldnt you also just write traditional functions as well? I feel like lambda functions are more style than anything? 
Best place to use a lambda function? Any functional programming call that takes a function as an input (e.g map, filter, etc) which could be written in a line of code.
The { at the end of the line vs on the next line is purely stylistic and AFAIK always has been. It is, however, a topic debated nearly as fiercely as tabs or spaces.
you absolutely did. just build stuff with spring and look things up when you get stuck. that's how a job works anyway.
This would be a massive waste of time - it's documented so you don't HAVE to look at it. If there are big principles you don't understand read until they start to take shape, but be prepared to say "I generally know how this works, I think I could figure it out" in an interview and mean it. Study design patterns, agile development practices, learn common ancillary tools (like IDE's, database tools, etc) and know both svn and git fairly well. And have your resume be more carefully typed than that post lol
If you've used Spring to build something, then you probably have enough knowledge for a job interview. If you haven't, then do that. A simple project management app or something, doesn't matter. Or, find an open source project on github and work on some real-world features or bugs. Reading all those docs is madness. You won't retain most of it, and in an interview you'll be throwing around the random bits you do remember without context or confidence. Describing a project you actually worked on is going to be more impressive.
Yeah they're pretty much style. It's a lot less verbose and it looks nicer most of the time than declaring a subclass or using an anonymous class. There've been a few articles about performance of lambdas but those are mostly cheese, there's no difference if you pull out instantiations.
Usually you need just understand Dependency Injection and Spring MVC. And learn JCA if you can.
Most employers aren't going to judge you harshly because your code isn't 100% optimized or whatever. That's what code reviews are for. They just want to see that you can approach a problem in a sane way. They're not going to ask you the most obscure thing they can find. Maybe they'll ask you what a linked list is or something like that. I think some employers still do fizbuzz. Seriously, the technical knowledge bar is pretty low. You'll be fine.
Ever since anonymous inner classes we've technically been able to pass functions around on the fly, but this someFunction(x -&gt; x+1); is so much simpler than this someFunction(new Function&lt;Integer, Integer&gt;() { @Override public Integer apply(Integer x) { return x+1; } }); that people actually use it. Then, since they know people might use it, libraries don't have qualms about demanding it, and soon enough the whole standard library starts to look different. As to why you might want to be able to pass functions around, consider that it can eliminate entire inheritance hierarchies. This can be done by demanding callbacks from the constructor instead of from subclasses. Suppose I want an object pool, and I want each instance to be initialized to a default state before use. I might create this interface: public interface ObjectPoolInterface&lt;T&gt; { T obtain(); void release(T t); } But how to implement this? If I know the object implements a Resettable interface, providing reset(), I can do this: public class ResettablesPool&lt;T extends Resettable&gt; implements ObjectPoolInterface&lt;T&gt; { private final Class&lt;T&gt; cl; private int capacity; private final LinkedList&lt;T&gt; pool; public ResettablesPool(Class&lt;T&gt; cl, int capacity) { this.cl = cl; this.capacity = capacity; this.pool = new LinkedList&lt;&gt;(); } @Override public T obtain() { if (pool.isEmpty()) { final T t; try { t = cl.newInstance(); } catch (InstantiationException|IllegalAccessException e) { throw new IllegalStateException("Unable to allocate "+cl.getSimpleName()); } t.reset(); return t; } else { return pool.removeFirst(); } } @Override public void release(T t) { if (pool.size() &lt; capacity) pool.add(t); } } I want another allocator, or to pool some other type that doesn't support Resettable I'm going to need another implementation. But what if I can demand lambdas? public final class ObjectPool&lt;T&gt; implements ObjectPoolInterface&lt;T&gt; { private int capacity; private final Supplier&lt;T&gt; allocator; private final Consumer&lt;T&gt; cleaner; private final LinkedList&lt;T&gt; pool; public ObjectPool(int capacity, Supplier&lt;T&gt; allocator, Consumer&lt;T&gt; cleaner) { this.capacity = capacity; this.allocator = allocator; this.cleaner = cleaner; this.pool = new LinkedList&lt;&gt;(); } @Override public T obtain() { if (pool.isEmpty()) { final T t = allocator.get(); cleaner.accept(t); return t; } else { return pool.removeFirst(); } } @Override public void release(T t) { if (pool.size() &lt; capacity) pool.add(t); } } Now anyone can create an ObjectPool with a custom allocator, custom object-cleaner, even for objects that don't share an interface. final ObjectPool&lt;List&lt;String&gt;&gt; pool1 = new ObjectPool&lt;&gt;(100, ArrayList::new, List::clear); final ObjectPool&lt;List&lt;String&gt;&gt; pool2 = new ObjectPool&lt;&gt;(100, LinkedList::new, List::clear); 
&gt;To be honest though I'm falling out of love with streams because in my experience, they're significantly harder to debug than more verbose methods. Even using IntelliJ and its new stream debugger?
It should be doable, let me know if you need help. I assume you meant this issue https://netbeans.org/bugzilla/show_bug.cgi?id=170010 ? I've also created a #hacktoberfest for it :-) https://github.com/emilianbold/incubator-netbeans/issues/304
I’ve found lambdas to perform slower in any competitive programming context I’ve used them in
Great ,thanks.I thought they used hard questions to filter people.I wonder where the criteria lies then
What is a competetive programming context?
Like in codeforces, topcoder, leetcode, or atcode. They're contests where you have to solve algorithm problems efficiently.
As an example: You tend to have a lot of places where you're going from one type of object (an entity for example) to another (for example a DTO rendered as JSON). Streams + lambda's are very useful there. Once you get more experience you'll see more use for them. Having a bit of experience in a functional language like Scala helps too.
Kinda pointless since Applets were dropped officially. They're dead.
They should be used to process "streams" of data. If you have a collection (e.g Lists, Maps, Sets) of data that needs to be processed, using the Stream abstraction in combination with Lambda functions is often simpler, cleaner, and more powerful, than using deeply nested ugly iteration constructs, like for and while loops. In short, any time you have to do any kind of data processing, think Streams and Lambda functions. This forces you to tease out your processing pipeline into simple single-focused functions (Lambdas), as well as reason and communicate clearly about what you're trying to do with the data you're processing. 
We use spring and osgi so I don't think converting to intellij is easy. As much as I'd love to drop eclipse like a hot potato I don't want to spend all the time converting our project configurations. Unless there's an easier way...
Yes but you are looked down upon during job hunts if you are not using latest and greatest technologies
More like 2 hours and yourself after lunch break
Select * from *, and filter the response through a lambda then?
They are useful for running code in transactions, like jdbis dbi.inTransaction(handle -&gt;...) or whatever it's called. It allows you to easily implement transactions retrying without requiring an anonymous class or a loop.
“Java is generally slower than C,” followed by two tables that show it isn’t. Well done!
This look super interesting, but how are you able to pass functions as parameters? I thought that in Java functions are not objects 
Java added function references (like LinkedList::new above) and lambdas (x -&gt; x+1) in Java 8. What you say used to be true. 
That's neat! 
"If you can write me an application using Spring, you're hired" is what they mean. 
Criteria: candidate is intelligent, they don't have to know all the algorithms but when given a task they go in the right direction problem solving skills, related to the previous one, plus divide and conquer, being able to see edge cases, being able to notice and acknowledge problems in their code after being given a hint teamwork, candidate is not turning defensive when an error is pointed out, they remain calm when talking about their code, theoretical conflict situation solving, this is more personal intuition of the recruiter honesty, when candidate doesn't know the answer the best way to go is "I don't know, but I think that it's...". That's an indicator that when they get blocked on a task they will signal it. basic or more advanced knowledge of the language (java se programmer certificate level if it wasn't junior position) , we never asked questions about libraries (unless they were in cv), that's something one can ramp up quick. We asked a lot about concurrency cause it was needed on our project. Please don't tell us that all that's needed to make a field threadsafe is to make it static
Yeah - there ya go. I don't understand why Spring gets so much use. They, basically, take existing tech and put their own wrappers around it. Where's the added value? It just adds a new level of complexity without much gain. But, they've been very successful.
The problem is that there are some things that Applets could do that - as yet - haven't been replaced by anything. The software I work on uses a Java Applet to talk to the JPOS API installed on the client machine in order to allow a web page to print to a receipt printer. The *only* other way that we've found to reliably do this involves having an application installed on the client machine and the web browser talks to that, but we now risk losing tenders because of the requirement to have special client-side installed software. (As it happens, Java 9 has killed JPOS dead anyway, because it's killed the support for endorsed / ext which is the way that the hardware-specific drivers were installed into the JVM, but that's a whole other problem)
Wow. Talk about Annotation abuse. 
[removed]
Don't those usually use C or C++ though?
Thanks man , i will be sure to focus on these subjects.Functions and APIs can be more easily learned anyway after that.
Update: v1.0.2 is a bugfix release that's critical if you use UncaughtExceptionHandler instances or you want to use AesCounterRandom on Java 9 VMs.
Yep
&gt; I don't know what exactly is happening That is a good thing. You should have an idea, you should be able to investigate if you need more info, but the whole idea is that Spring (or JEE) takes care of the infrastructure, so you can focus in the business oriented code. And even in business related code, in every project you'll ever work in a team, you will only know some parts in detail (the ones you wrote recently), some parts you will know the big picture, some parts you'll have no idea. And even if you memorize and understand every single page of Spring reference, you'll still don't know every single detail of the JVM specs. And the compiler implementation details. And the assembler that runs. Is the price of abstraction. That said, I've found spring references to be great reads, and try to read them every once in a while, to know what Spring has to offer.
It is still true. There is no such thing as a function-object in java (ignoring reflection for now). Lambdas and method references are syntactic sugar to create an instance of an anonymous class subclassing a given interface. For example, `LinkedList::new` is syntactic sugar for `()-&gt; new LinkedList()` which is syntactic sugar for `new Supplier&lt;LinkedList&gt;(){ @Override LinkedList get(){ return new LinkedList();} }` when passed to a method accepting a `Supplier`. In other languages (e.g. Python, JavaScript, ...) `MyClass::someMethod` would actually be a reference to a (singleton) method-object, stored in the `MyClass` class-object. In Java, every time you write `LinkedList::new` a new instance of a matching interface is created. Thats a subtle but sometimes important difference and nice to know and understand if you are working with Java lambdas a lot.
I moved some things over to eclipse collections at work, and I'll mention a few things: The library feels a little bit like a mess, and the documentation (the last time I used it) was largely incomplete, I'm guessing that it's because of the shift to the eclipse foundation. It was a lot better under the GS github. Considering the learning curve in using the library, try only using this in situations where you have memory or CPU pressure. In my case, we used a ton of memory and I was trying to fit a service onto memory-poor machines with a pile of other heap-hungry services. That said, the Doubles i replaced were a huge portion of the memory pressure on my service, and I was able to reduce the heap footprint by about half.
How about a step builder pattern?
OP here: Infobip Spring Bean Validation provides new functionality that enables the user to leverage the full power of Querydsl API on top of Spring Data repository infrastructure. If you have any questions feel free to ask.
Serious question: isn't all of this stuff that belongs *into* the repository, not the repository clients? You're basically turning the repository into a SQL builder API, don't you (see the Native queries with Querydsl section)? That's very leaky abstraction, isn't it?
There are no assumptions on how those repositories should be used. In practice we have some concerns as you've stated, but not only about this repository, but QuerydslPredicateExecutor and others as well. In practice we always use those from within custom repository implementations (individual customs) where we use the more powerful API so the clients (usually service layer) doesn't express SQL and expose methods which are more business oriented in naming. 
I'd argue that naming methods like SQL introduces the same problem, leaky abstraction.
That’s a remarkable statement in the light of a repository and it’s usage model being a quite well-defined concept.
What is "low memory" in your case?
Spring-Security documentation lacks a bit, yes. But then source is openly available and any modern IDE lets you look at it without any hassle. I've gotten used to its workflow and there hasn't been anything I've been unable to do, no matter how non-standard the requirements may have seemed.
It really doesn't pull that many unneeded dependencies anymore. Yeah, it brings a ton of auto-configs for libs you're not using, but that's usually 1-2 classes. With Java 9, we should overall see a decrease in size of a lot of these things.
Yes, that is true. But it can eat quite a lot of time to read through that source, especially with the scale of spring-security.
I agree. It's definitely not perfect. But then again, the alternative is either some other not-as-well-documentated framework, reading source (and if there is enough, documentation) of some in-house code. Everything takes time to learn, and sometimes that time is spent debugging filterchains
&gt; Class&lt;T&gt; It irritates me to no end to see application code looking more like compiler code. I wish we could go back to Java 1.4 and throw out everything done since then, to Java.
Most people use C++ since it’s very fast, but java is the second more popular language.
Jigsaw and Java 9 deprive many practical, pragmatic and performant solutions. Another library that got unnecessarily handicapped due to Java 9 migration: [Eclipse Collections](https://www.infoq.com/articles/eclipse-collections?utm_campaign=rightbar_v2&amp;utm_source=infoq&amp;utm_medium=articles_link&amp;utm_content=link_text) &gt; In this example, once we call data.setAccessible(true), an exception would be thrown. As a workaround, we simply set data and size to null in order to move on. **Unfortunately, we can’t use these fields to optimize our iteration patterns anymore, but we are now Java 9 compatible** as this fix solved our reflection issues. 
Where did you see that?
It is used in some APIs, but a hell to code and maintain manually because you'd need a separate interface for each valid state of the builder. This grows out of hand fast for any but the most trivial builders. 
I don't get it, what do you mean? Is he using @GeneratedValue the opposite way it's supposed to be used?
Fine but you don't think @GenericGenerator is awful? FFS.
Caret at that position, hit ALT+INSERT, hit enter once (Probably already on "Constructor"). You get a choice of 5 constructors and you can generate 1 or more all at once.
Do you have some examples?
This has been discussed to death. Please search the subreddit for _all the other_ posts about certifications (including OCPJP) telling you that certs are basically meaningless.
My first job was for a contracting company that did Oracle Retail implementations. One of the things they used to advertise their services was that "all of our developers are Oracle-certified." While they preferred that the certifications were in Oracle Retail software, they recommended I take the Java one immediately so that I would be certified in *something* from Oracle. Fortunately, that meant they were willing to pay for the certification. At my second job, they didn't care that I was certified, and were much more interested in the number of years experience I had working with Java (as well as open-source or self-directed projects). To my knowledge, I am the only developer on my team who is certified. I will say that if you are a goal-oriented person, it's not a bad goal to get the OCJP certification to help you better understand the intricacies Java language, especially aspects you don't particularly use. It's also great if your employer wants you to have some measurable way to demonstrate continued learning and/or training, especially since it's cheaper than conferences. But in terms of making you employable, I don't think it has as much value as other things.
&gt; where I would choose it over an alternative What alternatives would you recommend?
Huh interesting. I'll probably take a look with JMH today if I get the time. Is this with it hoisted or directly inline with your code?
&gt; other than Java. ...so what better way than to ask in ***/r/java***!
I concede the irony :-) I was hoping that among the 75,000 /r/java readers there would be a lot of people familiar with other JVM languages.
Just as quick with things like Dropwizard and Java EE
https://en.wikipedia.org/wiki/BIRT_Project
https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.query-creation It might not be SQL, but it is a QL nonetheless.
[And the winner is...](http://www.annotatiomania.com/)
No it doesn't persist sessions. I use JWT tokens for "sessions".
There is a nice short blog post about this at https://michid.wordpress.com/2008/08/13/type-safe-builder-pattern-in-java/ That blog post inspired me to write a java annotation processor to automatically generate these types of builders: https://github.com/danamlund/ya-builder That script shows how wacky the generated code is. And how weird the compile errors are.
Unless you're seeking a job in systems administration, security, or other IT positions that will require you to do some programming, certs are worthless. 
&gt; The only other way that we've found to reliably do this involves having an application installed on the client machine and the web browser talks to that, but we now risk losing tenders because of the requirement to have special client-side installed software. Applets required a Java runtime already installed on the client machine anyway. Plus the Java plugin for whatever browser they were using. I just went through this about three years ago, replacing an ActiveX-based website. It also required interacting with hardware devices on the client's machine and I could not find a reliable way of building something that would last the next 10-20 years via a web application. I instead designed a Java desktop application and paired it with a web service. Seems like the most reliable way forward for my particular use case. For you, it sounds like a local service/daemon might be appropriate.
Lambdas **ARE NOT** anonymous classes. They're implemented as a `MethodHandle`that is called directly with the `invokedynamic` bytecode instruction, without the overhead of a containing class.
&gt; it's not a bad personal goal to get the OCJP certification to help you better understand the intricacies Java language, particularly aspects you don't particularly use. This is particularly true if you are new to the industry / recent graduate. Java has some twisty corners and you aren't necessarily going to know about them unless you take the time to learn them. The certification process is a great way to discover those and the knowledge is very useful on the job.
You could do that for sure, but you'd probably just want to use a more specific query if you're only getting stuff out of a db. :) Streams are most useful when it comes to doing operations on data.
Agree entirely. Begs the question: do we always _need_ to be explicit at compile time? How stupid are the users of the API? How bad is the documentation? This technique is clever but difficult to maintain, and is obviated by clearly documented API usage.
The problem I have with typesafe builder pattern ist, that the builder pattern is a general problem, that a construction of an object is too complicated and that it pollutes the classpath with interfaces or classes. Projekt Lombok helps you by generating the methods for you, but still, it is late validation. https://projectlombok.org/features/Builder
As far as I see it, it's about narrowing down the problem space by completely eliminating a source of error. This is paramount for critical systems, which admittedly, is not the vast majority of software out there.
The complaint mainly seems to be about the slowness of `Scanner.nextInt` compared to alternatives in Java, and indeed some of the alternatives presented are even faster than C's `scanf`. The main reason for `Scanner.nextInt` being slow is that it does a *lot* of regular expression processing in order to support fully localized numbers. See the section [Localized numbers](http://download.java.net/java/jdk9/docs/api/java/util/Scanner.html#localized-numbers) in the Scanner class specification. You can see there is a lot going on with localized numbers, so it's not surprising that it's slower than calling `Integer.parseInt` on a simple token.
That's pretty cool :-)
I was very surprised by the claim that LinkedList::new was using anonymous inner classes under the hood, so I checked: public class Container { public static final class Reference&lt;T&gt; { public Supplier&lt;LinkedList&lt;T&gt;&gt; supplier() { return LinkedList::new; } } public static final class Lambda&lt;T&gt; { public Supplier&lt;LinkedList&lt;T&gt;&gt; supplier() { return () -&gt; new LinkedList&lt;&gt;(); } } public static final class AnonymousInnerClass&lt;T&gt; { public Supplier&lt;LinkedList&lt;T&gt;&gt; supplier() { return new Supplier&lt;LinkedList&lt;T&gt;&gt;() { @Override public LinkedList&lt;T&gt; get() { return new LinkedList&lt;&gt;(); } }; } } public static void main(String... args) { new Reference&lt;String&gt;().supplier().get(); new Lambda&lt;String&gt;().supplier().get(); new AnonymousInnerClass&lt;String&gt;().supplier().get(); } } % javac Container.java % ls -1 Container$AnonymousInnerClass$1.class Container$AnonymousInnerClass.class Container.class Container.java Container$Lambda.class Container$Reference.class Nope. There's no Container$Reference$1.class or Container$Lambda$1.class, so it's not just syntactic sugar wrapping an anonymous inner class. I don't see any sign of it creating a new instance of anything when it encounters LinkedList::clear. javap doesn't show any references to object creation within Reference or Lambda other than constructing the object itself and LinkedList::&lt;init&gt;, whereas AnonymousInnerClass::supplier does refer to AnonymousInnerClass$1.&lt;init&gt;. So unless you have some evidence or source, I'm going to say that no, it's not using anonymous inner classes and isn't creating new objects. 
/r/swift
Either i didnt learn this or youre going to have to be more specific with your question
Are you talking about, 1. Fields, 2. Methods, 3. Constructors?
What the fuck. 
We r doing OOP and client classes and the question simply says what are the three parts to an OOP
Well, **OOP** has four basic aspects: Inheritance, Polymorphism, Encapsulation and Data Abstraction. **OOP Class** has three parts that I told you before.
Did someone just launch a technology they want people to colloquially refer to as "MVC 1.0", or maybe just "MVC". Fuck that shit. We've had eight years of Mircosoft .NET devs colloquially referring to "ASP .NET MVC" as just MVC, and Microsoft released that in 2008. 1978 design pattern, grumble grumble.
**Sidebar**: #NO programming help, NO learning Java related questions! Use the other subs that are dedicated for such questions. Also, please learn to ask *clear* questions.
Lmao no
Please be careful with Oracle’s commercial offers: * Oracle’s licenses are really expensive. * Oracle sometimes has a very broad definition of “production” during an license audit. Basically if your code will ever hit production in the future or will deal with any data that is production like (e.g. a one off test with anonymized production data), the Oracle representative might already consider it production use of their software.
It's surprising to me that they are in general more positive about MongoDB than Cassandra. We use Cassandra as our main database and that was simply a mistake (we're firmly in told-you-so mode). But at least the documentation of Cassandra is in general honest and clear about what it can and cannot do. The MongoDB documentation on the other hand is basically written from a marketing standpoint. Cassandra does not claim it's there to replace the relational database, Mongo does (or at least did, haven't used it the last 4 years). And whereas Cassandra has, like most NoSQL databases, a single big strengths (Scalability) the only 'strength' Mongo has is that it allows developers to skip the 'boring' "trying to remember data normalisation from school" part and just toss entire objects into a store. And the moment you want to scale Mongo or your software simply has relational data (and most applications have relational data) mongo is no longer useable as a main datastore. 
What other subs?
If your employer pays for them (quite common for consulting companies) sure go for them. Otherwise; no. These certifications basically test if you memorised a bunch of stuff. Being a developer isn't about having things memorised, it's about being able to solve problems. Language certs don't train you for that. 
--&gt; sidebar
Huh
I think there's a difference between filtering a collection based on a domain specific criteria about which the client doesn't need to know anything (it's just calling a method) and exposing methods to require the client to know intrinsics of the underlying data store. That's what's the different between abstraction and the leaky version of that ;).
Sure, be careful. Looking forward to the day it's all open. 
Cool, thanks.
Yes and no. It is true that they are not compiled to anonymous classes but anonymous *methods* on the containing class at *compile time* and some glue code involving `LambdaMetafactory`, which creates an anonymous class *at runtime*. It may be optimized away, but from the language perspective the runtime still *behaves as if* there was an anonymous class involved. Try this: public class LambdaTest { public static void main(String[] args) { final Consumer&lt;String[]&gt; l1 = LambdaTest::main; final Consumer&lt;String[]&gt; l2 = LambdaTest::main; System.out.println(l1.getClass()); System.out.println(l2.getClass()); assert l1 != l2 } } It will print something like this: class LambdaTest$$Lambda$1/1705736037 class LambdaTest$$Lambda$2/1915318863 and the assertion will hold. This was the point of my post: In other languages, `LambdaTest::main` would be an instance of a methot-type and just assigned to a local variable. In java, the statement `LambdaTest::main` creates a new instance of a runtime-created class implementing a functional interface. `invokedynamic` is just an optimization that makes *calling** lambdas faster. It does not magically change the very fundamentals of the java language that state that everything must live within a class. 
Please have a look at my answer to /u/VoxaAeterna in this thread.
I would really advise folks not to use this method to generate the primary key. Those of us that switched to using UUIDs as the primary key did so cause we wanted to have primary keys that where unique across distributed systems and **not have hibernate control our IDs**. If you haven't read [Don't let Hibernate steal your identify](http://www.onjava.com/pub/a/onjava/2006/09/13/dont-let-hibernate-steal-your-identity.html) I suggest you give it a read. 
I agree that passing a Querydsl parameter is more leaky than method naming, but there's another cost, there's no static typing, no flexibility and expressivity Querydsl API provides and that's a serious problem, at least for me. Leaky abstraction can we worked around by using standard Spring custom repository feature. Proof something like this is needed is existence of QueryDslPredicateExecutor. Maybe another abstraction could be created to solve this problem? Some infrastructure class that would be available only to custom repository implementations?
Ugh....why does every site need an account registered? Screw that.
Thanks ohaiya and thanks @ManiBePoint for posting the link. I'm a developer is Codiva. I'm am trying out with guest user account as an A/B experiment. For now can you try using https://www.codiva.io/p/c8a32e68-f52f-4090-9bfe-df3ea9f0bece you can run the code without login, and start editing or create new project. Sorry for the inconvenience. Thanks for the feedback.
I suggested the Lombok team an option to create a type safe builder, they rejected it because of classpath pollution. Final non nullable named parameters could be a nice language level solution
Thanks for the quick reply and alternate link. Just to be clear. I have no problem with registering for platforms and services I will use. I think there is an obligation to share both ways. More just a case of, it's great to be able to evaluate something without having to register. Password security is hard enough with all the different identities we keep, so either oauth or just no registration is great initially. After I'm committed, I'm more than happy to go through a specific registration process (though SSO through oauth is nicer).
The kind of documentation you mentioned is, as someone here already mentioned, intended to be used as reference - if you happen to find yourself investigating something in these areas and need to understand how things work - then you use this documentation. It's not meant to be read like a book. I believe the thing you're looking for is guides and tutorials - they'll teach you the framework by going over the basic things that are used 95% of the time and they're much easier to digest than reading the reference documentation. Look for these guides, make sure they are up to date (not necessarily the newest possible, but not from like 5 years ago or something). There's a lot of free ones, there are some paid ones, whether it's worth it to pay depends on you. Videos are usually nice. Some tuts only focus on a certain part of the framework but you'll probably want to look for those that introduce the framework as a whole, with explaining the context and basic functions. Having the knowledge from these guides and being able to create/modify a Spring app will be enough to get you in, probably. I kinda see in you the issues that I had when I was first looking for a programming job - you seem to have the view of the world where other programmers are waiting for the first occasion to pray on you and your lack of knowledge. It's quite the opposite, usually - the community is usually very nice and embracing as soon as you are honest about your state of knowledge, willing to learn and don't require stuff to be explained to you over and over again. Your colleagues will try to help you and point directions, not wait for your slightest mistake to display their superiority (well, some will, avoid those). You should also bear in mind that the market is in high demand for programmers, so it's quite easy to get in with some minimal threshold of skills which is quite low. As long as you're clear about being a novice and having basic skills, most employers will understand you need a mentor and an environment to learn - they'll treat you as an investment and will probably be understanding towards initial slow pace or mistakes.
I'd be interested in how J9 performs. It has also those features. Also, after your first article, I was playing with docker and checkpointing. I was able to resume java program, but not clone it (it doesn't work 2nd time). But I think with some work, it would be possible to prepare running java process and just clone it. Benefit would be, that you've all the JIT profiling and consistent startup times even with heavy frameworks. Had no time to measure it because it's not trivial, but it was quite fast (they mention 1s resume time with eclipse).
Thank you , that was very helpful.I definitely believe the preying part but that's just a side effect of the Greek programming market which is basically this 1)Web developer wordpress bottom of the barrel jobs which pay minimum wage of 3€ / hour 2)Get 100 degrees and insane theoretical knowledge to get a higher job which pays just 50% more than minimum wage.And that's like 1 position per day , and 1000 applications since everyone is desperate. I have looked at guides but i am really interested in knowing some more in depth.For example the guides in Spring.io just tell you "How to do x" and just show you the code without explaining.They don't have a logical order.On the other hand , tutorials found elsewhere use different or older methods like XML everywhere so its not relevant. I found some good java and spring books and i think ill start there.They have tutorial form but are quite in depth.They are "The complete java reference" (damn 1300 pages) , "Java 8 in action" and "Spring in action" 
I remember the original tutorial island. I thought that game was amazing because I had played flash games before and runescape was my first mmorpg. 
Nice
Separate from class time. I spent my weekends and afternoons playing with java. I started at below noob, I thought programming was green 1s and 0s. That was 7 years ago, now because it's my job I spend about 12 hours a day
While it's always good to see what a framework or language has to offer, you don't need to know everything in and out. You need to know the basics and the concepts behind it and for the rest you only need to know where you can read about it.
http://www.oracle.com/technetwork/articles/java/mvc-2280472.html They're not claiming it's new...just another, more literal MVC choice for Java EE (that sadly wasn't included in 8)
If you prefer to listen to senior devs who say things without proper explanation rather than to Bloch then go ahead.
In the morning I have lazy initialization, does that count?
I suggest you go with the [official tutorial](http://docs.oracle.com/javase/tutorial/uiswing/) instead of some random old one.
If a system is truly critical you need to test it properly. I can break the safety of this mechanism with a few casts.
love this kind of bugs! fun story
i mean, it wasnt too random. It was bucky's video (thenewboston) which is said to be one of the best java series out there
for this I would say that compiling (and executing) can be somewhat resource intensive. I'll leave the implications of having a fully open resource intensive API to the reader.
Well, it's because the "god mode" folder was never meant to be used by non-system components. When you use implementation details, you are bound to get burned at some point. (For anyone who doesn't know the specifics behind it; the "god mode" folder is a filesystem link to the virtual folder that lists all the control panel items. It's used by the start menu as a search folder when you search for a control panel item.)
I'd expect a call `getX(y, &amp;x)` to return something other than `OK` if the given `y` does _not_ have an `X`.
Thank you! Fixed. Please reload the home page, the error should be gone. When preparing for the release of JavaFX 9 I forgot to rename the links on the homepage from JavaFX to JavaFX 8. 
I guess. The documentation doesn't mention anything about whether the STRRET structure is guaranteed to have a valid value. It could also depend on the second argument, of course.
I totally see why the flexibility of the Querydsl approach is appealing and we consider it a great addition to the toolbox (statically defined query methods being another). I'd love to learn about the limitations you see with QPE in the first place to explore options how to improve the situation here (applying projections comes to mind). I don't think we'd go as far as you went – for reasons probably obvious from this discussion here – but we're definitely open to revisit what's currently there. Would you maybe mind to create a ticket in [our tracker](https://jira.spring.io/browse/DATACMNS)?
I happened to stumble upon this bug just couple days ago! I indeed had just created a 'God Mode folder' after hearing about it from a collague, later that day I tried to install NetBeans, and the installer would just instantly keep closing after starting. Thank god I managed to find solution by Googling the stacktraces that were created into a txt file besides the installer...
Sure, https://jira.spring.io/browse/DATACMNS-1194.
Not quite. You need to install the following extra SDKs to get a Hello World running: * .Net Core (yes, you need to install .Net to run Azure Java Fuctions) * Node.js https://docs.microsoft.com/en-us/azure/azure-functions/functions-create-first-java-maven 
If the returned code means success, the values affected by the call must be valid, _or_ the docs for the function _must_ very explicitly state that the client must also check this and that. And if there is a string desire to change such aspect to the worse in the new version, e.g. for the sake of higher performance in non-edge cases, introduce a _new_ function, `fastGetX()`, `getXEx()`, or whatever. That's API design 101.
JSR 371 - https://jcp.org/en/jsr/detail?id=371 - Model-View-Controller (MVC 1.0) Specification ... is what ths is about. "MVC 1.0 spec" remains a shit short name for this. It's not less shit when that's expanded to "Model-View-Controller (MVC 1.0) Specification". In the same way the open source community toiled to make simpler alternates to JSF and Struts, then will be a deliberate effort to ignore this JSR too.
Wow, windows API responses that do not confirm to API can break applications. More news at 11!
I just made a thread about wanting to make something similar (except no accounts). Is this open-source? Can I contribute somehow?
Windows continues to be a shitfest
We have been considering [WebPrint](https://github.com/micwallace/WebPrint)/[QZ-Print](https://github.com/qzind/tray) to print web reports to ESC/P printers. Would that work for you?
Having used Couchbase a ton, I always wonder why it's omitted? It's not the best for queries, but for self-indexed data, it works really well (imagine user has an inventory, key is uuid:inventory) 
&gt; Lmao no Sounds like a comprehensive summary of what this sub concludes whenever this question is asked.
It does work nicely with Java EE Security ;)
Why does the Start Menu wants to be a directory structure? Sure, it looks nice on a design board, that we'll just dump folders full of shortcuts into the user's Star Menu folder via our nasty MSI installers, but then why mix that with virtual folders for system components that are displayed in the Start Menu, but are not there.
Is that eclipse compiler doing that? None of this happens with Oracle jdk, compiler issues error and the last example you have, it compiles but throws NPE as expected because B is null at this point still. You can use variables in a class before they are initialized. This was problem with C programmers coming to Java because in C/C++ construction order of classes is different, in java all methods are virtual calls. The deal with enums is that they have an expected structure, the symbols come first. You can look on stack overflow for ways people find to get around [this.] (https://stackoverflow.com/questions/5678309/illegal-forward-reference-and-enums) This is also required reading on enums. http://madbean.com/2004/mb2004-3/ 
I have given a full description of what compiler provides which results. Eclipse does something and the Oracle JDK does something else. I am not asking how to solve a problem. I am questioning Oracle's JDK's compiler's behavior according to the JLS and for sheer inconsistency.
If it can print to POS printers - which are not actually printers in the OS, but weird USB devices - then it might. Things like the Epson TM-T88IV - which is our test printer. As I said, our current solution is JPOS based, and the completely breaks under Java 9 as there's no easy way to get hardware-specific drivers into the JVM.i suspect the *correct* answer is to have JMOD files in the Java module path, but that's a big step for both us and the printer manufacturers. (At least one didn't know Java 9 was a problem until we told them!)
As my previous comment put it quite moderately, neither the former or the latter. 
Yes, POS/thermal/dot matrix, that is my use case as well
https://stackoverflow.com/questions/3061654/what-is-the-difference-between-javac-and-the-eclipse-compiler#3061680 &gt;One notable difference is that the Eclipse compiler lets you run code that didn't actually properly compile. If the block of code with the error is never ran, your program will run fine.
Check out [Immutables](https://immutables.github.io/), specifically with the [staged builder configuration option](https://immutables.github.io/immutable.html#staged-builder) enabled. Should do exactly what you want - we use it in our applications and it has worked great for us.
Because you can compile once and run everywhere almost without care about the operating System. Besides that Java is one of the few languages where is it possible to build cross-platform quick dirty GUIs with Java Swing that works everywhere. I did not choose Java, I choose the Java platform and I hate Java syntax with love, I use the JVM with Scala.
Don’t get it
I believe he is referring to [David Guetta](https://en.wikipedia.org/wiki/David_Guetta).
I think I may have heard that name once.
Yeah, it’s an original joke!
Thanks for posting this! I use String.replace() a lot in my game in order to support language localization. While I won't see the high volume that you see in JOOQ, my game is designed to run on platforms as small as a Raspberry Pi Zero so every potential performance &amp; memory improvement is important.
You're welcome :)
omg this is great in so many ways. feeling prof after these :D
Something tells me OP is Canadian
That's not what it is. This is just the call into the native API (which you have to do if you're implementing the windows-specific stuff) returns unexpected (and unchecked for) values if that folder is present. Nobody depended on any implementation details here, just a bug. Now, it can be a bug in windows (as that API shouldn't return NULL) or a bug in the Win32 java implementation (as they didn't check) for NULL , but that's another issue altoghether. Both (oracle and excelsior) should fix it though even if it is a windows bug.
I lol'd.
You're right, it is a bug in JDK in native methods implementation. Oracle has already fixed it and backported into Java 8. We in Excelsior reuse some JDK natives including those with a problem, so it is fixed automatically in the latest version of Excelsior JET.
You can write it to a log and run it off a cron once a day, or once a week or something. Then whatever monitoring tool you're using can just parse the log. Something like: /usr/bin/keytool -v -list -keystore $JAVA_HOME/lib/security/cacerts &lt; /dev/null 2&gt; /dev/null | /usr/bin/grep 'Valid from' | /usr/bin/awk '{print $NF,$11,$12}' | /usr/bin/ts &gt; /var/log/cacerts.log
You can share this link, this is the other copy that I am experimenting with, that has "Try without login" https://www.codiva.io/?ref=reddit 
My first post on this topic involved asking the community for suggestions, and then looking at Indeed Jobs, GitHub Stars and Stack Overflow Tags. I realize it's not a great way to do a comparison because it's really just a popularity contents. However, Couchbase did get dinged on the fact that its server is not on GitHub, hence no stars. https://developer.okta.com/blog/2017/09/08/nosql-options-for-java-developers "NOTE: Cassandra, HBase, PostgreSQL are mirrored repositories. DynamoDB, Couchbase, and FaunaDB don’t have their servers on GitHub, so I counted stars for their Java-based drivers. Using number of stars for each option’s Java driver is a good idea, but there’s 11 just for Redis." JHipster will be adding support for Couchbase soon (alongside MongoDB and Cassandra), so I do think that's a strong endorsement. https://github.com/jhipster/generator-jhipster/issues/6086
I hate how Windows and other operating systems treat the file system as more than a file system and use it for things other than file systems &gt;:( All a file system should do is store files!
**Sidebar** + **Do not post tutorials here!**
The changes feel, indeed, not particularly stunning for 3 and 1/2 years of development time since the release of Java 8. Java 9 is all about Jigsaw. So much time spent on refactoring parts of the JRE, and so little on actual language features. Let's hope Jigsaw pays off somehow. And let's hope the shorter release cycles that were announced, result in a less glacial language evolution. 
I thank you for trying to provide help, but this is really irrelevant you know \-\_\-°
There is no problem with trying to use the file system as the basic organizing structure, but then make everything a proper file. Like 9p (Plan 9) does. Symlinks, hardlinks, pipes, sockets, sysfs, procfs, shm, and everything is a file. Great, but then be consistent. No registry (make it a directory). WinSxS is actually a great step in the file direction. Even if it takes up an ungodly amount of disk space. (Compared to symbol versioning and making backward compatible "DLLs" and or bundling up DLLs into a compressed indexed file.) And of course, Windows should make symlinking available for mere mortal users as a first step, before fucking up their own APIs with god mode files/folders. And fuck undocumented features, if it's possible to have a file without a displayable name, then that should be pointed out in the API docs. (Maybe it is, though. Allegedly MSDN is wonderful.)
Does this overhead carry over to .replaceAll() as well? .. I may need to refactor some code..
thenewboston is decidedly **NOT** one of the best java series out there, in fact it is probably one of the worst. It has been a dissuaded resource on /r/learnjava and /r/javahelp for years. Check out the sidebar on r/learnjava, I recommend the official Oracle tutorial and Derek Banas on youtube.
`replaceAll()` creates a new `Pattern` every time you call it. If you can store the `Pattern` in a static member, you'll obviously gain a lot if you call the method very often. The article shows an example: private static final Pattern TYPE_NAME_PATTERN = Pattern.compile("\\([^\\)]*\\)"); // Much better, pattern is pre-compiled TYPE_NAME_PATTERN.matcher(castTypeName).replaceAll("") // Much worse, pattern is compiled *every time* castTypeName.replaceAll("\\([^\\)]*\\)", "")
&gt; _God_ &gt; Windows 10 _Creators_ Update Check mate, evolutionists
Typo: grep -b 'fn__' | \ should be grep -v 'fn__' | \
So you think now. 
I am by no means a java compiler expert...but there are more than compiler. There's the one that turns the .java into .class and then there's the JIT while the application is running. &gt; It includes dynamic compilers that adaptively compile Java bytecodes into optimized machine instructions and efficiently manages the Java heap using garbage collectors, optimized for both low pause time and throughput. It provides data and information to profiling, monitoring and debugging tools and applications. Fixes for the first might make a difference in .class, the second class, not so much.
Sure, that's a distinction that I knew of but did not remember to take into account in my original posting. There is the javac compiler that compiles .java files to .class files, and then the Hotspot just-in-time compiler at runtime, which handles the compilation from .class files to machine code that is native to the processor the JRE runs on. Recompilation would only be needed when there are changes to the javac compiler, as the JIT compiler is part of the JRE.
Offtopic, but out of curiosity, how has your experience been with running something (considered) as heavy as the JVM on devices with such constrained resources?
I'm not aware of a Maven tool, but maybe this is somewhat going in the direction you want: [JAPI Compliance Checker](http://ispras.linuxbase.org/index.php/Java_API_Compliance_Checker) or [zipdiff](http://zipdiff.sourceforge.net/)
To quote QI 'Nobody knows'. No, really, nobody knows.
Caffeine is a diuretic.
Dude, stop spamming this sub.
Yeah I agree! This is exactly what this sub needs. Cheers
There must be another variable. Even small apples, or applets, make me poop so super hard.
You mentioned the important key term in the title already "forward reference". What you should be aware of is that you must first declare your vars then you may call it e.g. This is valid: String x = "x"; String xCopy = x; This is not valid: String xCopy = x; String x = "x"; The second example is not valid due to forward reference i.e. String x must be declared first before it can be used. If some compilers automatically fix this issue for you, great but you must be declaring your var before using it. Read more here: https://www.cs.auckland.ac.nz/references/unix/digital/AQTLTBTE/DOCU_024.HTM
So you don't have to waste time searching, here is a login for oracle.com that I found: Username: forkoff@bobmail.info; Password: N0peN0pe Worked for me like a charm! :) 
[removed]
Let's not talk about why it looks like obvious it should fail, and concentrate instead on these points: - different compilers provide different results. I'm not speaking weird shady compilers nobody uses. I'm speaking Eclipse and IntelliJ here. They pass all conformance tests. - The JLS says forward reference is forbidden when using simple names, as, indeed, it is obvious that should fail. MyEnum.TEST is not a simple name. - AFAICT this error is only observed within the enum constants declaration of an enum type. Trying to have the same behavior anywhere else just fails. The same reasoning that justifies for it to fail in enums is still the exact same reasoning and just as valid anywhere else. 
Then can you comment on the relevance of discussing what happens when some code doesn't properly compile and isn't entirely run, when working on a piece of code that entirely compiles and is entirely run? Or otherwise what is there in this link to help analyzing the current situation?
Nice article, but lots of capitalization errors. 
JVM is not that heavy by today's hardware standards. My friend runs the game on a Raspberry Pi Zero with 512M. He starts it from the command line with 350M or something like that ("java -Xmx350m -jar Remnants.jar") The game does check for low memory at startup and may disable animations. The game doesn't last that long on a Zero because I haven't decided how to do ship combat without animations yet... I might just make it all auto-resolve. The real problem is that many games have little actual memory tuning done. They just throw memory at the problem by raising the minimum amount of memory needed.
I've compiled a small library with a list of custom annotations. I mainly use those to "sanitise" my REST API requests. It's because javax bean validation integrates so nice with Spring (Boot). I would probably add some tests and more examples in the future. 
For the love of god, stop spamming.
Why would you want to enforce that a string is blank?
I think I did that with an new API that to replace an older one without breaking some existing clients, but in the same not allowing a value there. Crazy requirement. There are corner cases, it's not something you would any day.
welp....TIL
What problem are you trying to solve here?
There is more than that, as there are plenty of Java compilers to choose from, unless you mean to focus on Oracle only.
No for a few reasons: * There is more than one compiler * Even an individual compiler will make different decisions about compilation run-to-run * A developer may run all kinds of obfuscates or code refactoring tools that can change how a part of an application compiles drastically. 
I've solved this problem the other way around. I put the monitor on the web request with check_http. While it creates a monitor per micro service, it also lets you check which service has not received the new cert yet, even when running on the same box with the same cert.
This is what you're having trouble with? I can barely read this at all.
Let's look at your string example: static final String A = new String(MyClass.B); static final String B = new String("Hello, World!"); String A would cause a null pointer exception because String B has not yet been initialized. Java will not update the reference dynamically because that will break application flow. You're wondering, why does it not give compiler error? It's allowed because of null referencing. enum Test { HELLO; } Test.HELLO will never be null, how can it be? It's a singleton. Once initialized, you're done. static String A = new String(B); static String B = new String("Hello, World!"); The above example will result in error. A fails because B has not yet been initialized. static String A = new String(HelloCodiva.B); static String B = new String("Hello, World!"); A compiles because B has been initialized, calling using the Class.Var because B will already be initialized. Note the keyword: static, well how does static work? The static variable gets memory only once in class area at the time of class loading B technically should be initialized. Due to forward referencing, A will be null because of order of operations. Does it make sense? 
🙄
&gt; You're wondering, why does it not give compiler error? It's allowed because of null referencing. Actually I'm wondering why would the enum example give a compiler error if this class example does not. In my enum example, the thing that might be null is not the enum constant itself, it's the parameter given to the constructor for the enum constant. &gt; A compiles because B has been initialized, calling using the Class.Var because B will already be initialized. I am not sure I understand this sentence nor that I follow the rest. By the definition of initialized B will clearly not have been initialized. Though one could say we "trick" the compiler into not being able to know that as we use the syntax for a class access rather than B's simple name. I am generally well versed in the questions of the orders of class loading, initialization and instance initialization. I understand that despite best efforts to discourage it, the language makes it possible to access a variable before it was properly initialized, and it is instead in a blanked state that was performed by the first steps of class or instance initialization that obtains the necessary memory space for the variables and give them default values that are unaffected by programmable behavior. Here I am more wondering about the inconsistencies between compilers, what the JLS says and Oracle's compiler does, and what happens when compiling an enum or a class. 
There is a lot going on in this question * Javac does not do any serious optimizations, but there will be but code differences. Real optimizations happens at run time. * Javap is a utility that prints out the generated bytecode for a .class file. It would be easy to write a small utility that runs javap over all classes and uses diff to find differences. * Java offers a guarantee that all previously generated bytecode will run on newer jdk. Backwards compatibility essentially. This gets a lot more complicated with the JNI and keeping all dependencies identical. It's good to stay up to date, but it depends on what you are trying to get. You can get good stuff like optimizations and bug fixes, but you could also upgrade to a jdk that has new bugs( which does happen).
&gt; Even an individual compiler will make different decisions about compilation run-to-run Why are compilers implemented in a non-deterministic way? I have never heard of this before.
So you want to compile your code on every new JDK update, but only if the resulting byte code would be different. May I ask why the hell you want to do this?
Take a look at the [H2](http://www.h2database.com/html/main.html) database, especially the [architecture](http://www.h2database.com/html/architecture.html) page.
Thanks, will do.
Some compilers are more focused on particular types of works or metrics. That can make a big difference in what byte code gets generated, and the assembly thereafter.
There's actually [this article](https://cstack.github.io/db_tutorial/parts/part1.html) about writing a database from scratch. I believe the code in the article is written in C, but it should be fairly easy to translate to Java.
Here's the absolute best advice I can give you. Bookmark this for five years from now so you can self-reflect on how much of an asshole you use to be. 
I needed to make a tool that did something similar. Basically I needed a hash of all the runtime dependencies of a specific class - an "fingerprint" of a class at a certain point in time. You could follow the same pattern to maybe get a hash of each file and see what classe are different. https://github.com/StackTraceYo/sash
That's awesome. Definitely will read this.
It is not typically necessary to recompile a class file outside major java versions. The changes are minor, do not relate to performance (we have jit for that) and affect few people. Unless you are specifically experiencing a problem, do not worry about recompiling.
FWIW the Postgres source is actually really easy to read. As you start to learn some concepts you can drop in and look at how Postgres does things. More than once I've had a question that the docs didn't quite answer and just gone into the pg source code to see what it's doing.
It's not Java unfortunately, but people praise the sqlite code as well written and self explanatory. Also a person who tried writing a database in the past, this is one hell of an exercise that will make you learn about threads, network programming, caching, design patterns and many other things. Eventually I've lost interest and my database sucks, but it was one good ride that helped me understand a lot of "black magic" stuff.
Several years ago the [Eclipse p2 project](https://wiki.eclipse.org/Equinox/p2) was developed as a kind of package management system for eclipse projects. One of the design points for p2 was that "ID + version = bytes". It was a fundamental assumption that if your bytes changed then you should also change your version. Changing compiler is just one of several different things that could have an effect on the final built bytes for a jar. The p2 project then required build tooling to detect when final compiled jars changed without a corresponding version change. Some [ant tasks](https://help.eclipse.org/neon/topic/org.eclipse.platform.doc.isv/guide/p2_repositorytasks.htm?cp=2_0_20_3_3) were developed (in particular, the p2.mirror task with a comparator) for this purpose and were used in their ant based build system. One of the things this tooling did was disassemble class files and compare them against the previous version to see if they changed. Eclipse later moved from Ant to Maven for their build system, I don't know if this tooling is still used. (I no longer follow eclipse as closely as I once did.)
Never asked enough.
You flatter yourself way too much and have zero tolerence on any sort of hint that you are not entirely and unmustakenly right. I thanked you, I pointed out to you that this is not on the right track, and you actively chose to deny it. When I decided that you might be on more than what I could notice by myself and I invited you ti show me how, you chose to complain and call me an asshole. You need to grow up. And to learn that discussions on mathematical levels of correctness are not open to the sale fuzzy logic as other domains. Notably, you will learn that languages abd algorithms can be proven.
That is mental, you have my sympathies 
if your goal is to understand databases better, I think is would be a good idea to just get into mySQL or SQL, very easy to set up initially, and then build some java apps that use this DB. Something like a store inventory displayer/adder/remover, etc.
I already have desktop and web apps I host that use MySQL. I want a in-depth understanding. 
Finally back home and read it a little more. This is exactly what I was looking for thank you. I have dabbled in c and have a few books if something trips me up too bad. Thanks.
Never finished watching, but this might be [interesting](https://www.youtube.com/watch?v=Cym4TZwTCNU). From one of the creators of Clojure.
Video linked by /u/nexus4strife: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [Rich Hickey: Deconstructing the Database](https://youtube.com/watch?v=Cym4TZwTCNU)|InfoQ|2012-08-23|1:06:24|482+ (98%)|56,639 $quote Rich Hickey, author of Clojure, and designer of Datomic... --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/nexus4strife ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=$comment_id\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v2.0.0
Beware of cold starts 
I'd say write your own database that implements the jdbc driver and can do basic inserts, updates, reads, and deletes. Adding in all the other things like joins, subqueries, and the like is going to get really complicated really quick...
Just run diff and conditionally redeploy?
Usually you don't change compilers, except for updates. You install a jdk in your CI environment that will be used for all release builds. It's not like jenkins decides to use openjdk one day and then oracle jdk another because it feels like it.
I'm curious about the use-case being solved here. Obviously, it seems desirable to "leak" the query system that is supposed to be contained inside of the repository to the "outside world" of the repository. Why would that not be a clear sign that: - either your repository client code should be moved *inside* of the repository - or you should abandon the repository pattern entirely
Vert.x will screw with your mind. It's async, which is very difficult to get in too. Plus documentation isn't that complete. It is currently one of the better async frameworks, but that's because there aren't that many yet. 
 private static final long serialVersionUID = 2017_06_16_001L; You mean, like that?
Catches are probably resource usage and startup time. Spring Boot is like the 'reference configuration' of Spring, just like how you have reference implementations. Spring glues a lot of standard tools and functionality together pretty well, and has been doing that for over ten years now. A proven track record, plus they still create new versions and add new features. 
Oooh, that is such a beautiful way to debug streams. I'm in love. Does it work with Kotlin?
Neat.
Does Eclipse have something similar? 
They are hints because it takes work to research **undefined behavior** and I owe you nothing, but they are solid hints. Its your itch, you can scratch it but man are you bad at knowing where to scratch or taking hints from the vast trail of people before. I mentioned java construction order is not intuitive. How do you ensure singleton status if you are allowed to execute other code first? I said compilers behave differently. Even the JLS section on enums mentions this and if you read this section under methods you might realize how a compiler would make it past compilation, especially one that defines itself for speed by doing incremental compilation. I mentioned an article describing how the keyword enum is actually Enum&lt;E&gt;. Does type erasure affect incremental builds in the eclipse compiler? What you read in the spec and what exists in the wild are always different, but trust the official compiler, as the spec is married to it as implementation details often drive the spec. The SO thread I referenced should have been a warning sign you are not the first person to find some corner of the spec left to interpretation but certainly NOT TO PRESUME THAT SOMETHING MUST FILL THAT VOID, which is what you can't seem to wrap your head around. See how things are adding up and the uncertainty of where this bug/feature lies in the eclipse compiler? &gt;For each enum constant c declared in the body of the declaration of E, E has an implicitly declared public static final field of type E that has the same name as c. The field has a variable initializer consisting of c, and is annotated by the same annotations as c. &gt;These fields are implicitly declared in the same order as the corresponding enum constants, **before** any static fields explicitly declared in the body of the declaration of E. Compilers are allowed to do whatever they want but under the hood they would like to get to this part static final E &lt;cname&gt; = &lt;some value&gt; as soon as possible and they're supposed to do before anything else. &gt;The variable TEXT is used before it is properly initialized, thus actually has class post-loading value null. This is the crux of the problem except the dependency is reversed or you could say it has another layer of indirection to resolve first. Imagine a compiler that has to resolve one condition before another condition first, now imagine a scenario where the two events are reversed via being composed because of recursion. Which one do you resolve first now? Your compiler static logic checks for forward reference first and then non default constructor logic next or vice versa and there is your bug/feature. Even if you resolve both conditions independently you have to choose one of them to act on first. Are they doing it this way because it allows them to something special with incremental builds? Real world doesn't give a shit about your math, the holes in the spec are where compilers can define themselves in the marketplace just like every other business does. (laws are specs) You describe a recursive paradox because construction of enums happens at first use Object naming references have no bearing. You referenced it and it executed? You just kicked off the enum constructor because of the above JLS conditions I quoted. This is a forward reference. The value of cname is to be set internally before the call to construction in the source is supposed to happen because you reference the enum in the parameter value, thus kicking off what would be static initializers which again shouldn't execute before the enum cname initializers. **Undefined behavior yields undefined results** This is the ONLY take away you're getting from this nonsense. Don't make your school paper about this. -_-° 
NoClassDefFound for magicAccessorImpl...
Food for thought: what would prevent javac from being able to emit a binary file?
The trick is interpreting code as data :) For example, if you know that a xor %ecx,%ecx corresponds to the byte sequence 31 c9, then javac just needs to write those bytes to a file. When the processor interprets those bytes as code, it will execute the xor instruction.
Javac doesn't emit the binary file. Javac is a common Java application and "javac.exe" binary is a separate C launcher-application which just starts JVM and loads the corresponding javac's main class and passes all arguments to it. Actually if you look to the contents of "bin" directory of JDK or JRE you'll find out that almost all exes are actually the same with the only difference that they just start different Java-applications (e.g. kinit.exe, orb.exe, etc).
Same way that a C compiler can compile C, with the CPU only understanding machine code. Or assembler before that. The first compiler had to be written in machine code, but once that's done, the next version could be written with assembly, C, etc.
Do you think the switch statement is the way to go as far as the REPL is concerned? I guess a bunch of if else if would be hacky...
Because it makes Java bytecode? You could always make a Java to bytecode assembler though... That is basically what the jvm is.
Wow, I really thank you to have taken our differences to the side and taken the time to write that carefully thought up response. You are absolutely right that you do not owe me anything, but quite frankly you do not get to point out a random article and then say that it talks about how we don't always have it how we think we should and I should have taken that consideration as the one to apply in my case. Quite frankly, another way to save your time would have been to ignore me. That would have saved me from trying to find meaning in something that doesn't. While I thank you for this careful analysis and these theories, as they are exactly what I wanted to discuss, I am afraid I am not convinced by them. First, you make several mentions of undefined behavior. I am afraid I do not see how there is anything in any way undefined. There are simple names, and there are accesses that are not simple names. Both defined entirely as far as I can figure in the context of the examples I give. You try to illustrate that it is undefined behavior by pointing out the section on the definition of enums, enums constructors, and enums methods. But they don't actually mention an effect on the behavior that is fully defined, do they? Second you mention a difficulty for the compiler to figure out the proper execution order of the program I wrote, because of the problem of deciding whether to execute the initialization of the String variable or the initialization of the enum constants. But that is not actually a thing in Java now is it? The order is actually fully defined when encountering the same problem in classes or interfaces, and while it is true that it may seem counterintuitive and it unfortunately provides access to final variables before they are assigned their definite value, the order is all static variables of a class are initialized in the order they are declared. If that triggers one that is accessed before it was declared then it means its value was not set yet and the value obtained is zero / false / null. Unless the variable is a constant and the constant value is substituted to an access to the variable. Notably this problem is not recursive at all. It is true that the results may be unpredictible in inter-classes case, as it will depend on the order in which each class is loaded and depending on how fully defined is the example studied we might not know the order in which classes are loaded. The example I proposed are single-class though. You mention what the spec says is special about the enum case. Enum constants are essentially taken as static variables declared at the place and order the constants were declared. Okay well then it looks like we still have our fully defined behaviour in the same way we had it in a class. Now I will agree that in the real world there is what the papers say will happen and there is what truly happens after a team released a very efficient and fully functional compiler. That would be an acceptable realistic explanation. I still doesn't see what's relevant in the differences between enums and classes that would provoke a different result though, but I didn't intend to discuss too profundly the internals of designing a compiler if we agree or disagree on whether it behaves according to specs. 
Class files are binary files, but I take it you mean an executable compiled for a specific architecture. Well, as of Java 9 they added "ahead-of-time compilation", which does compile java to local native code. It's done with jaotc, not javac, but that's a minor difference. However, it is a new feature. I haven't had a reason to use it yet. Keep in mind that the just-in-time (JIT) compiler is rather good at creating efficient native code on the fly. It has a variety of optimizations, including recompilation based on additional information. For instance, if a given function seems to always have a non-null argument, it can recompile without null checks — and then if you pass it a null it will catch the SIGSEGV signal, recompile, and invoke again, all on the fly and without you noticing, other than the function being slightly slower on later calls (due to the null check). 
This is the correct answer.
So to crack this: 1. Start program and wait for it to load (optionally set breakpoint when JVM jumps to main method of loaded code) 2. Freeze process 3. Dump memory 4. Extract decrypted classes from memory dump Alternatively: 1. Start program and set breakpoint when custom classloader returns to java classloader 2. When program pauses, dump memory 3. Extract AES key from dump 4. Decrypt classes
You can't set breakpoint on the JVM, when JVM is under debugging, the data will not be decrypted.
If you control the host operating system, then you can hide a debugger pretty easily. Or use a hardware debugger to debug the entire system. The point is that storing the AES key within the classes is just security through obscurity, which just *delays* cracking at best.
You are very professional. Any solution only just can delay the cracking and improve the difficulty, or need some additional work to crack, that's enough. Nothing can 100% against RE, and we will continue to release new version to make the cracking harder. Thank you for your analysis. If you have any other suggestion, welcome to tell us. Thanks.
The class loader itself isn't encrypted, is it?
The ClassLoader itself is encrypted, and the native code is protected by vm layer code.
What a wall of drivel you've created. Did you have anytime for reading comprehension? &gt;the problem of deciding whether to execute the initialization of the String variable or the initialization of the enum constants. That's not a problem, the JLS is clear, the enum constants are the static initializers, the first ones, they are initialized by the constructor. There is a contradiction in the spec with regard to this special case and contradictions are undefined behavior. The problem is what the compiler chooses to do first when its in a recursive loop, its interpreting source code, it has to make a decision when unraveling it as a state tree there has to be a stopping point. The spec doesn't say how the compiler is supposed to compile. The distinction is that static initializers come before constructors in classes but in enums, constructors 'kinda' come before static initializers because they effectively have to set those static final cname variables first. That's why I basically said imagine the compiler uses the same logic for both cases OR because of the extra step of the recursive reference, the compiler is thrown off a step from that default logic and it bypasses a test somewhere causing valid code. Who knows, it really doesn't matter. The spec only covers the case of a default constructor, your case is a contradiction in what should be considered first because the logic is a recursive loop, it can't both access later static variables first and keep the contract of initializing the cname first with the constructor that accesses the said static variables. That's twice I've explained this. It is both a forward/recursive reference AND undefined behavior. Accept it. &gt;You try to illustrate that it is undefined behavior by pointing out the section on the definition of enums, enums constructors, and enums methods. *But they don't actually mention an effect on the behavior that is fully defined, do they?* I SAID ACCEPT IT. This is the actual fucking definition of undefined behavior as we know it. One compiler chose one way to handle it, another chose a different way. There is no mathematical right answer. There are literally hundreds of these edge cases in the language. Read some Java Puzzlers. 
We had projects that made use of Sun and IBM ones, while deploying across multiple JEE servers. So it is not something that happens every day, but it does come up.
Do I understand correctly that it is possible to a third person to download sources of your JRE, analyze it and build their own patched version which can just dump the decrypted classes (i.e. "skeleton-key-jre")?
&gt; Nothing can 100% against RE Well your title claims a solution so :)
The JRE is open source according to GPL, but the data is not decrpted in the jre, it is in a specia externall process.
Also, the first version doesn't need to handle the entire language. Just enough to get a bootstrapping compiler to run.
But it still means that JRE is the receiver of the decrypted data. Actually more relevant question is if it is possible to download a third-party app encrypted with your solution and replace the embedded JRE with the patched/hacked one?
And what's stopping you from intercepting that process? Especially when you are the one controlling the OS
And what about the first technique? You can't exactly stop people from making a memory dump
Ah that makes sense. So the bootstrapping of the compiler went something like: The first Sun/Oracle javac (written entirely in c/c++) compiled the first byte-code javac, which runs in a JVM written in c/c++ and launched by a small native binary. From then on, the byte-code javac is used to compile the next version's javac. I can see the byte-code for the compiler in %JDK_HOME%\lib\tools.jar. Thanks for explaining!
We will check the jre whether is legal, it the jre is modified, the decryption process will refuse to decrypt the data.
We have added some security mechanisms to prevent disassembly and debugging. Of course, There are still many ways to circumvent them.There's no 100% security against the reverse engineering. What we can do is to enhance the difficulty and continue to release new version. I think is solution is much better than obfuscation or just distribute app with original java class. For some java apps which are not widely distribute, I think this would effectively help them to prevent cracking to easily .
We already have JET for that, but your mechanisms actually appear worse than what JET offers.
Oh, it appeared to be more simple than I thought :) 
There is no solution could prevent people from dumping memory data. But they have to dump the whole memory page and analyze it, they should dump the data at right time and analyze the data to find useful.Of course it is possible to do that, but I think it would take some time. For security, we generate different key for every encryption task. People have to ask specialist to do the dump and analyze work every time. Perhaps maybe someone will publish a general crack tool someday on someway. There's no 100% security against the reverse engineering. What we can do is to enhance the difficulty and continue to release new version to change the way that we used before.
The actual desire is not to leak the query system, we just need another infrastracture abstraction inside of Spring Data repository concept. When using this new extension repository, we use it like I've said before, inside a custom repository implementation which doesn't expose the internals (Querydsl) to the service caller. Of course, service layer can access those methods, but currently there's no way of hiding that with Spring Data.
[removed]
Nothing, there are lots of native code compilers that for whatever mysterious reason, people keep forgetting about. Yet they are in business since Java exists. Since I don't feel like enumerating all of them, start by checking Excelsior JET or IBM J9.
[removed]
[removed]
JET is a great tool, it compiles the java class to native code by AOT, but it actually do not encryption or protection. I don't know the code compiled by AOT whether is easy to identified, I haven't do an in-depth research. But I think that somebody who can dump the memory and analyze the data by researching JVM, identify the code compiled by AOT is not so difficult for him. And JET is quite expensive, you have to pay it for every os platform and the process of AOT compilation is quite slow. This tool is from one of my product before. I want to distribute my app on Windows,Linux and macOS. But I can't afford the price for tree platforms. By the way ,the official AOT solution of Java is coming too, I wonder whether there will be many solution against AOT appear at that time. 
Sooner or later you will want to read up on ARIES for transaction logging. Derby has a nice page on this: http://db.apache.org/derby/papers/recovery.html C Mohan published quite a few papers on Aries, Google should help you. One is linked to from that article, but I find Derby's docs easier to read than C Mohan &amp; co. (While you're on it, read up on C Mohan's name. Real life example of when assumptions about what names people have fall flat.)
AOT is better protection than "encryption" that can easily be bypassed just by dumping memory (which is hardly a difficult thing to do). Assembler is not as easy to RE as java bytecode. OpenJDK AOT does not have the same purpose as JET. You still need the class bytecode available.
http://mail.openjdk.java.net/pipermail/hotspot-runtime-dev/2017-October/024831.html AppCDS seems to be slated for 18.3
This subreddit is for submissions written in English.
Congrats on your first application! Be thick-skinned on the criticisms, but learn. It's a long journey but you've got to start somewhere!
This is now the **second time** you post this exact same thing. The first time already was not well received and had multiple reports. What you are doing is **spamming** and this is not allowed on reddit. If you repost again, you will be banned from here.
gcj did that too, iirc.
&gt; Class files are binary files, but I take it you mean an executable compiled for a specific architecture. Well.... I think I wasn't clear, but my main point was that javac is a fully functioning java program... it can, in theory, emit whatever output it would like to a binary file. (Including a correctly formed .EXE file, or whatever other executable file you might wish.) There's nothing particularly magical or special about any of it.... it's just a program reading input and producing output. I've always liked this point of view, because it makes compilers more accessible.,. at least to my way of thinking. ymmv. 
I really like JSP + Mustache + JaxRS. I call it Model 3 JSP. JSP's are stored outside of WEB-INF, and accessed directly by the browser. Have NO business logic or jstl tags regarding layout logic. they do have &lt;fmt:message/&gt; tags, with javax.servlet.jsp.jstl.fmt.localizationContext , to enable i18n translation. Javascript takes over once a page is loaded, and loads the data into that page. the Javascript becomes the controller. Mustache.js is used to combine the HTML output from the JSP, with JSON data from the server. This is really *really* productive.... forget everything you know about stuff like Angular or Ember, or other js frameworks. This is fast, lightweight, and awesome. 
Since I haven’t been able to get help from r/javahelp, and I think my thread was deleted here, (understandably) I was wondering if someone here could answer a related question. I wrote an application using incubator.httpclient just to experiment, but a friend ended up wanting to use my project. I would like to continue experimenting with httpclient in this project, but because it is an incubator module, that makes distribution a bit more complicated. I was hoping someone could offer advice for linking httpclient to my project in the build process (Maven) without manually compiling it from OpenJDK. Thanks.
technically nothing prevents it. But my thinking is that they want to keep (most of) javac portable and the easiest way to do that is to write it in java itself and have no knowledge of binary formats for each runtime target (javac only needs to knows how jvm bytecode). 
The initial promise of java was that it would be 'internet-ready' - portable across different CPU architectures and verifiable in terms of correctness. So... the initial JVM's all interpreted the bytecode, which is part of the reason why there are as many type specific opcodes as there are in the JVM instruction set. (And it's the verifier that attempted to prove that they were all used in compatible ways.) This is not actually all that far from how languages like Python and Ruby (the C implementations, at least) work to this day. The JIT to machine code came in Java 1.2... so early in Java's history. By the time .Net rolled around, JIT was accepted practice, so Microsoft could optimize their CLR bytecode equivalent more around compilation than interpretation. Another interesting tidbit from around this time were the CPU's that ran bytecode in silicon. For those, javac did produce a native binary, even though it emitted bytecode.
Have you taken a look at the "javapackager" tool which let's you build native executables? It has an --add-modules parameter if you need to add the HttpClient module (unsure if it bundles incubator modules by default. http://docs.oracle.com/javase/9/tools/javapackager.htm#JSWOR719 As far as I know maven nor gradle support javapackager yet; however, there are ANT tasks which I know you can easily call with Gradle, I would assume maven lets you call ant tasks too (don't be concerned they aimed at JavaFX, javapackager works with standalone java apps as well): http://docs.oracle.com/javase/9/deploy/javafx-ant-tasks.htm#JSDPG198
&gt; Keep in mind that the just-in-time (JIT) compiler is rather good at creating efficient native code on the fly. This is true, but it's even more than that. Java as a language is designed in such a way that it's really hard to get good performance when compiled ahead of time. Every method being virtual, and the iterator protocol mean an ahead-of-time compiler ends up generating code that does a *lot* of slow virtual dispatch and can't inline as many calls. A JIT gathers type feedback dynamically, so it knows the exact concrete types of objects flowing through method calls. When it sees that it is always a single exact type, it can treat that as a non-virtual call which is both directly faster and opens the ability to inline the call and optimize across it.
The most annoying part of using jacoco is the way it changes your bytecode, so unless you compile using -noverify, java won’t let jacoco change the bytecode and you’ll see cryptic errors about the execution environment being corrupt or something.
Their justification is very, very poor. What they say is that Oracle wanted them to use a different name and the name should contain Java. All correct but that doesn't mean it has to be called EE4J, namely Eclipse ***. They have 0 feedback that people wanted Eclipse to be included in the name and they 0 obligation to do so. I don't like people trying to make others look stupid by using factual arguments but unrelated to the conclusion they got. They just wanted to make sure everyone understood who is the boss and increase visibility to Eclipse. In the end if openness is the goal the name should be a more generic one. Even just 'enterprise for java' or whatever is good enough. Now they are telling this BS because of all the backlash. Even if it's only the umbrella project IT IS still called EE4J so stop BS us and just rethink the name everyone hated.
Thanks for sharing. JVM FASS services is mostly unusable for user facing requests due to the load time and long cold starts. Always been an issue with systems such as App Engine also. In today's world where we can pay for compute usage by the second, the JVM lags far behind and is losing ground. Thanks for your research and hope it continues.
sdgsdfgsdfgsdfgsdfgsdfg
Nice. I like Bean Validation, only downside is that can be really slow when you have to validate a large number of objects (i found that apache bval is quicker, but it's not 2.0 compliant. and hibernate validator seems to be more actively developed).
&gt; . From then on, the byte-code javac is used to compile the next version's javac. no. javac.exe is c/C++
there is also this compiler, which compiles java directly to machine code. It's no longer supported, but shows that the concept is possible. There are a few other compilers like or similar to this https://en.wikipedia.org/wiki/GNU_Compiler_for_Java
**Sidebar** + **Do not post tutorials here!** First warning!
I suspect that the performance impact of virtual method dispatch is small in normal applications. Do you have any numbers to back up your claims?
What I meant is that the actual compile logic is in the javac java application byte-code. As mentioned in xappymah's comment, javac.exe is just a JVM launcher.
java.exe is vm. java**c**.exe is .java source file to java bte code compiler. Java/javac.exe get compiled from c/c+
You can post either a *link* or a *body text*, but not both together. As it stands, your post is useless since the link that you obviously wanted to post is not accessible. Please *edit* your post and include the link to the article in the *post body*.
&gt; I suspect that the performance impact of virtual method dispatch is small in normal applications. It's not just (or even mainly) the cost of the virtual dispatch itself. That's an extra pointer offset and an indirection. The indirection can suck because it can cause cache misses, but it's usually not the end of the world. The real problem is that a virtual method call means you can't inline the call and do optimizations across it. Keep in mind that idiomatic Java code often uses the "enhanced for" syntax which means many of your for loops are desugaring to virtual calls to `.next()` on the Iterator for each turn of the loop. &gt; Do you have any numbers to back up your claims? Not on hand, but I work with people who created the HotSpot JVM, other high performance VM implementations, and [one of the leading AoT compilers for Java](https://www.excelsiorjet.com/). My understanding of this comes from talking to them. 
is [this](https://www.quantcast.com/blog/death-by-1000-layers-the-perils-of-over-abstraction-in-java/) it? 
Doh. Thanks.
Doh. Thanks.
Doh. Thanks.
Doh. Thanks.
If you meant what prevents a Java program from emitting platform native binary, then I think it's fairly trivial to understand that because you can write out any sequence of bytes to a file, you can "handcraft" a native binary if you so desired. But my question was specifically about the javac Java application as it is, and as far as I know, there are no special parameters to instruct it to emit native binary instead of Java byte-code. I suppose it's possible to find a certain sequence of Java code that, if passed through javac, could map to an output that happens to be valid native binary that runs on your platform, but it certainly wouldn't be feasible for general purpose programming. Please correct me if I'm wrong.
This is article is wrong in so many levels, that I don't think it is even worth the effort to debunk it. Unless it is some kind of satire (as one might assume from the snarky comments about the delete button) I better that the author has never seen lisp/functional code or worked an good C++ codebase. If all you ever see in your life is bad Java code, this is the kind of article that one would write.
Yes, I understand that :) I was talking about the javac byte-code located in %JDK_HOME%\lib\tools.jar\com\sun\tools\javac\**.class
&gt; The real problem is that a virtual method call means you can't inline the call and do optimizations across it. Actually this is one of the reasons why we implemented [profile guided optimizations](https://www.excelsiorjet.com/profile-guided-optimization) in Excelsior JET. Devirtualization of hot method calls makes a significant difference.
Thanks for the update! Good to know that this feature will be brought to OpenJDK.
Ah, right. I looked at profile-guided optimization as bringing some of the same JIT magic into the AoT world.
It's rather like people are afraid of creating a new classes. Everything is shoved into a couple semi-global god objects. Fields have types like `Map&lt;String, Function&lt;String, List&lt;Integer&gt;&gt;&gt;`... Thats way worse. If you encounter a long stacktrace for debuggin, it's easy to identify the parts that concern you and are not part of some framework.
&gt; Good Java should resemble good Java. This is a super important point. The HotSpot compiler recognizes common Java idioms for which it can generate more optimal native code. If you go too far against the grain of idiomatic Java and try to apply C style optimizations, you'll handicap the JVM and you're likely to get worse performance.
Pretty good start! I would personally recommend you to check official [JDK demos and samples](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html). There are very good simple graphical applications (e.g. Java2Demo and SwingSet2) with sources which you can modify and learn a lot of interesting stuff and tricks. 
Interesting! I don't think our customers compile with -noverify and we certainly never did that with our code. Yet I never ran into that particular problem. Thanks for sharing, this will be very helpful when we encounter it :-)
I agree. Java is a hot mess. But it's an enterprise quality mess so the potential for adequate compensation is still pretty high. What do you want? Clean code? Hard cash? One cannot have both these days. And it's not like enterprise level python does not suffer from disease. 
well wouldn't final classes help to counter the problem? since they can always be devirtualized?
&gt; If you don't know what good Java looks like, then try learning that first This is exactly what leads to today's hot mess -- people *learn* what is good. How do you learn what is good? I assume it means simply memorize the patterns that you were told to be good and supress your own urge to reason. If *good* is that simple, the world peace should be here. Good cannot be told or learned. It can be immitated. In the end, it requires common sense -- that is, judgement based on critical thinking. 
I'm confused. Are you looking for a program on a MacBook or an iPad? 
I think I get the point of the article, and generally agree, but oh my god the writing style is terrible. First, the author's complaints have nothing to do with Java. Second, the whole rant can be summarized as [SOLID](https://en.wikipedia.org/wiki/SOLID_\(object-oriented_design\)). Layers are good, when used in the spirit of DI. Policy shouldn't be dependent on details of things like persistence. Too many layers seem like to me to point to an SRP violation. A class should have a cohesive responsibility, and the classes inside one layer work together to implement a cohesive policy. Otherwise, responsibility is scattered throughout the system, and changes in one layer will ripple to other layers.
I'm looking for apps I can use on my iPad
You might have better luck trying to find an online code editor than looking for an app. I'm not familiar with any iPad apps that will allow you to code and build your project. 
I would advise to reconsider, if at all possible, I can't imagine programming on mobile device being a pleasant experience.
This guy has the right idea. There's a lot of good cloud based IDEs that you can use in a browser window from any device. Personally I'm partial to codenvy.io but there's a lot of other good ones.
&gt; Java is a hot mess. How is *Java* a hot mess? Other than having an obtuse static type system and being overly verbose, nothing about Java encourages the so called "enterprise" programming style. Python may not suffer from the "enterprise" disease, but IMHO, Python has worse diseases brought on by being dynamically typed.
That helps somewhat, but the reality is that most existing classes aren't final, and you still have a lot of interfaces and interface dispatch. Think how many lines of Java code in the world are calling methods on List&lt;T&gt;, which is an interface type.
I program on my Surface Pro, but I guess that's a bit different.
Apple explicitly forbids this, you won't find anything for java and the closest thing there is currently is playgrounds. That said i do from time to time develop on my iPad pro with the keyboard but i do that using texttastic , a a source control client , and prompt ssh client
Well yeah, surfaces are designed to be used by at least semi-technical people. 
If you have more details on specific workloads causing perf issues during validation, I'd be very happy to learn about them. We've spent quite some time on improving perf (through-put as well as memory allocation) for Hibernate Validator 6 (= reference implementation for Bean Validation 2.0), so it's faster than 5.x. Surely there's further room for improvement, so if you have any input on that, please let us know. Disclaimer: I'm the lead of Hibernate Validator
/r/iPads is a better place to post this imo but I have an iPad Pro and although iPads can be great for entertainment or productivity or whatever you want (they’re really great machines), they are not a coding device. You’re gonna want something with a desktop OS. If it could run MacOS then you could download eclipse but developers are slow to bring those kind of work programs to mobile OS’s (it’s not on android either it’s a mobile problem not an iPad problem). Your best bet is to use a laptop as your main coding device. If you *really* insist on coding on an iPad you can SSH or do Python in Pythonista 3. If I were you I would get a Mac or PC laptop at your preference and keep the iPad as a secondary device. I use my iPad as an eReader, a Reddit and YouTube device, a secondary computer for casual tasks, handwriting notes in college, scanning documents, etc. my laptop is essentially only used for coding and typing larger documents like essays. 
/r/iPads is a better place to post this imo but I have an iPad Pro and although iPads can be great for entertainment or productivity or whatever you want (they’re really great machines), they are not a coding device. You’re gonna want something with a desktop OS. If it could run MacOS then you could download eclipse but developers are slow to bring those kind of work programs to mobile OS’s (it’s not on android either it’s a mobile problem not an iPad problem). Your best bet is to use a laptop as your main coding device. If you *really* insist on coding on an iPad you can SSH or do Python in Pythonista 3. If I were you I would get a Mac or PC laptop at your preference and keep the iPad as a secondary device. I use my iPad as an eReader, a Reddit and YouTube device, a secondary computer for casual tasks, handwriting notes in college, scanning documents, etc. my laptop is essentially only used for coding and typing larger documents like essays. 
Pico Compiler, but it’s not an IDE like eclipse and compiles in the cloud. As others have mentioned far from ideal, but if iPad is the only option outside of class....good luck. Pico Compiler - Java JDK by Marcin Olawskihttps://itunes.apple.com/us/app/pico-compiler-java-jdk/id992268206?mt=8
You could probably use something like Coda, and if you have access to a cloud server (or if you manage to set up an ssh connection to your Mac) you would even be able to run command-line apps. I don't think that Coda's completion and navigation (e.g., navigate to a class by name or to the class under my cursor) is great - I haven't used it - but if you just want syntax highlighting, to be able to navigate your project structure in a sane way, and to be able to run projects, it should be able to cover that.
Yes, developing on iOS is completely different from developing on Windows 10. I made it through Operating Systems on a Surface Pro. 
i'm writing a database engine in java that uses java as the query language (similar to using TreeMap and ArrayList). it's not open source but the license is liberal and developer friendly https://github.com/db4j/db4j mapdb.org is another pure java database ("a hybrid between java collection framework and embedded database engine") 
Eclipse Che Cloud based. Will require some skill to set up. Runs slow a bit. 
Wow that is impressive, very nice.
Yeah I agree. It seems they just want to force the Eclipse name even though no one thinks it's a good idea. This doesn't look good
Working with Java over for last 7+ years, I feel this article raises few relevant questions. Too many times, I have seen "future-proofing" in code bases. Even worse, people try to future proof code which within a package which is not even supposed to be used by any package outside the package. It results in lots of abstract and interface classes which don't make any sense at times
Are you a masochist? It will be trying to build a ship in a bottle...
[Eclipse Che](https://www.eclipse.org/che/)
Yeah. Developing on an iPad through a cloud based IDE sounds like a special kind of hell.
Just... why?
Log4j2 is working on an audit log framework currently, but it’s unreleased so far. Not sure on other realistic options right now for Java.
Thanks for the info! I'm pretty much in bed with logback this point, I felt like I was keeping up with best practices at the time. Is log4j2 the preferred logging framework now?
I prefer it, but I’m one of the developers, so I’m a bit biased. There are a lot of advantages to log4j2 compared to logback, though. [This page](http://logging.apache.org/log4j/2.x/manual/index.html) has a good overview.
You could look at codeHS.com They have a web based sandbox where you can store and run programs. They also have teaching material specifically for the ap test. I’m not sure how you sign up if you don’t have a class to join. If you really want to join and have problems, DM and I can add you to one of my classes. 
Type Erasure
Why?
- Put Java 8’s Date and Time API in from the start. - Overload == for Strings. - Give Applets a premature death.
Don't make everything implicitly nullable, "the billion dollar mistake". Only allow nulls when something is explicitly declared nullable, a la Kotlin. So much else of what we might want to change can be done additively; but this one is going be very hard to retrofit.
Yeah, they’re looking for a way to migrate the old date APIs to the new ones.
+ lose checked exceptions
So that you don't have to pass Class objects around just to get deserialization and it's ilk.
Looks like it's pretty limited because of Apple's regulations, but still a nice find!
Put even more money into HotJava so instead of having a Javascript based VM for all our web apps we could have an actual VM with a proper bytecode.
Show them Kotlin, basically. I know I'm gonna be downvote for this.
this x100
System.out.println() prints to stdout, which is usually the console. If you want to show some text in your program, the User Interface library (Swing, AWT, ?) you use for your program has different ways of achieving that. Hard to be more specific than that, when I don't have more context.
I don't go for changes in architecture but rather practical language features. Such as have an easy way to express delegation. Most of cs student who go through their java courses will think that inheritance is the primary way to do oop, even though delegation is actually better design in many instances. But in Java writing the delegation method wrappers is pure pain if you don't use an IDE for that. And really, anything else which reduces the massive code bloat, why do we need IDEs to write our code for us? Any such instance if a sign of bad language design. Most of project lombok as language features in Java right from the 90s, that would have been heaven. 
Just rewrite some of the old APIs so they don't throw a dozen checked exceptions every time you call them.
Why *signed* bytes???
I would recommend reading up on [https://en.wikipedia.org/wiki/Standard_streams](standard streams).
I would recommend reading up on [standard streams](https://en.wikipedia.org/wiki/Standard_streams).
**Standard streams** In computer programming, standard streams are preconnected input and output communication channels between a computer program and its environment when it begins execution. The three input/output (I/O) connections are called standard input (stdin), standard output (stdout) and standard error (stderr). Originally I/O happened via a physically connected system console (input via keyboard, output via monitor), but standard streams abstract this. When a command is executed via an interactive shell, the streams are typically connected to the text terminal on which the shell is running, but can be changed with redirection, e.g. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
Java will be adding specialized generics, which will work with both primitive and values types. Those will be reified.
Serialization: Just Say No
Amen, amen!
&gt; What does everyone else do for AUDIT logs? We just use a separate standard Logback logger. 
What specifically from Kotlin? They are looking into adding data classes to the language.
Local variable type inference will be here in 18.3!
Even after AOT Compiled, is the data still in the memory? We can dump the memory too.
Operator overloading!
Adding to the others; Don’t put so much on object, at a minimum clone, notify, notifyall, wait should not be there Marker interfaces should not be part of the spec; actually require some method/s to be implemented - eg Cloneable, Serializable Why why why why are there two damn classes in the standard library called ArrayList.. 