My biggest issue with lombok is that it doesn't play well with other processors. For example, if you're using JPA criteria then having a [metamodel processor](https://docs.jboss.org/hibernate/orm/5.0/topical/html/metamodelgen/MetamodelGenerator.html) is essential to auto generate the metamodel classes. Unfortunately a lombok annotated data entity isn't a source compatible bean class so the metamodel processor doesn't work with it. It's a pick-your-convenience scenario and the one that can't be done by an IDE wins out.
&gt; if the project can use Kotlin. I wish :) Edit: I don't get why I'm downvoted for expressing that I'd like to use Kotlin :S
JavaServer Faces is not your dad's MVC. It's component based, not action based; it handles simple things well, but if you don't know your execution stages well, they'll come back to bite you in the ass as soon as you start meddling with AJAX and Validation. Big learning curve. In my experience, it's easier to use traditional MVC frameworks like Spring MVC, or pure Javascript frameworks + REST on server side.
You mean drag and drop WYSIWYG editor? If you want that, you can get it, too. So what's the point?
I would've just used some silly regex. The way this is phrased here (support for Java and JavaScript, and probably soon also HTML, and CSS, and XML and XSLT, and what not), it looks like the simplest and silliest solution would fit.
I do not like code generation
Take a look at https://github.com/immutables/immutables, it uses annotation processors to accomplish exactly what you are describing. 
So a scala case class?
You're not that far out of the loop. I think spring is my favorite. 
The one thing that puts me off is that it turns java into something that isn't java. I put it in the same place as CSS processors. Or IE6 'extensions' It non-standardises, standardised java. I dont like it. 
Sure, IDEs code null checks for you everywhere https://projectlombok.org/features/NonNull they make creating immutable classes very simple https://projectlombok.org/features/Value the code Builders for you https://projectlombok.org/features/Builder they code cloning methods for you that change only one field https://projectlombok.org/features/experimental/Wither etc, etc I didn't even mention the basics like @Data, @Getter, @Setter It all reduces hundreds of lines of Java code and makes the code so much more readable...no hundreds of lines of getters/setters/equals/hashcode
Uhh, there's no reason for source code generation to be necessary at any point. Can you use it? Sure. Can it save you time? Maybe. Do I like it? Never. I've run into a handful of seemingly useful code generation tools in my career. Every. Single. One. has been a pain in my ass. Some saved me time (Spring Roo), some helped me do stuff I didn't know how to do (wsdl xml generation crap), and still others tried to make my life easier. None of them helped after years of working with them (in some cases) and only hindered the end result. So, using my experience with various code generation things, I am making a decision to steer clear of other things that match the same description. I feel I'm better off for it. YMMV. Think of it this way. I ate a red berry and got sick. Someone told me another red berry was good and I tried it. Got sick. A few more times I had bosses that made me eat red berries. I got sick -- not right away, but eventually. Now you show me another red berry (Lombok). I don't feel I'm unjustified in staying away from it even though it could be a strawberry. I don't need a strawberry and the chances that it's a poisoned berry like all the other ones is high enough I'll just steer clear.
Well, I've successfully writen an annottation professor that was happily living alongside Lombok and generating proper data from custom annotated fields and classes without clashing with Lombok. After some initial stumbling with compilation phases, it turned out not to be that hard. Furthermore, when Lombok was first conceived, it was indeed a hack. But subsequent annotation processing API updates have fixed the official API in a way that makes bytecode/AST modifications during annotation processing officially supported (albeit nontrivial). In most cases, the problems other annotation processors have living alongside Lombok, are bugs in those processors themselves, not Lombok.
&gt; So, any code relying on that iteration order ends up breaking between Java versions. So there is a simple solution: Change the code to **not** rely on the iteration order - or in other words: Fix those *bugs* 😎
The great thing is it's powerful. The bad thing is it's powerful. A few things I've run across are issues with Hibernate. Hibernate is notorious for vague and obscure stacktraces, not that what they are doing is anything short if incredible but still. Builders of builders or other edge cases. There are clever ways for it to be implemented but I find clever to be the enemy of stable. @Data The single worst annotation that I've had used against me in every argument of Lombok. Default your beans with setters and getters making them non-obviously mutable to your junior engineers. Sure everyone should know better, but we are dealing with human beings. Doing bad things should require more work, not less. Stick with the @Setter individually and be explicit. There are good aspects to Java being verbose. It was an easy language for beginners back in the days if C. Let it continue to teach with a healthy balance in removing the monotonous boilerplate.
This is not entirely true, it was not possible to run other annotation processors in the same cycle as Lombok as there were some things missing from Lombok side. However, starting from version 1.6.14 this is not the case anymore. Have a look at their [changelog](https://projectlombok.org/changelog). Out of the box works if Lombok runs first. However, there is a way to make sure that the order is not important though.
&gt; and they gave SceneBuilder to Gluon instead of keeping developing it. SceneBuilder is still in the OpenJDK. Oracle just no longer provides binaries for it. Gluon offers binaries for it, or you can just build it yourself. It builds quickly and easily with a simple ant command. 
When I've used it I've enjoyed using it - largely just because it makes data objects that much more readable. It makes necessary practices like null checking and good practices like immutability frictionless whereas plain Java adds unnecessary overhead to these things. Generating getters and setters from the IDE always sat badly with me, in part at least because most IDEs don't really set that up in a nice way - even IntelliJ makes you click on things to do it by default. My biggest worry with it initially was that if Lombok goes away you might be stuck, but it's all open source and the Delombok tool is simple to use. It has good IDE integrations as well. In my ideal world, Lombok would be incorporated into the Java standard library.
True but on the flip side it removes ton of useless boilerplate. The worst kind of boilerplate -- stuff that contributes absolutely nothing to advancing your understanding of the semantics or behavior of code, obfuscating it behind as much as three to up to fifteen times more LOC. Meanwhile the code it generates is tried and tested and provably correct. The kind of code generation performed by Lombok falls perfectly into the category of "perfect solution to a specific problem". If you choose to use it in your project, you will see immediate benefits. If you don't it will be hard to convince you. 
Perhaps you are right. My last (and first) foray into annotation processing was little less than 6 months ago and and my problems disappeared after moving my code generation step to later stage. Overall I found the experience pretty nice. 
Actually Java 8 told you that your tests we're broken all along.
I still don't understand what are the disadvantages? I personally do not enjoy reading through dozens to hundreds of lines of code that I should not have to write or read, as those lines contribute nothing new to what is already there. Not to mention highly reliable and correct implementations of 'hashCode()' and 'equals(Object)' (and 'toString()') generated by Lombok - it is way too easy to fowl up those. 
That's only one website. Our company has an open position for a developer with experience with JavaFX and I didn't see our ad in that list. Also, JavaFX is a GUI toolkit that is rather new compared to Swing. It will pick up over time as existing desktop projects wane and new ones begin.
No, Immutables is nice, but it is a real annotation processor. So you need an abstract class or an interface to annotate, and will create the builder in another class. What I was trying to describe is more lombok-like: an annotation (or a comment) that tells the ide 'in this pojo, I want getters/setters/whatever', and the IDE generates that code (and keeps it in sync) in the same class. Also, lombok offers some features not present in Immutables: @Log, @UtitlityClass, etc 
Mixing up object equality with equivalence is probably my biggest gripe with Hibernate and other persistence frameworks. They are not the same thing imo. Entity equivalence should be based on their identity while equality should be based on data content. 
I use it on my personal projects where I only have to worry about myself, but haven't introduced it to my day job yet. Not confident it would be worth the hassle there (differing skill levels and management who likes to think of devs as hot-swappable cogs in a machine).
"[I]t’s easy to have a codebase that accidentally relies on undefined JVM behavior". Well, if you don't read the documentation, sure. But that's like saying it's easy to have a codebase that's buggy if you're bad at coding.
* Laying out components with an API designed to layout components, including correct resize behavior, not CSS hacks which has nothing to do with laying out components * Right click popup menus (instead of getting the browser's popup menu) * Scroll the data in a table independent of the headers so the headers are always visible. No CSS and javascript hacks necessary to accomplish what is normal and expected behavior. * Out-of-the-box table sorting and filtering, no css and javascript hacks necessary * Components that are part of the same ecosystem and are designed to work together with a consistent API. Don't need to go looking for dozens of different javascript libraries, each with their own styling, none of which are designed to work together, to accomplish simple tasks. And for the love of anything sane hopefully you are able to style those libraries to make it look like the rest of your app. * Not having to work in a stateless fashion, I have access to all of my app's data without having to pass everything to/from a server on every request. * Don't have to worry about each browser making my application look differently, and the quirks of each browser making some things work in one browser but not another. All based on the whims of browser developers' interpretation of standards. * Don't have to write my application in the garbage that is JavaScript. * Desktop apps can be debugged far easier than an app running in a browser. A desktop application, whether Swing, JavaFX, or insert your favorite desktop GUI toolkit, is going to be far richer, far quicker than any web application will be. Web applications are basically evil, they work good for some things, but people are going way overboard e.g. http://www.trello.com is awful as a web application, would be a much better experience as a desktop application. Crazily enough on desktop computers everyone wants web applications and say native desktop apps are dead, but on mobile devices everyone wants native apps. And the only advantage anyone can ever come up with for web applications over desktop applications is deployment, seriously that is the only advantage. Hardly worth it when there are dozens of disadvantages. Web applications are nothing but a hodgepodge of technologies pushing HTTP and web browsers to do things they were not designed to do, they are all just a pile of dirty hacks on top of each other.
Lazily-loaded renderers into *enormous* models. It took a me a few minutes to understand why things like ReadOnlyUnbackedObservableList exist, and why they kick so much ass.
Don't leave home without it. 
Define your pojos in a Kotlin file data class Foo(val id: String, val foo: String) data class Bar(val id: String, val bar: String) 
Agreed. Without it, I feel like Java is an annoying language to use because of all of the unnecessary boilerplate required... 
Can't live without it.
But, annoyingly, not great interoperability with Lombok. I have a project that uses Lombok extensively and I wanted to try introducing Kotlin, but I discovered that if the Kotlin code needs to call Lombok-generated methods in existing Java code, you are pretty much out of luck, at least if you want to build your code using IntelliJ's build system. You can make it work in a Gradle or Maven build by running `kapt`, but that's not supported by IntelliJ's build system. 
&gt; That means the code that runs somewhere is not the code I have in Git. How is this different from the output of javac, though? The compiler is taking a text file and turning it into a bunch of bytecode. Although it's a third-party tool rather than integrated into javac, and the implementation is kind of a hack, what Lombok is doing isn't really that far removed from, say, `x -&gt; x + 1` in your source code causing the compiler to generate an anonymous inner class that implements an arbitrary single-method interface and gets instantiated implicitly.
Reinforcing the point that Lombok should be avoided because it de-standardizes your code. 
Grid layouts. Browsers can't even do a proper *grid* layout!
Uses JavaScript. Eww.
Reactjs? Was that last month or this one?
Native applications are far more stable in terms of maintenance, more resilient to developer whims over time, more consistent, etc.
JavaScript is even more horrible a language than C++. Y'all are nuts.
I work on Play, so I'm biased... but you should check out Play. Play will give you incredible performance next to anything else, and it's simple to use. Here's the REST API example for Play Java: https://github.com/playframework/play-java-rest-api-example/blob/2.5.x/app/v1/post/PostController.java If you've never used Play before, you should start with one of the starter projects (download the zip file, then type "./sbt run" and go out for a coffee), and then try the examples: https://playframework.com/download If you want to use GAE with Play, the packaging is pretty straightforward if you use Docker: http://tanin.nanakorn.com/blogs/345 Since you mention developing for Android, I know that Dagger 2 is popular there, and Play has a project showing compile time DI using Dagger: https://github.com/playframework/play-java-dagger2-example/tree/2.5.x Also, do note that Play 2.6.x is coming out this week, so you'll need to upgrade in short order. :-)
No, it's a preprocessor. You can verify that using a decompiler and decompiling the generated class file. edit: grammar
I just use kotlin
So where is the Web RAD development environment that supports? - WYSIWYG editing of screens, including layouts and component design - Drag and drop of components from a toolbox. - Ability to add components to such toolbox - Components powerful enough the be plugged together, connect to databases or draw graphics while in edit mode - Configuration of render time data for demo purposes while editing - Visually define workflows between application screens - Visually bind events from one component into another component - Visually define and configure data bindings, also visible doing edit time - Ability to customize components styles and look&amp;feel at design time - Creation of animations and binding them to the components - Visual debugging - Configuration of layout managers, including adding new ones Suggestions are welcomed to which editor covers 100% of these features for web development, and how to deploy such applications in the HTML/JavaScript/CSS stack. This was a brief overview of what is possible today with the likes of Microsoft Blend for WPF and UWP applications.
You could check out [Trouble Maker](https://github.com/in-the-keyhole/khs-trouble-maker), it's like Chaos Monkey, but not based on EC2.
Vavr lookes much more tempting... Light weight: immutables. 
&gt; Swing sucks. Can you share some reasons you think swing sucks? 
So electron is wrapping a web application as a desktop application. That is coming full circle. Why not just use a desktop GUI toolkit like JavaFX or Swing in the first place? What possible advantage over could Electron offer over JavaFX or Swing? Once you are using Electron you don't even have the "deployment" excuse.
Well, YMMV. And it seems that you've made up your mind and there's nothing I or anyone else can say to convince you otherwise. Pity, but not really surprising, given how strongly dogmatic you seem to be in protecting your point of view. As for the NPE that Lombok throws when assigning null to fields or params annotated with @NotNull - this is actually subtle but very powerful feature. You will see exceptions exactly where they are passed to values that should never see a whiff of null instead of discovering it very far away far removed and silently propagated through code until it blows up where it least expected. In a way it is similar to array bounds checks you are used to when accessing arrays and lists by index. 
&gt; What I couldn't do is use lombok with kotlin classes. O_o That's just pure masochism.
&gt;Why not just use a desktop GUI toolkit like JavaFX or Swing in the first place? Well I don't know about swing but javafx doesn't come close to electron in term of 3rd party components, CSS frameworks, tutorials and a community. Styling in javaFX is still somehow tricky so if a good look is a requirement for your application you will need to spend (much) more time on figuring that out. There are also minor things, like the fact that javafx8 webkit is pretty outdated (should to be fixed in java9). 
Yep, delombok is a nice insurance.
mmmm... I work in a team, not everyone wants to change the language. It is a big investment in time and effort. (Honestly, I don't now how people do change languages in a team... I'm not confident enough about Kotlin, or Scala, or whatever, is worth the time and effort)
Eh, it's a hack. If you want a similar set of functionality, just use Kotlin. Otherwise, just use Java. Lombok seems like an evolutionary dead end. 
&gt; It's a pick-your-convenience scenario and the one that can't be done by an IDE wins out. Can you see if an IDE generated equals was modified by a human or not?
I'm just starting with Kotlin and I didn't know how to override `equals` and `hashCode` methods declaratively in a Kotlin data class. I immediately reached for a tool I know how to use (lombok), but fortunately it didn't work (the way I understand it, Lombok cannot work with Kotlin). Fortunately, because now I know how to declaratively override `equals` and `hashCode`. I like Lombok personally. It eliminates a lot of boilerplate code, however it really shouldn't be used with Kotlin
Its fine used with other frameworks.
And I agree it being a bad language as I also prefer statically typed languages like java and c#. But Js with its librariers amd ecosystem just get things done, which is the goal at the end anyway.
Lombok, Spring.
Our clients never bat an eye at needing our Java desktop applications. They are deployed with java web start which takes care of installation and even automatic upgrading when a new version is made available. 
What about using a VI emulator plugin in an IDE? IntelliJ has IdeaVIM which is great. I am not sure if eclipse has a VI emulator.
Agree with the "roll into java". Jodatime, finally forced java to get rid of the crap that was before. Hopefully Lombok could be made into a nice JSR. Java 10 ? I realize there is massive emphasis on backward compatibility, but if java doesn't evolve fast enough people will move to Kotlin or equivalent.
I was introduced to it at my first day job and it makes life so much better. I've never heard of any of us running into any issues with it, or its interactions with other libraries/frameworks. And with the IntelliJ plugin, the IDE understands it perfectly. It makes me fear my next Java job, if the people there don't use Lombok, and/or are against using it. I'm worried that Java life without Lombok might suck.
[removed]
Use typescript :)
&gt;What kind of 3rd party components are you looking for? Well at the start of our application development process we needed a UI toolkit that is material design-ish and supported a dark and light theme. The only thing that came close to that was jfenoix but at that time it lacking. Tho to be fair I see it now improved a lot. Anyway we decided that it would be best to implement everything on our own. For comparison if the app was written using electron front we could have just used http://www.material-ui.com/#/ (and there are many competing). Other than that so far my needs are limited as our app is farily simple (for now) and when I want something I can just implement it myself. &gt;You don't need CSS frameworks with JavaFX Its kinda related to what I described above. By CSS framework I don't just mean something that gives you layout and resets cross browser issues but also something that gives a nice predefined look. There is the previously mentioned ever more getting better Jfenoix but speaking of amount and quality I would say the web technologies are richer in that regard. &gt;What do you mean by this? JavaFX has a very CSS like stylesheet syntax. It is super-easy. Its stuck in the CSS2 era and getting some components right without breaking them can be harder that it should be. (want to change the background of a textarea? well nope, you don't just target the textarea, you only have to have to target its internal pane, its other internal pane and make sure to cover all pseudo selectors on them!). But to be fair I guess you don't get hit with those issues if you don't make larger modifications. &gt;Are you referring to the WebView component? I have only need a web view once. Besides for that I have never needed one in a desktop app, is this a common need? We are able to get away with what its currently offers as we use to display email content but im still disappointed that when I tested in on modern sites like youtube it didn't worked. Anothrer issue with the web view I found is that it inherits styles from our custom css. (issue described here: https://stackoverflow.com/questions/44389116/make-webview-ignore-scene-css-in-javafx - the wrap it in a swing context answer is kind of working but it brokes drag and drop functionallity). @edit: fixing words :)
It kind of varies. I feel like the drag&amp;drop toolkits get you up and running really fast, but if you wanna do anything advanced it can get hairy fast. Granted, making html layout without flexbox and css-grids is quite awful. It also took some time getting used to. 
I'm guessing you wanted a structural equals() vs. the default that only compares the reference. How to do that is described here: https://stackoverflow.com/questions/37524422/equals-method-for-data-class-in-kotlin Edit: I just saw you know how now. I will leave this here in case anyone else finds it useful. 
TypeScript is a half-hearted Band-Aid over a horribly broken language. It's a joke compared to even Java, let alone cutting-edge languages like Scala. Scala.js is a thing, though. Maybe I should give it another look.
Clearly it should be: if (bool ? true : false) { return true; } else { return false; } 
I think this is exactly why people like it. Also, you can use whatever parts you like, and even disable the unused parts so they don't get used by your team. And of course, if it's still too much magic, isn't Google AutoValue like Lombok lite?
And true immutability, and default `final`, and value types, and better functional programming support, and right side composition without chaining (e.g. extension methods), e: and non-nullable by default.
11000 customers and counting.
None of which (other than Scala.js) add a real type system. Lol no.
jquery is deprecated. You people in this subreddit been living in a cave? Webdev isnt just html, css , js with jquery anymore. Its bigger now.
Spring, Lombok, Spock, moved my security stuff to Keycloak and quitted Jenkins in favour of Drone.
AutoValue, Immutables, Kotlin for pojos, theres many ways to get the benefits without the magic.
I've only been introduced to it about a month ago but I think it is pretty good. I guess it doesn't suit every use case but I like it
Nothing. Best case scenario it provides no value whatsoever. Worst case is a liability.
It's more fad-driven, I think you mean. Also, if you require JS to decently render static web pages, you are incompetent. Static pages do not need scripting.
@Data also breaks your JPA entities by generating faulty equals() and hashcode().
Yeah c# has some of these features baked in
it would be a shame to loose something like this to history, people have even preserved very early DOS versions, so the progenitor of Java definitely deserves preserving, ideally the source code too! 
Nothing! Plenty of people do. But "you can't go wrong buying IBM" will keep many institutions from swapping. In the interests of making the lives of programs working for such places more pleasant, I think something like lombok built-in would be great.
I like it because it simplifies my code and because I think that kotlin and scala are ugly languages
Google's AutoValue would be closer. I used to use it on Android projects, and it's a far better option if you can move away from the horrors of setters.
Yes, the agent is Eclipse specific. Maven and intellij do not require it. Either way, there is no difference at runtime between Lombok proceeded code or code you'd have written yourself. No part of Lombok is required once compilation is done.
so you say it tracks a variable's assignment everywhere on the stack? holy shit, really? that's worse than i thought. i mean, is great for development, but holy shit, one cant put that crap in production.
This thread is full of examples of things breaking because they're not compatible with Lombok. At least with Kotlin, almost everything will be compatible out of the box, and there are ways to force the few things that aren't to be.
It's not automatic, but most of that's there. See the tips and tricks user doc: http://help.eclipse.org/neon/topic/org.eclipse.pde.doc.user/tips/pde_tips.htm?cp=4_4
&gt;flexbox should improve things http://caniuse.com/#search=flexbox Its 2017 you dont need CSS hacks anymore.
Cool down. It is simply a null check. There's no magical _variable assignment tracking_. It's nothing more than what you would write yourself if you want to keep null away from your API innards. You put it in the boundaries of your API so that as soon as someone assigns null to something that should not be null they find it out earlier rather than later. You really are focused on bashing Lombok any way you can. What Lombok does is bringing good and proven patterns as close to the language level as it can while reducing _accidental complexity_ of having all that boilerplate code around in a source form. Sure, it adds a step to the build. Sure, the generated code can not be seen in the debugger. Sure you need an IDE plug-in with that. They are all cost you have to pay. I happen to believe that cost worth the benefit of less boilerplate. You don't. Fine. I get that. You really don't have to paint a monster out of Lombok simply because you personally dislike it. 
Try searching for 'Angular'.
http://www.vavr.io/ It's a immutable collection library (which I adore), it has almost nothing to do with this thread
To be honest, Kotlin does even more magic than Lombok. 
The boilerplate is still there, in bytecode. It's just source that has less of that. 
I would mirror exactly same sentiment back to you. The trouble with dogmatic geezers like you is that junior developers may listen to you and figure that once they have learned one way of doing things they can stop learning or adding new tools to their tool belt... Edit: But really, adding personal insults doesn't help anyone reading this thread with intent on learning more about Lombok, so let's agree to keep that to the minimum. 
We only use Kotlin for defining pojos. The rest is plain java, no one needs to learn any syntax beyond the above. It just compiles to java classes. 
The day, Project Valhalla with value types is released, will (hopefully) be a glorious one.
Since this is help with Java **programming** it should be, as the *plenty hints* on the page indicate, posted in **/r/javahelp**. Even worse is that just a couple minutes before that post, our *Automoderator* has removed another of your posts asking for code help. There it detailed that such questions have to be posted in **/r/javahelp** and yet you do the same again. Third time will lead to a ban from this subreddit. Please be sure to **read** and **follow** the [**Posting Guidelines**](https://redd.it/48eykt) there when reposting. **Post removed**: programming help
This is a thing people did: https://www.nytimes.com/2016/11/09/us/politics/hillary-clinton-donald-trump-president.html Doesn't mean is a smart thing. People do do dumb things. They don't do them because they're very smart.
Having used a ton of different frameworks I always tend to come back to Spring Boot. For me it's the perfect combination of "easy to get started" and "batteries included". I've used a lot of the 'microservice' frameworks and you always end up building / including a lot of stuff that Spring already did for you. 
&gt;are well elaborated bindings for lots of languages. …for Qt 4, which is dead, buried, and thoroughly decomposed. Qt 5 is C++-only.
To be fussy about it I expect it's the ECJ as opposed to javac which needs the agent, which both Maven and Intellij could be configured to use.
Every time I read about Lombok, I think of "boilerplate removal" libs for Java, hence I just gotta mention vavr (www.vavr.io) - also known as javaslang (they recently renamed it). Also, I have mentioned Immutables (https://github.com/immutables/immutables) which falls into the context of Lombok. So, imho not really off topic. But what I really think, switching to Scala is the way to go...
Why wouldn't you want getters and setters on a bean (not a spring bean)? What's the advantage of having a immutable class, and how do you persist changes to one if the id is immutable? 
http://eclim.org/
You have my sympathies 
And slow as fuck.
Turn in your two weeks notice today. Life is short. Don't waste it in projects like this.
When it first came out, I liked idea of it. These days, there are alternatives that I think are much better - like using Kotlin instead. You get all of the benefits of Lombok, plus quite a few more, and none of the downsides.
This deck is rubbish by itself.
I even already know what to say on my exit interview! Sadly I have to pay them $10k if I leave before January.
&gt; Glassfish 4.1.1 (it's still the latest, I think) Updated to 4.1.2 back in March: http://download.oracle.com/glassfish/4.1.2/release/index.html
&gt; Qt 5 is C++-only. PyQt has also support for Qt5 - so your thesis is a bit too strict 😉
I just went for it and started converting the lowest level classes I had, some domain model pojos with simple inheritance. It was stupendously easy, the only problem I had was that I wanted to use data classes, but they can't inherit properties.
Oh, Javaslang! As much as the code looks good, (re)naming libs isn't their strongest point... :) But yeah, I can understand why you'd mention it. If someones looking to modernize their Java, they'd probably want to use er, vavr, too.
Nice intersection between design and programming, keep up the good work. Please consider release the javaFX you mention in the FAQ. I have some fliewatuut here myself :) and the birdview could be handy to fix some of them.
What if the change was made before the commit?
Not sure what you mean. When I evaluated lombok it was for a project that was already using git and already had some IDE generated methods (getters, setters) alongside hand coded methods (equals, hashCode). Changes were tracked as normal. There isn't a way to make change without it being part of a commit, as per the definition of source control. Honestly I really wanted to use lombok. I wanted to avoid the boilerplate. But we were also heavily using JPA metamodels so the incompatibility between lombok and the processor linked above made lombok a non-starter, at least for beans.
The name makes more sense when you remember their tag line is "Turn java upside-down." Because that's literally all they did with the name. It's not a good name.
Eh, if I'm going to start generating data classes, I would rather go ahead and jump on the Kotlin bandwagon.
H2 is nice to have for integration tests and local development
Highlights?
TL;DR; Design your structure with OOP, implement with FP as much as possible. 
X is dead articles are annoying. FP, like OOP, is a tool. If it makes sense, use it. If not, don't. With concurrency coming more and more into flavor, FP will naturally as well. We will also see a stronger trend in immutables in OOP (one of the strongest ideas behind FP)
Not being automatic is the problem. I want my IDEs to do the repetitive task, and also I want to remove the need to remember to do the repetitive task. 
I'd say there's basically no chance
I took a look at the PostController example. Could you explain how this is easier/more effective than creating your controllers with Spring and Jackson, because it didn't appear that it is.
Um, those are languages that run on the JVM, no?
Emacs, ant, log4j, JFreeChart, commons-math. My hobby projects are libraries for text-only (e.g. ssh-able) systems and some science stuff. 
Wow, the fact that he gets mad at you makes him even more incompetent than I thought. I hope you can find some better people to work with.
`JComponent. repaint( ... )` schedules an object to be painted, and is non-blocking. `JComponent.paint( Graphics g )` does the actual rendering, and is blocking. To get the time it takes to render a component, you could override `paint( Graphics g )` to include timing info. So: @Override public void paint(Graphics g){ long start = System.nanoTime(); super.paint(g); long end = System.nanoTime(); long nanoseconds = end - start; } You could also use `System.currentTimeMillis()` if you don't need nanosecond resolution. Also: why the hell don't code fences work in programming subs?
ts?
I'm trying to build a library program. It should have 5 classes: Main, Library, Branch, Book, and Customer. Somehow the library should contain a list of customer, the customer should contain a list of books, and the library should contain a list of books.
University 0 chance with udemy
every CV with a certification we have a big laugh and we grill them very hard in an interview, harder than the others and then say 'what a bad dev he was'
Did you break out from r/SubredditSimulator?
&gt; carpenter and carpets are totally the same thing, right? No, you silly. A carpet is a small carp; a carpenter is someone who makes carps, usually by whittling down larger fish. 
Java is like Javascript the way cars are like carpets.
Flexbox isn't intended for complex layouts. It is intended to layout items in a row or column. You can indeed achieve complex layouts by nesting flexbox layouts in different orientations. However, this is a hack because this isn't what it is intended for. The situation won't be improved until the CSS Grid spec is complete and has wide browser support, then CSS Grid+flexbox should finally bring some sanity to web application layout. 
Management prowess such as this means only one thing: the boss is a product of the'90's. So, in this instance OP doesn't have to worry about their boss reading this thread... Their boss has recently run out of CDs for free AOL hours and can't connect to the web. I'm sure they can't wait to get back to Geocities, but that'll have to wait till tomorrow; mom needs the phone.
&gt; Could you explain how this is easier/more effective than creating your controllers with Spring and Jackson Play Java is using Jackson under the hood, but it puts an asynchronous non-blocking API on top of Netty -- what's called "reactive application" but essentially means "CompletionStage&lt;Result&gt;" where you're getting a promise of a result back and the server handles the threads under the hood, and looks roughly the same as Spring (or Rails / Grails / etc.) Play can do around 60K requests a second out of the box without special tuning, meaning that you don't have to spend lots of money on hosting, and get more out of every instance you do host.
Are you sure that you just aren't writing the client-side with JavaScript with a Java web service back-end? I don't have all of the details of the project, but wouldn't assume that the manager is wrong or dumb. He may be trying to let you figure it out. It is an internship after all...
This. I would be willing to bet OP doesn't fully understand the technology stack the company uses. Especially when you consider he's a first day intern. 
I have a similar experience with my current manager. He wanted to assign me web application project developed with JavaScript since i have Java experience. When i told him they are different, he was shocked but at least polite. I think you are Egyptian. My guess is based on your username. If not ignore rest. Your boss matches arrogant, ignorant Middle Eastern manager stereotype. It is unfortunate meeting this type at your first intership. But get used to it.
For me the red flags are: 1. OP is an intern 2. Experienced manager knew exactly where the JS tutorials were online 3. Very few shops build Java GUIs anymore.
Yep! I use angular on the front-end and interact via Rest APIs. OP might want to take the opportunity to learn some JS instead of assuming he knows everything on his first day. Lol. 
Honestly, I think this is exactly what OP's task was supposed to be, but he simply misinterpreted it. Or OP is from year 2000 since nobody writes UIs in Java anymore.
Also keep in mind... sometimes you are the numbskull. If you have never made an error or misunderstood something fundamental sometimes that means you have been wrong and acted like a dick. It can be the hardest thing to do but trust me everyone makes mistakes.
So you're from 2010?
Types in TypeScript are structural, not nominative. If you have an interface with an `apply` method, for instance, then any object with an `apply` method (with a compatible type signature) is an instance of that interface—even if one of those objects was never intended to be used as an implementation of that interface. This makes the type system mostly useless. Scala has *support* for structural types, but it mostly uses nominative types.
Vaadin and sencha are still going strong. We (3 devs) just build an algo trading platform from scratch in 4 months. For data rich guis where styling doesn't have to be fancypants, its great. 
High schoolers can get internships too sometimes.
If you say so.
&gt; "[It’s] like the new Lotus Notes but for the modern era" (I'm gonna say the same thing i said on /r/node) Hahaha. No.
Sounds like you are not a smart person who most likely compromised their work relationship on the very first day.
I don't think you can even compare this to BeanShell, apples to oranges
This sounds like something that would appear on The Onion.
I wrote a processor that got around that problem entirely (on javac at least) - you type cast the javac task to it's implementation and you then can attach a listener on the compilation process which tells you about the process So I just waited until the last possible moment (after the lowering of language features) and then ran all of my processing. Any other law-abiding processor wouldn't matter at that point. It was surprisingly simple in that case, I dont know about lombok because a lot more goes into that project (ecj, etc)
As someone who was forced to use Lotus Notes in the past, it was a terrible program. If they were comparing NodeJS (or anything JavaScript based for that matter) to Lotus Notes, then I'm not necessarily sure that they were *wrong*.
I'll admit I've never used NodeJS, but from what I've heard from developers who have, it has severe scaling issues.
Clickable headline. He didn't say that Node would overtake Java in terms of market share, business investment, etc. He said that it would overtake Java in terms of "number of users". Which isn't far-fetched. Java is where the money is at career-wise, for serious professional development. But every 12-year old knows JavaScript, so Node probably has more students and hobbyists doing personal tinkering and writing toy apps.
(I'm going to almos quote myself, but who cares) List of things I can remember right now, (in no particular order) that will overtake Java: * C# * Ruby on Rails * Python * Scala * Node All of them were being adopted at a extremely fast rate, all of them could replace java, all of them have companies with extremely successful stories that looked like: '10x less lines of code switching from Java to xxx'. Most of them eventually end up getting a slice of Java's cake, but a small slice. Why? IMHO, dynamic languages tend to become problematic when your application becomes bigger, time goes by, and the original authors are not around anymore. See [this](http://classicprogrammerpaintings.com/post/142737403879/programmers-at-work-maintaining-a-ruby-on-rails). That explains the lack of success of RoR, Python, and I think eventually Node, in killing Java. C# and Scala had other reasons. C# was too expensive, and too locked inside the Microsoft world. They are working on that, maybe they make it. Scala requires smart people to understand every feature the language has, and even smarter people NOT to use them. Also, half Scala people are trying to make it Haskell for the jvm. Now, I'm thankful for the existence of all of them . All of them injected new life into Java. Thanks to RoR and Pyhton we have frameworks that are not a horrible mess of XML (remember Struts?) Thanks to C# and Scala some bits of functional programming have entered the Java world. I still envy C# properties and Scala type inference. And I think node.js is pushing forward a nice asynchronous way to do things. RxJava now and Spring 5.X in the future will make that happen in the java world. But replacing java? Eventually is going to happen. I don't think any language/framework will do it very soon. That said, I think it is kind of sad that so many good ideas came from other languages... 
This is an article I wrote months ago and it listed some of the disadvantages of Nodejs. I hope it will help people to make decision between Java and Nodejs. https://networknt.github.io/light-4j/benchmarks/nodejs/ 
On the plus side, the fact that you knew enough to facepalm means you'll be CTO in no time! Not always, but sometimes being a big fish in a little pond is a great career move. For a while anyway. 
[removed]
Sure we do. Proud JavaFX dev here.
Not necessarily, but making a class final has nothing to do with immutability.
I thought that was the whole point. The consultant kept telling me we had to convert to node and I looked up why and it kept saying that Walmart handled 50M requests a day because they used Node and all of a sudden IO blocking wasn't an issue. (?) I asked the consultant if anyone, anywhere, in our organization, had had a failure to due to IO blocking and he looked at me. We went with node. 
That;s the link I found, I guess if you don't want to register you might find the articles on their site without any wall. they produce a lot of free content
"We are now at about 8 million estimated users and still growing at about 100 percent a year. We haven’t passed Java in terms of users yet, but by this time next year at the current growth, we will surpass." So he thinks nodejs will have 16million users - whats his definition of a user. According to oracle, java has 9 million users circa 2012. Thats my empirical objective analysis, as someone who hates JavaScript.
Is introducing typescript a possibility?
Indentured servitude 
&gt;I started explaining to him that Java and Javascript are completely different things 1st guess: fake story 2nd guess: you were way to eager to jump on this and stroke your ego.
This crap mostly comes from people not using java
They said that about Python too....
I had the same experience with a Java 5 project being updated to Java 8. A few global search/replace and the project compiled and ran, passing all tests. We had so many problems with the front end just trying to update one library (which had a massive cascading effect of upgrades) that we just gave up and rewrote all the JS from scratch.
"This will be the next WoW killer". 
You may appreciate that one of my clients is a company run by open-source enthusiasts. They run all linux desktops and servers, open office, etc. What I remember most about them is they had this one server with some strange hardware and software problems; it locked up all the time, programs were always failing for seeming random reasons. Guess what they set the hostname to? They named it "windows". :P
Cool project though :D
Can't see the source in the article but I assume it's based on this survey: https://nodejs.org/static/documents/2016-survey-report.pdf So you're looking at a self reporting subset of the node community vs a (survey?) of maven central users. I can imagine that the responses rate of node users is much higher than java users due to the relative maturity of the technologies. This could skew the numbers significantly. 
Java (like SQL) has been on the verge of being rendered obsolete by [ random alternative here ] since decades.
experience rules everything, if you don't have that, you will have to demonstrate in coding interviews you're really really good. I don't know what the fuss is about portfolios, we don't care about that at all, it's the interview that counts and the whiteboard/algo/coding questions
It's really hard for any language to gain critical mass. Early and fast adoption is often not enough for long term sustainability. It's good they exist to keep Java evolving though.
&gt; Certification is the safest way to "proof" your knowledge. No idea why this was upvoted. Memorising Java trivia does not make you a programmer. Language certificates are completely useless as proof of being a 'developer'. I work at a small consulting firm specialising in experienced Java devs and the Oracle Java certs we really don't care about at all. 
Surprised no one's mentioned JRebel. Price is a bit steep but the productivity increases are immediate. Save and reload - like doing development in a dynamic language without leaving all of Java's benefits behind.
Also, I think fast adoption is misleading metric for long time success because fast adopters of language n will move fast to language n+1. You need to convince slow but responsible people if you want your language to stick around for a while
Excellent, thanks!
Perfect, thank you!
&gt; I know Java gets a lot of crap for never actually removing deprecated functions, but to some degree I understand. Some of that software is going to be around for decades. True. No one wants the baggage around unless it is there to help them. The last time I needed to upgrade a lot of dated dependencies in a Java project I budgeted a lot of time to find and fix expected breakage just due to the scale of the change. In reality it was about the most painless thing I could imagine. My NPM based projects, on the other-hand, will go from build passing to build failing without any source changes on my side just by letting some time go by. Yes, version numbers could be locked down to exact versions, but who is going to check for security fixes on the half million packages they are bragging about having?
I think dart never got to the 'we are killing java' part. And golang was supposed to kill c, and ended up attracting people from python. I'm not seeing it as a java-killer yet, but maybe in the future, with generics/templates/something... who knows? 
Those billions of lines don't need to be touched. If the groovy or lombok way of implementing getters &amp; setters was incorporated in Java (provide them, but back away if they're already present), I would be ecstatic. I recently watched a talk of Brian Goetz ( https://www.youtube.com/watch?v=ROL58LJGNfA ). He basically says there's no shame in copying from other languages as we all want to become better programmers.
Well that is no small feat IMHO!
I'd avoid the [Apache Commons HttpClient](http://hc.apache.org/httpclient-3.x/), which is long EOL'd, and go with it's successor, [Apache HttpComponents HttpClient](https://hc.apache.org/httpcomponents-client-ga/). It's likely this is what you meant, since Unirest uses HttpComponents, but googling for "apache commons httpclient" may lead some astray. 
I agree with your point.... have you ever tried Kotlin? What do you think about its future? 
Another language zealot preaching that his favorite language will overtake a different popular language while assuming the other language is stagnant and not making its own improvements. 
There are various scaling axis. NodeJS fails all but maybe horizontal scaling (as any other) or downscaling to simple webapp size / time to market so to speak.
I'll go ruby over nodejs anytime.
I'm biased because it's my baby, but I recommend Play WS: https://github.com/playframework/play-ws It is a pure async wrapper around AsyncHttpClient, which is in turn a layer on top of Netty. It uses Akka Streams for streaming input and output, which means Reactive Streams compatible. And I just put in a caching layer. It's used internally in Play Framework, but you don't need to install Play to use the standalone version. The documentation on how to use it is here: https://www.playframework.com/documentation/2.6.x/JavaWS 
I've tried Kotlin, I liked it. I think they are making an effort in keeping it 'a better java', while Scala is moving too deep into the functional world. However, in the long term, I'm not sure how can they manage to remain relevant if Java keeps adding stuff (a glacial pace, ok). In java 10 we are probably going to have value types, flow typing and pattern matching with destructuring (and maybe even automatic pojos). So the only big advantage is going to be null safety. I like null safety, but I don't think you can convince people to switch if that is the only selling point. Honestly I hope Java the language gets frozen at some point, and Oracle bless some other language as a non compatible java successor, because the infinite retro-compatibility is becoming a too high price to pay. Kotlin could be such a language. (on a trivial note, I don't like the `a: String` syntax at all, but people seems to like it, so be it) 
Crack Java Interview Questions.
Completely meaningless click-bait title since the actual statistic being used, its definition, and its methodology isn't described at all. Good job! Someone click on the ads on that web site since that's all they actually care about.
We're using Java8, Ratpack, RxJava, Jooq/Postgres, Cassandra to create RESTful web services and it's fun again. My team are having a ball and knocking up services very quickly. But, the issue is that they are well written, easily maintainable, backed by brilliant tools etc. And, Ratpack running on an 8 core machine using 16 thread loops, runs rings around Node.js. We're getting absolutely insane throughput, utilising all the CPU % making them very efficient.
I don't think the code that is already written in Java is suddenly be thrown away.
Not really specific to Java but SmartGit.
Wtf yo
Thanks for the detailed response, I really appreciate it. 
Yes but only so long as it is singular purpose, "for readability". Lambda to iterate a list, ok. Lamda to iterate a list, produce a new list, iterate that list... unfortunately, nope. I love that shit tho. Makes everything so much easier. 
I agree with you on this. All of my gripes stem from the fact that I am used to IntelliJ features. * When I do not see the signature of the method the lambda is taking the place of, I do not know the types of the parameters and I cannot ctrl+b or ctrl+click into the class. I have to press ctrl+p to see the parameter that the lambda is and then navigate to that class. Then I can ctrl+b into the classes that are the parameters for the interface that I am lambdaing. * When you put a breakpoint on the line with a lambda, you have to choose if you are breaking on the outside or inside the lambda. Fine. But then if you come back and see that breakpoint, it isn't obvious what you chose before. The fix for this is that there is a small lambda symbol on the breakpoint, which works but is less clear than separate lines. It's not as simple as less lines of code == easier to read. It's really about how much cognitive load reading the code takes. If you are reading code without lambdas, you are already filtering out the useless signatures so it doesn't matter if you are reading code with lambdas or without. All this being said, I am mostly ok with java 8 method references. Those make it easy to jump to the method that is being referenced and see the full sugarless syntax of a method. If you aren't interested in the implementation of the method reference, you read the *well named* method name and move on.
Try control + q when on the lambda expression. IIRC, you'll see the type that way.
One of the times you learn how a common language word can interfere with people finding something (at least while we still use keyword based searching). I don't know my Java history that well, but you can figure out who the most appropriate person responsible for these specs at the time is, it wouldn't be unreasonable to email them and see if they can give you copy or point to towards one (My guess would be Gosling, but he's like a person with an email, and you can contact them directly). It's pretty common thing to do for finding documentation and details like in the computer science academic space. You might run into issues of IP, licenses, and all that since FirstPerson Inc (or their successor) might have some license agreements with that person/author might be limited by. I doubt there's really any business that'd care about stuff that old, but depending on the situation the author might be careful (or might not think it's problem given the age).Luckily you're clearly outside the patent window so there's nothing like that to worry about. Other thought is that that company at javaspecialists.eu still hosts that Oak language specs in that /archive/files/ location. I'd bet the document you're looking for might be in the same folder, possibly downloadable if you knew the right filename. While you could get lucky and guess, you could contact them and ask. Being a business as opposed to a person they are less likely to want to help you find something especially just for the sake of history. Good luck. 
&gt; But i dont like this recent drive to bolt functional constructs into imperative languages. Well put. Each language has its strong points and think a language suffers when the designers try to fill every niche. When OO was hot, a number of language maintainers tried "bolt" OO into languages that were never meant for that. The new hybrid languages I saw never really took off as much as languages built from the ground up to be a certain way.
Are you using the proper Scala idioms though?
I'm learning to get there. Only 2.5 months in at this point, mostly doing spark for the first two, and now a play api to run the spark stuff and process the results for a web-app frontend. I definitely see how scala suffers from a perl problem (there are so many ways to do things) but thus far I like it.
I've never used SWT, but from what I've heard, it's even worse than Swing. I take it you disagree? If so, why?
At the time, swing had its own look. SWT uses widgets from the OS so, it fit better. Another thing, for a few apps, I used GCJ to compile to native. It was pretty straight forward with SWT, just had to add the so's/dll's to the package. I haven't done desktop apps in a while so, I don't know the current state of things. I primarily do server dev.
Lambdas and Stream/Consumer API are the bees' knees. 
Stuck on JDK6
I see them from time to time but we don't go out of our way to use them.
That must have been a while ago. Actors haven't been in the Scala stdlib for a few versions now.
I pulled it from play libraries
The company that I'm at (and indeed most Java companies I've been at), they say they want it, but getting product out the door is paramount. And the deadlines are oddly always short...
Streams and lambdas are powerful, but you should try to keep it simple and never do something like `stream.filter(element -&gt; { // a lot of lines of code here })`; try to never use curly braces inside a statement.
We are doing a lot of asynchronous stuff, and lambdas with RxJava are used everyday. We had a new developer come to the team from an horizontal transfer as his previous project went into maintenance mode. He didnt like our code style initially, but after six months he has become an evangelist...
But if you use anything that throws an exception, you don't have a choice unfortunately :/
Where I work everything is allowed as long as it makes sense to use. So we're not even limited to Java.
Create a method, deal with exceptions there and call this method with one-liner lambda. Easy. 
It depends
On what ?
I don't want to do pre-8 projects anymore. They can pry my lambda's and my streams from my cold dead hands!
that's a weasel statement and a half. Sample of one, I work at a "big" company, and we like lambdas. Java is typically the gread read language, compared to perl, ruby etc. Lambdas change this, it's definitely possible to write very unclear code, but that just means you need policies, code reviews, best practices. Banning lambdas is a silly solution.
Exceptions and lambdas are not a happy marriage unfortunately. You could always wrap a method that throws a checked exception in a method that throws an unchecked exception I guess...
&gt; and I don't really find it easier to read When generics were introduced, this argument was made quite often as well. People argued that the explicit type cast helped them understand what a particular list contained: String string = (String) list.get(0); In hindsight, that's so silly, of course. Generics have greatly improved the overall Java experience, and so will lambdas. [Just don't overdo it ;)](https://www.youtube.com/watch?v=Dun8ewSeX6c)
Yes, because they are generally much more high-level abstraction of the business logic and thus for anybody revisiting the code, it is much easier in comparison to nested loops. Often people tend to forget to document **why** the business code is that way though. Could you post an example what you find difficult to read in comparison to the imperative implementation?
I don't really understand why people take the time to write articles like this. It starts off with the inflammatory statement, "the programming language that most seem to despise with great passion". I spend a lot of time at Java conferences and don't see many people despising what I and others talk about. The article is littered with minor factual inaccuracies and doesn't really help anyone new to Java other than showing them how to write a "Hello World" program and a program that reads a line from a file. There are so many *good* resources to help people learn Java I just don't see the point on expending time on writing an article like this. Which then leads me to wonder why I bothered writing a response to it...
Totally second this - but you mean it's not written by a clickbait bot ? Maybe the bot code itself would be tremendous piece of science. Please note that the site has a 4 month only history - either a well-intended newbie or a too-frequent clickbait/bookseller 
Thanks, I will follow the MOOC you mentioned.
&gt; They have adverse effects on memory, GC, and overall performance for very little if any readability gain On recommendation of someone in this thread, I am following the Oracle MOOC on Java8 right now, and there they mention it is easier to take advantage of multiple cores and cpu's to solve problems. So maybe it's a performance gain if you use them?
&gt; that's a weasel statement and a half. and that is a childishly gratuitous insult. &gt;Sample of one, I work at a "big" company I first heard of the issue at a JUG I attended hosted by a high powered company in my area. The presenter reeled off a list of big and well known companies who feel that the new Java 8 functional programming features make large projects hard to debug. I have seen other companies mentioned in articles here and there since. I don't have a didactic memory. If you do congratulations. For the message was enough.
Retrolambda or you can wait for the next Android Studio release which will be with lambda (api 9 onwards) and streams (api 24 onwards). 
Not quite. It's like asking "nail or screw?" in a screw-forum.
Play is built using Scala. That might be problematic if you want to look up framework internals at some point. There is a Java API, but for a long time it was treated with low priority. The Java API is not idiomatic and you will encounter a lot of "unreadable" calls like `bind(java.util.Map&lt;java.lang.String, java.lang.String&gt; data, java.lang.String... allowedFields)`
Also consider using something like [OkHttp’s MockWebServer](https://github.com/square/okhttp/blob/master/mockwebserver/README.md) to test your HTTP calls. Use it to confirm that your client responds appropriately to both success and error responses. Because MockWebServer is a real (but very limited) webserver you can use it to test whichever HTTP client you choose. It's small, simple, and fast and works even in unit tests.
There is a peek method defined on Stream...
My company does encourage **reasonable** use of Java 8 features. Thats means something like: * Remove old Guava equivalents when encountered * Prefer method references over lambda. Though most times it is no issue unless a lamda one-liner needs to be debugged often. * Use Streams when transforming data in collections and the Stream statement is short and simple (+- 5 chains). * Stream`flatMap` etc. only if the use is crystal clear. * No blocks / if-else / exceptions etc. inside Streams. * Rarely return Stream, unless private shared methods. * Optionals only inside Streams or as return type when the value returned is likely to be null and could be handled with an `ifPresent` on the callers side. * forEach only if looping over a single statement * Rarely ever felt the need to use Function / Supplier / Consumer etc. Code can immediately become more complex. 
So you find: foo(new Function&lt;String, Integer&gt; () { @Override Integer apply(String s) { return s.length(); } }) Easier to read than: `foo(s -&gt; s.length())` or `foo(String::length)`? Maybe you just aren't used to that syntactical pattern, but I honestly can't fathom anyone preferring the former over the latter.
I occasionally have to write for 1.4.
Looks like poorly configured eclipse autoformatting. Many eclipse developers don't know about the "Never join existing line breaks" option. Also, recent eclipse versions ignore this setting under certain conditions. See here: https://bugs.eclipse.org/bugs/show_bug.cgi?id=474362
&gt; foo(new Function&lt;String, Integer&gt; () { I've rarely encounter such code in the first place. It wasn't even in there before Java 8. Function's meant to be used together with lambdas. `Runnable` or `ActionListener` would have been a better examples. But that's because they is are perfect example of applied functions and where functions make sense, lambda's **can** make them more readable. Where functions make no sense, lamda's **can** make code less readable. 
We have performance criteria for our Java servers and no one is going to change perfectly acceptable code for something slower.
Because the anonymous class is CLEAR and the Lambda garbage is NOT CLEAR ... that's why. The former, it is CLEAR what an "event" instance is ... it is an Event type. It is NOT CLEAR in the latter case, it's just a C style structure pointer looking thing and the word "event".
I only just started learning Java 8, because despite it being my favorite language, school always got in the way of me taking the time to learn it. I can't say what's faster because I haven't looked into that.
I actually mainly use Eclipse and I didn't see anything similar available in the market place.
All of the performance comparisons that have been made
What type is s? Your example doesn't show it. That is the problem with Lambdas. Method references are even wackier than that.
i'm a crotchety old Assembler, BASIC, C, C++ (then OO C++), then Java developer, who took a side trip for a few years into C# before it got funky (select from a list? really?, await here and there and everywhere all strewn threw the code? really? c# generics, readable? really?), version 2 and earlier. Lambda calculus? No I don't. I do have programs in production in all the languages I mentioned above at a variety of businesses across America and the world, some of them are the largest, most notable high tech companies of our time. But...Lambda calculus? Nope, never got into it. Perhaps the world needs a language that is FP based so those who like the FP stuff (being polite) added erroneously in Java 8 will have a place they can go code and be happy and let those of us who want to code in a wonderful language like traditional OOP Java will also be happy and let businesses of the future decide whether traditional thinking or mathematics thinking is best for business. 
Maybe it's an issue of domains. Our code pretty much just did conversions of one kind of data to another. For those cases, higher order functions and Stream manipulations like map, flatMap, and filter are definitely the way to go.
The type of s is String. The Function interface isn't exactly arcane. If you really, really insist, you can even write `(String s) -&gt; s.length()`, or even `(String s) -&gt; (Integer) s.length()`, which, again, is better than an anonymous class. I guess you also don't like `ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;()` since the type of the ArrayList isn't shown. &gt; traditional OOP Java can be read, without an IDE, without touching the keyboard and it is clear what the piece of code you're looking at will do Oh really? What does this code do `foo(bar())`? What does foo accept and what does bar return? This isn't even OOP Java; it might as well be C.
Same here, we will move to 1.8 in a "few months".
Just wait if you learn Scala :)
Fine. Make the type explicit. So what? button.addActionListener((Event event) -&gt; { // A lot of lines of code here });
marshaling to Json if that matters
Who cares? The code is completely clear without knowing the type of s. 
Pfft. Nail all the way. Always.
You may want to look into code formaters that are lambda and stream aware... as vytah shows below it's a lot easier to read and understand when stacked rather in-line.
Lambda calculus isn't a "thing you get into". It was formalized in the 30s and provided the basic structure for early programming languages that evolved to encompass all the wonderful styles we have today (declarative, imperative, blended, etc). You may be old school, but you don't know the basics. You sound like a nightmare to work with. Also, who gives a shit what code bases you've committed to? Just because you slipped through the cracks into a decent company doesn't magically make you right about everything.
I'm looking forward to your feedback! :)
Before java 8, if I wanted a single function with no associated members or state, I still had to create a class, and a method, and then call that method. All lambas allow you to do is do this same thing but skip the class. It also allows us to treat this function like a first order object - to return it from methods and assign it to variables. How is this bad? What does it hurt?
I'd love it if IntelliJ tried to go to the right class for a lambda parameter. That'd be amazing. 
The only redeemable features Java has are the things Java 8 brought to the table.
V8 is like an order of magnitude faster than Ruby, though. We only use Node because it's fast for a dynamic language.
It's like anything, though. There are *so* many garbage Java developers. They might make more money than a garbage webdev, but I make more money than they do because I understand how to tune and profile not only JVM but also V8. We use Node for use-cases that actually make sense, and it's been really great for us. Right tool for the right job, etc.
I'm not suggesting it in every situation. Only when it isn't entirely obvious what the person is doing. 
Not disagreeing with you at all, but I have co-workers who bitch and moan about really simple one line predicates and method references. My point is just that learning good functional style means knowing when the pithy one liner is worth it and knowing when `.filter(isActive)` is more readable. :) 
The optimization could also happen after the bytecode, in the JIT.
Well then I violently agree with you.
This sounds like a bad idea
Faster in what? If all you want is speed why not use C++? Rich Hickey said: "Programmers know the benefits of everything and the tradeoffs of nothing", I say the tradeoff of using node because it's fast is overlooking the reason of why use it, it only fits a specific use case when a non blocking event loop is needed.
This is useful if you need to modify content which is not owned by you. In our case, we had to modify enums in Minecraft to add additional states to reflect the modded Minecraft environment.
Working with certs can be a pain. A utility program I wrote and run on my home system for accessing my site worked only on Oracle's JDK until recently; I tried OpenJDK again and now it works. I tend to use the Apache libraries for Http client work.
Screw is more advanced and versatile.
&gt; Working with certs can be a pain. Working with certs is ALWAYS a pain. FTFY :) &gt;A utility program I wrote and run on my home system for accessing my site worked only on Oracle's JDK until recently; I tried OpenJDK again and now it works. Uggh. . . I feel your pain. For me one of the biggest headaches is the every OS, language, tool, etc handles SSL certs differently. The code I'm working is partly a port of a Python tool. The client cert/key handling is trivial in Python. 
I guess you could embed chromium? I don't think there's a good way without some sort of pitfall. Eg. Extract YouTube IDs and get MP4, then you wouldn't have the player and could break over time. Or using something like chromium is a hassle with getting it all to work and deploy well.
**Loop fusion** In computer science, loop fusion (or loop jamming) is a compiler optimization and loop transformation which replaces multiple loops with a single one. It is possible when two loops iterate over the same range and do not reference each other's data. Loop fusion does not always improve run-time speed. On some architectures, two loops may actually perform better than one loop because, for example, there is increased data locality within each loop. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^] ^Downvote ^to ^remove ^| ^v0.23
Is chromium similar to java's webview? Because the webview works for everything, except for youtube videos. I read on a stackoverflow that it had something to do with the updates youtube has had, and so webview just no longer supports it. And also say I wanted to watch a youtube live video. You wouldn't be able to grab the mp4 till the stream is done, and wont be able to watch it live.
Because Lambdas and Stream/Consumer API are the bees' knees. 
I upvoted you because i think you are right. I don't have very good mechanical sympathy for java streams yet. I definitely need to do more testing with them. It's the lazy eval that always throws me off and how it interacts with various calls like flatmap.
It isn't a real world example. Like i said parallel streams work better in example and theory than in practice. Once you have to start dealing with thread pools and exceptions and concurrency and other messy real world subjects then the imperative way starts becoming more straight forward and perform better. And if you are going to a database you wouldn't do that. You be making a request per id. In a real app you would want to build a larger query into a stringbuffer not use parallel streams.
If you don't marshal an object before sending via ActiveMQ, Camel is probably serializing it for you which is just a shitty version of marshaling. Whenever you need to share data across processes, you need to marshal it into something since you can't just send a pointer or reference at that point.
you could, if nothing else works download the video through livestreamer and work with a local copy
Except that the person you're replying to seems to be bluffing. Since he doesn't have an answer for a simple real world example where two ArrayLists are used for iteration and sorting, and can't give a practical example of his own either. https://www.reddit.com/r/java/comments/6j55tz/are_java_8_features_like_lambdas_encouraged_in/djd1jwb/
This is the stupidest thing I have ever heard. 
I wish the sample app provided was an actual sample app not pulling the whole wildfly stack, just so I can get the essential content.
You can get direct streams from http://youtube.com/get_video_info?hl=en&amp;video_id=&lt;video_id_here&gt; You'll need to parse out the links; they start with "url_encoded_fmt_stream_map=", however, they are URL encoded. Also, getting a link with "ratebypass" (afaik) will allow the video to be downloaded ASAP rather than streaming it in little bits at a time. Do note that those links are generated on a per-IP-address basis and do expire. However, the requesting IP doesn't need to match the actual IP that is viewing the video (or so I would assume after having it work on 2 different servers in 2 radically different locations)
Bluefi is either woefully wrong, misinformed, or trolling. I'm guessing trolling.
So with a ctrl+f in the file for youtube, I see 35 results. What exactly would I have to parse? And so the thing is I wouldn't want to download the videos because that would pose an error if I wanted to stream youtube live videos. 
Yea probably true, but who knows. Maybe he's trying to just learn more about java like the rest of us :).
Plenty of apps embed them, if that's what you want.
So yes you can request video ids, but they don't let you pull the videos themselves through the data API. And that's the issue I'm running into though, when I try playing it through any Java web libraries it keeps giving me a try again later error or something. And for gui I'm using Javafx, not jframe, but I don't think that should make a difference right?
But that's the issue I'm running into, how to play the videos once you get the links. So i'm not too knowledgeable about url decoding but essentially you end up with a link to the video right? It's then how I play that link in Java that I'm getting an issue with. Because the usual solutions I found from googling are from like 2013, and no longer work with the new YouTube. Lol and geez that sounds pretty frustrating. And I feel like since everyone is used to at least 720p, I wouldn't want to restrict to 480 or 360 as a work around.
Apps like what? I tried googling around and checked stack overflow but couldn't really find anything. A lot of the apps are for embedding than into a website or something like that.
Pass the URL to a media player. On Android you could use ExoPlayer or built in MediaPlayer. Not sure of your options in plain Java, but I doubt you want to write your own.
Got a repo somewhere I can look at? Not nearly enough context here to make a call on whether this makes sense. 
Chromium would definelty be much more up-to-date than Java's Webview. It'd definitely solve the problem. 
[removed]
bad code is always bad code no matter in which fashion you program it. I have seen code like using .map(this::addTaxes) and in this method they subtracted. But I think functional programming forces you to think about what you want to program and not how you want to program. From the business logic perspective you should not care about if you use an `ArrayList` or a `LinkedList` as your implementation since the logic is based on a `List`. 
&gt; In java we have enum types, they might be great to describe some constant stuff, like days of week. But unfortunately some people use them to describe something that might change, like types of users, types of monsters in some game, etc. And this is just wrong, enums should be constant, they should never change or break. Sure they can change or break. This is a versioning issue. There is no difference to adding an enum value and adding a method to a class. 
out of curiosity, what are these things 
Webview works for me. package sample; import javafx.application.Application; import javafx.beans.value.ObservableValue; import javafx.concurrent.Worker; import javafx.beans.value.ChangeListener; import javafx.scene.Group; import javafx.scene.Scene; import javafx.scene.control.ScrollPane; import javafx.scene.web.WebEngine; import javafx.scene.web.WebView; import javafx.stage.Stage; public class Main extends Application { @Override public void start(Stage stage) throws Exception { stage.setWidth(400); stage.setHeight(500); Scene scene = new Scene(new Group()); final WebView browser = new WebView(); final WebEngine webEngine = browser.getEngine(); ScrollPane scrollPane = new ScrollPane(); scrollPane.setContent(browser); webEngine.getLoadWorker().stateProperty() .addListener(new ChangeListener&lt;Worker.State&gt;() { @Override public void changed(ObservableValue ov, Worker.State oldState, Worker.State newState) { if (newState == Worker.State.SUCCEEDED) { stage.setTitle(webEngine.getLocation()); } } }); webEngine.load("https://www.youtube.com"); scene.setRoot(scrollPane); stage.setScene(scene); stage.show(); } public static void main(String[] args) { launch(args); } } 
Sure the biggest statistic software does: SPSS an it looks jank and is completly unoptimized but you will pay out of the wazzo for it because ibm
If the certs and made correctly with well known authorities they generally work out of the box. If you don't care about the security aspect you can also trust all certs fairly easily. I would only do this if you are scraping websites or something along those lines and don't care about the security. Never do that when using an api you write to or might be sending sensitive data.
Alright cool, I'll check it out. Thanks!
Haha idk man, I spent hours trying to find a method that would work. A lot of the stack overflow answers didn't work anymore, so I wasn't too sure.
Yea so it opens up youtube fine, but it doesnt let you play a video. If you try clicking on something the video will give you an error.
Oh you're not on Android? That changes things indeed... WebView term is more known for Android than JavaFX or whatever you're trying to use then.
Use IntelliJ IDEA instead 
The pure git solution is: 1. Remove the files from the index. 2. Move the files to the new location. Do not update references! 3. Add the files to the index again. Git will recognize that they have been moved. 4. Update references. 5. Commit.
Looks good at first sight. I have no experience with them, and I really don't want to build websites of which the GUI is programmed in Java. That may work for some people. I'd rather use PHP.
like thatsIch said, it is useful when you are creating some extension to exiting program and you need edit some enum to make it work.
Oh I didn't know that! Dam but yea, Im trying to do this in Java.
Also, use Mercurial instead.
Oh I'm very aware of the CompletableFuture thing, as it's one of my favorite tools. The forward cache is for synchronicity. It's a network of game servers, and players can join one server immediately from the other. With just the sql persistence layer preventing race conditions in this scenario has proven...difficult. So we use a pub/sub in hazelcast, and the forward cache takes in an object that implements Syncable which has a method called sync() which puts the data in the forward cache if the player isn't found, or syncs the data to them when received. Doing tests without the guava cache hibernate didn't seem to help much. I'd prefer to leave 2nd order caching off and use my own cache tbh. That way I can wrap it in async logic in case it hits the db. Hopefully that makes sense I was drinking when I posted this, and I haven't uh stopped.
Unclear what you mean. Anyone could stop financing/supporting anything at anytime, so that's really not a valid argument against. As long as you have a copy of the tools and the language is adequate for the job...
[jaotc](http://openjdk.java.net/jeps/295) is a start
Naw I just wanted input on the overall high level design. That's exactly the advice I wanted :P. I'll look into ECS and jOOQ, and see if they may be more appropriate. Redis I wasn't super fond of.
In intellij there is a refactor rename feature that does this for you... Even updates all code references. 
Streams are lazy, so you effectively get map fusion.
experience &gt; degree it's even: experience &gt; (10 * degree)
I don't like devoxx at all.
I just use drag and drop, Eclipse takes care of refactoring and updating git. That's not working for you?
Git MV?
Afair there's a thing specifically for this - [git-mv](https://git-scm.com/docs/git-mv). 
Good note! **Everybody,** use this instead!
Why? What does IntelliJ do better in this scenario than Eclipse? In Eclipse, you can simply drag and drop the packages around, everything will get refactored and the git repo will get updated.
Nice list. One question: why this rule? &gt; Rarely return Stream, unless private shared methods.
What did you try originally?
Except, dragging and dropping did not work in this scenario, which is why I posted to begin with :) Using Neon.3 Release (4.6.3)
I tried to drag and drop... Simply wouldn't let me. And I also tried "refactor" and then move. The list of folders that populated included just the package that I was moving from, rather than other packages to which I could potentially move to. 
Ah, ok, sorry about that—I though it was a theoretical question since it should be so easy :). What's the problem you're encountering, i.e. are you getting some error message or stack trace we can work with? The suggestions you're getting to use the git CLI are certainly helpful—but this should absolutely work from within Eclipse.
I host the [Illegal Argument](http://illegalargument.com/), tho we've been a little erratic with recording lately due to work, and me doing more and more concert photography ( which often clashes with our Wednesday recording night ). People seem to enjoy our ranting and raving, so maybe you might find it amusing and/or interesting.
Software Engineering Radio has several podcast episodes that focus on the JVM. http://www.se-radio.net/?s=Jvm
It just takes practice. Also JavaFX and swing are libraries FOR Java written IN Java. It's all the same language. Java is the general code it is all in, they hide away all the technical for GUIs in Swing and JavaFX. Just keep coding, reading, and practicing, you'll get the hang of it. Don't feel bad about googling things, I recommend **NEVER** copy-paste. And when you "retype code", comment what it does and a link to where you found it. In case you come across it later. Keep making new types of apps, don't repeat the same thing more than once (identical ideas), similar ideas are great.
I'll try my best but it's so difficult, not to mention I can never find the answers online for what I want to ask so I basically have huge gaps in my knowledge making it harder to figure out other stuff
Subbed because I can't stop laughing at the titles. "Episode One One Seven :: Int -&gt; Int -&gt; Int -&gt; ()". Oh wow. I'll check it out
Java is a pain in the ass. Especially the GUIs. Swing was created by Satan.
FX is actually decent though.
You can buy a Java SE 8 (or 7 to make it easier) certification guide and try to pass all the test questions in it.
I love FX. :) Easy to learn basics using Scenebuilder or such, fun to learn how to manipulate objects further using Java.
you could try learning Android. it's a more modern UI API than javafx or swing and the docs are more beginner friendly. there's also great material for learning networking and DB storage, etc. a lot of those things apply to vanilla java. 
I really don't want to literally all I want to do is learn java and it's so complicated or I'm just an idiot, every time I look up how to do something I just find another way to do something simple and it looks even more complicated
Java is so hard to grasp for me and I feel like an idiot it's been 2 months already
import package.myclass; You can ignore the package if you don't use them (you should use them).
Ouch... Alright I guess I'll see what I can do. Thanks.
I have a Java Application that I want anyone to easily run through their browser (no downloads, in the actual browser). It seems that this is impossible.
What is your depth of programming knowledge? Is Java your first compiled language? Regardless, I'd post a bulleted list of questions on /r/javahelp. I'd be happy (and others) to run through answers for some of those gaps. Programming isn't something you rush, if you do, you'll half-ass your implementation and realize it later when problems arise.
HTML CSS php
Does that mean that your game (game.java) class does not belong to any package? If this assumption is true, that means that the class belongs to the unnamed package, and by the [standard](http://docs.oracle.com/javase/specs/jls/se7/html/jls-7.html#jls-7.5), you can't import classes from the unnamed package into classes that belong to named packages.
Definitely follow my advice and post some questions on javahelp. You are probably having trouble because you are switching paradigms completely. It can be a hard transition, and it helps to understand how Java is different from PHP and the web technologies.
How long did it take you to get good at java if you don't mind?
I learned C++ as my first language and used it for about a full year until I started Java. It only took me a month or two to get pretty well versed. C++ and Java are very similar, except Java hides the more complex things from you, so it was an easy transition for me.
Okay, one possible problem is you're trying to learn JavaFX without knowing Java first. An analogy here might be going to Germany and taking a math class, trying to learn more math... while doing it in German, which you probably don't know. Take a few hours and just write some Java code to solve problems. You'll want to pick up the basic language (classes, methods, objects and types). Figure out how String works. Take a look at the Math class, and Arrays. You'll want to learn about Collections, which are like arrays, but with far, far, faaaaar more features. Those are in the java.util package; ArrayList and HashMap come in super, super handy. At some point, if you can get an IDE to work for you, you get superpowers; it shows you where you're making some of your mistakes before you run javac, which is damn handy. Then pick up either JavaFX or Swing, but not both at the same time. Also, if you can't find answers online... have you seen stackoverflow.com? It's super crazy handy, although they only allow very specific questions (and delete/lock threads about discussion, like this one.)
For me, learning PHP was a big transition. I couldn't make heads or tails of how I could get stuff working well for at least 3 or 4 months with HTML, CSS, and JavaScript together. It's all relative. The person who suggested Android had a good idea. Android is 100% Java. And the documentation is much better, you'd just learn different GUIs while u learn the actual language.
Virtually impossible. Java runs on their PC directly. You could in theory run the delete command and delete some of their files if they give you permission. I'd recommend a different tech stack. If you really want to use Java, look up GWT. I learned it in college and it basically cross compiles Java Swing into JavaScript. But it is coding Java for the web effectively. It is not for the faint of heart, it's a real pain in the ass sometimes.
Yea I tried obj c and it was similarly hard, idk why I just can't seem to grasp object oriented stuff
It's tough to switch paradigms, but keep at it. Do some reading on object oriented specifically, and then head back to Java, see what you can do!
Effective Java is great but hardly the right book for a beginner.
Sure. It all depends on how well he knows JS and PHP. He said he knew them, but who knows at what level. If he's competent with them, Effective Java will be hugely important to get him into thinking about things in a more Java-way. When I started writing Java professionally after a year of PHP and Python, Effective Java helped me like crazy. 
Any good book ?
No, I didn't.
Brace yourself, getting past the actual language is nothing compared to mastering design. You have a 10 year learning curve ahead of you to become a decent engineer. 
Try doing some OOP exercises. One of my favorites is playing a game, and then making a rough UML diagram for a section of the game. If you're not a gamer, you can do something similar with the objects in your living room. Once you make enough, you'll start to be able to think of code as objects, and OOP should be easy from there. Edit: forgot a word.
Looks like a pain in the ass... Also looks like I'd have to rewrite the interface since it doesn't really port over, and I have no idea how Java JAR dependencies would work out in this scenario... Either way, this project isn't really looking hopeful so I may have to rewrite it in Python or something. Really don't want to :( If you come upon any other ideas that may allow me not to waste all the work I put into the project please share, but thanks for the input anyway.
my java project for this week is a laundry application.
I have done what you are describing many times in Eclipse without any issue. What is it that doesn't work?
Really doesn't have to be ultimate. Community is enough. 
You could try TeaVM instead of GWT http://teavm.org/ It compiles Java bytecode to JS instead of transpiling Java source. It is supposedly has complete JDK coverage although I've never tried it.
Listened to 2 of his presentations on Valhalla and the future of Java &amp; JVM. Guy really explains the method to the madness of all those experimental OpenJdk projects very well. For example - I never would have thought about all of the possible applications of the stack-walking API until I heard him talk about it
Definitely! There is a great team working on the platform!
This is the real answer, I had my fair share of WTFs with IDEA, but moving files around packages always worked flawlessly. And in general I find it easier to operate than Eclipse, though I haven't used Eclipse for few years now. 
This is the right answer. If you just move the files (through the command line, IDE, file manager, what have you), git will think the old files were deleted and that the new locations are brand new files. git mv will retain the history of the file.
I wanted to add a practical question: as a learner and a beginner, what are some actual practical projects I can do with Java? Not play examples, but something real life, albeit at a perhaps much less complex scale. Maybe that way I'd "get it". Sure, its easy enough to say that, for example, Twitter is Java, but what exactly is Java in Twitter and how can I learn to do something like that? An isolated part of that, of course
Java is the king of the server side, where as a client you're not going to know what language the system you're communicating with was written in.
But JetBrains must be using their own GUI, no?
A few important reasons: 1. Java is very backwards compatible. This means when a new version is released, in all likelihood, your existing code will just work. That's a huge deal to large organisations that have multiple projects and millions of lines of code. 2. Java standardizes a lot like how things must be named, and even makes recommendations on code formatting. This means that all java code looks very similar, which makes the code easy to read. So when you swap people on projects, the learning curve isn't steep. 3. Java is very verbose. This can be a pain in the ass when coding, but ByteArrayInputStream leaves little to the imagination. When you need to maintain code, that verbosity really helps. 4. Java developer tools are excellent. They're frigging spectacular compared to most other languages 5. Java has an enormous ecosystem that had evolved over many years. When starting a project, it's great knowing that most of your grunt work can be handled easily. See the apache software Foundation for tons of high quality tools. There's other reasons too but basically, going the java route is safe, reliable, and feature packed. That's what most people want.
I guess the two most common cases where Java is used are: 1) Applications for IT support in enterprise. You encounter them if you work in some big company which uses databases for large data storage and data processing. These are *in house* applications, therefore they are not seen to the public eye. 2) Backend programms that run on servers. Frontend is usually written in something different, like Javascript, so you don't even know that the core is in Java. Most public desktop applications and most web applications (frontend) are not in Java, which makes biased experience for ordinary computer user. 
To support the other answers: Java is mostly backend systems or enterprise applications. To get a feeling for Java backends take a look a JEE or Spring (https://spring.io/) or JHipster (https://jhipster.github.io/) for a current Java stack. I.e. Spring Boot as backend server, Angular JS for the UI.
they don't use swing
Why would you say that? https://github.com/JetBrains/intellij-community/search?utf8=%E2%9C%93&amp;q=swing&amp;type=
&gt; in my country the form used to fill out tax reports online is written in Java, and it officially doesn't work on anything but Safari and IE That has nothing to do with Java the language. Let me explain. Java applets are just one, tiny, very particular part of Java. And they _used_ to be supported by every major browser years ago (Netscape and IE, and then Firefox and Opera and Safari, and then Chrome). However, due to a number of security issues, and to the fact that almost nobody uses applets anymore for new Web applications, Chrome decided to drop support for Java applets. Firefox still supports them AFAIK but you need to confirm you know what you're doing in a couple of security-warning prompts. Sites with applets were then forced to choose: drop applets in favor of a more modern front-end technology; or drop support for non-compatible browsers. Your Government (the department who made the tax report site, at least) decided to go the second route, which is of course cheaper. That has barely anything to do with Java. They could have replaced the applet with a JS front-end, while keeping the Java backend (all the server-side processing). That way users wouldn't even need to have Java installed. But this of course requires time and money, and Administrations don't have much of any of those. -------------- Back to your question, the problem is that your Java experience is limited to amateur user-side content: a game, a BitTorrent client, an applet. Java is a more professional language. You say you are a "hobbyist beginner programmer". Ever used Eclipse? That's written in Java. All of it. IDEA's IntelliJ is even better and it is also written in Java. Your ISP uses Java in most of their systems. Every time you call them, a Java application pops up in their terminal, with all your data. Need to change your data plan? A Java process handles that. Want to renew your cellphone? Another Java process. Cancel your subscription? Java too, but they won't let you have it :) Banks, corporations, IoT, science... Have a look: https://www.quora.com/Where-is-Java-used
The reason Apple did it was that in the early days they weren't sure developers would be so keen in picking up Objective-C. Java was their plan B, just in case, but given that everyone was gladly picking it, they scratched it instead.
still though ?
Well, misinformation about java's shortcomings is one of them. You talk about how 'tax reports online is written in java' but only runs on Safari and IE. That gets us to… # Java on the web. That makes no sense. There are only two options: 1. Someone wrote the _server side code_ in java. No java web framework requires the client to be safari or IE; you are of course free to make your java server respond with a mix of HTML, CSS, and JavaScript that doesn’t work properly except on IE and Safari, but this has nothing whatsoever to do with java, it just means the programmers of that tax return form are bad. 2. It’s a so-called ‘applet’. That technology has been abandoned as a failure 10 years ago. It WAS how java was originally ‘sold’ to the public, but like all grey boxes in browsers technology (Silverlight, Adobe Flash), it’s dead or dying. As in, browsers do not support it anymore, and absolutely _everybody_ doing java consultancy, including Oracle itself, recommends you do NOT write any applets. I’m guessing this is it. Note that if it’s #2, java is better than everything else. In that it works _AT ALL_. For just about every available web deployment framework out there that isn’t java that I can think of, trying to run 10 year old code on current versions simply does not work. It’s one of the reasons java is popular. A very boring reason: Java takes backwards compatibility more seriously, and doesn’t just _say_ that, it has a proven trackrecord in it. Few other languages do. It’s a business / blue collar mindset versus what language/framework authors really want to do, which is upgrade to cooler, newer stuff and no need to bother with the stick-in-the-muds that can’t be bothered to upgrade along with you*. *) 10 year old stuff written in flash probably still works too, but that’s mostly because flash is no longer being updated by adobe. Google adwords and a ton of corporate sites run on java, but it’s not like your tax return form stuff. You’d never know: The server, stuff you never touch, THAT runs on java, and the java code generates the HTML and REST APIs that power your website. From your view (the ‘client’ side), all you see is plain jane HTML, JS, and CSS, and you have no idea that it’s all tied together at the server end with java. # Games Java isn’t designed for it. Simple as that. Note that nobody* writes games in Python, PHP, Scala, C#, Ruby, Dart, Clojure, node.js, etc either. Game programmers who get their choice of platform all write C and because all game programmers write C today, the game programmers of the future… also do. We all start out as noobs, and if you’re a noob, starting with a fresh hip new language mostly means you can’t find many tutorials, examples, or help. And like a vicious circle, because nobody* writes games in java, it’s not a focus for anybody in the java community. *) I’m taking some liberties and rounding down to zero a lot here. As OP said, Minecraft is a rather impressive counterargument, and there are plenty of java based games in android. But, note, if the programmer has to pick a certain language or it’s impossible, then naturally people will try. Games are now written in JS because, well, if you want it to run on browsers without plugins, you don’t really have a choice in the matter. # Desktop apps Again, not a focus, but, again, this applies to all languages. We have no idea why, but if it’s not ‘native’, it tends not to work out, as far as ‘language + libraries to write desktop apps in’ goes. With ‘native’ I use this somewhat creative definition: “If the owners / authors of the platform were to write a desktop app, what would THEY use?”. For example, how many successful apps do you know that run on MacOS that aren’t written in ObjC+Cocoa or Swift+Cocoa? To really drive home the point: If you want to dev desktop apps for KDE-based linux distros, you’d generally pick C++ (or was it just C?) and the QT library. That’s what most of the KDE apps are written in. Those fit right in. QT is cross platform. You can program windows desktop apps in C++ and QT as well. But… no serious windows apps* are written in this. Clearly the library/language just don’t factor into it much. It’s the native platform that wins out. *) Again, taking some liberties and rounding down. It helps to consider ‘the web’ as its own platform. # Notes for the pro These points will probably fly right over OP's head and aren't meant as an answer, more for those pedants in the audience who would like to nitpick this post. Feel free, but please keep in mind: * IDEs are not a fair example of a 'desktop app written in java'. __OF COURSE__ a programming team that's all about java will want to write their desktop app in java, and almost by definition the audience for such an app has no problem making it all work. They're java programmers! If anything it strengthens the argument that the quality of language/library just do not matter: IntelliJ, eclipse, etc – these apps are incredibly complicated, some of the most complex desktop apps you can possibly build, and they work just fine. * Electron and co. are an interesting new development in 'desktop apps that are successful that aren't written in the native platform'. But, hey, Adobe Air seemed to take off at first too, so there's that. I bet it'll remain a niche for programmer's tools but it won't get much beyond that. Still, it's a somewhat valid counterargument to my thesis here. 
Still, what? Source is Java, regardless of the output.
There are a number of nonsense memes about Java that are perpetuated by basically ignorance... Java is no good for games, well you might as well say C# is just as bad for the same supposed reasons... take a look at for example libGDX you can make great 2d or 3d games with it, and as for the so called "stop the world" garbage collection, just not an issue, and in the unlikely event it ever would become an issue there are plenty of techniques like object pooling to completely mitigate the issue Java is slow... this rubbish has dogged Java for years and in this day and age even *if* Java was inefficient modern hardware would more than make up for it, the GC is so fast that you can actually perform *faster* than a C app where there is a very high allocation and deallocation of large numbers of objects... While many people have dismissed JavaFX because presumably because of its rocky start with jfx script... now a days its a great GUI system and even means that every JRE comes with in effect a mini 3d engine built in (ok sadly no shaders - but you can still do a lot with it...) Java is verbose and thats bad - is yet more nonsense verbosity is a very good thing, Java code is very much easier to maintain, you can come back to Java code *years* later and very quickly get back into it, reading other peoples code is usually fairly easy, you just cant say this with a bunch of C++ ascii soup 
android
I was hoping for a little more insight than a Top 8 list straight from the [Stack Overflow results](https://insights.stackoverflow.com/survey/2017#technology-databases), like Language/Framework and DB pairings. 
Most people do this by running the application on a server somewhere such as AWS and then using a web interface to the application using JS/Html and REST
You can try setting up a spring rest service. They have some nice tutorials to start out with. 
Java is a good server-side language. The bugs you are mentioning on the web are probably due to poor JSP and/or JSF frameworks implementations. Java started its web journey with Java Server Pages and JSF. To this day, JSF is the "official" webapp development framework in Java. The trouble is that it's very old, it's a server side technology (hence slow) and it requires a lot of architectural talent in order to be propely implemented. But since the rise of JAX-RS and clean JavaEE applications, you can simply write a backend of HTTP endpoints and a HTML5 + Javascript client, to replace the JSF.
The latest version of the Zing JVM we (Azul) released recently includes a new JIT compiler that is a replacement for the C2 (sometimes referred to as the server) JIT. This is based on the LLVM project and generates code that uses both AVX2 and AVX512 where available and in more situations than HotSpot, even using the relevant command line option. There's a nice blog post from Gil Tene (our CTO) with more detailed information here: http://stuff-gil-says.blogspot.co.uk/2017/05/zing-hits-trifecta.html
Here is one proposal. Do you know some math? You can create some [beautiful pictures or animations](https://en.wikipedia.org/wiki/Julia_set). It goes like this: You choose some polynomial equation with complex roots (like z^3 - 1 = 0) and you try to find the root with Newton-Raphson method. You choose a rectangular grid in complex plain as a pixel domain for your picture, and every pixel defines corresponding complex number, which is starting point for Newton method. The color of pixel is determined by the root at which the method converges. You can apply intensity of that color according to convergence rate (more iterations, the darker the color). You can display final picture in a frame in JavaFX application or you can save it as JPG picture. Edit: You can use publicly available [Apache commons math](http://commons.apache.org/proper/commons-math/) library, which has a predefined class Complex for complex numbers. It comes handy when computing fractals.
Good point! 
If you feel there is no measurable difference in risks involved, then indeed a decision based on a risk assessment shows all options to be equally risky. My point is that for those people who, unlike you, believe there is a measurable risk difference, it is a valid argument to go for less risky options. Maybe those people are all wrong, while you are right, maybe that happens to you all the time, maybe everybody should should up and listen to you, sure. But your infinite wisdom is beside the point of my argument.
1. NodeJS is a Java**Script** framework that has nothing to do with **Java**. Java**Script** and **Java** are two completely different, unrelated languages. If anywhere, this should go in **/r/javascript** 2. Are you actually asking a question or what purpose should your post serve? Should it link to a tutorial? (If so, it is the wrong subreddit anyway - tutorials, **provided** they are actually **Java** related should go in **/r/learnjava**.) If you were trying to link to a tutorial, you cannot use a **self post, unless** you post the tutorial in the **post body**. If you create a **link post** you cannot have text in the post body. It's either or. **Post removed:** Most likely Java**Script**/Tutorial and actual intent completely unclear. ---- **Edit:** looking at your post history indicates: + You are **spamming** to the max - which is **forbidden** according to the reddit rules of self promotion and spamming. Your only participation is through your failed posts. + You are not clever enough to have figured out that each and every of your post misses the links to your website - you haven't yet figured out the difference between a **self-post** and a **link-post** - which, after having been **9 months already** on reddit is a **shame** and an indication of the overall quality (or better lack thereof) of your contributions. + You probably are a (badly programmed) bot **Stop spamming** and **start actively participating** in reddit or otherwise you will be reported to the **reddit admins**.
I'm a Java guy too, but... &gt; in intillij I can right-click, refactor, rename, and all references are updated. That works in PyCharm too. (In fact, PyCharm is made by the same people as IntelliJ) &gt; in python their are no real private variables, It's widely accepted that if you prefix your private variables with `_`, people have no business mucking with them and shouldn't be surprised if they change in a future release. &gt; Python has tons of packages available and some are really great, but their is a large quality gap in many of them. This is just as true in the reverse direction. I haven't seen anything like Passlib on Java, and Flask is much nicer than Spark (personal opinion).
Also, there were a lot of issues in Java's beginning in regards to public relations, security, speed, etc. that people didn't get over even though those issues were resolved. One other thing that I've noticed about the developer community is that it tends to be very hipster and "trendy" so many languages that have stood the test of time are looked down on. People are always looking for the next new fucking javascript framework (don't get me started on JS).
&gt; If I try to use the Java equivalent, Java Webstart, all Jars have to be signed by the author, application privileges have to be declared. any java program deployed this way will popup an ugly security screen, Your description of deploying apps with Java Webstart seems overly dramatic. We deploy Swing apps to our clients over the public internet with Java webstart and we have zero problems. For permissions it is literally a single additional line in the MANIFEST.MF where you can request "all-permissions" (or you can be more fine-grained with what you are requesting). If you have a code signing cert from a CA the security dialog simply asks the user if they want to run the code from this publisher (lists the name associated with the code signing cert). The user can choose to never be asked about the publisher again and the dialog won't appear again. Mac OS actually does the same thing for all apps that are not downloaded from the App Store (even ones written in obj-c or swift), so at least on Mac OS the additional dialog to run a webstart app seems pretty normal. 
Great writeup, but I disagree C# isn't used for games. It's Unity's programming language, as well as XNA back in the day and Monogame now. C# has a relatively healthy games ecosystem.
Renaming isn't generally possible in dynamic languages. In many cases where the type can be inferred or where names are perfectly unique across the whole project it *is* possible, but not generally.
JavaFX has made it relatively easy now to make very nice looking desktop applications.
I think he's asking if it's still written using GWT. We use it at work and GWT seems all but abandonded by google. No clue if they still use it for major projects but it seems unlikely.
In fact there's an auxiliary desktop app called [ElsterAuthenticator](https://www.elster.de/eon_auth.php) now, which fulfills most of the applet's functions and exports encryption keys from the smartcard to the browser using a local servlet container. Not quite the most secure solution (there's no further restrictions except for restricting clients outside of localhost, which doesn't have to be a browser running the ElsterOnline portal), but at least it works without Java inside the browser (just a private JRE installed with Install4j).
No no no no don't do this. We tried that. We had Java web apps. They were terrible. Just write it as a desktop app, or as a server with a standard web browser ui. If you want to do Java still then use gwt which cross compiles. Just because it is possible to do this, Nd people will give you answers. It is basically ethically wrong.
If I had to name one cause it would be JDBC. Java simply works with any relational database you throw at it and it has been that way forever.
Sorry, does that mean make new windows, use more screen space than the browser, etc...? If so, yes for the time being, but no in the future (working on making sure everyone remains on a single JFrame instead of opening a bunch of new ones)
Because the server-side is mostly boring, requiring large hordes of low-wage programmers.
Would I need to write a Java server to handle the requests or will REST take care of that? Also, I can host the code on the website's server, correct? Just to save money.
Yeah, it looks like this is what I will be doing (web browser UI). GWT seems like too much. As soon as I get the details ironed out for the server and communicating with it, I'll probably switch to web UI.
Usually yes, but sometimes the sites are configured to deliberately mislead the attacker.
Just to pick nits - If you use reflection, you're asking for it. There's usually no need to use reflection. There's times, sure, but if it's a main tenant of your application and you're not coding some sort of library (aka, you're a business application, gettin stuff done) - you're probably doing something wrong.
Well sure - but there's never a *need* to use meta programming in any language. My point was that it's not dynamic languages that break IDEs, it's meta programming which is available in pretty much every language. It's just used less in some than others.
this was my thought too (it really is a shitpost and a half), but [the dude](/u/Zwordiak) is just a non-native speaker with limited software experience his first ever reddit post [whats_wrong_with_lina](https://www.reddit.com/r/learndota2/comments/4x788y/whats_wrong_with_lina/) has similar language. he proceeds to make 100-ish posts/comments in learning dota (and he appears to be getting better at the game). while his choice of language is unfortunate, i think it's highly likely it's an honest and well-intentioned question if he puts the same effort into learning java that he's demonstrated in dota, he'll end up as a contributor to the community 
Now? The ecosystem. The tons of fantastically good frameworks and/or libraries. Originally? It was the first to provide a really easy to use language, powerful concepts, write-once-run-anywhere (yeah, right ... but it mostly worked), introduced several standards (jdbc, servlet for example). And all of those things by 1999. Compared to the old CGI, the java servlets were extremely powerful. JSP only added to that. Made writing dynamic web applications a breeze. And it only improved with time. Edit: another thing: I wrote my first java application (servlets and jdbc) back in 1999. I remember I used an IDE called JBuilder 2 (I was a student, it was probably pirated). It was the first time in my life that I saw code-completion. It was a jaw-dropper. VC++ at the time didn't have autocompletion. The next version I believe they introduced it. But for me, that first exposure to it was ... whoa. Before I had to program with the book by my side (DOS borland c++ or linux emacs). Suddenly, the book was recommended, not mandatory. Yes, I still studied the book, but man ... that autocompletion really helped.
well, welcome to the wonderful world of programming. i'm not trying to be an ass, but there is no language that is free of the things you describe. you'll be hard pressed to find a language that works flawlessly in all environments - especially when its claim to fame is that "Write once, run anywhere" IMNSHO Java is the new COBOL. Its great for server side programming, database access and generally doing whatever has to be done to get the data someone else will display. I think, as a presentation technology, its crap. I *LOATHE* javascript but i'd much rather use it than any of the perverse things (going all the way back to AWT, anyone remember that?) Java required/requires to get stuff to display in a browser/UI and that's why i don't think you "see" it much. you aren't looking the right places. i also disagree with well designed - if it were well designed there would be no need for something like Spring. think about that for a second - Spring is a tool designed to make using another tool easier. its the equivalent of need pliers to use your hammer
Java is robust, secure and stable platform. Spring Security integration with Java based web application makes it secure. Also with recent tech of RESTful Web Service with Spring JPA, JSON; Java provides apis which can be used by website, android or iOS application too. Angular JS with Typescript and java bases Spring REST services and OAuth are in great demand now a days.
I would add that a lot of the "Java is slow" crap is simply a hangover from the bad ol' days of Swing and AWT desktop apps where the UI was just awful and slow, which was partially because both of those are kind of crap to begin with and also because a lot of people writing those apps were kind of crap and old UI code always turned into massive piles of listener spaghetti.
Everything sucks in one way or another.
Let's admit Java has problems. Sure. This is true. So which language or framework should we switch to? One that doesn't have any problems, right? Unfortunately, they all do. Every decision like this will always has both pros and cons.
Java in the browser (which you describe) is very different from Java on the server. The vast majority of the code written in Java executes on servers and do not experience the kind of issues you describe. Most, if not nearly all, of the Java that executes directly in browsers has since been replaced by user interface code in Javascript that uses frameworks like Angular or react.
Java is popular, because it's popular. If you would compare programming languages in a vacuum, Java might not come out on top. But it has a ton of infrastructure to support it like app servers, things like Spring, utility libraries, etc, etc. For every problem in Java, there are many solutions to choose from and they keep getting better. I programmed in a somewhat obscure language before this (Progress OpenEdge/4GL) and if you had a problem with it and tried to google an answer, well.... good luck with that.
Because if you are using the right framework, most usually complicated tasks ate dirty easy to do. Also, due to it's popularity, it's all tried and tested technology, that implies little risk for your business. Building and deploying scalable parallel application is easy and mostly automatic. Also, Java performance is actually good now, so even financial services will be okay with using it. With all this in mind, Java will be around forever.
That reminds me of this quote about United airlines a few months ago on /r/investing regarding UAL stock doing better than its competitors about a month after its incident which included a 5% stock price drop. Customers thought "oh my god United is beating people up". Investors thought "holy crap, their planes are so full this is how they have to deal with it". 
Video linked by /u/mcroft: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [Life of a Twitter JVM engineer: the garbage keeps coming... Tony Printezis](https://youtube.com/watch?v=M9o1LVfGp2A)|Devoxx|2015-11-13|0:57:03|51+ (96%)|4,261 &gt; Twitter runs a swarm of services executing on several... --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/mcroft ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=djfdi5z\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v1.1.3b
Every language had issues.
&gt; Java runs anywhere, but users are forced to install the JRE which then sits in the tray, nags about updates and such. Yea, but anywhere that is not windows this doesn't happen. The question is: Why do windows users put up with oracle's proprietary java implementation and updater and don't organize a trusted OpenJDK build? I only know about the ["Zulu" builds from Azul](http://www.azul.com/downloads/zulu/) but apparently people rather install Oracle's JDK and then complain about Oracle's updater. For desktop applications it really sucks a bit. Swing GUIs are just lacking a bit. I mean Swing and AWT just isn't very good. For university I'm currently working on something and have a small GUI for visualization of the results. It's a map widget and on top of that I'm just drawing some stuff with Graphics2D and it is sloooow [when you start drawing a couple more lines than the developers thought you would](http://i.imgur.com/bJ4ceEG.png). JavaFX is supposed to be better with that with hardware acceleration... There also are Qt and GTK bindings but I can't say I remember seeing anyone ever use them.
You could host it on anything that can run a Java application server. So, anything from your home PC (not recommended though :) ), to a small VPS or all the way to a hosted service like AWS or Heroku.
I mean things like reading &amp; writing the local filesystem, using UDP or TCP sockets, opening new (undecorated) native windows, interacting with other applications on the desktop, accessing the clipboard, and so on.
It's getting kinda old
I'm not saying it isn't well-maintained, just that it's age becomes more and more apparent each year. And that it's popularity despite perceived problems is due to it's age since it was the language of choice for so many projects for so long. Universities still use Java as one of their core languages and so many businesses still use it that despite the age and issues people have with it it will remain popular for a while to come. I do think it's popularity is slowing down though, languages like Node, as well as other JVM languages like Scala and Kotlin are slowly but surely replacing Java.
So yea actually I threw together an iOS YouTube player app, and when testing the app in xcode I get the same error. It might be an issue with my browser or something
I've used reflection for AOP stuff. But generally I try to stay away from reflection, it makes refactoring a pain.
In my experience, Java is pretty much the major language used in teaching, followed by C++.
&gt; Except, what the OS vendors realised is that Java would &gt; commoditize the desktop No, not really. Java UIs were first written in AWT, then Swing and now JavaFX. The problem with AWT is that it is lowest common denominator. AWT doesn't even have a tree component because not all operating systems support it. Swing came along and fixed that by rendering widgets using Java2D and then using themes to give a native look and feel. But Swing never really looked or behaved correctly, so it mostly never took off (IntelliJ is a notable exception). I mean, it took a long time before fonts even rendered correctly on Windows, such matching ClearType rendering on windows. And on Linux, the Gtk theme is still just plain awful. Metal was okay, then Java 5 introduced Synth which was plain amateurish. Nimbus looks kind of neat. It has been my experience that if a desktop client is required for windows desktops, it is written as a .NET app, using Java as a backend. Cross-platform UI development is a huge challenge, and very few toolkits manage to pull it off truly well, such as perhaps Qt. I find Electron quite awful, but people at can accept HTML/CSS/JS since they use web browsers. The absolute best apps that I've seen don't even bother to use cross-platform toolkits at all, but write native UIs that match the "experience" that users of that OS expect. Java was never a threat to desktop commoditization. Now server commoditization is a different story...
Java is the backend, carrying all the business logic. 
With Java, BootsFaces. With JavaScript (or TypeScript), Angular.
/r/madlads
clap clap clap
Yeah, I've gone down this road. More than once, actually. In 2002, it was a good idea to write your own UI framework. There was competition, but it was a lot weaker than today. I'm glad I started my own company framework at the time. It was a great success, and it saved us a lot of time. 15 years later, things look a tad different. There are still things you can optimize. But the competition has become very tough. So I recommend to chose one of the popular frameworks and to build your own framework on top of it. As for general thoughts: well, chose your target platform. It's easy to support a single platform. Fixed resolution, fixed CPU architecture, fixed operation system - things like these help you. The general purpose frameworks are, well, general purpose. They are Swiss army knives. Another idea is to optimize your framework for your company. That's the only unique selling point nobody else has. And that's why my good old framework of 2002 is still used. I'm sure it's outdated, but it still does the job much more efficiently than any of the Swiss army knives :).
That’s arguable. I don’t think Java is going to be replaced in the foreseeable future.
Java really runs many more places than you see... Plenty of functioning websites are written in JSP rather the headache (I think we can all agree it is) that is applets. Obviously it has a more practical use case on servers as it only has to be written once deploy on even large networks such as Google's cloud computing system or YouTube. Many other websites use Java. Another popular place to find Java is in IoT devices, from your shiny new WiFi thermostat to many Samsung Fridges (which actually run Android). Another of it's more popular use cases is in Java phones, an I don't mean Android. To date more Java phones have been sold than android as many older systems (like flip phones) ran the language. Finally we come to what may well be the lost popular use case, embedded devices, many of which you'll find in Java's installation window as it downloads (3 billion devices run Java). Embedded Java systems include: Street lights, set top boxes, almost all bluray players, many TV's with OS's onboard. In nearly all of these cases Java has never become a problem or a long time setback for developers. Many Java systems are programmed well and work seamlessly in your daily life... For more information Java did release an article about the whole 3 billion devices thing (its more likely between 4 and 5 billion).
C# is nothing but a scripting language in Unity. All of the code that does the heavy graphics lifting is all C/C++
With hibernate, completablefuture, and guava caches high performance databasing is trivial
Maven and Gradle are pretty sweet. It's nice to have vendor neutral build systems. I've been doing some Unity experiments in C# and the situation isn't as nice. C# is also fragmented at the moment with competing .NET Core and .NET Standard standards. At least the bad situation with Xamarin licensing is coming to an end.
I wrote a java app that downloads and digests market data files, normalizes them, and loads them into a database *seventeen years ago*. I'm told it still works, and it didn't even blink when my firm swapped the Sun Sparc boxes to Redhat Dells. Even the Perl and Bash scripts broke when we switched, but not Java. I don't think Sun or Oracle ever removed a single deprecated method either, so if you ignore warnings, you can code y2k style.
Look at the bitter man, everybody!
Yeah, good for you. In Python every function takes Object and returns Object. That's a no go for slightly more complicated code base.
You should be able to with little to no modification, not sure what's involved though. I know the documentation isn't great.
I've used reflection to write great tests that are not needed to be maintained. E.g needed to make sure that all endpoints are secured in a spring application, wrote a test that fails if the a servlet class has itself not the preauthorise annotation and one of the mapped methods neither. I remember that I had also a use case in production code, where after discussion everybody agreed to use reflection too, unfortunately I don't remember the details. All in all, reflection is great for tests and should not be used in production code, because of readability, but many of your favorites libraries use it extensively and you use those in production code too. Then again I love, because of readability, aop and lombok, so I change my statement to just not use reflection in your business layer. Everywhere else it's fine. 
I can't for the life of me figure out why they dropped javafx from the arm binary. It really screwed up our project and the alternatives all have outdated unusable install instructions 
I have decided to move on from trying to use the Swing library and just use the back end I wrote for the app with a server that communicates with a JS/HTML front end. Currently figuring out what kind of server I would be using. If you have any background in serving clients with a Java server please share any steps
I can access it. Maybe your ip is blocked?
Most of my colleagues are older than the typical programmer (in their 30s and 40s) so I use them lightly when it doesn't affect readability too much. I think that using lambdas just because you can isn't always the best solution. Verbosity makes it clearer, especially when people are taking over other people's code and figure out what's going on.
that would be strange. still no access. i have not been geo blocked before. as far as i know.
I'm sorry you think that way but if you're not an idiot you must realize I am in no position to troll when it comes to programming, even if I wanted to, because I am literally not a programmer, have no experience with anything, have no legitimate opinion and thus cannot be secretly advocating for a different technology/language. My question was worded the way it was, and I've put the disclaimers precisely because I was doomed from the start. However, this has unexpectedly taken off beyond my dreams, and I want to thank the rest of you here for a productive discussion. You, meanwhile, should continue your troll witch hunt elsewhere. People like you are the reason I was forced to write the way I did in the first place.
&gt; I would alloc it from the very beginning and keep a fast free list handy. Good luck beating that in Java oooo that's cute!! You think you have a turning machine!!! In the real world when you start to build big boy apps at big boy scale, your manager will fire you for wasting the most expensive part of the hardware : memory. (if you could even buy a VM big enough to host your fat app) You think you could produce better binaries if the compiler just converted your source to binary rather than optimizing? If your compiler simply translated your source to binary, you would have to spend years optimizing every sub routine in your service. As if a human could do better memory management in a reasonable amount of time. Why don't we just all write in assembly?
So what don't you like about [Apache Wicket](https://wicket.apache.org/) then?
Effective Java, 2nd Edition.
Only problem my answer is just irrational hatred.
Part of the problem is that Java is old. Unicode was still fairly new when Java was in development, and while UTF-8 was technically created before Java launched, it wasn't published as a standard until [January 1998](https://www.ietf.org/rfc/rfc2279.txt)... almost a year after Java 1.1 was released. `FileReader` and `InputStreamReader` were added in Java 1.1. And once a default is set, you can't change it without breaking things. .NET got away with using UTF-8 by default simply because UTF-8 was the standard by the time .NET 1.0 came out in 2002.
Yes this exactly. I use it at work, quite like it. But seems obsolete now.
Ours is "rainbows and smiles -- she doesn't even go here!"
Trivia: The name FigWheely comes from Figwheel, a plugin used for interactive development in ClojureScript.
Because 999 times out of 1000 it does exactly what I need and that 1/1000 edge case has already been solved at some point. 1/100000 it hasn't. 
The article does not provide a simple code example or at least a description, which serialization / deserialization steps were going on. I am a bit disappointed to be honest; the *mystery* why a pi char can magically duplicate itself remains. That said it is a must to be as explicit as possible about the encoding used to decode inputs to your program and encode outputs from your program. Using the platform default is one of the worst ideas ever! (And me beloved Python 3 repeated this in 2008 iirc... 😓)
&gt; When I took these findings to the support engineer I was working with, the first comment was “but μ is an ASCII character”. That’s true, but Java uses US-ASCII which is a 7-bit encoding and doesn’t contain μ (which is in the extended ASCII set). OK, so the article's author and their support engineer *still* don't understand character encodings. No surprise this happened. The amount of ignorance about this topic among even otherwise experienced developers is breathtaking.
Oh yes, this was a small puzzle but it wasn't too difficult to figure out from the description. It seems like the problem was that code was writing strings by encoding them in UTF-8 but then reading them by decoding as US-ASCII. You can simulate this by using the `String.getBytes(cs)` method and the `String(byte[], cs)` constructor. For example: String s = "\u00B5"; // the mu (micro) character byte[] ba = s.getBytes(StandardCharsets.UTF_8); // c2 b5 s = new String(ba, StandardCharsets.US_ASCII); // \ufffd\ufffd The code point U+FFFD is REPLACEMENT CHARACTER which is what you get if the decoder encounters an invalid byte sequence. US-ASCII is officially 7 bits, so both c2 and b5 are invalid bytes, thus both decode to U+FFFD. Now: ba = s.getBytes(StandardCharsets.UTF_8); // ef bf bd ef bf bd The sequence `ef bf bd` is the UTF-8 encoding of U+FFFD. s = new String(ba, StandardCharsets.US_ASCII); // \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd There are **six** invalid ASCII bytes, so we get six instances of REPLACEMENT CHARACTER. You can easily see that a "round-trip" of encoding using UTF-8 and decoding using US-ASCII will result in the geometric growth the OP observed.
**Extended ASCII** The term extended ASCII (EASCII or high ASCII) refers to eight-bit or larger character encodings that include the standard seven-bit ASCII characters, plus additional characters. The use of the term is sometimes criticized, because it can be mistakenly interpreted to mean that the ASCII standard has been updated to include more than 128 characters or that the term unambiguously identifies a single encoding, both of which are not the case. There are many extended ASCII encodings (more than 220 DOS and Windows codepages). EBCDIC ("the other" major 8-bit character code) likewise developed many extended variants (more than 186 EBCDIC codepages) over the decades. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^] ^Downvote ^to ^remove ^| ^v0.23
Why not just Vaadin?
The thing i like about html/css/js is that i dont havrle to recompile my application while i play around with the ui, i only have to reload the tab. But that could be just my bad habit of trial and error. 
Brilliant book, but a bit outdated. I'm using Java for less than seven years and cannot say I've approached advanced proficiency. Still, I haven't found anything in this book that helped me to become better. Most of the tips are based on switching from pre-Java-5 idioms to related idioms based on Java5/6 features. And if you started your career from Java 6, all of them are already obvious to you. Hope for something like this but more modern to be published soon.
And this one is great. Must-read even if you don't use concurrency on a daily basis.
Front-End Java ... so many tried it... Maybe you could look into Typescript. It is not Java but, depending how you use it, it can feel very much like Java. Typescript can be a soft entrance for Java-Developers into the JavaScript-World. 
Ok, first of all sorry for my harsh response. I guess I was having a bad day. However, you should really rethink how you communicate on the Internet: &gt; you must realize I am in no position to [x] because I am not [y] / I have no [z] No I must not. I don't know you. I don't know what you are not, nor what you have not. **You should stop expecting people on the Internet to be prescient about your personality and motivations**. The only neutral element available to others to judge your post is... well, your post itself. What you write in it and _how_ you word it is very important when it comes to others seeing your post in a good or a bad light. &gt; My question was worded the way it was And it was a *really* bad way. Re-read your post like it was from someone trying to learn to play DOTA. Not really kind, huh? Actually, **your post was almost the exact opposite of "_what can I as a Java beginner practice on?_".** Hence my anger when, on your reply, you tried to tell me that you had asked the contrary of what you did. You _may_ have wanted to ask that, I give you that -- but you didn't, and as I said before I'm not prescient. &gt; I want to thank the rest for a productive discussion. You, meanwhile, should continue your troll witch hunt elsewhere. I think my first comment (browser support, uses of Java in corporate etc.) was actually very fair; you even thanked me for it. If you decide to disregard that just because I called you out, that's your decision. &gt; People like you are the reason I was forced to write the way I did I can't see how people like me are the reason you wrote **350+ words** of Java dissing in a Java forum, but if it makes you happier, then sure, it was my fault. ---------- TL;DR Ever heard the saying "You catch more flies with honey than with vinegar"? Next time you want to get help from people who like a thing, just ask for help nicely, instead of wasting your effort in dissing said thing.
Just adding the last vote results https://jcp.org/en/jsr/results?id=5959 and highlight the only abstained vote from Red Hat &gt; On 2017-06-23 Red Hat voted Abstain with the following comment: &gt; &gt; Red Hat is voting **Abstain** at this time because although we think there has been positive progress within the EG to reach consensus since the last vote, we believe that there are a number of items within the current proposal which will impact wider community adoption that could have been addressed within the 30 day extension period for this release. However, we do not want to delay the Java 9 release and are happy with the more aggressive schedule proposed by the Specification Lead and EG for subsequent versions of Java because getting real world feedback on the modularity system will be key to understanding whether and where further changes need to occur. We hope that the Project Lead and EG will continue to be as open to input from the wider Java community as they have been in the last 30 days and look forward to the evolution of Java being driven by data from users and communities beyond OpenJDK. &gt; &gt; We would also like to take the opportunity to thank the EG, the Oracle Specification Lead and others who assisted in the numerous meetings which have taken place in the last 30 days. This increased collaboration and positive approaches to discussing and resolving issues has been welcomed by ourselves and the wider Java community.
Might want to wait for the 3rd edition, (October 2017, according to the publisher - (https://www.amazon.com/Effective-Java-3rd-Joshua-Bloch/dp/0134685997)
Is there an overview somewhere of the key changes between the original (rejected) proposal and this (approved) one? 
With Java, Java EE.
Explicitly setting the CharSet would have avoided this issue (though would be a pain to refactor all `new String(byte[] byes)` uses). I can imagine the backlash of deprecating the API which uses the default charset would be large. Using UTF-8 as the default always would be great (and this is what I initially thought was the case), but even that could have unexpected results in the future. The bottom line is that going into this I didn't understand the default encodings, how the defaults were set, and what the ramifications were. Now I have a better understanding.
Sorry about not adding any code examples, I will definitely add some in any other posts I write. Below are a couple samples of what I initially tried and what helped discover the issue: // Pull, serialize to a JSON string, then recast to a Java object SerDeStrategy jsonSerDe = new JsonSerDeStrategy(); Element element = getElementFromDatabase(); String json = new String(jsonSerDe.serialize(element)); // This string method uses the default CharSet Element recontructed = jsonSerDe.deserialize(json.getBytes(), Element.class); // Check for invalid characters which appear if the default encoding is US ASCII SerDeStrategy jsonSerDe = new JsonSerDeStrategy(); Element element = getElementFromDatabase(); String json = new String(jsonSerDe.serialize(element), "UTF-8"); // Explicitly set the string encoding Element recontructed = jsonSerDe.deserialize(json.getBytes(), Element.class); // No invalid characters Casting to a string and then getting the bytes from the string is necessary to force corruption with the bad encoding. Serializing to a byte array and back will not corrupt anything.
There are tools that will flag all instances of such encoding-dependent calls and you can use structural search-and-replace to fix them in one go.
Working Effectively with Legacy code is great. It's not specifically a Java book, but I've found it very useful. https://www.amazon.co.uk/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052 
Oh cool. Silly me, indeed it's right there. Sorry. Did you remove the post altogether or will it sit somewhere the monument to me not paying attention? Thanks for being reasonable! 
I wonder how fast industry adoption will be compared to Java 7 -&gt; Java 8.
I've removed the post. You might want to post the survey in /r/programming or in /r/learnprogramming. These subs accept surveys (even though I have to warn you that surveys are generally not too well received).
Using Thymeleaf, mostly because of Spring.
Or if it'll be another excuse for companies to stick to Java 6 until the inevitable remote code execution exploits run rampant.
To clarify, that was the original vote that ended May 8th. Here are the results (and comments) for the latest vote that ended June 26th: https://jcp.org/en/jsr/results?id=6016
gotcha, thanks for the advice! 
Alright, well thanks so much for staying around and helping me. It's much appreciated :)
Well, we're already through with the tax form, but it is literally a Java window, not JS, trust me. You open the page, waaaaaait, then a grey area appears, you waaaait some more, then several security prompts pop up, you waiit, click on and it slowly loads a a window within a window. Only on Safari and IE
I don't believe I am mistaken and you confirmed that I am not mistaken. Web Start should be started in the browser, however, due to some security issues, Chrome will not autorun the application and instead it will just download it (not supposed to happen). My goal here is to streamline the usage of my app. I would like my end users to not have to download and run things on their computers because it adds a level of hassle that I would like to stay away from. For the time being I have chosen to serve users the app through an HTML front end communicating to a Java server running the app on the back end. Thanks for the input.
&gt; Web Start should be started in the browser, however, due to some security issues, Chrome will not autorun the application and instead it will just download it (not supposed to happen). Web start should not be started in the browser. Just like a browser probably has an executable associated with the ".zip" extension (usually via whatever mechanism the host operating system provides), browsers have an executable associated with the JNLP extension. That executable is "javaws" (java web start). When the browser sees a file with a jnlp extension it can execute javaws. The "javaws" executable then takes over (outside of the browser), and it is javaws that will download, install, then run the application. For whatever reason Safari and Chrome developers have decided that it is a security concern to have the browser execute "javaws" automatically when it sees the jnlp extension (I have no idea why this is seen as a security concern). So both of those browsers just download the jnlp, then users have to go double-click on it. That is great your app will work as a web application and you are going that route; however, please don't spread wrong information about web start. 
when you work in the real world you don't get to just 'understand the problem' and that's it. in the real world when you inherit a code base you most certainly must understand the behavior and then implement new features and fix old bugs and make the software perform better .. that's the job. and to do that job competently and effectively you *MUST* understand the impl details .. that is solid fact and not opinion
Hi Stuart, do you know of any plans to make it possible to change the default charset after the JVM has started? [This stackoverflow question](https://stackoverflow.com/questions/361975/setting-the-default-java-character-encoding) suggests its not possible. Is this a fundamental restriction? I usually do something like this as the first thing in my `main`-Methods (or equivalent): TimeZone.setDefault(TimeZone.getTimeZone(ZoneOffset.UTC)); Locale.setDefault(Locale.ENGLISH); Security.setProperty("crypto.policy", "unlimited") It would be nice to default the charset there as well. Oh, and thank you so much for your work on Java, it's getting better all the time! :)
Desktop: JDownloader, Jetbrains IDEs, Netbeans, Eclipse
Swing scaling will be a big benefit for me, but then again I don't write server side software like most seem to...
Probably comparable to moving from Python 2 to Python 3 
Interestingly, you can do exactly the same thing with Swing. Back in the olden days when I developed Swing apps, I would add a main method to my JFrames and my JDialogs and just hit run from Eclipse to popup up the window or dialog so I could fiddle with it and experiment with ideas without having to recompile the entire app. 
Everything has issues. You have to install the JRE because without it you can't run Java anything. Running everywhere works because you install the JVM which is what Java runs on instead of your program itself having to be compiled for every architecture like C++. It's another layer between the program and the hardware. It's a little naggy, but no more than any other updater and it largely does so because unless you tell it to it won't auto-update. You shouldn't compare the desktop and browser experience. Imho the latter was never a good place for Java. There also a number of file access and security dilemmas in the browser scenario that aren't an issue afaik on the desktop. As somebody else pointed out Eclipse and JetBrains product are very good IDEs. Minecraft was and is very popular and for a long time had some aspects that made it very obvious that Java was in use. The same developer was also responsible for something called Wurm Online. I suspect there are a number of obvious reasons for Java not being used in games which run the gamut from not being the industry standard to issues with library availability and interaction with native libraries. Originally Java was used for early mobile games
The same could be said of almost any language. Novelty has no intrinsic benefits and what's trendy now may not be next year or a year from then. There has also been a lot of growth in web services. I think you'll find that none of those are replacing Java so much as expanding into areas where Java isn't necessarily applicable.
I don't really think it's novelty, but more that programming languages are generally becoming more specialised and certain paradigms are becoming far more popular as the improved hardware allows more inefficient styles to become practical. This causes languages that have been built from the ground up to support a single paradigm, a la Java and OOP, to fall out of favour a bit. Take functional programming for example, it falls flat in a few areas like game development, but it makes for a far better programming experience IMO, which ultimately leads to better software. Constantly assigning variables where they aren't *strictly* necessary is relatively expensive, but it reduces headaches a lot. Same with immutability, if you create new instances of an array when you iterate over it you can forget about messing with another part of you application that would otherwise have been holding a reference to the same array. Other benefits include greater reusability, composition over inheritance, pure functions with no side effects, etc. Most of these come with a greater computational cost but tend to produce more stable code. The flexibility of languages like Node allow people to switch it up and effortlessly change programming styles without having to learn an entirely new language, and it's for this reason, amongst the other mentioned above, that I think Node will overtake Java. I don't think it'll happen in a year, but I think it'll happen. For me personally, I almost always take Node over the competition. I write Java, Objective C and Node at work. Always prefer working with Node for the aforementioned reasons, but that is just my opinion.
There aren't any plans to allow changing of the default charset. It's not supported to change the value of the `file.encoding` property, even from the Java command line. (Although people do this anyway, apparently with moderate success.) The fundamental problem is that the default charset is initialized quite early, and changing it -- even from the command line -- results in different pieces of the system having different ideas of what the default charset is. This can mostly work, or it can lead to havoc. Initialization order can shift around quite a bit from one release to the next, so even if things mostly work in one release, they might break in the next. A definitive word on the setting of the default charset, and the setting of the `file.encoding` property, was given by Mark Reinhold in his evaluation of [JDK-4163515](https://bugs.openjdk.java.net/browse/JDK-4163515?focusedCommentId=12567794&amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-12567794) way back in 2005: &gt; This is not a bug. The "file.encoding" property is not required by the J2SE platform specification; it's an internal detail of Sun's implementations and should not be examined or modified by user code. It's also intended to be read-only; it's technically impossible to support the setting of this property to arbitrary values on the command line or at any other time during program execution. &gt; The preferred way to change the default encoding used by the VM and the runtime system is to change the locale of the underlying platform before starting your Java program. On a Mac, at least, you can do this by setting the LANG environment variable. If you have a one-liner program that does System.out.println(Charset.defaultCharset()); you can easily try out different values of the LANG variable: $ java CS UTF-8 $ LANG=C java CS US-ASCII $ LANG=uk_UA.ISO8859-5 java CS ISO-8859-5 $ LANG=zh_CN.eucCN java CS GB2312 I found the list of locales by looking in `/usr/share/locale`. Incidentally, this might explain why the OP's docker images use US-ASCII. The base docker image was probably quite minimal, and whoever configured it might have thought, "We don't need all that internationalization stuff" resulting in the default locale for the system being the C locale, which for Java gives a default Charset of US-ASCII. (This is mostly speculation on my part.) 
&gt;However, we do not want to delay the Java 9 release **and are happy with the more aggressive schedule proposed by the Specification Lead and EG for subsequent versions of Java because getting real world feedback on the modularity system will be key to understanding whether and where further changes need to occur**. Wasn't that what the spec lead said from the very beginning? That it was better to get feedback from the real world by following a simple model than following a OSGi-like path with no point of no return? Seems to me that they finally got it.
Yep. As you mentioned in another comment, that pesky `String(byte[])` constructor uses the default charset, which can lead to the problems you observed. But note that `String.getBytes()` **also** uses the default charset, which can lead to data loss/corruption, though it might not result in a geometrically expanding string. For example, byte[] ba = { (byte)0xc2, (byte)0xb5 }; String s = new String(ba, StandardCharsets.UTF_8); // string containing the mu character OK so far. But suppose we were to call `String.getBytes()` in a JVM whose default charset is US-ASCII, or if we were to call it with an explicit argument: ba = s.getBytes(StandardCharsets.US_ASCII); // 3f Since U+00B5 cannot be represented in ASCII, the replacement byte sequence is used. It happens that the replacement sequence is a single byte `0x3f` which is the ASCII value for `?`. (Strictly speaking the behavior of `getBytes()` is undefined when the character can't be represented in the default charset, but using replacement bytes is common for encoders. See the [CharsetEncoder](http://docs.oracle.com/javase/8/docs/api/java/nio/charset/CharsetEncoder.html) class.) Anyway, the upshot is that you should always specify the charset explicitly in **both** directions, from String to byte[] and vice-versa.
I stand corrected.
Have a look at spark java and drop wizard. They're fairly lightweight and easy to get started with.
There's always one who breaks the pattern...
Assuming windows, right click - open with. Choose other or browse for more. Select what you want and check the option - use application as default 
Shit its 2017 and I still like Wicket
We don't use service loader because order matters. One converter can delegate to another (same for call adapters) and for that to work correctly we need ordering guarantees.
and I answered you- java.exe which can be located in the directories I mentioned. The location will be different based on which version and which architecture you have installed.
Oh ok, thanks for the help! I really appreciate it!
On the Builder pattern: we started making our Builder instances final and immutable, too. This requires additional constructors, but they can be kept private and thus hidden. It results in fast creation of small, short-lived objects. Adjust the JVM's garbage-collection ratio accordingly.
&gt; (The downvote button is not the "you're an idiot" button, ok? If you think I am such then just comment it.) This is not a tech support subreddit. Your question is not about Java programming nor "News, Technical discussions, research papers and assorted things of interest related to the Java programming language" (read the sidebar). It's a question about opening files in Windows, thus does not belong here, and thus is downvoted.
&gt; This leads to long package names, which does not convey much. Strip down groupId from your package name to keep package names short and easy to remember. Your import statements will also start looking much more readable. You need to develop your understanding of this practice. The package naming convention is specifically engineered to mitigate ambiguities. "Long package names" is not a problem but ambiguities are. &gt; I believe this is something Java community learnt from Python and JavaScript communities. And now the Python community has problems with name-squatting.
&gt; The downvote button is not the "you're an idiot" button, ok? No, but it is a "please read the sidebar before posting" button ;)
My fear is that if a lot of standard libraries are making the switch, you're somehow forced to go along to keep the whole modular magic working.
Don't use Java, use 7-Zip. :)
This is a classic question for **/r/techsupport** rather than for here.
I've learnt using Spring and Spring Boot effectively by reading the source of the spring-cloud-commons project. Very easy to understand and nicely documented. Maybe I should write a blog post too :).
/u/Zwordiak 
Stripping the groupId is a very bad idea especially with generic names like Retrofit. If hope others don't follow that example.
JSON is one pivot which is stored, yes.
Nail is faster to use.
JavaFX for Dummies That book really helped me make the switch from Swing/AWT to JavaFX. You can skim through it in a day and gain enough of an understanding to start writing basic GUIs.
You mean a Java Applet embedded in web pages? Applets are obsolete and probably shouldn't be used. They went out of favour in the late 90s early 00s and haven't been well supported for about a decade. The applet tag is already obsolete and the Java browser plugin has already been nixed. In fact, the reason why it only works on Safari and IE is that Mozilla, Chrome, Microsoft Edge, have all removed plugin support for their browsers. Another thing, Java has never been particularly strong on user interfaces. It's real strength is hosting services. It's basically the workhorses for the internet. Again, this isn't indicative of the language itself as a whole. If you put a language in an environment that it wasn't designed for and has no official support from any of the people up river then it will always be terrible. Here are some example: LinkedIn is primarily written in Java Facebook's HBase is written in Java. That's the messaging platform. Large chunks of Ebay and Amazon are written in Java. 
recently i did a very simple args parser &amp; validator for one of my projects. was too lazy to search for an existing lib. but next time around, i am def. going with one of the tools described in the article.
Just configure it. Eclipse uses gtk, you can modify gtk theme if you want. Search on Google "eclipse gtk theme" if you want to see how eclipse will look before changing to that theme. It's the gtk2 theme, maybe you will need to install something in you distribution to customise it.
The new, extensible Generic Editor looks nice. Supposedly it makes adding support for new languages / syntax easier. Hopefully this is true (for example, currently there are no plugins in Eclipse for React's JSX, maybe with this it will be easier to implement it)
The Well grounded Java Developer
Try a proper IDE, IntelliJ for example.
Thankfully, Eclipse does incremental compilation even with the maven plugin. As of now, Maven does not support incremental builds.
Here's an interesting thought exercise: For those who remember it, what does kotlin bring to the table that fan(tom), or for that matter, groovy, did not? "It's just a little bit newer"? "This time a bigwig company threw its weight behind it (android/google)"? "This time IDE support is actually good"? Specifically: Consider the long line of 'let's do java but better' languages. There are some highbrow attempts in the form of Scala, Ceylon, and Clojure. There are also some decidedly more kotlin-esque attempts, which really just add some syntax sugar and that's about it: Groovy, Fantom, and in some sense JRuby and Jython. I'm pretty sure we can consider all of those a failure: Their growth curves have topped out at fractions of java's user base, or are in fact heading down to 0 again, and there's nothing on the horizon for any of those languages to indicate their ascension to the mainstream is eminent. So, if kotlin is worth adopting, what, exactly, does it bring that these languages didn't? Fantom seems like the closest match, and that definitely didn't go anywhere, fast. So what's new? I can think of rather a lot of cool technology that truly would be groundbreaking, in the sense that none of that long list of languages took it seriously. Kotlin has exactly zero of these, and especially from an IDE builder I would have expected a bunch of these. Off the top of my head: * A pluggable language. Like annotations but much more impressive: Where plugin code can run as the compiler does its job, generating code, running linting tools, and even parsing entirely new constructs. Imagine typing regex literals naturally, with the IDE giving you auto-complete support for back references and highlighting them on the fly, in a way that is inherent to the language itself (not that you have to build plugins for every tool to make it work right), or for example making a DSL for a GUI layouting toolkit where you can draw ascii art (or better yet, draw straight up). An IDE builder would no doubt find this intriguing. Unfortunately, no go. * Language itself is versioned. Added some syntax that in retrospect seems like a mistake now? Okay, just.. stop supporting it. You can do that without breaking backwards compatibility if this requires you to put the actual version of kotlin you wrote this source file for, at the top. Imagine all your java files started with 'source 1.8;' and only if you did that, would you be allowed to use lambdas. You can now just plain ditch various mistakes in language design and nothing breaks because files with 'source 1.7;' at the top would still work out fine. You can even write tools that automatically upgrade your source from 1.7 to 1.8, refactor-script style, where the IDE will tell you where some human choice is required to do a good job at it. Now we no longer have to live in this world where people get all antsy for a new language every 5 years. Scala REALLY dropped the ball on this (Scala now has foldLeft imported by default, which, well, if you say 'accumulator' you lost the parallelization game, ironic for a language named 'scala', and it also has XML literals which seems a bit quaint at this point. No way to get rid of em without breaking backwards compatibility, because scala doesn't have this). * A way to expose APIs to the outside system that are different in structure than what you actually use. If you want to talk to other JVM-targetted code and you want to transfer a list, well, either you put it in terms of java.util.List, or it's not gonna work, because no java code is going to read your kotlin.ImmutableList or whatnot. Unfortunately, List in particular is a crappy interface: It's got a .set () and .clear() methods and such, which you really don't want to see in your autocomplete dialogs. Kotlin seems to just cop out here: They've got their own types, so you CAN interop with java, but only if you wrap everything. I can imagine various language-based ways to make that process automatic, so that external parties see java.util.List, but internally those set and clear methods simply do not show up because internally the system knows those aren't designed to be mutable. * A language that can be parsed hierarchically; just about every line is unambiguous and thus a file can be parsed as individual pieces. This means individual pieces are cacheable (which speeds things up considerably, which is nice if you want your IDE to reflect changes to the code as-you-type and not as-you-save, or, worse, after-the-mvn-run-that-takes-5-minutes), and error messages when you make typos or semantic errors are much better. Such a change would involve language rules that unmatched parens/brackets/braces are always dealt with first and take spacing into account (just an example; note, spacing only relevant if the file is guaranteed to be syntactically invalid, and only to come up with better errors), and rules such as: Type names MUST start with a capital, and package parts MUST start with a lowercase letter. If you're not a compiler/parser wonk this is a bit hard to grok. Colour me disappointed. My bet: Hype. Give it 2 years and kotlin will be as familiar to programmers as fantom is today. I kinda hope that's how it goes, because surely 'we' as a programmer community can think of something better than this tepid helping of syntax sugar if we're going to go through the trouble of changing language. 
[removed]
Dark theme does not look correct in Windows 10. They've had years to fix it with no massive improvement in quality of it. The tables still use jarring white borders (which dont align exactly with header borders) and more than a few icons have white pixel backgrounds which are distracting. Eclipse has done some soul searching, but at this point its really showing its age as well as weight. Lighter cross platform toolkits like React Native are not as feature full, but they get the job done and look way better doing it both in development and in production. I don't have a good feeling for them. Anyone interested in knowing what a real dark theme should look like, check out just about any other editor out there (MS Code, Sublime Text, Intellij etc)
I wonder if these are covered: 1. Hitting backspace tabs back, instead of having to hit 4 backspace 4 times. 2. Line-spacing in the editor: lines are way too tight.
It looks way better because it gets attention from RedHat. I'm jelly as a Windows user.
Actually...yes. The first is verbose, but it's very clear what it's doing. The second one is unclear to me what it's doing. I'm unfamiliar with the syntactical pattern, true, so maybe with practice it would become more clear. But I'm just not seeing the advantage there other than saving a few lines. 
**Mind your language** You should be able to express your opinion without using expletives. **Comment removed**: foul language
Sure. But as you said there are *two* invariants you have to be aware of. With base64 you are safe out of the box - with the drawback that is looses human readability. But for that an encoded document should be the preferred way 😉
At this point it would probably be better to rewrite Eclipse completely. The gap between IntelliJ and Eclipse has become ridiculous, and Eclipse is innovating at a snails' pace.
yada, yada, yada :P I see strong correlation between people that use Eclipse and who find PHP, NodeJS and BASIC mature production environments! :P (love and kisses!)
This is the first time I see someone complaining about long package names. I mean, where's the issue?
&gt;That it comes from academia is no surprise. This is something I see repeated everywhere but never backed up. What about Scala suggests it's a research language? It's grounded in the existing ML-style languages, and every feature in it has appeared in something else before. If you were talking about Idris or Coq (both of which introduce major new language features) then I'd agree, but Scala strikes me as a very commercial language more than anything else. Or are people just using "comes from academia" as another way to say "confusing to me"?
It's already great, it's just getting better :)
Don't forget Atom, I love Atom. :D
They should dedicate a whole release cycle to finally create a proper dark themed UI. Otherwise they just can't be taken serious these days. [Eclipse Horrorshow](http://i.imgur.com/EavoEXY.png) (yes this is the newest Oxygen, the preferences dialog looks even worse) I think the Eclipse IDE shows the limitation of open source development. In a full year they managed a changelog that [others](https://blog.jetbrains.com/idea/category/eap-releases/) do in a month. &amp;nbsp; *Disclaimer: Using Eclipse at work, developing an EclipseRPC application.*
I love the dark theme on Windows 7. It was a shame it took them so long to fix the couple bugs like poor highlight color on search.
Woah watch out where you're headed right there buddy
Pretty free for use unless you run/work at a business. If the business can't afford it - that's a whole different set of issues...
Community edition is free, and good enough for plain Java. I've switched back and forth several times between these IDEs, due to changing teams. Currently I'm in a mixed team that allows intellij, and hope I won't ever be forced to use eclipse again.
Again,no Spring, Java EE support, which I need. Trust me its great otherwise.
I'm coding spring with Community, don't really see the issue here. Adding @Component to a class, and @Autowired to an constructor every now and then isn't so bad? JEE I don't know.
Well...
Inverted snobbery. It's "comes from academia" so it can't be a proper language. I posted this in response to a similar criticism sometime back: &gt; Java was designed by James Gosling ([Computer Scientist](https://en.wikipedia.org/wiki/James_Gosling)) and Guy Steele ([Computer Scientist](https://en.wikipedia.org/wiki/Guy_L._Steele,_Jr.)). Python was designed by Guido van Rossum at a Dutch research institute. C++, designed by Bjarne Stroustrup ([Computer Scientist](https://en.wikipedia.org/wiki/Bjarne_Stroustrup)), F#, easily the best programming language that MS has ever produced, designed by Don Syme ([Computer Scientist](https://en.wikipedia.org/wiki/Don_Syme)), Haskell - Phil Wadler ([Computer Scientist](https://en.wikipedia.org/wiki/Philip_Wadler)), ML - Robin Milner ([Computer Scientist](https://www.theguardian.com/technology/2010/apr/01/robin-milner-obituary)). &gt; Meanwhile, in the industry-designed languages column we have Javascript, Visual Basic, and Perl, three of the most badly-designed languages ever to grace a computer.
2 Of my Favorites: https://shipilev.net/ https://vanilla-java.github.io/
No it is not, it is nothing to do with class (or abstraction) as oop concept but rather a scope concern, even defined with same "class" keyword. It is supposed to be a collection of static methods, random or not random up to you.
It does. Gradle too. If the project doesn't show up as a Maven project right-click the pom.xml and select 'Add as Maven project'.
&gt; it is nothing to do with class (or abstraction) as oop concept but &gt; rather a scope concern I'm saying there are situations where it *should* be an oop concept. There's an abstraction hiding in the mixed bag of static methods in the util class which would be better off expressed as a proper abstraction so that the system is easier to understand because it is *systematic*. &gt; It is supposed to be a collection of static methods, random or not &gt; random up to you. I'm saying that *random* collections of static methods are usually a design smell, because it usually means the design has not been thought out. *StringUtils* is good, *AppUtils* is not so good.
That doesn't really seem to address the substance of my comment. Why do you think it has been designed in academia any more than Java, C++, or any other language?
What is wrong with it? I am using both sts and cevelop on ubuntu and there is no differences with windows versions.
Unlike some of the haters, I like eclipse, but there are two things that are simply terrible about it. JSP and JavaScript files just crash Eclipse frequently enough I've switched to Brackets for web development. Does anyone know if these editors work properly now?
**Scala (programming language)** Scala ( SKAH-lah) is a general-purpose programming language providing support for functional programming and a strong static type system. Designed to be concise, many of Scala's design decisions aimed to address criticisms of Java. Scala source code is intended to be compiled to Java bytecode, so that the resulting executable code runs on a Java virtual machine. Scala provides language interoperability with Java, so that libraries written in both languages may be referenced directly in Scala or Java code. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
When are these morons going to slow down these ridiculously long example gifs and put a fucking pause between when they start and stop. Better yet, just make them a video. Whoever has license to publish on this blog needs a cock punch for not hallway usability testing on someone that has no idea what these features are already. 
It supports spring as much as Eclipse or Netbeans supports Spring, which is to say it 'supports' annotations and Java.
Why does the default font on their blog always looks so much better than the default font in my IntelliJ? /sadpanda
Oh right, that's what you're expecting. Ctrl+Alt+L isn't supposed to add any imports, just clean up and re-order the existing ones. I don't know of an action that automatically adds all missing imports (that's not to say there isn't one) but IntelliJ generally indicates strongly when a class isn't defined and gives you the options to import, create the class etc. by highlighting the missing class name and hitting Ctrl+Enter. If you paste in code with undefined classes it will show a dialog with the imports it suggests and you can hit Enter to accept them all.
Ya, node.js! Only idiot Mom-and-Pops like Netflix and PayPal use that!
&gt; JSX Copyright © 2012 - never heard of it.
Upvote for cock punch. LOL
&gt; I like eclipse &gt; JSP and JavaScript files just crash Eclipse frequently I don't get this at all. Its an ide it crashes when editing files; your experience of it is bad, yet you still like it. I used it for ten years, switched to intellij, never looked back.
[yeah looks like this](http://imgur.com/a/dCUU2)
yeah im thinking its the files I modified since my last push, that would make the most sense
Import suggestions are extremely laggy in oxygen for me, but weren't in neon :/
I feel like this is an alternative to... coding like a caveman! Why did these features take so long lol 
At this point I'm not sure if any amount of configuration will properly scale elements for HiDPI. Even with this release half the things scale properly and the other half don't, often within the same tree widget. Turning off theme support make it a little more sane.
I've been an Eclipse user since, oh, around 2003. But the delta between yearly Eclipse releases is smaller than the delta between quarterly Intellij releases. I haven't switched yet because 15 years of inertia, but the writing is on the wall. Also, Kotlin. Because I'm getting damned tired of Java's extra-verbose boilerplate verbosity that takes 25 verbose keywords and classes and methods to verbosely express what Kotlin does in 6. Also Java is too verbose.
should've read a cookbook on how to write code samples in a blog correctly. This is just a hideous wall of mashed up code that I refuse to look at. 
Videos, preferably. This page is over 22MB because of all the gifs.
That is a shame. Out of curiosity, where do you work? Do you find the individual license still too expensive, or only the business license? I live in a developing country &amp; even I think IntelliJ Ultimate's individual license is pretty cheap ($149 for 1st year, $119 for 2nd year, $89 for 3rd year onwards)
You should just switch. Honestly! It might take some getting used to, but you won't look back.
If the only thing you miss in a car in 2017 is power steering, you are probably using the best car out there!
It's syntax for writing (web, mobile) UI using Facebook's React library
Its some js magic, to include html into js, to make reusable components
Only on high pixel density screens. Fonts on Windows and Linux have far better hinting, so they look better on screens with lower pixel density. Edit: Here is a nice comparison with screenshots: https://blog.codinghorror.com/whats-wrong-with-apples-font-rendering/
That's probably just the web dev plugin that's crashing. Eclipse as a whole is very stable. It hasn't crashed for me even once in the last 10 years of regular use. I have only used the JDT and ADT (Java and Android development tools) though.
Maybe because he uses Eclipse mainly for development of other kind of files, like .java, ocassionally touching this kind of files. I'm in a similar situation: Being a JEE developer, most of my work is on .java files, and I hate how the application handles XML files and the lack of proper support for scss files.
This is stupid and it shows how little the votes matter that this comment has twice as many up votes as any other on the post.
That was 10 years ago; is it still the case now?
 Have an upvote because if you question anything JetBrains does on the java reddit people attack you. A quick google search yields something like "video mode" from http://rubentd.com/gifplayer/ that might work. I have definitely seen better gifv players with full video control functionality as well.
Why is the dark theme so important to people? 
&gt; Don't forget Atom Only if wasn't slow as hell.
Yes, it is. Apple's font rendering is all about kerning and trying to make everything look like it's printed, but the font antialiasing is still bad, you just don't see it on screens with high pixel density.
[sigh](http://imgur.com/a/sf10H).. has anyone an idea what the message said? Anyone who was able to read it? 
The beta was pretty buggy for me so I'd say hold off until 1.19.0 has a stable release but I am hoping it will resolve peoples performance complaints that I just have not experienced.
Your workspace is in an older format. You can click OK to convert it to the newest format, but you will not be able to open this workspace with older Eclipse version anymore.
Yes. You do. It doesn't need to be populated though...even just an empty file named beans.xml will work. 
Why do people hate JavaEE so much, to the extent of voting any story that mentions it down. JavaEE is a standard and is part of java ecosystem. This is a Java Forum. If you want to use Spring , may I suggest go to https://www.reddit.com/r/springsource/ instead where i'm sure any mention of JavaEE will be voted down in the same way.
Try Shift+Tab. Tab to indent, Shift+Tab to unindent. 
JavaScript support is awful in Eclipse in general. I mainly moved to IntelliJ because no matter what I did to the JS formatter settings I couldn't get it to honour our eslint formatting. E.g. It would mix spaces and tabs even though I had it set to use only spaces. 
Instead wait way longer to run apps in IntelliJ. Also the Eclipse keybindings are very bad and not very similar to the actual Eclipse keybindings (and last time I filed a bug about it no one seemed to care) I like IntelliJ a lot, it works much better than Eclipse for non-Java but for Java everything feels so clumsy and slow. The Maven integration is also very bad :(
ah! thank you
1 - how do you know what I think? 2 - what's your point?
Some people find darker screens easier to stare at for 8 hours straight. 
It crashed Alien Blue. Fucking use videos FFS.
I would switch to IntelliJ in a heartbeat if it allowed multiple projects in the same window. Creating one "large" project with smaller sub-projects all in the same window isn't *quite* good enough for my needs, unfortunately.
Everything on my machine is themed dark. I find it a lot easier on my eyes.
Why doesn't anyone have eyes?
&gt; the more important lesson is: make sure you support UTF-8 in all parts of your system. This is *so wrong* that I would like to puke. UTF-8 support is present everywhere nowadays; however, if you don’t specify the charsets in most of Java’s ancient I/O handling system you deserve every ops alert you get at 3 am.
Penguins. I dont even know... Brain decided to be weird this morning
https://github.com/brettwooldridge/HikariCP is good.
For the plugins, this used to work, maybe still does: https://stackoverflow.com/a/10494974/14379 You should be able to export your main settings to an XML file too. Used to be in the File menu, under Export.
Instead they just waste time half fixing it every few months. Much more productive!
That's interesting because I am the exact opposite. I can't stand how Eclipse forces you to have a single workspace that has all your projects in it. I much prefer a project-per-window style.
Eclipse Members: https://www.eclipse.org/membership/exploreMembership.php#allmembers Among them are IBM, Intel, Microsoft, Google, GitHub, SalesForce, ZeroTurnaround , etc. I notice Apple, Facebook and Twitter are not on the list, Apple I can understand. 
Its more **readable** /s
Thanks for sharing!
I turned validation off (apparently it's not what I think?) and the lag went away So idk.
As far as I know you don't need it with CDI 2.0.
Having an enum vs hardcoded int is almost the same, but the enum wins in explicitness, it is type safe in the java side, and does not needs join. 
build a firewall and make intellij pay for it!
He didn't say anything of the sort.
I have been using Grails for some years now but recently I have been hearing rumblings (twitter, blogs, etc) that said JavaEE 7 (and the forthcoming 8) is actually pretty good. So a handful of weeks ago I checked out Oracle's JavaEE 7 tutorial and I must say I am impressed with what I saw, seems much improved over when I was using it before in the 2004-2010 timeframe (was called J2EE then). I am now questioning if I need Grails at all. 
There's arguments to be made going either way. Using the enum ordinal will likely make selects faster and result in smaller rows. However, if you're worried about select performance you're probably not going to use JPA and just send SQL over JDBC and do the ResultSet mapping yourself. Using the enum name does give you a bit of readability when looking at the tables yourself. There's no need to look back at the source code to remember if 0 is `IN_STOCK` or `SOLD` if the column just uses IN_STOCK or SOLD. You can also reorder your enum values on the source side, which isn't all that common, but I have seen it done.
&gt; I want you guys to keep in mine that this PC is new This is the key piece of information here.
☜(ﾟヮﾟ☜)
Here, have this if its 64-bit system: [JRE download](http://javadl.oracle.com/webapps/download/AutoDL?BundleId=220315_d54c1d3a095b4ff2b6607d096fa80163)
Aaaahhhhh
I thrashed around for a few years trying to find a pattern I was comfortable with here. Nothing ticks every box, but in the end I nearly always use a reference table. They inevitably grow into richer entities (active flag, name, description, display_order, is_default, is_placeholder, display_color, deprecated, requires_authorization, etc, etc, etc...) The thing I find with enums, is that they get stored as strings in the DB, which means anything that ISN'T your java code interacting with the DB can create 'illegal' values. I'm guessing the database will likely outlive my Java code so this is a real deal-breaker for me. The performance hit of extra joins on a primary key, of a table with a handful of entries, has in my experience been immeasurably small. If I really want to hook the reference entities to a Java enum, Ill add a 'code' column to my reference table, and cast that back and forth to an Enum. My repositories in this case end up with findById(Long id) findByName(String name), findByIsDefault(true), findByLookup(OrderStatusLookup enum) etc. The downside is that it ends up being a whole load of boilerplate code...
[removed]
the second i press play it just crashes and when trying to play from other game mod launchers it says i need java
Methodology: &gt; We first generated a list of twenty thousand Java-related Twitter accounts (including all accounts that contain the keyword Java in their bio or in any of their tweets.) A ranking so useless it could be described in less than 140 characters.
Yes, and if you say wrong sub mention the right one or at least the sidebar ;) 
Well I can assure you I wasn't. It was a simple question. It's pretty crazy how everyone is reacting to it.
Bullshit. It reads to me that you're putting words in his mouth to push a social agenda and your edit above is a thinly veiled attempt to pass it off as a "joke". You know full well that gender has nothing to do with one's ability to code and to suggest otherwise is frankly idiotic.
Wtf. I didn't put any words in anyone's mouth. I asked a question. I know full well? How do you know what I know or think? I was just asking a question that is weirdly still unanswered. Edit: the joke part was me assuming it was less last year, I am not at all hiding my bias towards wanting more women in top code community positions. I openly celebrate it and if you don't then that's fine. I was just weirded out by someone not thinking that more women is more progress, which is why I asked the question to inquire about someone else's view. I didn't know I'd get bunch of people butthurt for asking a question.
Nice, thanks for sharing.
Can always have them open, and alt-~ between them. I agree though, it does kind of suck. I think it has led to me making more multi-module applications for most projects I work on vs multiple projects... which may or may not be a good thing. Good for my org's repo count for sure.
I have no idea what you're doing to your JavaScript or JSP files, but that's never happened to me ever.
Are you using JEE edition on OSX?
If you're on a Mac. It's considerably likely you'll have another window getting in the way of an alt-tab on Windows.
Nope. I run windows on my mac when I need to use eclipse.
I see. I'm guessing it's a bug in the OSX build.
Thanks, Finally got it looking decent. For anyone else that is curious I did it by forcing GTK2 in Eclipse, installed libwebkitgtk-1.0-0 from the Ubuntu 17.04 repository to get the browser working, and made a few manual tweaks for font size.
Can you give me a scenario in which you have a bunch of code in your class but not the required import statements? The only thing I can think of is when you are pasting code from another location, in which case IntelliJ does all the import matching then.
really ? Its the react stuff, you must have heard of that ? 
Thank you I will have a look! It will just take some time for me because I needed 2 days to understand FOR WHAT GitHub is xD
Here's a decent example project: https://github.com/treyzania/BlockParticles This is a Bukkit plugin but it's a good Maven example because it doesn't have any complicated modules and plugins and stuff going on.
I am so confused
I'm sorry. I gave by best to document my first published project
I think that you should rewrite your ask, as not have much sense. By default, the OpenJDK JVM is was you find installed, except on Oracle Linux. But you can install Oracle JVM without any problem on any modern distro. Also, you not have anything special that can improve the JVM performance. Its more about using the correct configuration of the machine to get better performance on your application. Choosing a FS (BTRFS, EXT4 ,XFS, ZFS...), using compressed swap or not, swapines, network configuration, etc...
You're actually asking the wrong question. Linux distros differ in a variety of ways, but the key part (from your long-running Java application's point of view) is what kernel it is using. Different distros will use the same kernel and then add different desktop managers, packages, etc. The key thing for the performance of your Java app is the JVM. There are several options available to you for this. There is a build of OpenJDK that several distros use, but often this does not include JIT compilation. Oracle provide the latest version of the JDK for Linux free of charge, as does Azul with Zulu (http://zulu.org). This also supports older versions of Java (JDK 6 and 7). If you want really great performance check out Azul's Zing JVM (http://azul.com/zingtrial). This uses a different garbage collector and replaces the C2 JIT compiler.
So what? Follow them as commanded. They're INFLUENCERS!
https://docs.oracle.com/javase/tutorial/
&gt; There is a build of OpenJDK that several distros use, but often this does not include JIT compilation. This is false. OpenJDK always comes with JIT compilation. &gt; If you want really great performance check out Azul's Zing JVM Azul Zulu is just a re-branded and slightly modified OpenJDK. Zing is an LLVM based and quite expensive alternative runtime. How expensive? $3500 USD per year per server.
A few remarks on style: * Always put a block with curly braces after `if`, `while`, etc. even if there is just a single statement within and braces are technically optional. * Prefer enums over int constants. They are strongly typed in Java, which makes it much harder to accidentally pass an invalid value. * Throw a `java.lang.IllegalArgumentException` in case of an invalid input. It is more concise and saves you the trouble of checked exceptions. * Also, you probably shouldn't ever instantiate a `java.lang.Exception` directly. Throw a `java.lang.RuntimeException` if you're not sure about what type of exception to throw.
Thank for the tips! I'm still a student and started to learn how to code Java one year ago so I'm still a newbie. But I will apply your advice!
http://yegor256.com
I didn't need such tools because my projects used to be 1000 lines max until now. I use Netbeans and now GitHub too to organize my workflow and publish my projects. And it helps me a lot now because it happend very often to me that I changed a bunch of lines and suddenly it didn't work anymore and I had made to many changes that I could just undo them.
Well, I'd like to think so. But I wouldn't make that assumption of anyone, which is why I asked. I asked someone how seemed to signal that they didn't think it was progress to have more women on the list. To me this hinted that they might not think genders are equal, since why wouldn't it be progress if people from an equally capable segments of the population started acquiring recognized positions in the community? But I made no assumptions and asked. Then... this. Anyway, I think this is not a productive conversation anymore, as whole in this post I mean, not with you personally. #ImplyingItEverWas
As others have mentioned- wrong sub. However, its good that you're attempting to learn programming and java at a young age. You'll be further ahead than most of your peers. Feel free to ask me if you have any java or CS questions.
I never give a 2nd thought to imports, IntelliJ handles imports by itself, even when cut/pasting (only have to give it a hint for ambiguous imports) Make sure you didn't inadvertently turn off these settings (think they are on by default): Preferences-&gt;Editor-&gt;General-&gt;Auto Import-&gt;make sure "Add unambiguous imports on the fly" and "Optimize imports on the fly (for current project)" are checked. Also make sure (on the same screen) that "Insert imports on paste" is set to "All" (again that should be the default setting)
No mention of how to use the various actual collectors (CMS, GC1 etc) and setting memory sizes (Xmx/Xms/permgen etc) No mention of different heap and permgen areas (eden, young, old etc, though permgen only applies to &lt; Java 7). No mention of various ways to reduce memory footprint or the tools to monitor garbage collection (jconsole, flight recorder etc). Fluff piece. 
&gt; Full disclosure, I work for Azul. I kind of guessed it :) Specialized solutions like Zing are worth their price for certain customers, I do not question that. For most users (including businesses) however, OpenJDK is the best option, with Oracle being a good fallback if some proprietary monster of an enterprise application requires it. GC pauses are only a problem for certain use-cases, namely games, visualization or low-latency trading. The new GC in OpenJDK-8 (which will be the default for OpenJDK-9) is pretty good at preventing long pauses, and also great at freeing heap space that is no longer needed. It's a real improvement, and many users don't know about it at all, which is a shame really. I'm working on a REST file service and managed to pump ~2.2GB/s of data from an SSD all the way through the HTTP layer of Netty to 1k clients a the same time, while the heap never grew above 50MB of ram and there were no significant GC pauses or spikes in heap usage at all. Bottleneck was the SSD in my case, not the JVM. That would not have been possible with the old GC implementations. All I want to say is: Measure and try the most obvious optimizations before you spend money on something you probably don't need.
Lets play Guess Who: Is yours a girl. Yes. Game over
It's like you're expecting some sort of quality from an eight day old account with 36 submissions and no comments at all. /s
The repos are here: https://github.com/deeplearning4j The include: * Deeplearning4j - an NN configuration layer * ND4J - n-dimensional arrays for Java (Numpy for the JVM) https://github.com/deeplearning4j/nd4j --Alibaba is using this on their 8,000-node Flink cluster * DataVec - A general purpose ETL tool that vectorizes/normalizes/standardizes/cleans images, video, sound, text and time series https://github.com/deeplearning4j/DataVec * RL4J - reinforcement learning for Java (we're using this in robotics) https://github.com/deeplearning4j/rl4j * Arbiter - model evaluation and hyperparameter optimization for Java https://github.com/deeplearning4j/arbiter * Dev support channel https://gitter.im/deeplearning4j/deeplearning4j
I see from your comment history it's mostly just you throwing out insults. Whatever the historical cause: Paper - reflects ambient light only Monitor - backlight produces light, lcd filters out light to create image OLED Monitor - individual pixels produce light Creating books with black pages and white text would be harder to read without a lot of light. You're probably right that they'd also be more expensive with no benefit. With monitors it could be done either way without an increase in cost. Seems to be easier on the eyes to have a black background as well for many people. 
Fwiw, we use Maven with DL4J - https://deeplearning4j.org/buildtools
Well when you sometimes actually do have to switch back to Eclipse you don't get to run away from comparing the IDEs. But I get where you're coming from.
Can you provide some justification for that last bullet point? I've been writing Java for a while now and have never heard that.
How good would a trained neural network be at playing the game generals.io?
I hate to do this but I just have to quibble with the underlying worldview of the question. The database design and the application design should be two completely separate areas of concern. You shouldn't pick one thing or the other in your database based on what or how your application is going to do when using it. Figure out the best database design without even thinking about the Java application. Then design your Java application without even thinking about the database (beyond what data is available). Finally, design an appropriate data access layer into the Java application that maintains decoupling of the application from the database except in that layer.
Yeah, exactly. But, that's just how I interpreted the comment. I didn't write it. 
That's exactly what I meant, thanks! Of course it's fine to instantiate and throw for example `java.io.IOException` etc. although personally I would very much prefer a `java.io.UncheckedIOException`. I'm not going to lie: I really fucking hate checked exceptions. They're one of the worst parts of Java.
Yes I realise it wasn't the focus of your post, I'm not meaning to derail, it was just something that came to mind! &gt; Do you think that's not true? Eh I dunno, anecdotally I feel like it's true for me on websites, so maybe ... but I'm not convinced by your reasoning as to why. It seems a bit like saying adding wide white margins to the page would make it easier to see the text because there would be more white there to reflect the light. That doesn't make the white brighter, it just adds more of it in the surroundings. The contrast is still the same at the important parts. **edit:** Interestingly I've done a little reading and black on white is easier to read than white on black... But then *grey* on black is also easier to read than white on black, which is less light *and* less contrast. That seems to go against what both of us were saying, so who knows why it is.
I know for sure that if you paint your walls a dark color, either your room will always look gloomy or you'll need significantly more light to get it to the same light level as a room painted white (or another brighter color). So I'm basically assuming it works the same way for text, put a bright color behind black text, it's easier to see than white text on a black background. I would think the contrast between the 
What??? Even the color of a car is more important than the dark theme in Eclipse :)
Run it completely offline. Wipe the machine and start over when a new version is released. There's no risk in leaking confidential information if it never gets a chance to phone home.
Do you really expect some anonymous internet user to provide reassurance that the product is safe for your project? :) What is the context of your project? I have worked on *serious* confidential projects to the point where every piece of software and hardware had to be vetted by a certified engineer. If you're not going to that extreme (which I doubt, since you are posting here), then I wouldn't worry about it. If you are truly paranoid, unplug your ethernet cable or run it in a virtual machine with no network access.
Exactly. Run it in a VM that has no internet connection. Done. Although your maven repositories may not automatically download.
that's true but it's not an excuse for things not to be secure. not saying IJ is or isn't secure though.
Run Nexus on your host and only give it network access to that?
The project is confidential (but certainly not NSA level), and I'd need to convince IT to allow the program. Either way, the points mentioned above should be concerning for any developer. Using the program in a vm w/out ethernet is unacceptable. 
We're allowed to use Eclipse, but I think IDEA is a much better editor. If the editor is insecure, I wouldn't use my PC without ethernet as a workaround. The IDEA product page shows some major US companies that likely have high security standards, but I'd like to make sure.
Why is it unacceptable? It's by far the easiest way to improve security if your project requires it. 
&gt;Using the program in a vm w/out ethernet is unacceptable. Why is that? That makes no sense. Which, if that is the case, then that's an entirely new topic. Virtually sandboxing your dev environment is a level of security that should be considered, from the direction you are coming from at least. Having said that, nothing is truly "secure". Asking in a place like Reddit says your required level of security is truly not .. "secure". At least, not to the point of worrying about whether or not to use an industry standard IDE. Research the topic from other sources, you'll get further with more solid info.
By unacceptable, I mean that I'll use Eclipse instead, which IT allows.
You realize Eclipse also collects usage data in a similar manner as IntelliJ and both can be disabled, right? This sounds more like an issue for your specific IT org policies than a flaw in tool A vs. B.
Not sure what you mean by secure. I've used it on all projects I've worked on that required a clearance. 
oh the howls of outrage there would be especially in the gutter press (like the register for example), if an open source repo had code that provided a back door! or did something untoward without explicit explanation. if you're unsure compile the code yourself, its then up to you how much of your time you commit to looking through the code (you're already not the first set of independent eyes to look at the code)
You're being ridiculous if you think Eclipse is going to be more secure than Intellij. Intellij is an open source platform, managed by a company who relies on people paying for the product. They have far more to lose by being insecure than eclipse does. But the real thing you are missing is that Intellij, Eclipse, and any other modular IDE out there, are _platforms_. As a platform they are only as secure as the plugins/modules/addons you install. IDE's _by definition_ load and execute code. Of course there's always some sort of risk if you are connected to the internet, but that is true of _any_ IDE. The question itself is somewhat crazy. You want security? Then run only on a lan, with a secured artifact repository that is LAN only, with dependencies that are completely vetted. Otherwise, just don't be dumb and load random 3rd party plugins. Jetbrains doesn't care about your source code. Look at [the companies](https://www.jetbrains.com/company/customers/) that use JB products. You think your source is more confidential/valuable/important than theirs? Not likely. If it passes muster for them, I guarantee it's fine for you too.
You can turn off Anonymous Usage and Statistics as well as Check for Updates. Those are the only two things that phone home.
IDEa is just an good editor. I would have thought the more important question is how/where are you keeping your code? Dedicated/offline SVN? Because if your asking about secure IDE while using a github repo well then.. Also, going totally offline is going to work against you if you need maven libs, an option here is to go semi offline and have libs come through locked down nexus/artifactory repos on a local network.
int a = 0, b = 0, c = 0;
haha thank you i totally overlooked that
Within aforementioned agency, IntelliJ is popular among java developers. 
I wouldn't recommend that in an enterprise situation when maintainability matters. One per line with comments would help with context for future programmers.
Also cleaner in source control when somebody else adds a field. 
I wouldn't worry. OP probably just needed this for a homework assignment. :/
&gt; The project is confidential (but certainly not NSA level) Are you working for a government or is this private sector? &gt; and I'd need to convince IT to allow the program. Is that all this is about? I am not sure anyone can really help you there, if so. Especially if this is all political (you mentioned Russia in your original post). Have you thought about contacting JetBrains to get their take on your question?
&gt; One per line with comments. If you name the variables properly, you wouldn't have to add comments.
Comments are for adding business context. Sometimes you end up with names that won't be meaningful without a comment. Again, this is for enterprise.
Very true! Why would they even teach that?
That's a great point!
what the fuck are you building? :D haha
Pretty sure it something for the GOP and OP doesn't want to be in the news. 
hahaha
im following bucky's java tutorials! 
Woah, I have not heard that name in years. He was my favorite youtube tutorial channel, learned ton from watching him!
In an enterprise setting, you will have legacy developers that love to abbreviate everything because at the time of their prime (80s &amp; 90s), they had limited space to work with (fixed format RPG, COBAL, etc.). 
Hahaha, American paranoia is always great comedy. :D
Is that Bucky from thenewboston? His tutorials are notorious for having poor programming practices throughout and I would strongly advise using a different source for learning. If video tutorials are your preferred method of learning, I would recommend [Derek Banas](https://youtu.be/TBWX97e1E9g?list=PLE7E8B7F4856C9B19)' series instead.
In Java? Not on my watch!
https://i.redd.it/dnu76hvosq6z.jpg
Next time try /r/learnprogramming
Oh my. So nostalgic, i remember good old Bucky 
Not everything can be explained with a few words, you shouldn't have variables like this: int distanceInKm; int distanceToBakeryInKm; Its hard to read, just 'int distance' is enough, if you need to explicitly explain its type of unit of measurement, you could use comments: int distance = 5; // Distance to bakery, Unit is kilometers.
I wish you were wrong, but you arent
I will take your advice, but Derek Banas' videos already seem so much more daunting ):
Definitely No! Comments may explain the *why* of the following code block. Not the *how* or even worse the*what*. Those can and should be deduced by the code itself. The *why* is for things that aren't obvious or couldn't be grasped by tye code easily. Don't confuse *comment* with API *documentation* - within the latter you could of corse describe the *what*! Documentation appears always at the signature level of a component, whereas comments are often inline ones.
Meh, I don't agree. The first one is better, self documenting code is always better, unless you absolutely have to explain what the code does, then avoid any comments, because they confuse more than they help usually. IMO having unit names in variables is a good practice. Comments aren't always noticed and the next guy who comes and refactors the piece might reuse the variable to indicate something else, then you end up with &gt; int distance = x; // Distance to bakery, Unit is kilometers. except the distance means distance to nearest Bar and is in centimeters. 
Why comments? Just use descriptive var names so you don't need comments 👍
Since this is help with Java **programming**, it should, as the *plenty hints on the page* indicate, be posted in **/r/javahelp**. Please make sure to read the [**Posting Guidelines**](https://redd.it/48eykt) there before posting. **Post removed:** programming help
Check your environment variables. If java is indeed installed but applications can't find it, it's probably not on your path variable. It should be tho... 
&gt; Do you really expect some anonymous internet user to provide reassurance that the product is safe for your project? :) I am anonymous internet user and approve Intellij as secure, non-Russian loving IDE, beloved by millions of comrades around world. 
&gt;:) I am happy that you are happy. Spread the happiness around. [This doggo demands it.](https://i0.wp.com/s4.favim.com/orig/50/boo-cute-dog-pomeranian-Favim.com-452643.jpg)
I don't get it. If you have an immutable final Builder instance, it would always build identical instances. If those instances are immutable themselves, why wouldn't you just build one and cache it instead of building the same thing over and over?
Note that, due to the lack of immutable arrays or const access, Enum.values() must create a new array and copy its internal values into it. This slows things down if you often access values(). If they didn't do that, you could muck with the return value, changing the order of values, or making them all the same value, and that would make the next call to Enum.values() return that incorrect result. Example bytecode: public static Timing$RatingEnum[] values(); Code: 0: getstatic #41 // Field ENUM$VALUES:[LTiming$RatingEnum; 3: dup 4: astore_0 5: iconst_0 6: aload_0 7: arraylength 8: dup 9: istore_1 10: anewarray #1 // class Timing$RatingEnum 13: dup 14: astore_2 15: iconst_0 16: iload_1 17: invokestatic #55 // Method java/lang/System.arraycopy:(Ljava/lang/Object;ILjava/lang/Object;II)V 20: aload_2 21: areturn To avoid cost from that, I find that every enum needs this: public static final MyEnumType[] VALUES = values(); Of course, I have to trust my own code not to muck with the contents of VALUES. That said, there's no way I'd go back to the ancient pre-Enum days with static values that have no grouping and fewer checks. 
Your biggest difficulty can be easily handled by apache poi ( https://poi.apache.org ) If you're familiar with the Google maps API (I'm not) and know how to get the images of the address, I'd say you're 90% there.
There are libraries that will make this easier for you from Apache, however your description of the requirements are not too clear. Like if giving the address returns the Google map image, why not just save that as an image instead? Word files are essentially a custom zip format that is just a dog to work with. Java can do what you're asking, as could Amy general purpose programming language
You can use [Apache POI Project](https://poi.apache.org) which provides API for working with different Microsoft formats (including DOC &amp; DOCX). It looks complicated at first sight however it is not difficult to use for different basic tasks. I personaly used this library to parse Outlook messages and generate Excel documents and it took less than one day to make everything work as I wanted.
Best post: https://www.reddit.com/r/java/comments/6kjryf/is_intellij_idea_secure/djmojja/ 
thanks. i just wanted to know if it is possible so i know where to start (macros - java) gonna look at apache poi
thanks for the tip
Why Word files, though?
the client is a law firm. they currently merge everything manually and want as much as possible automated. the output should be a word file so they can change things easily instead of using the tool again
I don't know why you're being downvoted because this is a legitimate question and concern especially since other Russian software companies like Kaspersky have been [accused of spying](https://www.theregister.co.uk/2017/05/11/us_security_chiefs_dont_trust_kaspersky/). JetBrains is based in Russia but they have a front office in the Czech Republic, for presumably tax avoidance and marketing reasons. American companies are more comfortable sending money to the Czech Republic than Russia for obvious reasons.
To add on to this Apache has a project called "Tika" which uses POI under the hood. It provides some very convenient utility methods.
I get that they're trying to have fun, but the metaphor is kind of confusing, and most of this is talking about general system architecture...not the JVM. After the first paragraph there is little to no mention of it. Also the author is kind of all over the place. The entire paragraph about NICs was...unnecessary. 
Since this is help with Java **programming**, it should, as the *plenty hints on the page* indicate, be posted in **/r/javahelp**. Please make sure to read the [**Posting Guidelines**](https://redd.it/48eykt) there before posting. **Post removed:** programming help
**Sidebar:** + **Do not post tutorials here!**
Thought of it more as a General discussion of Java is capable of this, so i wasnt Sure. Next time i know
What's the difference? I've used both IntelliJ and Eclipse extensively and don't understand how their respective approaches differ, except in that they use different terminology. 
It looks like you are using varchar for many data types that should not be varchar. Price and dates to name a few.
Yeah if only they could get their window layout system on part with Visual Studio or Eclipse ... It's a shame really. As for the bugs, many that I've reported have been fixed, others I reported, well, no activity for a while. Just keep reporting what you come across and make feature requests for the oddities. 
No, no, you can't put decent images in a Java application. I mean, just look at the original Minecraft and at Pokémon Go. It's all dreadful.
The For Dummies series is excellent. You should be able to borrow it from your school library 
I appreciate the answer and I truly appreciate the sarcasm. 
Wow, fantastic work. Exactly what I was looking for, I'm sure it will be very useful to me. Would you be ready to support it by adding a few payment processor integrations for my site? Unfortunately I can't pay more than $250,- per hour, but I'll be happy if you share the result with the rest of the community. I am particularly impressed by tests and this https://github.com/vatri/spring-rest-ecommerce/blob/master/src/test/java/net/vatri/EcommerceStarterApplicationTests.java gem! Superb!
It's easier on my eyes than white themes.
Never had real issues with Intellij, but with Eclipse several times: It was a real pain... &amp; Intellij live decompiler really help you: * when some people should have given you the source, but did not. * when you want to check the quality of your -big company- libraries in order to take action to be in safer place. https://plugins.jetbrains.com/plugin/7017-plantuml-integration
I've got my OS visual theme set to accessibility dark. Eclipse automatically adjusts. Then I applied the Monokai code coloring theme. It mostly works fine. I'll try Darkest Theme next.
Its his first API. Probably better than your first API
Nice
`@Transactional` ?
Good answer to the question. 
No you can't "upload" graphics to a Java program.
http://jmonkeyengine.org/ r/Demoscene/comments/4eckav/is_it_possible_to_make_a_64k_demo_with_java/ 
Shouldn't it also depend on the size of the project as well? For /r/dailyprogrammer I usually leave the variables with very small names, but in projects estimated to have 1000+ lines, my variables will be more descriptive. It also depends on the scope aswell and if I'm going to actually use that variable instead of just a throwaway. EDIT: Also what color scheme with your Editor/IDE always matters. In some schemes, comments are light grey which makes the code stand out more, while other schemes' comment colors are darker, making comments stand out with or without the code.
Java needs more of this foundation documentation. 
An application server basically follows a Java EE specifications and ( therefore) provides support for EJB's , their persistence, transactions and rollback of transactions, handling db connection and pooling of resources, allowing remote EJB's calls etc etc Examples are JBoss , weblogic, Oracle as , websphere, A webserver does not support that. It can only support servlets and jsps and other non tx related( basically not EJB's) web applications Example tomcat, 
Well, I work on decade old project, which has been continuously under heavy development. I cant reaĺly trust any comments. Whenever I see a comment I take it with heavy sceptisism. Even if it meant something 5 years ago, you cant be sure it means anything today. Trust me, the only thing that matters is the code. Some comments have an expiration date and that is why its better to avoid them unless you really need them.
Notepad is totally secure, only the NSA has access
I guess your problem is not junit, but unit testing in general. Sounds like at this stage you would be more productive writing integration tests. However my personal preference in integration test code is to use TestNG instead of junit (it has a couple of things that i prefer, for example the beforeClass does not need to be static).
This answer right here. In a more simple way, an app server takes care of business code whereas the web server takes care of web-related code. For instance a **web** server would intercept an http request and treat it accordingly, An **app** server compiles the code you wrote yourself in an entity class. 
He probably didn't make a reddit post to tell people all about his first api
I agree that integration tests sound more adequate for them, you can actually get better coverage this way because you'll be utilizing these methods anyhow. Though I would take a look at JUnit 5 it has a lot of nice features that were lacking in 4. JUnit tends to have better support across various tools which makes integrating into IDEs and build tools much easier. 
Do remember that EJB is greatly deemphasised in modern Java EE. Modern Java EE applications mainly use CDI, Interceptors, Bean Validation, JTA, JPA, etc. Remote EJB call have started to become really rare, to the point that there were about to be actually removed from the platform. Most people now use JAX-RS and JSON-P/B for that.
Its the last part of four-part article on layers of abstraction, the JVM level is in the second part: https://howtotrainyourjava.com/2016/12/29/from-java-source-to-bare-metal-part-two-the-desolation-of-bytecode/
a lot (but not all) jre implementations come with javafx as well as GUI's it can also do basic 3d (no shaders alas)
Retrofitting unit tests is going to be an uphill battle. The issues you are describing are that the testability of the code is poor, not that the test framework (or unit testing in general is bad). Testability on its own would be a tall order if only to enable unit testing, but code with good testability tends to be well factored in other ways (low coupling, separation of concerns, etc.) I feel the most love for/from unit testing when I've been developing tests along side the code base from the start. You tend to produce code units that aren't entangled in the way you describe. Sometimes an integration test is the way to go. I don't really see the point of trying to mock an SQL database for example. In fact I consider a proliferation of mocks to be a (test) code smell. Sometimes a good mock object is the way to go, but don't shy away from just using "the real thing" even in unit tests. Every time you think "let me run this to make sure it's working right" or "let me make a throwaway main method to check this piece of code" write a unit test to do the job instead. If the test is really hard to write, rethink how your code is factored. And finally, since it sounds like you are starting with unit tests on a mature code base, one great way to get started is to incorporate testing into your bug fix process. Once you track down a bug, write a (failing) unit test that causes and detects the bug condition, and then don't check in your fix until you have all green tests. Over time you will build up a robust regression suite this way. 
Even more of the reason to start now! You can add JUnit and Mockito and start in a small scale and begin refactoring the code so its becomes testable. Sure it's an investment but if this project/massive code base is to live on for quite a while it's propably worth it. You have to start somewhere.. I'm speaking from experience. Our team took over a big project with alot of static methods and singletons. Not testable or mockable at all! We introduced JUnit, Mockito and Dependency Injection (Google Guice) to get a better seperation of our classes. We "converted"/improved one method/class at a time. Sooner or later it will all be covered by the tests.
I think that IntelliJ is secure but not as much as it seem, there are errors it can't detect. There are external tools who helps detecting those, such as checkamrx or others. It does a great job but it's never enough I guess.
Out of interest what level of auditing do you do of the libraries you use and their dependencies?
As another answer said: this is not about JUnit, but Unit Testing There is a theory, that writing tests for production code is exponentially more effort (approx. 4x) than writing tests for boundaries and then write the production code until all tests are green. Tests are there to document the behavior of your code. What if in the future your underlying implementation changes, but the behavior is supposed to stay the same (See implementations of Lists e.g.). This allows you to refactor code without fear of breaking it. It may seem to you as trivial for now, but not in 3 months, 2 years or not trivial to others. If you break your own code, it is easy to fix, but not if somebody else is breaking your code. What if you have to keep an API steady? Not just from the signature, but from behavior, too. If your method returned null with a special meaning, you need to keep that behavior unless every dependent class updated their integration. 
Yeah. It is really, really, really hard to write unit tests for old code. Therefore the idea of test driven design exists... The main advantage for unit testing is that they are repeated automatically --&gt; no more undetected regressions. In my experience there is no easy way with monolithic legacy code. Start writing larger tests that test larger chunks. And then refactor, refactor, refactor. If your application is testable, the overall design will be better... 
Unit testing code which hasn't been written with even the slightest level of testing in mind is going to be quite hard, especially on a codebase which is very large. Having to write complex tests for trivial checks hints that maybe the original code should be structured differently so that it could be better tested. This is why TDD is getting such attention: it essentially forces writing such code because it must be testable. Of course unit testing isn't a magic solution for everything which is why testing at higher levels might be more sensible to start with in such case.
Yes, writing unit tests (with any framework, not just JUnit) will be very hard in a poorly designed codebase. If quality is an important metric for the application, you should still write them, and refactor as you go. &gt; I have seen entire classes written to test 3-4 lines of code. This shouldn't be happening, and is a sign of either poorly designed underlying code, or a team that doesn't yet understand how to write tests. Your tests should: 1. Mock out dependencies and the return values of their method calls 2. Call the method under test 3. Assert the return value (if any) is as expected 4. verify the expected dependency methods were called. I would strongly suggest adding Mockito to your testing toolkit, and looking into an IOC framework like Dagger or Guice to help extract all of those pesky coupled dependencies. 
&gt; you can actually get better coverage this way because you'll be utilizing these methods anyhow That's unlikely if you have a lot of branching out business logic. You simply can't get all the corner cases using integration tests, unless you write an awful lot of them.
This could also be a sign of bad design, unit testing is meant to be easy and is meant to test only the "granular logic" not integration or other things, it is generally faster and easier to maintain than integration tests. I too started with the same feelings you have, one thing you can try is ask yourself what am I trying to achieve with the test I am about to write. If you still feel this pain with unit testing, ask yourself why it is painful, 1. is the code resisting a lot? If yes, question the design, perhaps your layers are tangled up, or simply the method may be doing too much. 2. were you trying to test something which shouldn't be unit tested? 3. Or is it that you haven't mastered the testing framework yet? 4. Or is it a resistance to something which has been forced on you? It may seem like I am kidding, but I am yet to see a programmer take it in their stride when something is forced on them. 
&gt; exponentially more effort (approx. 4x) That's not exponentially.
You can always use swing library which helps with graphic interface. Just so you know, It's not the easiest to use and many errors may occur using swing and it's really important to learn all about it before you start. Also, there programs that can help you, such as checkamrx, for error detection.
Any chance you remember where that 4x estimate came from? I'm curious to read more about that. Thanks.
A bad case of hemorrhoids
It took me a while to really get why tests are useful. I still don't unit test every single function. Still, whenever I'm writing something non-trivial like a complex data transformation I usually spin up a test to ensure that the values that I expect it to generate are actually generated. It also helps me find edge cases and improve the code. Write the tests with one dimension in mind, don't care about the coverage, focus on finding the places for potential bugs in the codebase and writing tests that ensure they work as you expect them to work. For each of these tests you write, you have a permanent guarantee that that particular piece of code is not bugged.
2^2
Been there. Done that. Write unit tests when it makes sense, which it won't very often for such a code base. So if it takes more than 4 mocks or *any* objects from Spring or *any* database access or *any* I/O, then *don't* write a unit test. However, I think you should write tests for services. These are called integration tests even though you'll still writen them with JUnit. Have Jenkins (or whatever) run them on push or merge. Unfortunately, these tests are usually too slow to give you the TDD benefits of unit tests, but they are quite useful. I prefer them over functional tests as they are usually more stable.
You're a Wizard, Harry.
I'm a *what*?
Sure, but in a badly designed legacy system, there usually is no practical alternative. You'll more often get better coverage per hour spent with integration tests than any alternative.
Read this after making my own comment. We think alike.
https://www.youtube.com/watch?v=tZVdR19E5mU
* [JavaFX drawImage](https://docs.oracle.com/javase/8/javafx/api/javafx/scene/canvas/GraphicsContext.html#drawImage-javafx.scene.image.Image-double-double-) * [libGDX](https://libgdx.badlogicgames.com/)
Good, judging by the downvotes the sarcasm was somewhat noticeable. And yes, I find the "publish everything" culture that started in NodeJS world a bit poisonous. And really hope it won't spill into more mature technology stacks. Imagine if maven central would look like npm? The OP is a newbie, that's cool, but also should be discouraged from sharing every single burp he created with the world. He'll learn. 
Without the tests I would be lost in our codebase. I wouldn't know anymore if I broke something at the other end of the system. I wouldn't be able to look up how that complex business logic was meant to work. *shudder*
Per unit of time, sure. But I would still focus on refactoring key pieces of business logic and covering these with unit tests. Probably after integration tests, though.
This kind of question is impossible to answer adequately. We don't know what you are doing. But... I'll give you some tips. In general, don't worry about Linux. Worry about your hardware and algorithms. The kernel, file system, and various configuration options are what matter, not the distro per se. These things can help, but you need to understand the implications of doing any of these. I won't be much help beyond this list. You have to learn this stuff if you intend to use it. * Tune JVM options, esp. GC * Never let Java swap. Set swappiness to 0 and have plenty of RAM * Disable atime * Mount /tmp to /tmpfs * Pick a file system that will work best with your app 
&gt; ... thinking of the OpenJDK ARM version that does not have a JIT. I believe that is no longer the case.
Do you know Java SE 7? Java SE 8? If you haven't, take some time to learn some of the new features. Try reading some books. Also, what are you using for GUI? If you're still using Swing / AWT, it has been deprecated for like 10 years. Try learning JavaFX. Try learning a new library. Do you use anything for Unit Testing? If not, check out JUnit. It makes it a lot easier to test your programs.
Swing has been deprecated for like 10 years. JavaFX is much better.
I'll echo TestNG as a good candidate for integration testing. You can do it all with JUnit, but TestNG provides a bit more manual control (at the cost of having to manually control the suites)
That definitely makes sense. I guess a persons views on certain aspects of programming depends on what they do or have done. I haven't even touched old projects, and all of my projects aren't big so I guess I have time to continuously change and update comments. Thanks. 
Tldr on junit. Junit is best on classes that dont require reflection or introspection to setup. If the class needs reflection, most likely another class should be extracted from it and tested in its own. This results in small and focused classes.
Without being close enough to the actual project it's hard to say exactly, but I agree with your sentement 
You should check out /r/learnjava
are you asking if unit testing is a "must" do for this particular situation / project? or are you not sure about the general use of unit tests, in software development?
A classic text for this situation is [Working Effectively with Legacy Code](https://www.amazon.ca/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052) by Michael Feathers. Legacy code is a different ball-game than relatively clean code-bases, and has its own set of strategies. As it happens, there is a [timely episode](http://www.se-radio.net/2017/06/se-radio-episode-295-michael-feathers-on-legacy-code/) of the SE Radio podcast as well.
I use the philosophy of good unit testing to help me drive my application design. 1. Unit tests should treat a function as a black box. It gives inputs and tests outputs. Unit tests and function code should be unbound except for method definitions. If for every internal functional change, the corresponding unit test must also change, then that means that the unit test is tightly bound to the function, and while still important, it is a lower value unit test. Refactoring the method, and perhaps its surrounding methods, and even its enclosing class so that the unit tests can be less tightly coupled and thus making the unit test be of higher value is a valid endeavor, and 99% of the time, the refactored function(s) and class end up being cleaner, better designed, and easier to maintain. 2. Unit tests should be unbound to the environment. I saw a great presentation at a Software Craftsmanship conference (big ups to Uncle Bob!) about making your unit testing suite run fast. Basically, as a developer, you want the fastest feedback cycle you can. You only get so many 'tries' per work day to do a type/test/failOrSucceed cycle. A manual QA cycle takes days, an integration test cycle takes 10s of minutes, a unit test cycle takes minutes, a compiler cycle takes seconds to minutes, and intellisense style feedback is nearly instantaneous. If you're doing something wrong, you want to know as soon as possible. Thus, keeping integration out of your unit tests helps keep that feedback cycle fast. Also, letting integration bleed into your unit tests means that your unit tests are becoming bound to the specific implementation of that environment. 3. Aim for high value unit tests. Gone are the days where dev teams would aim for close to 100% code coverage. Code coverage metrics are to software engineering as bicep curls are to olympic athletes. If you're a premium athlete, you can probably do some good bicep curls, however training for bicep curls means absolutely nothing to athletic performance on the field. High value unit tests are simple, run fast, have minimal mocks, test null, empty, one, some, all, and exercise the cyclomatic complexity of a section of code. ** The following note below don't relate specifically to unit testing, but rather to working with large existing codebases. ** 4. Find the seams of a codebase, and use that to group code that can be refactored together. Every codebase, no matter how convoluted, has internal barriers between different parts. These can be separate classes, or functions, or maybe even particular modules. If you can find a section of code that can have its internal workings reordered, and as long as the inputs and outputs are the same, the rest of the code is none the wiser, you have found a seam. 5. While refactoring a large codebase, ensure that it is ALWAYS in a deliverable state. As you work your way through the codebase, refactoring as you go like a unit testing Johnny Appleseed, you will have to show proof of your ability to continually deliver functional change and value to the business. By keeping the code always deliverable, you will have to do more work over the course of a year, than a greenfield rewrite. However, KCAD (Keeping Code Always Deliverable) earns the trust of your managers, since the code is in prod and it works, and as the business changes, your code can keep up. How many stories have we heard about a dev team being sequestered for a time, coming out for the dog and pony show, only to be told by the business "that's not what we want", or "that was true then, this is now". KCAD helps prevent that from happening. KCAD is agile for legacy codebases. It is a business, technical, and political battle to refactor a large existing codebase. If you can successfully do it, you will essentially have earned a masters degree in software engineering. I encourage you to take that challenge.
This is a good book! I recommend this, as well as [Pragmatic Unit Testing in Java with JUnit](https://pragprog.com/book/utj2/pragmatic-unit-testing-in-java-8-with-junit) and [Refactoring](https://martinfowler.com/books/refactoring.html)
Not a single comment?
You can also use Java and HTML for building a website, just use Google. There are a lot of frameworks(e.g. PrimeFaces, Apache Wicket, Thymeleaf) and tutorials out there. Just search for it. 
I agree with you about critics of "publish everything" culture. And I appreciate your 2 comments more than 15 upvotes or anything else I got from this article so far. However, it seems you choose wrong way to tell it - now your comment is hidden due to downvotes.
Hi. Can you give example of **useful** comment in the example code and explain why it's useful ? 
im totally with you on this one. Given all that i prefer Spock as a testing framework over Junit. Much less boilerplate code. Its a bit of a heavy lift at first but worth it. 
There really was no way to say it without being downvoted. Again, nothing against you personally, just annoyed with some of the bigger trends around. As for your codebase - it is probably an OK exercise to have in your github to share when interviewing. Few notes though: * Sweatshops caring about Spring will be anal about tests coverage (and not only IT's, but UT's as well) * You seem to use weird coding style. Ether natural Sun or Google java styles are much preferable. * Readme could focus on _what_ that code does, not _how_. Maybe with examples. * Security will play a big role in any such code/solution/problem domain area. * eCommerce is a term that spans anything from an e-mail link "send money here" to amazon.com platform. Clarify your attempted niche. To me it looks like "stock and shopping cart" service. * It's personal code, sure, but your commit history will be a struggle even for yourself to look at in 12 months time (and spot particular stages in development). Make it a habit to make commit messages meaningful.
Advanced questions: * Automated regression scenarios and testing * Performance/load tests and results (e.g. 100k operations per second) * Reference deployment/implementation * Concurrency concerns (e.g. 100 people claiming one thing at the same time)
&gt; ... an SQL database ... I see your pronunciation. You can't hide behind the initials! Let the flame war over _a_ SQL database begin! Oh also here's an upvote because everything you said was correct. Except the SQL thing. That was blasphemous.
So your codebase is not testable. I'm guessing that guy is pushing it so he can show off with coverage statistics but unless you refactor your code to make it testable those tests won't give you any benefits.
I'd also suggest learning the various frameworks. JPA, Spring, junit, mocking tools, the list is endless.
Related question, if you don't mind: How would one verify that the dependency methods were called? Would you have a proxy wrapper implementing the same interface keeping track of the calls it passes through, or is there some functionality in a test framework one could use? I find that I'm doing a lot of this specific check manually.
&gt; I'm guessing that guy is pushing it so he can show off with coverage statistics I'm guessing someone is pushing for testing because shit breaks all the time and he has to get out of bed and fix it. 
&gt; Has anyone else felt the same way from experience and then seen the value in JUnit for themselves? I work as a consultant on Java project and basically not having unit tests on these projects is a concept that's completely alien. When a project grows over a certain complexity not having good test coverage means that stuff just constantly breaks about every release. Add to that the complexity of different systems talking to each other and you're in for a world of pain without tests. The project I work on has 2 Front-end apps (iOS and Android), a small web portal, over 20 Java microservices, Python microservices and a Spark cluster running stuff. In general our unit + integration tests are about 1.5 to 2 times the size in LoC of whatever service they're testing. And we need those: with so many moving parts that are too complex for us humans to comprehend it's just too easy to introduce subtle regressions on a new release (which we do every week). So while I am 100% a fan of proper testing (I wrote a [blog post](https://niels.nu/blog/2016/testing-for-managers.html) about it a while ago) I fully understand your apprehension. Testability needs to be part of the design of the software. That's what TDD is about; design. So in your case I would suggest you start with integration testing the modules of your system. So you're starting at a high level and from there identify the parts that need unit testing the most. And those parts you should not try to just slap unit tests ontop of what you have; the code should be redesigned and refactored bit by bit with unit testing in mind. 
&gt; And, if someone wants to use it for commercial purpose, I can technically support and update it to your needs. Since it has no tests I can imagine they'll need quite a bit of it. 
Did you read the sidebar? There's sub for learning Java. This isn't the one.
There is no sidebar on mobile good sir or ma'am. 
So how is that our problem? Use a desktop or tablet then. It points you to where you should be.
It appears I must rephrase my reply for you to better understand it: I only use Reddit on my phone. Therefore, I have not seen the rules that you speak of nor the side bar that you mentioned. Luckily I had a nice maverick like yourself to come along and show me the error of my ways. 
Thank you. I will look into JavaFX
Yes. And getting al sarcastic is totally going to convince people to help you.
Does that codebase have a lot of Singletons? No, not the Spring/Guice idiom by that name, I mean the Gang-Of-Four design pattern which makes an instance of a class accessible statically to any other pieces of code. Otherwise called "shared static state". I ask because I oversaw the transformation of a large Java codebase in 2006/6 (FX trading platform) that desperately needed unit test attention, and we did a set procedure to eliminate the singletons in order to make more testable 'seams'.
Yes, do Unit test. Introduce the slowly, with every new change. Use Helper libraries, Mockito, Powermock and assertj as an example (or similar). There is no reason to drop your common sense when writing unit test, the size of the test should fit the size of the code under test. The software quality of tests does not need to be better, but should not be worse than other code. Also think of the main purpose of unit tests not to detect a bug in what you currently change, but to detect bug in things people will change in the future (regressions).
I think it's funny you're getting downvotes for an obvious joke, I giggled
One like this? Absolutely incapable. A carefully designed and tuned one by a research lab or team of industry practitioners? There's a large chance better than any human.
Unit tests don't fix bugs. Unit tests provide maintainability.
No there isn't a 5 minute tutorial. You have to commit time and effort to learn complicated things properly.
Confidential work? Community edition? RUSSIANs? My good man, I have the solution for you. Don't listen to all the VM peddlers on here, that's a trap. I wholeheartedly recommend you develop everything using the vi editor. It's been around for decades, built I believe by good old Americans and not by some commie front organisation. Further, I recommend you don't use a VM but go find yourself a real Made-in-America computer to do this development on. For this bit I can recommend you follow the lead from this guy https://m.youtube.com/watch?v=45X4VP8CGtk
&gt; Performing 10 times the same process using reduce: &gt; &gt; Fastest was done in 14ms. &gt; &gt; Performing 10 times the same process using custom collector: &gt; &gt; Fastest was done in 7ms. Please, use JMH. Your benchmark *might* hint in the right direction, but it might as well be the JVM warmup performance penalty of running your reduce algorithm first.
What is the need for migration from spring boot to Java 9?
But it's SQL. Not SQL. 
If you mouseover a method in eclipse (or a reference to it) it will show you a list of every method it throws. This includes any method in the stack that declares "throws". If you don't want to catch an exception...just don't catch it.
I suggest that you try to test expected behaviors. Unit tests are testing a certain "unit of test", but it is not strictly what that unit is. Most common is a class as a "unit", but that is not useful in general. In most cases it is much better to think in "functional units" what could be a java package in a good, modular design. A unit test would then test the methods exported by a module. With this approach you would be testing the most important aspects of the software without getting lost in too much detail. Another advantage is that you would be able to refactor without changing too much test code.
I just tried it, but Eclipse does not list RuntimeExceptions. Eclipse does not display the exception for the code below. private static void createTrayIcon() { if (!SystemTray.isSupported()) { throw new UnsupportedOperationException("This application requires system tray support"); } appTray = new AppTray(); } &gt; If you don't want to catch an exception...just don't catch it. But how do you know which exceptions (including RuntimeExceptions) you should handle, without reading the source code? For popular, well documented libraries you can rely on Javadoc. But many code written in business does not have proper documentation. I can just write `catch (Exception e) { ... }` but that will catch stuff I don't want to catch.
I use mockito. Also I use constructor level injection so I can unit test without a DI framework. Not at my workstation so this is pseudo code from memory. // System under test is a widget builder called Bar. // Bar has a dependency of Foo. // We are not testing foo so we want Foo to be well behaved // Testing behavior of bar using Foo to ensure widget is valid // GIVEN a Foo that believes any Widget to be valid Foo foo = mock(Foo.class); when(foo.isValid(any(Widget.class))).thenReturn(true); // and a bar that uses said foo Bar bar = new Bar(foo); // WHEN a Bar builds a widget Widget widget = bar.buildWidget(); // THEN bar should leverage Foo to ensure widget was valid before returning to user. verify(foo, times(1)).isValid(any(Widget.class)); edit: more of a real world example //GIVEN a user to delete long userId = 12345L; // and a userService and its dependencies var emailService = mock(EmailService.class) when(emailService.notifyOfAccountDeletion(userId)).thenReturn(true); var userRepo = mock(UserRepo.class); when(userRepo.markAsDeleted(userId).thenReturn(true); var msgService = mock(MessageService.class); when(msgService.notifyCentralAuth(userId, CAAction.DELETE)).thenReturn(true); var userService = new UserService(emailService, userRepo, msgService); // WHEN a user is deleted var result = userService.deleteUser(userId); // THEN user should be emailed verify(emailService).notifyOfAccountDeletion(userId); // and DB record flagged verify(userRepo).markAsDeleted(userId); // and Central Auth team sent a message verify(msgService).notifyCentralAuth(userId, CAAction.DELETE); 
I can't think of a tool that does what you want but I'd start by looking at [static code analysers](https://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis#Java). That would give you a starting point for examining any code that you have the source for which is a lot of libraries. If you don't have source I suppose you could examine the byte code but I wouldn't know where to start with that.
Thanks for the tips
&gt; If you mouseover a method in eclipse (or a reference to it) it will show you a list of every method it throws. That method isn't valid, as it throws an exception, but doesn't declare it in it's declaration statement. That should error and say something like "you need to add throws UnsupportedOperationException" to it. This is (among other reasons) so you're IDE knows it throws an exception. If I type a reference to a method called doStuff in apache commons or something... If it, or any method it calls throws exception the IDE will know (eclipse at least.) You just mouseover the method, and it will tell you. This is only for exception not already caught by a try-catch higher up the stack. "But how do you know which exceptions (including RuntimeExceptions) you should handle, without reading the source code?" try { Integer.parseInt("32"); } catch(NumberFormatException e) { e.printStackTrace(); } that will catch a NumberFormatException, but it will not catch, say...a NullPointerException. You have to explicitly say which type of exception you want to catch. In other words the behavior you want is exactly how Java works. To catch all format typed you'd use catch(Throwable t) or catch(Exception e)
That code is valid, it compiles on my computer :) Java does not require you to declare unchecked exceptions (RuntimeException &amp; its subclasses) in a method's throws section. See the last paragraph of https://docs.oracle.com/javase/tutorial/essential/exceptions/declaring.html
I don't think you understand the concept of RuntimeExceptions, which are a specific category of exceptions that are not intended to be declared (e.g. NullPointerException).
&gt; Unit tests don't fix bugs. I didn't say they do.
Ah, yes. So you know how in the Builder pattern, we set one additional attribute at a time? For each of those, we typically create class instance methods that return the same mutable Builder instance, having set the additiobal attribute. To make Builder instances immutable too, we keep the class instance methods that set one attribute, each. But instead of returning the same mutable Builder instance, we construct a new Builder instance each time. We do this by passing the current Builder instance ("this") and the attribute argument to a specific constructor. For example: public Builder with(final OrderId identity) { return new Builder(this, identity); } private Builder (final Builder root, final OrderId identity) { this.one = root.one; this.two = root.two; this.identity = identity; } As you can imagine, this pattern forces us to set up multiple Builder constructors, so it doesn't save any amount boilerplate coding there. But it does have the benefit of passing along immutable Builder instances. It generates tons of small, short-lived class instances, which, in the current JVM, forces us to increase the CG ratio. And from my experiencr, that works just fine. 
Ack. I need to learn how to get Reddit to format my coding. Any hints?
The reason why unchecked exceptions aren't required to be declared is because you aren't normally supposed to catch them, and because they can be thrown from almost any code. While it's true that some methods document some runtime exceptions in their javadocs and you might want to catch those, I wouldn't recommend routinely trying to catch all of the unchecked exceptions that could possibly be thrown by a method. Especially if they aren't explicitly documented by the author. A well-designed method will only throw an unchecked exception in two cases: 1) if there is a programming mistake in either the method or the calling code, or 2) if there was a serious and probably unrecoverable failure of the system. In both of those cases, you probably *want* the program to crash and print an ugly stack trace.
Yeah, it's kinda confusing for a newbie like me man. As far as I know, there's also a different view: Checked exceptions are a mistake &amp; all exceptions should be unchecked (like in C#, Kotlin, etc). Unfortunately some libraries follow this view too. I think JPA &amp; Hibernate does, it wraps SQLException (a checked exception) to javax.persistence.PersistenceException &amp; org.hibernate.HibernateException (which is an unchecked exception). So I got no choice but to handle 'em :(
[removed]
Haha thanks mate!
I think parent is spot on. I'd further offer my opinion that retrofitting unit tests as your first stab at unit testing is even harder. I cannot recommend enough the suggestion below of the book Working Effectively with Legacy Code. This book contains a ton of super valuable techniques for dealing with exactly what you're facing.
I didn't realize UnsupportedOperationException was a derived class from RuntimeException my bad. I think that's why it's compilable. I'm almost certain I've had an issue with that throws thing before. I suppose maybe you could use instanceof if statements in a catch(Exception e), but that probably doesn't produce the results you want. Missed a major detail of your question lol.
So they may not require a throws, but you can still use one. You can also specify catching those exceptions if there is intended behavior if one of them is caught. So if a nullpointer means field A isn't filled out, I catch it, and bitch at the user. That's just an aside though. I totally missed the RuntimeException part upon first read. 9am is early for me :(
No problem mate!
Yes, if you are using one of those libraries that only throw unchecked exceptions for whatever reason, then you will need to carefully catch some of those exceptions. But hopefully those are all well documented in the library code. And hopefully you have made sure that none of those bogus exceptions will leak into your business logic, for example by wrapping all your calls to the bad library methods with some code that catches the checked exceptions and either handles the failure or re-throws it as a checked exception. If your own internal and undocumented code also follows the practice of throwing unchecked exceptions when it should throw checked ones, then you have made your own problem and you need to deal with it. In the end, your original question asks "If I want to get the behaviour of checked exceptions from unchecked exceptions, what can I do?" And the answer is to switch over to using checked exceptions instead of unchecked ones.
How big is "extremely large"? How many engineers are working on it? What's the cost of a breakage? When the software breaks, how bad is it? 
Thanks for the tip!
JUnits give you the most reward for the effort it takes to write them when you write them with the code in the first place. They help you test your code as you write it, and give you confidence in the future that the code is still working as expected through automated testing. As you're finding out it's usually always significantly harder to write tests for code that already exists. When you write them at the same time as your code, you can make conscious design decisions to write your code in a way to support your testing. Doing so usually results in easier to maintain code. My advice would be to not let your current experience give you the impression that JUnits are not useful, you're just experiencing that its harder to write tests for code that already exists, which is definitely true
What stopped the removal? 
Can someone give me a TL;DR; in what's coming up in Java EE 8? I have not been following very well.
You don't pronounce it "essquel" like everyone else?
Generally what I do is I make sure there is a place the unchecked exception bubbles up to that will log it. Then I don't worry about it until I start seeing it in my log. Once I start seeing the exception in the log file at a sufficient frequency, I look to see if it's a problem I can do something about. Maybe there is bad data or a bad environment setting? Or maybe I can catch it and fix it during runtime? At the very least I can change the error message to something the user can do something about or report to support with enough information.
I pronounce it "squirrel"... Why how do you pronounce it?
Detecting an empty field by catching an NPE is a bit roundabout. There's a direct way to check whether it's empty, why involve exceptions that represent a programming error?
FYI, native code can throw, too, and it's hard for a tool to even detect that. For example, constructing a `ToneGenerator` on Android can throw an undocumented `RuntimeException` from native code if all of the system's `AudioTrack` resources are already taken.
I couldn't think of an example, but there are surely use cases for catching null pointers, and other exceptions extended RuntimeException. Actually I keep trying to think of use cases, and most of them just involve "the user gave bad stuff to a command," and should be handled elsewhere. The only thing I can keep of is a terrible 3rd party library doing something terrible, and it forcing a hackish solution. Actually I have one use-case which would be logging. You might throw something more specific for each exception to give extra insight into the problem. To me though this begs a very specific question: There are many, many java core classes which throw runtime exceptions. "Check input before doing the thing that causes an exception" seems like it'd be pretty bedrock knowledge now that I think about it. So why do core classes throw FileNotFoundException, NumberFormatException, etc instead of just asking for a callback if user input is messed up? I understand this would have been far more difficult until Java 8, but Java 9 is almost here. Are we creating unnecessary boilerplate in our applications? Would the cost of a Consumer&lt;Result&gt; or something be less than the cost of the exception? Sorry I know it's going off on a tagent, but now I'm curious. I've never thought about use cases for this stuff, and it led to a weird place. I assume there is a very good reason this is done. If I've had this thought I'm sure many far more talented individuals have.
Not sure this is possible. For example consider the method: public String getHashCode(Object object){ return object.hashCode(); } object could be null, so this could throw an NPE, even though it has no "throw" statement. Other such exceptions are difficult to predict (ArithmeticException, ArrayIndexOutOfBoundsException, StackOverflowException, etc...) even with bytecode analysis, since they are language features. Consider also decoupling techniques such as design patterns (e.g. Strategy), dependency injection, aop, and runtime bytecode instrumentation. At compile time it can be completely ambiguous what implementation will be called.
I personally feel like a lot of Java's exception use should really be a contract. For example, if you have a function taking a non-null parameter and pass null, I consider it a bug on the caller's side, not a recoverable error. This essentially leads to exceptions that should never be thrown in the first place. Midori is one language that actually went the contract route from the beginning with a lot of these, and Joe Duffy estimates a [10:1 ratio](http://joeduffyblog.com/2016/02/07/the-error-model/) on the two types of errors. Now that's not to say contracts would magically solve this. Firstly, existing code moving to contracts would need to do it incrementally. Contracts are hard to specify - they force you to think really hard about what a function requires and guarantees in a way that is useful and consistent with the rest of the system, which is really a good exercise and allows for pointing blame (to code, not people) when a bug is detected. It's very possible you get a contract wrong, and you don't want a contract that is incorrect because of some corner case to blow up in production or anything. Secondly, it can be hard to differentiate what should be part of the contract in the first place. For example, parsing a string to make sure it contains all digits just so that you don't violate a contract for a function that parses the string again is just a waste. C#'s `TryParse` etc. are good fits for this kind of situation. Another example is a contract requiring a sorted sequence (O(n) check) for an O(log n) lookup, which is typically handled by a contract level where the check is only performed as part of a nightly build or whatever. In the case of a contract requiring that a file exists, it can be downright impossible to guarantee the contract is being satisfied because the file might disappear between checking and calling the function - that's a good exception case. All of that said, there's yet another approach that involves neither exceptions nor contracts (narrow ones anyway). When parsing an integer, return an `Optional` (or a more fine-grained type if you want more error details). This is a tradeoff with contracts. The former is more rigourous, requiring every caller to ensure preconditions, but makes it easy to see the exact caller who violates one and is therefore broken. This approach is more lenient - if there's a problem with the input, the output will simply be empty, and that output can be chained to future operations pretty easily. I find that both are useful in different scenarios. Ultimately, bugs are easier to track down with concepts, but excessive checking can clutter the code in some cases. Sometimes indexing out of bounds is pretty normal and checking all the time is not worth it. Receiving an empty optional is great in those cases. Now in a way, Java's version of contracts is exceptions, specifically the whole side of the hierarchy that represents these types of faults. I'd attribute this to when Java was created. Perhaps different decisions would be made today. It wasn't all that long ago in the grand scheme of things that C# introduced [Code Contracts](https://docs.microsoft.com/en-us/dotnet/framework/debug-trace-profile/code-contracts) on top of a similar exception situation, along with a static analyzer to check for possible violations (with some extra help specifying what you expect, static analysis becomes a lot more useful). (Edit: In cases like C++, it's extremely valuable for the optimizer as well.) C++ has contracts in the works, but it has traditionally left preconditions as undefined behaviour. This is good for it, because now adding a contract there is perfectly valid under the old undefined behaviour. Unfortunately, there are also some instances of this, e.g., `std::vector::at` throwing on out-of-range when it could presently return a `std::optional&lt;Elem&gt;` (although `operator[]` was always UB). Rust has `panic!` in a lot of places for programmer error. Now you mentioned callbacks. This is essentially equivalent to returning an `Optional` or `Expected`. Ultimately, these are typically used with callbacks to access the data anyway. The situation gets better with some extra language support, as `async/await` do for futures. For example, Rust has `?`, which will return the contained result if non-empty, or immediately short-circuit the current function and make it return an empty optional or the error in the thing `?` was used on if there was no result. This linearizes the code using the results, and is actually a pretty viable solution for having no exceptions at all, although the same technique works with exceptions, too. I think this is the direction we're starting to move nowadays. I highly recommend reading that 10:1 link. It's long and it's completely worth it. A great comparison of different error approaches, and from that, you'll start to see how different languages are providing the same set or subset of tools in their own way. Oh, and on the topic of third-party libraries, I agree, it's nice when you have the ability to fix their mistakes. Ideally they would not trigger these cases, but even with contracts, there's usually a way around them. For contracts specifically, any violation is a bug that should never happen. If an assertion occurs in their code and it's not because of bad input you gave it, then the vendor should fix it. We all know the real world is less ideal.
well IntelliJ might be secure.. but there are keyloggers on your computer. I bet you Windows 10 has a special keylogger installed by the NSA&gt;
So TryParse is a good example. They could add tryXxx methods with callbacks to the existing classes and easily maintain reverse compatibility. When you say contracts I think of value types. Or even requiring parameters to extend/annotate NonNull. What exactly do you mean? If you mean C# contracts aren't they fairly large overhead? My understanding is interface dispatch is effectively done twice if you use preconditions. In C# in many cases it's already quite expensive. There was a post on the C# subreddit about it. I use a Defaultable interface that has a method to define defaults without gson getting mad. Maybe we need a proper optional class. If the object passing and such was handled like a functional interface it'd be far more performant. Atm it's slightly more pressure on the garbage collector and additional GC roots no? That low level context remains largely a mystery to me, and you post was detailed af, so I'm also kind of asking for more understanding.
Did anyone investigated, the help systems of Eclipse and Intellij idea for comparison? http://www.cvedetails.com/vulnerability-list/vendor_id-10410/product_id-20389/year-2011/opxss-1/Eclipse-Eclipse-Ide.html https://blog.jetbrains.com/blog/2016/05/11/security-update-for-intellij-based-ides-v2016-1-and-older-versions/ 
good point. however Sun didn't give much shit about Java GUIs. They could have created a Java Store on windows which would run the JVM non stop creating an eco system on top the OS. They were so dumb stupid.
When I say contracts, I mean mainly being able to specify preconditions, postconditions, assertions, and invariants, being able to choose what to do when they're violated (throw, abort, run a custom piece of code and then resume), and make use of them to optimize the code or get better static analysis. Most people turn off checking on release builds, although there are many, many cases where the cost of checking is negligible because it's not in a tight loop or anything. All the cost is, though, is as if there were an `if` statement that runs whatever violation handling you need if false. Perhaps there's more and I haven't heard about it. Not many people would think much of an extra cost for debug builds considering it goes away for release. That said, there is still value for release mode contracts (as Joe explains in that Midori link), one being that you no longer have to pick some action if there happens to be a violation in release (because when ignoring the check and the program is in a bad state, who knows what will happen if you don't have a fallback). This is something exceptions offer: a violation behaviour that stops continuing the program in a bad state and works in release without an extra fallback. As for a proper optional class, Java 8's [`Optional`](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html) is what I was referring to for Java, and I'd say it works well besides the lack of value support in the language (meaning there's potential for both an empty `Optional&lt;T&gt;` and a non-empty one containing `null`, although the class specifically doesn't allow that, but still has to check when you create an object). For performance purposes, you're not going to get much better than C++'s optional, which avoids heap allocations by storing the object directly in the optional's space, most optionals being on the stack. I could see Rust doing the same thing with its language enum (sum type, more generalized than Java enums) support. As far as Java's goes, I can't imagine the double-dereference (one for the optional itself and one for the value) does it any favours, but I also doubt it makes a real impact except in rare cases (tight loop etc.).
Why would you need this? You should catch only those exceptions that uou can recover from, and let all others propagate to the piece in the stack that can handle it.
&gt; Heroku i like their java tutorial
backward compatibility, Allowing people to move their stuff to JavaEE 7 and follow a gradual migration path, rather than big bang redevelopment.
Eclipse has content assist. You hover over a method, it will tell you what exceptions it throws. If you make your own method and to something that requires exception handling, but do not put it in, Eclipse will put a red circle in the left margin. Hover over it and it will tell you what you have to handle. Eclipse is free.
Thanks so much for this reply! I just assumed Mockito was simply for mocking objects. I'm going to read more into this. I use constructor-level injection as well. Things get so much easier with testing the POJOs when you don't have to start up an application context
So anyone can be encouraged to use/contribute to your stuffs?
And this is why peppering your code with RuntimeException is not cool. Not cool at all.
&gt; 15 packages are using underscore or enum as a keyword, which hopefully should be easy to fix everywhere. I think this means to say "15 packages are using underscore or enum as an identifier, which hopefully should be easy to fix everywhere." * `enum` became a keyword in Java 1.5 IIRC * `_` as an identifier became a warning in Java 8 and disallowed in Java 9. It looks likely that it will be a keyword (or more correctly perhaps, a special identifier) in JDK10. The whole `--source`, `--target` thing has been replaced with a `--release` mechanism instead. This should be better (compiling against not only the same grammar and to the target class-format but also against the right API) but might trip up, if it can't find the older java version to use, as the [JEP](http://openjdk.java.net/jeps/247) reads as though it needs images of the targeted release. Another avenue for failure might be that some combinations of GC have been dropped so a build might succeed but execution could fail. Great exercise though. I think a lot of devs will be wondering how easy it will be to move to Java 9 - there are some compelling reasons in development and runtime environments to want to do so. 
Down voted because the question being asked is unabashedly racist.
Possibly check out how the MariaDB JDBC driver handles these things as it covers some of these scenarios e.g. the JDBC Connection API has the concept of read only which should then delegate requests to read replicas and frameworks like Spring leverage this via the @Transactional annotation. It also has failover behavior which may be similar in some ways to what you're trying to achieve. More information here - https://mariadb.com/kb/en/mariadb/failover-and-high-availability-with-mariadb-connector-j/
All of the applications I've written which involve read-replicas already explicitly use a second database connection pool for read-replica directed queries. Basically if the code is doing a db write OR a select involved in a transaction which involves a write, then it would use the primary connection pool. Otherwise it would use the read-only pool. There is an implicit assumption that the read connection pool queries might yield data which is be behind as a consequence of replication delay. But to your question more directly. Pretty much all java relational database interactions go through an interface called JDBC. As long as you can stick to that interface you're good to go WRT interaction with all the various ORMs and other frameworks.
 &gt;There is an implicit assumption that the read connection pool queries might yield data which is be behind as a consequence of replication delay. Right, that's exactly the thing that this feature helps with. After tx1 commits, if the same client thread runs tx2 on a read-only database, or tells some other thread/computer/microservice/whatever to do so it'll definitely see tx1 or fail and be told to go elsewhere. This should allow more read-only queries to be run elsewhere: right now people can only really do it for transactions that can stand to see oldish data (reports etc). &gt; But to your question more directly. Pretty much all java relational database interactions go through an interface called JDBC. As long as you can stick to that interface you're good to go WRT interaction with all the various ORMs and other frameworks. Thanks! Aware of JDBC, it's really the pooling, rerouting and transaction-level retry management that I'm asking about.
Java 9 is another nail in Java coffin. 
&gt; https://mariadb.com/kb/en/mariadb/failover-and-high-availability-with-mariadb-connector-j/ Thanks. Yeah, following the same approach Spring @Transactional annotation seems like the way to go. And they also have a concept of blacklisting hosts based on *connection* failure. Doing the same type of thing but extending it to cover certain magic errors too would seem the way to go. But that leaves questions 2 and 4: how to intercept special errors and how to retry whole transactions (J2EE requests).
Checkout the failure detection behavior on that page specifically the part about "The query that was read-only will be relaunched and the connector will not throw any exception." This makes it sound like when the exception occurs on the read only slave node the driver can seamlessly retry without having to bubble up the exception to the calling code. That may be analogous to what you're looking for then - would have to checkout the drivers source. 
Python is a very useful tool, and a powerful one. Still java is the language adopted by most corporations, and big companies cause on larger scale it has better performance, scalability and is more diverse. Also java would bring other languages with almost same syntax that run on jvm. In larger companies you will see python mostly adopted by devops for automation, while most apps run on java. Plus you have android development
It's not a question of superior language, it's a matter of use case. Which one makes more sense is based on what you want to do with it. 
Thanks, I see. I don't think it's going to be possible to do retry inside the JDBC level with sane semantics for PostgreSQL though. We have snapshot based transaction isolation: if the statement is part of a REPEATABLE READ transaction, we can't just run it again somewhere else because it'll get a new snapshot, and even for READ COMMITTED I'd be hesitant to have a transaction split into multiple transactions with different statements run on different nodes -- time might go backwards for them for example. I think we need the exception to reach a higher level, where the whole transaction can be rerun. And by transaction I really mean the request the container is handling. Maybe something like this: https://dzone.com/articles/automatic-deadlock-retry But I can't find many people writing recently about this type of thing, or 'standard'-ish libraries...
All of those are good options. If you like Python and already know it, there's nothing wrong with sticking to it. It's definitely better to know one language very well then to keep jumping between different ones and not learning much. Python is a perfectly good language and quite popular in industry. That being said, it would be good to learn multiple languages and get a broader view of how things can be done, being able to see differences between languages and learn new languages will help your knowledge overall. Java is also a behemoth in the workforce so you will find many work opportunities. If you know both Java and Python instead of just one it will open many doors. Ultimately it depends on you. Neither java nor Python is a "better" language than the other although they are quite different from each other. It would certainly good to learn both. If Java interests you, you should definitely give it a look. 
May I advise Kotlin? It's like Java, but more fun! You're programming for the JVM, so you can use all of the regular Java libraries, but the language is less verbose and more powerful.
Good about _ not being allowed. The single most irritating c# convention that pops up a lot is _ prefixing private fields.
Unfortunately `_` isn't being disallowed in names, just variables being called `_`
One thing I will add, which should be obvious. Writing unit tests is for the developer. You. Its not for the business, not for the customer. not to please a boss. Its for developers. So write the tests to inform you not only if there is something wrong, but if things are working right, don't error (false positive). Ive seen so many tests that are built by: 1) Create the first part of a test that calls a bit of code. 2) Run the test in debug, capture the output of the code. 3) Copy paste this output into an assert Equals, in the test. Basically, you're testing the code does exactly what it does. This is not a test at all..... You cant do this, it would only take changing the output a bit, adding an extra flag, and boom 100'd of test failures to go fix. Instead, when you write tests, they need to be more intelligent.... Instead testing an entire response matches a hard coded one, in the test you should break apart the response and test if certain elements you expect to be there are there. For example, a json output you might Check if an active flag set to 'y', and name the test to say what you're doing. Even if this means the same code is run several times, but the output is checked in different ways. Then when the code changes, as it always does, you don't need to go and refactor tests, they should continue to work with the slightly different output as long as that output still contains the information the test requires.
Learn any one language well and you can figure the others out as you go. The best tip i can give for anyone who wants to learn any language well is ide avoidance at first, ide's are productivity tools not learning tools. Also learn to code without google. Good luck, at times it will be hard, stick with it, it is a rewarding profession. 
No fear, you get the Hungarian *m_* instead, usually littered across all Android source code. Oh and that isn't a C# convention at all, you won't find it in the Microsoft documentation about .NET naming best practices. Like on Java's case I bet it comes from C and C++ ex-converters that miss Hungarian notation.
&gt; I don't think it's going to be possible to do retry inside the JDBC level with sane semantics for PostgreSQL though. Upon further reflection, maybe it could work. For REPEATABLE READ, it so happens that the new error can only be raised for the *first* statement executed in a transaction, and that's also the only statement that you could magically redirect to another node at the JDBC driver level. For READ COMMITTED, maybe it'd be OK in an early version to redirect on error for the first statement, and just let the error hit the user if the error happens on any later statement. I suspect by automatically handling the error on the first statement you'd be handling most cases anyway. Redirecting automatically on later statements would also be an option too, with some caveats. So yeah, I take some of what I said back. That could probably be made to work with useful semantics. (Still interested in how to handle retries at a higher level too though.) Thanks for pointing this out!
That is exactly what mocking frameworks like Mockito or EasyMock do, and quite conveniently.
What are you trying to achieve? A language is just a tool. And they are in general tools that very much overlap. You need to know what you want to do before you pick a tool to use. 
If one day you want to start working in this field, I'd recommend Java by far. It's used by many companies for server applications and it has a lot of interesting frameworks (Spring, Akka etc).
I know it's not personally and I agree about the trends. They are global problem, not only in programming and internet. Thanks for programming suggestions - will explore everything. Can you be more specific about coding styles ? I checked couple of months ago this: http://www.oracle.com/technetwork/java/javase/documentation/codeconvtoc-136057.html and I usually try to write "standardized" code.
Yes, the one you referred is the canonical sun style. Still in widespread use. Your code is not compliant (mostly spaces around braces, I didn't check for tab use)
I've never seen this in Java except in devs that came from C#. I've seen it in C# a lot. You may not see it in any official style guides or anything, but it's an extremely widespread practice. Google "underscore private field C#" and grab some popcorn if you're curious just how widespread. You will run into some very venomous debates. 
Dammit. I'll be correcting goddamned _privateFields forever.
Haha I don't get into venomous debates but I do really like the convention
&gt; Is REST still the standard? What I'm seeing in my projects (I work as a consultant so tend to switch every 1-2 years): yes. Or well at least JSON-over-HTTP is the standard, not everyone takes the 'REST' bit that seriously :) I do think it's a good approach to go for since it can tie in very well with whatever client you want to create (desktop, mobile, web). &gt; Any advice or similar migration experiences would be greatly appreciated. We have quite a few clients doing pretty much just that. Angular is well established and most new front-ends our clients are building are done in Angular (with a few React and Vue.js front-ends mixed in). I would suggest, if you haven't already, to try and get some training on how to set up the whole front-end build pipeline including the compilation from TypeScript to JavaScript. That bit is quite important to get right. I would myself start by migrating the existing system from RMI to REST module by module, thoroughly refactoring where needed. And also in parallel start building the web app; a very bare bones version that's mainly there to dog-food your REST API to make sure it's suitable for a web application. Also make sure you properly set up your front-end development stuff including things like code-linting and tests. Even 'simple' front-ends get complex fast and testability needs to be part of development from day one. 
I love kotlin but I think it's definitely for people with an existing knowledge of Java.
It's a bot ;)
I don't know, existing knowledge of the frameworks, classes, etc would help, but if you're learning it fresh it might be an advantage to not constantly compare to Java.
Why?
That, but also Oracle's year long inactivity. When they came "back" they mostly panicked about releasing stuff that was done before.
https://www.reddit.com/r/java/comments/6kcwrq/performance_differences_in_linux_distros/djnxiha/
&gt; Never let Java swap. Set swappiness to 0 and have plenty of RAM Or user zswap instead normal swap partition/file. If you get over the expected RAM usage, the kernel would compress RAM pages using a bit more of CPU, instead doing slow I/O to the hard-disk and a obvious slowdown of the whole server. In my case, we have a Tomcat publishing many java webaplications and a scheduled "batch tasks" that occasionally could have peaks of RAM usage over the normal expected usage. So zswap here comes very helpful as we avoid that the VM becomes very slow on these peaks. 
I use https://plugins.jetbrains.com/plugin/7138-frame-switcher mappend on Alt-W for switching between projects, including closed ones.
this http://bedroomcoders.co.uk/using-dyn4j-with-javafx/ might be of interest to you dyna4j is a 2d physics lib (using this gives you a lot for "free" - collisions and so forth) the article might be a bit out of date, but if should be a start... 
Because when transition to next version creates so many problems, it is very inconvenient for developers, and when developers are unhappy, they start to use different tool. 
Java is not write once run anywhere anymore. It doesn't work on the same platform anymore. 
I guess it depends on the area where one lives. But given that Hungarian notation is mostly a Windows thing and C# lives also mostly on Windows, I would imagine that plays a role.
And that's why angular 2 was a complete failure and nobody used it? /s
The good thing about Spring is that it can be adapted to basically anything, by using the parts that you need. You should be able to get very far by using Spring MVC (and Spring Boot) to handle your REST-endpoints, and using your existing code to handle the backend. If you want to be able to Autowire Spring services and components, you do have to move away from static initializers, if you have them. Other than that, go ahead. Angular 4 (and TypeScript) was very well liked by our Java backend developers when they had to do frontend, especially the types in TypeScript, and personally I like it a lot too. Spend some time to set it up correctly up front, and you will save time later. Also be aware that a lot of early articles on Angular 2 (4) are outdated, and no longer work. 
&gt; An app server compiles the code you wrote yourself in an entity class. Last time I checked my compiler did that for me ;) The distinction you're making is rather strange. Java app servers in general very much handle HTTP requests. What the developers 'sees' is just an abstraction on top of that. 
no, sorry. It was presented at a tech talk, I think in either Devoxx or GOTO they were talking about TDD and stated following: * writing boundary tests: `t` * writing production code: `t` * thus total sum: `2t` with t as time and order not as important since you write both at once, just writing tests first is best practice If you write production code long before tests first: * write production code: `t` * debug production code: `2t` * test production test: `4t` basically stating that understanding an already written production is much harder than writing it in the first place and if you want to add tests afterward, then you need to add into the account all the kinks your code already has und understand the business logic behind that and why the technical implementation looks like that.
As I understand it, `_` is probably going to be used for [unnamed, unused parameters in lambdas](https://www.infoq.com/news/2017/01/java10-lambda-leftovers). It reminds me of the same use in pattern matching in Erlang. 
I've actually seen this style recently in some sample Java code: String $label = "Are you sure this isn't Perl?"; I will not be carrying that over to my code.
I've only ever used Mockito to mock method return values. I'm really happy that I learned it could verify calls as well.
Java is widely used in the industry, so it's good to learn if you want to work with programming. I wouldn't say that it's a particularly fun or interesting language, though (sorry, guys ;) ). If you want to learn another language after Python, definitely go for something statically typed. Java fulfills this requirement, but so does many other languages, including the C family of languages. If you want to get close to the machine, maybe learn about operating systems, plain old C is what you want. It's a lot less friendly than Python, but it gives you far more control over what your computer is actually doing. C++ is C with classes, or alternatively "C with everything" - it's used a lot for video games because it's fast (if you know what you're doing), but gives you more tools than C. C# is a solid language, very Java-like in some ways, but gives you access to the .NET platform. You could also go in the opposite direction and find a functional language instead of an object oriented or imperative one. If you like elegant abstractions inspired by mathematics, this is the way to go, and if so, I recommend trying Haskell, although that's just my personal favorite - there are many good functional languages out there (F# if you want .NET, Scala if you want the jvm, SML if you wanna go old school...).
Sometimes in function arguments, we'll format them one-line-per-variable when they have more than 3 arguments and/or we expect it to increase. Makes for less merge conflicts and cleaner code reviews, but it is verbose at times. Everything is a matter of trade-offs. The key is just to know what you are trading off and try to make the best decision available. 
Testing has benefits and costs. You have to work out whether the benefits outweigh the costs. If you write tests without understanding the benefits, then you are liable to produce a test suite that delivers no value. Equally, if you write tests without understanding the costs then you will not allocate sufficient resource to realising the benefits. You are completely right to question whether or not testing is worth it or not. However, I would be sceptical of any answer that lent towards the extremes of "Testing must be done categorically" or "Testing is pointless" #Benefits I like to think of tests as describing the behaviour of some part of your system. If you agree then I think the value of testing is twofold: ##Documentation Your test suite documents what the behaviour of your application should be. If you are unfamiliar with a part of the application because another developer has written it then referring to tests let you know how it is supposed to work. You can understand the code faster because you are able to distinguish between expected behaviour and bugs. Pieces of code whose intent is unclear, and made clear in the context of their tests. This is especially helpful when new team members join or old team members leave and more helpful with more complex applications, or applications that require larger teams. ##Validation Your test suite validates whether your application behaves the way it should. When making a change, it may have unintended consequences to other pieces of behaviour. Your tests should fail if some behaviour has changed so you can decide either to accept the change, and update your tests, or reject the change and adjust your initial work. This is also useful when you get people who insist that the application is supposed to, or did work in a particular way. You can prove that the application is supposed to function in this way, if you have a test that shows that. #Costs ##Writing Each test takes some time to write and that time will be increased if the piece being tested, is not very easy to test. However, you should be tactical about what tests you write. Remember why you are writing tests and use that to guide you. Sometimes it is much easier to test the behaviour of a cluster of classes, than an individual class. If you find a class hard to mock then don't mock it. Find the edges of your system and work inwards from there, incrementally making each level easier to test as you decide it is worth the investment. Consider writing the tests first for new pieces of functionality, separate from the existing system. This will reduce this cost as it will guarantee the new code is easy to test. ##Quality Tests are pointless noise if they either never fail, or don't fail when the behaviour of your application changes. Unfortunately, it is difficult to write tests well and so you are going to need to invest some amount of resource in quality controlling your test suite. This may come in the form of training, or agreeing testing principles in your team. It may come on a more ad hoc basis when a developer must fix a test that is failing because it is too brittle. I don't think there is much you can do to reduce this cost. If your team is bad at writing tests, then it is not really worth the effort. You need to invest some time in making sure they are useful. ##Visibility If your tests are not run automatically, and if the results are not immediately visible to all team members, then they are in danger of rotting. Eventually you will declare test bankruptcy when you delete large numbers of tests that all fail, but are not worth the time to try and fix. You need to be running your test suite on every change and publishing the results somewhere where all team members agree that they will look. You need to prioritise fixing test failures over developing new features. This will require some resource to setup and look after e.g. a Continuous Integration server.
first - there are no superior languages there are just those better suited to a particular task if you've got a good handle on python i'd say learn java. its becoming the COBOL replacement in that businesses run lots of stuff on it. C++ if you want to work closer to the hardware
Definitely interested in this! Share away
I don't have much thought on the "how" this feature would work, but I would like to say it's really appreciated that you're working on it. I've been following the Causal Reads threads for the past couple years, and really hoping they make it in. It has been a pain point for my application to have to in most cases use the primary for queries which could be satisfied by the slave if only we could ensure prior commits would be seen. Are you planning on modifying the JDBC driver to handle this, or creating a whole new piece of software? I'd think creating a PR for the JDBC driver would give your code a whole lot larger install base pretty much instantly.
Do not get hung up on RuntimeExceptions because they are undeclared. Fact is, even checked exceptions are undeclared. How? You just need to execute code that is not part of your project (e.g. a JAR with a driver or other implementation of some interfaces) then all sorts of compile time unknown checked and unchecked exceptions (i.e. sub classes of checked exceptions declared at the interface) can be thrown. So, formally you cannot even know all exception types that could be thrown at runtime as long as there is code used which is not part of your project.
We are currently using JSON over WebSockets for our existing mobile and web offerings. These are lightweight companions to our primary Windows client. However, I am not sure we are doing things the "proper" or "standard" way right now. By that I mean we basically have a broker that handles passing the messages back and forth. Our Application server has a few different ClientEndpoints that receive the messages, call some methods, and send a response. It is working for now and has been a solid short term solution. The server being able to communicate with the client without an initial request from the client is definitely a nice benefit. Each of our clients has their own server behind a private network. The broker handles determining which back-end server to send the messages to/from based on the user of the mobile and web applications. I am just unsure if there is a current framework in place for dealing with WebSockets in a similar fashion that would also make sense.
&gt; We are currently using JSON over WebSockets for our existing mobile and web offerings. These are lightweight companions to our primary Windows client. Would've been worth mentioning ;) No problem in extending that functionality so the primary Windows client also uses these for communication. 
Yeah this is great stick it up. Currently the Java compatible version they link to just binds to the original native implementation right? A pure Java implementation would be nice.
&gt; Like on Java's case I bet it comes from C and C++ ex-converters that miss Hungarian notation. The underscore-prefix-for-private-fields might come from Python instead, where it is the official standard. (And double underscore for truly-private-I-told-you-so fields.)
Languages are not superior. Jobs and/or the language required for the job (lower case job) are superior. So don't pick up Java just because. If you're a "Python guy" you can get a "Java job" just fine (assuming you're appropriately proficient in CS concepts). Languages are just how you get meaning across. They're not the meaning themselves. That said, we only have so much time on this good green earth, so don't pick too many languages to learn or you won't have enough time to master a few of them.
Right, well I guess the issue is I am not entirely comfortable with how those are currently set up. The Broker web apps are deployed using Tomcat and I've had some memory/CPU issues there. This is not a bad solution for the mobile apps since they only handle about 25 different method calls whereas the full fledged Windows program will need a much more robust API. There seems to be a lot more resources available for going the REST route, and I'd rather not have to create an entire framework from scratch for WebSockets.
There is no such things as a superior language. There are only languages that are right for the job you want to do.
use the Now for Reddit app, youre welcome
LOL
Learn both, I believe Python to be very complimentary to Java because some times their is better availability/support for Python and vice versa with Java. If you learn Java, Python, and JavaScript. You will be able to tackle a large set of projects.
&gt; Right, well I guess the issue is I am not entirely comfortable with how those are currently set up. The Broker web apps are deployed using Tomcat and I've had some memory/CPU issues there. You need to profile the application to see where the problem is. I wish I could help but I unfortunately don't have a crystal ball ;) &gt; here seems to be a lot more resources available for going the REST route, and I'd rather not have to create an entire framework from scratch for WebSockets. Spring Boot handles websockets just fine. You can even mix WebSockets together with REST endpoints (since Websockets are just upgraded HTTP requests) in a Spring Boot application. I wrote a [blog post](https://niels.nu/blog/2017/spring-boot-websocket-client.html) on Spring Boot and websockets (using Stomp messaging) a while ago. Going for a REST API is definitely the easiest route though, but they don't allow you to push information to the client. Is that a requirement?
I bet you don't know what you are talking about. Every IDE is fine, the problem often sits ib front of the Monitor. Overthink your priorities man.
Learn Java if you want to have a career in programming.
But does it has dynamic connection pooling? I guess its really suited for the fixed size pool. May be I'm wrong here. 
&gt; https://github.com/vladmihalcea/flexy-pool Thanks for the reply. Will definitely take a look at them. 
This must be the most bullshit buzzwords per sentence in an article possible before it reaches critical levels and self implodes from all the hot air getting out. Reactive, scalable and resilient microservice architecture? I'm so fed up with where IT is heading since MBAs smelled the money. 
I came to the same conclusion, after doing an indeed job search in my city by programming language I realized I'd be foolish to neglect to learn Java on the side based on how many jobs there were available (also SQL as well). So I ported my c# side project code to Java and now the Java port gets my priority. There are a lot of languages that are gaining popularity reasonably fast (python, Swift, rust, c#) but that doesn't mean there are an abundance of jobs yet.
You need to know the upsides and downsides of a tool to pick the right one for the job
Knowing a language's syntax isn't knowing a language. It's more about what a dev do with that syntax that counts.