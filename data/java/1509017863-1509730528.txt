As usual, thenewboston is a discouraged/garbage resource. Don't even look at his channel.
He's joking obviously. 
Nope, no reason
You still have a huge suite of TestNG tests and no budget to rewrite them?
I wrote an article about this a long time ago, but it's still largely true: https://henk53.wordpress.com/2013/01/09/the-curious-case-of-jboss-as-7-1-2-and-7-1-3/ Essentially WildFly is a public beta and early ones can even be seen as Alphas. The WildFly that is released just prior to a major EAP release is mostly feature complete, but missing a final amount of bug fixes. WildFly is essentially a parallel versioning scheme. For some time even translation tables were published. E.g. WildFly 8.0.Final was JBoss EAP 7 Alpha 1, WildFly 8.1.Final was JBoss EAP 7 Alpha 3, etc It doesn't mean though that you can't ever use WildFly in production. If your app works on it and is tested well, then you may just be using a subset of WildFly that's stable enough. The proof is basically that Red Hat themselves don't really recommend WildFly to be used in production either and specifically don't support it. While you can use JBoss EAP in production via self building (it's LGPL after all) and without a support contract, most half serious companies are probably better off getting a support contract anyway and an explicitly supported binary (which is the one you download from Red Hat).
Ok, legacy code is always a reason to stick with a certain framework. But to be clear I've added the condition "for a new project" to my question.
Honesty it kind of feels like you are taking a step backwards from some of the major benefits of jOOQ such as type safety. It's also a bit confusing that sorting params and filtering params are passed in the same map. Made this up on the spot so not fully complete but you get the idea. public class DateRange { LocalDate start; LocalDate end; } enum SortOrder { ASC, DSC } public class SortBy { String / Enum / constant field; } public class PersonSearchRequest { Long id; Long authorId; DateRange dateCreateRange; Boolean isAdmin; SortBy sortBy; SortOrder sortOrder; } public List&lt;Person&gt; findPeople(PersonSearchRequest request) { Condition cond = DSL.trueCondition(); Seq.of( Optional.ofNullable(reqest.getId()).map(Tables.PERSON.ID::eq), Optional.ofNullable(reqest.getAuthorId()).map(Tables.PERSON.AUTHOR_ID::eq), Optional.ofNullable(reqest.getdateCreationRange()).map(range -&gt; Tables.PERSON.DATE_CREATED.between(range.getMin(), range.getMax()), Optional.ofNullable(reqest.isAdmin()).map(Tables.PERSON.IS_ADMIN::eq), ).filter(opt -&gt; opt.isPresent()) .map(Optional::get) .forEach(c -&gt; cond = cond.and(c)); var query = context.selectFrom(Tables.PERSON) .where(cond); if (SortBy != null) { Field&lt;?&gt; field = sortColMap.get(sortBy.field); SortField&lt;?&gt; sortField = sortOrder == SortOrder.DESC ? field.desc() : field.asc(); query = query.sortBy(sortField); } return query.fetchInto(Person.class); } * Fully type safe. * We aren't passing Maps of Strings around which is unclear what is happening * You can easily build reusable query parts * Conditions can use more than a single column * Everything is explicit so its very clear what is happening.
did they decide which syntax are they going to use? I just hope thay use Scala/Kotlin var and val, no auto or const
I don't see any traces of the original JUnit in JUnit 5. Since it now has a lot of the stuff from TestNG, why not use the library that introduced them, ie. TestNG? I mean, TestNG is not finished. They are still improving it, no? So, since you preferred TestNG why switch to JUnit? Because of the brand name?
I wouldn't call tests using a modern library "legacy code" just because another library was released and it is presumably better in some area.
I wonder why Java has no standard APIs or annotations for unit testing? Wouldn't it be more portable? Maybe it is too hard of a problem...
Cool. :) Sorry to be pedantic.
Your example is simply good ^^ And yes my API is very similar as well with more or less same amount of code in each repository (pure jooq code example I did very similar XD ). In my API, it is type-safe, values are passed to parsers and throw exception if value cannot be parsed. The Map does contain filters and sort keys/values but sort values are ignored (and used with Pageable from Spring) and only filter key/values are contained in it with sort keys ignored. In Spring REST API in a GetMapping, how do you get PersonSearchRequest and DateRange? With @ModelAttribute or something else? What does the client of the API needs to send? (I guess json but how do you get the url to contains the values of filtering and sorting so the link can be shared :) ) How are handled bad values? -&gt; bad date/int/datetime/etc format when building your PersonSearchRequest How are handled excessed params? 
I'm using TestNg mostly beacuse of parameters. And reading [junit docs](http://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests) I found &gt;&gt; Parameterized tests are currently an experimental feature So I'm not ready to move yet. Also the equivalent of TestNG dataprovider is somehow verbose //JUnit static Stream&lt;Arguments&gt; stringAndIntProvider() { return Stream.of( Arguments.of("foo", 1), Arguments.of("bar", 2)); } //TestNG @DataProvider public Object[][] stringAndIntProvider() { return new Object[][]{" {"foo", 1} {"bar", 2} }; } That said, there seems to be more options as sources of parameters inn JUnit, so once it moves from experimental I'd probably start using it for new projects, mostly because is more known and tools are usually more junit compatible.
That's what I meant. I burned a lot with running WildFly in prod(memory and resource leaks mostly) under not so heavy load(we were not 'big data' at all). Don't know why so heavily downvoted though... 
Happy to see this release, however, I am concerned about the slow rate of change for Wildfly. A year just to release an updated security stack? Websphere Liberty seems to have all the momentum these days in the Java EE space.
I think Mark Reinhold is thr ome doing thr bikeshedding, but it’s noy as if multiple things can’t be worked on at once. This isn’t slowing down progress on anything else.
&gt; In Spring REST API in a GetMapping, how do you get PersonSearchRequest and DateRange? I don't use Spring but i'm sure theres a few ways to do it. You could just use all query params then construct the object manually. Or I think there is a way to annotate the fields on an object and have the query params pulled into it. &gt; What does the client of the API needs to send? (I guess json but how do you get the url to contains the values of filtering and sorting so the link can be shared :) ) Again this is up to you it could easily be a GET request with a query String. I only build out the repository code it doesn't dictate anything about the endpoint. &gt; How are handled bad values? -&gt; bad date/int/datetime/etc format when building your PersonSearchRequest Validation should be handled way up the chain probably in the resource layer or service layer. &gt; How are handled excessed params? Same way as you would any other way. &gt; The Map does contain filters and sort keys/values but sort values are ignored (and used with Pageable from Spring) and only filter key/values are contained in it with sort keys ignored. This part is a little hidden away which could confuse people. They would also be force to use the exact naming you use. Which might be ok if it's the Spring standard. I think it's a cool idea but personally I don't see much value added especially since I don't use Spring. I'm also someone who prefers everything to be explicit. I'd rather see the query being built than passing some objects to a method that magically build it.
wrong sub
**Sidebar** **NO programming help, NO learning Java related questions!** Also, **no** related subreddit allows links to stackoverflow questions. We are not a second opinion to SO or other sites. If you don't get help there, you won't get it here.
yea I understood that eventually. sorry im pretty frustrated with this one. 
Ehh... I don't buy that reasoning at all. Struts introduced many of the concepts found today in Spring. Would you start development on a greenfield project using Struts in 2017? Libraries are constantly evolving. Borrowing from what came before, and each other, etc. "Standing on the shoulders of giants", and all that. Reasons to stick with an older library, when it seems superseded by newer alternatives, include: * You have a lot of legacy code using the old library that you can't migrate, and adding a second standard just splits your focus and increases the learning curve for new devs. * The differences between the old stuff and the new stuff are pretty minor, and/or the old thing hasn't been around that long anyway. In other words, JavaScript churn fatigue. * You believe that the older library has only been temporarily superseded. That it will retake leadership (or at least relevance) with its next release. However, I don't that "*it's had some great laurels in the past, let's rest on them!*" is a good reason for using outdated tech in a greenfield project. You're swimming upstream in terms of community support and developer recruiting, for no concrete reason.
&gt; I had a personal JRebel license when it was $65. I had to move away when it got up over $250. This is surprising to me. I will look into this, but are there any missing / Pro only features? no its full featured. It's hard to find this information that its free they dont really advertise it.
The idea is that in many (I'd say, 'in most') cases you don't actually need to explicitly name the type of the variable. It is either obvious or not so important. When you read the code, the main information you are reading is usually the algorithm itself. You read, where do you take the information from, how you filter that information and where do you send it. So, overall, it does not make code any less readable. In some rare cases when the exact type is really important and it is not obvious from the code, we may explicitly type the type's name.
Haha
Moderating a subreddit requires a good understanding of reddit and is no trivial task. That's why it should never be left to newbies. Commonly, newbies become megalomaniac dictators instead of sensible moderators.
A Promising Solution: https://github.com/ota4j-team/opentest4j
I do find this weird. Especially when you look at unreleased stuff in OpenJDK. By the time it's released, it's decent, but in the interim?
My experience is completely counter to this. Variable names are in most cases inprecise or even lying. The type needs to be visually present to give enough context to understand a variable or what to expect with it. Just the variable name is nowhere near sufficient.
As you point out, junit doesn't really have its pedigree any more. It's like a less battle hardened testNG.
Cool, they fixed Spring Boot autoconfigured webapp: resolve model variables https://youtrack.jetbrains.com/issueMobile/IDEA-132738 
If instead of being called JUnit 5 they would have called it Test5000 and launched it as new competitor to TestNG, would people use it? People wouldn't switch from TestNG to this new Test5000 for "outperforming in some areas". So, it's a matter of picking the bigger "brand", not the best solution. I don't see how all of a sudden TestNG is 'outdated', 'old', 'superseded', 'legacy' or the whole situation even comparable to Struts vs Spring. The latest TestNG release is from March 2017. JUnit 5 is a sequel to keep the brand alive. And it is using the brand awareness to position itself as a layer in every stack regardless of the test library used. It lost its way: &gt; JUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage ... what is this stuff?
It's *var*, there's no *val* as you can already use *final*.
Why not?
Oracle is looking for something suitably evil to bundle with the Java installer at java.com. /s 
Could you give some code example?
 @Before public void backup() { var src = prepareSource(); var dest = prepareDestination(); move(src, dest.toString()); } 
I'm stuck on eclipse, I've tried intelliJ before but I felt too spoiled. 
Well, Ok. I don’t think that will happen to me 
The new rest client seem really cool.
Holy shit that changelog is amazing quality of life for me.
How does this work together with Java EE Security?
Sorry for the delay. I'll look into this soon, currently on the road with little time to provide feedback, though. I will, though!
&gt; I'm pretty sure it works exactly the same as the paid version. Yes, almost. As of version 3.10, these are the differences between the commercial version and the Open Source version: - Commercial only: Commercial database support - Commercial only: Java 6 and 7 support - Commercial only: Scala 2.10 support [See also here](https://www.jooq.org/download). Apart from the above, the two editions have the exact same feature set and are largely source and binary compatible.
I don’t know what “experimental” means in this context but so far, I’ve used parametrised tests in JUnit 5 and they are great! For the simplest cases there is CsvSource, that is probably the least overhead syntactically. 
Supremely nice. That's all.
lol you felt too spoiled by IntellliJ? Such a humble guy!
It's true lol
TestNG was a relatively niche even before JUnit 5 came around (even if it had a loyal following). So I don’t really think we can talk about JUnit 5 (Jupiter) superseding TestNG. If it is superseding anything, it is JUnit 4. Even there the parentage is more symbolic than anything - it is a completely new test engine. Furthermore, the architecture of JUnit 5 platform is such that it can easily run all your legacy JUnit 4 tests alongside of all your JUnit Jupiter and TestNG tests (given TestNG decides to provide TestEngine API of the JUnit Platform) and Cucumber tests. So I don’t think there any need for competition between these test engines. But to answer OP question - my preference goes clearly to JUnit 5 for new green field projects. 
How's the arthritis?
And.. what is the problem with this code and how explicit types would change it? Sure, the types are not obvious here, but I would say they are not really needed. The code is compact and pretty readable. The only thing that slightly bothers me is that either "src" and "dest" are of different types or "move" expects a different types as arguments. So, it looks a bit clumsy for me even without explicit types, but I have no the context of it, so can't say it for sure.
Never heard of a paramatised test what is it and why do i need them? 
Get the JRE and JDK from the Oracle website. Look up how to install them into eclipse if eclipse didn't come with it. Every version of java is very similar, the stuff you plan to do prob won't be affected by any changes in J9. So yes, java 7, or 8 book would work just fine even with java 9
I don't understand why somebody would write an article like this in 2017. It refers to technologies used 10 years ago. In the Java world JSP and JSTL have been mostly replaced with JSF. And even more recently the whole GUI has been replaced with the Javascript frameworks. So instead of suggesting to use JSTL, the least you could do is to suggest an upgrade to JSF. A better article would be "Refactoring JSP scriptlets using Java Server Faces"
1) Nope, you can pick up a Java 7 book and it wont matter much. All the core stuff are there, maybe a few new features missing, but you wont miss out too much. Everything that can be built with Java 9 can be built with Java 6. 2) If that's what the team uses and somebody has experience with it, stick with Eclipse for now. If nobody have any experience with it, suggest Intellij Idea to them. . 3) JRE is short for Java Runtime Environment, where Java runs. If you don't have that, it won't work. You might need JDK (Java Dev Kits), which also include JRE. And no, it won't break your computer. Oracle and openJDK are made by reputable software engineers who won't put those malware in JDK. On the side note: If you are doing robotic, why are you/your team decided to go with Java? Low level languages like C would be much better interacting with hardware.
I immediately started thinking of how we could use it during development and how our postman collections could be reduced or even replaced. Then I remembered the contractors who use eclipse, oh well. It's probably for the best to not be too invested in IntilliJ
Honestly, I have no Idea why we use Java because I have no knowledge of the pros and cons. I'm doing the programming team next year so I want to be prepared. Bring it up with FIRST Robotics, I guess. Thank you for all your help. What can I do to remove Java or JRE if I need to?
Thank you
They should use 18.04 and 18.10 as the next version! Also give it a name consisting of an adjective and animal which both start with the same number. For 18.04 they can use Bionic Beaver! /s
JSP + Spring &gt; JSF
Junior developer does the same work as regular developer, but gets paid less.
I would agree with you if the original article suggested Spring MVC instead of JSP. But given the fact that it just talks about plain vanilla JSTL, I don't see how your comment applied here.
I think this is what a lot of the APIs in Junit 5 are based on ?
&gt; 1) Nope, you can pick up a Java 7 book and it wont matter much. All the core stuff are there, maybe a few new features missing, but you wont miss out too much. Everything that can be built with Java 9 can be built with Java 6. Streams and lambdas change things quite a bit, although you are of course free to use the old clunky ways, of course. :) But starting with Java 8 should be just fine, since the modules in Java 9 aren't necessarily even that useful for small projects, never mind necessary.
That stream debugger (visualizer really) is sexy!
I agree with you. I will try in resource layer to use @Valid @ModelAttribute to get the object and check which exception I get when binding fails, etc in order to send back a good error message with the REST API. I will come back here to post solutions I found and I will try to see if I can add something to my API to handle some parts of @Valid @ModelAttribute consistently through the app. Thank you.
Settings synchronization has me excited. Such a relatively "small" thing but it'll really make life easier. 
Do you know any other programming languages? The best way to learn differers if you it is your first experience programming, or if you already have programming knowledge but with a different language. Java 8 textbook would be fine. Check out the sidebar of /r/learnjava for more resources. http://mooc.fi/english.html is especially recommended for learning Java. JRE is the "Java Runtime Environment" ie. it is the software that java runs on. JRE will not be enough for you though. You need the JDK (Java Development Kit). The JRE lets you run programs but not create them, JDK is for creating Java programs (it includes the JRE so you don't need to install both). The JDK can be downloaded from the [official site](http://www.oracle.com/technetwork/java/javase/downloads/index.html). Just download and run the installer. 
Even though we're a Java shop, we've turned to groovy and Spock for all of our testing. It's worked well for us.
java
I just learned today that intellij invented Kotlin. Mind blown. 
JetBrains technically, haha
java
28 y/o so no arthritis yet
Java runs on pretty much every device, if it was actually that bad it would've flopped. Is it as efficient as other languages? No but it is also a higher level language. 
&gt;&gt;JUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage &gt;... what is this stuff? Agreed... What an annoying thing. I bet imports are fun in Junit5.
I've just started using Java a couple weeks ago. I've noticed there's definitely more than one way to accomplish things, but not all are right. Which makes me presume that perhaps this is due to the language being old, and some people complaining don't know how to utilize the language in its modern capabilities properly. At the same time, if you have to even say that, maybe that's the problem it itself. But again, what drawback do you have from moving on and just using it correctly? I think it's easy to hate on Java's syntax given its verbosity, but frankly, I think that complaint only comes from people who haven't passed the "Hello, World!" beginner phase ... or insist on using Eclipse instead of something like IntelliJ. Major companies are behind it, a plethora of open source everything exists to make Java the all-in-one suite -- that's mature -- and can handle massive projects, continuous integration, testing, etc. I primarily use Golang and Python, as each to their own, for my project development. But Java seems like a solid language when working on a team project, and one I plan to use for just those things. Plus, once you go past Java 8, I feel like 90% of the things people complain about is no more.
Well Java has some nuances, but it's also been heavily updated since it's conception. Things like simply making a call synchronized make multi-threading a breeze. In C you have to fiddle around with semaphores. Java has a solution for just about everything. That is part of the reason it is so appealing for me, I don't have to worry about parsing character arrays for integers that won't fit all I have to do is create a Big integer. The down side is these methods and classes may not be optimized for a particular application. This is because they are cookie cutter, yet people would rather complain how unoptimized Java is rather then develop thier own class. Personally I like Java, I like making classes portable and modular because I hate coding crap over and over again or splicing old code into new code and spend time debugging. Python is nice, there are several things I like about it such as not having to declare variable types and error handling. Each type of code has it's place. Personally I like to use python whenever I am on a Linux box, it makes scripting super easy, same with C. C is amazing if you are trying to develop something light weight. As far as large application development I like how everything in Java is available. There are tons of tutorials if you get lost and a million different ways to tackle an issue. I'll tell you one language I detest, Swift... I don't like Swift because everything is under the hood. It's difficult to keep track of what exactly is going on behind the scenes. I've never coded in golang.
I still love programming in Java
Programming in Java is like microwaving food; it's easy, convenient, and quick. It may not be gourmet but you save a hell of a lot of time.
I love Postman, but I think they may take back all the free goodies because it’s REALLY good. If the IntelliJ rest client is decent it would be an awesome news.
What about eclipse would give him arthritis? Or is it cause of old age 
Totally agree. Time to spin up IntelliJ again. 
Yeah, it is. Don't listen to people saying "it runs on every device" rofl. Embedded systems and enterprise software are like apples and oranges. Java was left in the dust in 2013 and has been on the decline ever since
The Java language isn't bad. It's okay. The Java platform and ecosystem is great though.
Left in the dust? Is that why we saw JDK 9 release this year?
I've seen your posts around here. Why are you so angry at Java? Did you fail a Java unit or something?
Yeah the ecosystem is really empowering. It's not like JS with many options all rapidly changing. Often you can choose between just a few very solid alternatives.
I cannot use neither jUnit nor TestNG since I discovered [Spock](http://spockframework.org/spock/docs/1.0/data_driven_testing.html). class Math extends Specification { def "maximum of two numbers"(int a, int b, int c) { expect: Math.max(a, b) == c where: a | b | c 1 | 3 | 3 7 | 4 | 4 0 | 0 | 0 } } Have a look, it's unbelievably amazing. 
https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition
???
Also community support, tools an libraries. So many of them feel like they are polished and mature.
I don't know about others, but I love The Java Programming Language and Platform. They are both being evolved at an outstanding pace, and I am excited for the future. Features like value types and specialized generics will be instrumental to its continued success.
Man, this is a satire. You can definitely find places where code like that is still written but the language is not at fault here, people are. With modern features and frameworks even EE development can be pleasent.
There are a lot of people who hate on Java because it isn't the new hot and they see old/venerable languages as being out of touch with modern developers. My counter to this comment is that you are probably not reading enough about the latest library/tool/framework developments for the Java platform. Modern toolkits like [Vert.x](http://vertx.io) show that development in Java can be even MORE modern than other languages and still benefit from the 20+ years of hardening/improvements/updates which make Java suitable for enterprise development.
Do you have the statistics to prove that? Recently, I've seen an increasing job market for Java, even on new projects. I doubt what you're saying is as accurate as you want me to think.
I wouldn't say outstanding, but it has definitely evolved. And the verbosity is improving too. Now if only we could get properties.
To ELI5, the JRE includes everything to run your code. The JDK includes everything to build and run your code.
They are looking into adding data classes. They tried adding properties once, and apparently no one could agree on what the definition of "properties" was.
Yes, and from the very start the intention of Kotlin was to be a widely usable non-elitist non-discriminating programming language making life easier. There's a (badly transcribed) interview with the lead dev here: https://www.mappingthejourney.com/single-post/2017/10/26/episode-12-interview-with-andrey-breslav-lead-language-designer-of-kotlin/
What is your point? That's satire.
It's a [web developer](https://www.reddit.com/r/Frontend/comments/3a28y5/advanced_css_tools_help_me_understand/). Evidently having to program JS has turned it into a miserable troll.
I'm not convinced that the suggested way for type inference is an improvement to the language. From a "philosophical" perspective, it optimizes writing code (less typing) over readability. Historically, Java always favored readability over writability which makes perfect sense as code is much more often read than written. More technically, we now will have forms of type inference on the left sight (new proposal) and the right side of an expression (diamond operator). What if someone tries var list = new ArrayList&lt;&gt;()? The proposal mentions this as a risk, but I feel it's pushed aside too easily. IMHO, the preferable way would be to enhance type inference on the RHS, e.g. by allowing something this: ArrayList&lt;String&gt; list = new &lt;&gt;; ArrayList&lt;String&gt; list = new &lt;&gt;( 3 ); NonGeneric foo = new; NonGeneric foo = new ( "bar" ); It's not as powerful as the proposed inference on the LHS, but it expends an existing concept and still would improve usability in many cases.
Java and ecosystem is just fine. Whiny node.js/rust hipsters are a vocal scrounge with loudest voices on the playground. Move on.
Me too!
Nothing by itself is "wow", but each of them is "that's kinda cool. I can see myself using that". Together they just make life so much easier. I really miss having these intentions in PHPStorm. Like in IntelliJ, inverting an if at the end of a block will automatically use an `if() { return/continue;}` and unwrap the else branch. PHPStorm gives me an empty if block. It'll get it eventually, I'm sure. It's not a big thing but it shows the small impact Jetbrains tools have.
What you wrote is so non-sensical, it sounds like you have never actually used this stuff.
Same test, different data. Basically a way to run the same code using different inputs without having to write a separate unit test for each one. You write one test and then declare the inputs and expected output.
I have zero problems using Eclipse with "modern" Java.
What do you need properties for?
Rust, at least, seems to have some merits. That's more than I can say for JavaScript.
Web development is miserable work, so I guess that's understandable.
Idiotic, crayon-chewing web “developers” seem to love to crap on Java. You'll learn to ignore them.
The thing about Java is that very little is ever removed from the language. For example: * [`Vector`](https://docs.oracle.com/javase/9/docs/api/java/util/Vector.html) is a class that acts as a resizable array. It was introduced with the first version of Java. * `Vector` was obsoleted by [`ArrayList`](https://docs.oracle.com/javase/9/docs/api/java/util/ArrayList.html) in Java 1.2. * ...which in turn was changed to `ArrayList&lt;T&gt;` in Java 5.
Go kill yourself.
To reduce boilerplate code. It would mean replacing class Point { private int x; private int y; public int getX() { return x; } public void setX(int x) { this.x = x; } public int getY() { return y; } public void setY(int y) { this.y = y; } } with class Point { property int x; property int y; } And if you wanted to override the getter or setter for a particular property you can do so. This is not an exact example, as there's various issues not addressed here, like constructors and read only properties etc, `equals`, `hashCode` and `toString`.
The JVM as platform is pretty awesome. I'd prefer Scala over Java since it's functional programming at heart. I would even say that it's the most advanced general purpose language. The main flaw of Scala is that it wants to do everything, so it's a bit bloated.
If you're using Windows check language and locale settings are correct
Ok, when we leave Java as the testing language, there are more nice options like [KotlinTest](https://github.com/kotlintest/kotlintest/).
It is like that old quote "There two kinds of languages, those that people complain about and those that nobody uses". Additionally, there are many different opinions on programming languages, and is it is, we like to voice them. For myself, I like Java *because* it is always explicit and verbose. It is like building with basic bricks, if you know the few bricks, you can understand everything. I can completely understand that people like to type little, that is one of the reasons why they like syntactic sugar. C# is the best example for a language that constantly adds syntactic sugar on top of it, making it more and more complex...but easier to type. On the other hand, this syntactic sugar can make it harder to read, for example: // C# var value = getValue(); // Java CustomObject value = getValue(); Or the other day somebody was excited about operator overloading because they could define `+` as extension to add items to a list...with example code looking like this: var strings = new List&lt;String&gt;(); var something = strings + "Some value"; Yes, it is easier to type, but it makes it quite hard to read. Java was always very conservative about what syntactic sugar and language features it added, so many people see it as "slow" and "old". For the past few years I've seen a trend coming up that "old things" must go away, people are very vocal about how "old things" should be burned on the stack at all costs for the greater good (Java, C, X11, every browser except Chrome, ...). Not sure what to make of that, though. Last but not least, the JVM and the whole Java ecosystem is *unmatched*, as far as I am aware. If you don't like writing Java, pick one of the countless languages on the JVM that suite you. 
What about this: public class Point { public final int x; public final int y; public Pount(int x, int y) { this.x = x; this.y = y; } } ?
I think about this, not because I don't like TestNG anymore or because I just want to use the hottest stuff. But because JUnit was a bit better supported by other frameworks and tools in the past.
A good way to form an opinion about Java is to spend a fortnight with Kotlin, then go back to Java and see what irritates you (it mostly comes down to "no data classes" in my case).
Local variable type inference is coming in 18.3!
I knew you'd show up, lmao. Love your posts, laugh every time.
Java as a technology is very good. Companies not updating their application servers from Java 5 or 6 are bad. Also, companies creating custom frameworks replicating MVC or dependency injection are evil. There are also Java developers who didn't update their knowledge for at least 10 years. They force their colleagues not to use try with resources or the diamond operator. So the problem is not Java, but the way Java is used and seen by companies and developers.
I've recently learned Rust, and it is amazing. In Java I often felt limited by the language, while writing in Rust on the other hand, I'm more often surprised by the things you can do with it. Also, even tho I still have less experience in Rust than I have in other languages, I find code written in it much easier to understand, even when compared to python. Overall, I believe the only real advantage Java has over Rust is the amount of people that know the language, which makes it easier to work with others.
. . . Vector is fully synchronized, it's the thread safe version of ArrayList now. It's 100% still has a use.
Yeah i see i see. Yeah i suppose that is useful.
I can't wait to use it. Would be great if it allow to just write a curl line in it and using it other features (like context).
Yes, if you only apply it to that particular limited example, you can make properties seem unneeded.
Even more advanced than Haskell, Eta language or Idris?
I mean you could put all your test code in a function and create a `@Test` function for each input that just calls your function, but that's a little verbose. 
/r/learnjava 
search lombok, it does just that
Being able to “do more” may be nice, but can also lead to a lot of bad choices. Sometimes, languages like Java are written in a way that make it harder to make mistakes, and easier to build robustly, at the cost of freedom
They are correct, unfortunately.
With sealed data classes they are thinking about for pattern matching, Properties or getters / setters will be a little less common. But still would be great to have them. Though a lot of frameworks would need to rethink (e.g. JAX-B).
Do some searching in this subreddit. Notice how often questions like this are posted and observe the denial circle jerk in the comments. I've never seen a subreddit try to gaslight itself so hard. It's borderline comical 
I don't understand why they are allowing it also on method returns. Even C# has it in the guideline *not* to use it on method returns. Other than that local variable type inference seems ok as a feature.
It's also easy to understand. It lacks some of the advanced features of other languages which, while great, make code harder to reason about.
Who is allowing it on method returns? You won’t be able to in Java.
maybe he refers to [Tiobe Index](https://www.tiobe.com/tiobe-index/). Though the deline there was interrupted with a high-peak around 2016 and after that all of the top 10 languages declined or stagnated due to general interest in polyglot development.
Java is kinda ok for doing everything. But when you look at other languages, you learn their strong points and weak points. Today java is the defacto language used everywhere but it is not the most effecient for performing some tasks (for example, clojure can do better in some cases). So I think people dislike java because it is too much used. That's the golden hammer anti-pattern (https://en.wikipedia.org/wiki/Law_of_the_instrument)
**Law of the instrument** The concept known as the law of the instrument, otherwise known as the law of the hammer, Maslow's hammer (or gavel), or the golden hammer, is a cognitive bias that involves an over-reliance on a familiar tool. As Abraham Maslow said in 1966, "I suppose it is tempting, if the only tool you have is a hammer, to treat everything as if it were a nail." The concept is attributed both to Maslow and to Abraham Kaplan, although the hammer and nail line may not be original to either of them. It has in fact been attributed "to everyone from Buddha to Bernard Baruch". Mark Twain has sometimes been credited with it, though it cannot be found in Twain's published writings. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
`Vector` is conditionally thread safe. You still need to lock on it to iterate. You can get this same conditional thread safety using `Collections.synchronizedList`wrapper on another `List` implementation like `ArrayList`, making `Vector` obsolete. For full thread safety, you can use a concurrent collection like `CopyOnWriteArrayList`. There's no excuse for using `Vector` in 2017.
I mean `var x = getX();`
Where else do you think you can use it? It’s only for local variables. `x` still has a strong, static type.
Remove classes? Why would you want classes to be removed? If you don't want to use a class, don't use it. It doesn't impact the developer to have classes there that you don't use. The JRE is not bloated. The bytecode execution has gotten faster over the years, not slower. Removing classes would also make legacy code unusable and therefore break the notion of backward-compatibility, which Java tries very hard to do....unlike some other languages *cough* Python *cough* Plus, ArrayList was not 'changed' to ArrayList&lt;T&gt;, generics were simply added to the class. They are not separate classes. You can use ArrayList with or without generics - again, allowing backward compatibility. 
You use a lot of buzzwords for a very small argument if you even have one. Java operates on what matters and there really isn't much to deny, either. Read through this thread, there are some solid arguments. If you can bullet point each of them, and provide a solute refute, then I'll be inclined to view you as anything other than a willfully ignorant shithead.
Java is fine, but there are much better languages on the JVM (e.g. Scala and Clojure). IMO comparing Java to Scala would be like comparing svn to git. Svn is far from being "bad", but git is just so much better and the next step in VCS evolution. Also note that Git and Scala have a steeper learning curve than Svn and Java, but provide much more once you master them.
I'm ok with `var x = new X();`or `var s = String.valueOf(2);` but not on `var x = getX();` because you loose **visual** information about what type the variable is. Type is a very important part about the variables definition, which is not potentially missleading or deceiving.
I wouldn’t blame type inference for that. I would blame the person who named that method.
But methodnames shouldn't contain the type information either, neither should the variable. `var personList = getPersonList();` would be very bad. Also it is still missleading and hard to consistently refactor. Changing the method / type or variable name would require you to refactor *all* the places there are similar variables instantiated.
Being an explicit language makes making mistakes harder, having less power doesn't really come into it; And Rust is actually more explicit than Java(for example, floating point number literals must always have at least one decimal, and integers can never have a decimal, so you always know what it is from the literal), types are also never casted automatically, and you have no null values or exceptions, if you want to return a failure state, you can use one of the language's built-in enums (like Option, that can be Some(Value) or None) or your own. All of this and you still do things with about the same amount of code. Note: You *can* make things risky in Rust if you use unsafe code (denoted with `usafe { code here }`), but without making use of that you can already do everything that you can do in Java in Rust(or more, if you take optimizing and comprehensibility into account).
According to the docs, experimental​ means &gt; Intended for new, experimental features where we are looking for feedback. Use this element with caution; it might be promoted to MAINTAINED orSTABLE in the future, but might also be removed without prior notice, even in a patch So your tests may stop working at any given time, with a minimal version upgrade. That said, I'm pretty confident parameterized test are going to stay, and you are betting at the right horse. I just don't want to bet. I like having the cvssorce option, I've coded my own version for TestNG. In most cases however I rather have my parameters in the same file as the test itself, TestNG version seems to be a little better, but maybe junit version is more type safe. Also junit seems to be moving into property testing, and TestNG seems to be not so active, so I think junit will eventually be my choice too. Note that TestNG accepts both an Object [][] or an Iterator&lt;Object[]&gt; , junit uses a Stream&lt;Argument&lt;&gt;&gt;... They both need a Tuple, but we don't have that in the language
If you already know the answer, did you post this for attention? Sounds like a junior java engineer insecure about working with a dated, low-paying technology to me
I know about Lombok. I want it in the core language without using effectively a precompiler.
Yeah I'm not a fan of "var" keyword. In addition to what you said if you go to class and "Find Usages" - the "vars" are not found. You have to find the calls to those methods and backtrack to find the actual use. Painful. 
You're avoiding the topic at hand here. Stop it.
You're asking in the wrong sub. Obviously people subscribed to /r/java like Java. Why else would they be here? My personal opinion is: Java is still a good language. It has lots of pros and several cons which all have been discussed at length all over the internet. Having said that, I also think there are several JVM languages that share a lot of Java's pros but add many useful features while removing a lot of the cons. It has been a long while since I have actually written Java code but I still use its ecosystem since many JVM languages allow you to use native Java libraries.
Sorry but this absurd amount of boilerplate is expected in java projects 
Well, It might have the annotation stating that it is "EXPERIMENTAL", but it is fully featured in the JUnit 5 official documentation and that is good enough for me. YMMV of course... The `CsvSource` option does not require external resource with test data. It is just an annotation that allows you to provide data as a CSV formatted strings in the annotation like this: ```java @ParameterizedTest @CsvSource({ "1, false, 0, 0", "1, false, 2000, 0", "1, false, 2000, 1999", "1, false, 2000, 2000", "1, true, 2000, 2000", "1, true, 2000, 2001", "3, true, 2000, 2000", }) void testParametrisedValues(int firstInt, boolean boolean, int secondInt, int lastInt) { ... } ``` 
Considering how large the changes are all the tools will have to add JUnit 5 support, while any existing TestNG support is already there. So, tools support might surprise you. I know that NetBeans does not have JUnit 5 support and the authors came and opened an issue about this https://issues.apache.org/jira/browse/NETBEANS-6
Some idiots like to shit on Java because it is too verbose (they don't know getters and setters can be generated) or too strict (OMG I want my BS code to compile even if it fails at runtime). Some hipsters may like Kotlin and other sub languages because it's so cool I can program my hello world more easily. Some webdesigners think Javascript is the best because they can write shitty code and it will work still, ignoring the fact that this language lacks basic properties like transitivity in some of its operations. They are stupid enough to use JS in backends, and think reactive programming is the way to go to implement a software that handles less than 1 request / second. Meanwhile, Java has a very solid ecosystem, with EE4J, Spring, Apache etc... and a shit tons of libraries that work. It can run on many different hardwares, it is secure, robust and retro compatible. It is not slower than other languages (or slightly so it is not noticeable) because JIT and also because performance have more to do with design and complexity than with technology. So yeah, Java is the best :)
This is gonna blow your mind : &gt; public class MindBlown &gt; public int x; &gt; public int y;
declare your variables public 
what is the difference between this and the "property" keyword ?
&gt; IMO comparing Java to Scala would be like comparing svn to git. Svn is far from being "bad", but git is just so much better and the next step in VCS evolution. GIt and svn serve the same purpose. You cannot say that a functional language is better than an imperative language, they are jsut different, and one or the other will be best suited depending on what you need to achieve.
And there is also [MVC](https://www.mvc-spec.org) for JavaEE, much better than this servlet-based.
The language is good, the platform is great. What people typically mean when they hate Java they are referring to the old outdated java systems that companies are still relying on and refuse to update and have to maintain something quite ancient.
&gt; It's a web developer Hey man #NotAllOfUs
**Sidebar** -&gt; **NO programming help, NO learning Java related questions!** Such questions should go in /r/learnjava and there you will find excellent, free resources in the **sidebar**, section **Free Tutorials** Do the **MOOC [Object Oriented Programming with Java](http://mooc.fi/english.html)** from the University of Helsinki and you will have the best possible start.
A C# property implicitly creates accessors that have default functionality, which is literally return the value (getter) and set the value to the provided parameter (setter). If you want to override any accessor and change the behaviour you do so at the property's declaration, but *references to the property itself don't change*. The benefit is cleaner, concise code in the most common scenario, and additional code only where it's needed in other scenarios.
No.
Still no.
Sure, but some people think that because all methods are synchronized, that it's fully thread safe. 
So can you state what is the difference between this example and the one with the "property" keyword?
&gt; If you want to override any accessor and change the behaviour you do so at the property's declaration Thanks, can you provide a simple example ?
Though maybe spreading @Deprecated annotations with more fervor would be nice.
Not that bad, but for most projects I prefer to use something higher level like python or clojure (or even javascript) even if the performance is much worse (usually not a problem). Clojure also provides access to Java libraries (and I believe there still are ways to code python on a JVM even if I have not done that for over 10 years?). And if I want something lower level there is C++. C++11 and C++14 (and C++17 probably) is a huge improvement over earlier versions. C++ used to be really complex and difficult to use compared to Java (compare Java 1.1 to C++98...) but I do not feel like the difference is worth arguing about really anymore. The code is on a similar level, but with C++ I get very close to the hardware, and even if Java performs quite well I see no reason to compromise, even if I guess you could argue that in general a small decrease in performance can be worth to pay for a small gain in simpler code.
No no no. Do you even understand what getters and setters are for?
[You've already had it explained to you](https://www.reddit.com/r/java/comments/790t9q/late2017_discussion_is_java_really_that_bad_or/doynwdr/)
I did link to an example in my original comment. https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/properties
&gt; Plus, ArrayList was not 'changed' to ArrayList&lt;T&gt;, generics were simply added to the class. They are not separate classes. You can use ArrayList with or without generics - again, allowing backward compatibility. Yes, generics being added to the class was the change I was talking about. There's a reason that the compiler spits warnings out at you if you try to use ArrayList without using generics... because you're not supposed to use them that way any more.
&gt; Do some searching in this subreddit. Notice how often questions like this are posted and observe the denial circle jerk in the comments. I've never seen a subreddit try to gaslight itself so hard. It's borderline comical It's impressive actually
It might be true for some places, but you can't use obvious satire to validate your point.
Every language has his usages.
I agree, it is less verbose in C#
&gt; Properties allow you to create 'fake fields' (interfaces!), perform validation, lazy computation, etc. in this case, you should write the method anyway, so it does not have the conscise advantage
You are comparing two different things though. Either you want direct access to the value : making the field public serves the same purpose, with less boilerplate code. Or you want to perform logic, you are going to write a method anyway, you will only save yourself writing the signature of the method.
Why would you use var in place of an actual type, besides laziness ?
No, I'm not. Properties provide default implementation for getters and setters that you can override if you need to change the implementation. The underlying values are still encapsulated. 
Have you checked the encoding you've set for the app?
My point is that a property that is syntaxically encapsulated but with no further logic applied to the getter and setter is equivalent to making the field public.
Sorry, I have no idea what that means. As I stated: I'm not the creator of this program, I'm not a programmer. I just use it, but suddenly it started doing this. It's definitely something on my end, I just have no idea what it is.
To make your program more readable. The most important thing is what your code does, not what classes is your program using.
I would argue that var makes the code less readable. If I write var x I don't know what x is. I need to navigate in the code to know what it is. If I give it a type, I already know.
But your member variable is now exposed and you can't change the access/implementation without breaking all of its users. 
In many languages, you can solve this problem like this: var x : int It is optional and can be used where the type of the variable is not evident.
Haha, that's a good description. It's JavaScript for everything! Ew.
Are those general purpose languages? Haskell maybe to some extent, the others though...
This is true, but in 99% of the cases, you just access the variable.
Eta is Haskell for the JVM. It is a very young language. From Idris home page: &gt; Idris is a general purpose pure functional programming language with dependent types.
Sure, let me wrestle with Reddit's formatting for a moment! The smallest example of a field in Java is: public Object thing; Used like this: whatever.thing = new Object(); Object athing = whatever.thing; Very concise, but what if you want to add encapsulated behaviour to field? You can't, not without making the field private and adding accessors, like this: private Object thing; public Object getThing() { return thing; } public void setThing(Object newThing) { thing = newThing; } The problem here is that you now need to *refactor all usages to use the accessors*: whatever.setThing(new Object()); Object athing = whatever.getThing(); It's a bit messy and has a knock-on effects wherever the field is referenced. In C# the language allows you to add this encapsulated behaviour without the refactoring. The field is defined like this: public Object Thing; ...and used like this: whatever.Thing = new Object(); Object thing = whatever.Thing; If you want to add accessors in order to add encapsulated behaviour, it's done like this (as one example): private Object _thing; public Object Thing { get { return _thing; } set { _thing = value;//see ^note1 } } However the *usage doesn't change*, so it remains: whatever.Thing = new Object(); Object thing = whatever.Thing; Zero knock-on effects! Yay! Obviously I'm ignoring semantic changes, but you hit that problem in any language so it's not part of this problem. ^note1: **value** is a *contextual keyword* in a property setter that refers to the new value being provided.
Not sure why you think Python is *higher level*.
Synchronizing is so easy too. If they want to complain tell them to port the threads into C. 
Pretty sure that's about maximizing backwards compatibility. After all Java was really big on the 'write once, run anywhere' mantra. That would seriously break down if care wasn't exercised in what got removed and when. That's not to say that those things should never be removed, but being able to migrate stuff modular or piecemeal probably has benefits,
If you want the syntax sugar, but still the Java interop, check out Kotlin
Thank you for taking the time to explain and format it. I completely agree with the fact that it changes the interface, on the other hand, in 99% of the cases, it is just a direct access to the property. But overall, I agree, it's better in C#. C# is not a bad language anyway, only slight difference with Java ^^
I have to say the yellow crayons taste like apples... Or was it banana... Hell idk I'm just a Java developer.
I sort of agree. The only meaningful point to having methods there is to either selectively hide fields or have some control over validating the input, at least if you believe that set/get functions shouldn't have *any* side effects.
Ugh, no thanks. If I want this, I will switch to Kotlin and use a data class
I just started reading this sub over the last 2 weeks as I started to pick up Android. I've last done Java during university and was then employed doing PHP, and currently C++14 with a bit of Python sometimes. Compared to the current standard of c++, Java (at least on Android, which I know is a bit out of date) seems basically like "mostly like how I'd write C++, but less flexible". The everything-as-an-object idea of Java causes some annoyance in cases where just using a free function makes a lot of sense, but you aren't able to. Attaching event listeners to UI elements in Android is like this. You'd really like to just pass a function, but instead need to pass an entire anonymous class that @Override's the proper method. I miss auto, and type-deducing lambdas (which exist, but I can't use them in the Android API level I'm targeting currently so that feature may as well not exist for me). ArrayList feels like a worse std::vector because ArrayList has the limitation where you can't use it to hold primitive types, so you need to instead use the object form of Boolean, Int, or whatever. These seem to only exist because of the weird limitation that primitives don't work like everything else does. Distribution of a desktop app (not terribly relevant these days as most things are now web apps, but I build apps for myself as well so this matters to me) is annoying because you need to ensure the user has Java installed as well. Compare to a C++ app, where I can compile for the proper architecture and distribute it in binary form for ease of use without any external dependencies if I want. Java is an OK language, but I probably wouldn't be using it if it weren't for Android.
This is so very very true.
Why go back? The interop between the two languages is awesome. Use Kotlin for your data classes, and Java for the rest of your app.
If you end up overriding the default for validation, logic, or other functionality then the property usage becomes effectively *syntactic sugar*. You could get the same effect on time/effort typing with autocomplete.
Ughhhhh.... You mean like SWIFT
This is a complaint I see occasionally in the C++ community about the auto keyword, which works similarly. I work on projects where we use the automatic type deduction of everything as much as possible, and find that this isn't an issue for figuring out the code. You just read the type information from the right instead of the left in most cases, and it saves you from writing the same thing out twice. So the usual usage is more like ArrayList&lt;String&gt; bucketOStrings = new ArrayList&lt;String&gt;(); becomes var bucketOStrings = new ArrayList&lt;String&gt;(); You still get all the same information, it just isn't cluttering up the lines so much. Which is also helpful in my experience when you have the occasional complicated for loop condition. It helps you focus on what the conditions are rather than seeing a bunch of type data cluttered that you don't really need.
&gt; low-paying ** *Looks at bank balance* ** HAHAHAHAHAHAHAHAHAHAHAHAHAHA ** *Looks at bank balance again* ** #HAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHA
That's like saying lambdas are just syntactic sugar over anonymous inner classes.
In at least some cases they are as far as I can tell, 
There is always that type of person, the guy/gal who will deny everything even if getting past thier unfounded bias will make thier life better. You really limit your potential by saying burn Java to the ground. Instead of throwing shade make a wrapper class, sell it, and make some money. *Shrug*
I thought Java and Scala also serve the same purpose... And Scala can be as imperative/functional as you want it to, just like Java. It's all about how much boilerplate you need to do so.
I guess it is not an issue when you instantiate a new object, as you said, it is redundant to write the type twice. But what about var x = methodCall()
Usually I just jump to definition and look. I tend to develop with at least 2 split panes, and I like to reserve the left one for a view of whatever file I need to reference at the time. So in my actual coding view I'm not jumping in and out of different contexts all the time.
&gt; Distribution of a desktop app (not terribly relevant these days as most things are now web apps, but I build apps for myself as well so this matters to me) is annoying because you need to ensure the user has Java installed as well. As of Java 8 the JDK includes a tool called "javapackager" that produces native executables for windows, macos, and linux. It includes the runtime: https://docs.oracle.com/javase/9/tools/javapackager.htm#JSWOR719 If you use Java 9 and write modularized code javapackager also uses "jlink" to only include the parts of the runtime you need. 
This is pretty neat, thanks for mentioning it.
Aside from RAM usage, it's actually pretty goddamned efficient compared to anything that isn't C or assembly. In most of the benchmarks that I've seen, it lags just a touch behind C++ in terms of sheer speed. Granted, frameworks and servlet container environments can make a huge difference there, but people love to forget that the JVM is freaking fast. If you don't have serious RAM constraints, server-side Java is tough to beat from a performance and productivity perspective. The same goes for Kotlin and Scala about 99.9% of the time. As for the scripting languages, NodeJS isn't even as fast as its evangelists claim, though it is surprisingly quick for an interpreted language. PHP 7 seems to be catching up in that space, and Ruby on Rails is like watching a snail race on every HTTP request. (Disclaimer: it is entirely possible that I just haven't run across a Rails site that was actually freaking optimized by someone with more than two functioning brain cells.)
Get an original copy of the files before this started happening. Try opening those. Or try opening such a copy in a different text editor. The file you are looking at now could have been modified by an editor the first time you opened it. I had a problem like this a couple years back. I initially developed on Windows in Eclipse. Had a Unicode degree symbol in strings throughout the code. (like compass heading 120 degrees) Opening this code in Eclipse on Linux gave me strange symbols wherever the degree symbols were. I don't quite remember how I fixed. IIRC, I searched for what the new symbol was, and replaced with a degree symbol. Once it was fixed on Linux in Eclipse, it stayed fixed.
Why would I not think so? It is a scripting language with very concise syntax, much like ruby or perl or php or pike or bash or Lua. Just way more convenient to work in without having to get bogged down in (relatively) low-level details like types. There are probably no strict boundaries between programming and scripting languages, or between higher-level and lower-level, but I never heard anyone question that python would not be higher level before. I started using python because it was used for writing scripts for an application otherwise written in java (and that was the beginning of my transition away from being a 100% Java developer), and have since also used it in a larger project that was java but we needed/wanted a higher level scripting language to be able to write plugins in a simpler and faster way (even if performance hurt). I think it makes a lot of sense to do that. I imagine the the opposite decision must be very rare, having a python application and adding the ability to "script it" using java?
Lol you said evangelists. :D :D :D
tldr but I will :), well worth some half an hour or so. Nice graphics btw, did you hand draw ? Used Watercolor? 
Personally I think C# is the better language, but modern development isn't just about the language in isolation. The tools, ecosystem, community, and principles behind it all are just as important. In this respect Java is still ahead.
It's also worth pointing out that Java also gets a bad rap on account of Oracle's dubious decisions since they bought out Sun. Most of these kids just know Java as "oh my god it's that thing I had to download on my mom's computer that one time and it installed a bunch of toolbars," or because their middle school's grading portal used an applet. These things tend to stick in people's minds for a long time. I think that this "psychological" factor plays pretty heavily into why Java 8+Lombok is the Great Satan, but Kotlin is A-OK when you're talking to younger devs. Then there's my boss, who thinks that when one of the two developers in the entire fricking company is constantly swamped with frivolous feature and change requests and is unable to keep up with the constant flow of incoming work -- most of which involves working around someone else's "I did this at 3 AM while dry-drunk" database structure (actual quote: "inner joins are bad for performance!") -- then *clearly* it's Java's fault, because Java is *slow*. Not because the VB6 legacy code being translated is shit, mind you, but because of Java. So I get to gently explain to him about once every six weeks that, no, using classes is not "tanking performance" in the fucking program. The end user isn't going to notice if it takes the server an extra CPU cycle or two for a symbol table lookup to be translated from the bytecode to the JVM, because we aren't running on a fucking Commodore PET. And most of that boilerplate is being IDE- or compile-time generated, so it's not a problem with the language. It's a problem with lax requirements specifications and stakeholders who feel the need to barge in every 15 minutes and demand more shit. So, to answer OP's question, there is a lot of ignorance and outright hostility out there. There are also IT managers who haven't updated their knowledge since 1988, and will balk at anything that doesn't have the word "Microsoft" in front of it. The same managers may also tell you that documentation isn't "real work," and gathering requirements is just a waste of time because of some kind of defeatist attitude toward project change management. Please kill me.
That bad? No. It's good. It has just some imperfections. For me it's mainly that classical java apps are memory hogs (and that starts with hello world..). If it runs like an average golang app (ecommerce eating just 10megs) that would be a dream come true. (in fact i need 8GB of ram in notebook only because of java)
I used to be really anti-Java. It seemed so big and heavy compared to C/C++ (that I use at the embedded end) and so unfriendly compared to python (that I use at the web end). I was wrong. While I don't think Java-on-a-Cortex-M0 would ever be sensible; at the web end it's fantastic to have a properly typed and strict language, along with just as many "batteries-included" libraries as Python. The problem with your Python/JS is that they're great for a project that fits in a couple of modules. Once you get above that they just run away from you. If you're in a team of developers, you get no enforcement-by-compiler that is so pleasant in strongly typed languages. So I'm a changed developer. You'll never get me to give up C/C++ at the low end; but if I'm on a PC and doing any project of substance -- Java is what I'll reach for.
&gt; Some hipsters may like Kotlin and other sub languages because it's so cool I can program my hello world more easily. And some of us crusty old farts in the enterprise space love Kotlin because it makes Spring halfway bearable.
I think you're mistaking interpreted vs. compiled for a low/high level relationship. Java is also a high level language. I wouldn't use Java for scripting in general, although it's not terrible. That depends on whether 'scripting' for you means being able to add in functionality at runtime without recompiling or simply automating a task.
You're not wrong
Scala is amazing. My only beef with it is that there isn't a true Hibernate/JPA interop layer for collection types, which bit me in the ass while trying to migrate a JEE7 JAX-RS CRUD service over to Scala as an experiment. Great language for writing DSLs and doing domain-driven design, though. Hopefully Java will keep bastardizing Scala features (e.g., lambdas) in the future. I wouldn't mind trait support.
Check out lombok https://projectlombok.org/features/all The @Data @Setter and @Getter annotations solve that in a nice flexible way. 
Thank a lot! :) Yeah, I drew them with watercolor!
But you will for the other 90% of plain get/set. Changing a public field to a method is a bytecode change.
What do you think about swift instead of C++? I don't follow C++ development, but is there any benefit nowadays?
&gt; ArrayList feels like a worse std::vector because ArrayList has the limitation where you can't use it to hold primitive types, so you need to instead use the object form of Boolean, Int, or whatever. These seem to only exist because of the weird limitation that primitives don't work like everything else does. Yep, this is called "boxing." Primitives also aren't nullable. Nine out of ten times, though, you should be using the "boxed" type names to declare your instance variables (e.g., Boolean), as you also can't use primitives for things like entity class fields that are supposed to be managed by an ORM (Hibernate/EclipseLink/etc.). As far as installation... Unless you statically link everything in your C++ program (which makes for a HUGE executable), you have to worry about whether the user has all of the necessary link libraries installed. Do they have the right version of QT? Do they have the exact version of DirectX that you used? Do they have the correct version of the Visual C++ distributable installed yet? ...so you end up having to write an installer that checks all of this. With Java, yeah, you'll have to bundle your dependencies, but as long as they have a JRE installed, that JAR will run. Swing is Swing, whether they're on a Mac, Windows, or a Linux box, and you can distribute the same binary to everybody. But yeah, good luck getting them to install a JRE without having to worry about downloading a bunch of fucking toolbars in the process. Thanks, Oracle. (I know they took it out a while ago, but you can literally hear a 50-something's butthole pucker when you tell him or her to update Java on their workstation.)
Maybe, but one can do some pretty interesting stuff with JSF, like the &lt; ajax /&gt; tag , and javascript resources by declaring them in the pom.xml, [webjars](www.webjars.org)). As an example of a well done component there is [primeface's table with filter](https://www.primefaces.org/showcase/ui/data/datatable/filter.xhtml), very hard to do that with jsp/jvascript/css "by hand". 
I programmed for an FTC team last year, you could pick up a Java 6 book and still be fine.
Yes they are, but it massively reduces the verbosity of the code you write, and as a result allows you to be more expressive. The same with properties; they reduce verbosity.
It has become engrained in web dev to latch onto trends. 
I did not say anything about interpreted vs compiled. That is of course irrelevant for discussing the language syntax. Also irrelevant are details like if it usually compiles down to machine-code for a real CPU or some virtual CPU or some kind of other byte-code. When I first started working in Java was in version 1.1. It was essentially like programming in C plus you had a built-in garbage collector and a simple C++-like class-syntax. C is the "portable assembler", as low level as a language can (without being assembler or machine-code as numbers) get by any definition I can imagine. Compare that to the highest level languages like Prolog or Common LISP that did not come from trying to make machine-instructions human-readable, but from the opposite side of just defining a language to be whatever they thought it should be (based on some mathematics or whatever), worrying about trying to make it run on real hardware as an afterthought. Python is much closer to that tradition of high-level language. I never had to think about what size of integers to use (and I never even had to consider what size the integers in python are; I just googled and learned that python 3 switched to using BigInts that can grow until you run out of RAM so there *is* no maximum value to worry about in practice). That kind of design is terrible for performance of course because the compiler/interpreter have no way of optmizing almost anything, but I think that is exactly why it is "high level".
I feel like python maybe more apt for that. 
Lucky for you, IIRC interfaces will allow method definitions soon which basically makes them a lot more like traits if not the same thing.
Imho "expressiveness" is overrated. It's important to know what's actually happening. Turning code so far into english that you can't know what the computer is up to is sketchy. Something like this is: &gt; str = 3 * 'test' resulting in *str* being 'testtesttest' is an absolute load of crap because it tries to extend an already questionable use of arithmetic operators for *concatenation*. At least 'dog' + 'house' makes sense because there's no ambiguity in joint two strings into one and the operands are of the same type. Code verbosity is NOT some **evil** to be disposed of at any cost. 
C++ is essentially the same speed as C. 
Java 1.1 was 20 years ago. I'm not qualified to evaluate all the differences since I started using Java around 1.5 (Java 5), but 7 versions of the language leave a lot of room for change. I've written code in C and Java is at a much higher level, especially when it comes to string manipulation and objects. Generics are a far sight better than mangling around with casts and Lists beat out arrays any day for frequently adding and removing stuff. There are many things to worry about in C that are hidden in Java of which memory handling is a significant example. With regard to byte order you still have issue anytime you deal with stuff that was created outside the VM since Java assumes a byte order that *might* not be the case. Also Java only has signed numeric types afaik, so you end up having to use longs if you need a larger number. So C has a slight leg up there. The python approach you describe might be better but it completely *obscures* that representing a larger number than 2^32 - 1 will double the memory usage for a number larger by *1*. I think expressive implies a certain degree of sloppiness and inefficiency when it comes to coding. At the very least and in the very best case the computer is doing a lot more work so the programmer can be lazy.
Did I say I wanted to multiple an integer by a string? I said I wanted to reduce boilerplate where it's redundant. Your argument is a straw man.
In Java 8, interfaces allow default method definitions, but they can't store state. The JVM bytecode from a Scala trait basically translates it into a "magic" inline delegate class definition: https://stackoverflow.com/questions/2557303/how-are-scala-traits-compiled-into-java-bytecode So if you wanted to compose part of a class out of mixins, you can do it in Scala, but in Kotlin and Java, you're boned unless you want to write a bunch of explicit delegate boilerplate.
It's just an example of a kind of 'expressiveness'. The problem is what do different people consider "redundant"? Please note the comparison between Groovy and Java in this [example](https://stackoverflow.com/questions/638881/what-does-expressive-mean-when-referring-to-programming-languages). There is no straw man here. I think that it's nice to do this: &gt; for(Car c : cars) { &gt; } It's a bit more *expressive* than specifying an index variable, the comparison to the list size, and the exact increment I want. However not everybody is going to agree that such is good and it has some downsides, however minor they may be. In that case it must be an *iterable collection* containing Car(s) or a subclass of Car. It can't contain other objects at all. I also can't pull any easy tricks with modifying the index and have to stick to using continue and hoping the rationale is clear. Another consequence is that trying to remove objects *while* iterating produces concurrent modification exceptions. If it was just an index and I removed something it's not a problem and will exit the loop if there happen to be no more objects to look st after I remove one of them.
It *should* be identical for anything trivial. Hell, compiler optimization is smart enough that a lot of the time, *non*-trivial tasks should still be within the benchmark's margin for error.
&gt; declare your variables public Found the JavaScript programmer.
Care to elaborate what am I am missing? Did I mis-read the article?
This kind of programming is possible but it can cause some errors. Those can be dealt by programs like checkmarx but still it's recommended to try and avoid those as much as possible.
As a new to Java I recommend taking some courses on the web as they can really useful and save you a lot of troubles. It's really important to know how to deal with errors and detect them quickly. If you're having troubles doing that on your own you can always use a program as help. I tend to use checkmarx and it works fine. Good luck!
Don't spam such here. Should you do it again, you will be banned without further ado.
Also give Scala a look. It's somewhat like Rust, but runs on the JVM.
is it considered as a spam ? i didn't know i thought its a place to discuss all about java !
These "Top xxx Interview questions" are all spam without any exception. Especially the site "career.guru99.com" is a complete spam site don't use it and don't recommend it any further.
okay roger, that ... deleting the post 
Yeah. C++ can for sure be slower. But there is no reason c++ to be generally slower since you can right a lot of the tasks with almost identical techniques which compiled down to the essentially the same thing 
Please, when *replying* use the **reply** link below the comment you reply to. This way the commenter gets a message. If you are new to reddit, which you are, it is best to first check the subreddits, read into them and see what the general tone and content is. Once you know that, post. Also, don't blindly post links. This is not really welcome on reddit in general.
Since this is help with **Java Programming** it should be, as the *plenty hints* on the page indicate, be posted in **/r/javahelp**.
And when you need those advanced features there's plenty of JVM languages that have them
Ok - &gt; suggested Spring MVC instead of JSP... It's like you're saying "We're going to replace our Ford Fusion with Goodyear Tires because they're more reliable". When you realize one is a car, and the other are tires that go on the car, it's non-sensicle. Spring Mvc instead of Jsp is equally non-sensicle, they don't do the same thing and are not replacements for each other. 
var has nothing to do with lazyness. The only usage of type inference is less typing redundant type information. e.g. `List&lt;String&gt; s = new ArrayList&lt;&gt;();` becomes `var s = new ArrayList&lt;String&gt;();`
&gt; optional and can be used Thats an issue. I needs to be enforced for only evident use cases.
`ArrayList&lt;String&gt; bucketOStrings = new ArrayList&lt;String&gt;();` is not usual. It's `List&lt;String&gt; bucketOStrings = new ArrayList&lt;String&gt;();`. Type inference is unusable for collections. 
&gt; Though maybe spreading @Deprecated annotations with more fervor would be nice. We're doing what we can.
Still, you should know the API you are working with. And IDEs like IntelliJ often show the type as you are typing the names out.
Value types will likely help with this. Stay tuned!
The architects are working on generic specialization, which will work with both primitive and value types.
Ugh I hope the Java IDE's manage somehow. If not I would introduce a checkstyle rule to completly ban "var".
I think he must be the reincarnation of /u/agleiv437.
I couldn't tell you. I've not done anything with swift. I'm not sure it would be suitable for embedded work anyway. The thing is there is a lot of legacy there, and the majority of the effort is interfacing with hardware. How wise would it be to swap out 20 years of developed driver code for the sake of a bit of application logic in a new language?
All the points you mention are either addressed in Java 8, Java 9 or a future version. Also Android is just lagging behind.
Thank you 
Noone knows the API's of all the JDK, the libraries and frameworks, the own codebase by heart. You know the basics of course, but not all details. The IDE doesn't help when you start typing "var variableName = ". It could be everything on the right-side. 
Fast without pointers? That is Java
Still, if some people want to use it, they can. If some don't, they won't. They're just trying to reduce boilerplate.
It's all about reducing boilerplate. With Java's local variable type inference, I don't know if you'll be able to write the type.
I for myself like NodeJS a lot because I can develop insanely fast in it, but I like Java as well and for a enterprise App which has to last many years I would probably use Java over Node
I am sorry but you are taking my sentence out of context. And the context is JSTL (which is what the original article was talking about) So Spring MVC **plus** JSTL is a perfect replacement for JSP scriptlets. Or you disagree with that as well?
Does it access a database of any type? If so did the language settings for that get changed?
There will always be that type of person, the guy/gal, who will gaslight everything instead of providing actual counter-arguments for the ones already made. Again, you either bullet point the legitimate arguments made in this thread and refute them -- or you provide a well-elaborated generalization of why Java is actually terrible. Thus far, you've made more of an effort to attack me as a person, than you have at discussing the argument at hand.
Looks like we hugged it to death :(
If you are looking for general programming exercises for mostly beginners, I would try www.codefights.com.
hover your mouse over it... - oh its a map - x.[auto complete all map methods] Use kotlin for a while and you realise its no big deal at all and makes code so much nicer to read. 
&gt;So I get to gently explain to him about once every six weeks that, no, using classes is not "tanking performance" in the fucking program. ...I'm so sorry. Do you integrate with NewRelic? Its APM metrics can be really helpful when trying to dodge this kind of performance bikeshedding.
If you're okay with annotation-driven codegen, you might want to check out Immutables: https://immutables.github.io/
&gt;Hopefully Java will keep bastardizing Scala features (e.g., lambdas) in the future. Since the proposed Java additions coming down the pipe reads like a list of Scala's features (type inference, pattern matching, value types, etc.), I'd say we're in luck.
I’d rather use Python for rapid development. It has a much saner type system
I like the elimination of null. That seems like something I’d like in Java. But what’s the alternative to exceptions?
Oh man, I’ve ran into this shit.
Oh my god I'm sorry, I read your first sentence and assumed it was him trying to gaslight me again. I'm so sorry. I didn't mean to direct my other reply towards you.
It's okay I never Reddit so no harm no foul :) simply agreeing with you
Awww, poor site. Seems to be back up now!
You missed :) 
Code reviews often happen outside of the IDE, though. Extensive use of “var” can make code reviews harder in my experience. 
In C# at least, “Find Usages” does find those that are assigned using “var”. The compiler has all of the type info after all since it’s still statically typed, just with an implicit type tag. 
Something that was mentioned in the JEP or whatever is that it allows you to line up variable names so multiple lines of code are easier to read. Like this: var nameList = List.of("bob", "jim", "sally"); var count = 20; //is literal inference allowed? var favoriteName = "jim"; So you can avoid this: List&lt;String&gt; names = List.of("bob", "jim", "sally"); int count = 20; String favoriteName = "jim"; You can see that the variable names in the second example are much harder to quickly read.
Something that was mentioned in the JEP or whatever is that it allows you to line up variable names so multiple lines of code are easier to read. Like this: var nameList = List.of("bob", "jim", "sally"); var count = 20; //is literal inference allowed? var favoriteName = "jim"; So you can avoid this: List&lt;String&gt; names = List.of("bob", "jim", "sally"); int count = 20; String favoriteName = "jim"; You can see that the variable names in the second example are much harder to quickly read.
nice overview!
It must also be why we're now on a six month release schedule, with features like local variable type inference, pattern matching, value types, generic specialization, fibers and continuations, and things like the Graal compiler 🤔
It doesn't find the left side declarations wherever you don't spell out the type on the right side. Like from properties or methods. 
You make a good point, too. Java isn't just a great platform to create systems with, it's a great tool for making money because there isn't enough people to help make those systems!
&gt;I for myself like NodeJS a lot because I can develop insanely fast in it Not if the code has to actually *work,* no, you can't. JS' type system is utter chaos, and chaos is really really bad for software (except random number generators).
mockito should be there
&gt; for mostly beginners They do get rather tricky towards the end, don't let the gentle introduction fool you! A few days ago I did one that required implementing Kirchoff's matrix theorem, and the one after that requires extending it to count the number of MST's.
Fair enough. I've only dabbled in the beginning sections. 
I didn't mean to disagree, just wanted it known that it also has lots of good stuff for anyone looking for 'advanced' challenges, especially the graph section. The site is just so much nicer to use compared to all the other ones out there that I didn't want anyone to miss out!
A nice thing to wake up to. :) When Java 8 first came out I never really liked the stream API. It didn't feel understandable. But then I started using it and I realised the code tended to be a lot more readable. The intention of the code became much clearer. "Okay so I'm taking this list, finding all the items that are in progress or in the future and getting a new list of just those IDs". I'd been missing experience with the coding style. The other missing component was using named lambdas as documentation. Instead of that confusing complex `filter` operation, you have something like `filter(itemInProgressOrInFuture)`. You could use a method reference too if you're going to use the same predicate multiple times. The advantage the is that you can easily unit test that method. Plus, they're very likely to be pure functions.
Notice how this sub is about Java? I see the word Java is mentioned zero times in the linked article. Interesting as the article may be, it belongs in /r/lisp or /r/programming or /r/alankay. In fact, I've already seen this very article on /r/programming this week.
Please see the sidebar and repost your question in /r/javahelp or /r/learnprogramming. Notice the big black letters: &gt; NO programming help, NO learning Java related questions!
Google "How to read reddit sidebars which are written in huge ass bold letters and are the first freaking thing". 
Wrong subreddit. Please post such questions in **/r/learnprogramming** and make sure to read the **Frequently asked Questions** there before you post because they contain links to practice problems.
Thanks a lot!
Not only does the code work, writing in nodejs also produces very scaleable, but also fast code without doing much since you have to write in an asynchronus fashion all the time. I once wrote an indexer + search engine in node for university. We got laughed at for using node for this task, in the end our indexing step was as fast as the indexer written by colleges in c#.
Ha! I don't believe a word of that nonsense.
Bullshit. I believe exactly none of that.
ok what exactly do you not believe?
Optionals have no place in parameters or fields.
I like to use Stream's for those use cases aswell. What I'm often missing however is when I want to filter on some "deeper" property but return the items of the original collection. Can't use map or method references: collection.stream() .filter(a -&gt; a.getB().getC().equals(givenC)) .collect(Collectors.toList()); What I'd like to to: collection.stream() .shallowMap(a::getB) .shallowMap(b::getC) .filter(c -&gt; c.equals(givenC) .collect(Collectors.toList())
Yeah, screw getters and setters
You have some preliminary results, or you think? The J9 JVM is more conservative, but I think also the openjdk is part of the problem. 35megs RSS for hello word? Cmon.. Yes, 35megs is nothing, but that's just basic app. Scale that in a modern cloud/microservices environment, suddenly you wasted GBs of ram (and also that's not very green).
Agreed. Optionals should really only be used as return types. If someone can pass null to an optional argument you will still get an npe.
Better to document your API with null/not null annotations and let the IDE warn you.
That's not exactly scalability. Maybe vertical scalability. What we usually mean by scalability is that with little work you can run it on multiple cpus, or in a cluster to scale with load. Or sometimes that you can serve thousands of connections, but any modern java web framework can do that nowadays. NodeJS is single threaded and definitelly not inherently horizontaly scalable like for example PHP (because PHP runs for each request, it has no state, it's easy to scale with load balancer, but PHP is super slow).
NIO has other benefits like ability to use sendfile behind the scenes. Someone once measured it and found out, that asynchronous IO is in fact slower than multithreading. Multithreading eats stack space and OS can't handle such large amount of threads, that's the only problem with it. AIO+righ amount of threads is best of both.
Do that, use [Objects.requireNonNull](https://docs.oracle.com/javase/7/docs/api/java/util/Objects.html#requireNonNull(T)), and document it if it's unclear or a public API with `@throws`
Python2 or Python3?
Certainly true relative to C++. Java was designed with the goal of replacing C++ for writing enterprise software decades ago. That goal was definitely achieved. The success of Java's GC was certainly a milestone in programming history.
does that still compile very slow? I've heard of warmup, but wasn't able to use that via IntelliJ last time I used it, working with Scala was terrible since it would compile everything everytime.
Oof. Strongly disagree on the "struct" style, especially if we assume (and later notes _do_ assume) a good set of tooling. If you want final, you only need a getter anyway, and if you don't want final, you really ought to have a setter for possible (later?) sanity checks. &gt; it's a waste What is a waste about three keystrokes to generate getter/setter? --- [Square's dagger is deprecated](https://github.com/square/dagger#deprecated--please-upgrade-to-dagger-2), and has been for quite some time. Use Google's dagger fork instead. --- Given the `final` advice, lots of params and vars are missing `final` in this doc. Either it is a good idea, or it isn't. --- Java 9 is here, JUnit 5 is here. --- Effective Java 3rd edition will be released soon.
I'm currently building a Java app with Tomcat and deploying with Google Container Engine and Kubernetes. I'm very new to containerized applications but have been using Vagrant and Ansible for a long time for dev ops.
18.3? What happened to 1.5, 1.6? I'm out of loop
reminds of scala, lol, w/o adding the type declaration, intelisense in IntelliJ won't work. I'd be confused if something was wrong with the code.. I can't be bothered manually looking up the available methods I can call...
 List&lt;String&gt; names = List.of("bob", "jim", "sally"); int count = 20; String favoriteName = "jim";
Python 3
how good is it's Java interop? Scala has two APIs to convert a Java List to Scala list. And you have to import it. And sometimes it doesn't work as you expect.
Yep, I'm working with an API that has a `Foo.createInstance()` method, but contains no documentation (annotations nor Javadoc) regarding whether it returns `null` or throws an exception. Fuck you developers; fuck you right in the ear.
&gt; You'd really like to just pass a function, but instead need to pass an entire anonymous class that @Override's the proper method. This is fixed with Java 8 lambda. button.addActionListenter( e -&gt; System.out.println(e) ); not sure if this is available in Android's JVM.
Unless otherwise specified, assume passing null throws an NPE.
It is an old language. Back when it was new, it was the hipster's choice. It is better at achieving stable software for enterprise as opposed to then dominant C++. Now the wheel of time has turned again.
What kind of calculator are you guys compiling stuff on where compile speeds are a serious issue? I’ve worked on a $200 laptop, and a $2000 desktop, and they’re both usable. I’d call one luxury.
With the risk of tooting my own horn too much: A fair amount of people like my screencasts @ https://www.marcobehler.com , so in case you find them valuable as well, they could be something for your resources / videos section.
Well, yes...it’s an enhancement that builds in typesafety. That’s a good thing and I can’t imagine why you would want to not use it. Removing the old class and creating a new class would be a bad idea. If you’re only issue is the flood of warnings when you upgrade the Java compiler, then you can add @SuppressWarnings annotation to the individual classes with the appropriate parameter. 
It does incremental compilation these days, at least if you use SBT or scala-maven-plugin. (For the latter, you have to explicitly turn on incremental compilation in the plugin configuration.)
&gt; whether it returns `null` or throws an exception
Looks like [Mojibake](https://en.wikipedia.org/wiki/Mojibake). What language is it suppose to be? This happens when a UTF8 encoded file is read as ASCII.
**Mojibake** Mojibake (文字化け) (IPA: [mod͡ʑibake]; lit. "character transformation"), from the Japanese 文字 (moji) "character" + 化け (bake, pronounced "bah-keh") "transform", is the garbled text that is the result of text being decoded using an unintended character encoding. The result is a systematic replacement of symbols with completely unrelated ones, often from a different writing system. This display may include the generic replacement character � in places where the binary representation is considered invalid. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
And? Like you say, one can do non-blocking IO and event queues in lots of languages. Node is nothing special there.
&gt;NIO has other benefits like ability to use sendfile behind the scenes. Now that everything happens over HTTPS, that's not too helpful any more…
Challenge accepted! public class ShallowMapTest { static class A { public B b; public B getB() { return b; } } static class B { public C c; public C getC() { return c; } } static class C {} @Test public void foo() { C givenC= new C(); C otherC= new C(); B bWithoutC= new B(); B bWithGivenC= new B(); bWithGivenC.c= givenC; B bWithOtherC= new B(); bWithOtherC.c= otherC; A aWithoutB= new A(); A aWithBWithoutC= new A(); aWithBWithoutC.b= bWithoutC; A aWithBWithGivenC= new A(); aWithBWithGivenC.b= bWithGivenC; A aWithBwithOtherC= new A(); aWithBwithOtherC.b= bWithOtherC; Collection&lt;A&gt; collection = Arrays.asList(aWithoutB, aWithBWithoutC, aWithBWithGivenC, aWithBwithOtherC); List&lt;A&gt; result= collection.stream() .map(i -&gt; new AbstractMap.SimpleEntry&lt;&gt;(i, Optional.of(i))) .map(i -&gt; new AbstractMap.SimpleEntry&lt;&gt;(i.getKey(), i.getValue().map(A::getB))) .map(i -&gt; new AbstractMap.SimpleEntry&lt;&gt;(i.getKey(), i.getValue().map(B::getC))) .filter(i -&gt; i.getValue().isPresent() &amp;&amp; i.getValue().get().equals(givenC)) .map(i -&gt; i.getKey()) .collect(Collectors.toList()); assertThat(result, is(notNullValue())); assertThat(result.size(), is(1)); assertThat(result.get(0), is(aWithBWithGivenC)); } } Err... well.. look..... nobody ever said it would be pretty! But it works :)
Right, that part sucks in Scala. In Kotlin a Java list is a Kotlin list. I haven't found anything yet that hasn't worked across the languages.
A good read. I wish Java had a way to enforce the principles mentioned in this article as I like to design most of my methods this way. Would just be nice if the compiler had a way to guarantee it in case I made a mistake without realizing it.
In Node everything is non-blocking using callbacks per default. If you write a method in your class it will get a callback passed or return a promise, if you do a database read same thing, file system access, same thing. You barely write synchronous code. Sure other langs support is as well, but JS handles it in a very simple way as functions as input parameters are allowed.
Thanks! Unfortunately verifying purity is not possible at compile time.
Depends on your configuration. You can have ssl on the edge proxy and use plain traffic internally (see nginx docs why you would want to do this). (btw you've similiar issue with gzip encoding)
This is a font rendering issue, not a character set issue - note the terrible kerning. It's drawing incorrect characters with the spacing of the correct characters.
I have to (politely) say that I disagree with your disagreement about the struct style. Endless getters and setters that add no value is one of the reasons people make fun of Java. 
[TypeSafe Config](https://github.com/lightbend/config) + [tscfg](https://github.com/carueda/tscfg) 
You mention Java Tuples. Javaslang(now vavr) provides [Tuples](http://www.vavr.io/vavr-docs/#_tuples) with better api.
Have you heard about the new time based release cycle? 18 represents 2018 and 3 represents March. There will be a new release every six months.
I filled out the form, but I'll post some of my answers here for discussion. *What's the most important thing about modern Java style to you that I should mention?* Higher-order functions. Streams aren't the only place to use lambdas/method references. Embrace "Code as data"/parameterized behavior. *What's one thing about Java that more people should know about?* Collectors. They're succinct, declarative and wonderfully composable. Get comfortable with all the premade ones in `java.util.streams.Collectors`, but then it's worth digging into the Collector interface and creating your own. As with lambdas, they don't strictly rely on Streams. *What's one thing you'd tell someone skeptical of Java to encourage them to try it?* IDEs and other tools make up for some of the short comings of the language fairly nicely. When you pick a language you're using the whole ecosystem, not just the language itself. When taking into account all the available tooling, Java gains a lot of ground versus other languages.
Good work :) I hope they make it into the Streams API someday.
I don't disagree that they are a pain, only that they are part of the conventions that we live with, and that tools expect. Were I writing Java in vacuum, dropping them would be pretty reasonable in most cases, but we (at least most of us...) use Java not because it is pretty, but because there are pretty great network effects, between others who can read/write the same code, and other code and tools you can lean on.
What tools are you using that expect getters and setters?
I get that JavaBean style is useful, for things like DI, etc, but the kinds of classes I write in this style, it just doesn't add any value for me. The only thing that bothers me is no method-reference, which seems prettier to me, but it doesn't bother me enough to stop doing it. ``` stream.map(Person::getAge).collect(...) ``` vs. ``` stream.map(p -&gt; p.age).collect(...) ```
You name *Gradle* as an alternative to *Maven*, but I think you should talk about it as the first choice and give more importance to it. In addition, maybe you should talk more about functional programming in modern java and, at least, a simple explanation of java-9 modules. Also, you talk about *Optional* in fields and parameters, which is not advisable. I would recommend to use Jetbrains' *@NotNull* and *@Nullable* annotations for those cases. You can also use them in method declarations and parameters. They really help you with nullability. Finally, I recommend the use of *final* whenever is possible. You should say something like "use the final keyword by-default and erase it if you need mutability" to enforce immutability best practices. I didn't know your guide and I really enjoyed. I'm sure the new version will be awesome. Best wishes!
What are those advanced features that other languages have which Java doesn't?
Here's my other candidate: public interface Foo1 { default void foo() { } } public interface Foo2 { default void foo() { } } public class FooImpl implements Foo1, Foo2 { // this is OK @Override public void foo() { } } public class GenericFoo&lt;T extends Foo1 &amp; Foo2&gt; { // here I get the error } Here I get the error `T inherits unrelated defaults for foo() from types Foo1 and Foo2`. This is actually [a bug in the JLS](https://bugs.openjdk.java.net/browse/JDK-7120669).
Jackson is a huge one that comes to mind. (The auto object to json bit, obviously not the core)
It's one good thing about the map function in JS `collections.map(a =&gt; {return a.getB().getC() === givenC});`
Doesn't look different than the solution with filter in Java.
[Some homework for you](https://en.wikipedia.org/wiki/Uniform_access_principle).
**Uniform access principle** The uniform access principle of computer programming was put forth by Bertrand Meyer (originally in Object-Oriented Software Construction). It states "All services offered by a module should be available through a uniform notation, which does not betray whether they are implemented through storage or through computation". This principle applies generally to the syntax of object-oriented programming languages. In simpler form, it states that there should be no syntactical difference between working with an attribute, pre-computed property, or method/query of an object. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Hey, WPILib developer here. Read the [screensteps](http://wpilib.screenstepslive.com/s/currentCS), especially [the bits about Java development](http://wpilib.screenstepslive.com/s/currentCS/m/java). There's also a lot of discussion on [ChiefDelphi](https://www.chiefdelphi.com/forums/index.php?) in the [Programming](https://www.chiefdelphi.com/forums/forumdisplay.php?f=51) and [Java](https://www.chiefdelphi.com/forums/forumdisplay.php?f=184) subforums. There's also /r/frc if you really want to stay on Reddit, but CD has a much larger (and smarter) community. Read screensteps first, it gives step-by-step instructions on how to set up the RoboRIO and your development environment. And the Java 8 book is fine, since that's what you'll be using to program the robot.
Operator overloading, among other things. All kinds of syntactic sugar that makes unreadable code (and good code, admittedly) easier to write.
Do you have iStat installed? You can track the battery with that
 But I’ve run this test 500 times, I don’t know why my app is crashing. 
I've gone about 4 hours while running intellij
Are you capable of reading? If so, how could you have missed the **sidebar**: **Do not post tutorials here!** Before you continue posting your **self promotional** content, you should really read the **reddit rules** [**What constitutes spam? Am I a spammer?**](https://reddit.zendesk.com/hc/en-us/articles/204536499-What-constitutes-spam-Am-I-a-spammer-) because these parts: + If you flood a Reddit community with posts or comments, you may be considered a spammer. Instead, post one or two times and see what happens. + If other users in a community historically downvote your posts or ones similar to yours, but you feel the need to continue submitting them anyway, you may be considered a spammer. apply **100%** to your contributions to reddit. **We do not tolerate spam, nor spammers!** This is your first and only warning. Next one will earn you a ban.
`var x;` by itself is invalid Java, the compiler needs an initializer like `var customers = someService.getCustomers();` to be able to figure out the static type of the variable.
Or, alternatively, `button.addActionListen(System.out::println);` 
Getters and setters are must haves especially if you're working on an api. Lombok is the way to go.
While the performance benefit of flat value types is nice, I honestly want them because writing a value class in Java is hundreds of lines of code (even if they are auto-generated) when it should only be one, e.g., as in Scala or Kotlin.
This subreddit is about **Java**, not about *Scala*, not about *Kotlin*, not about other *JVM languages*.
The architects are looking into adding data classes to Java. These are different from value types.
I’m not clear on specifically how JShell helps with testing micro services. Anybody have a demo?
ok
Objects First with Java
Why do you need data classes separately if you already have value types?
The one by Cay Hortsmann
Head first JAVA. I was in your spot once, not anymore. This book is really interactive and full of excercises.
Please read the sidebar.
You probably don't want your value classes to have too many fields, as that will just fill your caches
https://www.reddit.com/r/learnjava/ is a good reference.
I had the same complaint until my team adopted Lombok, which solves the problem pretty well.
If you are smart you don't need to read.
Horstmann is highly recommended. You can't go wrong there. However, I use Starting Out with Java by Tony Gaddis for my courses that I teach. There are several versions: Early Objects or Late Objects, plus a decision of how much to cover, up to Objects, or all the way through to Data Structures. In my course we do lectures in a lab and I find that the Gaddis book gives better examples for students and a wider variety exercises at the back of the chapter. That's especially important for learning to program because you need to actually DO things to learn the skill.
**Sidebar** **NO programming help, NO learning Java related questions!** Please, read the **sidebar** in **/r/learnjava** for recommended resources.
Thank You. I'm not really in a hurry because I'm in the Design team this year, but I'll definitely use this
it's bollocks
I think it's more of an issue with IntelliJ not being able to compile only the file you are changing. Or at least that's what I've read investigating it. In Eclipse, it would only compile just the file you are working on. I believe it has something to do with the special compiler that Eclipse is using. With a lot of source code and not being able to use that incremental crap that Scala apologizes for... or at least it wasn't out of the box with Intellij + scala plugin. anyway, if the project I was working on wasn't a legacy java calling scala code.. it would've probably a different experience for me.
Oh sweet. although I hope no experimental syntax gets introduced.
i don’t think it will help with testing ms. For me it’s just a way not to write MAIN method or unit tests just to see how some specific method works.
This has got to be one of the most low effort posts i've ever seen. Congrats someone uploaded a library. Maybe include information about why anyone should care? Any actual content at all?
There were 28 upvotes within a couple of hours. It seems that many readers found this to be a useful submissions. Beside, the framework makes use of Java bindings for CUDA.
But you don't see the reports we moderators are getting. Some of them weren't very nice.
So you've got people here to spend their time writing reports that aren't "very nice" about a link to an open source library for the JVM that, in part, is based on JCuda. And, as a result of these actions, the majority, represented by 28 upvotes, doesn't get to see this information. The project itself might not be particularly important. But the overall topic of machine learning is quite relevant and deserves coverage. It would not even have occurred to me that people would do this sort of thing and that they dominate the discourse. Rest assured that I won't bother you with any more project updates.
&gt; EE4J I just died inside
If you haven't heard of FlatBuffers (and Protocol Buffers) yet, you won't care. And that's fine. Before one had to include FlatBuffer sources or create an artifact. That's all. Just some new convenience.
Yeah it's just a command line java editor that can store variables, has multiline edits for blocks and even has auto complete. It's pretty neat if you want to quickly see the output of some system method. 
Gotcha. I use eclipse anyways, so maybe that’s why I could work on a $200 laptop
I agree. Exposing fields directly mean you have no control of the state unless you make it immutable which is not always desirable. If you don't like setters and getters you can use a fluent style though many apis don't support that either. public class DataHolder { private String data; public DataHolder() { } public DataHolder data(String data) { this.data = data; return this; } public String data() { return this.data; } } 
That is correct. They do not allow for representational polymorphism.
Would you be open to filing a bug on https://github.com/uber/NullAway? I'm betting that Manu would be interesting in supporting this use case. Actually, I'd be surprised if there wasn't already a configuration option for this. 
You're kidding, right!? Flatbuffers! One of the last essential dependencies that just refused to be on maven central, moved to... maven central!
A bad joke, though...
An old one but a good one. https://en.m.wikipedia.org/wiki/Design_Patterns
**Design Patterns** Design Patterns: Elements of Reusable Object-Oriented Software is a software engineering book describing software design patterns. The book's authors are Erich Gamma, Richard Helm, Ralph Johnson and John Vlissides with a foreword by Grady Booch. The book is divided into two parts, with the first two chapters exploring the capabilities and pitfalls of object-oriented programming, and the remaining chapters describing 23 classic software design patterns. The book includes examples in C++ and Smalltalk. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Remind Me. 8 weeks!
I dunno, I find that books are sometimes better than digital reference. I often know "where" something is in a physical book far better than "where" something is in a digital book. And while Ctrl-F is indispensable, it can be equally useful to stick a post-it note to a page or write a clarification in the margin. I feel like ebooks add a lot but lose something in the process. Books are just more tactile than anything digital. And that's not just some sort of hipster romanticism - that tactility adds a useful dimension for interacting with the book. Plus, from a purely romantic position, it *feels nice* to pull a tome off the shelf.
I use IntelliJ and Eclipse, and the compiling times are about the same. Maybe reinstall?
Whats the time using javac and java? 
Is it a maven build or are you directly running it?
Compilation of 100K lines of code takes less time...
I sometimes encounter this when it's the first time I run something in a large project. When I run it again, it's pretty fast.
We use Lombok in our project and I use it in almost all of my own projects. Haven't written or generated getters / setters in ages. The struct style still directly exposes stuff you might want to hide and is IMHO a bad idea.
&gt; I for myself like NodeJS a lot because I can develop insanely fast in it How? How is working in Node.js in any way faster? I've seen the same been said about Go as well. With Node.js you only save a tiny bit of time typing which you loose due to most errors being at runtime. With Go you just have to write a ton more stuff to do the same thing. People make claims like this all the time but never explain the 'why'. 
Not just that; he's a complete beginner too. He accidentally asked some beginner questions a while ago and forgot to switch out of his troll account. He deleted them when I made fun of him.
Tiobe index is utter rubbish though. The only thing those spikes and dips are showing is the huge changes made to the google search index. 
Thata true. I only asked to make sure that its indeed IntelliJ fault. 
&gt; Condition cond = DSL.trueCondition(); &gt; &gt; Seq.of( &gt; Optional.ofNullable(reqest.getId()).map(Tables.PERSON.ID::eq), &gt; Optional.ofNullable(reqest.getAuthorId()).map(Tables.PERSON.AUTHOR_ID::eq), &gt; Optional.ofNullable(reqest.getdateCreationRange()).map(range -&gt; Tables.PERSON.DATE_CREATED.between(range.getMin(), range.getMax()), &gt; Optional.ofNullable(reqest.isAdmin()).map(Tables.PERSON.IS_ADMIN::eq), &gt; ).filter(opt -&gt; opt.isPresent()) &gt; .map(Optional::get) &gt; .forEach(c -&gt; cond = cond.and(c)); That shouldn't compile, no? `cond` is effectively final. This should probably done with `Stream.reduce()` instead...
Thanks for your explanations (and sorry for the delay). Yes, indeed, I think this is clearer now. As I suggested, it is a case of applying querying by example, but with much more sophistication. Essentially, jOOQ right now is missing: - The capability of creating arbitrary predicates, not just equality predicates, from examples - Including sort (and pagination) capabilities As far as "PojoToMapAdvanced" is concerned, the jOOQ way to do this could be `RecordUnmapper`, but I'm sure there's room for improvement. I'll think about this some more, I can definitely see a few change requests in this area to make the out of the box API more powerful.
dynamic typing fastens up my coding a lot, especially when I have to parse and work with dynamic json or similiar stuff. You can keep your error rate low if you use type hinting on your functions
That's definitely not right. I thought intelliJ was faster or the same as Eclipse in most cases.
If you are running on Windows, maybe it is the anti-virus messing up with read access times.
probably your antivirus interfering 
That's extremely unusual. Have you tried restarting your computer? (seriously)
It’s more ‘scaleable’ for specific types of workload. It’s not a panacea. 
Cpu spikes are typically caused by spending too much time in a function. Get a profiler for your ide. It will tell you how much time you're spending in different parts of your code. You can then optimize as required.
agreed.
[JavaSlang was renamed to vavr ](https://www.google.pl/amp/blog.vavr.io/javaslang-changes-name-to-vavr/amp/)
Since Java 8 It's recommended to use java.time instead of Joda 
Yeah, but it's still better than Redmonk or any other that searches by github or stackoverflow. PYPL assumes: "The more a language tutorial is searched, the more popular the language is" (also google trends). Job postings from indeed.com is more prevalent in English speaking countries. They are all skewed towards a certain demographics. The IEEE language rankings data source seems rather random. 
&gt; Yeah, but it's still better than Redmonk or any other that searches by github or stackoverflow IMHO it is, because it actually shows an incorrect intepretation, much worse. Redmonk etc. at leasts shows a correct intepretation of their rather limited scope. Tiobe gives an incorrect interpretation of a much broader scope.
Its been around for a while. But, its the first time I've seen it so its worth mentioning
Sooo, still no reified generics ("it's going to stay"). But maybe we get the specialized type at runtime ("species") with reflection, e.g. like `getClass` still returns List.class, but `getGenericClass()` returns String.class? That'd remove a whole lot of issues I have with the current erased generics.
As far as I know, yes. I highly doubt they’ll allow for reification at the language level. Other JVM languages can certainly do so, though.
I love Webjars! For a Java guy like myself, who also has to take care of a minimal front end, Maven + Webjars is an excellent option. I'm using Spark (the web framework) and with some minimal reflection I can get automatically detect the installed version, so I can get rid of the version part of the URL, and so upgrading JavaScript libraries only implies changing the pom.xml I can't believe Webjars is not more popular 
Ops, sorry for deleting the question, you were too fast to answer :). &gt; Other JVM languages can certainly do so, though. The future certainly looks bleak for Java then.
Not necessarily. Why break code that’s been working well enough for twelve years? Type erasure was, and still is, a very pragmatic solution.
Type erasure is an annoyance. I think Java should start throwing away compatibility with last decade code. See latest article [CheckedExceptions in Streams](https://javax0.wordpress.com/2017/08/30/noexception-in-stream-operation/). &gt; This is just a simple, nice and little trick that helps you keep up with Java, which is backward compatible instead of starting development with some other language that is modern, clutter-free and let’s you focus more on the functionality you need to code instead of coding techniques.
That’s quite a naive point of view, though. Not all code lives in the same maintenance domain.
``` import java.cake.CakeFactory; import java.cake.Icing; public class BirthdayCake { public BirthdayCake() { Cake c = CakeFactory.createCake() c.setIcing(new Icing("Congratulations Darion Thompson")); return c; } } ``` You could possibly just use the content of `BirthdayCake()` if you're short on space
Thank you so much! 
At some point no new projects will be started in Java anymore. In my country, we are already seeing signs of this. Of course, who wants to maintain an old application with tons of cruft and technical dept, when they could start a greenfield project in hipster language x which is additionally interoparable?
They are not averse to ever breaking compatibility. They did just remove six methods in Java SE 9.
What does it expose that you might want to hide?
Can you explain why getters and setters are must haves if you’re working in an API?
Mutable lists for example. AtomicIntegers is another.
That is on library level, not language level.
I would use an immutable list. I would never use an AtomicInteger in what I call a “data class,” that’s a smell the class is doing much more than I need it to be. 
Yeah, it's definitely not that big a deal, just a personal preference.
essential? I know zero projects using it.
 System.out.println("Congratulions, Darion Thompson!");
it is missing a semicolon on the cake creation and the constructor does not return a cake.
Both. We're a fortune-50 company ;) 
Good spot - how doesn't it return a cake? Haven't used a Factory in ages lol. 
Java has been pretty good about versioning. When they upgrade from Java 1.8.101 to 1.8.102 I'm pretty sure that they didn't break anything and don't have to review the patch version changelog. 
Webjars are great. Spring Boot automagically resolves webjars URLs. Even better, if you're using JSPs, [webjars-locator](http://www.webjars.org/documentation#springboot) allows you to reference the files you need without specifying the version. Updating a JS library requires just updating the pom and not your JSP. Now, though, I use [frontend-maven-plugin](https://github.com/eirslett/frontend-maven-plugin) to tie in a webpack-based JS project into the maven build cycle and construct a webjars compatible jar. My backend project then includes the frontend module as a dependency and the JSPs link to the webpack created resources. This allows frontend developers to use the tools they are comfortable with (webpack, npm, etc.) and allows backend developers to not care about how the frontend is done.
yep i use it myself too...in production for quite some time, love it :D
Alright people, we gotta get this right! Two months from now we don't want to see a pic of Darion Thompson's cake as the top post of r/ProgrammerHumor for all of the wrong reasons! BirthdayCake() - this is the constructor, right? It shoudn't have a return statement. Cake class - this isn't imported, is it in the same package as BirthdayCake? Speaking of which, BirthdayCake needs a package statement. Or is CakeFactory supposed to return a BirthdayCake instance? Generally we use a constructor or a factory class to create an object, but not both at the same time.
This is the safe bet right here. Though definitely spell check it.
 return c; this is illegal in a constructor. You need to set it on a field like public class BirthdayCake { private final Cake cake; public BirthdayCake() { Cake c = CakeFactory.createCake(); c.setIcing(new Icing("Congratulations Darion Thompson")); this.cake = c; } } at least this compiles ;-)
Webjar lover checking in. Yes.
I think it is simply lack of awareness. Unless a technology is pushed by Google/Facebook/Twitter it struggles to get anywhere.
Thank you very much! There is one thing that is bothering me and it's the high complexity this version creates. It can lead to errors and although there are programs that detecting those, as checkmarx does, it is highly recommended to and avoid it. But I really like it any way. Thank you!!
You are correct. I rushed the implementation and didn't have my IDE at the time. So pseudo codeish. Reduce would definitely be preferred. There is probably a better way to handle the Optionals as well.
I could get onboard with this. Though I think we could simplify the object model even more. A BirthdayCake has a Cake field...seems a little redundant. You'd think it would either extend a Cake superclass or implement an ICake interface. Or maybe we can eliminate Cake altogether? public class BirthdayCake { private final Icing icing; public BirthdayCake() { this.icing = new Icing("Congratulations Darion Thompson")); } } 
So you also specify the frontend package version in your backend pom.xml?
Yes. But, who says pom.xml is for backend only? You also can specify liquibase.jar in the pom for database schema updates, or maven deployment configuration...for deployment process. Neither is strictly backend. Why shouldn't front end dependencies be included in .pom ?
**Sidebar** + **Do not post tutorials here!** These should go in **/r/learnjava**.
 public static void main(String[] args) { System.out.println(happyBirthday("Thomas")); } private static String happyBirthday(String name) { String hbToYou = "Happy birthday to you"; String hbDear = "Happy birthday dear %s"; return String.join("\n", hbToYou, hbToYou, String.format(hbDear, name), hbToYou); }
Well, Java 9 now has `Optional.stream()`, so you can flatmap it: Stream.of(...).flatMap(Optional::stream)
Aren't webjars just for static resources (loading css/js)? How does it save you from NPM hell? I use https://github.com/eirslett/frontend-maven-plugin to handle NPM in my projects now.
If these could be decently hooked into HTTP/2 then I'd be fan. Otherwise a better path is to pull all your various JS files together during the build process so that you have perhaps 3 total JS files. 1) start.js ( the bare minimum to show a loading screen" 2) vendor.js (all your libs, hopefully changes rarely and is cached) 3) main.js (all your app.js files, changes during each release ). 
do you have any thoughts on how to reach developers in the java space ? because of upvote/downvote ratios, niche software dies in this subreddit and stackoverflow frowns upon pimping your own software in answers
Agreed. I'm a web developer with a ton of Java, Maven, Ant, Gradle, etc experience and I never heard of Webjars until just now.
sorry bout that, will change
1) Setup a servlet that responds to start.js 2) Foreward to DEFAULT, with the path of jquery.js 3) Foreward to DEFAULT, with the path of bootstrap.js 4) Forward to DEFAULT, with path of mustash.js 
Here is a list of threads in other subreddits about the same content: * [The dangers of garbage-collected langauges](https://www.reddit.com/r/programming/comments/79pe1i/the_dangers_of_garbagecollected_langauges/) on /r/programming with 1 karma (created at 2017-10-31 01:49:00 by /u/thaynem) ---- ^^I ^^am ^^a ^^bot ^^[FAQ](https://www.reddit.com/r/DuplicatesBot/wiki/index)-[Code](https://github.com/PokestarFan/DuplicateBot)-[Bugs](https://www.reddit.com/r/DuplicatesBot/comments/6ypgmx/bugs_and_problems/)-[Suggestions](https://www.reddit.com/r/DuplicatesBot/comments/6ypg85/suggestion_for_duplicatesbot/)-[Block](https://www.reddit.com/r/DuplicatesBot/wiki/index#wiki_block_bot_from_tagging_on_your_posts) ^^Now ^^you ^^can ^^remove ^^the ^^comment ^^by ^^replying ^^delete!
Nothing new. * the general problem of knowing whether some piece of memory is needed is undecidable * having a garbage collector does not prevent you from managing memory 
How exactly does it help with modern frontend development though? You don't just put script tags into head to use the libraries. All reasonable frontend gets built, transpiled and bundled through npm and friends still so having a dependency through webjars doesn't help much at all.
&gt; You don't just put script tags into head to use the libraries. webjars can be used along with [wro4j](http://wro4j.github.io/wro4j/) to minify css and js assets. Spring Boot has a [tutorial](https://spring.io/blog/2015/01/12/spring-and-angular-js-a-secure-single-page-application) demonstrating how to integrate webjars and wro4j to develop an SPA with AngularJS.
It doesn't still cover the modern web workflows very well. Even the tutorial mentions that: &gt; Aside: Wro4j is probably not the tool of choice for hard-core front end developers - they would probably be using a node-based toolchain, with bower and/or grunt. 
....Awsome! Thanks for this!
This is a Java group..... full of java developers...not hard-core front end developers. Having something that will naturally fit with java back end means we can produce full stack java / javascript apps quicker than dealing with two seperate stacks. 
Thank you, "obscure, unknown thing" for saving me from "popular, well-known dominant tool". /r/java in a nutshell
As a Java developer I'd rather keep my hands off web development entirely because it's so nasty. If I still need to deal with certain web parts, it's much easier to find resources about doing that with industry standard webdev tools than try to achieve JavaScript building with Java toolchain. It's also much better if any real webdev people get involved because they'd be really put off by some unusual build process which doesn't accommodate their needs and practices. I prefer still having npm etc setup for building the front end but use Maven/Gradle to involve that into the entire build process for completeness and usage by non-webdev people. Everyone gets what they want the most.
...Webjars is not something you install... run, download, or do anything with. It take up 0 bytes on your hard drive. it just means that instead of explicitly downloading jquery.js, you put jquery.js in the pom. and let the already existing maven tools sort out what needs to be done. It need zero amount of ramp up time learning about it. It just works. In fact, totally opposite to what the well-known dominant tool is like. 
Your concern was that webjars aren't transpiled or bundled, instead promoting script tag style development. wro4j does transpilation and bundling. Of course it doesn't work as well as the *native* tools for JS. However, wro4j might be *good enough* depending on your needs, especially if you want to stick with the Java ecosystem.
That probably means you need to add at least one more unit test once you discover why it is crashing.
I run an app connected to a DB and it compiles AND starts up in 4 seconds (including connection to DB). So obviously something is very wrong in your PC.
char[] myArray = new char[1]; should give you a char array with only one slot unless I'm mistaken. Why not just use a single variable or Arrays::of?
Having an array of size 1 kind of defeats the purpose of the array. 
It's common with Spring Boot to bundle the entire application (front and backend) into a single jar file and deploy to cloud.
u/SomeRandomBuddy is a troll. You can always ignore his statements.
It's a bit of a mad question. I've failed at interviews for mediocre jobs, only to succeed the next week at a better job with higher pay. So I don't see how there could be any kind of objective metric. Every company is going to have their own.
yes, you are right. I did a mistake..
&gt; char[] newArray = new char[0]; would produce an error No it doesn't. It does exactly what it seems like it should. If you `System.out.println()` it, you'll get `[]`.
No it doesn't. One of the points of an array is to hold an arbitrary number of items, and it makes perfect sense to hold 0 things or 1 thing.
As does a variable... It can either contain a character or be null
It's a great way to mutate a variable from a lambda. The array is effectively final but its item is not.
:o you sir are naughty
A variable does what? A `char` can't be null, but yes, a variable can either contain a value or be null. Unless the variable is a reference to an array or other collection-esque object, though, it can't contain *multiple* objects (or primitives). Arrays (and many other collection-esque objects) can contain 0, 1, or any other positive integer number of elements. None of that has anything to do with your original point, though. You claimed that using an array to contain only one element defeats the purpose; it doesn't. Here's an example of when you might want to do that: static String makeEnglishList(String... elts) { if (elts == null) { throw new IllegalArgumentException(); } switch (elts.length) { case 0: return ""; case 1: return elts[0]; case 2: return elts[0] + " and " + elts[1]; default: StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; elts.length; ++i) { sb.append(elts[i]); if (i &lt; elts.length - 1) { sb.append(", "); } if (i == elts.length - 2) { sb.append("and "); } } return sb.toString(); } } Now run System.out.println(makeEnglishList("alpha")); // prints "alpha" System.out.println(makeEnglishList("alpha", "beta")); // prints "alpha and beta" System.out.println(makeEnglishList("alpha", "beta", "gamma")); // prints "alpha, beta, and gamma" System.out.println(makeEnglishList("alpha", "beta", "gamma", "delta")); // prints "alpha, beta, gamma, and delta"
This only seems useful when perpetuating an old situation where the backend renders the html and javascript from a template. In that context this solution is an improvement over manually downloading and including the minified js bundles. I can't recommended doing this but in some places there is enough inertia to make this an actual improvement. 
Having used that tool I am not happy with it. It means the backend breaks when the frontend does and the other way around. It also means that you can't put your static resources into a CDN and use seperate domains for APIs, user content and static content which makes this approach a dead end. If you do need both the front and backend up and running together I'd recommend setting up a docker compose thingy with both front and backend app. Or if that is too much effort a make file in the parent directory of both projects that starts servers for both.
&gt; Arrays::of ?
Look at a random java project on github, do you understand it? Syntax and what it's actually doing? No? Look it up. Repeat this. Look into data structures in that language (linked lists, hashing, trees, etc.) 
Someone have told you the answer. I just want to suggest, if the intention is to return an object containing a char that can be null, you can always use the Character wrapper. In addition, you can even protect your method from null pointers using Optional. In this case: Optional&lt;Character&gt;
The more important question is "can you write code that's as easily understood?" Reading well written code is easy. Replicating it is much harder.
I don't have anything against downvotes, but at least let me hear an explanation.
Riight I always use a single item list :D Also it is okay to do if you don't overdo it. 
Only note that Optional&lt;Character&gt; can also be null... 
Also, report and block.
The language allows it, but if you know you have to return an optional you won't do this. If you want more protection there are jetbrains @Nullable and @NotNull annotations. In fact, I do this, for example: @NotNull public Optional&lt;Character&gt; foo(@Nullable final String bar){ return Optional.ofNullable(bar!=null ? bar.charAt(0) : null); } If you decide to return a null, you will have a code inspection warning.
Report for having an opinion different than yours? Now that's gold
Yes. Do what this guy is saying. Lol
Well, it seems to me that you're asking two questions: what's the test fot being proficient, and how do you know when you're qualified to be employed as a Java coder. To the first question, there are certifications such as Oracle's "Oracle Certified Professional" program. I took the exam several years ago and found it to be a very challenging test. If you could do well on it, I'd say you were qualified to call yourself an expert on the core language. Of course, there's lots more to Java programming than just the core language, but this would be a good start. To the second question, you are qualified to be employed as a developer when you get a job as a developer and are still there a month later. I'm not being flippant, I really believe this. In fact, I've learned more about Java by doing it professionally for 2 years than I ever did studying it in college or studying for the Oracle exam.
Thank you. Yes you are right, "PojoToMapAdvanced" would have looked very similar to *RecordUnmapper*; And as I explained in [reflection-of-pojodto](https://github.com/Blackdread/filter-sort-jooq-api#reflection-of-pojodto), I did not implement "PojoToMapAdvanced" because DTO are already type-safe and validated (in Spring resource/controller) so it would be a bit of a waste (cpu time) to map it to a Map to then do the filtering/sorting, I wanted to think how to be consistent through the app with an API for DTO. As @dartalley said it would certainly look similar to: Seq.of( Optional.ofNullable(reqest.getId()).map(Tables.PERSON.ID::eq), Optional.ofNullable(reqest.getAuthorId()).map(Tables.PERSON.AUTHOR_ID::eq), Optional.ofNullable(reqest.getdateCreationRange()).map(range -&gt; Tables.PERSON.DATE_CREATED.between(range.getMin(), range.getMax()), Optional.ofNullable(reqest.isAdmin()).map(Tables.PERSON.IS_ADMIN::eq), ).filter(opt -&gt; opt.isPresent()) .etc...... As you say, that would be great if jOOQ can have something similar out of the box but still recommend to use DTO instead of a Map\&lt;key, value(s)\&gt;.
I can totally agree with this. Certifications are nice but they aren't necessary in my opinion. If you can do your job and fullfil your tasks you are qualified to do them. And also in my opinion programming is more trial and error than pure knowledge, so as soon as you got a basic understanding of Java you should be able to solve any problem using your own ideas as well as parts of solutions for different problems from different people. 
It sucks that so many frontend frameworks insist on bundling a cumbersome CLI with annoying tooling these days - can’t just get away with concatenation anymore :(
[Arrays.asList(...)](https://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#asList\(T...)) Confused with Stream.of()
Release from NPM hell goes by the name of Yarn nowadays. Without a build tool, you're still going to be in JS hell though. https://yarnpkg.com/
I rarely code on the frontend, and I still consider using any "Java (or Scala, etc) to HTML/CSS/Javascript" is perhaps the absolutely worst way to develop frontend applications. I'm too tired to write out the entire rant, but a few major points: * As your product ages, fixing bugs (especially browser bugs) becomes exponentially more difficult over time. * Your actual code never resembles the real code. * It's almost impossible to optimize, given you're not dealing with the code that's actually executed in the browser. * Programming javascript in a "Java" way is extremely inefficient and contradictory to the way Javascript is designed. * To debug frontend apps, you need to know HTML/CSS/Javascript anyway. As a side-note, Swagger's Java/Scala APIs are nightmare. You basically use these poorly designed annotations that don't work most of the time, and which is extremely slow to iterate and verify changes. Conversely, using the Swagger Editor, you can see your changes, errors, etc in real time. If your team has zero frontend-devs, refusing to learn any HTML/CSS/JS is only going to make your product just that much worse. 
&gt;I'm too tired to write out the entire rant, but a few major points: * As your product ages, fixing bugs (especially browser bugs) becomes exponentially more difficult over time. No, you're DevIceMan.
You're incorrect grammar-bot. Your code could probably use a little bit of help.
I think maybe you've not understood what webjars is. It's not a java to js/css converter in any shape or form. You still have to do the HTML and javascript. Its not a 'special' version of HTML, or converted on the fly. It still takes 100% front end skills, and the code you write is run directly in the browser. The front end stack, like java, also has dependency, compilation and deploying management tools- NPM and Bower are Maven 'equivalents' . These are not as mature as Java's Maven, and as its written in javascript, not as fast either. Webjars is simply moving the dependency management functionality of NPM, into Maven. By doing this, do not have to install front end stack tools, because maven handles it the way maven handles anything else. So, as an eclipse user, I end up with an eclipse workspace where If I want to make use of PostgresqlJDBC driver, I add it to the pom and it works. If I want to make use of jquery, I add it to the pom, add &lt;Script/&gt; tag pointing at it, and it works. Maven handles the interdependencies between javascript frameworks like it does Java frameworks.... with NO changes at all. it just works. 
Enthuware has a great exam simulator for that certification
Would it be better or worse to use .map() instead of the null condition? return Optional.ofNullable(bar).map(s -&gt; s.isEmpty()?null:s.chatAt(0));
I was more focused on the way you expressed your comment, and not the contents of the article. However, given I misunderstood you, I suppose disregard the above.
If you're building a project with a front-end (using WebJARs), you can hardly call yourself just a Java developer right? Then you're doing both Java and JavaScript. It all depends on the project, but there are proper JavaScript tools now that take care of transpiling, dependency management, unit testing, code quality checks, ... . /u/sim642 is right when he says that WebJARs (and wro4j) doesn't cover all of these. And even if it did, then you can ask yourself if Java/Maven is the proper toolset to maintain a frontend project. You can't rely on what 99% of the web does, and have to rely on certain Maven plugins. I tried WebJARs before, but I eventually decided that they were more of a nuisance than good. Yes, they can be easily added to your project, and that's good if you're not going to have a really complex front-end. But in these days, the front-end part of the application tends to become more complex, and probably shouldn't be seen as a part of your Java application (or PHP, ...) but should have a dedicated project on its own. In that case, it makes more sense to use the proper toolset for your frontend-application (eg. Webpack, ...) and a proper toolset for your Java application (Maven, Gradle, ...).
Webjars is nice for simple projects but it doesn't exactly replace npm for actual js dependency management
What advantages does Yarn have nowadays? The lock-file system has been implemented now by npm as well, so what other benefits does Yarn have that npm doesn't?
Nowadays, you wouldn't even use bower or grunt.
To be honest, I've never had any "hell"-like issues with NPM apart from the speed, which Yarn definitely has an edge on. The OP didn't elaborate on what specific issues NPM has, so my "nowadays" remark wasn't meant to be taken too seriously. 
Make something!!! I recommend a facebook game. Its really *really* hard to make even the simplest facebook game. But , if you can do it, you're there!
Oracle certs are hardly a good measure of proficiency or effectiveness with Java. I've actually heard of people that they throw out resumes with oracle certs because they are so useless, though most recruiters will probably just ignore the cert. Either way, preparing for and passing those certs will not help with actual programming.
I partially agree. There is a lot to know for programming but those knowledge are not related to java. For example, design pattern or solid principles help to create code that can be easily understood and modified. But yeah someone that does not know those concept even with the best knowledge about the language would not be expert in my mind. That's really a subjective question : ask 15 dev "what is a good dev?" And you end up with 15 definitions :)
don't use it! it's wrong.
Line 4 compile error. unexpected ')'.
Correct me if I’m wrong. I think it’s better to use DDD pattern instead of @Formula @Where and so on annotations. Of course in huge apps is impossible to change whole app just like that, but using @Formula won’t improve anything in this case.
You can't store a null inside an Optional, so returning a null from map should be forbidden. However i believe map allows it and converts the null to an empty Optional. This sounds like a nice feature but unfortunately it means Optional is no longer a functor. To put it another way, it's counter-intuitive. A more idiomatic way to do this would be to use flatMap, or just split out the operations: return Optional.ofNullable(bar) .filter(s -&gt; !s.isEmpty()) .map(s -&gt; s.charAt(0));
Yeah. That's really neat. We now have an additional state. So we have 'null' and 'really null'! ^(/s just in case)
It's really nice for simple SPA's when you for example want to demonstrate the output of your REST api. But for a 'real' integrated workflow you're going to need all the FE tooling as well. My last few FE apps were Angular 4 based and there you can just use the NG CLI. You can also quite easily integrated this into your maven / gradle build. 
please no `ICake` please :*(
Is your site blacklisted by Reddit, hence then need to post these as text submissions (which don't even contain a working link) instead of adding them as link submissions?
Pure **spam site**.
&gt; How do I tell the secondary build job to use the new version of the artifact without changing the POM? - You either use snapshots, but this is not for production or - you don't This seems easy in your own environment, but imaging you are using a library version 1.0.0 and suddenly they release a breaking change with 2.0.0. Suddenly, you set the system to automatically include that library without your knowledge? It is better to inform the owner/team of second Jenkins that a new version is out and that they should update. You can even fail builds if the new versions are required. 
It's not about the language or the platform, it's about what you're trying to develop and how. There's no such thing as a "java professional". You need to know stuff that's common for all programming languages and platforms. A little bit of stuff specific to JVM, yes. Are you going to build a non-blocking app? Then you have to know how to deal with CompletableFuture-s. Or RxJava (which isn't java). Or Kotlin coroutines (which isn't java). Or some Java coroutines impl (which isn't part of the platform, again). Are you going to have to write code for servlets? Then you have to know Servlets. EJB? Same. But what if it's a custom http server on top of Netty? Maybe Spring-beans? Not part of the platform, again. JMS? Cool, but maybe you're going to work with MQ outside of the JMS spec, what then? So when I'm hiring someone on my team, it's never about the language or the platform SDK or a specific framework. It's about understanding the underlying concepts. - Do you know what AOP is? What are its good sides? Bad sides? - Any idea how TCP is different from UDP? - What is a "session" in web development and how many ways can you come up with to implement it? - What's SSL? Why would you need it? - What's a resource pool and why would you use one? - What's a transaction? - What's wrong with "synchronized" block? - So your http service accepts connections but clients never receive a reply, what do you do to find the problem? - What's non-blocking IO? - What's wrong with this code: throw new ConnectException("Connection timed out") etc.
There's also `Arrays.stream(array)` and the cycle is complete :)
For me its the sane default values compared to dbcp2.
Could you elaborate it a little bit? What specific default values are you referring to? 
eg The default value for `maxOpenPreparedStatements` is `unlimited`. Nice gotcha if you didn't notice this on first sight and enabled `poolPreparedStatements`.
Since connections are reused over and over and being open for a long time, I'd guess there would be lots of statements being cached. Did you eventually run out of memory?
Thought it might be, but was trying to be polite for a change!
So, that is true from a deploy to production stand point. But I'm trying to add in downstream testing of a dependency. Essentially I want to know, via automatic testing, whether upgrading to a new version of a particular dependency will break downstream projects. When the second project gets deployed to production I absolutely expect the team to explicitly declare dependencies, however for testing purposes that isn't very helpful. Again, I'd like to stress that I'm not asking for wildcard dependency declaration in Production, but rather how to manage downstream testing of the first jenkins artifacts.
[removed]
Since it's not been said - stuff like this is best going in /r/javahelp
Yeow. That was a nice one.
What is the purpose of the second Jenkins build? Is it just to test whether a downstream dependency works with the package produced by the first build? If so, what package is being deployed in the production stage?
The first Jenkins artifact is being deployed. The second is the downstream build to confirm comparability of the new dependency. The second Jenkins build is a downstream project of the first. So when a new version of the first is built I want Jenkins to build the second so that I can see if there are breaking changes in the new version.
Gah! I'm so embarrassed. Fixed!
You're right, how about `Cakeable` - something that is capable of being baked and consumed as cake.
Ah! And that's cool because it specializes int[] and double[] to produce IntStream and DoubleStream.
Yep, expected a mention of our lord and savior Rust in there. ;-)
Generally, your downstream applications provide you with a test suite to run your application against. This will be your contract and needs to stay active until managed on both sides. 
implements * Consumable * Bakeable * Iced _haha_
I'm not sure I follow your logic on Optional losing its functor-ness when map turns null into Optional.empty(). I suspect that Optional.ofNullable(T) is the method to wrap any value of type T into a monad (return?) and that Optional.of(T) is a convenience wrapper that asserts that the returned Optional .isPresent(). If Optional.ofNullable(null) is Optional.empty() (and Optional.of(null) throws a NPE), then shouldn't it be true that the Optional wrapping null is Optional.empty()? And that therefore a mapping that produces null should produce Optional.empty() when wrapped into the monad? Because I don't see anything wrong with implementing map as `flatMap((item) -&gt; Optional.ofNullable(f(item)))`? 
Good article, but could the title be any worse or click baity? It makes it sound like object oriented programming is dead, when in reality it's just about a very interesting GC bug.
Got very close to it. Received warnings from our monitoring and averted the crash. But who thought this would be a good idea? And that wasn't the first time i was bitten by one of the default values. But lesson learned - HikariCP is working flawlessly.
Seems appropriate in the context of the article. It's more like Chum though since the article itself is more than a pithy bit of meaningless text surrounded by ads. I didn't mind being baited. :)
sounds like a nifty service, but it depends on if you're working on something whose logs can be shared externally like that. For instance most gov contracts this'd get ya fired.
What's Chum?
Friendly bait. Cut up baitfish and blood tossed in the water to attract predator fishes. They get to just eat it but one or more of the bait chunks is attached to a hook. So yeah it's bait but you have a good chance of getting a bite to eat without getting the hook.
A lot of projects are stuck on older versions of java. There may be a way to use the new java 9 multi release jars to alleviate the (mostly imagined)pain of updating to newer java versions. That may be worth covering but currently at work and company internet filter junk insists on breaking the certificate chain when I go to your form for some reason :(
&gt;How many of you have multiple apps in production on the same Tomcat or JBoss server? currently only if the same team's working on the apps and they're fairly related, even then I don't think we have many and it would be prefered to have them split off given time. &gt;Is it better to have only one app per server? Iffy app servers are pretty darn good at handling multiple apps, and managing child nodes across machines. However there is still a risk exposure that someone catastrophically screwed up and did something that will affect an unrelated app if they are both living on the same app server. Less worry of that by having them split.
the post title comes from the phrase "the king is dead, long live the king" - which doesn't mean there is no king (it actually means the opposite). it's actually not a terrible title, just a bit cliche. it's literally talking about a bug where a weakref object was being GC'd before it could be used, and the resolution to prevent (too-early) collection.
If you run windows, run this tool: https://docs.microsoft.com/en-us/sysinternals/downloads/procmon It will show every single system-call happening. A normal windows-machine makes 1000 calls/s when idle (not acceptable at all). If using linux run oprofile. It will do a whole-system profiling (including what is happening inside your kernel). ;)
While that'd be optimal, they currently have about 6 unit tests across 90 applications. I'm working on some of this with baby steps.
Not only than it is faster, but it's correct too, in regards to clearing metadata before returning the Connection to the pool.
I split arrays into three parts. (but I did the Initilization wrong) And there I needed an array of the size 1. 
IntStream, the unholy offspring of boxing and generics.
Maybe you were confused because `[]` is also used for indexing, ie `new char[1]` has one entry you can retrieve with `myArray[0]`
Nice article. But what's the fix? Catch the exception and implement retries?
Your previous code doesn't compile. @jonhanson's example is more concise and easier to read. It's a really good choice if you want a functional solution. Because of the simple case I exposed I find my code easier to read if you have an util class with a isEmpty(@Nullable String) method. return Optional.ofNullable(isEmpty(bar) ? null : bar.charAt(0)); But that is debatable.
Yes, IntelliJ can use any annotations for null checks. There's a list of annotations for each that you can specify in the settings. I believe it includes the Jetbrains annotations and JSR305 annotations by default.
That is the only fix in the client side code. But you could also patch the JDK you use. The authors are maintaining their own compiler, so they have other options as well.
&gt; I'm not sure I follow your logic on Optional losing its functor-ness when map turns null into Optional.empty() Perhaps [this article](https://developer.atlassian.com/blog/2015/08/optional-broken/) by Atlassian can explain it better, just ignore the clickbait title. &gt; I suspect that Optional.ofNullable(T) is the method to wrap any value of type T into a monad (return?) No, the equivalent of monadic return would be Optional.of.
Really? I've made small games with Libgdx yet I don't feel ready at all for an internship as a Java programmer at a company. Maybe I'm underestimating myself but for example I know more or less half the things /u/Wilem82 enumerated.
Okay, so I see that it's impure if g returns null, and f can consume null where Optional.ofNullable(f(g(x))) isPresent(), but Optional.ofNullable(x).map(g).map(f) is not isPresent(). I'm not sure why you think that returning a null from map should be forbidden, because that would also violate that property. I was curious what Atlassian's docs said about it: &gt;[An [Option](https://docs.atlassian.com/fugue-parent/4.3.0/apidocs/io/atlassian/fugue/Option.html) may contain null as needed] if a function is mapped across it returns null, as it is necessary to preserve the Functor composition law. **Note however, that this should be rare as functions that return null is a bad idea anyway.** Note that if a function returns null to indicate optionality, it can be lifted into a partial function and then flat mapped instead. The billion-dollar mistake has already been made. I see Optional as an attempt to start fixing it. Sure, it's wishes and hopes, but what if we just pretend that @Nullable and @NotNull are different types? 
Yep, there is a typo at cha[t]At. [It works after that, though.](https://ideone.com/fHLMvG) I'm glad for jonhanson's answer - I definitely learned a lot more about Optional than I was expecting today! And thank you, arieled91, for tolerating this noobish question. 
https://projectlombok.org/features/NonNull
I thought the article was about value objects.
What happened to 3.5.1?
cancelled
Maven team skip release numbers a lot. They probably deemed it not good enough and just said "skip it"
r/learnjava
In the for loop you have to define your counter and your increment, so you decide for(int q = 1; q &lt; string.length; q = q+1) { // Do stuff here} Create a counter variable, add one to it each time you find what you need using charAt(q). You can say "q" is the value of the position of a given character. 
Brian Goetz proposes it is more readable, as long as you use a good variable name. I don’t know if I buy it, but in practice I don’t care because of IDEs. Your proposal seems very bizarre to me. By switching around where the inference is happening, you seem to be confusing the difference between the type of a variable and the class of the assigned instance. This would be a major change in the meaning of existing Java code in a sense. The LHS would then potentially mean two different things. 
Answering your first question: There is no universal way. This was discussed in detail in a [recent issue of Java Magazine](http://www.javamagazine.mozaicreader.com/MayJune2017/Default/3/0/3631981#&amp;pageSet=3&amp;page=0). Different frameworks use different annotations. And some frameworks that use the same syntax enforce the rules differently. While your remaining questions are focused on IDEs, don't forget that if you run the code through a code checker/bug hunter in your CD pipeline, the differences will pop up there too. *Edited for clarity
3+5+1 = 9. There was no Windows 9. The last Java version to use sequential version numbers was 9. Illuminati confirmed. ^/s
/r/domyhomework
Article editor here. Thanks for reading and sorry if our little word play attempt in the title did not work out as we intended - we are not native English speakers. I can only hope that you have found the content better from the language use standpoint, and, more importantly, worth your time.
That, or move over to Java 9 (with its own set of yet-unknown issues).
I was confused because the first slot is the 0th slot, but to initialize an array with only a single slot you must type char[1] 
Content was excellent, definitely worth my time. Thanks for posting, even though the article title confused me :-).
Java already is doing inference on the RHS, e.g. List&lt;String&gt; list = new ArrayList&lt;&gt;(); My proposal is expanding that instead of also adding inference on the LHS. &gt; This would be a major change in the meaning of existing Java code in a sense. The LHS would then potentially mean two different things. I don't follow. Can you give an example? How does it change meaning of existing code?
Why not? What are the downsides?
tldr; this guys talk is about his own personal coding philosophy only adding to more bikeshedding. So, I'll do more bikeshedding... While he makes a few good points, I think this talk shows mostly over exaggerated examples and its just his views on how to write code. If you don't want developers to use method chaining then you shouldn't have released the streams api. This style of coding is addictive and I have found my code to be so much more understandable and I have gained more confidence in the quality which is why I often abuse optional too or just generally try chain things together. I have found `Optional` to really clean up code to avoid `if else hell` when things start getting complex and it often takes away the stress of handling null all the time when streams and optionals will just do it automatically once you get in the groove. I think he is being way over the top when he claims he needs to write out a state diagram to understand the `BigDecimal` example. His proposed solution is essentially just repeating what he said not to do earlier in the talk and call `isPresent` before doing the next operation. His solution is clearly ugly code and if you're going to do this just use `BigDecimal` with null checks and do your typical pre java 8 crap. The thing is, all of this is a social/psychological issue. I guarentee we will see some oracle big shot standing up delivering the same talk in a few years when pattern matching comes out or any new java feature. Developers will use it everywhere because java developers are starved of new language features so anything new we tend to just use everywhere because thats all we'll get for years and get frustrated at writing code in the dark ages vs stuff that is in other languages already. Would hate to get this guys opinion of putting [vavr](http://www.vavr.io/) into codebases or using kotlin. He is clearly against method chaining and this talk is basically just enforcing his views on coding style. 
I said facebook game!.... Which involves. * Database to store list of players in your application. * REST calls to facebook to return names of facebook users * Authentication OATH * SSL - Facebook need your app to be run on a secure server. I use 'Lets Encrypt' to secure my own for nothing. * Database locking and transactions when more than one player attempts to update same table * Performance - when 100 or so people hitting your application on a single server concurrently, if your code is bad it will slow * Cloud deployment vs Stand alone server. Start with a PC at the end of your ADSL line.... and once up and running, look at ways of moving it to AWS Free Tier. The LibGDX is quite possibly be the easy bit! So try it... Try to get a facebook game up and running, with a simple LibGDX front end. Actually, to begin with, just get a facebook application to say 'Hello World, Lunarpeak' when you access it. You will get stuck! but by muddling through and getting it all working, you'll learn far more than reading anything in a book... EDIT: Looking what Wilem82 wrote....you will learn the answers to those questions/concepts he mentions, as a matter of course. 
He didn't say "don't use method chaining", he said "don't use `Optional` just for method chaining when null checks are more appropriate". Especially when you're unwrapping the value at the end of the chain. And he gave a very good reason for that, namely that you're creating an object when none is needed.
I understand that and agree its wasting memory to do it for a single value only. I just feel like his talk exaggerated a lot and cherry picked examples that don't showcase the real benefit of solving something through a stream pipeline. If you use vavr or something like that theres even more methods on their version of Optional that makes life even easier and encourages the chaining mindset. When the BigDecimal example was shown he gave some lame excuse as to why to avoid it and instead opted to provide an ugly as hell solution that abuses optionals anyway... 
His reasoning there was that it was overly complicated. The second example most definitely was. Just because you can be clever doesn't mean you should.
WebJars is nice because you, as a Java developer, can add a dependency to a client side resource (css, javascript) in a standard way. It's not a difference between how you add slf4j (java library) as dependency and "bootstrap". Your dependencies manager (for example Maven) resolves for you the all dependencies of bootstrap (jquery). Because I think that WebJars is an important concept, [Pippo](http://www.pippo.ro) web framework comes with support for WebJars since the first version. Below I will present you a code snippet (for more details see http://www.pippo.ro/doc/static-files.html ): The html template page (freemarker engine) contains a head section like: &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta content="IE=edge" http-equiv="X-UA-Compatible"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;link href="${webjarsAt('bootstrap/css/bootstrap.min.css')}" rel="stylesheet"&gt; &lt;link href="${webjarsAt('font-awesome/css/font-awesome.min.css')}" rel="stylesheet"&gt; &lt;/head&gt; Sure in your pom.xml file (if you use Maven) you must declare the dependencies to these webjars: &lt;!-- Webjars --&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;bootstrap&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;font-awesome&lt;/artifactId&gt; &lt;version&gt;4.2.0&lt;/version&gt; &lt;/dependency&gt; 
I've been playing around with what might be a good workflow for this is. I quite like starting with a maven multi-module project, that has separate modules for the Frontend and Backend. Then using a modern FE workflow in the FE module, but have maven orchestrating everything. So while developing the FE you can use whatever npm + webpack/grunt/gulp and use the same tools to create a dest folder with all the deployment assets. That means the maven module can then produce a webjar which only contains the contents of the dest. The BE code that needs to host the FE, can then just include the FE webjar. Seems to work really well and means with the help of the frontend-maven-plugin, I can go to the root of my project and run one maven command to build, test, and package everything. 
Thank you this is very useful. 
Is this a question or a statement? 
Cancelled due to issues with 2 tickets per the mailing list
From a technical standpoint, it's fine. From a functional programming purity standpoint, it's an abomination - your functions end up with side effects. It's really the sort of thing you shouldn't do unless you REALLY have a good reason. 99.99% of the time, it would be a sign of overall design problems for your application.
It sounds fantastic! Just some syntax info. Your headline is a little bit confusing. Either use: 'How Kotlin's "@Deprecated" Relieves Pain of Colossal Refactoring.' or 'How is Kotlin’s “@Deprecated” Relieving Pain of Colossal Refactoring?' The way you made the headline right now is a statement with a questionmark after it.
Sorry I didn’t mean to suggest it actually changes the meaning of existing code in a way that would make it run differently. I just mean that throughout the history of Java, the LHS has been for the type, or interface, while the RHS has been for the actual implementation. This would change that, and I think that creates a major cognitive burden. 
Before you keep going on your **self-promotion spree** you need to read the **reddit rules** [**What constitutes spam? Am I a spammer?**](https://reddit.zendesk.com/hc/en-us/articles/204536499-What-constitutes-spam-Am-I-a-spammer-) Currently, your **sole contributions** to reddit consist of **self promotion**. This is against the **reddit spamming** policy. Limited self-promotion is acceptable but not excessive self promotion as you are doing. We want **active participants** in the community, not **self-promoters**. We want people who take part in discussions without constant self-promotion. If you don't want to participate, you are not welcome here.
Glad to see they fixed the non-ASCII char in windows console issue. Every time I build one of our projects I think I broke something because the console output looks like I tried to open it in wordpad: � foo�b � �ar
If I do the trick only function-locally, it's fine, right? I mean I only use it when I want to return a value which is evaluated in a lambda - I need some kind of Holder&lt;T&gt; which is final, but it's value isn't. A T[1] is a pragmatic way to do this.
Are you referring to something like RxJava? If so I don't think RxJava will just go away, in fact they've refactored a lot of that library for Java 9 and they're building things on top of flow. Also libraries like RxJava do a lot more such as they're built in async/multi threading capabilities that would be tricky to implement yourself with flow so these libraries will still have a purpose but they're gonna be built on top of flow instead of building out flow like classes on their own. 
That wouldn't change at all. The fact is though that when doing derivation on either side, the declared type and the runtime type of that variable will be the same. Also when doing it in the way proposed by JEP 386 (var list = new ArrayList&lt;String&gt;();) the type of list will be ArrayList, not List. But I think it makes more sense (and is in line with the existing type inference in Java) to drive inference from the side of what you *want* the variable to be instead of driving it from the side of some value provided to you.
All they did was fix some issues.
You could also consider using an [AtomicReference&lt;T&gt;](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicReference.html) as your "Holder", especially if you're dealing with a lambda running concurrently. Even single-threaded, I would find that clearer than using a single-value array. Personal preference I suppose.
Yes
Oh, good, another JavaScript build tool. Should I use this with bower? Gulp? Grunt? Webpack? Something else? I can't keep up.
I love how coders generalize their own requirements to the whole world. Not everybody is working on an app that needs CDN, separate URLs for API. For those of us writing crud apps used only internally where we work, all in one is a reasonable choice.
Both can use any annotations to detect nulls. However, you can find some inconsistencies between them. 
&gt; JSON is a pretty versatile data format. It's human readable The article starts out calling JSON human readable, what kind of nonsense is that? There is nothing human readable about JSON, sure if you have just a few non-nested properties it is readable. However, once you even have one nested level, you are totally screwed, if you use arrays good luck reading that! To prove my point, how quickly can you find how many comments this /r/java reddit post from a couple of days ago has? And how long does it take you to find the text of the 2nd comment: https://www.reddit.com/r/java/comments/79mymr.json Don't even get me started about being human writable, no mere mortal can write JSON. 
"Bikeshed" is very quickly becoming my least favorite overused word. I had never even heard of it until about a year ago. Now I see it every where and every programming blogger seems to love nothing better than using this word.
No, I'm not referring to something like RxJava or Reactor, my post was only related to the Reactive Streams API as a foundation for such frameworks. Since the JDK 9 incluces the exact same interfaces, but in a different package, I was wondering whether the JDK interfaces will replace the Reactive Streams interfaces eventually.
Well they bumped only the Bugfix version number, so what did you expect?
Do you have a proposal of something better? I'd say JSON beats XML, Protobuff, CSV (if there are nested properties). &gt; To prove my point, how quickly can you find how many comments this /r/java reddit post from a couple of days ago has? And how long does it take you to find the text of the 2nd comment: Is this really a fair argument? Pick up a dictionary and lookup a word how fast can you do that without flipping through the pages. How about tell me how many words it has starting with the letter A. Does this mean dictionaries are not readable? &gt; Don't even get me started about being human writable, no mere mortal can write JSON. I often write JSON by hand and don't find it very difficult other than maybe escaping? But theres what like two whole escaping rules and that's it? Happy to hear what you find more readable than JSON.
Well, I think we all expected they'd be cool like Facebook—release new features and to heck with fixing existing issues!
The question is, does that say anything Flatbuffers really or about your knowledge?
name 5 popular projects using it.
But.....Gradle's been at version 4.0 ! - come on Maven, pull your socks up.
I personally prefer to just use for example MockMvc to write assertions or responses. That or just deserialise to a pojo and check that. Less work and much less error prone than comparing blobs to JSON to other blobs of JSON.
&gt; Do you have a proposal of something better? Um. Yaml?
Yup, the sane default values, the fact that Brett EXPLAINS these default values and also the codebase. Ever had a look at the code base, and then at the one from dbcp? Enjoy :D
If it's the right pragmatic solution for your case, then it's certainly fine. Not a great habit or first approach to consider, but when it's right for you it's right for you. /u/I_am_Black_BoX has a good suggestion re: using an AtomicReference to at least make things more readable. The next person to read that code (even if just "future you") would likely appreciate that.
It seems that java.lang.Runtime.Version developer didn't watch the presentation ;)
While AtomicReference is part of the Runtime, I feel like the guy who read it later on would wonder why it would need to be atomic for about just as long as why that one element array is there. Before I learned about the array trick I always put a little Holder&lt;T&gt; class into the project. This takes about 30 seconds, and would still be the best solution from a readability standpoint, but is not directly copyable to another project. Well, as I said, I only use it for this one usecase, and I think it's the best trade off for that. 
yml is great for config files. I don't see many web services using it as a response format.
Some advice to you. Your computer is probably chock full of porn viruses and those viruses are fucking your computer, my young friend. Stop fapping and spend more time on the command line. Install Linux and learn to use it. Mastering linux concepts at a young age will set you way ahead of your peers and set you up for success in college. If you really want to code, write code. Read code. Read and write code. Asking questions will not teach you how to code (although effective googling is seriously an important coding skill). You must code to know how to code. Go write some code, fail, learn, fail, learn etc repeat until you're old. Somewhere along that path, your IntelliJ problems will probably sort themselves out :)
True, I just answered the question :)
Of course. I wouldn't use this for testing endpoints at all. The unit tests were to test that this feature itself worked. The use case mentioned was to generate a md5 checkusm of an arbitrary java object. We were using an objects hash code to generate an ETag version for certain REST endpoints. However hash codes are not guaranteed to be the same across JVM's or even different JVM executions and we ran into some issues. This isn't necessarily the approach I would personally pick but it's what I was tasked with. I have also thought about using this method to quickly check if an object needs to be updated or not. Possibly across data sources. It was interesting seeing how much more complicated it turned out to be than expected.
# Great work team! I've incorporated everyone's contributions into our initial release: [GitHub - BytecodeBakery](https://github.com/matt-9000/BytecodeBakery "LOL") u/thedovahkiin24 - instruct your baker to clone the repo to their local kitchen. It will provide him/her with everything needed to launch a successful cake. &gt; git clone https://github.com/matt-9000/BytecodeBakery I'm glad to say we were on time, on budget and met all of the original requirements as well as the scope creep of Birthday Cake functionality. Also reached our stretch goals of object composition and unit testing. Excellent work u/4stringking , u/thatsIch , u/jacobbeasley , u/deadlock_jones and u/_INTER_ ! This has all been good fun. And apparently I felt the need to brush up on my Java this week. :) 
I think this was their intent, to provide an API with a readily available implementation.
AFAIK the Java 9 Flow API *is* the Reactive Streams API - just in a different package. The idea is yes, just renaming the packages that you're using should be enough to migrate.
Constructor injection is not incompatible with try-with-resources: public class HelloWorldWriter { public HelloWorldWriter(Supplier&lt;Writer&gt; writerSupplier) { this.writerSupplier = writerSupplier; } void write() { try (Writer writer = this.writerSupplier.get()) { writer.write("Hello World!\n"); } catch(IOException ex) { System.err.println("Problem writing: " + ex.getMessage()); } } } public class Main { public static void main(String[] args) { new HelloWorldWriter(() -&gt; { Path file = Paths.get("/tmp/hello-world.txt"); Charset charset = Charset.forName("US-ASCII"); return Files.newBufferedWriter(file, charset); }).write(); } } You don't even need mocks or fakes to test this: @Test public void should_write_hello_world() { final StringWriter sw = new StringWriter(); new HelloWorldWriter(() -&gt; sw).write(); assertEquals("Hello World!\n", sw.toString()); } The reason why this isn't a good candidate for mocking is that you don't own `Writer`, and because it is part of the JDK, there are plenty of common implementations you can directly instantiate. A better candidate for mocking would be something like a boundary protocol for the system under test. For example, using mocks to drive the development of an interface like the JSch [keyboard-interactive SSH authentication protocol](https://epaul.github.io/jsch-documentation/javadoc/com/jcraft/jsch/UserInfo.html). Or, the always popular repository interface.
JavaFX is your best bet. You can find out more [here](https://docs.oracle.com/javase/8/javafx/graphics-tutorial/javafx-3d-graphics.htm#JFXGR256). It supports 3D "out of the box". There is also a [video](https://www.youtube.com/watch?v=ZVPIBkDgZV4) that demonstrates Rubik's Cube in JavaFX.
Google is your friend, mate 😊
Just a guess: the serialization in Java is quite old with JDK 1.1 and due to backward compatibility, they could not change much of the underlying implementation to optimize it. On the other hand: just profile both and take a look at it yourself. It is always easy to believe statements by others.
&gt; And he gave a very good reason for that, namely that you're creating an object when none is needed. That's probably not going to be an issue forever though, I'm pretty sure Optional was designed with evolution to value type implementation via Valhalla in mind. It might be a good reason to avoid Optional in the short term in cases where the choice is purely an implementation detail, but I certainly don't think it's a good reason to constrain long-term API decisions wrt return types.
The meaning is also morphing from "pedantic due to lack of auxiliary knowledge" to simply meaning "pedantic". 
+1 for JavaFX, sadly no custom shader support, but yeah just works and if fairly easy to get to grips with...
I would not really call it slow, Java's serialization mechanism allows for easy conversion of objects to a serialized format without thinking about it too much. Every field of your object is individually stored in a binary format. When you want performance you might want to think a bit better at owhat and how you want to format these fields, for instance, you can store multiple fields in a single byte. Which would result in a smaller footprint. 
They might be coming for you now, be careful.
If you write an article like that, please let me know! I"m always interested in what other developers are doing!
&gt; That's probably not going to be an issue forever though, I'm pretty sure Optional was designed with evolution to value type implementation via Valhalla in mind. 1. It is; `Optional` is declared to be "value-based", and to rely on reference semantics is undefined behaviour. 1. The *only* thing we *know* about Valhalla is that it wasn't in Java 9. It may still turn out to be nothing. We just all hope for it to succeed because it would be wonderful. In the interim, `Optional` is still heap allocated and incurs an extra pointer indirection.
I don't have experience with G1GC, but this guide/reference looks like it could help. https://docs.oracle.com/javase/9/gctuning/garbage-first-garbage-collector.htm , my first thought is to reduce the maximum threads and max pause times.
And Chrome is on version 61 or whatever, so what's your point? 
For writability XML is far more human writable than JSON. For readability when neither XML or JSON are pretty printed readability is about the same. If both are pretty printed, XML is far more readable than JSON and nesting is far easier to follow. I am not disparaging JSON I just think it is far-fetched to call JSON "human readable". It was quite clearly designed for machine-to-machine communication.
- Maven now has an animated logo - all previous build are incompatible and must be recreated - Xoxo !
^^kotlin?
&gt; I am not disparaging JSON I just think it is far-fetched to call JSON "human readable". It was quite clearly designed for machine-to-machine communication. http://www.json.org/ might disagree :) &gt; JSON (JavaScript Object Notation) is a lightweight data-interchange format. It is easy for humans to read and write. Maybe you are using bad JSON formatters? My nested objects and arrays format pretty nicely even for large complex objects. Obviously that doesn't work forever but in most cases its pretty easy to follow at least for me. For arrays if its short it will inline. If its an array of objects each will get its own line with proper indenting. Either way, not really the point of the article. I can change it to say "fairly readable"? 
I've done some profiling on that at $work a while ago (java 7) and the biggest performance bottleneck I found affected classes which did not explicitly declare a serialVersionUID, and after that was the heavy reliance on reflection. The uid which is computed by the ObjectStream classes for each class which doesn't explicitly define one is created using a digest over the class structure (field names and other stuff), which is quite slow. The uid of the last class gets cached so this is not apparent if you benchmark the serialization of a single type. The ObjectStream also caches most slow things so benchmarking using a single stream tends to distort results, as you typically don't reuse these when processing different serialized blobs. We ended up adding unit tests to ensure all our serialized stuff defined uids, and used Externalizable to mitigate reflection bottlenecks on the most heavily used objects. Externalization also helped improve the signal to noise ratio of serialization, which is quite bad for small object graphs due to the included classdesc of each serialized type. IIRC serializing a single Integer produces ~40 bytes for 4 bytes of actual data, enums are also quite bad in this regard.
Yes, it was discussed in the video. That's why `Optional` isn't `Serializable`. But even then, it's more typing for very little benefit. 
The phrase dates from 1999. http://phk.freebsd.dk/sagas/bikeshed.html I suspect you're experiencing the [frequency illusion](https://rationalwiki.org/wiki/Frequency_illusion) (also known as the Baader-Meinhof phenomenon)
At the risk of being pedantic, it's never meant that. It's talking about the phenomenon of people spending most of their time talking about trivial aspects of a design rather than the important parts. "What colour should we paint the bike shed next to the nuclear power station" The video was possibly badly titled, because he admittedly only discussed any bikeshedding (regarding making `Optional` not `Serializeable`) for a tiny part of it and spent most of the video on various anti-patterns. 
So a few pieces of this article went over my head. I have a vague of idea of what they mean. However the main question the article posits seems...answered. Lombok and gson seem to pretty much have this shit solved when used in tandem. They mention every method @Data generates and didn't mention Lombok once. Members they seem to have a problem with writing: .equals: lombok compares the fields. I believe an instance where that isn't enough is quite rare. .toString: Lombok does this well enough. I guess this is just a debuggability/logging issue primarily anyways. .hashcode: there may be some complexity here I'm unaware of In my humble opinion, solving this issue just requires Java to "take inspiration from" a third party lib: lombok. "Without rehashing the properties debate, one fundamental objection to automating JavaBean-style field accessors is that it would take what is at best a questionable (and certainly overused) API naming convention and burn it into the language." That line lost me. That's not questionable, it's so common it might as well be in an RFC! Burning it into the language would be *fantastic*. I would (hopefully) never see shit like GetField again. 
Covering all the ways Annotations are applied (and interpreted) might be tricky. There are some that can be applied to Fields, Methods or constructor arguments but must be applied in only one of those places (eg DI). It feels more like we need a property notation that is converted to fields, getters and setters (as per language conventions). &amp;nbsp; Something with this expressiveness (OTTOMH)... It would want more java-like syntax though... public data Foo { @AnnotationX String name { @AnnotationY get @AnnotationZ set } This then allows you to declare mutability, annotations per aspect of the property and retain the concise form for immutable non-annotated data-classes. public data Foo { String name };
That method naming convention definitely deserves to die, it's redundant and stupid. I'm glad Java's architect's understand that.
* One of the main advantages of data classes is construction injection and immutability, so getters and setters should absolutely NOT be included. (there should be a means to hide fields to the outside though) * Plain composition of data classes is preferable to magical annotations.
GC logs or it didn't happen!
I first heard the term years ago, although I've only really started to see it being used more commonly recently. And I must agree that most uses seem to be abusing the term. The other overused phrase/term I keep hearing recently is [munge](https://en.wikipedia.org/wiki/Mung_(computer_term\)). It might just be due to the people I happen to work with, or something to do with my location.
**Mung (computer term)** Mung or munge is computer jargon for a series of potentially destructive or irrevocable changes to a piece of data or a file. It is sometimes used for vague data transformation steps that are not yet clear to the speaker. Common munging operations include removing punctuation or html tags, data parsing, filtering, and transformation. The term was coined in 1958 in the Tech Model Railroad Club at the Massachusetts Institute of Technology. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
I'm sad he isn't more assertive. The Java language can't keep catering to all the old school, verbose, imperative frameworks and devs in the community. They need to be left behind or the language will be.
&gt;I'm sad [Here's a picture/gif of a cat,](http://random.cat/i/kittle_whiskey.jpg) hopefully it'll cheer you up :). ___ I am a bot. use !unsubscribetosadcat for me to ignore you.
&gt; Developers will use it everywhere because java developers are starved of new language features so anything new we tend to just use everywhere because thats all we'll get for years and get frustrated at writing code in the dark ages vs stuff that is in other languages already. Having made the switch to Scala, it's nicer here. Also, Option is far more useful in Scala, but that's perhaps topic-drift. If pattern-matching and a few similar features started making their way into Java, it wouldn't shock me to see null being treated as bad code-smell in Java. What little of the talk I did watch was simply groan-worthy. I feel no need to argue this talk, any more than someone saying "addition is bad" or "Sets are bad." Obviously they can be misused I really don't feel the need to sit through an hour long talk by someone who doesn't seem to have done his homework. &gt; His proposed solution is essentially just repeating what he said not to do earlier in the talk and call isPresent before doing the next operation. Please. Kill. Me.
&gt; Especially when you're unwrapping the value at the end of the chain. From a FP perspective, starting with and/or ending with a null is completely missing the point of Optional, at which point you probably shouldn't be using Optional anyway. 
Again, I'm not suggesting it would change real behavior. Obviously, the type of `var list = new ArrayList&lt;String&gt;()` has to be `ArrayList`. But if you look at how Java tends to be written, with an interface on the LHS and implementation on the RHS, a la `List&lt;String&gt; list = new ArrayList&lt;&gt;()`, it is way easier to get to `var list = new ArrayList&lt;String&gt;()` than it is to get to `ArrayList&lt;String&gt; = new &lt;&gt;`. What you're saying makes some sense, I just think it's too far from what Java has come to be.
That cat does not look very cheerful.
I added a screenshot of Visual GC using VisualVM while doing normal daily usage with Eclipse. Eclipse becomes unresponsive for 15-30 seconds and during this time I notice the G1 Evacuation Pause along with several collections of Eden spaces. If I switch the garbage collector to ParallelGC I can't replicate the issue.
I just really hope that true immutability is either the default, or the only option. By true immutability, I mean that all fields are final, all fields are primitive, String, or other Data classes. I want a compiler error if someone breaks immutability of data classes. It would even be nice if that could be enforced in perpetuity. If a data class is immutable, it can safely be shared across threads. If someone violates that immutability guarantee, code should break everywhere that class is used, because it is no longer safe to use in the ways that it has been used.
They are planning on making value types immutable.
You're right, but a big positive about good, conventional Java is that it's method and class names are extremely predictable. You can figure out much of how a class works just by looking at its method names and their types. I would rather not give that up.
What naming convention..the getField/isField convention? 
They can pry my @Data from my cold, dead, curled fingers.
I don't see why there are people that want data classes so badly. I've never felt like I needed to write a "data" class where it is simple enough that it only has getters/setters but important enough that the fields cant just be made public and the class nested in another one. I don't think I'll like seeing lots of strange getter/setter data class mumbo jumbo. I would rather that Java just "owns" its verbosity, especially since people who view it as verbose right now and don't use it probably will keep the same opinion even if it becomes outdated. I like Java feels very "what you see is what you get", without too much hidden code generation.
That would then necessitate immutable collections in the standard library, or mean data classes cannot have collection fields, neither of which sounds likely
Tuple Tommy here. I like them for their conciseness.
It depends, what platform are you writing code for? I've seen Google Maps style maps implemented in Swing, including the ability to pull the tiles from various sources [Google Maps, OpenStreetMap, etc]. It was just a Swing component so it could be thrown in any Swing/JavaFX desktop app. I don't believe it was open source, however.
Yeah, there is quite a lot of code generation in Java, but most of it is pretty simple under the hood (with the exception of lambda expressions). Generating entire fields and methods for classes just seems a bit much.
You could implement a web browser in your application and use that to display the map. Not done it myself but a quick Google led me to jxbrowser. https://www.teamdev.com/jxbrowser
How would you do collections? Arrays are mutable so you can't use them as a backing store, you'd have to use expensive data structures like linked lists and trees. Yes, Valhalla introduces immutable arrays but this is not part of this proposal.
javac already generates lots of synthetic methods, mostly bridges. In the end it's mostly irrelevant where the code is "generated", javac or the jit, so I don't really see an issue with that. Data classes are very common in DDD and FP where you decouple logic from data. In a DDD/FP code base a majority of your data will be held in such data classes. I'd argue that getters are still a good idea for that, be it for convention or for other reasons such as proxying, but even if you like to use public fields everywhere you still need eq/hc/toString.
ArrayList but no add Method I would guess
&gt; but most of it is pretty simple under the hood Again, explain enums :) &gt; I had no idea about covariant return types though, I learned something new today! Yeah, they were a requirement to implement generics and proved useful otherwise.
No, it "standardises" it. See the `Flow` types more as an SPI for vendors and products like RxJava rather than an end-user facing API
But how would you enforce that? It's neither primitive nor a data class (and it can't be with those requirements).
**Sidebar** + **Do not post tutorials here** Post removed
&gt; Is it possible to show a map like google maps on java? Yes
Panama and frozen arrays?
The obvious keyword for declaring mutability would be `final` which would imply it was mutable by default. A new keyword would need to be introduced. `volatile` would be too confusing in my opinion.
This cat looks like it has drowned its pain in alcohol.
Yes, at least prepending "get" in front of an accessor's name. I can accept "is" since it often makes sense in the context of a boolean, but that should also be purely optional.
There's no reason why a member variable access syntax doesn't go via an auto generated getter, so that you could explicitly define it later if required. This is basically what people mean when they talk about adding properties to Java. Check out how they work in C#.
I don't think they were implying that data classes should be done via annotations. They were discussing how you would define annotations on different parts of the class as you do now. How does annotations interact with the proposal?
It would at least make things like Array.length (a read-only property) seem a bit more consistent with the rest of the language. I'm not sure I'm that sold on making Java that much more terse when I'm mostly just typing a couple of letters, hitting ctrl+space, enter, alt+enter and letting intellij figure out the rest. I do love Lombok for giving me a sensible way to do field generation though tbh, even in modern IDEs it still requires mouse clicks to do the generation, usually, unless you want to type them out (great fun if you somehow have more than 10 fields).
As already stated, you haven't specified what platform you'd like this to run on. For the desktop, you can definitely do something like this in JavaFX. Use a WebView and then add a node for your car on top.
&gt; Yes, Valhalla introduces immutable arrays but this is not part of this proposal.
Yes, kotlin does this as well, but that is very much out of scope for this proposal.
The new collection factories are immutable. They were released in Java 9.
Yes, but they do not fulfill /u/cutterslade's requirements for true immutability.
Nah there are uses for mutability. Immutable by default would be nice but there's very little value in requiring it imo.
It’s a step in that direction, at least.
Yeah I think you missed a lot of it. He made that whole big deal about how the primary issue isn't reducing boilerplate for a reason. Lombok does not provide destructuring, which is a **huge** part of this imo. Check out this exploration of pattern matching for more info on this: http://cr.openjdk.java.net/~briangoetz/amber/pattern-match.html I think you missed the point about the getters thing too. Why would burning that into the language be fantastic when---so far as data classes are concerned---you could simply access the field directly? I think that's part of what he was driving at when he was making the case that field encapsulation isn't desirable here. And on the point of field encapsulation, take gson, since you mentioned it. Gson already breaks encapsulation, and it does so in ways which can violate the contracts of a class. For a data-class-based system this wouldn't be a problem, we can guarantee that these behaviours will be safe and predictable.
Could you please let me know on what basis you consider this is tutorial, I see so many tutorials in this group 
I don't see a major problem here tbh. Let's say you have an annotation which would be ambiguous between fields and parameters. By default the annotation should be carried onto the generated field only. If you want to annotate the constructor parameters, just provide a manual constructor implementation and annotate there. Same story for getters/setters. That said, I don't think these should necessarily even be generated since the whole point is that *field encapsulation isn't generally desirable for data classes*. Sure, it's a little more verbose, but it's a rare corner case. How often are you going to want to do something like inject dependencies into a simple data carrier class anyway?
Christ, you could almost start calling it "No True Immutability" as no one seems to agree on what is enough. For me, a mutable backing, a read only interface and code review is enough to have the benefits of immutability.
Easy. `mutable`. Or `var`, `val` if you prefer type inference.
On the plus side, I've never seen the different flavors of data classes so clearly explained. Ok the other side, now I understand there are use cases for all of them, so I want them all!
I think the question is better translated as, "is Java SE different to JavaEE?" ~ The short answer is no, because it's still the same old Java. You just have a few web based extras with EE. Google it.
lwgl isn't bad
Well, there were deprecated before they were officially deprecated. Web facing applications are expected to either be "something with HTML 5 and a JS framework" or an app.
First time I hear about it too but it was to be expected. There's no reason to keep the desktop java applications around, regardless on how you launch them.
Java EE is called enterprise edition . So I get confused wether it's for web or enterprise level solution. Anyway thanks , I will google it.
`var` will be added to the language in 18.3!
&gt;*privately mutable* but *publicly immutable*, so you can specify that a field should only be modified internally. That wouldn't be hard to reason about at all
Wat?
When I started Java development, I thought the same thing, that Java EE (what was J2EE at one point) was a completely different setup. The difference is there are components available to handle web requests and responses. Your programming will be the same, but you'll use some extra tools. A lot of the time, frameworks like Spring or Struts are used which wrap a lot of the Java EE functionality and make it easier to start from scratch and add endpoints. Message me if you have any more questions.
So...you either have it in the browser or in an app store...or not at all?
Pick Spring or EE if you're looking for a job. If you go with Spring most people would recommend you use Spring Boot, but since you already know Java I think you should put together a Spring app yourself before relying on the auto-configuration of Spring Boot. If you go with Java EE it's about the same as Spring. Just pick one and start building a small webapp and web service.
I went from 5 years of Java SE to EE and honestly it's all much the same. I'd say the learning curve is also rather shallow
Wait, what? They've been talking about deprecation of Applets since the browsers started dropping support, but the whole time they've been telling people to migrate to WebStart. Dammit. 
Wait, I'm confused; I've heard convincing arguments for avoiding/eliminating getters and setters from code entirely, but I wasn't aware that people had something against the naming conventions. What's wrong with "get"? It's descriptive, and helps to drive in the fact that you're performing a method call as opposed to working directly with private fields.
Uhohh... 3/0 
Dude, you friggin' rock! Thanks!!!
Java is turning into c++: the do everything language, do nothing well.
Yep, I wrote [an article](http://javachannel.org/posts/immutability-in-java/) on this a while back. However, for *compile-time checked* immutability, as the top comment wishes, a read-only interface is not sufficient.
Do nothing well? They're doing this to reduce common boilerplate. And hey, at least there isn't operator overloading.
This might be accurate if you're more familiar with Java than other languages, but isn't it kind of the opposite of Java? I associate speed with functional languages, convenience with modern languages like Kotlin, and easiness with Python. I would associate Java more with a well oiled machine. Its emphasis on abstraction practically ensures that parts play well together, and that they can be replaced with little difficulty.
Thanks. I am going to start watching jsp tutorials tomorrow and if it's all the same then I won't have a hard time learning it 
I think I am going to go with Java EE cause most jobs I saw wants someone who knows Java EE. 
:( I really, really wish we had something like C structs. I don't mind if you can't do bit level manipulation on a value type, but just having something that you know is on the stack is really nice. I get that we have escape analysis and a bunch of HotSpot voodoo, but it isn't transparent _at all_. (And on that note, if anyone knows if there's tooling for writing tests to see if something stops getting optimized with a code change, please share!) I'm curious about how collections will work with this. Hopefully you'll be able to make mutable value types.
Maybe not specifically what you are asking but you can use something like [GeoServer](http://geoserver.org/) which is written in Java.
Your advisor is either out of touch with the real world, or possibly just a fool. Java is the most used programming language and has a heavy presence in enterprise software. Now that doesn't make it the best programming language, but there is no shortage of Java positions. There is also a number of other JVM languages such as Kotlin, Groovy, Scala, Clojure, etc that run on the Java platform and interlope with Java. C# was supposed to be a Java killer, and while C# and .NET have been successful, Java still has higher use. Let's not forget about Android, as Android primary development language is Java, although Kotlin is catching on (but once again it's a JVM language) If your university offers C# you may consider taking that, it is fairly similar to Java, and a great language, with a good job market. 
People just say Java is dead because they don't like it. I don't know about other countries but as far as I know, Java is still used quite a lot in the government and enterprise sectors in Belgium. It's just startups that want to use the "hip" languages. 
I have a few questions( sorry if they sound really stupid. These question are due to my lack of knowledge about Java EE). Q) Is Java server page the only language used for Java EE development ? Q) should I start learning Java EE with frameworks(like struts, spring etc) or without ? Q) is hibernate important for Java EE? 
immutability is really hard. It sounds simple, but, it isn't. What you describe would indeed result in 'true immutable' stuff, except.. you can't retrofit the collections API into these rules, thus any data class you make with your rules in place cannot use any collection APIs (nor arrays!), which, obviously, means this proposal has to either fix that somehow, or it goes into the bin as far too unwieldy to ever consider implementing. But it gets worse. Let's say I make a data class as you described it with your rules, and I add this code to it: public data class ImmutableOrNot { private static final IdentityHashMap&lt;ImmutableOrNot, Integer&gt; sneaky = new IdentityHashMap&lt;&gt;(); public void setFoo(int foo) { sneaky.put(this, foo); } public int getFoo() { return sneaky.getOrDefault(this, 0); } } This class walks, quacks, and looks like a ~duck~ mutable class, but yet it fits the rules of an immutable one. So, is it immutable, or not? Let's just say that your dream of sharing this thing 'safely' across threads is definitely shot. Certainly we can blame the programmer for this atrocity, but the point is, the 'guarantee' that this thing is 'safe' is just not there. That's one of the tricky bits: Instances have an identity, not to mention you can lock on them, so in java everything can be mutable if you want it to be. Another hairy as heck issue: Is java.io.File immutable? There are 3 very interesting issues with this class, each relevant to the immutability issue: 1. `java.io.File` is not final. We can simply state: Hey, okay, so, then, the type simply is not immutable and that is that. Unfortunately, there's like a billion lines of existing java code out there, and they aren't just gonna go in and add a `final` modifier to their API's classes lickety split. Heck, that is technically a backwards incompatible change. Just leaving them out to dry creates a split world: Libraries written before the Great Switch and those after, with multiple maintained versions. It's like the python2 vs. python3 thing and I, for one, think that was a big debacle; a lesson of how not to do it. 2. It has a non-final field; it is marked 'transient', and it serves as a cache, to speed up validity lookups somewhat. It truly has no effect on the state of a j.i.File instance unless you consider the speed at which certain methods respond part of the 'state' (and let's not go there), and thus it is necessary to cater to this need. Do we just allow the programmer to mark a class as 'this is immutable' and then put some sort of `@SuppressWarnings` or other tag onto non-final stuff to let them say: Yeah yeah. I know better, shaddap with your silly errors and just compile it. I think that's the way to go, but, certainly people who like to use words like 'purity' and 'elegance' tend to chafe at something like this. I despise those words and _I_ find this somewhat distasteful, even. 3. Forget all that and just think about files for a second: is it truly immutable? The object is, but it represents a file on disk. If I call .delete() on it, it goes away and I can measure this change with .exists(). Is that not state? Is a thing with changable observable state not mutable by definition? Therefore, even a hypothetical j.i.File class that is final and did not have the cache... is it immutable? But if not how would the compiler ever know? One thing that's a lot simpler to establish is 'side effect free'. It suffers from none of these issues (a method is side effect free; not a type. At best, a type can be considered SEF if all its methods are SEF. You don't even need a final class, presuming that overriding a SEF method requires that method to also be SEF). A method is SEF if it does not change any fields anywhere, and calls only SEF methods. The low-level (native) functionality powering j.i.File's `delete()` method would not be SEF, thus, File.delete would not be SEF either. Messing with an IdentityHashMap as per my code snippet above is calling put, which isn't SEF, thus, the setFoo method isn't SEF. A setFoo method that executes `this.foo = foo;` modified a field and thus is not SEF. compiler-checked SEFness lets you do different things than the notion of immutability, possibly less. My point is: Immutability is impossible to nail down and definitely impossible to have compiler-checked guarantees that actually, you know, guarantee it. SEFness – that at least is doable. 
Value types are simpler, and more powerful than structs. Goetz has talked about this. Value types are different from data classes. Value types will be stored on the stack.
Hype. Every now and then new fancy language or framework appears and you read about it everywhere, new GitHub repositories appear, tons of blog posts published. Meanwhile older languages have already libraries written, blog posts published 1000 times over and not so much repos created. So all OSS metrics shows that old languages are in decline and while new ones are rising. Which is bullshit because such metrics shows only how much new projects were started and new issues tackled - if e.g. Java have all common issues resolved and documented you don't need to write a blog post how you solved it - you can just google existing solution. You are also less likely to create a new exercise project since you already done that. Not to mention those metrics never shows lauguages actually used on production in closed projects with proprietary code. As a result rankings like Tieto are more hype-o-meters that acutal usage metrics. If one doesn't notice that difference it is easy to jump to conclusions. Additionally old languages are less likely to introduce new feature as the need to keep backward compatibilty, make sure that nothing breaks, while bored programmers writing new side projects don't take that as a factor as much as new features to play with. Also haters and marketers. Use your own reason and don't belive everything on the internet ;)
Values Victor checking in. 
Oh, derp. Shows how much I know about modern programming languages. I decided to read more than a few lines of the proposal, and yeah, I completely misunderstood what data classes were. Downloading the presentation now to watch later, thanks for sharing it. 
No problem! The features can be easily confused. I just remember that data classes help in reducing boilerplate.
You start off by saying Java places emphasis on abstraction and that 'parts' can be replaced with little difficulty. I am going to assume you are talking about modularity since you crudely defined the concept. If you were talking about modularity than your very first sentence insinuates that Java isn't fast and thus modularity isn't. I'm sorry you don't get any faster than plug and play coding with the exception of maybe drag and drop like SWIFT. You associate speed with languages like 'Python'. Python is an Interpreted language where Java is a compiled language this means extra overhead is required to execute code in Python. Now you could mitigate and pretty much eliminate interpretation using a language like Cython which converts Python to C and then C to machine code. In large machine code is faster than interpreted languages. Where you are correct is the ease of Python, as you could teach a monkey Python in general. However, this doesn't make it superior only easier to understand. Java can be difficult to understand in rare instances and this is why documentation is fundamental. I shouldn't have to read your code to understand what it is doing. As for my analogy... I think it's spot on... Lastly you assume I lack knowledge regarding languages. The only purpose of such a statement is to attempt to attack my credibility, which assumptive argument. I hope you don't code on assumptions otherwise your coding is likely not robust and riddled with vulnerabilities. 
Java in a nutshell
Agreed, as far as operator overloading: no operator overloading, YET :)
Gosling said it was originally in Oak, but he removed it. The architects are looking into allowing operator overloading for numerical types like `ComplexNumber`, which would make sense. Otherwise, no way.
Not stupid at all. I had the same questions when I first started. Java Server Pages (JSP) is primarily a technology for templating HTML from Java-like code: https://en.wikipedia.org/wiki/JavaServer_Pages. You'll notice a lot of websites have a .jsp extension; that's a .jsp file used with or without a framework that allows you to have Java logic within HTML. I would recommend learning frameworks. Most companies and jobs use frameworks because it speeds up the process of development. Java EE by itself was used before people started developing frameworks to make their lives easier. Most languages depend on frameworks, and Java is no exception. Think of Hibernate as a framework for SQL and interaction with databases. Most languages use something called ORMs. Hibernate is an ORM which essentially allows you to write Java code, and Hibernate converts the code to SQL for the database your using. This is so you don't have to write raw SQL to perform queries. It is important though to understand SQL along with Hibernate or another ORM. https://en.wikipedia.org/wiki/Object-relational_mapping
You can read on some reasons here: https://www.infoworld.com/article/3028134/java/oracles-java-plug-in-move-no-surprise-but-is-javaws-the-answer.html https://stackoverflow.com/questions/46904795/java-web-start-support-in-java-9-and-beyond 
Thank you for the detailed answer. I will follow the links you gave and start learning jsp and spring. ^^
Download eclipse and run it. I imagine the reason it isn't running is because it isn't compiled properly. 
Where are you trying to run this? Terminal window? IDE? Did you compile it? Try your development in Intellij too btw 
IntelliJ will spoil your ass rotten
I'm sorry I offended you, I was trying to make zero personal attacks here. The only assumptions I made were the ones I have regarding the qualities of different languages; my definition of modularity was crudely defined mostly because this whole discussion is super qualitative, and I wanted to just stick with analogies. I didn't associate speed with Python, and I was more referring to code brevity/time taken to write rather than actual speed of execution; on that metric, of course Java is going to win out against everything but lower level languages. I don't consider Java slow, and certainly its modularity helps both with readability and brevity, but you have to admit that Java is a relatively verbose language. I work predominantly in Java, and truly enjoy coding with it, but there are times where writing every class as a JavaBean can become tiresome, despite the shortcuts modern IDEs offer. There is a lot to love about Java, I just would praise plenty of its other virtues before its speed, convenience, and easiness. Also, again, I really don't want to start a fight, I was mostly just curious about your point of view. I see Java in a different light, so your perspective is genuinely interesting to me.
Use of ThreadLocal in new design is a code smell.
I see what you mean, but he did also point out that destructuring would render everything publicly accessible anyway so in a way those semantics might make sense by default. If everything is publicly accessible regardless then all we can reasonably wish control via access modifiers is who is allowed to *modify* a field. It would be a confusing inconsistency though if not handled delicately.
Wow, thanks for the great reply. My short answer is: Yes, Immutability is hard, that's why I want some really smart people to make it easy. Collections and arrays: Yes, immutable types would require immutable arrays at the very least, probably immutable collections built on those. Your nasty static map trick: These immutable classes cannot contain static mutable fields, and cannot reference any external static mutable fields. Files: You make another good point. The simple answer is that the File class is not an immutable data class, so cannot participate in immutable data classes. Realistically though, any time you interact with I/O at all, thread safety is out the window. We could take that argument a step further and say that a String (or nearly any other type) is not truly immutable as it may refer to a file which can change. Split world: Yes, there is a bit of a split world, certainly not as bad as python though. I would say similar to the type safe enum pattern that we still encounter now and then even though enums were introduced more than a decade ago, or the more recent introduction of the java.time package. SuppressWarnings: destroys the possibility of a compiler checked guarantee. Regarding your statement: &gt; Immutability is impossible to nail down and definitely impossible to have compiler-checked guarantees that actually, you know, guarantee it. That is true only if we refuse to give up some flexibility. Brian discussed this in the article. I think I'm willing to give up a lot to get immutability. But it's not a one way street, by getting immutability, we gain a lot too. As a simple example, you mentioned the transient field used to cache a value computed from immutable state. If the object is truly immutable, and references no external, mutable state, we know that any method will always return the same result. This allows the programmer, compiler, or runtime to decide to cache the result. We no longer have to use the cumbersome transient field cache, we can have the runtime implement that for us based on its instrumentation of the code. I'm certainly not suggesting this is an small change. Maybe the data classes proposal discussed in the article is not the right place to do it, heck maybe Java isn't the right place to do it. I think that it's a very valuable potential feature that makes it much easier to write safer cleaner software with less code.
No harm no foul brother, I was simply refuting your statement. Yea you are right Java is certainly verbose and redundant in alot of cases. Some length can certainly be shaved off to decrease coding time. When it comes to verbosity Python wins by miles. Fortunately there are IDEs out there that auto fill and reduce coding time. *Sarcasm* Personally I like the job security that is attached to Java and it's verbose nuances. If we make coding too easy we may lose job security. 
That's the one of the few things that seemed "new" to me but it's really not that far from HTML. One of the other things would be dependency injection.
Are you compiling to a jar fine? If so, you are probably missing a declaration to create a manifest that declares your main class. You can fix this yourself with a simple Google, or you can use IntelliJ/Eclipse/NetBeans as an ide and they'll handle it for you.
If there is no compulsion to use textpad then you could try running the Java app traditional way rather than using fancy IDEs. I would recommend you use native editors of your os. Once Java setup is correctly done, you could use javac compiler and java interpreter to compile and run your code. This would give you more insight into how Java code is executed, how Java interpreter uses classpath to find your classes. In my opinion going traditional way at the start of your learning curve is best way to learn any language
I had this error the other night. I needed to add the CLASS and CLASSPATH environment variables to Windows first. Then in a command prompt terminal I navigated to the directory of my java project. Then, "javac &lt;myProg&gt;.class". Finally, I ran "java -cp . &lt;myProg&gt;". You'll have to open a new command prompt terminal if you update environment variables while it's open. Otherwise the terminal won't see the changes. It works, but I don't like it. I'll be making a runnable jar with a JavaFX though so it won't matter later to be later on.
If they're mutable use a normal class? I don't see the value in introducing data/records/whatever if they're mutable because we already have normal classes which can do all that. If it's just about being able to semantically say "This is a record, therefore" we'll just see haphazard use and anti-patterns of people implementing records where they should have classes, and vice versa. That said, I don't know if a fully immutable record will be particularly useful in very many practical cases. Maybe if it has optimization/performance implications?
JavaFX can do this for you for sure, I've seen a few libraries already. This is probably the most known one: https://github.com/rterp/GMapsFX
Java is far from dead, however some of the newer languages will pay you more for less experience because for whatever reason companies want to develop in the new, shiny thing but there aren't that many developers who know the new, shiny thing.
What do you mean by "Java server page the only language"? I wouldn't recommend learning pure EE with a framework and hibernate isn't import or even required. But you could just stick with SE and write a simple server to handle HTTP requests lol 
Real bummer... Java WebStart has some really cool features, like auto-updating in the background, OS-agnostic icons, shortcuts, etc.
Doesn't have to be an app store, he means "app" as in a stand alone program that you download instead of running in a browser.
Both of those options almost always require zero intervention during installation. Nobody wants to do "thick app" deployments anymore - they suck up huge amounts of manpower to achieve the same goal.
U tell me..
Why link a random stackoverflow question asked and answered 2 years ago except to farm points on there because you asked/answered it? Also you should probably just look up the patch notes if you want to know what is in the new version of something.
What about making EXE's for JavaFX applications? I thought that was the use for JNLP these days?
Learning C++ will probably be extremely useful from a Computer Science understanding standpoint, but unless you are looking to get into a very specific field/company that uses it, you will have a much easier time finding a Java/JVM job.
&gt; If they're mutable use a normal class? And if they're immutable just use a normal class with final fields? &gt; I don't see the value in introducing data/records/whatever if they're mutable I realise the benefits of immutability, but they are an orthogonal issue to most of what was discussed in the proposal, so I'm not sure what you're getting at. I think the value they intend to bring is made pretty clear: destructuring for the purpose of e.g. pattern matching or serialization, with the side-effect benefit of reduction of boilerplate (which would be enough to make most people happy by itself, just look at the popularity of Lombok). I think "people will use it haphazardly where it's not appropriate!" is rarely a great argument, and I don't even see how it applies any less to your proposal than it does to this. As I think people have already pointed out, if you wanted to guarantee (at least shallow) immutability for a data class you would presumably be welcome to combine data class *and* value type semantics for a class once both proposals have materialised.
**Sidebar** -&gt; **NO programming help, NO learning Java related questions!**
Well, for me webstart is a big part of why I use Java on the client. I need a fat client to talk to hardware on client side.
Well, here comes the negative karma. I'll start off by saying your advisor is wrong, no chance java is dead and won't be in the foreseeable future. He is probably referencing C#. The dotnet core 2.0 release has a ton of hype behind it and I see existing libraries adopting dotnet core 2.0 at a very rapid pace. The reason Java has such a huge footprint is that that it's a easy to use language available on every platform. DotNet Core is available for almost every platform and their MVC is available for 2.0 and working great with decent performance. The next reason is [Kotlin being adopted rapidly](https://adtmag.com/articles/2017/10/11/kotlin-edges-java.aspx) since you can easily convert all of your android code to kotlin, though it's still JVM. I'm guessing C# will start to overtake Java mainly for those reasons, but I could be wrong. Oracle may surprise us.
What do use insted?
So, it's some sort of odd compromise between $YYYY.$MM and plain old semver. It's acceptable for me, we basically just go to 10 in March and 11 in September with 11 being the LTS version.
Thank you, eclipse has done the trick in running it properly. What I was trying to use works perfectly fine on campus with their computers and running it from textpad/cmd.exe but not from mine. Do you know what could be the main problem for it not compiling properly on my computer? I'd kinda like to figure out the problem for future sake, thanks though!
I was trying to run this with Textpad if that counts as an IDE as well as with Terminal window, both gave the same errors but Eclipse seems to have solved the compiling problem. I'll take a look at Intellij though, thanks for your comment!
Yea, the Java code is supposed to compile. Your text editor may be missing the required plugin to compile the code. 
No one loves Java and most people writing it would prefer to be writing something else. Enterprise managers have been taught that Java is good software and so we're stuck with it. We only wish it was dead.
Thanks I had the pathing and everything correct, the "-cp ." pat of your run command is what actually helped it run in cmd.exe. Not sure why but on campus computers just doing "java &lt;myProg&gt;" works, any idea why "-cp ." is required for my computer? Thanks!
Yes thank you, it seems that "-cp ." is what I was missing in the cmd.exe command when wanting to run it. Although the computers on campus didn't require it so it baffles me. Thanks for your comment!
Just did a quick search on Indeed, United States with no city/state. Java developer ~ 29,700 jobs. C# developer ~ 15,000 jobs. Python developer ~ 20,000 jobs. C++ developer ~ 10,000 jobs. I know some of these jobs probably have some kind of listing saying they want someone with Java/C#/C++ experience. I don't think Java is really going anywhere anytime soon.
Those are very big generalisations. I feel for you if you don't like writing Java and wish it was dead, but I quite like it. I wouldn't use it for my personal projects, mind you, but it fits very well in Enterprise settings.
Not all at, the Java packaging tool introduced in Java 8 covers that.
I love Java. I would rather be programming in Java than anything else. The language itself is just like any other C based language. IMHO because Sun maintained such a strong hold on the Java ecosystem for so long, there were a lot of good models to copy from the start. The effect of this is that the vast ecosystem of everything you could possibly want, is cohesive and mature. What this means in practice is that by drinking the Java koolaid once, you get the entire ecosystem for free. Once I've seriously understood how the JCA/JCE works, all the other libraries out there are trivial to understand and work with. Whenever you are trying to solve a problem, you are actually faced with two problems. One is the problem at hand, and two is facing the incomprehensible DSL in Python, JS, etc. that supposedly solves the problem. You don't have any domain knowledge in the problem itself so when you are faced with a completely non-cohesive library, you can't possibly understand it. With the Java ecosystem its different, getting into ML with absolutely no knowledge, I was able to use Weka effectively enough for production. When I realized ML wasn't what I really wanted, I was able very quickly to refactor to Drools, not knowing anything prior about Rules Engines or RETE. I think part of the reason no one likes Java is because they fail to realize that literally everything you could possibly want is there for you already. I honestly don't understand the sentimentality that you must write ALL THE CODEZ yourself. For that purpose, maybe just invent a new language/ecosystem.
I like java. I write small personal programs with it. What do you program with java? Are you perhaps just stuck with a problem using the wrong language?
I'm actually writing very little java now, after 16 years of being forced to do mostly Java and PL/SQL. For small, personal programs, I'd probably still use Perl where I can, but for anything that needs to last, I'm preferring Scala. My employer is working hard to keep up with the times and strongly supports every Java programmer learning Scala. I wonder about the people downvoting me. Are they people who love java, or Enterprise programmers who love their jobs? 
That's really quite cool, I'll give this demo a go later. Are there other existing validation tools out there that are commonly used? We handle every error manually at my company :scream:
You don't have to abandon the Java ecosystem to use a better language. Scala, Kotlin and Clojure are all options.
Yep. They're generalizations based on a whole lot of experience in a lot of different organizations. I've known far more programmers who were forced to write java than programmers who choose to write it.
Anyone here with contacts at Oracle so we can have an official answer soon on the fate of WebStart ? I'm not interested in speculation or someone interpretation of 2 lines of documentation... I use webstart for the ease of only having to update an installation on a server and get all the clients updated, and loosing that would mean more work in our future.
Other than JSR-380 there is OVal library that offers more or less the same features. The nice part with JSR-380 is that you can define your own custom annotations quite easily. 
I bet the Java installer will still let me restart my browser anyway because right now it does and Chrome dropped the support for anything Java related ages ago...
This. Let the numbers speak for themselves, instead of listening to "Java is dead!"
But that's still a matter of personal preference. JVM languages that aren't Java aren't objectively better overall. 
Well I do l love Java and Enterprise customers have money but I didn't downvote you.
Java and C++ both share the majority of the job market and the other languages like Ruby, Python, or Javascript each have a little slice. There's no reasonable definition of "dead" that could fit Java. It's very alive.
Dang, I'm doing scala rn in class, there's too many parentheses!
The truth is you're going to have to know all the languages. This year alone my job made me write programs in Java, C++, Python, TypeScript, JavaScript, Skylark, and Shell. Languages never die.
Uh... sounds more like Lisp. (Or Clojure) Most parens in Scala are optional. Curly braces everywhere though!
Java the language is rusty, but it tries hard to combat it, by having more releases and incorporating ideas found in other languages. Java the ecosystem is awesome, there are many good and stable ways of doing regular stuff which means you can spend more time doing meaningful programming. 
Oi, sorry, I meant scheme haha
You're in /r/java - think about it. These people use java everyday and have a vested interest in it.
A lot of people associate Java with applets. Applets are dead. Java is very much alive in the: * Mobile sector, with Android * Web sector, with Spring or JSF
What do you mean by rusty? Libraries missing stuff? 
yeah java in the browser died before it was born. As someone who makes a very good living off of java i can tell you it's here, and here to stay it's everywhere. 
They don't suck up huge amount of manpower or tech resources if you use Java Web Start. I am surprised JWS is deprecated it is a great way to deploy apps to a large number of users. I use it to deploy two applications to our clients. 
I'll give you a positive data point: I choose to write it! :D
Removing Java Web Start (JWS) would be a huge mistake. It is a really nice way to deploy desktop applications to users. JWS has nothing at all to do with applets.
I don't think anyone (including Steve Ballmer) ever claimed C# is a Java killer.
Not libraries. Go back to the start of java. early 90s. They made some tradeoffs then to get performance which today kinda suck. For example mixing in primitive types like "int" within Object types like "Integer". These tradeoffs made since in the early 90s, but today, it leaves the language with a legacy of weirdness since today there would be not reason for such thing.
Not sure why you expected negative karma. Anybody with a brain can see Java isn't dead.
Value types are looking to caulk that seam.
All the commenters here are linking stuff job markets' numbers using them as a proof that Java is not dead. And yes, they are __100%__ right. The market is full of Java jobs, as Java is the main enterprise language and __it's not going anywhere soon__. However, Java __as the language__ is experiencing tough times. We waited 3 and a half years for Java 9, and it did not introduce any significant or desired language features. In that time the developers' world embraced ES6, 7, 8 React (and similar), the explosion of Electron apps, Kotlin, Rust, Swift and __what's most important__ -- several version of __C#__. Microsoft does not stand in place and improves the language, introduces new features, develops ecosystem. Oracle decided to shorten Java releases, so I love Java and __hope__ the situation will change, but it is very cumbersome to write in modern Java.
While Microsoft may not have said it. It was the impression given back then: https://www.theregister.co.uk/2000/06/27/microsoft_describes_its_java_killer/ 
So, for real (and search if you don't believe me), Java is dead everywhere except in this sub. Java jobs pay well, _when you can find one_. And when you do, you'll likely be working with an _old_ stack with little to no redeeming value. The reason it's dying is primarily because of microservice polyglot codebases. Coders are using much more lightweight API gateways (node/elixir/php/python) and only sending standing up Java microservices when they're needed for rich concurrency use-cases (java.util.thread). But even in these situations golang is emerging as a serious competitor because it's not as resource heavy and allows flexible management of threads etc. with so much less overhead. In short, people aren't using Java to "do it all" anymore, like they did in 1998 before the age of horizontal scalability. Modern langs/frameworks/runtimes let today's coders accomplish much more, in less time, and host it at a fraction of the cost. Have you ever tried running a production-grade Java server? It's a nightmare to maintain and a cost sink. Also most Java code is written like this, and it's encouraged: https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition Does that look enjoyable? Answer is **no** Seriously though. Look at all of the old, grumpy Java engineers here that have had their legacy roles forever (at obscure companies) telling the rest of us that Java isn't dead. Look at career trends and graphs. Java jobs do pay well but are overall in low demand
1992: Your advisor is either out of touch with the real world, or possibly just a fool. Cobol is the most used programming language and has a heavy presence in enterprise software. Now that doesn't make it the best programming language, but there is no shortage of Cobol positions. Java was supposed to be a Cobol killer, and while Java has been successful, Cobol still has higher use.
I don't understand the fuzz about immutability. Or maybe I don't understand immutability. Let's say I have a view model class in an MVVM pattern and the view updates a string value in that class: I'm mutating that view model. Is that bad? 
No doubt!! but in the meantime, we have some "rust"
If you are worried about parentheses, you are using the wrong development tool. IDEs that understand lisp based languages can help deal with the parentheses.
Enterprise sector with system to system communication is also a lot of Java.
I'm a recruiter and I'd say I look for Java 1 our of 4 jobs in the IT field. Its very common, and its usually very difficult to find people for it. Keep learning it! 
I was just teaching some more advanced java topics to a new intern and came about a bunch of those weird quirks, specially around generics. It took me a long time to explain variance. I've been around java for so long that a lot of those weird things are natural (albeit ugly) and don't sound so bad until I have to explain them. 
In some societies self promotion is considered low class.
Java is for sure trending down (very slowly IMO), but it's nowhere near dying (not yet) and I bet that I will be long dead before java is 'obsolete'. It also depends on your definition of dying of course. A lot of cool things are being done in not-java land, specially in startups but at least where I live, medium to large companies do mostly Java and C# and can never find enough programmers.
Rather than jumping on the bandwagon, I will at least *try* to substantiate the claim that java is “dead,” despite how ridiculous it is. - It’s *much* less common for new businesses to start with Java these days. This is sort of nullified by the fact that a lot of those businesses switch to Java later on when they’re bigger, as well as the sheer volume of existing Java businesses. But startups tend to start with “leaner” technologies like Node. - Java is not exactly the most modern language. - For a language with strong static types, it doesn’t exactly have the *best* type system; there are a lot of languages with more powerful and useful type systems. - It has only recently adopted lambdas, and the APIs around these are still taking shape. A lot of people are overusing them, and a lot of APIs would be much nicer with them. - A lot of design patterns are often followed far too strictly, leading to a lot of the verbosity and complexity that people complain about. People have been coming to their senses on this stuff in the past seven or eight years or so, but there’s a lot of historical baggage exhibiting some really massive complexity for the sake of blindly following a design pattern. --- Java is not dying. It’s still in massive use. There are existing Java projects, existing businesses starting new Java projects, new businesses switching to Java projects, and the occasional brand new business starting with Java. But I could definitely see why someone would *want* it to be dying, as it shows its age a little bit.
Why wouldn't you recommend learning pure Java EE with spring ? I mean are there other langaue beside JSF that I need to learn to develop application using Java EE
Yes, I'm aware of the fact the Reactive Streams is a set of low-level APIs. However, my question was whether these low level APIs will live on as "Reactive Streams" (as we know it today) or as Flow API as part of the JDK. The interfaces are the same, but what will be the standard namespace of these interfaces?
This subreddit is **Java only**, not **JVM languages**. Please, refrain from further posting non-Java content.
Your advisor works in academia, where Haskell and Rust are cool, and you don’t have to worry about bottom line problems, so there is little reason for him to care about Java.
No, just the burden of backwards compatibility, meaning old stuff can't be removed easily and new stuff can't be added easily.
That is completely unrelated...JNLP is the Java Network Launching Protocol, it got nothing to with that.
 &gt; Both of those options almost always require zero intervention during installation. That's neat, but might not be feasible. JavaScript applications in the browser is nice until you need to access local resources or you realize that it is utter shit (Vaadin is still the best option, but even that is not good). Considering an App Store to deploy an in-house solution is stupid at best. &gt; Nobody wants to do "thick app" deployments anymore - they suck up huge amounts of manpower and tech resources to achieve the same goal. So...you've been doing deployments wrong? As /u/wildjokers said, previously with applets and now with JNLP it is rather easy. 
Oracle in a nutshell. 
Exactly the same as the states
You mean grab them by the pussy Trumpistan. Fuck that place.
Cobol STILL isn't dead. Only most of the people who know how to program it!
I would recommend enjoying learning C++ in uni. Any lesson you are asked to do in C++ try to solve in java as well to keep your java up and allow the differences between the two to materialize. Java is an incredible language.
At the very least you should add a README file in your Docker repo to explain what is this. Also even though, more and more developers know what Docker is, I would not say the same for OpenFaas. So as a minimum you should also describe how does your project fit into OpenFaas.
at some points it looked like java was going to be obsoleted by something else. and especially around oracle vs google lawsuit, things were rather shaky. but there is just too much stuff reliant on java, and to interface with it it's best to also use java (unless it has a rest api).
javas dead cuz Oracle fucked it.
https://docs.oracle.com/javafx/2/deployment/packaging.htm
no, search java jobs on indeed or dice. People who want to pull people away from java to other niche newer languages like to say it's dead, java is a target for this because it's so large. Think of it like this no one has ever had to tell you something that's actually dead is dead.
That's why I hope Kotlin catches up. It already has all of those libraries from Java and it's a really nice language.
I've been using Java professionally since 1995, when it was released. It's still my bread and butter professionally. Every few years there's a dumbass article about Java being dead. It's usually just a headline for grabbing clicks with little to back it up. There's a vast landscape of libraries across all tiers, including embedded systems. Remember, Java is just the language. Where it really shines is in the context of a framework like Spring. You can literally write a Spring Boot app, deploy it to Heroku and make it publicly available in minutes. Circa 2010, it was really only Ruby and nodejs that could do that. My point is, Java frameworks have continued to evolve over the years as has the language itself. It's not going anywhere anytime soon. Go to salary.com and compare Java jobs to nodejs jobs. Java will get you more. That said, the same search against .NET would be pretty close.
The thing with Java is while the language is mediocre the tooling, ecosystem and especially JVM are top notch. Java as a language might eventually fade away, but the rest will stay.
Yes, like the java.util.Date class, the fact that Generics had to be bolted on, the never ending war for some sane package management built into the java framework, etc. Java isn't dead, but it won't give you those sexy new features that newer languages can.
Troll!
Yes, like the java.util.Date class, the fact that Generics had to be bolted on, the never ending war for some sane package management built into the java framework, etc. Java isn't dead, but it won't give you those sexy new features that newer languages can.
&gt; but it is very cumbersome to write in modern Java. Not it's not. What do you mean? 
This falls under **tutorial** and thus under the + **Do not post tutorials here!** These should go in **/r/learnjava.** rule. **Post removed**
JAVA was terrible for a long time, in a lot of cases compared to other options, but it was so widely used that almost everyone came into contact with it. I got off the JAVA wagon during that time, back when .NET took off and actually became awesome in the early days of the enterprise web application. Jokes on me now though. Between spring boot, great cloud enterprise support send self-containment JAVA is probably the most modern shit in enterprise town. Especially with all the JavaScript hype dying down. Yet I'm stuck with fucking .net core and the truck load of devops required to make it actually work satisfactorily in production.
Check out Kryo.
Since adding shite like lambdas....java is dying. Java's power is its simplicity. Lambdas are great, but clash terribly with Java's simplicity. I fear java is dying.
&gt; the explosion of Electron apps what?
What would you have liked to know? Also GitHub Issues are extremely appreciated ;-)
I honestly think it's a typo. There's no deprecation warning running `javaws -help` in Java 9, despite the website saying it's deprecated.
were just doing a 3 week thing on it, just emacs stuff lol
You know the same amount or more about scheme as most of the people who complain about Java do. 
Promoting what exactly?
Short answer: people have no clue what the hell they're talking about if they say Java is dead. Also, now that Java has gone to a more aggressive release model, it may be prudent to try to stay on top of things. Just because your school doesn't think it's useful does not mean you shouldn't keep up with a technology. While I will defer all kinds of theory knowledge to university professors, when it comes to reality and pragmatism, I take what they say with a large grain of salt.
&gt;its usually very difficult to find people for it. Why? They're all employed already?
Schroedinger's Java
RIP. If Java in the browser survived, we'd all be doing our DOM manipulations and whatnot in a real language right now, not friggin' JavaScript.
You say simplicity, I say weakness. Bring on the new goodies!
The only thing Electron grows explosively is its RAM usage.
\&gt;thinks Java is dead \&gt;uses Perl 😂
The curly braces around method definitions are also optional, FWIW.
If they are one-liners, the brackets are optional. I find an awful lot of situations where they aren't.
The good ones are, yes.
One-expressioners, to be precise, and yeah.
Because of the steep experience requirements that seem to be more or less ubiquitous. Could you imagine needing 7 to 10 years of experience to be a Ruby, Python, or Node developer? Most of that ilk would have needed to have started professionally programming while in middle school.
I wouldn't touch java when learning c++ as you'll hate learning c++. Why stuff around with pointers and a million silent ways your code can fail. I love java as its easy to reason about and follows good standards. c++ is messy as hell with convoluted coding standards and unreadable source code. Eg __X__Y__Z__PRSN somehow is supposed to mean Person class. Whenever I look at c++ code I just love java even more. 
We may dislike Electron apps as much as we want, but it is the easiest and the cheapest way to build a UI today. Why did I mention Electron apps? Well, JavaFX was/is a promising platform, but would people choose it?
Sorry, I edited that out :)
&gt; The truth is you're going to have to know all the languages the good thing is that once you learn one others get a lot easier to learn. especially from a problem solving standpoint and while comparing similar languages (e.g. java,c++,c# etc.)
I've been using this instead of webstart - perfect for my needs https://github.com/edvin/fxlauncher check it out.
That's fine. It doesn't have to be distributed via webstart.
Yes, I’m getting contacted by recruiters constantly these day. I say I’m happily employed. They “forget” and call me again the next week.
Over Electron? Not sure about anybody else, but hell yes, I would.
Exactly. There's no reason to do this anymore. Don't. Let it go. There are way better desktop technologies (c++ anyone?) than java. Let it be on the server where it actually shines. Let it go, let it go, let it go....
&gt;java &gt;simplicity kek
How do I use this? Am I supposed to checkout the code and add my own? Or do I use the Docker image as my base image for something else? What is the use case? Any examples? Why is the unit test empty? Why does it use JUnit3? Is there a limitatation for this? What am I supposed to do with the javatest.yml file? And so on... All these things should be in the README file.
Ask him why he isn't working professionally as an engineer and likely getting paid more, and getting to do more innovative things instead of guiding people through writing a trivial compiler for another decade. Okay, I admit I was being a jerk. But seriously academia doesn't always have the most in-touch perspective when it comes to technology. They're good at diving deep but now the reality of getting a modern system going.
Don't use Java serialization, full stop. It's at best slow and as worst a massive security vulnerability. Use a standard serialization format like json, protocol buffers, kryo, or others. Benchmarks prove they're faster if you're performance sensitive, and they don't allow the sender to manipulate the payload in such a way that they can call code you didn't intend for them to be able to call. Added bonus: you can now write clients in other languages easily. Don't use Java serialization. There are reasons you might, but if you're asking the question you're asking, the answer is that you absolutely should not because you don't understand it.
Academia tends to be generally out of touch with industry. But I don't think it's not their fault. Their busy focusing on curriculum and research. Keeping up with industry standards is a lot.
It's almost exactly the same as people saying ".NET is dead." No, it's not dead, it's just not trendy with the startup crowd. 
It's almost exactly the same as people saying ".NET is dead." No, it's not dead, it's just not trendy with the startup crowd. 
&gt; Your nasty static map trick: These immutable classes cannot contain static mutable fields, and cannot reference any external static mutable fields. You are now conflating immutability and side-effect-free-ness. It is not possible to apply this unless you add the concept of compile-time checked and runtime-carried SEFness. I can call any method and it can do this stuff for me. Unless you intend to disallow any method calls of any sort, except into other such data types, in which case we're back to: That's nice, but there's no way to retrofit that into existing java code so you're splitting the community, python2 vs. python3 style. I'm quite sure that the cure is far worse than the disease, if this is the cure. &gt; Files: You make another good point. The simple answer is that the File class is not an immutable data class But what if I make it final and add 'data' to it? There's nothing in it (let's forget about that cache field for a bit). How can the compiler know that the thing is interacting with I/O? Is it the programmer's responsibility to just mark it as such? Your instant kneejerk reaction that File is clearly not 'immutable' leads me to believe you're still mixing up immutability and SEF, which are quite unrelated. It's a bad idea to mix these ideas up. &gt; Split world: Yes, there is a bit of a split world, certainly not as bad as python though. As I have tried to show, this rabbit hole is very deep. I'm afraid I'm not going to just take your say-so as proof. &gt; (paraphrase: Hey, we can memoize!) Memoizing is a nice trick, but note that file needs to operate on this cache as an in-between step. However, with some extra tweaks and rules you can indeed have the VM cache it. Presumably, you can add a hint annotation or some such to make sure the VM is going to try hard to do just that / have the compiler generate some syntax sugar. So that's one of the three issues resolved. The other 2 are not so easy. 
Are you on a Mac? Is the hostname in the /etc/hosts file for 127.0.0.1?
That's not bad, and there aren't many cases where you would encounter issues in a MVVM style application. Where mutability becomes an issue is when instances are shared across threads, used as HashMap keys, stored in a HashSet, and a variety of other cases. The biggest benefit of immutability from my point of view is that immutable classes are far easier to reason about than mutable classes when shared between threads.
We have the technology http://www.kaasdesign.nl/nutshell1.jpg
LWJGL has a great implementation of OpenGL!
&gt; There are only two kinds of languages: the ones people complain about and the ones nobody uses. - Bjarne Stroustrup People say Java is dead because they think it makes them sound cool. There is debate over whether Java is the new COBOL, but like COBOL it is used everywhere and it's never going to die because it's so widely used throughout corporate systems. Java is the #1 most widely used language in software development right now. I personally would not invest serious time in C++, as it is actually fading out in use because of security and stability issues that garbage collected languages like java solved. Java is the #1 widest used language, the only thing it's dead for is being trendy or esoteric enough to interest academics.
I'd verify that first, as someone with over a decade of experience in the field, I almost never see requests for java ee when I'm searching off "java". Spring mvc, angular, react, yes. Java EE, no.
Okay
Where did he say that Java is dead? He said that he prefers Perl and supports Scala, nothing about Java.
Your advisor is literally a fucking idiot if he/she said Java is dead. Java runs on three **billion** devices worldwide. It's one of the core languages in the operating system used by one billion people, which is Android. It's fucking everywhere, and there is a huge demand for people to maintain it. I see no reasonable explanation for this person's logic or reasoning, other than monumental ignorance or stupidity.
Got it. So you're admitting there is a place for mutable classes, and that it should at least be an option? There surely are downsides to immutability as well. I'm an Android developer and we're working in a resource restricted environment. Constantly copying objects instead of modifying them puts an extra strain on the runtime environment. 
As a Dev with experience I only had to apply to one job an got it within a week. Still 300+ positions open in my city only for good JAVA devs!
For starters: your website with ads for your book and your company with its training courses. But please: explain to us why you keep submitting your own StackOverflow answers (not even the questions themselves! In this case here your answer isn't even "the accepted" one (not that this matters)), which often are many months if not years old.
exactly, they usually focus on research trends...
&gt; For starters: your website with ads for your book and your company with its training courses. That's quite a stretch from the original reddit posting. Anyway, most bloggers have something to sell because where there is a demand, there is an offer. Basic economy theory. &gt; explain to us why you keep submitting your own StackOverflow answers *Keep on* sounds like there were tens of such postings which is not true. &gt; In this case here your answer isn't even "the accepted" one (not that this matters)), which often are many months if not years old. I posted my answer 6 months after this one got accepted. Now, if you were a regular SO responder, you'd know how it works. Once a user accepts an answer, it's rare they will reconsider their option. But, that's not important anyway. Nevertheless, even if it's 6 months newer, my answer still gets lots of upvotes because: - it's more informative - it's more authoritative. Who do you think knows more about Hibernate if not the people working on it? By the way, some of the features I talk about in that posting were developed by me. Kinda cool, right?
That part I haven't quite figured out yet. "-cp ." is telling java to use the '.' directory (i.e. the current working directory) as the classpath. There's some more configurations to get running for sure. I was doing this on a friend's loaner laptop, but I normally don't have to do this on my home PC just as you don't normally need "-cp" on campus.
Most good programmers have.
JVM based languages are here to stay and there is enough legacy code to employ java devs for a long time, but java for Greenfield projects is slowing down (at least as far as total market share).
tbh, I couldn't convince anyone to pay me for my Ti-83 calculator games. Seriously, hiring managers want to see full time employment. I've been docked because some was 'part time while I was in college'.
Wow, this would be huge if it was ever actually implemented. And if we ever get both Loom (user-mode threads) and Valhalla (value types) Java would become insanely performant.
I think /u/pron98 seems to be the author. He's the guy behind Quasar. It'd be nice to have this natively in the JVM, as currently Quasar relies on its own agent to do bytecode instrumentation. But this clashes with several JVM runtimes (Scala at least, Groovy?) so native support would be extremely welcome.
Probably because basic knowledge about the common parts of EE is just assumed from a senior Java developer? It's the default. No need to require it in a job posting.
There is a lot more to EE than just JSP and CDI. Try to pick the part that are actually useful, but *never* tell a senior developer you know EE. Nobody knows EE ;)
Oh I'm know there's plenty more than that - I was more meaning conceptually those things have been the most I've ended up reading up about most.
Frameworks are intended to hide the underlying implementation. Using a framework will give very little exposure to EE so what learning is really going on? You're not reinventing anything if its just a learning exercise. Sometimes you can create a http server that does more then what is provided out of EE's box.
I kinda agree with you adviser. With 5 years working experience, I've seen a trend with .NET being more in demand.
The only thing I disagree with is the idea that C# will ever overtake Java. C# has some major flaws (like partial classes and structs) which can never be fixed. 
&gt; Let's say I make a data class as you described it with your rules, and I add this code to it I don't see what your example has to do with immutable data classes. An immutable data class is one where all the instance variables (i.e., the state) are immutable (and hence you don't need getters or setters). Whether you can tag on some methods that mutate some global state, as you do in your example, is completely orthogonal and has nothing to do with the discussions here. I also don't see the problem with the collections API or arrays. They are obviously not immutable data classes, but they can store immutable data classes the same way that store any other class (they don't need to ability to mutate their members). If you want immutable collections, you need another API, or just borrow the Clojure implementations.
I like the approach: let's hire the one who hacked something into the JVM to do it the right way. The same way the asked Colebourne to write the new DateTime API
&gt; it's clear that the rule is a lot more complicated than simply: "Only final fields, and the types of these fields are restricted to known immutable primitives and other such immutable classes". You're now looking at what the methods of this class are calling. That is not at all clear. I don't see any problem here. Immutable data class is a class with only final fields of immutable class instances. That makes the state of the class immutable, which is what gives you the properties that you want. What the methods of that class do is completely irrelevant, as long as they cannot mutate the state (i.e., the values of the instance variables). I also don't see your issue with the File class. It's not implemented as an immutable data class. Maybe it could be converted into one without breaking backwards compatibility, maybe not. Doesn't matter either way. Conceptually the File class is a pointer to a filesystem path. That can be made immutable, if one wants. The filesystem itself is of course mutable, but that again is not relevant here, you still get all the features of immutability for your File class instance.
&gt; Constantly copying objects instead of modifying them puts an extra strain on the runtime environment. Immutability does not mean copying. In fact you rarely copy immutable objects because it is safe to share them. What things like immutable collections do instead is structural sharing.
You can still roll out a desktop application with auto-updating. Applets are a thing of the past.
That's pretty much the gist of it. If you are a startup there are not many reasons to use Java, but once you start looking at companies with 20+ employees the chances that they're using Java increase exponentially. Actually the same statement could be made about C++ with little modifications (which is the language op mentioned he's now learning) What you don't mention is that a lot of companies also tend to switch to Java as they age.
&gt; Why did my advisor say java is dead? Because he does not know what he is talking about. Saying that Java is dead combined with teaching C++ as the primary language shows that this is not a top university. Java is in no way dead. It is used extremely widely in the industry and it is being constantly developed with modern features added. It has its strong and weak points like any other language. If anything is dying, it's C++. There are fewer and fewer domains where it would make sense to use C++ for a new project. It might make sense for things like large game engine projects, but even there personally I'd argue for straight C instead. Mobile development is Java/ObjC/Swift/JS, web frontend is JS/TS, backends are Java/Ruby/JS, native desktop is C#/ObjC/Swift/JS, embedded systems are C/Rust, etc. There just aren't many use cases for C++ these days.
&gt; Learning C++ will probably be extremely useful from a Computer Science understanding standpoint It really, really isn't. It's way too convoluted and complex, and doesn't have any innovative ideas. For CS understanding you want to expose yourself to well designed languages of different paradigms: Lisp, Haskell, Erlang, C, Java, Go, Rust.
Umbc, "top 6 undergrad" lul. But I think its just this professor, he seems to not give a fuck. He didn't respond to any emails for 3 weeks when I tried to make a meeting ffs, not even a "No, ask next week"
&gt; it doesn’t exactly have the best type system; there are a lot of languages with more powerful and useful type systems. Just curious, what do you think it lacks? Except for handling nullability I found Java's type system to be outstanding.
How does user-mode threads differ from the old green threads we had in Java 1.1?
The existance of primitive types and the inability to say that a third party class implements my own interface are my main gripes. Then theres stuff like runtime erasure of type parameters that I know bothers a lot of people, but I personally rarely run into practical problems because of that. Similarly the type inferance sucks, but with good code completion Im not very bothered by that either.
Java 1.1 was before my time (I started with 1.4), but at a quick glance it sounds like Java 1.1 *only* had user/green threads, which sucks. If you're only going to have one type then it definitely has to be kernel threads like we have now. But the real trick is to have *both*. Also I bet green threads didn't make the nice continuation/scheduler distinction that's described in the Loom proposal. Finally, you really need the standard libraries (especially libraries that perform IO) to be aware of user threads so that you're not blocking kernel threads when they're waiting on IO.
Well that takes the cake for being the most condescending and absurd excuse making I've heard yet.
&gt; Java would become insanely performant. It already is. Plenty of libs that let you do exactly that already.
Depending on what web sites and articles you read, you can come to any conclusion that you like these days.
If you had a choice between Electron and JavaFX no one in their right ming would choose Electron. HTML+CSS+JavaScript is a shitty way to make a rich client app.
There are absolutely times when mutability is better and easier, but as /u/njetwerk mentioned, there are times when immutability means less copying. When I started building data classes as immutable by default, I was surprised how rarely I actually need to modify (or make a modified copy of) an object. The vast majority of data objects in my experience have their state set at or near their creation time, and never get modified. But yes, there are certainly times when mutable objects just make more sense. What I'm referring to in my top comment is that it would be very helpful to have language support in building immutable objects which guarantee deep immutability. I don't honestly expect such a feature, but hey, a guy can dream.
Yeah, it was only green threads. Green threads are one of the reasons that everyone thought Java was slow (and it was at the time).
&gt; How does user-mode threads differ from the old green threads we had in Java 1.1? Weren't Java green threads M:1? This is M:N.
&gt; the one who hacked something into the JVM I think a bit advantage of the Quasar was precisely the opposite of that - he didn't have to hack it into the JVM, he did it all using user-space Java.
The video tutorial makes you understand the structure of a Java class and guides you the procedure to run it through NetBeans IDE. Language used is English
&gt; Oracle may surprise us with great new features. I'm very hopeful for the future of Java right now, there are all sorts of cool things being explored atm: - Value types (Valhalla) - Data classes (Amber) - Fibres / continuations (Loom) - Sealed types / pattern matching / switch expressions (Amber) - Local type inference (Amber) - *Huge* native interop improvements / vector API (Panama) - Java-on-Java / polyglot VM &amp; JIT (Truffle/Graal) - Declaration site variance for generics - etc... Some of these things are pretty long term plans, but all the big ones already have significant work behind them and some are already planned for release in the next cycle I think. Let's hope the new release-train model helps bring them to us quickly.
Could I please get an ELI5 or tl:dr here? 
And enums are pretty useless in C#.
Why it isn't 18.3?
See [here](http://mail.openjdk.java.net/pipermail/jdk-dev/2017-November/000089.html).
Wat?!
The following is a simplified explanation, so is not true as such. When Java deals with concurrency, it asks the OS to give it a new process. These processes are designed to work by themselves and even though communication between them is possible, it's very complicated and so slow. Let's call this communications process synchronisation. Like the article says, we can often only run a thousand of these on a big computer, whereas the actual, underlying operations (which are being executed by the process) themselves could be handled by the millions if there was no synchronisation involved. The trouble is that we do need a lot of data to wait for each other, so we definitely need _some_ way to schedule these operations. This is where the mentioned forkjoinpool comes into the picture. The idea is that we could develop code that can be split up into smaller chunks, and instead of making the process wait for some other process to finish what it's doing, the finishing one could simply invoke our next operation. This in itself is nothing new, we've always been doing this with messaging systems and user interfaces. What is new is that they want to add native support for this kind of operation within the language itself. 
I'm all for getting rid of all the crap we had to bolt on to our systems recently and getting back to our beautiful abstractions, but our bottleneck in most enterprise systems is the database and bad engineering, not our blocking threads. In fact, now that I think about it, I don't think this technology would have impacted anything I've done in the last ten years. I understand that not everyone works with systems like these, so I'd be glad if this worked. 
Before anybody starts any: **no IDE flame wars!** We want an on-topic, hate free discussion. No discussion which IDE is better.
Okay... It works without you adding your own code, but the idea is that it's a template for you to use for making OpenFaaS function as a service using Java. The docker image builds your code in a reproducible environment so that you don't need to worry about build environment (gradle branch resolves deps using gradle, master branch uses maven. I've not used Ant in years so I guess it's missing Ant and other build systems). The use case is to run ./build.sh docker stack deploy func --compose-file ./javatest.yml If you have OpenFaaS setup it will deploy a Java Cat example with pseudo dep on apache both to demonstrate use of external deps and pipe stdin to stdout (OpenFaaS provides functions with data via STDIN and returns STDOUT) It doesn't use JUnit3, it uses 4.12, has done since first build and it's a useless but not empty test. The Javatest.yml is an example docker stack deploy so the function can be deployed. Other methods are supported but while building it made most sense to delete and deploy many times unattended to have a file. I'll accept some of these things should be in a README but the Junit bit wasn't even accurate. 
Oh look, /u/hypersistence – it's another post that you've deleted and your comment, too (you know, just like [the one a couple of days ago](https://www.reddit.com/r/programming/comments/79mocp/why_is_hibernate_open_session_in_view_considered/)). Why the need to erase it from your posting history? 
Thank you, I appreciate it. 
Thanks god
Will the M3 software update feature update it to M4, M5, etc. and eventually GA as those versions are released? Or would it be necessary to re-download the entire package to get updates?
I realized that I'm not welcomed on these reddit channels, so it's not worth keeping any comment that, otherwise, provided many useful info about various topics: SQ:, transactions, concurrency control. Cheers!
I think you will have to redl it.
We all know which one is better