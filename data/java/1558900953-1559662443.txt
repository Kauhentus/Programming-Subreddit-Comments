Isn't it technically wrong to say that people "can't use Java 8 updates beyond Jan 2019 for free" because Red Hat will be providing maintenance updates for their distribution until 2023? And isn't it also wrong to say that people "can't use Java 11" for free because Red Had will be providing maintenance updates for their distribution until 2024? I understand that those statements apply to Oracle's distributions, but I think it's bad to publish statements like that because it creates the false impression that Java 8 and 11 are no longer freely available for supported use. Considering that Oracle is now charging money for enterprise support of their Java 8 distribution, it seems like they could be trying to create that false impression to make Java 8 users feel like they have no choice but to pay Oracle for their enterprise support (rather than switching to a Red Had distribution). Personally, I think the most appropriate thing for Oracle to do would be to steer existing Java 8 and 11 users towards the Red Had distributions (so they can continue to receive support for several years). I'm sure the OpenJDK release cycle will be practical for many developers, but some companies aren't in a position to quickly switch from older distributions and would thus benefit greatly from the continued support being offered by Red Had.
Straight from [Java API documentation:](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Deque.html) &gt;The name deque is short for "double ended queue" and is usually pronounced "deck".
No, it needs a Googles security provider, which doesn't support server side SNI. At least last time I checked.
So I'm not an expert on HTTP2, but I worked through the Jetty examples with the help of a contributor and got this example running last year: https://github.com/tipsy/javalin-http2-example
Jshell
If Hadoop and HBase ever start working with it
&gt; I understand that those statements apply to Oracle's distributions It's not Oracle's *distributions*, either. Oracle distributes the JDK under two licenses, one free and one commercial (as opposed to the mixed one we had before). &gt; Considering that Oracle is now charging money for enterprise support of their Java 8 distribution As they have for *every* version of Java before. &gt; it seems like they could be trying to create that false impression to make Java 8 users feel like they have no choice but to pay Oracle for their enterprise support (rather than switching to a Red Had distribution). I'm not aware of anyone who provides enterprise support for free. It is true that there is an OpenJDK 8 updates projects, with free builds available. That may be useful for many, but it's not what people call "enterprise support." Also, there are considerable differences between Oracle JDK 8 and OpenJDK 8, as the JDK was fully open sourced only in JDK 11. &gt; Personally, I think the most appropriate thing for Oracle to do would be to steer existing Java 8 and 11 users towards the Red Hat distributions First, these aren't Red Hat distributions but an OpenJDK project led by Red Hat and distributed by several vendors. Second, OpenJDK 8 and Oracle JDK 8 weren't the same, as I said above. Third, it's important to remember that Oracle's support subscription is what funds the development of OpenJDK, so I see no reason why *anyone*, and especially Oracle, would want Oracle to advertise against the main funding source of OpenJDK.
Nothing I really need but made the jump to stay current. In some ways the language is worse. It's becoming more complex in offering several ways to do the same thing. It makes reading others code require more knowledge.
Ahh... the difference between /r/programming (or Hacker News) and /r/java: # /r/programming **Q: "What is the most-bestest programming language in the world today?"** *A: "Anything but Java. It's so old and stuffy and stagnant. Impossible to get any work done with it."* # /r/java **Q: "Any plans to upgrade to any new or proposed version since 2014?"** *A: "Meh. Whatever. Too busy getting work done."*
* When they actually release Generics primitive subtypes * When the altJVM Gradle plugin maintainers get their act together * When my coworkers stop complaining about how method chains for streams are “way more complex” than try/catch * When I finish my Go, Rust, C, C++, D, assembler project milestones and revisit my JVM projects
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Generics over primitive and inline types are [in the works](https://openjdk.java.net/jeps/218).
Migration from Java 8 will be an inflexion point driven by the Ecosystem (libraries, tool, communities) - nothing to do with the features. There'll be a sweet spot where enough libraries and stuff support it and people will slowly start porting and dealing with the hassle, but mostly only the forward-looking "let's not accumulate too much technical debt" people. Then some more popular stuff will drop support for Java 8, and the snowball will pick up speed. We're not at that point yet, but I think the industry will get there in another year or two.
Java 9 fixed a critical bug in javac that involved complex generics. If you have code with complex generics, javac may hang in compilation, and never finish. The bug is described here: https://bugs.openjdk.java.net/browse/JDK-8051946
Java's def not the best language, but it's the one I--and pretty well every other coder I work with / know--use most often (except for those that use c/c++, which has never been my thing.) Lately, I've been leaning toward Scala a lot though, I like how it looks and it's easier to reason about. Also, I'm looking forward to string literals and improved switch statements. I'm on Java 11 primarily right now, but I'm skipping 12 because it's not LTS. I would kill for one line 'if' statements in vanilla Java, and maybe support for first-class lambdas, but Scala already does both quite well.
Easier to reason about lol? Good luck with insane compiler plugins and extensions. Java jit can make the majority of software just as fast as cpp these days. For the a lot of things you don't need to be the fastest, and java is very very good as most things.
&gt;out of the box container awareness You caught my attention, can you say something more about it or provide some link on that topic?
Agreed. It's getting too confusing, reminding me of C#. It always seemed to be in that sweet spot - less complicated than C because no need to deal with memory allocation and raw pointers, but safer than all the *cool* languages like python or perl which were awful once your code base became larger than a few scripts. Now it just seems like they're bolting on new features in order to maintain parity with other new at the expense of readability which, if you've had to deal with Scala, is something we've taken for granted for a long time. Motion seems like a decent compromise if it catches on.
For me personally - some more performance optimization would be nice (im looking at you, Fibers), data classes (and generic types like Pair in Kotlin) would be cool, maybe some more functional-style/reactive features. I don't need much as i'm the early-adopting-type of programmer. For me professionally, in the other hand, it would be hard to justify a migration if it won't result in any additional business value as java 8 is already a fully-fledged language with tools to get any job done right and efficiently. Licensing of java 12+ induced so much confusion on the market that many companies will hesitate for at least some time to use anything beyond java 8 as it was last old-styled LTS version.
IntelliJ handles all the Scala related mess for me, it's just a couple lines in a pom file otherwise.
The least interesting thing about the Java ecosystem is Java. Cross platform and the massive library support are the best features.
JJWT does the trick (although we're stuck on v0.4 because it's pulled in via the Twilio SDK)
Well, first of all Google Cloud Platform will need to support JDK &gt;8 …
If I remember correctly, you need java 9+ to do it in a single jar. java 8 requires a separate jar for the alpn thing. I put together my own [archetype](https://github.com/nullterminated/react-archetype) that did http2 on jetty, and that's how it worked then.
Just use jlink without including any other libraries than the system libraries you need, to create a minimized JRE.
Oracle certifying that their own product that I work with is compatible with Java 8 would help.
Optional.ifPresentOrElse
For years
Grand features like this take time. There is some great progress being made as of late.
Wouldn’t this bug fix have been ported to Java 8, with it being a LTR?
Yep, your example uses Google's Conscrypt library to do the TLS. It supports ALPN which HTTP/2 requires. Problem is, it doesn't support SNI. I need both. Java 11 supports both out the box.
EOL, because that's the only thing that will justify it to management.
pattern matching preferred! https://cr.openjdk.java.net/~briangoetz/amber/pattern-match.html
The architects take many factors into account when adding a new feature, including readability. Take `switch` expressions for example. In my opinion, I would rather read this: int letterCount = switch(day) { case SUNDAY, MONDAY, FRIDAY -&gt; 6; case TUESDAY -&gt; 7; case THURSDAY, SATURDAY -&gt; 8; case WEDNESDAY -&gt; 9; } than this: switch (day) { case SUNDAY: case MONDAY: case FRIDAY: letterCount = 6; break; case TUESDAY: letterCount = 7; break; case THURSDAY: case SATURDAY: letterCount = 8; break; case WEDNESDAY: letterCount = 9; break; default: throw new WTFException(); } There is no fall-through, repeated assignment, or even a `default` case (since `DayOfWeek` is an `enum`). Readability will also be aided by records. Once again, I would rather read this: public record Point(int x, int y); than this: public class Point { private int x; private int y; public Point(int x, int y) { this.x = x; this.y = y; } public int x() { return this.x; } public int y() { return this.y; } @Override public int hashCode() { int result = 23; result = 31 * result + this.x; result = 31 * result + this.y; return result; } @Override public boolean equals(Object object) { return (object instanceof Point) &amp;&amp; (this.x == ((Point) object).x) &amp;&amp; (this.y == ((Point) object).y); } @Override public String toString() { return String.format("Point[%d, %d]", this.x, this.y); } } The architects go to great lengths to make sure that features fit into the language as if they were there from day one. If a language doesn't adapt to meet the current needs of developers, it will parish.
Everything you mark with ```provides``` in module-info is available through the service loader.
Didn't realize they were adding pojo type class definitions. I will agree that's a great addition!
Yes, you can read about them [here](https://cr.openjdk.java.net/~briangoetz/amber/datum.html). The proposal discusses records (product types) and sealed types (sum types).
Man, I really wish jumping from 8 was an option. Hoping to get there from 6 some day…
Best answer.
Seems like .net is bridging that gap with .net 5. I love coding in java, but seems like Microsoft is making some smart moves unlike oracle lately
Oracle's Lawyer Update
Java Dynamic Web Project. From there, you can decide which frameworks or technology you can use. Maven and Gradle is also good. Quick question: This Java application will call the REST API? Or will you will create the REST api?
https://blog.docker.com/2018/04/improved-docker-container-integration-with-java-10/
It will call a rest api
Fibers(project Loom). Having green threads would be cool.
&gt;[https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/Optional.html#or(java.util.function.Supplier)](https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/Optional.html#or(java.util.function.Supplier)) How's that better than the [java 8 version](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#orElseGet-java.util.function.Supplier-)?
This bug fix was not ported to Java 8.
What, that's basically a LoadingCache for a single element?
Fortunately they ended up backporting that to 8.
Docs on that?
You should be able to find it in the release notes, but here's a random blog post: https://blog.softwaremill.com/docker-support-in-new-java-8-finally-fd595df0ca54
We use this one, and it works without problems: https://connect2id.com/products/nimbus-jose-jwt
Java9 modules
Lightweight treading - using Java since ‘95
With my last project in Java I was already on the latest version, which was 10 at the time. In my next one I will go for the latest again. The only thing I'm currently torn on is that Graal only supports Java 8 and I love the AOT compiler. But I also love local type inference, and Loom and Valhalla and Amber are amazing too. (don't care about Panama) I so vehemently disagree with r/programming I don't know how to stress it more. Java is the best language, and I don't think the competition is close. It's clean, it's fast, it's easy to work with. My productivity with Java is insane, so far higher than anything else. On occasion I look into other languages and so far I've looked at kotlin, python, perl, elm, javascript, typescript, c++, c#, scala, rust, go and a few others. None of those are as good as Java. The only other language I sortof like is Groovy.
Value types will be one of the most significant improvements to Java since lambdas. If they can get that to work with algebraic types and pattern matching also, that would be great.
&amp;#x200B; &gt;... Now I'm using multiple primitive arrays and the code is awful! Did you consider using a library like fastutil?
My question was more for your own/hobby projects, when the decision will not come from above.
I prefer to be "forced" by the carrot, not by the stick!
Surely ```.flatMap(Optional::stream)``` alone is reason enough to jump to Java 9?
Make @Autowired great agian
I tried many approaches - no significant speed difference. When I write the code in OO style (really beautiful to read, easy to understand and etc.) - it becomes ~3 times slower.
Here is the list of [open source Jwt library in Java](https://www.findbestopensource.com/tagged/jwt-library?fq=Java) You can choose JJWT or Java-Jwt from Auth0.
Is OSGi still a thing? (serious question)
Personally I think OSGi is to niche to even bother learning about it. If you are not writing an application server or an IDE, I think is easier to just go the microservice route with spring boot or microprofiles.
You might be interested in checking a project JUnion, which I'm working on [https://github.com/TehLeo/junion](https://github.com/TehLeo/junion) It adds support for struct types with performance of primitive types. Currently, a working pre-release is out, but at the moment I'm in process of redesigning it. If you like it you can also give feedback/ request features.
Yes, OSGi is still used in products like Jira, Eclipse and Adobe Experience Manager (quite popular marketing framework for large corporations). It takes an advantage in large modular applications that are looking for class path isolation for "components" coming from different vendors, teams, etc. That's an alternative to microservices, I would say.
Sure, OSGi is not a bullet-proof solution for all applications. However, if someone is going to use it anyway, code/design quality matters as same as regular codebase written in Spring.
Adobe Experience Manager is not a marketing framework, but an enterprise content management system. It's a part of a bigger ecosystem, called Adobe Marketing Cloud, which provides things analytics, campaign management. They can be integrated with AEM, of course. But AEM on its own is a CMS. It's very complex, has a lot of features and possibilities to customize it, though.
Liferay (open-source portal) uses it very extensively
Speaking from Shenandoah perspective, you don't have to migrate to newer Java releases to get it. Red Hat builds of OpenJDK (which are picked up by many RHEL-derived distros) ship with Shenandoah backports to 8u and 11u. Most of our (Shenandoah) users are firmly on 8u, and few are on 11u.
To convert to base word is called stemming. You can look in to porter stemmer algorithm. Below link has implementation in different programming languages. [https://tartarus.org/martin/PorterStemmer/](https://tartarus.org/martin/PorterStemmer/)
Agree, that's the CMS of the bigger marketing framework - I simplified that bit :)
Had to laugh at this because I recall in the early days of Java, the Solaris implementation of the JVM only had green threads for a while after the Windows version had native threads. That was seen as an *embarrassment* by the leadership at Sun until it was fixed. Now here we are and thinking green threads are the way to go. What goes around comes around.
That's great! I worked with it in 2010, but I moved to other projects and I was curious of its current state when I saw this post.
What I find weird about OSGi is this seem to only apply to java... why can't you find something similar like this in C#, JS, or even python? Yes, there's always some DI frameworks, but shouldn't OSGi apply to other languages as well?
It depends on what you are doing. If you are programming a microcontroller, Java isn't really an option. even C++ has sometimes too much overhead and falling back to C is the best option. Likewise, depending on your market, PHp isn't a bad choice. Its supported by every webspace, so if you are targeting private consumers thats often a better choice then Java - not because PHP is better, but because its economic the better choice. Similarly, while Java is by far my favorite language, there is something to be sad for the simplicity of Node.js. What Java lacks is a small, lightweight web server built-in and a lightweight framework on top of that. C# also has some very nice language features that java is desperately missing. All things considered, java is a very, very strong language with a very strong ecosystem, and for complex applications I would always consider it my first choice, but sometimes it not bad to look around and also consider other choices.
OSGi just isn't that great.
Are you working on multiple microservices at once on your own? It sounds like you have prematurely distributed and don't need microservices at all.
Yes, but you need some extra JVM options to explicitly enable it, those are not needed anymore in newer versions.
Nope! They did a second backport, and now you don't need to set anything.
Eclipse Kura (IoT Edge Framework) uses it as well. Not sure how popular Kura actually is, but it's conceptually a nice fit for IoT edge.
Am i the only one having more questions and very few answers after reading this article?
No, that's why I posed this question :)
I used osgi quite extensively in a old project when using eclipse as ide. Now i moved to intellij and in the past (about a year back) had really big troubles getting osgi working at basic level with intellij. With eclipse you had a nice plugin, intellij osgi plugin seems old an abandoned. There was a maven plugin offered by osgi folks (an old one and a newer one) but it was all quite confusing. &amp;#x200B; Is there a "correct" way (best practice) on getting osgi working nicely with maven projects in intellij?
i tried that recently but i could not open jar files via double click with it. Did you have to change something in the registry or did it just work for you?
I still remember urlconnection from the old days, what a wonderful class that was! But strangely enough i still tend to use it...
Victims of the 6-month release cycle?
Fair point, I sometimes forget that not every new feature is an upgrade, and how much hard work the Red Hat folks put into backporting make Shenandoah easy to try/test. Thanks for the reminder and for all the engineering you do to make the JVM better.
After a few searches I found some more details on Project Sumatra: https://adtmag.com/articles/2012/10/01/openjdk-project-sumatra.aspx The original mailing list announcement of the project: http://mail.openjdk.java.net/pipermail/discuss/2012-August/002717.html where it says the HotSpot team will be taking this up, but there is nothing on the HotSpot website on the status of these kinds of projects: http://openjdk.java.net/groups/hotspot/ &gt;Sumatra has roots in a project started a few years ago by AMD, called "Aparapi," which aimed to allow Java code to be executed on GPU and Accelerated Processing Unit (APU) devices by converting Java bytecode to OpenCL at run time. The Aparapi API allowed Java developers to create their projects in pure Java, and then converted that code at run time under the covers into OpenCL (the open standard language for parallel computing), which would execute on the GPU. The performance improvements were impressive, Frost said, reportedly as much as 60X. Sumatra takes that external Aparapi API and brings it into the JVM itself. &gt;The Aparapi project, which was open sourced in 2011, is still "alive and vibrant," Frost said, and he expects feedback from it to help with Sumatra. Some of the contributors to the Sumatra project are current users of Aparapi, he said. But the last commit for that was 9 months ago: https://github.com/Syncleus/aparapi/commits/master and most commits are by a single user.
TBH it always seemed like a not-so-great idea to me. Setting up computation to happen on the GPU is really nuanced and has a lot of gotchas (that's why the APIs that let you do so usually have hundreds of different enums/settings you have to set before you can even do anything). And then it's pretty tricky to set up your computation such that it actually benefits from running on the GPU, particularly considering that there is a huge overhead of transferring data to the GPU first, and secondly because there are many different GPU models/drivers which sometimes have different performance caveats (like separate vmem vs. UMA). I also don't really subscribe very much to the concept that everything has to be in java (or whatever language -- most language communities try to do this, like cython) -- if you interact with a database, use SQL, if you interact with the GPU, use OpenCL, CUDA or similar. There's a huge amount of effort and a huge loss of functionality when you layer another thing on top of the thing that's actually being 'natively executed' -- usually the abstraction is really leaky. As I see it there's two scenarios; either your GPU kernels are going to be very complex and are the 'centerpiece' of your software, in which case you'd want to write them directly in CUDA/CL anyway (both of which is perfectly possible in java) because otherwise the loss of functionality, perf etc is pretty critical to your project -- or your kernels/queries are pretty small, in which case it's no big deal to just leave them as opencl/sql etc anyway? The only people I can see benefiting from this kind of thing is people who are looking for a quick speedup of something simple and they don't want to bother really investing into anything in particular (who want a 'just make things faster' switch) anyway, sorry for the rant, just my 5ct. I've written pretty large quantities of both SQL code and OpenCL/CUDA/GLSL, so maybe I just have a pessimistic outlook on these kind of abstraction layers.
&gt; A statement that uses string interpolation This require corrections. As I understand Slf4J has: public void info(String msg); public void info(String format, Object arg); public void info(String format, Object arg1, Object arg2); public void info(String format, Object... arguments); So worse case only if 3 or more args call is used because of array creation.
Project Panama is in active development, see http://openjdk.java.net/projects/panama/. Panama is not yet faster than JNI, but this is to be expected: https://mail.openjdk.java.net/pipermail/panama-dev/2019-March/004834.html
If your project is Bnd(Tools) based, give this one a try: https://plugins.jetbrains.com/plugin/10639-amdatu
Nice study
No, the 6 month release cycle is supporting many multi-year efforts.
My apologies, i was in the understanding that you wrote the article, or found it interested to post. Having it as a illustration to your question makes more sense.
Project Valhalla is under active development. [Here’s](http://mail.openjdk.java.net/pipermail/valhalla-spec-experts/2018-October/000760.html) Brian Goetz announcing that the project has entered “Phase III” last October: &gt; So, I think this demarcates the start of Phase III -- where we have a solid enough proof-of-concept that we can largely graduate from the "risky experiments and wild theories" portion of the program (at least for the VM). Fantastic work from everyone involved to get us here! You can see more recent discussions on the [valhalla-spec-observers mailing list](https://mail.openjdk.java.net/pipermail/valhalla-spec-observers/) and track development on [valhalla-dev](https://mail.openjdk.java.net/pipermail/valhalla-dev/). If you want to test it out, there’s an EA build at https://jdk.java.net/valhalla/. If you’d rather build something more recent, check out https://wiki.openjdk.java.net/display/valhalla/Main#Main-SourceCodeandBuildingValhalla. I don’t think they’re at a stage to estimate a release date for it yet, but it’s chugging along.
which they have to be, chasing after a moving target
try chaining them. It is getting really ugly. With `orElseGet` you basically get either/or. But what you actually want from daisy-chained fallback logic is `List&lt;Supplier&lt;Optional&lt;T&gt;&gt;&gt;`. A list of Lazy-evaluated optional responses. Check this answer how it needs to be done in Java 8 https://stackoverflow.com/a/28514843/2787159
I am not familiar with ´LoadingCache`. From the description, it seems like a lazy`HashMap\`. It does not seem to fit for the use-case of chained lazy fallback options. My use-case is something like: final String configValue = loadFromEnvVariables .or(loadFromSystemProperties) .or(loadFromDeploymentProperties) .or(loadFromDefault) .orElseThrow(() -&gt; new UnknownConfigOptionException());
It looks like in your [submission](https://www.reddit.com/r/java/comments/btn4xk/help_me_with_this_project_please/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Alright, thanks for clarifying!
let jvm get SIMD on the CPU right before worrying about GPU. There's no proper vectorization if any and to talk of GPGPU is well... ambitious to say the least.
literally the opposite
There is video from very recent talk on progress in projects Amber, Loom, Panama and Valhalla, from Mark Reinhold at Devoxx UK - https://youtu.be/kpio9jFhpD8
I see, yeah that's a difference use case :) The chaining is quite nice
Just because they have a six month release cycle doesn’t mean they only have six months to develop a feature. When a feature is ready, it will make it on the next release.
&gt; What Java lacks is a small, lightweight web server built-in and a lightweight framework on top of that. Springboot is lightweight enough.
I watched the entire thing. Actually it's exciting stuff! So that leaves Trinity and Sumatra. Little news on that?
I still think it is pretty bare bones. For example, you still have to construct a query-parameters string using a combination of StringBuilder and URLEncoder. OkHttp has the class HttpUrl.Builder for easy construction (and parsing) of correctly encoded URLs. I really hoped for something similar for the JDK.
Jpackager will take care of that. It is currently targeted for JDK 13.
Also has EA builds here: http://jdk.java.net/panama/ Or recent talk: https://youtu.be/M-FPNBFAoSo (which also goes a bit more into the performance part)
No explicit vectorization: http://prestodb.rocks/code/simd/ - true. I wonder if there are any plans for that.
Yes, but it's not built-in. HTTP POST/GET is the new standard out/in. Having a basic HTTP server would simplify things for people who are new to the langauge.
I since learned that, so from that list from the linked article, that leaves the status of Trinity and Sumatra unclear?
Here is a small performance comparison: https://github.com/skjolber/java-jwt-benchmark
I agree, it 's an improvement and I'm all for it, but the above could have been written as a function: int letterCount(Day day) { switch (day) { case SUNDAY: case MONDAY: case FRIDAY: return 6; case TUESDAY: return 7; case THURSDAY: case SATURDAY: return 8; case WEDNESDAY: return 9; default: throw new WTFException(); } }
The project I'm currently working in (about shy of 1MM SLOC) switched from Eclipse to IDEA about a year ago because eclipse was brought to it's knees when opening that project. IDEA works just fine, takes a minute to load but then operates about as smoothly as with a single file project.
Surely, but this is just one example. If you wanted to print out a value rather than store it in a variable, the updated `switch` makes that a lot cleaner too. `switch` will also be extended further to support [pattern matching](https://openjdk.java.net/jeps/8213076).
Sumatra seems to be put on the shelf - its mailing list is dead for about two years and proposed to be archived. Trinity has been vanished from web site at all and you could find its traces in mailing list, all from 2017. So I suppose it wasn't under development or research.
lol -15 downvotes.. wow.. some butt hurt people out there. :( or a jetbrains army downvoting any pro Eclipse comments.
I would love for this. It would literally speed up my code about 3x and make it on par with C++. Lots of heavy matrix math.
exactly... that's the power of Eclipse workspaces. but never mind. i got -15 and guy i replied to got 38. I tried IntelliJ incremental compilation it was slow. And you don't have workspaces anyways. post got brigaded.
I am looking into classloader isolation solution and it seems OSGi, especially the Classloader specification is wonderful. The whole OSGi spec is a 400+page book if you are into services, security, etc... but the Classloading isolation spec is small and very useful. I am in need of a way to allow plugins/integration with other teams. If we use standard Java package sharing mechanism, sooner or later teams will run into dependency conflict hell. More often, microservices (IPC) is suggested, too. But, the nature of our application is sensitive to latency and require high throughput. That throws IPC out of the picture. Then, I remember the servlet API and how the servlet spec dictates classloading isolation at the container level. I rolled my own classloader to isolate the plugins/integrations but it is not as nice as OSGi implementation. At this point, I am very inclined into using OSGi just for the sole classloading purpose. One question that bother me is: since we are not that hardcore OSGi users, would it make sense for us to just bundle every plugins' into a fat jar and use bundle-classpath to resolve the plugin's owned dependencies? I know that by doing so, we are not strictly adhere to OSGi classes' sharing but it would lower the friction for independent teams to integrate with us.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
There should be a business name for that particular case. If there is not, then it could be bad modeling of the business domain. Nobody talks about "without tax" and "with tax" but net and gross for example. From glancing the table should look more like * FruitType * intial cost * inflation * escalation * discount * ...
Your domain model doesn't have to follow your database model. In a relational database, the column names (often) include a lot of information about the context of the data. In object oriented design you can encapsulate data so that it only needs to make sense in that context. So for example : class Apple { List&lt;Cost&gt; costs } class Cost { CostType costType Boolean withInflation Boolean escalated } This is just an example of course, you might come up with a more practical model depending on how you read and write the data.
1. Maybe link your sections in your table of contents 2. Use text instead of images in 9) results 3. You should mention that any micro benchmark should be taken with a grain of salt as it does not reflect real life scenarios. Actually I am really missing a blog post about that statement as there are many posts that are similar to yours already which mention it but never fully explain what it means Solid post :)
What if we have to deal with bad modeling? In our case we can't change how the client made the database. Can the unclarity of the code be somewhat excused?
I have implemented a board game in Java some time ago and optimized the hell out of it. Logging was only necessary for debugging purposes so it was disabled when e.g. genetic algorithms ran. My tip when performance is crucial: make a slim wrapper around whatever logging library you are using and a `private static final boolean LOGGING_ACTIVE;` flag and change it while compiling your code. Javac or the JIT will constant fold it, inline your now empty log-method and effectively eliminate any overhead.
Why not?
Both Closed- and Open Liberty, as well as GlassFish and Payara use OSGi extensively.
Yes, value classes (recently renamed to inline classes) will work with records, sealed types, and pattern matching.
Interesting read, thanks!
Thank you for this good solution. I guess I should spend more time thinking of creative solutions like this. I believe for functionality that just exists in the back-end, an approach like this is perfect. But quite often I am forced to make objects the way the front-end developers want in our REST API. I think in times like that I should just take a small risk and have them try out a solution I thought of.
Most annoying thing about 8 is having to cast the result of `ByteBuffer.flip` to `ByteBuffer` from `Buffer`
A vector API is being developed as part of project Panama. Some of the key missing pieces that remain are the results of project Valhalla and also lambda cracking.
It looks like in your [submission](https://www.reddit.com/r/java/comments/btqq13/can_two_threads_each_targeting_a_different/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Database framework can make the abstraction. for example, hibernate default on the parameter name, but can be customized using @Column.
There’s a bnd maven plug-in to generate a fat jar with the dependencies needed to resolve everything at runtime.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
The typical software engineering approach is to create your applications with multiple layers, So for example you'd have : - a presentation layer, exposing your domain the way front-end developers want it in the REST API - a business model layer where you represent the business domain in a practical way that allows you to code - a database layer, that closely resembles the way the data is stored in the database. Often, one or more of the layers is automatically generated from your domain model but YMMV. I like to draw it out on a paper first and then have the code follow that approach so that it follows a consistent logic, making it more maintainable and shareable. One typical pitfall developers meet is the intuitive reflex to write as little classes as possible ("less code to maintain"). often times making code "clean" (I would add testable) means separating the purpose of each class even if it means some duplication.
Agreed. I wish I was able to get my hands wet with Hibernate... our current project was engineered to avoid it for specific reasons (could be complexity?). We make our complex SQL statements directly in the repository layer. I should actually utilize stack-overflow more. I recently have been using Baeldung as well but more for quick "how to" guides.
You have to map it. There are some good examples in this thread. Better examples can only be given with more domain knowledge, thus it is quite difficult to model a good abstraction.
Personally, I'd do something like this: ``` interface Cost { BigDecimal getWithInflation(); BigDecimal getWithoutInflation(); } interface Product { Cost getInitialNormal(); Cost getInitialEscalated(); Cost getDiscount(); } // then this: interface Apple extends Proudct{} // or replace the Product interface with this: interface Product { ... // the code above // add this method: getProductType() } ``` There are many ways to tackle this. You just have to do it in a way that makes sense for what you're doing with the program. As for the names in the database, as long as the names in your code are consistent and they map consistently, it will be fine. Once you lose consistency, all hell breaks loose.
I started looking into https://dzone.com/articles/layered-architecture-is-good . Right now our domain classes are in Groovy (each main screen has its own package). Then in Java we have packages for our Controller, Service and Repository layers. Correct me if I am wrong, but the thought is to divide up the Groovy packages by a presentation, business and database layer (modularization)? So that we would have to process data from the database layer object to a business layer object for us to use, and eventually from the business layer object to a presentation one to show front-end? So if the database layer object looked like the sample one I made in the original post (for ex.), the business one could be your solution? But if I grab the data as-is with your solution from the get-go, then the objects could be the same it looks like. I'm trying to wrap my head around this a little...
[https://github.com/mxmlnkn/rootbeer1](https://github.com/mxmlnkn/rootbeer1) &amp;#x200B; seems to be dead, too... :-( &amp;#x200B; Maybe FPGA JVM's will give us similar speedups...
We've recently switched from Android native to Flutter. So based on my experiences: Pros: \- Productivity \- It's really fast \- Modern \- I really love Dart because the Dart team focus on making this language special for UI-as-Code concept. \- Dart compiler, It supports both AOT and JIT, so in the sake of that you will have hot reload feature Cons: \- Localization sucks (but can be fixed with an intellij idea plugin) \- JSON (de)serializatio sucks \- Dart has no extension function (but I think it will be added in future) \- Working with **some** native features is a little bit hard.
Everything...
Hi, so my post was not about seeking homework help. I am trying to understand a Java concept and to get my question answered, I had provided a fully working example program. Why is my post still blocked?
Stream.flatMap() is lazy instead of eager
You are confusing Scala string interpolation with [parameterized logging with SLF4J string templates](https://www.slf4j.org/faq.html#logging_performance). See [the code under benchmark](https://github.com/wsargent/slf4j-benchmark#raw-debug).
Based on the column names, looks like your table is not normalized.
&gt; Microsoft is making some smart moves Such as..? (asking as someone who doesn't follow .net news)
The joys of upgrading the JAXB dependency
Quick question, how doe AoT compilation prevent reflection?
In this specific case I would start with a class which exactly matched the DB, even with the crazy long property names. Use that to get data via SQL into/from the table. Then make a better structured domain object, and use the first class to instantiate the better object. Then you use the better object in your calculations or processing. This way you separate out the database and SQL shenanigans from the actual object. As many others have noted, your actual object is probably going to look very different from the table. You may want to look into jOOQ. I had to do this precise case (a client database which cannot be altered) a few months ago, and jOOQ simplified the DB parts. You point jOOQ at the DB, and it generates classes which match the existing tables.
Use the newer maven plugin. Best practices for getting started are [described here](https://enroute.osgi.org/). There are a couple of intro tutorials and some maven archetypes.
Nice tip. I wander if it possible to make this pluggable. Like compiling `private static final boolean` into separate `.jar`... So `enable-debug.jar` or `disable-debug.jar` on `CLASSPATH` do correct job...
I do not know if this can be attributed to Uncle Bob.
It's very interesting since even when displaying the data, the requirements are to be able to edit columns with similar names like that on the same screen. For example they could have separated out the discounts, cost and price into their own sections. But it *seems* like it was intentionally done that way. Some tables we encountered seemed a bit *too normalized* but then there are cases like this where it doesn't seem normalized enough and they don't seem to care lol
It's very interesting though. In this particular case they just want CRUD functionality. Even the screen they want to display has all the column names long like that above the input fields for the users, with no distinct sections for the discount, cost or price. Your idea is great where I can make my own object which I can map to, to make it easier to do calculations and whatnot if needed. But that's the thing... in this case it's just CRUD functionality. Or is the case to make a readable object anyways? In case if they want to add functionality based on specific cost, price, discount etc?
But what if all the client wants is CRUD functionality? I should have been more clear before lol. It's not like there are any calculations or sections based on type, cost or price. Even the users who will use the system will see super long names like this above the input fields. Is the thought to map it to a better object for possible future functionality?
What if the requirements are just for CRUD functionalities, where even the users will see these super long names above the input fields? Everything jumbled up in one screen (it works for them though). Is the thought to design for possible future alterations anyways?
&gt; who want a 'just make things faster' switch That IMO is a very big market. It will simplify development and improve portability of video codecs, for example. Indie games is another area, where a boost in rendering (without the complexity of C/C++) would be a decisive factor in choosing Java for development.
It prevents effective tree shaking, see rationale [here](https://flutter.dev/docs/development/data-and-backend/json#is-there-a-gsonjacksonmoshi-equivalent-in-flutter).
If you want to fully understand it, you need to understand reactive programming as well : [https://spring.io/blog/2016/04/19/understanding-reactive-types](https://spring.io/blog/2016/04/19/understanding-reactive-types) I liked this series as well : [https://spring.io/blog/2016/06/07/notes-on-reactive-programming-part-i-the-reactive-landscape](https://spring.io/blog/2016/06/07/notes-on-reactive-programming-part-i-the-reactive-landscape) It is not about understanding CompletableFuture in details but grasping the big picture of asynchronous programming. &amp;#x200B; For details about CompletableFuture, I liked : [https://www.baeldung.com/java-completablefuture](https://www.baeldung.com/java-completablefuture)
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
 &gt; Your domain model doesn't have to follow your database model. It doesn't need to, but it can save you (and others) a lot of headache, especially when the database is in a different language. If the application and the database model differ, you always have to go through one layer of translation to map between them, both in the code and in your mind when working with the code.
Tomasz Nurkiewicz blog on it has a good overview and dived into some details/common problems as separate posts: https://www.nurkiewicz.com/2013/05/java-8-definitive-guide-to.html Or if you enjoy it in talk form(has example comparisons of old-style vs CompletableFuture style): https://vimeo.com/131394616
 &gt; "Literally anything but Java. It's so old and stuffy and stagnant. Impossible to get any work done with it." Most programmers running around on Reddit never had to deal with code bases that are 30 years old, nor did they ever need to create a solution that is also supposed to last 30 years. So they tend to be in that nice little bubble were a dependency upgrade through NPM is done within a few minutes with deployement and switching to a different framework is maybe a person month of work. Meanwhile, Java projects tend to be old, they tend to be big and they tend to be important. Downtime is one of these things you can't allow and having subtle bugs being introduced with a library update can be existence-threatening to multi-million/billion euro companies. What you also always hear is "it took me literally half a day to upgrade my project to Java 9+", but that doesn't scale well. If you have a 20 year old project which a multi-million euro company with hundreds of employees depending on it, ***nothing*** is being done "just like that". As I said, most seem to lack that experience, or they blissfully ignore it.
You may find this presentation really useful. It starts with parallelism on stream api. Then goes into completablefutures an so on. https://youtu.be/x5akmCWgGY0
 [https://www.youtube.com/watch?v=kpio9jFhpD8&amp;feature=youtu.be](https://www.youtube.com/watch?v=kpio9jFhpD8&amp;feature=youtu.be)
wow!!!
Someone else linked this, I watched it entirely, and answer my question. Except for: * Project Sumatra * Project Trinity
What is the license on this one? Just wondering. I must admit i never had much trouble with java on the client, just package the entire thing and generate a installer with maven for inno setup.
So I read the article and understand what the author is trying to project but honestly it doesn't make the situation any less concerning. &gt;Oracle JDK / Oracle OpenJDK builds and OpenJDK builds from other providers will be built from the same source for the first six months of updates and should be interchangeable for that period. After six months Oracle JDK / Oracle OpenJDK builds will be built from Oracle’s own fork. So for 6 months you can assume the builds are interchangeable, but after that no guarantees. Take away here - pick a release and stick with it. If you're willing to pay for a license go with Oracle, if not go for OpenJDK. The author then makes this comment &gt;The crux of the issue is the idea that over time, we will see a divergence of the Java platform as different distributors of OpenJDK binaries provide slightly different implementations from the Oracle JDK. Now he immediately states after this paragraph &gt;There are a number of reasons why this will not be the case and, in effect, nothing is changing. This might be his opinion, but I know many folks in various industries that think the drift will be happening and is a concern. His argument is that there is a group that handles vulnerabilities jointly and that they'll work together for all builds. Perhaps that is true for security but then he asks &gt;Who does this backporting work depends on who provides the binary distribution. I know the various Oracle reps who watch these forums and regularly post seem to gloss over this issue, but for many enterprises upgrading every 6 months to a new release that may or may not have backward compatible changes isn't something they can or want to absorb. Go look at the various other threads that show just how many organizations plan to stay on Java 8 to see what I mean. This is the major complaint with the change in the version numbering scheme away from the more common [Semantic Versioning](https://semver.org/) approach that was used up until Java 9. Yes everyone should read the release notes, but being able to see at a glance if an upgrade is a bug fix or breaking change impacts project plans. &gt;The April JDK update was different from those in the past, as it was the first time Oracle did not release a public update for a long-term supported version. The only free public update from Oracle was for JDK 12. &gt;Engineers at Red Hat, in conjunction with others from the likes of Amazon and IBM backported the changes and immediately upstreamed the changes to the OpenJDK 8 and 11 update repos. Azul’s engineers did the same, independently. So enterprises are now evaluating that either they need to depend on groups that do not control Java to keep versions up to date, or the pay the licensing fee to Oracle for support of the older versions. &gt;Under the new release cadence, Oracle upstream all changes they make to the current OpenJDK repository only. The changes for the most recent update (in April) were upstreamed to the OpenJDK 12 repo. Then there is the concern that, as has been posted on different threads by some Oracle employees, OpenJDK is owned by Oracle. So what happens to OpenJDK should Oracle decide they aren't making enough money off their commercial licensing? Do they pull the plug or stop upstreaming their changes? Nothing would prevent them from doing so. I know for the firms I work for a good deal of review is happening with regards alternatives to Java that I didn't see just a few years ago. Considering a number of enterprises are using or planning to use public clouds, new solutions like Golang, Node.JS, Python and even Webassembly are being considered more seriously. Time will tell if we need to **Fear the Java** or not.
I'm not familiar with the checker framework, but i looks a lot like the "analyze inspect code" feature of intellij. Which, when run, generates a huge amount of tips and warnings. I find it extremely useful to run it after big code additions. Problem is deciding on what is important and what's not. For every single rule their are most likely huge discussions online. It isn't a easy subject, but one well worth your time.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Looks like [3-clause BSD](https://github.com/gluonhq/client-maven-plugin/pull/1/files#diff-9879d6db96fd29134fc802214163b95a).
&gt;... GluonVM, we said we would aim to bring Java on mobile at the same level as Java on desktop. When they say 'mobile' does that include Android?
That's a cool one if it works. Of course, until is available on at least the 3 major platforms (plus a 4th one, freebsd) it'll be quite useless. But hey, is a step in the right direction and hopefully it won't take too long to port it once the proof of concept is done.
Wow this looks great! Is there any "catch" to using this other than the complexity of implementation? Also it might be nice to have a memory usage comparison as well as how much garbage it creates.
Different binary distributors providing slightly different binaries is nothing new, and nothing to be afraid of. Just look at Linux distributions: It is completely normal that a source package contains patches written by the package maintainer, and that the binary package will differ from what was shipped on day one, even if the major version number stays the same. As long as these maintenance-forks stay compatible, everything is fine. It's the job of the maintainer to back-port security fixes and provide long-term support, and it's the job of upstream to move the project forward. Enterprise distributors pay maintainers to do the boring job of back-porting fixes, so they can keep their promise and sell long-term support to customers. That works fine for a lot of software. It will work fine for java, too.
One department in a huge Ukrainian bank switched to Go when Java 7 was the thing. Because execution environment &amp; language is not as important for simple batch jobs, REST/SQL calls. Before they had *OSGi &amp; application server disaster*. Overengineering accompanies Java. Look to serverless offering when 3 lines of JS code solves business task while with Java you are picking ORM mapper and WEB framework few month before work can be done.
&gt; If you're willing to pay for a license go with Oracle, if not go for OpenJDK. Or do the default, and just use the most recent JDK, unless you have a very good reason not to (not understanding [what LTS and the feature releases mean in the context of the JDK](https://www.reddit.com/r/java/comments/bt4qri/upgrading_from_java_8_to_java_12/eouj9vq/) and making assumptions based on other projects is not a good reason). Between the two brand new update models you must choose from (neither of which is the same as the old one), this is the option designed to be the easiest and cheapest overall. &gt; So enterprises are now evaluating that either they need to depend on groups that do not control Java to keep versions up to date, or the pay the licensing fee to Oracle for support of the older versions. This has always been the case. All JDK versions end their free public updates after 4-6 years (JDK 8's ended after 5), after which users have had the choice of either buying support from Oracle or from someone else. &gt; Then there is the concern that, as has been posted on different threads by some Oracle employees, OpenJDK is owned by Oracle. So what happens to OpenJDK should Oracle decide they aren't making enough money off their commercial licensing? Do they pull the plug or stop upstreaming their changes? What matters is not that Oracle owns OpenJDK, but that it contributes &gt;90% of the work (the vast majority of OpenJDK contributors are Oracle employees). To do that, Oracle must be able to fund this work. Java has always had some funding channels. Early on it was licensing Java for mobile phones and other embedded uses (I think this may still be done), then we had that annoying search toolbar and the mixed free/commercial JDK. Now that Oracle has completely open sourced the JDK, the main funding channel is Oracle support subscriptions.
Of all the platforms for an initial beta, you did not choose the one 9 out of ten people have, you did not choose the one that is FOSS and literally everyone can easily obtain, no, you chose the one very few have and sits behind a multiple thousand dollar paywall ಠ_ಠ
yes
In this blogpost I wrote a solution for validating phone numbers using Libphonenumber and Hibernate Validator, two Java libraries which combined are a great fit for this.
I have to agree. It pisses the hell out of me when developers release multi platform applications that only run on their computers because Docker or whatever. And there’s always a lame excuse to justify this sort of behaviour.
&gt;Today, we are very excited to announce that we are working on an additional approach to create native applications using Java and JavaFX. With our new Gluon Client plugin, your Java Client application and all required dependencies are compiled into native code, which can directly be executed on the target platform. One of the advantages is a much faster startup time, as we don’t need the JVM to start anymore. Sounds close to what helped fuck over applets in the 90s. Instead of write once run anywhere, now you will have write once, makes sure you have the right plugin, then run.
Depending on the scenario your approach is more sane than mine :) Good idea
To be fair to them I assume the reason is as follows: - Windows packaging requires a bunch of 3rd party stuff - Linux is still fairly segregated when it comes to distros and packaging with limited cross distro support (and flatpak is still far from great unfortunately) - macOS has out of the box executable bundling Making it an easier first step. Others are coming soon anyway.
I was reading this and thinking "Man, these bifurcan LinearX data types seem pretty consistently ahead of the curve, I should look them up" and then did a google search that took me back to the same page, and realized this was, in fact, posted on the /bifurcan repo, lol. Still pretty sweet stuff.
Their plugin sounds like a build-time thing (although I am not sure what the plugin plugs into...gradle/maven?)
What platform would that be? I tried finding it on their site, but did not.
Setup on windows is a complex thing, using a matured third party product like innosetup is a good thing. I always am a bit easy on the other platforms, just offer a zip and most users can unzip and call "java -jar" (or double click a file) on their own. I can of course imagine that this isn't going to work on big businesses, but that is not a very big target audience. And they can easily pay for the professional setup packages that are multi platform and everything you ever dreamed of ;-)
Oh they will most certainly go the InnoSetup route in the future, but I imagine they wanted to check that the foundations are solid without complex packaging around first, and then move on to the more meaty bits. Also since Gluon and JavaFX are mostly about desktop applications, the `java -jar` route really is not ideal in this case, especially as AoT compilation and custom linking they provide work best when embedding the target JDK subset directly, meaning that `java -jar` approach is even more brittle. But yeah, it's not fully NEEDED, but really appreciable and a huge push up for the JavaFX ecosystem :-)
&gt; and nothing to be afraid of Well, this [could be a problem](https://mail.openjdk.java.net/pipermail/jdk8u-dev/2019-May/009330.html). Best to rely on package providers with a good JDK reputation.
&gt;At this moment, we are ready to open a **beta-version** of the Gluon Client Plugin that is capable of creating Java(FX) 11 applications running on MacOS X. Linux and Windows support, and support for Java 12 and beyond is expected shortly.
Ah! Now I completely understand the "WTF?" attitude behind your comment.
Great article! I'd personally add a conclusion, but the content was great and got right to the point. What would be interesting to see as well would be a comparison of memory footprint of large (1M) element data structures
If it's based off their Gluon Mobile product or incorporates it, and it seems to: &gt;Gluon Mobile provides: &gt;Tooling to build and deploy your Java app to desktop, Android and iOS platforms &gt;Glisten, the UI component that offers JavaFX Controls that have a cross platform behavior, but a platform specific look and feel. They make your application look like a native application. &gt;Connect, the API for communicating to Gluon CloudLink or other 3rd party webservices. &gt;Down, which makes device APIs available in a device-independent fashion, like the storage systems, accelerometers, screen details, GPS devices, and more.
Bugs happen. In an ecosystem with multiple competing distributors, we can at least choose and try to avoid the bad ones.
I like Adam Bien, Java Pub House, and a bootiful podcast
still no java11 build for freebsd (that I know of at least) - I think it's asking a lot for anyone else to support it.
&gt; about JAVA About what?
Are you a bot?
I recommend this video [https://youtu.be/-MBPQ7NIL\_Y](https://youtu.be/-MBPQ7NIL_Y) by Tomasz Nurkiewicz also.
No. ^Bleep ^bloop.
&gt; you did not choose the one 9 out of ten people have I'm sorry.. Are you suggesting that 9/10 people use Linux, or Windows. Both are totally wrong, especially among developers, but one of those is way more wrong.
&gt; After six months Oracle JDK / Oracle OpenJDK builds will be built from Oracle’s own fork. Looks like a copy-paste error. I think after 6 months there are no more new Oracle OpenJDK builds, only Oracle JDK builds.
It looks like in your [submission](https://www.reddit.com/r/java/comments/bu3nv0/can_anyone_explain_why_this_code_breaks_java/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
It looks like in your [submission](https://www.reddit.com/r/java/comments/bu3p5v/i_break_java_compiler/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Um, what about memory usage per element in the collection being benchmarked? What about scalability past say 30-50 million entries?
Sad!
I miss the good old days of javaposse...
Kudos for bifurcan, but good to see the Java Standard Library doing so well.
What are your thoughts about adding this to r/javahelp and r/learnjava as well? I see that you are a moderator for those subreddits, too.
Take a look at the announcement for .NET 5. No more "legacy .net" and .net Core. It will all be merged into one framework/platform and with expanded features targeting all kinds of platforms. *nux, Mac, Windows, web, desktop, various mobile. Just need a full fledged "IntelliJ" for .net (if Rider would be a 100% replacement for VS) and it's mighty promising.
if no domain expert knows a better name and no functional and business requirements pushes better modeling you are stuck on that namespace. &amp;#x200B; If you suspect it is required in the future you could do it, but YAGNI!
*Beep boop* I am a bot that sniffs out spammers, and this smells like spam. At least 66.67% out of the 3 submissions from /u/OnlyCombination appear to be for courses, coupons, and things like affiliate marketing links. Don't let spam take over Reddit! Throw it out! *Bee bop*
Good idea. Will do it tomorrow (CET).
No problem! Thanks!
Where are the tips?
has to be one of the worst API's designed in existence. 50+ methods all with strange names...
They'll get my upvote once they support Windows and Linux.
&gt;the projects … have a large group of contributors What? Not by any relevant metric, they don't. Not JavaFX, anyway, and the rest (Java, GraalVM, etc) is meant for use on servers. I'd certainly *like* to use JavaFX for my next desktop/mobile app, as the API looks far more sane than DOM, but unless by some miracle it becomes as relevant as Electron, I can't afford to risk it. I need my apps to still work on contemporary devices in 10 years, and I see little reason to believe JavaFX will still be maintained by then, especially with Apple breaking legacy apps on a yearly basis.
I think you’re building runescape classic
r/gamedev
Games are great for learning because they touch so many different domains. Thanks for sharing. Would you say that making those videos helps you with development, staying focused or motivated ?
I'm not sure if it helped with the motivation or any of the development aspects but it's been really cool to see how many people have something nice to say and how much support it's gotten :)
I feel like you're going to need a lot of refactoring down the road. Having each item be a line in an *items* class only works for so long. Unless I'm misunderstanding what you're doing here. Ideally you'd have some kind of item data model and individual items would have their data stored in something like a json file (Doesn't have to be json, can be anything, hell make your own format). Then you'd load them all into the game as generic items. Looks really cool though man. It's exciting to see progress come together on a project like this.
i 100% agree with you about the items being a hassle! there is a plan to move all of the item data over to a more structured and easier to use and work with format as well as all of the crafting costs and a few other things its just not something i've gotten around to yet (as you might imagine i tend to gravitate towards the more fun stuff ;) ) I do really appreciate the support and the suggestions!
What engine?
my own :) everything is done using the standard java libraries
Just curious what are you learning materials? Also why Java?
The learning materials is mostly self taught and playing with things and just generally making things (not everything ive done over the last while has been smooth or well done aha) there have been a number of people who took the time to explain things to me when i was needing help as well that made a big difference. As for why java, simply because i enjoyed it and i felt like it gets passed over by alot of people for a lot of reasons so i decided to keep working with it :)
Cool thanks for sharing! Look forward to more features.
Thanks for the support and interest!
As long as you understand the tradeoffs.. In my personal experience the database access layer is a headache only when you abuse it. (e.g. use an ORM when need complex queries as a first class citizen).
is this by chance a grails application (you mentioned groovy) ? If so, you would be best to follow the grails way of doing things. write your domain groovy classes and have most of the logic in the service layer.
Google has a distribution dashboard with market share info for Android users: https://developer.android.com/about/dashboards Keep in mind that in Android you typically want to Target the latest Android version, but set a reasonable minimum version that includes the market share you are wanting.
You will likely have better luck asking this on r/Android.
In his next video he will add $11 membership onto his next video. XD
Try these tools, I found it very useful. [https://fastthread.io/](https://fastthread.io/) [https://heaphero.io/](https://heaphero.io/)
No love for BalusC :( this man is a godsend for anybody doing JSF development. http://balusc.omnifaces.org/?m=1
I'd vote for the KISS principle. Just use guava immutable data structures. They're efficient, very simple and as bug free as reasonable possible. Anything more complex should only be used after careful performance measurements when absolutely necessary.
/r/Androiddev
I did a (very naive) simple test for memory usage, see it for yourself: &amp;#x200B; `import org.pcollections.HashPMap;` `import org.pcollections.HashTreePMap;` `import java.util.HashMap;` `import java.util.Map;` `public class Main {` `private static final int SIZE = 100000;` `final static Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(SIZE);` `static {` `for (int i = 0; i &lt; SIZE; i++) {` `map.put(new Integer(i), new Integer(i + 1));` `}` `}` `private static long usedMem() {` `System.gc();` `return Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();` `}` `// trove` `public static void pcollections() {` `long mem = usedMem();` `HashPMap&lt;Integer, Integer&gt; pMap = HashTreePMap.from(map);` `mem = usedMem() - mem;` `System.err.println("pcollections " + mem + " bytes");` `pMap = null;` `}` `public static void vavr() {` `long mem = usedMem();` `io.vavr.collection.HashMap&lt;Integer,Integer&gt; vavrMap = io.vavr.collection.HashMap.ofAll(map);` `mem = usedMem() - mem;` `System.err.println("vavr " + mem + " bytes");` `vavrMap = null;` `}` `public static void bifurcan() {` `long mem = usedMem();` `io.lacuna.bifurcan.Map&lt;Integer,Integer&gt; bifurcanMap = io.lacuna.bifurcan.Map.from(map);` `mem = usedMem() - mem;` `System.err.println("bifurcan " + mem + " bytes");` `bifurcanMap = null;` `}` `public static void main(String[] args) {` `vavr();` `bifurcan();` `pcollections();` `}` `}`
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Pretty huge dependency to pull in just for some immutable collections, I think we have different ideas about what constitutes simplicity.
It looks like in your [submission](https://www.reddit.com/r/java/comments/bubg4a/resteasy_a_guide_to_implement_crud_rest_api/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
The other classes like Multimap, Ranges, primitive utilities and so on are generally useful too. And the classes themselves are very simple.
Interesting talks in the agenda, definitely worth to check it out
I great example of where they're useful is of you take a look at the main collection interfaces, [List](https://docs.oracle.com/javase/8/docs/api/java/util/List.html), [Set](https://docs.oracle.com/javase/8/docs/api/java/util/Set.html) and [Map](https://docs.oracle.com/javase/8/docs/api/java/util/Map.html). These are abstract contracts for which many different implementations exist. Take List for example, there's the commonly used [ArrayList](https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html), but also [LinkedList](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html), or the list returns from [Arrays.asList](https://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#asList\(T...\)). So let's say we have a method that takes a number of tags and prints them, we could write it like so: public void printTags(ArrayList&lt;String&gt; tags) { ... } However this would force whoever uses this method to actually supply an arraylist. But that method would probably work fine on a LinkedList or any other list right? This is why we generally try to 'program agains the interface': public void printTags(List&lt;String&gt; tags) { ... } Or even better: public void printTags(Collection&lt;String&gt; tags) { ... } This method above can deal with Sets too. By programming against the interface we make it easier to have code that's reusable. Had LinkedList, ArrayList, etc. not all implemented these interfaces we would have to write the same method for any list we would want to support, creating a heavy maintenance burden where we would have to maintain and extend all these different-but-the-same implementations.
You can go a step further by accepting Iterable ;)
One benefit of interfaces is that it allows for polymorphism. Consider the following type hierarchy: public interface Pet { void speak(); } public class Cat implements Pet { @Override public void speak() { System.out.println("Meow."); } //speak } public class Dog implements Pet { @Override public void speak() { System.out.println("Woof!"); } //speak } Now let's put a `Cat` and a `Dog` into a `List` and make each speak: List&lt;Pet&gt; pets = List.of(new Cat(), new Dog()); for (Pet pet : pets) { pet.speak(); } //end for This will print out the following: Meow. Woof! Had `Cat` and `Dog` not been related through `Pet`, we wouldn't be able to perform this operation as easily. Polymorphism, through the use on interfaces, allow implementations to differ while still sharing a common API. As another example, think of cell phones. Modern phones have some sort of touch screen and buttons, but are their internals the all the same? No. When they are hidden away, what is left is an *interface* that users of the device can interact with.
Inheritance in any form is only useful, when you want to work with any such thing afterwards. Say you have some objects that can `.fly()`. Some of those things fly by flapping their wings, some with a propeller, some with a jet turbine. You then want to put some of those things into a `List`. You only want things that in that list that can `.fly()`, by whatever means. So create an interface `Flying` and make a `List&lt;Flying&gt;`. If you never want to put an object into a Collection or hand it over as parameter (to constructorss or methods), there is no need for any kind of inheritance, including interfaces.
I know.
In my experience, especially with larger projects with multiple people working on it, the "translations" of the fields *will* diverge, and then you're left with even more mess then when you started out. Maybe I should say at that point that this only applies if the database has to be "eternal". If you're thinking about swapping out the database sooner rather than later (because let's face it, it is never going to happen later) then already modeling your object structure in a sane way is a good idea and can help you much. If the database is not going to go away, and has to stay like that (because other applications are accessing it), then it is better to model the objects the same as the database.
&gt;C# also has some very nice language features that java is desperately missing. By all means share :). When I say Java is the best I'm looking at the full package, but there are a bunch of things I like in other languages that Java doesn't have. And yes; there are things Java just can't do. Go's goroutines are great, Kotlin has package level functions, and Perl has regular expression parsing which is amazingly expressive. I also sometimes miss multiple return types, creating some POJO or using a Pair class just feels hackish.
I think you hit the nail on the head - it's a question of if the database more of an eternal source of truth that will serve multiple applications or is it a temporary data store for your application.
As a fellow mostly self taught developer. Please look into inheritance, polymorphism, and encapsulation. They're the some of the most important concepts in computer science. You do not need incredibly long switch statements like that. Each of your items can share some code, making it easier for you to add new items in the long run. You can add a new item class and change one or two lines of code elsewhere, and everything will work. I wish you the best!
Update: Is done in both /r/javahelp and /r/learnjava in old and new reddit views.
See my reply above.
See my reply above.
I feel that generics are better fleshed out in C# then in Java. You get to decide on Covariance and Contravariance via the In/out parameters and you can use primitives as generics. You can somewhat get Co/Contravariance n java, but to me the C# way feels so much more intuitive and easier to read &amp; write then the clunky Java syntax. C# also has structs for quite some time now, something that is only slated for java in the future. LINQ is great, although it can seriously crush performance when done wrong. The yield keyword is great, something like that is completely missing in java. You can simulate it wit a supplier, but prior to java 8 you needed a factory and even with Suppliers, to me yield feels just so much more elegant. I feel C# handles delegates in some cases in many cases better then java does handle lambda functions. Overall I still prefer Java, but reading Eric Lipperts blog about C# and language design is very educational.
I'd give you gold if I had
You have a talking parrot, a talking dog and a talking human: class Parrot { public String talk() { return "Hi, I'm a parrot.";} } class Dog { public String talk() { return "Hello, I'm a dog.";} } class Human { public String talk() { return "Hey, I'm a human.";} } I want you to make them talk. Without interfaces: List&lt;Object&gt; beings = new ArrayList&lt;Object&gt;(); // [..] Iterator&lt;Object&gt; it = beings.iterator(); Object obj = null; while(it.hasNext()) { obj = it.next(); if(obj instanceof Dog) { ((Dog) obj).talk(); } if(obj instanceof Human) { ((Human) obj).talk(); } if(obj instanceof Parrot) { ((Parrot) obj).talk(); } } Imagine I give you a talking unicorn, a talking fish, a talking fly and a talking kangaroo. You would have to expand the while loop anytime you add a new type of animal. This is where interfaces come handy. You can look at interfaces as extracting a "feature" and treating object by that "feature". (In other words having a contract.) interface Talker { String talk(); } class Parrot implements Talker { @Override public String talk() { return "Hi, I'm a parrot.";} } class Dog implements Talker { @Override public String talk() { return "Hello, I'm a dog.";} } class Human implements Talker { @Override public String talk() { return "Hey, I'm a human.";} } So our code becomes this: List&lt;Talker&gt; beings = new ArrayList&lt;Talker&gt;(); //[..] Iterator&lt;Talker&gt; it = beings.iterator(); Talker being; while(it.hasNext()) { being = it.next(); being.talk(); } Inheritance is good but it's somewhat limited. You can't inherit from different classes at the same time, you can use chaining. However you can implement as much interfaces as you want. Inheritance // Make me a walking talking animal. class Walker {} class Talker extends Walker {} class Animal extends Talker{} // Now make me a talking plant with these class Plant extends Talker {} // WRONG, it becomes a walker also. I said a talking plant. Interfaces interface Walker {} interface Talker {} // Make me a walking talking animal. class Animal implements Walker, Talker {} // Now make me a talking plant with these class Plant implements Talker {}
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
It looks like in your [submission](https://www.reddit.com/r/java/comments/bucxz2/learn_jdbc_at_tcci_tccicomputercoachingcom/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
This explanation is perfect ! I am even able to know where I can use it in code I already wrote and it will make it much easier. Than you so much
With the explanation of u/Lowdryer and yours I am now able to understand it, thank you. Also thank you for the extra matieral, I will definetly dive into them
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
As previously mentioned there is a plan to do an overhaul on the items and get rid of a lot of that mess :) I appreciate the suggestions and support :)
Meanwhile I'm still stuck at learning how to create a GUI.... Good job man.. any tips for me? :(
Clients dude clients, who are you going to build your app for?
Just keep at it man! it takes some time to learn but the more you do the easier it gets.m if youd like send me a message or an email and id be more than happy to help :)
What libraries? Opengl? LWJGL? Im very interested in currently learning opengl in java
no opengl or lwjgl. like i said its nothing fancy, the window is using jframe and canvas, and all the drawing is done with graphics and graphics2d
&gt;Anything more complex should only be used after careful performance measurements when absolutely necessary. Assuming your bottleneck is the CPU/memory efficiency of the collections you use. CRUD line of business apps can go wild. ;)
Can talks be watched later on ?
Yes there will be available [here](https://www.youtube.com/channel/UCbrpfdjKI_2LZtJGI24bbhg)
[https://micronaut.io/](https://micronaut.io/)
Java is multithreaded, in order to process parallel work you need to spin up new threads and you are responsible for handling all the problems that may occur in a multi-threaded application. JavaScript is single threaded it uses a queue to store the work that it has to do. Once the main thread is free it pull ups tasks from queue and executes them one by one. Event loop helps you on this part and more. Java is blocking I/O which means whenever you have to write/read from files the thread is blocked until that work is done, that's why on enterprise applications one request = one thread. Usually you have a pool of threads and which one is free get assigned to process a request. In order to support dynamic pages we need to extend our web server with our own objects (servlets) these objects generate two other objects (request, response) for you so you can work with them. We need a container for these servlets so here comes the Tomcat to help you with that. Working with Java enterprise frameworks is mostly coding by configurations. Angular uses same concept most of the components, modules, services need to be registered somewhere and combined for the application to work properly. There are a lot of new stuff in Java 8 that make your life easier, consider using Java 8 I'm a mid software developer so take these information with a grain of salt.
This is a question for /r/techsupport. Please, ask there and be more clear/elaborate. **Removed**
Thank you!
Thank you!
You're welcome! :)
If you are looking exclusively at development then do go through Mozilla's Github Repos as well! They are quite interesting [https://github.com/mozilla/DeepSpeech](https://github.com/mozilla/DeepSpeech)
Some examples of how interfaces are useful. Define an interface when you don't know what possible future implementations of the interface might be created later. Like for plug-ins that might be developed later on (eg, photoshop plug ins for example). Define an interface when you want to manipulate objects provided by someone else, where the interface specifies some basic required methods in order to do your specific manipulations. Example: a Node interface, and an algorithm that can process a tree of Nodes in depth first order. The Node interface would specify a `List&lt;Node&gt; getChildren()` method to get the children of the current node. Now later you could also create an algorithm that can process a tree of Nodes in breadth first order. You don't know what the Node objects are, and you don't care. You just need to be able to get the children nodes of any node. Maybe someone is using your algorithm to walk a tree of possible chess board positions -- they would implement the Node interface, but you don't care about anything else in their chess board class -- just the method required by the Node interface to get the children. Define an interface in preference to a class when creating polymorphic subclasses. A class can implement multiple interfaces, but can subclass only once. The new feature of default methods in interfaces can allow common methods in the interface that might have been in the superclass. Define an interface with default methods that provides helper methods that build upon some basic set of required methods. Suppose you have a number of objects in your system that have an x, y and radius. Create an interface with the getX(), getY(), getRadius(), and then other default methods that build upon these to provide other helpful values calculated from them. The common implementation is now only in the interface. Multiple different, and completely unrelated classes with x, y, radius could implement this helper interface in order to "inherit" the additional features provided by the interfaces default methods.
gonna be honest, vscode is ok for small projects but you're really gonna be best off just using intellij. skip the nonsense and just go for the easiest, most feature-filled IDE
Here is an example of how I could use an Interface in an application to offer the user a choice between two implementations -- fast but memory hungry, or less memory but slower. I need to read in and process millions of records that contain various information, including ECEF coordinates. (Earth Centered Earth Fixed, use Wikipedia) It is possible to convert from ECEF coordinates into Latitude - Longitude coordinates. The Lat-Long coords are then used in some further calculations. Define an interface which represents each record read in. It offers getter methods on the values. (The read in records are immutable. No setters.) Two classes implement this interface. The fast but memory hungry class, and the slower but less memory class. Both classes have a constructor that takes the same parameters. While reading in the millions of records, each record creates an instance of a class behind that interface. Which of the two instances depends on whether the end user wanted performance or less memory. Basically the read loop has an IF statement to determine which class to instantiate. Either way, it returns the interface for the class. The fast class would pre-calculate all of the additional values (eg, latitude-longitude, and other things) from the constructor and store them in private members within the class. The getter functions would simply directly return those pre-calculated values. The second class would store only the constructor parameters as private members within the class. Some of the 'getters' would actually calculate their values on the fly when called, because there is no pre-calculated value. Some of these 'getters' would call other of the 'getters' as some calculations build upon other calculations. The rest of the application sees a list of these record objects (by interface definition) but doesn't know or care which actual implementation is behind that interface, the fast implementation or the slow implementation. Furthermore other implementations could be offered via configuration settings in the application. The interface might expose all floating point values as doubles. But some implementations might internally store them as floats (to save memory) yet still return them as doubles through the interface methods. This technique has other applications. Suppose you were building a Mandelbrot program. You have an array of pixel value objects. These are actually an interface. The interface could offer the iteration count for this pixel as well as what color the pixel should have. The fast version would pre-calculate and store the color. The slow version would calculate the color each time it is asked for. Furthermore, the color might be a function of something other than the iteration count -- such as the distance of the previous point before it escaped, or some other coloring, such as the angle of the line segment formed by the two points prior to escape. Different implementation classes behind that interface could store more or less information as required to produce the result. I hope that helps inspire you.
Poor Eclipse Foundation. They do such good work, but my outsider perspective is that Eclipse is where projects go to die. I saw that one of my project's dependencies was getting handed over to Eclipse and I was pretty bummed about it. I mean, that dependency was already atrophying but now it's basically dead dead. I understand that one solution is to contribute time and code to the project myself, but that's not always feasible. I don't know enough to maintain the project, especially when even the original creators decided that they didn't want to deal with it. What chance would I have? I don't know how to solve this kinda problem, but I'm sad to watch it.
Somebody who makes more money than I values my advice, especially if I can make a business case. Over the years I've upgraded to the latest Java about a year after it becomes available. First in dev. Then testing. Then in production. It's a smooth process. Nobody really notices. But the biggest thing: we never have a HUGE sudden cost because we need to upgrade across many versions. And we avoid the worst case: we can never upgrade because it simply would be too expensive and break too many things. By upgrading along the way the cost is close to zero. The benefits of new features are very real. Any small issues that might creep in from a single version bump are promptly dealt with in development. And even that is rare. In general, everything just works on the next version. A difficult to measure benefit is that within about a year of a new release, and about two years after all the hype, I get to use the latest cool features in Java. Java 7 was good, but Java 8 was fantastic in the things I could write in my source code.
papaya, papyrus, payara, cobra corba what is going on here
I can't understand why anyone would pay for this. OpenJDK is - well - open. You can get free security updates from several providers. Spring itself doesn't need support. Who is this targeted at?
The best explanation I've ever seen.
Not that discussion again. There are already plenty posts about that question. Please use the search function of the subreddit. **Removed**
It is quite powerful indeed, if you want to enhance your type system with tons of meta information that you can compile time check using any sorts of rules. Unfortunately, too many examples evolve around nullability, which are the trivial use cases. It can do so much more. jOOQ for example offers a two type checkers: - One that checks if any "plain SQL" API is being used, which can be forbidden by default due to the SQL injection risk that it poses - One that checks if SQL dialect compatible API is being used. E.g. when you're using MySQL, and you're using a jOOQ API method that is not supported in MySQL, you can get a compilation error. Details here: https://blog.jooq.org/2016/05/09/jsr-308-and-the-checker-framework-add-even-more-typesafety-to-jooq-3-9/ So, really powerful stuff, and quite easy to do with the checker framework. I actually brainstormed this idea with Mike Ernst in person, at a conference speaker's dinner, where he introduced me to his framework. Years later, I finally implemented the above.
Using JavaCV / OpenCV for a stand alone application with real time video processing. Have moved to OpenJDK 12 and had no issues.
I wanted to use JavaFX for video processing but it simply did not cut the mustard. Not even as fast as JMF. If you need to process video in a performant fashion JavaCV is the only real option.
🤔
Fuck man I wish I had the motivation to make something like this. Java has such a great potential for a game platform, but nothing big sans Minecraft has used it.
Yeah people underestimate how hard game dev is. I did some minecraft stuff professionally for awhile and boy that shit was hard. I do backend dev and sometimes touch our react frontend. It's about a million times easier doing this, and also clients are actively trying to break your shit.
Agreed! Theres a lot of potential that a lot of people just skip past or overlook in favor of more traditional languages like c++
For the original goals of Trinity, stream processing, they might simply be waiting until Valhalla delivers some of its goals before jumping into explicit vectorisation support. With value-types I anticipate some improvements for optimisation from the lighter objects and better locality of reference. This might lead to better escape analysis and auto-vectorisation. Valhalla is a mammoth piece of work but it stands to yield some pretty significant improvements (and should combine rather nicely with a number of Amber plans too).
Yes for sure. The nice thing about doing something like this that's it's mainly just a person project is that the only person I have to make happy is me :)
It's a Spring Boot application. Our domain classes are in Groovy so that we don't have to spend time making the getters/setters and other small things.
From the side bar... *"Do not post tutorials here!"*
They've done some great work on this. I'm really happy they've taken the time to get this right. It looks pretty great
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
If you check what Oracle shipped for Java 211 and 212, and compare that with the OpenJDK 212, there are indeed differences. Not all the changes backported into OracleJDK were backported by the OpenJDK community, and viceversa. I doubt there will be any significant drift between OpenJDK releases, as they all use the same repo. The only difference will be between OracleJDK and OpenJDK (for versions like 8 or 11 for which Oracle no longer upstreams most of their changes). Now, the good news, because which changes go into each version are known, the OpenJDK community can now check which ones Oracle included in 212 and include them into 222. They might not be 100% exact what Oracle did, but they will be 99.999%. Which means, even if the versions differ, there is a process to sync up them again. (Whether Oracle will include in their OracleJDK changes that were put on OpenJDK by the updates project, I don't know)
Business people who need a throat to choke when things go wrong. A paid support contract is almost always preferred over free no-support, because you can blame a third party (for your mistakes...I guess).
everyone will say intellij idea
IntelliJ (https://www.jetbrains.com/idea/) is really nice and it's my favourite. However, it's not free. Eclipse is actually a really good IDE, especially for being free. Is there something particular about Eclipse that you don't like, or are you just exploring other options?
Yah I have been messing around with it but i am honestly not a he biggest fan of it
At the moment I have been messing around with the community version of IntelliJ and been using eclipse, I was wondering if there where any other better alternatives the community could reccomend.
It looks like in your [submission](https://www.reddit.com/r/java/comments/bupxxd/is_there_any_high_performance_open_source_native/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Putting in so much effort, but - once again - missing the elephant in the room: "Text blocks do not directly support string interpolation. Interpolation may be considered in a future JEP." If you have text blocks or string literals, what is the *most likely action* you would do with those next? Any guesses? Interpolation. Of course. So now we have a nice text block where the compiler already interprets the string and replaces escape sequences, btw, and next thing a hand-crafted or existing library is used to replace placeholder strings, rips that lovely text block apart again, creates basically a separate copy of each substring between the placeholders and then glues it back together again. Voila: 3 copies of most of your data. If you are clever, maybe 2 copies. Why can't they just adopt the JS approach? Here's an example: `This JEP is ${expression} sufficient` Even better, if you don't like the built-in interpolation, you can run your own! aFunction`We could do ${expression} better` // aFunction (String[] -&gt; T) And if you don't like the ${} indicators for an embedded expression, you can just access the string `raw` and do whatever you want with it. So much more utility that came with a syntax extension (backtick in this case)
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Apache Netbeans is alternative if you tried intelij and netbeans, then you can decide which is the best for you.
Go through this, You may find it helpfull. [https://blog.fastthread.io/2016/10/27/thread-dump-analysis-api/](https://blog.fastthread.io/2016/10/27/thread-dump-analysis-api/)
Blatantly copying syntax and semantics from another language is not something that the architects do, nor should they. I am sure we will get interpolation, but the design and analysis of new features takes time. Be patient.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Literally anything that gets you coding. You're a beginner, you don't need to worry about the nuance between 50 different compiler options you won't use for a decade.
🧐
No one says they should. The example was to Illustrate what is possible with a rather small investment. Java is famous for adding features and just not getting them right. From generics to enums and annotations: missed opportunities to get it right the first time and barely any activity to fix their shortcomings, often because they backed themselves into a corner. And “blatantly copying syntax and semantics” Is what C# did rather successfully so even that isn’t a good rule of thumb. Given the glacial speed of adding syntax to Java, interpolation is years away.
Well you appeared to imply that they should. You also appear to be viewing the glass as half empty. Just because you don’t agree with a feature or its offerings doesn’t mean that it is “wrong”. Generics were, and still are, a very pragmatic compromise. Had we gotten generics on day one, we likely would have gotten C++ templates. Text blocks are just the first course of many possible options, some of which are mentioned [here](https://mail.openjdk.java.net/pipermail/amber-spec-experts/2019-March/001057.html). Given the new six month release cadence, I’m sure we’ll get interpolation sooner than you think.
It's not only about security updates, also bug fixes, "Pivotal can initiate bug fixes and changes to OpenJDK should the need arise." A bug might be high priority to your business, but low priority to the OpenJDK community. So if you need the bug fixed on your business's time-frame, then it's good to have paid support.
Illuminati!
I sure hope so. Admittedly I'm frustrated at the innovation speed of the ole' Java tanker. Reliable, robust, keeping the course ... into oblivion. The innovation speed of many of its competitors is much higher, some of those languages having been around almost as long. Keeping the language fresh, adapting it to new insights and trends is important. In the case of new string syntax, it's a perfect opportunity to help reduce bugs in string manipulation and introduce a new standard. Pushing the envelope a bit. It's an odd process they have now: Faster releases (with version numbers that are slowly becoming meaningless) but with very skittish changes that - in this case - went through two JEPs to get anywhere. I appreciate them being careful in adding the right feature (text block is vastly improved over raw string), but I'd like them to be bolder.
Enums? They are much nicer in Java than in C# so I know you're being disingenuous. Generics have been argued about to death but what's your problem with annotations? At least they are named correctly unlike C#.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
No. IntelliJ is hands down the best.
&gt; Java is famous for adding features and just not getting them right. Java is famous for being among the top 3 most popular languages in the world, the other two being even smaller and slower to change. The belief that most people want a faster moving language is just not supported by facts. On the other hand, the minority of people who do can use one of the other Java platform languages, largely because of: &gt; generics ... Java got generics much better than C#. Reified generics were such a big mistake that they killed language interop on the CLR. This is actually a great example of the wide public not understanding a feature and its costs. Reified generics get you a small increase in convenience in one language, while at the same time bake the variance model into the runtime, so that any other language must either adopt it or fail to cleanly share data and code. Clojure, and Kotlin, JS and Python interop so cleanly with Java *because* Java erases generics (specializing generics for invariant value types is a different matter). &gt; Is what C# did rather successfully so even that isn’t a good rule of thumb. How do you determine that C# has done this *successfully*? It is actually .NET that backed itself into a corner with generics and is now doing the same with async/await.
18 years. With pleasure. Why would anyone use anything else? 😎
What’s wrong in this? As long it helps others to improve there skill sets and it is relevant to the Java technology I don’t see any reason of not posting the study materials.
&gt; keeping the course ... into oblivion. What is this observation based on? &gt; but I'd like them to be bolder. The Java *language's* ["constitution"](https://www.win.tue.nl/~evink/education/avp/pdf/feel-of-java.pdf) calls for it to be conservative. But the Java platform was not only [designed to be bold](https://youtu.be/Dq2WQuWVrgQ) (as it's believed that runtime features are much more impactful than language features), but continues to break ground with garbage collectors like ZGC, compilers like Graal, and low-overhead in-production profiling like JFR. As a result Java is such an attractive target for languages, that if you want fast moving languages, Java offers you a nice selection.
Oh! That looks like a good chance to try programming in Kotlin!
dang. didn't know it was that old
You already have the best two.
Such questions belong in /r/javahelp. **Removed**
It's not a bad thing to deliver features in small pieces. Why should they hold back multi-line strings until they have *also* specced out interpolation/raw strings/whatever else? Why make people wait longer than necessary for something that's ready now? Better to deliver this now and work on the others later, so long as room has been left in the design to facilitate those features, which they have been very careful to do in this instance. They obviously can't add `${expression}` later in a way that's backwards-compatible. It would have to be implemented as an escape so as to not break existing strings (which is a good idea anyway just for consistency), so `\{expression}` is more likely. And braces are normally used to contain *sequences of statements* not *single expressions*. A single expression *can* normally be surrounded by brackets, however, so `\(expression)` seems to more naturally fit in with the rest of the language. Just one small example of why it's a bad idea to copy a feature without careful thought.
Security.
This is cool, but I wish the Raw String Literals went through. It would make my life easier when working with regex patterns.
I'm not sure if you were around when Microsoft pulled C# out of the hat. It was a blatant copy of Java where even the package names were lifted verbatim. But that is beside the point of this argument.
I love being on the JVM. It's great! I am fully aware of the Java ecosystem and it's pros and cons. I've been on that platform since Java 1.0. The Java language team i - I'm sure - doing the best it can. But if you are going to add a syntax feature that deals with Strings, why not take it one step further? Why is none of you actually addressing the point? Would it be good to have a standard interpolation mechanism? We already have `format` which I'm sure all of you are using... ;) Just kidding.
We were talking 'blatantly copying features of Java', which C# did if you recall how it actually came to be.
Again, no one said copy JS as it is. It's just a showcase of what you could have! And you just made an important point: Squeezing in interpolation later will not be easy and will have to rely on currently invalid escape characters. (I'm talking actual compiler support here) In general, it is not a bad thing to deliver in small pieces. But also in general, delivery of new language syntax takes a long time, especially with Java. To me, it's a wasted opportunity. If you are going to optimize how to concatenate strings and make it easier to type multi-line literals, you are 80% there.
Note to my peers here, since it has come up several times now. I wrote 'adopt'. That isn't 'copying', since that, obviously is not in the spirit of the Java language. And before you downvote, you could address the actual point. Kthxbye
&gt; It's just a showcase of what you could have! Okay sure, as are many other languages. Nobody is disputing that it's a useful feature. I'm just disputing that there's any need to artificially hold back other related features so they can be delivered at the same time. That buys no value in this instance. &gt; And you just made an important point: Squeezing in interpolation later will not be easy and will have to rely on currently invalid escape characters. (I'm talking actual compiler support here) How is that "not easy"? It is identifying an existing language mechanism (and a corresponding space in the lexing rules) that is appropriate to facilitate the feature rather than inventing a new one. I would argue that escapes are the natural way to implement this *even without* the constraints of backwards compatibility. And bear in mind that if they want to allow interpolation for normal string literals---and they most certainly *would* want to allow that---then they already are limited to implementing them as escapes. So these constraints already exist, they are not newly-imposed by the new feature. &gt; To me, it's a wasted opportunity. If you are going to optimize how to concatenate strings and make it easier to type multi-line literals, you are 80% there. That's the exact opposite of a wasted opportunity. It's *creating* an opportunity by building the foundations for it.
I'm glad they are still working on this but damn they are taking their time. Block Text was oringally scheduled for Java 10? Now it's slated for what 13 or 14. Lack of block text drives me up the wall nearly every day. Every other language I work with has them. I agree with the guy below that not only should they have block text, they should add automatic string interpolation too, but I'll take what I can get at this point.
Don't worry raw strings are still on the radar. This JEP isn't intended to be a replacement for the earlier raw strings proposal, it's more about finding the appropriate lines along which to separate out features, and the most natural way to deliver them piece by piece. From mailing list discussion it seems they've been careful to leave space in the design for adding things like raw strings and interpolation later without breaking backwards compatibility.
&gt; why not take it one step further? Again, **shipping this feature now doesn't preclude them from taking more steps later**. They have been careful to leave space in the design to acommodate that. Given that fact, I feel that you have failed to articulate any good arguments as to why this feature should have been held back until interpolation is also complete. &gt; Why is none of you actually addressing the point? I have addressed it in another reply to you, which you have not yet responded to. Why are you not addressing those points?
&gt; And before you downvote, you could address the actual point. Kthxbye I've addressed it here https://www.reddit.com/r/java/comments/bunyoy/jep_proposed_to_target_jdk_13_355_text_blocks/epgmxdq?utm_source=share&amp;utm_medium=web2x and you've not replied.
&gt; Java is famous for adding features and just not getting them right. From generics to enums and annotations Do you not understand what you wrote? Just admit that you're a disingenuous shill and move on. You can't even answer my question about annotations.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
/u/pron98 is that guy and he’s all over this thread so you are correct !
You can read about why they dropped raw `String` literals [here](http://mail.openjdk.java.net/pipermail/jdk-dev/2018-December/002402.html). While it is taking a little longer than expected, I appreciate that the architects didn’t end up shipping something that is they felt was incomplete.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I really like jOOQ's design, and so your endorsement is meaningful to me. The way you describe it reminds me of the kind of checks that the Rust compiler does with it's type system. Can be a bit tricky to get right, but it really adds a lot to the overall safety. I've looked at Kotlin lately and while the syntax and new functional features are nice, I thought the type system was lacking in improvements, other than the no-nulls and reified generics.
This article is a fantastic advertisement for gradle.
I don't know Rust's capabilities, so I cannot compare, but if you want to compare JSR 308, AOP with e.g. Scala's (or Lisp) macros, or C#'s compiler AST transformation APIs, then Java is really lacking. A lot of things can be implemented using the checker framework, yes, but it *is* an annotation processor and thus limited by APT's features. In fact, I don't even fully understand why a compiler plugin / AST transformation API would use annotations as "hooks". I'd love to transform arbitrary code, regardless if annotations are present, similar to what the instrumentation API offers at runtime. It is possible to go further than what JSR 308 and APT allow to do. Have a look at https://errorprone.info, which also hooks into vendor specific compilation APIs (javac's, and JDT's, for example) to achieve much more. I found Error Prone more difficult to get started with, but it's more powerful, and better maintained, and also far more popular than the Checker Framework. The license is also more friendly (ASL 2.0 instead of GPL2). The Checker Framework, after many years, still doesn't support anything beyond Java 8: https://github.com/typetools/checker-framework/issues/1224 Unlike Scala/Ceylon and other languages, I don't think Kotlin aimed for improving the type system, "only" the language. Kotlin also supports annotation processing (https://kotlinlang.org/docs/reference/kapt.html), so I would imagine that a Kotlin checker framework should be possible? Maybe, you should build one! :-)
Gradle fixes a lot of maven issues while adding some of its own.
&gt; Why can't they just adopt the JS approach? Because the JS approach is most certainly flawed and broken on the long run. Rather look at C#, Rust, Scala or Kotlin
You could use separate template processing library (freemarker for example) to address your issue. Using text block is great to liberate you from putting the template in a separate file and allow you to put it next to your processing code. Template processing library could do more things than just interpolation. I wouldn’t want a battery included JDK as we may end up like the bloated Python std lib situation.
What the... I was totally ignorant of ErrorProne up until today and I'm usually well aware of the Java ecosystem. Time to retrofit this in all projects! Thanks.
I'm happy you love Java. I'm not on the language team, but I believe that the language team has addressed this when asked (I don't know the answer). There are many reasons not to add features, or not to hold some features for others. In general, what slows down features of this size (as opposed to big stuff like Valhalla) is the determination that the feature is actually required and can make an impact commensurate with its cost (not implementation cost, but complexity cost), and then deciding on the best design. One thing that is important to remember is that while Java is fast moving and innovative, the Java *language* is conservative by design. Back in the nineties its "feel" was chosen such that "good idea" features *will not* be added; just features that have proved their worth. The majority of Java programmers prefer using the Java language, and those who want a less conservative language seem to be in the minority. Luckily, Java offers them a selection of other, more adventurous languages, and there are quite a few people (although a definite minority) who program Java in Clojure, Kotlin, Ruby or other languages. Those languages are also helpful for the Java language, as they serve as lab rats for features the language may want to adopt.
Excellent article. It's nice that this article covered how **and** why on each point.
Does that mean that I won't have to install all frameworks since .net 2005 to play my steam games?
Can you talk more about Nuance's offerings? I'm interested in applying this to recognizing medical terminology in an offline setting so I may be willing to spend the money. I visited their website and I contacted them but I'd still like more information
&gt; Text blocks do not directly support string interpolation. Interpolation may be considered in a future JEP. Blocks are cool, but I really just want interpolation
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I just wish I could get Gradle too work. I use the JDK(12) "uninstalled" as a stand alone binary (pretty useful if you can install your dev apps like this as building a new dev system is just zipping up an existing one and unzipping it on a new machine). Gradle does not like it at all for some reason and have not managed to get it too play ball. Went off Maven a while ago and use my own build system theena using ant. Have written several tools around it including a cmd app that generates a new project from scratch with the source / build auto generated so starting a new project is easy (inspired over the years by Ludum Dare). The release tool I have written calls ant (theena). Then goes through your java source looking for a specified tag and then copies that classes from the dev compile too the build. Finally calls proguard to shrink and obfuscate the release build. All in one command line. So no maintaining a build script, just add / remove tags from source code (making it easier to not accidentally release admin code for instance). There is also a cmd app that syncs source code across multiple projects but I digress...
I like this version very much, well done! Keeping in the long standing developer tradition of never being satisfied when somebody else worked hard for you, can we have [what the F# people have](https://github.com/rspeele/Rezoom.SQL) next? Edit: I'm aware that this will blow the complexity budget and be a poor fit for Java, but a developer can dream.
Oh man. Who made that suggestion? yield is connected to threading and async. Not returning results... "yielding results" makes no sense (well "breaking results" doesn't either but still)
Quickly, let *them* know it!
The discussion can be found [here](https://mail.openjdk.java.net/pipermail/amber-spec-experts/2019-May/thread.html), under the thread "Call for bikeshed -- break replacement in expression switch".
Offtopic, but that looks pretty impressive! :O
does anyone know what the technical term for being able to write method names like pseudo strings? eg popular in unit tests. Would this come for free with any of these JEPs? `given X then expect Y`() { ... }
If you have comments, you can send an email to amber-spec-comments@openjdk.java.net.
&gt; yield is connected to threading and async. Not returning results... You're mistaken. 'Yielding' results from a co-routine for example. 'Yielding' results from a generator. All about returning results.
I think “yielding results“ is fine in this context. What would you suggest instead?
So this only differs from the preview in JDK 12, that they changed `break x;` to `yield x;`, if I'm not mistaken. Does anyone know, why they decided to swap out the keyword? I'd love to hear the reasoning behind it.
Correct. I posted a link to the mailing list discussion below.
So I guess the reasoning was, that `break x;` could also mean to break to label x, and not return x as a result. Seems they wanted to make clearer, what the intention of the line of code was. https://mail.openjdk.java.net/pipermail/amber-spec-comments/2019-January/000016.html
I am getting a weird response for runtime. It says the version is 12.0.1+12
Why is the release of new features in Java so slow, compared to C#?
With the introduction of the [new release cadence](https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence), features will be delivered much faster than before. In the past, small features would get hung up by larger ones. That will no longer be the case. When a feature is ready, it will make it on the next release.
I see, thanks. Does this mean we can expect more syntactic sugar, like properties, object initialization, the null-coalescing and the "as" operator, etc in Java?
Not necessarily. I suggest looking at the Project Amber page [here](https://openjdk.java.net/projects/amber/) to see some of what the architects are working on in regards to language ceremony.
This seems overly terse and complicated for the desired simplicity, but I could be swayed. What happens if someone uses the var keyword? Also, how will this work with a Generic? &amp;#x200B; var j = switch (day) { case MONDAY -&gt; 0; case TUESDAY -&gt; 1; default -&gt; { int k = day.toString().length(); int result = f(k); yield result; } };
`var` works just fine with `switch` expressions. `j` will be of type `int`. And what do you mean by "a generic"? Do you have an example?
I know nothing more. I worked many lives ago for what would have been a competitor to Nuance.
Good episode! After listening to it a few days ago, I found one of Christian's talks on youtube ([https://youtu.be/G-vlQaPMAxg](https://youtu.be/G-vlQaPMAxg)) that he mentions, watched it, and was able to convince my team to try out the Graal compiler in our test environments. Also looking forward to seeing Josh speak at the Minneapolis stop of the SpringOne Tour.
They tried to break (irony) with the old C syntax and suggested `break-with` initially even if there is nothing to break because there is no "fall-through" in switch expressions... ;)
* A Bootiful Podcast * Java Off Heap * Java Pub House
There actually can be fall-through with `switch` expressions if you use the colon form: char letter = switch (day) { case SUNDAY: break 'U'; case MONDAY: break 'M'; case TUESDAY: break 'T'; case WEDNESDAY: break 'W'; case THURSDAY: break 'R'; case FRIDAY: break 'F'; case SATURDAY: break 'S'; }
Will this be backwards compatible with code written in let's say, JDK 8?
Yes, it will. The existing `switch` statement isn't going anywhere. It is just being updated.
What is j is an object? What is j is a generic &lt;E&gt;?
You can make `j` of type `Object` if you would like. It would just box the primitives into their wrappers. You could also you a type parameter as long as each yielded value is of the correct type.
OK, make sense. There are no `fallthrough` javac warning in EA build, though.
Is there usually a warning by default? I don't think I've every gotten one.
This might be interesting to you: https://softwareengineering.stackexchange.com/questions/201315/how-is-multi-threading-different-in-a-java-based-web-application-vs-stand-alone
Thanks noutopasokon, am I right to say that we can introduce parallel programming aspect to handle the concurrency issue? But, I am not sure if multi-threading is akin concurrency.
No warning by default, but normally it should print warning with `-Xlint:all` option
It is. If there are concurrent processes, they are running on different threads somehow. There might be abstractions above that, so you never handle the threads themselves.
Good to know. It doesn't print one in build 23. Could be a bug.
It looks like in your [submission](https://www.reddit.com/r/java/comments/bv36tb/javafx_swing_library_like_devexpress/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
It depends on where you are in life (adult or student). Either way, I recommend purchasing java books and looking at programs that are made in java such as Minecraft when you get more advanced. Oracle also has docs so that's another good place.
I definitely recommend getting a beginners book to start with. Books are good because they are structured, presenting fundamental concepts before more advanced concepts. Also, you can learn at your own pace. You can supplement your reading with YouTube videos and online articles that go more in-depth on certain topics that interest you. But I definitely recommend starting with one book and following it through from beginning to end. Just look for good beginners books with high ratings on Amazon.
Thank you
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
We will be seeing records (data classes) with sort of auto-properties and ways to declare value classes (simular to structs). But Java won't transform into C# or Kotlin. They're making careful compatible additions and not redesign the whole language.
I really like the choice of the yield keyword here. I wasn't a fan of using break to return a value, so I'm glad they simply chose another word. I've been seriously impressed with the well thought out JEPs that have been coming out.
If you don't know any programming language at all, I have 3 words for you. HEAD. FIRST. JAVA.
I like [https://codegym.cc/](https://codegym.cc/) and using it to teach my kid and his buddies (wannabe programmers :) )
Thank you will look it up
This is amazing thank you
Because Java wants to be forwards and backwards compatible.
The as operator is awful. Java will be getting pattern matching, however, which can perform the same function in a less silly way, i.e. without needing a null check.
I'm loving how Java is embracing Kotlin language features now.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
If you use `var` and your switch expression returns multiple types (e.g. String and Integer) you may be in for a surprise when calling `.getClass()`.
[I'd try working through these one at a time](https://www.hackerrank.com/domains/java). Intuition and the ability to build decision trees in your mind is really important and that stuff comes through practice. Theory is good a bit further down the track once you're hooked and you need to start following convention. I'd really recommend you try to get in the satisfying loop of taking on small challenges and solving them one by one. Sometimes it's frustrating and things take way longer than it feels like they should but if you feed into that problem solving cycle and you're lucky w/r/t having a suitable personality it doesn't take too much willpower to learn this stuff.
Because Java's approach is "First DO NO HARM". There are few examples where languages get full: Brian mention Perl in [his talk](https://youtu.be/xc6eKUB-dzk?t=505). Just recently there was an article about [Lisp](https://medium.com/@erights/the-tragedy-of-the-common-lisp-why-large-languages-explode-4e83096239b9). C# is becoming of concern at the pace they are adding features.
previously known as scala features
It's a little tangental to your question, however it might be worth looking at the [C10k problem](https://en.wikipedia.org/wiki/C10k_problem), which is how to support 10,000 &lt; users connecting concurrently to your system. Looking at that problem will give you a good background in understand the issues of using processes, or threads, to support a large number of users accessing your web application, and how software like [nginx](http://www.aosabook.org/en/nginx.html) is architectured to handle large numbers of users through an event-based architecture (neither processes nor threads).
Thanks for sharing. So, it seems that multi-threading is all done at server end, nothing to do with the programming of our web app...and I just need to tune it to handle load balancing that kind of stuff right? I am using Tomcat now but it seems Docker and Kubernate is the trend now so not sure how they all mixed together....
HEAD FIRST JAVA 😀😀😀
Epic
Tomcat is a thread-based web server, so you have to be aware that your code will be called from multiple threads. However you don't have to handle the server aspect yourself; that's the point of Tomcat. Docker and Kubernetes is a separate topic from your original question.
Previously known as ML features.
Thanks for the infor. So, i don’t have to implement anything to handle any multi-thread situations(if there is such a thing) right?
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I still think it's confusing to use a keyword that exists in many other languages, and use is with an entirely different meaning.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt; you have to be aware that your code will be called from multiple threads If you depend on some shared resource, then you'll have to make sure it is thread safe.
Interesting side-note, in that case the inference algorithm would determine the type of the assigned variable to be the infinite type `Comparable&lt;? extends Comparable&lt;? extends Comparable&lt;? extends ...&gt;&gt;&gt;`, which is the most specific common supertype of both `String` and `Integer`. This is a slightly different concept from a normal recursive bound, and is not expressible in the usual notation (hence the "..." above). Javac doesn't actually infer these types properly according to the spec, it stops at a certain depth, which imo is a bug. But yeah of course that info isn't available at runtime, and certainly has no bearing on the result of `.getClass()` on the particular instance assigned.
P R A C T I C E Nothing beats this word, avoid video tutorials at any cost, start creating small simple programs , divide it into classes play with it , than chose another project and so on gradually ull become a master. Learning programming is like learning to ride a bike, you can watch tutorials all day long but as long as you dont practice it you will never be able to ride it
Multi threading will be part of most of the web application. You cannot avoid. Servlet container like Tomcat, Jetty process one thread per request. We may need to start multiple threads to process the request faster. Consider a scenario, you have return document metadata and its content. Metadata is stored in DB, content is stored in disk. You can start two threads to process both tasks in parallel.
Why should this be on /r/java ?
Cause a lot of people using Java deploy it on Docker containers? If you are a Java dev, maybe you are not interested in all the details and posts of a Docker sub, so you don't subscribe to it, but this is definitely something important.
Because its very commonly used with Java apps?
So is Linux. Do we need a post about every major Linux vulnerability here?
People use lots of technologies with Java, doesn't mean every major news about every technology used with Java needs to be here. It is important, but it really is not directly related to Java.
Oh absolutely. But Java didn't evolve into adopting Scala features until Kotlin came on th scene. In fact they actively dragged their feet. Unpopular, I know.
We use Docker for stuff like our microservices, so I find these kinds of post really interesting.
Seriously? i thought Java devs are the least one who uses Docker, i mean as Java dev with strong packaging that has never seen the appealing of Docker.
Hi ram-foss, based on your scenario, which servlet api do we need to incorporate in order to process both tasks in parallel? Hope you can share that with me too. Thanks.
Basically, most of my code is like ‘procedure’ basis where one method is executed follows by another, so even though there is shared data state(living in memory - I am not sure if it is the case cos I didn’t have to write an SQL to retrieve it but once a user entered the form, the data is available for transfer to another method. Thus, I am not sure how concurrency can be occured since it is one method after another.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Not necessarily, but major Linux news would make sense on a Docker sub.
previously known as groovy features
No need for Docker when one has JEE servers.
Hey, if this is the hill you want to die on. I guess we shouldn't accept posts about Spring or other very important frameworks, even if they are written in Java and extensively used by Java devs. Shit, ban anything not directly about the java.lang package, cause with modules, are they really core Java?
Maybe you not seeing the appeal means you need to learn more and/or have to work with different types of applications. If you work in an environment where microservices are needed/used, you will need Docker.
If you really think that, you might want to reconsider your career choice.
If your data is only living in the stack, it is thread safe: https://stackoverflow.com/questions/12825847/why-are-local-variables-thread-safe-in-java I won't post again, as I think conversation is best suited to /r/learnjava or stackoverflow.
This 'insecure docker' thing is beginning to seem suspicious to me. Docker is amazing.. I mean, so much better than any alternative as to make the rest of them look stupid. I honestly think there is fear in the industry. What is the point of AWS managed services, if you can just use docker containers? Docker is 'disrupting' the industry in a fantastic way.. I think people reposting this stuff are RedHat, Amazon or HashiCorp astroturfers. Just stop it.. it's immature.
Is the book still a good rec? It's woefully outdated and a lot of the stuff you learn isn't even used anymore. If you want just a concepts book there are better ones out there.
Thanks for the link. Didn’t know there is r/learnjava
Perhaps. But not in this case Im afraid. My company uses Docker significantly and a colleague pointed this article out to me. I just posted because I thought others would be interested too.
Don't worry about it.. It's nonsense... it's just scaremongering.
What a great and in depth explanation, I was trying to think of something to help and some examples, but this is already perfect, good job! The only thing I can add ( and it's way more abstract and off-point ) is that when you start getting into bigger projects that use one or many frameworks ( for whatever reason ) you'll find that the more loosely coupled your code is, the better! That means that there are less connections between classes and modules and components, so when you change your dependencies, your other code doesn't need to change as well. Good luck with exploring Java!
A security issue is a security issue, if it's exploitable you can be sure it'll be part of a hacker's toolbox at some point. What makes Docker great in dev and tests also makes it's weaknesses in production, and denying it won't help. No solution is perfect. RedHat, Amazon or HashiCorp will find a way to make money no matter the technology, if you're thinking this is a conspiracy against your favorite tool you have a problem, and it's not technical. Enlarge your horizons.
It's not a proper zero day exploit. It is an exploit which 'could' be used on certain 'managed' docker containers that haven't been properly hardened. The vast majority of people who use Docker do it within a VPC and this flaw will have absolutely no impact on them. Flashing 'docker root access security flaw' all over the internet is mendacious at best.
It has to do with new release cycle not with Kotlin. Brian Goetz points out that their release cycle wasn't healthy, and most of the time [little features got lost under big ones](https://youtu.be/xc6eKUB-dzk?t=720). This is why var was delayed - it just never [cut the priority and got crowded out by big ones](https://youtu.be/xc6eKUB-dzk?t=785).
IKVM \*ducks\*
Is IcedTea even a thing anymore? If so, I can't see any reason to use it over OpenJDK. I also can't see any reason to use Oracle JDK unless you work for a company that insists on a paid support contract; there are just too many other good builds from reputable companies (IBM, Amazon, etc), and the only difference I've noticed is that font rendering isn't as nice compared to Oracle's paid build.
I've been using Corretto. It's free and supported by Amazon. &gt;Amazon Corretto is a no-cost, multiplatform, production-ready distribution of the Open Java Development Kit (OpenJDK). Corretto comes with long-term support that will include performance enhancements and security fixes. Amazon runs Corretto internally on thousands of production services and Corretto is certified as compatible with the Java SE standard. With Corretto, you can develop and run Java applications on popular operating systems, including Linux, Windows, and macOS.
Oracle JDK is a build of OpenJDK.
Other than licensing, Oracle's JDK and Oracle's OpenJDK build are identical (bar several very minor cosmetic differences). Given AdoptOpenJDK's stance of building straight from hg, their OpenJDK build should be almost identical.
I never tried the others, but my preference is the Oracle JDK. I know I am getting the latest &amp; official version. It isn't worth the risk of something being off just to use something that is fully open source.
https://www.azul.com/downloads/zulu/ because it supports apt-get (you can add the Azul repo)
My accountant is very happy with my career choice.
&gt; font rendering isn't as nice compared to Oracle's paid build FYI, font rendering differences between OpenJDK and Oracle JDK should have disappeared as of Java 11: http://mail.openjdk.java.net/pipermail/2d-dev/2018-March/009034.html "We plan to remove t2k completely including references to it from open sources, before JDK 11 GA's"
Hasn't this issue been known for a while? I remember a couple months back on r/programming this exact issue was brought up. Iirc if you mount your docker image as root then you docker has root on the host system. (I didn't read the article to see if it is the same issue).
And how much do you pay for that?
When you make a blanket accusation that everyone writing bad things about your favorite toy is a shill, how are we supposed to know it's not you who is the shill?
Well there are a few things I'd happily advertise for free and Docker is one of them. Cillit Bang is another.. it really works. This is about the 5th time I've seen this 'docker root vulnerability' thing posted on reddit alone, let alone in the thousand or so crappy little tech mags that pop up in my feed. When someone sees a headline like 'root vulnerability' they panic. Fine if you're a developer, not so fine if you're a clueless middle manager. If you actually read about this, you'll see that the Docker team couldn't give a rats ass whether this vulnerability is published or not. Why not? Well because it's not an actual vulnerability, in the real world. It's a theoretical vulnerability that can only have real world exploits in very specific and unusual circumstances. Sure, it's reported.. but the headlines used are suspiciously dramatic. The rate at which Docker is being attacked by people within the industry is suspicious. Certain people really don't like it, and with good reason. They're going to be out of a job.
You can find the prices [here](https://www.oracle.com/java/java-se-subscription.html). It's free for developer seats, $15-30 a year for production on desktop and $150-300 a year per a production server (the price varies by quantity within the range). I should add that Oracle Java support subscriptions pay for OpenJDK's development, and are a great way to contribute something back to OpenJDK (if you can't contribute code). (I work at Oracle but speak only for myself)
Why is de "as"-operator awful? I mean you can still use the classic way to cast, which means using the parentheses, but with the "as"-operator, if some object of a specific class cannot be cast into an object of another class, then you won't have any ClassCastException exception; so a try catch block becomes unnecessarily. &amp;#x200B; Btw, in C#, you can use the "as"-operator everywhere, it's not linked to pattern matching.
I don't do much work at home, so I use whatever comes with my linux box. I have no idea what the organization I work for pays, if anything.
Happy to answer any questions, 1.0.0 has just been released ! :)
Quite a lot of work was put into cleaning up and refactoring the section in the Java language specification around typing of expressions for just this reason. It should be mostly obvious as an extension of the type rules for expressions like \`a ? b : c\`, but if you ever find it isn't clear the spec should now be a lot easier to navigate in that area. When people ask why Java language features sometimes take longer than they think they should to develop, it's partly because that sort of thing is carefully considered, specified and tested.
The reason it seems like that is because we're all still stuck maintaining WebSphere apps with Java 6 that we're "migrating to the cloud" supposedly.
Whys that?
&gt; if some object of a specific class cannot be cast into an object of another class, then you won't have any ClassCastException exception; so a try catch block becomes unnecessarily. A catch is unnecessary for the cast too, because you should probably be testing that the object is of the target type before even making the cast. And when using `as` you might end up with a null, so again, unless you check for that null at some point you'll still get an NPE somewhere down the line. And yes I realise it's not pattern matching. My point is that pattern matching is generally a better solution to the same problems, because it *combines* the conditional with the assignment to a new variable within the same expression. Rather than this: ``` var v = thing as Type; if (v != null) { // you'd better not forget this before you use v! // do something with v } ``` Or this: ``` if (thing is Type) { var v = (Type) thing; // let's hope there are no e.g. copy-paste errors and you cast to the correct type... // do something with v } ``` It's clearer and leaves less room for error to do this: ``` if (thing is Type v) { // do something with v } ``` I think C# would be a better language without `as`.
That's what you should have opened with.
AWS managed services provide some nice benefits like built in auto scaling and needing a lot less configuration than DIY on EC2 instances. I do agree docker is awesome though. I just think the two things are orthogonal to each other.
**Sidebar** in **/r/learnjava** and there **Free Resources**
I just use Sdkman to try and switch between JDKs, it has Graal too which is nice.
I understand that. Though I believe the original idea behind the syntax of Java, as Gosling stated himself, condensed of course, was to create a language that was similiar enough that developers could move between languages such as C/C++, ... easily. &amp;#x200B; I feel Java is moving in a direction where you have to specialize in the language, this is causing me to be less likely to want to use it with new projects in the future. &amp;#x200B; I want developers from all areas to productive as quick as possible. &amp;#x200B; Changing something such as switch to look more functional in nature is a little bit of turn off. My mind could be changed though.
Seems interesting, I tried mapstruct but struggled with some more complex scenarios. Will give this a try.
Using unlikely security flaws as clickbait is nothing new and I agree it is despicable. Docker's popularity will make it attractive to those kind of people seeking attention. Just ignore them.
Super helpful thanks
I'm a fan of Amazon myself. But i can see a world where providers are commoditized and the cost of containers is reduced, and thats what docker will bring. We use amazon redis managed server, but we pay through the nose for it.
Good talk, very informative. Thanks!
Is this a beginner level lecture or higher?
I understand it now, you convinced me! Thanks for the explaination :)
Gosling said that Java is a wolf in sheep's clothing. It looks enough like C++ that people are comfortable with it, but it has more in common with languages like Smalltalk. You say you want developers to be productive. This is one benefit of these features. Having to say `break` all the time is annoying, and can lead to erroneous code. Other features, like [records](https://cr.openjdk.java.net/~briangoetz/amber/datum.html) and [pattern matching](https://openjdk.java.net/jeps/305), will also help in this effort.
Content: * private interface methods * comptact strings * indify string concatenation * stack-walking API * spin-wait hints * collections factory methods * local-variable type inference * next-based access control
It looks like in your [submission](https://www.reddit.com/r/java/comments/bvavak/first_ever_java_deep_learning_cookbook/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Well we can also post everything on new Android devices because Java runs on those I heard.
I'm hardly a ratings whore.. and it's not my job to educate. But, there's definitely an anti docker movement... and it's crazy.
Thanks! Tell me if you have any issues :)
&gt; Apache Ant is considered in the industry as the most complete build and deployment tool. Well, this certainly looks like a carefully researched and highly informative article, and definitely not worthless pabulum from some content farm that's being [spammed all over reddit](https://www.reddit.com/user/FreelancingGig/submitted/). /s
Yep, [once more](https://old.reddit.com/r/java/comments/ba7e9e/how_does_project_lombok_work/). Paging /u/desrtfx.
You were warned. You didn't listen. **Removed** and **banned**
Thanks for the ping.
Can we not downvote legitimate questions?
&gt; WebSphere aaahhhhhhh \*runs away*
How is this different than [ModelMapper](http://modelmapper.org/), which is pretty much the standard for declarative data conversion in Java?
Gosling was refering to the reflection abilities of Smalltalk when he made those comments. That is documented on USENET and in the original Oak specs. Smalltalk and Java today are two completely different beasts. The syntax was always to be as close to C/C++ as possible. That is also documented. &amp;#x200B; I am just stating, especially after more consideration I am not a fan of this.
Why do people keep trying to make Java functional??? Java is an OOP language, and I like it that way.
Disclaimer: I have not used ModelMapper before and will answer your question after doing some research I did while developing datus. The main difference is outlined in model mappers own description: &gt; The goal of ModelMapper is to make object mapping easy, by **automatically determining** how one object model maps to datus does not do any automatic mapping, no heuristics or other 'intelligence' (modelmappers wording). Therefor it is (subjectively) more simple and less magical but also more explicit and flexible. No conventions are needed which allows you to even map data structures over which you have no control over (3rd party, another company, legacy code). [As I read it](https://github.com/modelmapper/modelmapper/blob/master/core/src/test/java/org/modelmapper/functional/Immutable.java) ModelMapper also does not support immutable objects 'natively' as in you have to define mapping immutable objects on your own - so you lose any goodies when you have immutable destination objects. datus explicitly supports immutable data structures in its API with nearly everything that is possible in its mutable API. Furthermore ModelMapper is about a simple mapping from a to b, you cannot add any more logic inbetween (e.g. null-checking parameters and using a fallback, as outlined in datus examples in the readme). So it gets hard when you have some additonal business logic / steps to do while converting. datus allows you do define additional processing while doing conversion e.g. sanitizing or URL escaping some strings. To sum up: * datus does not enforce anything upon you (naming conventions, heuristics) * datus is explicit instead of using 'intelligence' to determine the mapping * datus allows for additonal processing while converting I personally think it's about taste: do you like explicit code or want a library to [detect/guess/intelligently](http://modelmapper.org/user-manual/property-mapping/#skipping-properties) try to map your data structures? I for one want full control and don't want a library to determine how I name my fields. ModelMapper gives you more for free, datus gives you explicitness and you decide what happens :)
My personal experience is that it's much easier to maintain code that does not use any data mapping abstractions. IDEs have nice support for regular code - call graphs work well, finding uses of constructors, etc. Often it's also easier to understand: Mapper&lt;Person, PersonDTO&gt; mapper = Datus.forTypes(Person.class, PersonDTO.class).mutable(PersonDTO::new) .from(Person::getFirstName).into(PersonDTO.setFirstName) .from(Person::getLastName) .given(Objects::nonNull, ln -&gt; ln.toUpperCase()).orElse("fallback") .into(PersonDTO::setLastName) .from(/*...*/).into(/*...*/) .build(); vs Mapper&lt;Person, PersonDTO&gt; mapper = (Person p) -&gt; { PersonDto r = new PersonDto() r.setFirstname(p.getFirstName(); if(p.getLastName() != null) { r.setLastName(p.getLastName().toUpperCase()); } else { r.setLastName("fallback") } return r; }
Thanks for your reply! &gt; finding uses of constructors U have to explicitly pass the constructor of the output object when using the mutable or immutable API, so this works as well. &gt; edit: also refactoring tends to break code when using data mappers Oh I know that pain. This won't happen with datus as any refactoring would also break datus mapper definition and thus won't compile as datus does nothing implicitly. It is highly subjective what code is more readable and as u prefer your code example I prefer the declarative approach :)
ModelMapper can be configured with various different kinds of type mappers. The automated one is the default, which I have also found to be very dangerous. Model mapping can also be done [manually](http://modelmapper.org/user-manual/property-mapping/). Type mappings can actually be quite complex. The entire mapping system is completely pluggable.
No it's not the same. This bug assumes a malicious docker container running, then a user or process on the docker host runs 'docker cp' to copy files into that container, allowing the malicious container is to hijack that action and leverage it into an action on the host filesystem.
That isn’t the only similarity. Smalltalk has a top type, which Java borrowed. C++ does not. What bothers you about the updated `switch`? It lets you say what you want with less code. It is also less error prone. The new release cadence is allowing features to be released at a faster pace than ever before. Some of those will come from functional languages.
It was just an honest question, out of curiosity since, as a student, I'm studying both C# and Java and it occurred to me that Microsoft was releasing more/faster features for .NET (Core) than Oracle did for Java.
But doesn't a programming language become too complex if you keep insisting on being always backwards compatible, which is currently IMO the case for C++?
A lambda expression, in the context of Java, is an anonymous method. The easiest way to illustrate this is to use the `Runnable` interface. Say we have a method that accepts an instance of `Runnable`: void foo(Runnable r) { r.run(); } What we want to do is just have the `run()` method print out `Hello, λ!`. This can be achieved easily by using an anonymous class instance: Runnable r = new Runnable() { @Override public void run() { System.out.println("Hello, λ!"); } //run }; `r` could now be passed to `foo()`. Lambda expressions, though, can make this even easier: Runnable r = () -&gt; System.out.println("Hello, λ!"); In order to create a lambda expression of particular interface, that interface must be what is known as a functional interface. That means it only has one `abstract` method.
I see. Looking at the ModelMapper documentation and how to implement conditonal mapping + additional processing I still prefer the overall API of datus as (their example) typeMap.addMappings(mapper -&gt; mapper.when(notNull).map(Person::getName, PersonDTO::setName)); cannot handle the non-matching case etc. datus overall syntax is a little shorter and less cluttered by `mapper` or the whole input object (e.g. `Person`). ModelMapper is quite the heavy weight (looking at the bytebuddy and asm code generation lib) while datus is just a thin wrapper around basic functional programming :) In essence: You are right, but it's good to have competition, isn't it ? :)
Okay, I think I'm following you. It certainly cuts down on boilerplate.
That's why you really need to put thought into every single language feature, no matter what it is. The Java folks got bitten by this in the 1.0-1.3 time frame, that's why Java progress is considered slow. In the meantime, every classfile can be run by the latest JVM (unless it was using undocumented/unsafe things, but that is to be expected). Interestingly enough, most issues with upgrades have to do with libraries that process classfiles that aren't up-to-date. Java is still relatively lightweight. It will become slightly more complex after value types, records, value decomposition and pattern matching are in, but the beauty of the thing is that these features have so many synergies that the extra complexity is worth it.
Yes, that is one of the benefits.
Oh no! A proprietary heap dump format is right behind you!
Is running your own Redis through Docker on EC2 cheaper? I would think not but idk.
I assume you have seen the basic variation of command pattern before? Think any time of Listener you've seen, or the Runnable interface mentioned earlier. All of these single method interfaces whose entire purpose is to have this one single method called by someone else... What is this? Its a pure object oriented way of passing a function around. Lambdas are a way of doing what we wanted to the whole time.. Pass around the function. No reason to wrap it inside an otherwise useless class/object. Of course that's just a simple case i think most java devs have come across. There are lots of other interesting things you could do with them. Another example i could think of is lazy initialization. (im on my phone or id write code) lets assume you have a Abstract class called Lazy&lt;T&gt; that contains a value of type T. When you call get() for the first time it calls a private initialize() that inits the value and returns it. In a pure OO way, you'd need to extend this Lazy and override the initialize method to do what you want. With Lambdas we could create the lazy by passing in the initualize function. So something like this. Private Lazy&lt;String&gt; lazyString = new Lazy&lt;&gt;(() -&gt; expensiveCallReturnsString());
Riiiiight okay, yeah I see that. I've definitely come across situations where it felt cumbersome to make class for a single function. This helps a lot, I'm sure I'll need to read it a few times to full get it but thanks :)
yes.. at large scale.. redis is single threaded To scale a single instance you need more ram and a faster cpu, but more.cpu's are of little (not none) use. The managed service doesn't scale efficiently in terms of cost, because you pay for cpu's you don't need. Later versions of the managed service have sharding which sort of fixes the problem... But.. though setting up sharding manually is difficult, creating an auto scaling redis on smaller, more numerous instances is far cheaper... and faster. Its a long, painful and complex tale of woe.
I highly highly recommend looking into the stream api and playing around with it (map, filter, reduce, etc). Its a great way of seeing the power of lambdas in action. Ive been a java dev for 15 years and it baffled me quite a bit when they first were added. It wasnt until i was forced to do some typescript and rxjs (which has a similar api to java streams) that it finally fully clicked for me.
Yes..very long story. Has to do with redis being essentially single threaded but ec2 instances scaling by cpu. creating and orchastrating a sharded redis instance is not easy, but once done it is cheaper and faster.
petition to put LXC in cloudabi sandbox
Certainly not for beginners.
I'm not sure what you mean as a top type, but Object is class, not a type. Smalltalk doesn't have this idea. In Smalltalk everything is a generic. Now, this might have changed, I haven't programmed in Smalltalk since the 1990s on an RS/6000. I have not kept up with it. I guess my issue is this, you've turned switch into a function. Literally, it takes an input and returns a value. It is now a function.
Classes define types. And yes they do. See [here](https://www.gnu.org/software/smalltalk/manual/html_node/Class-Object.html). You can think of it like a function if you want, but as it’s name suggests, it is an expression. If you don’t like it, then don’t use it. The existing syntax isn’t going anywhere, but I would much rather read this: char abbreviation = switch (day) { case MONDAY -&gt; 'M'; case TUESDAY -&gt; 'T'; case WEDNESDAY -&gt; 'W'; case THURSDAY -&gt; 'R'; case FRIDAY -&gt; 'F'; case SATURDAY -&gt; 'S'; case SUNDAY -&gt; 'U'; }; than this: char abbreviation; switch (day) { case MONDAY: abbreviation = 'M'; break; case TUESDAY: abbreviation = 'T'; break; case WEDNESDAY: abbreviation = 'W'; break; case THURSDAY: abbreviation = 'R'; break; case FRIDAY: abbreviation = 'F'; break; case SATURDAY: abbreviation = 'S'; break; case SUNDAY: abbreviation = 'U'; break; default: throw new WTFException(); }
Spot on, just read an article on java streams, that's tomorrow's learning all planned out. Thanks so much, that's exactly the right direction to start. I only started learning java because Kotlin syntax is appealing to me and there's less information about that ... But I kinda love it... There's a lot of boilerplate compared to Kotlin or python or whatever but since that's been the case since the 90's the ide will usually generate that stuff... I love how structured everything is (even when I wrote it) :D
Oh boy once you get up to speed with that stuff, i definitely recommend looking into Kotlin. I really dont have any issues with Java and its still what i use at work, but i particularly enjoy using Kotlin on projects at home.
&gt; case SATURDAY -&gt; 'S'; I don't want to get into an argument over semantics, but a class is a type, it doesn't define a type. But what ever.
From JLS 8.1: &gt; A class declaration specifies a new named reference type.
Okay, so an abstract class is a type. Got it.
I was curious, so I tried to see if my university's computers would emit the warning. They are currently running Java 10. Interestingly enough, there was no warning with fall-through. Do you remember which version emitted the warning? Maybe it was removed for some reason.
https://dzone.com/articles/strategy-pattern-using-lambda On another note, using a [Supplier](https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html) allows for lazy evaluation. I.e, in your example you're executing the function first to get the return value which you then pass to the function. When using a Supplier, you pass a Supplier lambda which only gets ran when the method you're passing it to decides to run it.
Which plugins would you recommend for eclipse ? I'm having trouble navigating large projects because I can't find how to make fuzzy search work for class and symbols name, and even full text search does not seem to find occurrences in the dependencies
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Another thing to think about is that it changes the order in which code runs. If instead of void foo(Runnable r) { r.run(); } We had void foo(Runnable r) { System.out.println("Start"); r.run(); System.out.println("End"); } You'd have Start End As output. If we'd just passed the output of the runnable to `foo` you'd have Start End
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Great. Very crisp to the point.
I'll keep this short and concise: lambdas are evaluated as needed, which may not be always and return values are calculated in advance. For instance `Map` has the method `computeIfAbsent` which takes a lambda as second argument. It will only calculate that (expensive) lambda if the key is not present in the map.
I thought it was a literal cookbook that made recipes for you and needless to say
How does this list differ from the list of the top 10 blogs posted a couple of days ago?
The picture of this guy... Depression incarnate
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
How worth is it to use Java over Python for deep learning?
https://skymind.ai/wiki/java-ai
lol just use a constructor: `Person(PersonDTO)`, `PersonDTO(Person)`
Yeah, I know that sometimes incompetent people manage to make lots of money, but that's not what we're discussing right now.
Better be incompetent and have the means to enjoy life than closed in a dungeon playing magpie.
show me a hello world that works on desktop and web and android and ios its currently a lie. it won't work.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Use a command called screen
You can prefix the command you're running with `nohup` and add a `&amp;` to the end. The nohup will disconnect it from your terminal session, so that when you disconnect it'll keep running and the &amp; makes it run in the background. So for examples you'd type in something like `nohup java &lt;rest of your command&gt; &amp;`. The nohup is necessary because of something called process groups in Linux. When you connect with PuTTY, a new process group is created, and the entire group is killed when you disconnect to make sure there aren't stale processes left running that don't do you any good and just consume needless resources. The nohup disconnects the process from the group so it's allowed to keep running when you disconnect. If you want a real deep dive into how this works, check out http://linusakesson.net/programming/tty/ Also, I'd recommend that you find out what kind of service manager your VPS is using (system or sysvinit) and write yourself a little service script for your minecraft server. That way it'll start up automatically with your server and you don't have to worry about it. It can even monitor it and restart it if it goes down. Check out https://www.google.com/search?q=how+to+create+a+service+Ubuntu for lots of suggestions for how to do this on Ubuntu (recent versions will be using Upstart/systemd). If you're using a different flavor of Linux, you'll want to look up specific instructions for that version.
Or tmux.
Please, have mercy!
Not a bad list, I like [TheServerSide](https://www.theserverside.com/) too.
Seems to be a short and slightly pointless precis of this actual study of [JVM alternatives to JavaScript](https://renato.athaydes.com/posts/comparing-jvm-alternatives-to-js.html).
Happy Cake Day!
[This precise question](https://www.reddit.com/r/java/comments/a4tjwk/what_is_your_total_and_complete_honest_opinion_of/) was asked five months ago and got 112 responses, so I think you should find a pretty complete range of opinions in that discussion.
If everyone thought like you, we'd still be in caves. I wonder how old you are, cause if you're not too old you might actually see the day when you're obsolete. Yeah, there's a shit load of shit code running on behemoths like Weblogic and JBoss and \**puke*\* Websphere and there's more code written for them. But in a few years that code might as well be Cobol.
I am a proponent of `var`. Do note that it can only be used with local variables, though. If you do update, I don’t recommend that you change every local variable to use the feature. I suggest watching the talk [var with Style](https://youtu.be/786iemaCJHU) by Stuart Marks, which discusses how to use `var` effectively.
I have not used var with java yet but i have been using Kotlin which also relies heavily on inferred types. On one hand it cuts down on repeating yourself a lot especially with generic types. On the other, it makes reading code just a tad more difficult. The compiler can infer the types... But now you have to as well. Intellij typically makes things like this less of an issue because it will inline the inferred types as hints. But i dont think eclipse or netbeans do this sort of thing? And even worse if you drop into vi or something like that for any reason. I think its quite nice for those times where the type can be inferred by the programmer as quickly and easily as for the compiler. `var list = getListOfStrings()` is fine. `var foo = mysteryType()` can be painful.
I have used this extensively in c-sharp and yes it does reduce a lot of clutter and line noise. It also makes refactoring easier and breaks people of the ridiculous habit of trying to use abstract interfaces for local variables when it's not appropriate. The only time I don't use it is when I need to force it to type because a method I want is not on the class's public interface. But that's more of a COM thing and I don't think I've ever seen it in Java.
I like verbosity/things being obvious. So, not a big fan.
I completely fail to understand why ‘var’ is such a controversial topic that (iirc) Brian Goetz had to do an entire presentation defending it. If you don’t like it, don’t use it.
I wouldn't go back and replace existing declarations with var. I think you need to write new code this way and get a feeling where it helps and where it does the opposite. As a reason to upgrade... dunno, honestly this is not that important in code. It's an improvement for sure, but it's literally a cosmetic change.
&gt; On the other, it makes reading code just a tad more difficult. The compiler can infer the types... But now you have to as well. This is a choice for the programmer to make, though. You don't have to use `var` everywhere. Use it where it doesn't harm readability (which is quite a few places), and skip it where it's easier for the reader to see the type explicitly.
&gt; If you don’t like it, don’t use it. What if you ever have to read code written by someone else?
&gt; I completely fail to understand why ‘var’ is such a controversial topic Bike-shedding. If it weren't that it'd be tabs vs. spaces.
&gt; the ridiculous habit of trying to use abstract interfaces for local variables when it's not appropriate. What do you mean by this?
If I needed to write something in a rush, and don't care how it works then sure. But I think it's important for people to know explictly know what types are what if someone else is reading your code.
Screen worked :)
I generally agree... But as the reader of code you dont get to make that decision. Someone else has already made it for you. And lets not pretend that EVERYONE is making the right decision. Overall i like having the option to leave out the type. When i first started using languages/fearures that allowed it I figured i woukd hate it, but overall i think its been much more positive than negative. Modern IDEs help tremendously to cut back on any of the negatives.
People who think `IList x = new List()` somehow magically decouples something. As if the runtime won't see what's going on and say "you knucklehead, now I have to devirtualize this".
Okay thanks. I typed "what is your opinion of using var in java" and didn't find it. It's from a deleted account though. So maybe that's why i didn't find it.
It makes me think of JavaScript and that’s for dweebs. I am that superficial.
I've seen my coworkers deliberately try to use Java streams every place they can, no matter how much worse it is than a traditional approach, just because it's cool. I know it will happen again with var :(
`var` doesn't allow for dynamic typing in Java. You can't do the following, for instance: var foo = "Hello"; foo = 5; //incompatible types: int cannot be converted to java.lang.String
Haha im probably one of those stream people. The newness will wear off eventually for me, but i do really like how easily some things can be done with them. I could definitely see devs just using var everywhere even if it would really help to be explicit. Its something that bothers me about kotlin and typescript since ive been doing a lot of that lately too. The style guides/conventions seem to blindly recommend leaving off explicit types ANY time they can be inferred. I feel like thats a bad recommendation. Leave it off anytime its obvious what the type is makes more sense to me.
Haha ive always argued that too.. Oh how dare you be be explicit in what you are doing so its easy for me to read later! But there ARE times when being too verbose takes away from whats going on I think there is a happy medium somewhere but i'd rather err on the side of being a little more verbose and easier to read hundreds of times than worrying about typing a few extra characters once.
I know. I’m completely aware of what it is and how to use it. I straight up just down because it’s also a keyword in JS.
I'm just making sure, haha. Some people thought the architects were adding dynamic typing to Java.
Personally I think it is useless. The verbosity of java is a feature and why I enjoy it. I can easily see what's happening. I was a C# dev and the var was a pain in the neck because I had to always hover or click to figure out what something was. If I wanted to do something fast or messy I'd just use groovy and def.
&gt;On the other, it makes reading code just a tad more difficult. I don't currently work in 11 (my company has no plans to migrate to 11+, and I have 50 other things on my list to learn first), but this would be a reason why I would tend to minimize its use in my own code. Not just for my own sake, but for the sake of those who would come after me.
When used correctly it CAN be really nice. For instance is ``` List&lt;String&gt; list = new ArrayList&lt;&gt;(); ``` any easier to read than ``` var list = new ArrayList&lt;String&gt;(); ``` there are plenty of times where explicitly declaring what a variable is and then assigning it to what is obviously that type, especially in the case of assigning to a new object, is extremely redundant and doesn't help at all in making it more readable. its just those other times where you would be better off explicitly declaring the type that is bothersome. Because its easy to just get in the habit of his var all the time and forgetting about those who have to come after you.
There is really nothing special about lambdas in Java. Implementation wise, you can think of them as anonymous inner classes, which is actually how they are implemented. Java wise, it's not true only 'functional' types can be lambdas, in fact any SAM type (even abstract classes) can be turned into lambdas. Non SAM interfaces can also be written as lambdas if you are willing to provide default implementations for remaining methods. But beware, you need to allocate several objects just to get your single lambda instance. If you happen to get a static lamda, it will be reused, but dynamic lamdas that need to be created every time anew because they reference something outside the scope are quite expensive and will increase GC pressure. Don't use lamadas (unless static) on your hot path. Stream API is slow (meaning slower than potentially autovectorized for loop) and increases GC pressure, so unless you plan to use Graal compiler, you should not pollute your codbase with lamdas everywhere - especially the hot path.
Not a fan of the inferred types personally. My belief is most people are going to use it far too frequently and code quality will suffer.
I have really enjoyed taking advantage of var specially on the GUI side. GridPane contentPane = new GridPane(); var contentPane = new GridPane(); &amp;#x200B; Fuck yeah.
So probably best when newing up something, especially with a long type signature, but not when assigning the return from a function call.
Just follow the simple rule to only use var to cut out repetition of the type. Don’t use it if by doing so a later reader of the code can’t see the type right there on the same screen. So this is good: var emails = new ArrayList&lt;EmailAddress&gt;(); And this is bad: var emails = getEmails();
I highly doubt the code quality will suffer by the usage of 'var'. Much more probably the quality suffers because of naming failures, too large methods, method signatures with 20 parameters and the usage of runtime exceptions without adding them to the throws-clause ("because I don't have to!").
&gt; I generally agree... But as the reader of code you dont get to make that decision. Someone else has already made it for you. And lets not pretend that EVERYONE is making the right decision. Sure. My point was that as writer of the code you should think this through before choosing one or the other. I've been writing Scala for the past 3.5 years (no, not really happy about it), and found `var` to be a good thing when used in moderation.
Not a fan. It goes against the diamond operator: ``` var list = new ArrayList&lt;Integer&gt;(); ``` It means having to look at method signature to know the type: ``` var list = getMyList(); ``` That being said, IDE like IntelliJ could make it nice (as it does with streams).
Some more thoughts: I mainly wrote datus to eliminate the need for the myriad \*Factory classes and testing those classes as I have observed that most logic of said factories is so simple / won't break that unit testing seems unnecessary. datus alleviates those pain points as there are no named classes, just interface implementations. The declarative style also eliminates the need for any branch coverage testing for dull logic (null checking, I would not write a unit test for the given null check when written in a declarative way as it's obvious &lt;- this is highly subjective). &amp;#x200B; Even if you implement your conversion factories through an interface you most likely have an implementation class instead of an inline lamda like you outlined in your post which clutters the application unnecessarily.
It was a keyword in Pascal long before JS existed.
Start with Netbeans as its relatively easier compared to eclipse, has multiple languages out of the box (Java/PHP/HTML/CSS/JS/C++/C), and is also quite speedy in my experience. Eclipse may not perform at same speed with multiple language extensions unless you know how to tweak the JVM memory settings, or use hacks like running a separate eclipse installation folder for each language.
Yeah, but I don’t know Pascal
Note that you can still use the diamond operator, and have it infer the correct type, if the type argument can be inferred from a constructor argument (if one is present). For instance: List&lt;Character&gt; letters = List.of('A', 'B', 'C'); var strings = new ArrayList&lt;&gt;(letters);
The only reason to use Intellij in 2019 is that Google forces it down your throat in the form of Android Studio (which is just an androidized version of Intellij). I wish there was an alternative way to develop android apps using maven/eclipse.
Solid! Great talk.
I like it, and I don't like it. It makes life easier, and makes life harder, depends on context and situation. I don't remember when was last time I wrote `for(String s : string)` it's just `for(var s : strings)` now.
What's wrong with using the type inferred by the compiler?
Haha what’s funny is that a lot of JS programmers now follow a best practice of using let instead of var. So it could disappear from JS and appear in Java.
People that think like me are the ones that enjoy JavaScript, while having pleasure watching the magpies sell conferences, books and trainings about why everyone should jump into Coffescript, and years later reap nice consulting fees bringing those business into the safe harbor of JavaScript, while listening to those customers complaining how it was a fouls errand to trust critical stuff to junior devs. Replace JavaScript by any technology hated by magpies and Coffescript by any cool tech that dies in a couple of years. Age brings wisdom to ignore industry fads. 90% of companies jumping into Docker are not Google, FB, Amazon, and friends, they hardly have deployment issues that require such tooling. Docker is the new NoSQL.
IMO inferred types reduce code comprehension. I can see var reducing refactoring efforts but I think that is a bit of a straw man argument.
Local verbosity, e.g. long names of short-scoped local variables, can make the "bigger picture" less obvious. "var" is in a similar category. (IMO.)
Complete garbage without its immutable counterpart, \`val\`. Very good intentions but half-assed implementation which came too late. Both Scala and Kotlin already had both keywords; besides gross incompetence I really do not see any reason for which Java decided to omit val.
[command prompt pop up when attempting to execute the client. ](https://imgur.com/gallery/lvoB9tu)
Scala and Kotlin allow `var` and `val` to be used with fields, while Java does not. The architects decided that adding `val` would be a lot less valuable. If you really want, to can prepend `final` to the variable declaration. More is discussed [here](https://openjdk.java.net/projects/amber/LVTIFAQ.html).
I know the discussion and arguments around this topic and I consider the conscious decision of the architects a bad one. They had a chance and they blew it, again. Sorry dude but final var versus val just looks amateur at best.
Well, as they state in the FAQ: &gt; Immutability is much more significant for fields, whereas immutable local variables are comparatively rarely used.
I'm not a fan of it because I think explicit type declarations are better for self documenting code. I think it's fine for objects where the type is not a base class. But I don't like it for primitives especially. int and var are the same amount of characters.
Java already had type inference before (diamond, on the RHS) and I think it'd have been better to expand that; i.e. something like ArrayList&lt;String&gt; names = new (1); GridPane contentPane = new (); &amp;#x200B; instead of &amp;#x200B; var names = new ArrayList&lt;String&gt;(1); var contentPane = new GridPane(); &amp;#x200B; It feels more regular to me than having possible inference on both RHS and LHS (but not at the same time) and keeps the better readability (IMO) of seeing the type in the variable definition. Downside is it only works for constructor calls and not method invocations, but for those I'm even less of a fan of inference as you don't see any type at all when using var.
I love using it when initializing a variable through the "new" keyword, to not add redundancy. Otherwise I prefer not to.
Dude, I have read that page, why are you copy-pasting parts of it?
Its much worse with `Optional`, because for many at my workplace a complex `Stream` is too much to think about still... `Optional` they just throw around and believe they are now pro-grammers.
That sounds great but if not enforced in the language people will abuse it.
Others may not have, and it is an important point against your criticism.
And how is \*exactly\* it an important point ?
I think your jar file crashes with an error, but it closes too quickly to show an error (or just doesn't show one at all). You can start the program from terminal: * Make sure the directory path to the java.exe is in the environment variable PATH or JAVA_HOME is set. Normally this is done already when you install Java. If not, see this link. * Open cmd, navigate to where your client jar is. I guess `cd "C:\Users\your-user-name\Desktop"` * Run command `java -jar opengl-client.jar`
You said it was omitted for no reason, but that is not the case.
This is how I’m having to do it. I was just curious if there was a proper fix to it rather than just continuing to use this workaround?
No man, I said it was omitted as result of a conscious bad decision or incompetence/sloppiness. The whole "whereas immutable local variables are comparatively rarely used" seems like an excuse constructed when they got called out for it at best or more likely bullshit. This is the exact opposite of no reason.
I guess we’ll just agree to disagree :)
This is a good point and a strike against "var"; the fact that you can't enforce something like this.
When it closes immediately, I think it crashes for some reason, but it's too quickly to see. However its strange because the command does the same and it runs. Maybe your Java installation got botched up or your Windows file association somehow. Could you try to run it on terminal with `java -jar opengl-client.jar`?
Isn't this kind of nonsense what Kotlin is about? Java developers should chase this sort of thing away with a stick in my opinion.
Having used it in C# for years (and more extensive inference in Rust more recently), I see no issue with it. Code review can catch poor variable naming and good naming choices will improve code much more than verbose declarations. And where it's confusing, you can still use a typed declaration instead. You've already had inference in another form with lambda arguments where the type could be elided entirely (allowing var there has a different purpose and doesn't change the existing inference). IMO var is a readability improvement and a time-saver.
It is a poor decision that Java introduced \`var\` and not \`val\`. Personally I can live without \`var\`, I hardly ever use mutable variables. If you want clean and maintainable Java code I recommend lombok + vavr.
What's wrong with this? If `getEmails`'s return type is `List&lt;EmailAddress&gt;` then it seems fine. Any IDE would let you click through or highlight `getEmails` to see the signature.
Only use it for undeclarable types
In a 10 year old project, id hate to think how ugly the code is, simply doing a mechanical replacement of type stuttering to `var` isn't going to do shit.
It's the origin of the "var *name* : *type*" syntax that's finally starting to make a comeback after decades of language designers thinking they need to slavishly imitate C.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
My main issue is that I would expect a collection of `Email`s not `EmailAddress`es. If it does return the latter, then the method should be renamed to be clearer what it returns.
Give your code 1 point for every developer who will work on it, 1 point for every source file, and 1 point for every 6 months you plan on using it. If it scores more than 3 then implicit typing is going to cost more time for someone to figure out the code than it'll save to not have to restate something obvious.
So your issue is with the method name and not that a `var` is being assigned to the return of a method call instead of the instantiation of an explicit type?
I think because getEmails() could return List&lt;String&gt; or Collection&lt;EmailBody&gt; or something else? There’s just a little too much ambiguity and room for assumptions by programmers unfamiliar with the code in question.
Yes, because it's badly named with or without using `var`.
So it has nothing to do with `var`. It's a bad example against the use of `var`.
And anyone faintly familiar with typed languages and IDEs should have no problem with that.
Well var exposes the need to make your method names better. With explicit types you can continue to get away with bad method names; with var you can not.
Why is the second example bad? Since `var` is for local variables only, it would live in context, such as: var emails = getEmails(); var newsletter = templateEngine.render("newsletter.html", specials); mailer.send(emails, newsletter); Does knowing the type of `emails` or `newsletter` improve the understanding of what is happening? Granted, methods could be overridden and do wildly different things depending on argument type, but that seems like a bigger issue that should be adressed independently.
Yes totally, in your example I can’t tell you what type of object is being returned by getEmails(). So if I’m coming into your code after you I have to drill into the getEmails method to know what is being returned where I would not if var was not used.
Finding what to type is isn't the problem, it's the fact that you need to put your mental focus on finding it out. People can only hold up to about 7 discrete ideas in short term memory at once, looking around for a type will take up one of those.
That's what the IDE is for. The variable name is `emails` and that should be a good enough hint elsewhere in the code. If you need to double check then an IDE should be able to tell you the type on hover. If not then the compiler will pick it up. Granted, this argument is coming from someone that programs 99% in Scala and has a pretty deep hatred for the verbosity of Java but this seems like such a small problem.
But why is this level of detail interesting? When reading code, the logic is the interesting part. The types are relevant when the variable names suck, in the hope that the class names are better. Say \`emails\` is \`Iterable&lt;FrameworkEmail&gt;\`. What difference does it make?
As you said, IntelliJ will show the types, but not many other IDEs will, so if you think it helps you should probably just add the type annotation anyway (or let IntelliJ do it for you)
It’s a huge difference, sure the logic is the interesting part but in more complex examples you may need to know the object type to really understand why the code is doing what it is doing. The later example actually means something and you know things about it. Arbitrary “emails” could be absolutely anything and doesn’t tell the reader anything about what can be done with an email or what it really possesses.
The point of a programming language is to be readable, not to be decoded by an IDE.
[Style Guidelines for Local Variable Type Inference in Java](https://openjdk.java.net/projects/amber/LVTIstyle.html)
From the perspective of someone who often works in Scala, var is a non-issue. The only main problem with \`val\` and \`var\` in Scala might be when used for any public fields, and IDEs like IntelliJ typically warn you when that happens. Apparently, Java \`var\` s are local-only. &gt; Or would I just sound stupid saying that? While I personally wouldn't need much convincing that upgrading Java versions is a good idea, the reasoning you gave is rather weak. You should probably consider strengthening this argument with various other advantages you'll gain from an upgrade, depending on what version of Java is currently used in that code-base.
At a high level `var emails = getEmails()` is readable. A type can be inferred and if the type ends up actually mattering down the line (it's obvious `emails` is some sort of iterable) you don't even need a code editor to search for `getEmails` in a codebase. This is also being argued without any context so I'm not sure how you can make the case that that code wouldn't be readable. What if it's just a part of an asynchronous functions that gets a list of emails and then sends the same email template to all of them? Something that's probably 2 lines of code is plenty readable with `var`.
Right, if the type helps in understanding of the code, it should be present. I'd argue that in simple cases like this, it's more valuable to put the spotlight on the logic. For most simple methods (the majority, one would hope), the types tend to hide the program logic, which in turn hides bugs. It's all a tradeoff, I'm just saying removing extraneous detail to put the interesting bits in focus has value, too.
I would never want to work on java code base where other developers shared your sentiment. Nothing is ever lost by typing other than a few key strokes and in real world use simple examples like this become embedded in very complex things and then benefit from the disambiguatity.
If you can’t read someone’s code because the type of a variable isn’t mentioned twice, you need to have a serious discussion with them about naming things
just sitting on a cactus
I hate it. Anything that makes it harder to read code is a bad thing.
Not everything in life is IDE
CPU and memory is a lot cheaper than a developer's time. Better to run the IDE.
Knowing specific types is usually pretty important to understanding specific code, otherwise you have to infer it from the methods being called on variables or use the IDE. For a collection, maybe the type isn't as important as for other things, but you still don't know if it's a List of Email or String objects or something else.
&gt;infer it from the methods being called on variables or use the IDE And what's wrong with that? Readable doesn't necessarily mean you have to know exactly what every type is at all times in order to understand the code. Python code without type hints can be just as readable as Java code with explicit types. Basing this off of a single line of code calling an ambiguous method is silly.
This is a people problem not a legitimate argument against var. People can also call the database in an unbounded loop, and build bad class hierarchies, those aren't arguments against loops and polymorphism.
It's called code review.
You invest your time in reviewing code, I will invest in relying on the readability of Strong Typing.
It just happens that most programmers are people. The language should be designed with that in mind.
Because you shouldn't have to rely on an IDE to make code readable. It should stand on its own. Not having type information can require more mental processing, especially with strict static typing and for someone who hasn't read it before or isn't familiar with specific methods. And of course it helps even more if you want to modify the code.
A prime example would be presenting the code diff for peer review, where there is not much context and no IDE to help determine what emails is. Making the type obvious in that snippet would definitely help the reviewer.
You didn't address my comment at all and just reiterated your previous points. I'm talking about this specific example which obviously isn't enough to prove either of our points.
And someone reviewing the code probably has context and if they really need to understand types and APIs then they can pull the code. It takes less than a minute to do `git fetch` and `git checkout`. Maybe your point is valid if you have to read it in plaintext right then and there but it's not really a great point if you have control over your environment.
That's really reaching. In the many cases they don't have the code at hand, and I imagine a less than thorough reviewer would simply not bother looking it up, which can lead to dangerous assumptions.
&gt;less than thorough reviewer This is just moving the goal posts. Assuming someone won't be thorough when reviewing code isn't a reason to write code differently.
It's certainly not an after-the-fact justification. This point was discussed multiple times during the design of the `var` feature, well before it was finalized and delivered. You may disagree with the decision, but it's not incompetence, sloppiness, or bullshit.
Making it easier for them to understand the code correctly without requiring extra effort is my main point. Much safer, simpler.
Exactly. This is part of what code reviews are for.
&gt; without requiring extra effort For 1 line maybe. But doing it for every single line that you add/modify throughout the entire commit cycle might end up being a huge difference in time. Even for a 100 line change, how many lines do you think you add and end up deleting throughout the process. If you end up writing out explicit types for every single one then you're just adding a ton of extra effort. Compare that to the time it takes someone to fetch code and I think one is clearly less time.
I think you're missing the OP's point. Just do it where it helps readability, as in the example provided.
I think you're missing my point. The example doesn't have enough context to say whether it's actually helpful or not. You're assuming that the code is so complex that the only way to know the type of `emails` in the implicit case is by using an IDE. That might not be the case.
Not really, the example is great. getEmails() could return anything, and without some context it's hard to know what the code is dealing with, especially if it's a code diff/snippet under review external to an IDE. That's my thought, you're welcome to prefer brevity if that works for you (and everyone who needs to maintain your code in future).
We've been doing it for years and every one I've met that has come from writing explicit Java ends up preferring Scala by leaps and bounds (including the rampant type inference inherent in Scala).
I mean you should still prolly have code review regardless of the strength of your typing.
I don't fully understand the issue here. Lombok has been around for a whil and they have supported var and also val for a while. No one complained or questioned then. Simple rule of (clean) coding: Computer language is for you to communicate your intent to fellow programmers. Var can be used where it helps follow the above rule effectively. Where variable name is descriptive enough. Where type is absolutely clear and visible, where there are fewer declarations in the method etc. For example, var should not be used with a variable to hold return value of a method. And if you are not using Project Lombok, you must check it out.
Absolutely. I didn't mean to detract from the overall value of reviews. Just that I would not rely on code reviews when it came to not using Strong Typing.
Typing still "strong" with var. Now, sometimes you can have implicit types that will be infer at compile time.
I hate it and I hate lambdas too. (most of the time) Seeing types really help when going through an unknown code from a platform and domain you do not master, e.g. going through intellij-community when writing plugins.
&gt;kotlin &gt; &gt;Intellij typically makes things like this less of an issue because it will inline the inferred types as hints &amp;#x200B; First, the topic is about var in Java, not kotlin. Second, readability is central to most reader's comments which var can render inoperable in some or too many cases, when conducting a code review using a tool like Azure or Atlassian PR's or even plain diffs.
&gt;Personally I think it is useless. The verbosity of java is a feature and why I enjoy it. Thank you, the OP and all the salient points by readers, except the ones saying "var everywhere". Picture Chevy Chase in Modern Problems.
Pascal accounted for about 1 billionth of 1 percent of any code that ever mattered, scientific measurement. /s &amp;#x200B; variable name should not be first. It is wrong. It is why the leading languages today and throughout history and the future of all programming do it, type var. Type mattes. &amp;#x200B; Period.
Great talk.. Learned something cool that "LVTI would enable us to use the Non denotable types in java"
Um, why didn't you put the /s at the end? Am I supposed to read the rest of the comment as beginning your honest opinion? Are you a time traveler who knows the entire history of all programming ever?
Types are supposed to be for the Compiler / language server, less clutter makes it easier for thr programer to focus on the semantics. Also the syntax is in line with modern languages like TypeScript and Rust. The later has really long type definitions, so it is easy to see the benefit.
Gluon Scene builder is literally for javafx.
To be quite honest, I do not think Java is readable or writable without an IDE. It takes too long to ask basic questions about the codebase, like "what are all the concrete classes that implement this interface" or "find all uses of this property/method/class", or even just "what all public constructors exist for this type". At the first, I was told that it's good to know how to write code without an IDE, so I tried writing code in both C# and Java without an IDE but it turns out that only very, very simple programs can be written without IDE. Merely figuring out the package names for correct imports is a task in its own right without an IDE. So, if using an IDE is a given, then there's barely any cost to using `var`. You can just hover over the type, or the method call, if you are interested what that concrete types are. It may be that my background as a programmer in scripting languages has led me towards think this way, because typing information didn't use to be available, and duck typing is common. Even now, I find nominal typing a ball and chain at leg, and would much prefer having structural typing instead. `var`, perhaps, slightly reduces the drag I feel from nominal typing because I no longer name quite so many types. And speaking as someone who finds the generic types such as `List&lt;String, Map&lt;Long, EmailAddress&gt;&gt;`, extremely painful to write, I've welcomed `var` especially when working with the streams API. It is almost like writing a scripting languages again: you can concentrate on evolving the expression that calculates the result, and can leave the drudgery of expressing the intermediate types to the compiler.
total crap.
Are you one of those people that prefer to return null instead?
Just another useful tool that will be abused by the concise squad to create confusing code. Lambdas &amp; streams, great ideas till you get people who will write entire, undebuggable, unreadable programs in one line.
I work as a contractor for a big organization and, judging by the quality of code that I have to maintain for them (made by their "best professionals"), I know it's gonna be overused and a readability/clearity hell.
Okay, and? a) wrong sub. this is not a tech-support subreddit. b) "didn't work" and "nothing happens" is no description that anyone can help you with. Are others supposed to check their magic crystal ball in order to help you? Try providing some context.
I hate it. For several reasons: 1. It throws away the concept of programming to an interface. 2. It hides your intent. You now have to look in an unfamiliar place to find that intent (right side of the equals) 3. Closely connected to point 2, it changes how you read code. Normally you read the important stuff on the left, and it gets less important as you get to the right. var up ends this convention. 4. People will use this out of laziness more than anything else. It will very rarely be used to improve code. It will only be used to type less, which will likely lead to less readable code.
Which OS are you on? Which JDK version are you trying to install (the official one from Oracle?). Probably share some screenshots of the last step as well.
Considering that a lot of people write perfectly working programs in dynamic languages or heavily type inferred languages (Haskell, ML) I think it is laughable that people seem to have issues erasing type signatures. I'm not a fan of nonlocal type inference but people seem to don't even need those.
I think it’s fxml.
You know fxml means javaFX Markup Language right?
Yea, Gluon scene builder creates fxml files. We were discussing javafx scene builders in this thread.
Please explain to me the difference you make between javafx and fxml
I’m not saying they’re different. They both have different approaches on how to create a GUI.
first things first: upgrading just for that reason should not matter. Yes, developers happiness is important, but there should be a higher focus for example on security. The same discussion was introduced when lambdas hit the scene: oh no, we are missing types! but after several years of adoption, nobody would argue, that an anonymous class is a better choice. `var` was introduced to reduce the boilerplate of generics. So examples like var emails = new ArrayList&lt;String&gt;(); are a no-brainer. So the special case seems to be method result assignment like var emails = this.emailService.fetchEmailsForUser(user); I am not sure if the type is actually required here. I personally think, that most people did not try it out and just comment by "seeing". It is like using different programming languages. "no my language is the best! other languages look totally stupid how they do that and this" but after actually programming for few months in that "stupid" language you would understand the architects' design choices. Maybe some additional food for thought: which version would you rather see verbose style: List&lt;String&gt; emails = new ArrayList&lt;&gt;(); Stream&lt;String&gt; emailStream = emails.stream(); Stream&lt;Employee&gt; employeeStream = emailStream.flatMap(employeeRepostiroy::findEmployeeByEmail); List&lt;Employee&gt; employees = employeeStream.collect(Collectors.toList()); "typical" style: List&lt;String&gt; emails = new ArrayList&lt;&gt;(); List&lt;Employee&gt; employees = emails.stream() .flatMap(employeeRepostiroy::findEmployeeByEmail) .collect(Collectors.toList());
Win10, java Version 8 Update 211. Gotten from oracle. There's no screens to share as running the installer simply does nothing
It's great! I juggle a lot with generics and denoting them doesn't add value to my code, so inferring them definitely helps!
Do you have crystal balls? 😍😍😍
Meh. getEmails().forEach(email -&gt; { }); Suddenly it's good again? It's ok. Let it go. `emails` means "more than one `email`. It's probably a collection or an array, who cares.
Java *is* strongly typed, whether you use "var" or not.
Have you check spreadsheetView from controlsfx
tl;dr: Zip file entry names may contain `../`.
The fact that this was a deliberate decision specifically makes it even worse. This seems to be an unpopular opinion in this sub but hey, at least I know that this sub is more like a cult than a discussion forum.
In my opinion the type is an information you do not need. It does not help to understand the business logic of the code. The purpose of types is safety and safety only. That's why scripting languages like python or languages that use type inference more aggressively, like Kotlin, are considered more readable than languages like Java.
Thanks for the link, I read the article. Hadn't heard of TeaVM or JSweet before but both look interesting, though I tend to lean towards TeaVM.
Are they rarely used because they are not useful, or are they rarely used because of fucked up amount of bloat the current syntax provides? I've noticed the same people who didn't use local final variables in Java do use them extensively in Kotlin, with mutable variables being limited to a small number of variables they actually meant to mutate.
`Optional` is shitty thing for performance. Having `Optional` in low level / core library (networking/encryption) is a sign of poor quality. We can tolerate `Optional` in Hibernate where IO delays much larger than object instantiation time.
I had this exact problem before…...
When reading or writing code, I do not care what type it is. The variable name tells me what data or functionality I can expect inside and the compiler/IDE tells me if I was wrong. Nevertheless, I would prefer val rather then var. 'final var' is too much typing in 2019 and readibility suffers.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Totally disagree. If I follow you, what is the meaning of enum? Why do you have classes? Using good name in an API is very important. Removing types lead to a lot of very bad codes.
&gt; It throws away the concept of programming to an interface. You can't avoid programming to an interface in Java without using reflection. It's not some Javascript where everything is exposed.
&gt; 1. It throws away the concept of programming to an interface. How? You still have interfaces, you still have return types, this changes literally nothing in that regard. &gt; 3. .. it changes how you read code .. Normally you read the important stuff on the left, and it gets less important as you get to the right. What about chained methods, streams, etc? They all evolve from left to right, narrowing down the result until the end which is the most important part.
Class is also a keyword in js. Better stop using classes.
No, I think you've misunderstood me. A *people problem* isn't one that exists because engineers are human and fallible, it's a problem that is best addressed by having person to person interactions and training for the specific people causing the problem, not passive aggressive restrictions on everyone. If you have bad engineers `var emails = getEmails();` is the least of your problems but probably the easiest one to deal with.
Many people like Java because of how extremely explicit you need to be. Other languages like Python or Javascript lose how explicit they are at the cost of less error catching *before* it happens. I think Java should stick to explicit definition of everything.
Will use for explicit local variable declarations like: var index = new AtomicInteger(1); &amp;#x200B; Will never use for values "coming" from a distant place like: var something = superDuperFunc(); &amp;#x200B; That is my humble opinion.
It works, as long as you exactly know what type is returned from the method name. `getEmail` should return an instance of a class or Interface `Email`, but what about `email.getRecipients()`? is it a set of strings? A list of `InternetAddress`? Or a collection your own `Recipient` class which holds the recipient type (cc, bcc)? I like Kotlin, but if you don't pay attention readability will suffer a lot from lazyness of explicitly declaring typesPlay store link: [Boost for reddit](https://play.google.com/store/apps/details?id=com.rubenmayayo.reddit)
When ES6 came out, I started using struct instead and piping all my source files from cpp to javac to make it work.
We are talking cross purposes here. I didn't say we should get rid of classes. I said we do not need to tell the compiler of which type a variable is, when it can figure it out on its own.
I love it, long overdue. I'm surprised that a lot of Java people don't like it. Are you getting paid by the kilobyte?
Sometimes you need to look at the definition of the type to know things like what it inherits. Emails can easily have different implementation. It's easier for everyone that didn't write the code. I'm your example the lambda should have it's parameter's type declared. People using lambdas like this bugs me.
Your inclusion of diffs, code reviews, and other tools outside of the primary IDE is a great addition to the discussion and one that I think people forget about quite often. I'm just not sure why you took such a hostile tone. Yes this is a topic about var in java, but var in kotlin is literally the same thing and has the exact same pros and cons. I also mentioned that intellij inlines the inferred types, but i guess you stopped there cuz right after that I said that basically nothing else does and so that can be a problem.
As always, it depdends. The best is to avoid having some nullable return result, e.g. return empty collections or make sure it's never sure in the path you control. Sometimes I create Nullobjects, sometimes straight returning null seems a better fit and sometimes returning Optional is a good solution. However it's not just about returning Optionals. There are people that make fields with it, use it in parameters, return Optional&lt;List&lt;X&gt;&gt;, in properties, use temporary Optionals to map and filter, ...
Understood. My point was about instant readability
Try the installer from [AdoptOpenJDK](https://adoptopenjdk.net/releases.html?variant=openjdk8&amp;jvmVariant=hotspot#x64_win). If it still doesn't work, you can install Java without an installer: * Download the *.zip from AdoptOpenJDK * Unzip it to C:\Program Files\Java * Set JAVA_HOME and PATH. See this [guide](https://www.mkyong.com/java/how-to-set-java_home-on-windows-10/). * Check if it works by opening command prompt and `java -version` gives a result Note that all this will give you an OpenJDK / OpenJRE version, but that shouldn't matter at this point.
&gt; Gotten from oracle. How about https://adoptopenjdk.net as an alternative?
You would have the same (theoretical) problem with the following: mailer.send(getEmails(), newsletter); Meanwhile, according to Martin Fowler's *Refactoring* (1st Ed.) that's good code.
I agree. It's only going to get typed once, but read many, many times. Programming should be done for the maintenance programmer's sake.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
It’s minor syntax change. It just takes a few hours to get used to. Inferred typing is common in just about all the other modern languages. If this one feature hinders someone’s ability to read java code, I wonder if they’re in the right line of work.
See, people aren't judging the feature on its own merit. They judge it based on countless of prior discussions they had, like "hey let's write this in Node" and then an argument ensues about how typing makes Java a better platform for large applications, and JS is shit and bug-prone, and in that argument someone throws in how "they like seeing the type in the code", despite this has nothing to do with whether the type is *inferred* (like in Java's var) versus it being *dynamic* (like in JavaScript) and some impressions remain long after the fight. And then "var" shows up in Java and people take this emotional baggage of years of arguing about this shit, and they freak... the fuck... out. I mean ideally we wouldn't have shitty drivers drive trucks, or shitty software engineers write software, but we're humans, what can I tell you. Shit like that is part of what our society is like. Imperfect, but the best thing we know there is. I think the greatest skill of a modern professional is to know not to get into shitty battles like this, make their own determination and carry on, letting everyone else shoot themselves in the foot if they want to.
I get that it sucks to type `ArrayList&lt;String&gt; list` but why are you ever typing that? Just introduce variable in your IDE and you'll get the correct type with no effort and leave better code behind for everyone who follows. I haven't manually defined a variable type in years, I thought no one else was either. Here's how it works in Idea: [https://blog.jetbrains.com/idea/2010/11/smarter-and-faster-introduce-variable-in-java/](https://blog.jetbrains.com/idea/2010/11/smarter-and-faster-introduce-variable-in-java/) And if you're not using an IDE to write Java and are asking for `var`, please switch to another language and leave us alone. You'll like Go or Kotlin or something better anyway. Overall, we're going to look back on 'var' as a bad idea, probably within a couple years. It'll start with larger teams banning it from their codebase for code readability and code review reasons, but we'll all eventually realize it's a poor tradeoff. We save 1 developer who didn't want to use an IDE a small amount of time, and the code is less readable for everyone who comes after (including the person who wrote it).
Any IDE would have also introduced the variable with the correct type with no effort, so why don't we just do that instead? Use the IDE once, instead of every person using it every time we try to read this thing, forever.
It seems like you've got a lot of experience dealing with situations like these. :-)
Haha LOL
If they're going to throw a fit over every syntax modernization, they'll be having "hey let's write this in &lt;Not Java&gt;" discussions more and more often.
I've experimented with JSweet on the side, it is fun to work with, produces good results without having to touch JavaScript at all. I wasn't aware of J2CL, will look into it, thanks.
I don't know. I'm happy to have some languages be more conservative, and some more "progressive", like C#. Because C# has so many great features, but over time you see how the entire platform is becoming a mess of "there are 100 ways to do this".
Literally six posts down: https://old.reddit.com/r/java/comments/bvkuxl/writing_web_applications_in_java_a_study_of/
Why not just `return`. It's the same as we do in lambda block expressions now.
I haven't used Windows in a while, so unfortunately I cannot really suggest which log files to check for, but what /u/_INTER_ suggests in his post will work fine as well. It doesn't need an installer - you can simple unzip it to a location of your choice.
So just because it's not in Java (except Thread.yield()) **right now**, you can cause more confusion with todays polyglot developers than a break can? Also this will make future feature additions more difficult.
Can't both of these features be situated as concurrency primitives? Yield is dominantely associated with concurrency. Not regular return. That's what I'm trying to say and what bothers me with this JEP.
You said these use case are 'not returning results' and these are absolutely about returning results. 'Not regular return' yes I suppose, but that's not what you originally said when I responded. You also originally said 'threading' , and now you're saying 'concurrency'. Yes they're related to concurrency, but not threading in particular, so again that's what I was responding to.
The `yield` statement will always be the winner. If you meant to invoke a method, you will have to qualify it.
Makes my reading harder because the declarations don't start with the types.
And linters.
If you don’t like the syntax, blame C.
It looks like in your [submission](https://www.reddit.com/r/java/comments/bvzh9x/javafx_binding_stringproperty_and_use/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
https://www.owasp.org/index.php/Test_Upload_of_Malicious_Files_(OTG-BUSLOGIC-009)#Zip_files_path
I understand what you mean, but maybe people don't understand what I mean :-) The type is informative in a way similar as the name of a class. Defining good classes is not an easy task and if we can accept that some syntatic sugar can be used in some particular cases, it is not a good idea to remove the types. Assembler has no type but I am not sure that it is more readable... Redundancy is often a way to facilitate the read.
Surely, the IDE will help you navigate to the declaration?
One thing's for sure. At the introduction of the `import` statement, the same kind of discussion must have taken place: &gt; "I don't know what the qualification of this type is if I don't see it with my eyes" In fact, the same type of discussion took place when Wheeler invented subroutines: &gt; "I don't know what the implementation looks like if it is moved to some external subroutine"
Jeez, do you need to declare it if you do something like getEmails().contains(...); Noo, it didn't matter, since Java 1.0. "Just" use it sensibly, like everything else.
Thanks for fighting the good fight. In every `var` discussion it seems like Scala and Kotlin come up. In addition to these languages allowing `var` and `val` with fields, as you mention, they also optionally allow one to specify an explicit type. Thus, `var` in Java is considerably different from `var` in Scala and Kotlin. Java's `var` is much more similar to C#'s `var`, which has similar restrictions (local variables only, no `val`).
Basically all `javac` versions I tested emit fallthrough warning with `-Xlint:all` option, so I don't see any change or regression here.
Heh, interesting. I don't know how seriously this was considered. One issue is that it applies *only* to constructors on the RHS. It wouldn't help with declarations like this: var bi = BigInteger.valueOf(longVal);
If this issue is relevant to you then I would recommend reading the [Snyk writeup](https://snyk.io/research/zip-slip-vulnerability). Firstly, The OP article doesn't add anything to the original - and more seriously it has an error in its suggested code fix which the Snyk folks did not make.
You’re welcome! I’ve followed the discussion and am pleased with the direction you all went with. This is just bikeshedding at this point, haha! Thank you for all you’ve done for the platform!
https://www.clojurescript.org as well
They thought about using `yield` with lambdas, but some were concerned about the connection with concurrency in other languages ( as some are now). The problem with `break` is that it doesn't really fit well with other expression blocks. What if `if` expressions were added to the language one day? Have different ways to yield a value in different expressions isn't great. I agree that other pseudo-keywords could work, but they went with `yield`. Goetz discusses this [here](https://mail.openjdk.java.net/pipermail/amber-spec-experts/2019-May/001303.html).
I do only know about the one in control pantel to set the global setting, however, I would recommend if you have a certain program you want to have a specific maximum heap size, add the command line param xmx and a value to set its max heap size.
Alright. Just do it for the individual program J want at 14G while leaving the rest of Java free to use the 28G? That may work, but I'll have to see if it can override that weird thing I did the first time around.
It can be surprising but it really isn't. The entry path is just a string and a file format cannot prevent it from containing `..` especially when crafted by hand.
Could just link to https://renato.athaydes.com/posts/comparing-jvm-alternatives-to-js.html.
I’m not saying functional programming style is bad which is your example, I’m saying if you’re going to declare a variable it should be for good reason aka not just being passed as an augment and if it is being defined for manipulation or multi utilization you should define a type. I anyone can find examples to justify poor coding standards then finding a source to quote out of context to further justify it.
https://youtrack.jetbrains.com/issue/IDEA-188689
It looks like in your [submission](https://www.reddit.com/r/java/comments/bw3kw4/gif_isnt_displaying_correctly_when_using_imageicon/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I'm making this game, but I'm unsure why the gif isn't displaying properly. Is this something to do with Imageicon not being able to display gif's correctly? &amp;#x200B; this is how I display the gif... &amp;#x200B; public void twinTreesMainA() { position = "twinTreesMainA"; image = new ImageIcon(getClass().getClassLoader().getResource("twinTreesMainA.gif")); imageLabel.setIcon(image); enemyHealthBarPanel.setVisible(true); enemy2HealthBarPanel.setVisible(true); }
It’s quite the statement to rewrite Storm in a old dead* language like Java from a bleeding edge, programming language du jour like Clojure.... * /s
Wow - huge blow to Clojure. I like Clojure but I can't see how it makes sense in any context today. Boutique languages like Clojure, Scala etc. came about because Sun abandoned that platform. Kudos to Oracle - whatever their other faults - they've kept improving the platform so that a project like Storm has come back to the fold.
It's not for telling the compiler, it's for telling humans who read the code later.
I wonder how much of the performance improvements came from the move to Java, as opposed to rearchitecting.
Most likely Java is indeed installed but it is not part of the environmental variables. If you have set it up as part of the environmental variables, please note it WILL NOT BE reflected in active terminal sessions. Open a new CMD instance and try java -version on that , that should work. /u/_INTER_ has covered how to add java to the environmental variable.
If the return type is not a collection and there was no exceptional condition, it is superbly acceptable to return null. Imagine `String.indexOf` throwing an exception every time it came up empty. Optional is occasionally useful, but no more so than a javadoc comment or a Nullable annotation
They came out because there was research in functional programming on the JVM. Java is still too imperative to be fluently used for functional programming. Vavr is a great improvement in that direction. Oracle is also patent trolling Java and Java EE, so I don't know what to think about them.
I'm doing this so often. I know it's not worth it. Yet it's so difficult a habit to get rid of.
The LISP family of functional and dynamically typed programming languages, where Clojure belongs, exists long before Java. And it could survive for a longer time.
LISP: The second "old dead language".
I partially disagree here. Imho the type is secondary information. It is not needed to understand the business logic of the code (=what the code does). It is needed, when you want to know the implementation details of the code (=how the code works). When you read somebody else's code, the information that a variable is of type SomeClass doesn't help you at all unless you investigate the class declaration. Therefore the type only creates noise when reading. Languages like Python or Kotlin are considered to be more readable than Java and they omit the type completely.
You can add C and C++ to that list. Many languages are considered dead by fanboys, but turns out they are widely used everywhere.
Except C &amp; C++ are not even remotely dead.
It looks like in your [submission](https://www.reddit.com/r/java/comments/bw7m5r/is_teavm_going_to_be_javas_version_of_microsoft/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I'd say it's largely a philosophical question. Clojure performance can certainly be improved by writing it in a more Java-like way - i.e. using transitory objects rather than immutable data structures - using type-hints to avoid reflection - etc., etc. But if they had done that, would would non-idiomatic Clojure code still be a useful reference as an example of a Clojure application/library? The opposite is also a dilemma. A re-written Java version will do things differently, so can't be directly compared as language-level changes. The only rational conclusion to take is that it is rational to write core JVM libraries in Java, given how: a) it'll take advantage of the platform's performance better; and b) it'll be easier to call from other languages than the opposite. These two things are both true regardless of the specifics of the languages in question.
This. As the first and second high-level languages, Fortran and LISP could be considered "dead" WAY before C and C++. But first... COBOL, then maybe RPG, APL, BASIC, PL/1, MUMPS, Pascal.. Forth. And those are just the languages I know of that are older than C and still in production. THEN maybe C and C++ m'kay?
The vast majority of the time I don't really care what they exact type is. So long as what it returns has the correct API for how I want to use it, the specific type doesn't matter.
List or collection? Who cares. This is Java we're talking about; people are going to cast it to an interface no matter what is returned anyways.
Line noise. The vast majority of the time the specific type is more of a distraction than a help. The important thing is on the right-side of the `=` operator.
&gt; We can tolerate Optional in Hibernate where IO delays much larger than object instantiation time. Is it really? I don't know Hibernate, but in the case of EF and NHibernate you actually spend more time being CPU-bound than waiting for I/O.
&gt; 1. It throws away the concept of programming to an interface. No, `var` does not allow you to bypass a class's public and declared interfaces and start writing directly to its private fields.
Thank you for fighting the good fight, but I fear that Java programmers as a community will never understand that concept.
Many C# programmers feel the same. Except for 'val' itself. It is too visually similar to 'var' (and audibly indistinguishable in languages where r and l make the same sounds). So instead we're asking for 'let' and 'var'.
I kinda begin prog (&lt; 1 year) and it's already kinda manageable, and great quality ! Thanks for sharing that.
I'm new to prog (&lt; 1 years) so it's worth what it's worth, but IntelliJ at the current time is doing so much more than Eclipse to be accessible, it's really great ! It auto import maven dependancy and any battery not included easily, which is really great when you clearly don't know enought yet, and the file handling is much easier. With Eclipse, I could export a project, import it, and bam, problems. With Intellij I just open it like in any other IDE or code editor I had before (VSCode, Brackets) At the current time, IntelliJ is plug and play, Eclipse isn't (at least in my noobish experience)
A far better name, far more explicite, I'll steal it.
Even if, like the Java language team, you have also experience designing a language with ten million users and have studied usages in codebases hundreds of millions lines long, talked to big Java shops etc., it is still possible for you to reach a different conclusion. But that it is different from yours does not make the language architects' decision "grossly incompetent." Language design is an art, and even experts with decades of experience designing hugely successful languages like the Java language team and you can have disagreements.
IMHO negative aspects outweigh positive. While types can get bulky and pollute code it can be solved without var. You already have auto completion so you don't have to type whole type name and visibility can be achieved with proper color schema. On the other hand types can provide some incite and hints. For example what can you infer from this declarations? `Map&lt;Long,String&gt; thing = getThings();` `Collection&lt;Map.Entry&lt;Long,String&gt;&gt; thing = getThings();` `ConcurrentHashMap&lt;Long,String&gt; thing = getThings();` &amp;#x200B; Argument "programmers should be good" is stupid. We have a lot of juniors and a lot of irresponsible developers/leads/managers such is life.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
In case you're actually trying to be helpful, let me point out that you merely asserted that a certain decision was a result gross incompetence, sloppy or just consciously bad, without providing any reasoned argument, based *only* on that you disagree with it. Now you are asserting that this is a cult rather than a discussion forum, based *only* on that others disagree with you. An observer that does not know you personally could come to the conclusion that instead of participating in a discussion, you just like slinging insults.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Thanks, gotta fix my code...
They moved to Java for performance and abundance of skills, not because as a language (syntax, features, etc.) it was better than Clojure. I have said this dozens of time so everyone hates me when I say it again, but lambda expressions in Java suck because of checked exceptions, even though there are workarounds. Sorry!
Please, head over to /r/learnjava and read the sidebar there. This subreddit is not for help with learning Java or with Java programming. **Removed**
Moved post to r/learnjava
Disagree. It's never worse to have it specified, sometimes much more confusing, and occasionally can even introduce errors.
Get ready to be massively downvoted!
&gt; Oracle is also patent trolling Java and Java EE Not true.
At this point, why even bother, the torch has been picked up by &lt;insert here one of the may options used to day for what storm used to be used&gt;
Just curious if anyone has any experience with Hippo/Bloomreach? Better than WordPress for a Java developer?
Checked exceptions are almost non-existent anymore. In our code we don't have them. It's an annoyance when you come across an odd library these days, but really not a problem.
That's true. Spark has replaced Storm.
Linux, Windows, macOS, iOS, git, memcached, Postgres, nginx, etc.... All dead technologies written in a dead language....
I wish the author had provided some performance figures for before and after the suggested hibernate tuning.
LOL. It can't possible introduce an error as it can't change the semantics of a Java application. In C# it could, in theory, because interface method A doesn't have to match public method A. But that's only theoretical, as nobody actually does that.
What can I infer? That in all cases you can reduce the code to just, getThings(); since you are obviously not using the `thing` variable. So we just need the side-effects from `getThings();`. **** That's the problem with most arguments against `var`. You only show the first line, which eliminates all of the contextual information which would otherwise alleviate the need for knowing the exact type.
That's only an option for leads and hobbyists. For the rest of us we have to deal with it, like it or not.
Fun fact, C# is planning on adding RHS type inference for `new`.
I was never a fan of Scala, but I am curious why we are seeing rewrites of Scala code in pure Java. Can someone answer this?
I think it's fair to point out that the efficacy of the Lisp ecosystem has run it's course and been proven deficient. Paul Graham et al have proven you can perhaps get to market quickly with a Lisp project but this has been just as true and, perhaps proven much more effectively about Python, Ruby, and Node.js. So, even that advantage of Lisp is now effectively gone. IOW - Idiomatic Lisp in any form just isn't going to be able to compete for long-term production needs. The main advantage now of Lisp is as a learning tool I think. It's just so flexible, and so easy to implement that one can't help but learn a ton from it. Heck, maybe you'll even be able to get a product off the ground with it. But honestly, it's not my ideal starting point.
Really? They seem to have different use cases. Maybe it's true you could replace Storm with Spark for most needs you have, but they don't have the same organizing principles: https://www.whizlabs.com/blog/apache-storm-vs-apache-spark/
Unspecified types can lead to errors when refactoring, it was mentioned as a risk factor in the JEP. It's probably a pretty rare case, but considering the limited upsides of this whole thing - not worth it.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I'm not an expert in either. But, over the last 4-5 years I haven't seen any Storm usage at the companies I've worked for but lots of Spark.
You can use a password management service (like AWS Secrets Manager) to store the password, and then retrieve it at runtime using an AWS client. Alternatively, store the password in an encrypted file or encrypted column in a database table, and limit access privileges to that table/column. On the Gmail side, instead of using the account's master password, create an application password that you only use for this application (you can have separate ones for dev/qa/production). Even better than all of this, though, is to use a service like Mandrill/MailChimp or Sailthru to automate sending emails; then you don't need a Gmail password of any kind stored anywhere on your system.
I've seen it as well and not Storm, but mostly in the service of processing log data for ELK clusters. Only once have I seen it being used for something else.
Having used for roughly a decade in C#, I've never seen that happen in real life. You would have to have two types with the same semantic meaning, and the same method names, with nearly identical signatures, but the method A in the first would have to have a different semantic meaning than the method A in the second. Yea, it could happen. But it is incredibly unlikely.
That would require some real business use cases, but the Petclinic application is just a demo one. However, you can find really useful benchmarks in my [High-Performance Java Persistence book](https://vladmihalcea.com/books/high-performance-java-persistence/).
I usually store passwords as env variables.
Use Mail Chimp, Adobe Campaign or other dedicated service for sending e-mails. There is high chance the emails will not get into spam folder and you'll get some stats about the emails.
Storm was written in Clojure
I don't really think you'll get many gains by switching to 'var', and in fact, you might end up with a mix of declaration styles which will just make things worse in terms of readability. &amp;#x200B; My #1 refactoring tip is to leverage the IDE to declare everything 'final' as much as possible to try to lock down variable mutability (yes I know 'final' doesn't mean immutable, per se). Then focus refactoring efforts on areas with lots of cyclomatic complexity, variable mutability, presence of nulls, etc. &amp;#x200B; While some may consider it 'verbose', marking things 'final' is key to assist in understanding overly complex code, as it gives a degree of confidence about what the state of any variable is, no matter where you are in the method. Focus can then be reserved for what is actually changing state, and the core business logic that engages those state changes.
You mean what IDE do we use? The most IDE for Java is Eclipse. I prefer using Intellj. This is paid while Ecplise is free.
Ah that is actually a very good idea, thanks!
I tried with sendgrid, but the email go to the spam folder. I am just trying to do a simple reset password email.
Intellij Community edition is free
Haven't you read this one https://codahale.com/the-rest-of-the-story/ ? We have a substantial code base from the Scala craze days and I wouldn't call it other than cluster f**k. Full of implicits, custom one liner 'helper' functions with half assed semantics, obviously undocumented and all the usual Scala goodness. Yes, Scala has unmatched type system. No, it does not teach you to be disciplined and responsible. Also JMM and Scala are not exactly friends. Immutability is fancy and cool until it isn't, at which point, the unnecessary GC pressure isn't worth it. Graal can help Scala nowadays, but the damage was already done. Java has sub par type system (some may say), but it mostly works and the language is reasonably fast when JIT compiled (like C plus plus fast minus value types and stack allocated datastructures), so... That is my subjective reasoning why this phenomenon is taking place.
What rewrites? Storm was Clojure. The main driver I guess is lowering the entrance barrier for new contributers. Performance and tooling also play a role.
The Ultimate Edition is free for students!
You can use text editor (VS Code, Atom, Notepad++, Sublime) for command-line Java or IDEs (Eclipse, IntelliJ, Netbeans) for the complete experience. Almost everyone uses some IDE.
Intellij IDEA is free for students or Open Source projects.
Have look at Magnolia CMS. &amp;#x200B; It is a Java CMS and includes plenty of features within community edition.
&gt; but I am a bit sceptical in having to use the email password in the properties file This is a standard approach. But, you wouldn't put the password in the `application.properties` file that is checked into your repo, which are don't have any secrets. Instead, you would have a separate, environment specific `application.properties` file that is installed on the server with the proper permissions so that only the application can read the file. Spring Boot will combine the files as described [in the documentation](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html). If you're not using Spring Boot, the idea is the same, but you would have to load the properties files separately yourself.
Okay, cool! Thanks, man!
Okay, thanks man! I think I'll download Eclipse then.
&gt; The most IDE for Java is Eclipse. If you meant "the most used", that's rather dubious: this year's SO developer survey has IntelliJ at 25%, Eclipse at 14%, and NetBeans at 6%.
Note that for the free Open Source license, there are [several additional boxes](https://www.jetbrains.com/community/opensource/) you have to tick: &gt; - You have to be a project lead or a regular committer. &gt; - Your OS project meets the Open Source definition. &gt; - Your OS project may not offer paid sponsorship, or receive funding from commercial companies or organizations (NGO, education, research, or governmental). You may not provide any paid support, consulting or training services for your OS project, and you may not distribute paid versions of your OS software. Contributors who are paid to work on the project are not eligible. &gt; - Your OS project is in active development for a minimum of 3 months. &gt; - Your OS project's community is active. &gt; - You release updated builds on a regular basis.
Great talk
I use Intellij ultimate at work but prefer NetBeans for personal projects using gradle. Sometimes Geany, Gedit or Nano are plenty good enough for quick edits though and then gradle on the cli.
[https://www.vaultproject.io](https://www.vaultproject.io) Has also SpringBoot support.
Please, head over to /r/learnjava and read the *sidebar* there. It has useful learning resources (Free Tutorials) that help you getting started. **Removed** as *programming/learning help*
You will have an infinitely better experience with IntelliJ, I assure you. The community edition is free and has everything you need to learn and develop small to medium sized apps.
\&gt; It just happens that most programmers are people. All of them are people. Those who are not would have moved into management already.
\&gt; I like verbosity/things being obvious. So, not a big fan. I share that view. However I found one good use for var. Suppose you need an anonymous class, like a button listener, but with additional members. var myBtnListener = new ActionListener() { int x, y; public void actionPerformed(ActionEvent e) { // do something based on x and y } }; myBtnListener.x = 5; myButton.addEventListener( myBtnListener ); These additional members, like x and y might somehow influence the action listener's behavior or 'state' in some way. This new anonymous class does have an anonymous type. But since that type does not have any kind of name, without var, you cannot access the internal x and y members. You can't cast to that type because it has no name to use in a cast. But var is of that type, and thus you can access both x and y of the anonymous class. This is the only thing I've found which demonstrated to me an actual use for var that contributed some new capability that I did not formerly have.
I'm working a lot with it at work, but I havn't touched wordpress in a few years. From what I remember, it's night and day. Wordpress always felt like a chore, and while Hippo/brXM (what a stupid name!) certainly has its oddities, I like it way better. I'd recommend you checkout the opensource version and follow the tutorials they provide [here](https://documentation.bloomreach.com/trails/demo-tutorials-and-download.html). Feel free to DM me if you have more questions!
You're still doing this is straight Java without an OpenGL library right? What type of framerates are you able to hit? I was doing testing over the weekend and full screen image framerates are not the best even when ensuring hardware acceleration is turned on.
This. Exactly this. If you use it immediately you don't need to add a type declaration and no one would bat an eye, but if you need to save it for later then it gets all verbose and ommiting the type is seen as bad? Even if you just need to null-check-then-use do you really need that type name so badly?
This stays fun to watch! I would probably have gone for just one fence with a pole on each side and made a key for turning it instead of thz multiple type of fences.
That's a great suggestion! I might actually do this in the future when I di the upgrade on the fences that I have planned! Thanks for the idea!!
Correct straight java no fancy libraries. The game runs at 60 and on my computer I can pull framerates in the 1900 range while playing
Nice, and I agree.
Yes, right. Personally I'd have found the expanded inference for constructors good enough, although I see how it's a bit lacking in the case of static factory methods as in your example.
You re welcome :-)
Ah, another rockstar that can dream up code faster than they can type. Code is read MUCH more often than it is written, think about that.
Just painting a JPanel?
Soon we'll introduce hungarian notation again to deal with the unreadability of this useless new keyword. Java is such a great language exactly because it is verbose. A snippet can be understood with very little context. Compare that to languages that seem to think that development speed is directly correlated with letters typed on a keyboard... Or languages that allow redefinition of almost anything through pre-proccesors, typedefs or otherwise. Unreadable without digging into everything it imports...
A canvas actually.
Anything but a rockstar. All of the code that I write gets reviewed by a subset of a dozen or so engineers before it can be merged and deployed just like all of the code that's gone into production in the past 6 or so years at the company. I have no problems with someone trying to read my code and commenting "can you make this a little more readable?" It gives me an idea of how my coworkers think. But I'm not going to go out of my way to make my code more explicit than it needs to be.
Maybe you could make the fence menu sticky while building a fence and close by pressing already available [x]
This is amazing
Do you have any suggestions for someone who wants to try to do the same? I am trying to make a strategic game and it’s so difficult for me (a newbie)
Wish you did a from scratch series, I would have loved to learn from you
Great suggestion! That's definatly something I'll keep in mind and play with when I do the fence upgrade soon :)
Thank you so much! :)
Theres lots of good resources online but the biggest thing is to just do it. If you dont know how to do something ask, and most of all just enjoy it :)
Its something I've considered doing for a little while now!! Its definatly something that I will likely start doing sometime in the future :) If I were todo something like this would you rather have longer episodes more like once a week? or shorter episodes more often?
nice work. what IDE are you using?
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I think goal based episodes are helpful because people that people that already know what to do in certain areas can just skip that episode Example - Episode 1 - setup / Canvas - Episode 2 - making a player - Episode 3 - making a fence - Episode 4 - creating NPCs - Episode 5 - Creating NPCs part 2 - Episode 6 - making items You get the idea, if you set a time frame for example **30 minutes every episode**, then it might be rushed and you might make mistakes or have to do a lot of editing to cut it down to 30 minutes, but if the point of each episode is " ok we are going to do this " it might take 10 minutes it might take 1 hour as long as you get there in a none boring way without rambling and getting off topic. This also can stop you from making a 30 minute episode that only needed to be 5 minutes. **Programming is only getting more popular** so a future project would be a great idea to consider, just make sure you dont have a hard to understand Indian accent and a clear microphone and you'll do great! *But that's just what I think*
Flink also has huge role in stream procrssing, as low latency is still a low-prio task in Spark and only basic map-only jobs can be launched in low latency mode. There are few more alternatives like Gearpump and Hazelcast Jet. For smaller jobs/low latency I'm choosing Jet over Spark, as Spark's PMC focus is now in completely different things.
1) Storm was written in Clojure, not Scala 2) Sometimes I see such migrations (from both Clojure and Scala), because of performance (JVM is optimized for Java) and readability (some people really hate "haskellization" of Scala, which makes Scala's code less readable)
Wow lots of info! Thank you so much for taking the time to give me a hand with this! Yes programming is always getting more popular so getting into this will draw more people to the channel and help me to grow and share something I love and am passionate about! I like the idea of not worrying about the time frame and focusing more on the topic and getting it complete! I really appreciate hearing your thoughts and opinions so thank you so much!!
I'm using netbeans :)
verbosity is a feature. i hate inferred types. In Swift IOS i often lose time digging for types... even on code i write. when i want to look at the class code. or when reading code snippets on SO. that and the lack of getter setters and abstract classes(swift) makes me wonder why swift and kotlin are supposedly modern languages. i always want to go back to Java.
Pretty sure this is still 3d.
Its actually not, everything you see is flat images draw with some perspective to appear 3D with the shadows and everything
Looks great! I'd recommend going for a auto-rotate method tho. Think of Minecraft. You place a couple fences at the sides of 1 fence, and it turns into a right angle shape, and so on. :)
Great suggestion!! That is actually one of the first things I want todo when I upgrade the fences is have maybe a few selectable parts then make the rest change based on the fences around them and the snapping system :)
Nice! Sounds like you've got this, and are off to a great start! I make my stuff in Python, but might move sometime. :)
Thanks for the support I really appreciate it! I've messed with python a few times but never did anything serious aha. If you ever do move to java shoot me a message I'd love to work with you :)
Will do! I moved to Python just today. xD I was trying to find a program that could make a program, and was going to go with Java, but no IDEs were reading Java for some reason. So, I settled with Python, and just made a calculator off of what I learned in 2 hours time. xD
I'm on the longer, once a week type deal.
I personally use the netbeans ide but have worked with eclipse as well in the past and have really enjoyed both! Calculators are always a great start and can be as complicated or as simple as you want! Good work :)
Greatly appreciate the feedback!
No problem, i think your work looks great, best of luck and I'll hopefully see you on YouTube sometime soon!
Thanks! The plan is to get that started soon! I appreciate the support :)
Thanks, man! I understand what you mean by they are a great start. I made mine between simple and complex by making it run in cmd, but have the ability to not close when the code is done, and calculate by addition, subtraction, multiplication, division, and even by PI. I really enjoy Python, but I miss making 2D games on Unity. I moved to UE4 for... various reasons. However, the 2D on UE4 kinda sucks. Hence, why I might try and figure out Java. Great job on your project!
for sure! i really like working in java, it was the first language i was serious about and this is by far the biggest game ive ever made in it but i still love it and love learning more
There's been some talks recently about many popular libraries and programs (not java) being vulnerable to this type of malicious entries in zip files.
We will build a fence in this decade and do the other things, not because they are easy, but because they are hard.
Pretty cool, what are you using to hot reload the code while the game is running?
The best bet in Java-land is Graal &amp; Truffle. They also have an implementation of an LLVM bitcode runtime with near-native performance, for comparison. It's reasonable to expect similar performance for WASM if someone does that. Interestingly, not only is the Truffle platform an appropriate host to consume WASM, but the Graal compiler may be able to implement it as an AOT target.
The Graal compiler may be able to target WASM in the future for AOT. It may also be able to consume WASM as a runtime via Truffle, as it does for LLVM bitcode. I mean, someone has to implement it, and I've seen no indication that Oracle intends to as of yet ... But the technology has certainly proven itself to be an appropriate basis for such an effort.
My team uses it and everyone hates it. Their custom database is pretty bad, build times are massive. That being said WordPress is even worse.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
When was SQL API become CPU-bound?
It's not. The bulk of the time is spent waiting for the ORM's materializer to convert the resultset into objects.
I'm actually not XD when I have to test changes to code I close and reopen the game, the other thing this helps with is ensuring the saving and loading all works properly :)
Can you please give some code examples for each of the cases of the problem you are trying to solve and how it looks with your solution? Personally I find lombok builder + mappers rather fine, it's plain java and thus everything is easy to do. Your api seems rather complex for something so simple, also how would you go about enriching models? &gt; separation of concerns How is this more separate than using a normal mapper? &gt;reducing dependencies: enable your businesslogic to operate on parts of a data structure instead of depending on the whole object (e.g. upper casing a persons name in a .map-step) There are multiple solutions for this. Use a mapper for this specific case and if you want to limit access to the other fields you can use a projection interface. &gt;cleaner abstractions: programming against an interface instead of concrete classes Not quite sure what you mean by this. It's just an API to call getters and setters or a constructor. &gt; declarative/functional-programming approach From what I can see mappings are imperative, binding is declarative, but I find no advantage to declaring a binding rather than actually doing the binding. &gt; simplicity: compared to Lombok and Apache MapStruct no additional IDE or build system plugins are needed I have not used MapStruct but Lombok is really simple, it's plain java for the mappers. The magic behind lombok is assumed and not that hard to get your head around in terms of usage. Meanwhile your API is rather complicated. The argument that plugins and build system are not required is not really relevant. Do you build your project using javac? Every compiled language in the world has a build system. Since java lacks the features for data classes or however you want to call them this gap has been bridged via compile-time libraries. &gt;explicitness: no black magic - you define what to map and how (compile-time checked), not naming conventions, annotations or heuristics How are traditional mappers not explicit? Naming conventions, annotations and heuristics are faster than writing a complex mapper using that API, not to mention the fact that it is an abstraction hence leaky by nature. &gt; low coupling: leave your POJO/data classes 'as is' - no need for annotations or any other modifications Those annotations are there in order to increase productivity. Json annotations, xml annotations, validation annotations, lombok annotations, they're all there to simplify an aspect that you want to handle fast. Coupling is a different issue and has to do with what you want to do with that "POJO" no coupling gets you either nowhere or to a over-complicated api that becomes its own programming language. &gt; less classes: no more 'dumb'/businesslogic less Factory-classes that you have to unit test You write unit tests to be able to refactor later. Avoiding unit tests is not something to be proud of. Whether you write unit tests for mappers or not is your choice. If your team decides to not write tests for them just exclude them from your code coverage tool. &gt; cross-cutting concerns: easily add logging (or other cross-cutting concerns) via spy or process(see below for more information about the full API) This needs an example for me to see it, I haven't found any link to your api doc to check how you would do it either. Although from the looks of it you're just moving all those responsibilities to the declaration of the mapper, which doesn't really solve much. Please provide an example. &gt; focus on meaningful unit tests: no need to unit test trivial but necessary logic (e.g. null checking, which once fixed won't be a problem at the given location again) Provide example. &gt; clarity: (subjectively) more self-documenting code when using datus mapping definitions Subjectively complicated api for calling setters, getters and constructors with reflection and function references while also limiting what you could normally do. It's hard to see the advantages, maybe you can make it clearer in your documentation. There are a bazillion API-s and libraries for many languages, we don't have time to test them all.
So today i had to read some Swift Code geoCoder.reverseGeocodeLocation(location) { (placemarks, error) in if let placemarksFound = placemarks { for placemark in placemarksFound { } } } What the hell is a placemark? In Java with Eclipse/IntelliJ i hover mouse over the type and i get a javadoc popup explaining it.
You need context? ok. You get this piece for review public void showSomeTable(String userName){ var table = new Table(); var items = getItems(); LOGGER.debug("items: {}", items); items.forEach(item -&gt; table.addRow(item.getKey(),item.getValue())); setAdditionalInfo(table, userName); showToUser(table); } Do you have issues with it? What type has items? How about this code? Is there any issues? public void showSomeTable(String userName){ var table = new Table(); var items = getItems(); LOGGER.debug("items: {}", items); items.forEach((key,item)-&gt; table.addRow(key,item)); setAdditionalInfo(table, userName); showToUser(table); }
JVM != /r/java
Looks like the type doesn't matter at all, as you are just shoving each of its two properties it into a generic row structure.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
That is where you wrong. `Collection&lt;Map.Entry&lt;Long,String&gt;&gt;` implies possible key duplicates. And you have to go and ask business analytics whether it is acceptable or you need to have some checks before showing table to user. `ConcurrentHashMap&lt;Long,String&gt;` implies possible access from different thread which can lead to inconsistent data shown to user. You need at least defensive copy. &amp;#x200B; And just like you many reviewers would just skim over code and accept it. While unusual data type might trigger wtf and warrant closer look.
&gt; Collection&lt;Map.Entry&lt;Long,String&gt;&gt; implies possible key duplicates. So what? If that is a problem it needs to be handled inside `getItems()`, which you have chosen to hide even though it would normally be part of the file. &gt; You need at least defensive copy. Oh don't give me that bullshit. The mere act of making the defensive copy is just as susceptible to race conditions as reading directly from the collection.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
P.S. The fact that you had to use two code samples instead of one further proves that you are over-reaching for an example where this would actually be a problem.
To continue playing the game, Map&lt;Long,String&gt; items = getItems(); While not my preferred style, it is very common for the local variable to be typed as the smallest possible interface. Which means you still don't know if it is a ConcurrentHashMap or not.
&gt; ConcurrentHashMap&lt;Long,String&gt; implies possible access from different thread which can lead to inconsistent data shown to user. Since you opened that door... `Collection&lt;Map.Entry&lt;Long,String&gt;&gt;` does not ensure it won't be concurrently accessed. Maybe you are supposed to always use the results of `getItems()` under a lock. The local variables type alone is not sufficient to answer your question. If unsure, you have to look at the definition of `getItems()`.
Does compiling C# to WASM yield better results than compiling it to JS?
Are you using a BufferedImage to assemble the view then doing a simple drawImage() call to the canvas or are you during each render update just drawing it all to the Canvas Graphics object directly? I've been playing with the first approach and for particularly large video screen sizes the BufferedImage approach slows way down.
&gt;Collection&lt;Map.Entry&lt;Long,String&gt;&gt; implies possible key duplicates. &gt; &gt;So what? * &amp;#x200B; &gt;If that is a problem it needs to be handled inside getItems(), which you have chosen to hide even though it would be part of the same file and thus visible even without an IDE. Ok. You clearly have never worked on any big project and have never performed review.
I have worked on large projects. Which is why I know that decision has to be made during the data modeling step long before any code is written. If keys are allowed to be duplicated, you can't just hide that fact in the presentation logic.
Though the library is built in Scala, I have made efforts to ensure Java interop works and included documentation for this. I see discussion on r/java about libraries such as Play Framework which by this strict definition are also off-topic.
Im drawing to the canvas object directly, I find its easier to work with than the first option
Don’t store user passwords if you can help it. Encrypted passwords are also best to avoid if you can because you’re then burdened with how to store encryption key as well. Hash then and compare hashes; use something like bcrypt for it.
Try Liberica JDK installer for Windows [https://bell-sw.com/java.html](https://bell-sw.com/java.html) Any version of 12.0.1, 11.0.3 and 8u212 should be fine.
Which version you have tried? 3 latest ones (12.0.1, 11.0.3 and 8u212) automatically set all file associations so it just works.
Can I clarify the Hash password that is created by bcrypt is it then stored in database, after giving it to the user? And so why we need the java.security.auth.callback.Callback handler in the picture?
You don’t give the hash to the user. You store the hash in the database and when the user attempts to login, you check their password against the bcrypt hash. There should be simple libraries out there to generate hashes and compare passwords against. I use spring for this.
But, I want to skip the registration part where user will give me the password. How should I handle it then? And also this module will only be made available to a few users.
Thank you. That is good to hear. I'll reach out with specific questions.
Thanks. That sucks to hear. I grabbed a copy of JRebel to help with build times. By the database are you talking about the JCR? Regarding WordPress, do you have experience with it too?
I don’t know that I can help move the needle for you on trade offs, you seem to have a good grasp on the trade space. When it comes to doing integrations like security, or whatever, I feel your pain on “I just want to do X which should be a super common use case” which lacks good examples, docs, whatever, but to some extent that comes from the great deal of control and flexibility afforded by these frameworks. On the other hand, once you take the plunge and get those things working, they tend to stay working even as you upgrade dependency and language versions. Good luck getting that from the node.js ecosystem. Having said all that, if the quickest of quick starts is your goal than Java frameworks that you aren’t already familiar with may not be the best choice. Spending a month to get a simple web project up and running sounds high, but you should realistically budget a week or two for “boilerplate” since you aren’t familiar with the frameworks. I would think that would be enough time to get a basic app up, running and deployed (or deployable). Also consider where it might make sense to “buy” vs build. These days that means integrating with some “cheap to start” third party service where they will have better getting started docs and examples. Auth0 comes to mind on the security side. AWS has some product here too but they are a lot harder to get productive with. You can always replace them if the operating costs are too high in the long run, but, at least with security, sometimes it’s worth paying someone else to help you stay on top of the evolving threat environment.
\&gt; Which is why I know that decision has to be made during the data modeling step long before any code is written. rofl. i have a bridge to sell. For a change can you write any benefit of using var?
I'm not a web developer and I generally think people should use whatever platform they feel most comfortable with and that meets their requirements (in terms of performance, stability, ecosystem etc.), but I just want to address one part of your post, as I work at Oracle on OpenJDK: &gt; Oracle's licensing change for their JVM distributions, the JavaEE ownership transfer The license change is simple: Oracle has recently open sourced the entire JDK, which means that instead of just as serving as the source code for ~95% of the Oracle JDK, OpenJDK is now the source code for ~100% of the Oracle JDK. As a result, the JDK, which used to contain both proprietary and open source bits, both free and paid features, is now, for the first time ever 100% free and 100% open source. Oracle builds OpenJDK and releases it under two names: Oracle JDK, which is the commercial version for Oracle support customers under the commercial OTN license (the money from the support is what pays for OpenJDK's development), and [OpenJDK builds](http://jdk.java.net/) under the usual OpenJDK license (GLPv2+CPE). &gt; the Java trademark thing I *think* causing the Jakarta rename The issue there is about Java standardization. People may disagree about whether Java should be standardized or not, but the reality is that both Sun and Oracle have stood behind strong Java standards. The standardization body for Java is called the JCP, or the Java Community Process, and the `javax` namespace has traditionally been reserved for APIs standardized by the JCP, including Java EE. Jakarata, or anyone interested in Java EE, can choose to work within the JCP and change the `javax` namespace, but Jakarta does not want to do that, and for valid reasons -- the JCP process is slow, and non-JCP-standardized projects, like Spring, have been able to innovate faster and have done pretty well without standardization. So now the question was whether Jakarta would be able to change the `javax` API *as if* it were working through the JCP without actually working through the JCP. Oracle offered to allow Jakarta to do that in exchange for help in enforcing another Java standard -- the most important one of them all -- Java SE. Jakarta chose not two, and the two sides came to an agreement on the Java EE IP transfer to Jakarta that does *not* include the right to replace the JCP as the owner of the `javax.whatever` namespace.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Unless you're delegating the authentication authority to another server (OpenID, SAML, etc), you can't skip the part where you get someone's password. JWT is just an elaborate way to use a password. While I haven't used specifically, I've used similar techniques with integrating React + Java rest backends. I would recommend starting with something like Spring Boot + Spring Security. It's a bit higher level (and can get complicated), but you can follow the guides until it "clicks" and you "get it". Spring Security ([or one of the alternatives](https://shiro.apache.org/)) has built in integrations for OpenID which would [allow you to have someone authenticate with Google](https://developers.google.com/identity/protocols/OpenIDConnect) (or some other OpenID provider).
&gt; I can't spend a week to a month just doing boilerplate, which I often hear complaints about with Spring MVC. This is strange. The most common complaint with Spring Boot is that it's "too much magic", and *not enough* boilerplate! It takes a couple of minutes to spin up a new project. I suppose it's a different story if you're skipping Boot, and using raw Spring MVC directly. But even most large enterprises don't do that anymore with new greenfield projects. &gt; the login mechanism the [Spring Boot] starter project it generates is worthless (1 ephemeral username + password) It's... a starter project. Any serious framework you look at (in any language) will indeed seem a bit overengineered for your specific use case, because they have to be flexible enough to support a wide variety of authentication types and sources. But using Spring Security to read usernames and passwords from a database isn't THAT complex. There are a million StackOverflow posts and Mkyong articles on it, if you search for them and don't expect the manual to provide the exact drop-in code that you need: https://www.mkyong.com/spring-security/spring-security-form-login-using-database/ Spring's also not the only game in town. There's Grails, which was targeted at the Ruby on Rails crowd and might be a bit more newbie-friendly. The same people have also produced Micronaut, which is a more cloud-friendly light framework that might play nicer with Beanstalk or other such constrained deployment targets: https://guides.micronaut.io/categories/micronautsecurity.html
[thoughtworks tech radar](https://www.thoughtworks.com/radar/platforms/osgi)
I can’t integrate with Spring because the framework I am using is JEE servlet, JSP and Tomcat.
If you don't understand the importance of data modeling, nothing else I say will make any sense to you.
Hola, Java with spring boot is perfectly for your need. If you don't want to spend time with security there is keycloack integration. With database there is spring data And for Web development there is spring web
That's all integrates fine with Spring.
If you're familiar with Java and don't like the boilerplate (and frankly I wouldn't recommend it for a lone developer) I would recommend Kotlin. It still runs in a JVM so you can get the performance you need, but it's lighter weight when it comes to the actual code. I have only minimal experience with Tomcat but I'd also recommend you look at Wildfly or Thorntail as an app server.
What about scala?
This is similar to my stack and situation. I'm a solo freelancer with a couple of small businesses as clients for which I have created some small server-rendered apps. I have used Spring Boot with Java and Postgres for most of them. More recently I've done a few projects on Spring Boot with Kotlin and now I start every project in boot/kotlin. Take some time to investigate Spring Security. The situation you describe is not that difficult to setup and I have used a similar setup for some projects. You probably need a WebSecurityConfigurerAdapter with a UserDetailsService implementation that is able to load your users from the database. I seed users &amp; passwords with a sql file, you don't need exact knowledge of the bcrypt params that your app uses as they are encoded in the bcrypt string. I typically run a seed password through an online bcrypt service or cli tool and paste the result in my seed.sql file. Since Spring Boot 2.0 you can also seed with a cleartext password if you insert it as `{noop}mypassword123`.
There's nothing wrong with Java for what you're talking about. If you have familiarity with it, I'd run with it. You mentioned functional languages, though. If that's something that interests you, check out C#. It has a lot better capability for FP than Java and .net core is cross platform. The other language that I'd consider would be Node, but only if you have some JavaScript experience or wanted to do something like Angular for the UI.
Also you can use it instead JS. [https://kotlinlang.org/docs/reference/js-overview.html](https://kotlinlang.org/docs/reference/js-overview.html)
I wouldn't even think twice about using Java. For your client or pretty much any other web application project of any size. But that is me. The best programming language to use is the one you are comfortable with and gives you confidence and decent velocity.
In this situation, you might consider thinking about python &amp; Django - coming from a java background my self the Django mantra of perfectionist hold true.
It's the same with Play Framework... Kotlin, Clojure, etc. have Java interop aswell and yet they are better posted in their respective subreddit. Otherwise this will be spammed with posts that have marginal to do with **the Java programming language** as per definition.
Here's a Hello World project to get you started, OP. &amp;#x200B; [https://github.com/dantheman213/java-spring-gradle-docker-mvc-rest-starter-app](https://github.com/dantheman213/java-spring-gradle-docker-mvc-rest-starter-app)
Have you looked at no-code/low-code frameworks? Disclaimer: I’m a developer on the Skyve framework, but it would seem to suit most/all of your constraints: productive to get up and running quickly, runs on Wildfly, supports multi-tenancy, scaffolds CRUD UIs for free and has built in security. There is a learning curve as with any large framework, but it’s extremely productive once up and running due to having a lot less lines of code to write (and maintain).
I was also going to recommend: If not Spring Boot, then try / have a look at Django.
And if you want to slap on a NodeJS-transpiled frontend (e.g., Angular, React, or Vue), you can always do that in a separate Maven module, and copy the resulting HTML/CSS/JS files under your "primary" Spring Boot project's resources directory. The only real caveat to this approach is that you lose some Spring Security integration perks since the server-side tag libraries can't talk to the client-side frontend app, but you can still apply the same authentication and authorization restrictions to your REST/HATEOAS resources. It's not *quite* as bad as it sounds, and it makes for a far more maintainable/responsive user interface than your usual server-side rendering + jQuery madness, if you don't mind taking the time to learn a frontend framework. (Personally, I recommend Vue. It has the shortest learning curve out of the three, and is really good about component reuse.) There's an example project on GitHub here: https://github.com/boylegu/SpringBoot-vue Basically, you need a multi-module Maven project. Your parent POM points to the other two projects. Your Spring Boot POM needs an extra section for Spring dependency resolution (since you aren't using the Spring Initializr parent POM). Your other project uses the Maven "frontend" plugin to download and run Node and NPM during your build to generate your Webpack "bundle" files, which are just static files that get copied into your Spring Boot project at build-time (via mvn install package). If you do your login page in pure Spring+Thymeleaf and then have a session-based redirect to the Vue app, it cuts down on some of the issue with lacking Spring Security integration, but it "breaks" the SPA user experience, if that matters to you at all. My only concern would be that even a light-ish-weight setup like Boot still needs something like 128-256 MB of physical RAM, which can be a pain on AWS EC2 tiny or LightSail instances, which can screw with your infrastructure cost estimates. You should still have less CPU churn than a comparable PHP, Rails, or Node/Express application, but the larger RAM footprint could be a little sketchy on public cloud hosting.
I apologize this was just meant to be a quip rather than a serious conversation. What I was referring to was that the fence is a 3d object as it gives the viewer a sense of a 3rd dimension. In 2d, this is not allowed. 2d utilizes the x and y axis' with no sense of a 3rd or 4th dimension. For example, a character in a 2d environment could not put its hands in its pockets or behind him because the would give a preception of a 3rd dimension. The television show "Futurama" did an episode that showed what true 2d is and how 2d presentation is not equal to a 2d environment. https://en.m.wikipedia.org/wiki/2-D_Blacktop Great video, thanks for sharing!
**2-D Blacktop** "2-D Blacktop" is the fifteenth episode of the seventh season of the animated sitcom Futurama. It originally aired on Comedy Central on June 19, 2013. The episode was written by Michael Rowe and directed by Raymie Muzquiz. Professor Farnsworth joins a gang of street racing punks, and ends up in a two-dimensional world. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
I also did not realize that I was in r/java
You can use it in lieu of vanilla JS, but if you want to use a framework, you're still better off sticking with JS or TS and a full-blown Webpack+Babel project. Thankfully, said frameworks are making it significantly easier to bootstrap projects with those settings. Example: https://cli.vuejs.org/guide/ Kotlin+Spring integration is freaking awesome, though. I love how easy it is to churn out JPA entity definitions as immutable data classes. That on top of Spring-Data-REST makes backend development a cakewalk.
&gt;Here's a Hello World project to get you started, OP. &gt; &gt;&amp;#x200B; &gt; &gt; [https://github.com/dantheman213/java-spring-gradle-docker-mvc-rest-starter-app](https://github.com/dantheman213/java-spring-gradle-docker-mvc-rest-starter-app) "There's no requirement for an API, and in fact a website monolith would probably be easier / more productive."
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Why would you build a monolith? It takes a tiny bit more effort to make it a REST modularized platform -- just do that instead. Who knows when you need to add a mobile app, cron job, lambda, or something that needs to pull strings automatically?
It is hard to debug in remote mode. That is why we have rules that you can't call function on any "getter" aside from trivial.
Amazon offers JDK 11[https://aws.amazon.com/corretto/](https://aws.amazon.com/corretto/) now and it's free
Yes. Amazon corretto should be more reliable. Amazon docs say &amp;#x200B; &gt;Amazon Corretto is a no-cost, multiplatform, production-ready distribution of the Open Java Development Kit (OpenJDK). Corretto comes with long-term support that will include performance enhancements and security fixes. **Amazon runs Corretto internally on thousands of production services** **and Corretto is certified as compatible with the Java SE standard**. With Corretto, you can develop and run Java applications on popular operating systems, including Linux, Windows, and macOS.