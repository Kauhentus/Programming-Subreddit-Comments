Tell me more about the one and only true savior Maven. Is it true that is rose from the dead and brought all incompatible jar files back to life?
&gt; Tell me more about the one and only true savior Maven. Is it true that is rose from the dead and brought all incompatible jar files back to life? On this topic, So far I've seen you: * Share a bunch of unclear personal anecdotes (AFAIK fabricated, since you can't even elaborate on them) * Contribute a bunch of erroneous statements * Insult those trying to help you * Evade any sensible debate by hiding behind grouping others as fanboys * Put words in other peoples mouths (as above) I'm not even sure you're a programmer. Do you develop software or just proprietary Rube Goldberg build scripts?
Yes, as a Maven evangelical I'm sure you have an endless ways to attack heretics to your religion. All praise the holy book of maven. As someone who's tried to use Maven, I don't care. The purpose of a tool is to make things better/easier/faster for you. If it instead makes them worse/harder/much slower, it's failed as a tool. And in my previous experience, it failed as a tool. P.S. Plus seriously, you fanatics are always the same. You write a bunch of erronous statements, make uncertain personal ancedotes, insult the people sharing experience if it doesn't match with what you think they're supposed to say, evade any sensible debate on the actual topic and instead try to change the subject, and put words in peoples mouths - so you accuse others of doing those things. You pretend to try to "help" as an excuse to talk until you drive other people crazy from exhaustion. Maven is a cold, unemotional tool. A tool that worked very poorly for me on my last project.
There's a diagram that clearly show serialization vs deserialization. But I guess you have to scroll down a little bit to see this.
Never! I judge harshly based on no evidence! At all times and for eternity!
Haha... typical JavaEE propaganda.
We use out test boxes to run continuous integration tests during the day and performance tests overnight.
Videos don't work for me either
Not a clue - there may be more generic audio processing libraries that can help you but it sounds like a fairly specific problem. You may want to search Github if you haven't already though.
Just to be on the same page, did I understand your question correctly that you want to input an audio file and output e.g. `"C major"`?
I usually recommend the book "Head First Java" from O'Reilly.
It depends on the number of servers involved and how much work is being done/needed by the application for each users. Is it one server and displaying highly customized content? Then very impressive. Is it 10 servers and completely static content, then not so impressive. But generally Java EE scales incredibly well. Plain Servlets top the charts of pretty much every performance benchmark. Higher level Java EE also beats pretty much every other comparable high-level framework. For some numbers of what JSF is capable of see: * http://jdevelopment.nl/wildfly-8-benchmarked * http://jsfcentral.com/articles/understanding_jsf_performance_3.html
Actually Genson supports Jaxb annotations too and most stuff Jackson does. Do you mean ordered result during serialization? Genson uses a consistent ordering on the properties names (alphabetical).
lol
I've a very minimalistic web application in Java running for a few years now. It started as an exercise were I built my own minimalistic http server but then moved to com.sun.net.httpserver.HttpServer and now to Jetty. From time to time I still improve it. Last time I did I refactored it to pass sonarqube analisys. The code is at https://github.com/vilaca/UrlShortener and the webapp is hosted at http://go2.pt
Learn about how mp3s are encoded and S domain transforms and the answer is straightforward. I doubt there are any frameworks or APIs that break down finding key signatures for you.
Echonest is the bomb. They have all sorts of crazy cool services and apis. 
And the first code example is about deserializaiton
I think your statement about non parallel operations happening is a bit of a sweeping generalization 
We have already got automoderator on the case flagging and removing java help questions. This was done fairly recently. Also we added extra warnings upon submission. Hopefully you should have seen less these past couple of weeks. 
I'm kind of in the same boat, really looking to get my foot in the door and I'd recommend building a paper trail of resume-applicable material first. Best way to do it, if you can swing it and dedicate about 10-15 hours a week is to do it for free. Obviously this isn't the end game and all of us Java coder's have seen the national averages for salary but I recommend finding a local development agency in your closest major city and linking up with them. Essentially, you'll work "for free", no monetary value but the experience is worth more than they could pay you at this point. Ask for a gig or two that is low priority or menial for those currently employed there and set a end point to the tune of two or three weeks of free work. If they like what they see, you can work out an arrangement later on. Do this with reputable agencies and I think you'll find this as more of a creative interview process rather than the community service that it'll feel like at the start. 
yes! at the extent of the possible program I would like the output to include some unit for tempo (bpm), the time (e.g. 4/4), and the signature. 
Oh, cut the crap! First of all, it's funny to see such a rant from a lurker who has next to no participation in the sub (or in /r/javahelp for that matter). You see the sub spammed with a whopping total of 5 (five) help requests on the front page? Why don't you look at *new* for a change. The *Top* posts don't change that frequently anyway. Also, you have some tools at your hands: the "downvote" button, the "hide" button, and you have your mouse to scroll further. &gt; I dont know what power moderators have, but it would be awesome to be able to close/move threads if they pop up. The mods are already doing a great job. They have the css in place, the sidebar is updated (and perfectly viewable in *every* mobile application contrary to what /u/AladdinP said. Mobile users are commonly just too lazy to read the sidebar.) *and* as opposed to common belief, the mods also have something called *lives*, they have other things to do than to watch the sub 24/7 and thus some help requests escape even their eyes. &gt; What about this reddits moderators / css gurus ? Did they just give up on the massive load of questions ? What more should they do in your opinion? Distribute electro-shocks through the internet for code help posters? The CSS is styled to the maximum, there are altogether 3 (three) different warnings *plus* a separate "Seek Programming Help" button on the subreddit page alone. There is another hint at the submit-text page. Those who want to submit will do it, no matter how much the mods do. Really, if it annoys you that much, it's better for you to see yourself out.
But the big red banner popping up should already be hinting that something needs attention. There is still a lot of information in the sidebar, including a *separate* "Please seek code help" button.
&lt;http://en.wikipedia.org/wiki/Banner_blindness&gt; &gt; When searching for specific information on a website, users focus only on the parts of the page where they assume the relevant information will be, small text and hyperlinks. Large, colourful or animated banners and other graphics are in this case ignored.
Who programs in Postscript? How can there be more of them than program in Go, Scheme, and Erlang _combined_?
That language that keeps dying ... for 20+ years that has remained around the top for those years... That is why it is hard to trust tech people sometimes. Java was never dying, will not die for a while unless some kind of "enterprisey" technology that does the same thing that java does. Java VM supports multiple languages which further pushes its viability. It doesn't suck but at the same time you don't have to use it exclusively. I tend to use python for basic scripts. I wouldn't mind using Clojure/Scala/Groovy more. I guess I could use C++ for games if I still worked on them. Edit: Oh yea, JavaScript. JavaScript is the new up and comer. With Chrome/IE/Firefox basically acting like powerful virtual machines, you can do pretty advanced coding in JavaScript for the client-side. And with NodeJS, we see a proliferation of JavaScript on the server-side. ... So it is good times for the technologies I mentioned. I think Ruby is one that could die... in that no one will work with Ruby technologies. And then Python, will it become stale? Will it be used for larger/enterprisey projects?
Hey it's universal, runs on every printer ;)
Almost all languages are on the decline, which makes you wonder what that signifies. Maybe just more diversity.
&gt; Androids ongoing success is probably the major reason for Java's revival. wait until golang turns into the main programming language for android... 
It can only die in the same manner as Cobol. Which means it cannot.
I don't think Ruby on Rails is the hotness it was say five years ago. I think what you're likely seeing now are the companies that invested heavily in RoR back in the day and are now desperate to find people to maintain and enhance large existing application stacks that the original developers have disappeared from.
I am getting my gun...
&gt; Basically the calculation comes down to counting hits for the search query &gt; &gt; +"&lt;language&gt; programming" Given the rather arbitrary number of results entries Google gives for search terms this has to be one of the silliest definitions ever. Here's Matt Cutts (from Google's Web Spam team): &gt; "We try to be very clear that our results estimates are just that--estimates. In theory we could spend cycles on that aspect of our system, but in practice we have a lot of other things to work on, and more accurate results estimates is lower on the list than lots of other things" For more: http://searchengineland.com/why-google-cant-count-results-properly-53559 Ultimately this means the ranking is: arbitrary and pointless. GitHub's ranking data is much more useful.
&gt; And then Python, will it become stale? Python is the language to dip your toes into programming. Unfortunatley it's highly misused to build bigger software, but in general it's pretty handy. A lot of statiticians use it because they're not good programmers to begin with. Ruby however is only maintaining it's foothold in Chef scripts. I would be happy to see it to go. And it would be nice if docker takes over that space.
&gt; Again, did my post in any way suggest I was asking for help? No. Clearly you need help. It may not be programming help. I don't need your permission to post, especially if you do a shitty job communicating your intentions. &gt;I'm not even on that project any more. That's great. I think you missed the preschool class where they taught "No, thank you." Responding with an isane "fanboy" chant and spewing religous dogma is idiotic. &gt;The first line of that post you quoted is a technique called "acting stupid". Sorry you think questions are stupid. You can go ahead and call me stupid, for all you know I am. At this point, I'm just interested in figuring out if you're 12, or incapable of logical discourse because you were dropped on your head. I haven't even tried to "evangalize" anything in my last few posts, other than pointing out your conversation style. &gt;The difference between a professional and a fanatical back and forth is that a professional back and forth follows "does this tool work well". Nothing you've said is professional. There are many other engineers that would have laughed you out of the room if the entirety of your arguments are so unsubstantiated. You started your post with an excuse that anybody who disagrees with your post of a limited experience and wild and inaccurate generalizations is "a fanboy". A professional would have simply done one of two things: * Solutioned with an engineer trying to help them * Backed up what they said with data that actually shows they tried to resolve the vague problems. * Graciously backed out of the conversation. Like saying that they're not interested in debate and it was personal experience on a project they're no longer involved in. &gt;A fanatical back and forth says "this tool always works well, even when it doesn't, now how can we attack posts of negative experiences with the tool?" Funny, on our team we use: * Maven - Java except for Android * Gradle - Android * Grunt - JavaScript * Rake - Ruby * gmake - C++ * msbuild - Microsoft * Jenkins (with some Python Scripts) * Xcode - ios * custom python + Docker But since you can't keep the conversation at a logical level, you sling accusations. So what do you do builds in?
Unless you've done profiling, nobody can know why your FPS isn't that high. It could be virtually any piece of your code that is causing the issues. You need to do some investigation to see what is impacting your FPS before you dive into making optimisations. Make your game output your FPS somewhere, then selectively remove features from your game. This can be both visual and non-visual (for example disable your enemy AI logic, etc). Do this until you've found what it is that's causing your FPS to drop. There could be other things that you are doing just fundamentally wrong. Maybe you're sleeping too long each tick, and it's artificially causing your game to appear slow. I wrote a game in Java using the standard BufferedImage class, and soon ran into performance issues myself. The BufferedImage class is done entirely onthe CPU, and you really want to use the GPU for this. There is a nice image class which allows this though, VolatileImage. Check this link here for information on how to use it http://stackoverflow.com/questions/2374321/how-can-i-create-a-hardware-accelerated-image-with-java2d For your tiles, how many do you have on-screen? How big are they? You really should be able to make quite a few draw calls per tick without having massive slowdown (e.g. some games have thousands of independent things on screen fine). 
Honestly, if I was writing a single java file that I had to launch multiple times during its development, without using an IDE, I would rather use the groovy console.
Github and indeed job trends. Both have a focus and seem more significant. 
&gt; A professional would have simply done one of two things: &gt; Solutioned with an engineer trying to help them &gt; Backed up what they said with data that actually shows they tried to resolve the vague problems. &gt; Graciously backed out of the conversation. Like saying that they're not interested in debate and it was personal experience on a project they're no longer involved in. Yeah, this is just what I said. God/Maven must always be right - clearly the problem is that the heretics just aren't trying to believe enough! I'm bored, so I'm out. Say hi to the other priests for me, be sure to let them know how you're going to "just keep at it" approach just like I said all of the zealots do, rather than "sounds like it didn't work well". Bye.
Interesting read, this sounds like quite traditional approach to performance testing. Our goal is a shorter cycle between performance tests, but I don't know if it's doable. Does your developers do any unit level performance testing?
That will literally never happen. There is way too much of an impedance mismatch. The entire API would have to be rewritten. The only language I want to see supplant Java is Kotlin. It was written by a bunch of guys who write some of the best Java software in the world, to tackle the problems that make people hate Java. It feels like a modern language (kind of reminds me of Rust in some ways) and yet is 100 percent compatible with Java. You can write an Android app fully in Kotlin right now. 
Java is verbose, and has other problems, but is not a horrible language. Java is also a great language for employment. I personally am moving away from the Java space for several reasons, but none of those reasons is because 'Java is a bad language.'
That really makes sense! I could only guess tablet users may also not see the layouts. Depending on used App i guess. Thanks for the Info, explains some of them!
As Peter Lawrey noted during his JavaLand talk, the game-changing feature of streams isn't that they're parallel (because, as you correctly state, they're usually not), it's that they can be *made* parallel by just adding one single `.parallel()` call. In fact, the underlying machinery is tuned to work reasonably well in standard cases, and may perform quite poorly depending on your workload. You can swap parallel execution in and out of your pipeline, so trying it out becomes very cheap. Therefore the assumption is not that everything *is* parallel, but it *maybe* parallel.
Java before 1.6 wasn't all that great. Since 1.6 however it has gotten pretty amazing. Try the Apache Tapestry + Hibernate tutorial out there with the annotations (persist, entity, transaction, etc). It blew me away how little actual code you need to write nowadays for CRUD type stuff. I pulled off in about 4 hours what took me almost two weeks to get working back in the EJB 1.x days on WebSphere. I am a total reconvert now.
And as allways with someone complaining there will be some other guy complaining about the guy complaining :D I use reddit for more like a Information platform, to get updates on stuff, to learn, to read the newest interesting articles. So yes i have next to no participation. Also im quite new to reddit, so i dont know about stuff like mobile reddit, automoderator and the possibilities that moderators have. In OP i asked for such explicitly. I didnt even knew about the hide function. Anyways, thanks, i guess..
They weren't really kicked, the course just "got away from them" they started getting behind on subjects while the course was moving ahead. And it was suggested that they may not be right for the job so they dropped out. And when I signed my new hire packet, it had a clause that every 6 months I would get a 14% increase in salary based on how happy my current employer was. 
Go's deliberate "less is more" approach reminds me of the old "hello world" joke in which the novice and true master both have the same "10 PRINT HELLO WORLD" solution, but the intermediate and working programmer make ever more convoluted messes involving iostreams and CORBA/COM stuff. In another domain, one can look at fitness: the novice gyms have lots and lots of specialized equipment, and as the gyms target more experienced users they have less equipment. Eventually you get the MMA gyms that might have just a rack/cage, kettlebells, and some hanging ropes, or you get to the bodyweight fitness folks and all they've got is a bench and a pull up bar. It will be interesting to see what direction Go 2.0 takes.
spam porn link...wtf
Annotations are fantastic and far easier to read than a hidden XML file. It is right there in the code and if I find one I am not familiar with then I just look it up. What would really be great is @getter and @setter annotations so we can remove a bunch of boilerplate code.
^ And here we have a poster child example of annotation abuse
You mean the way Perl does it? Just inject a variable in the current context?
But that's the reason! Why will nobody be listening!? ;)
The course is 8 hours with an hour of lunch. You can go out and eat or you can stay and work during lunch. I'd say I spent maybe 2 or 3 hours outside of the course going over what was taught the day. Then again I went to night school during the course so it's kind of hard to judge. Before you take the course you sign a contract that basically states you can't take the course, pass, and then quit cook systems. You have to work for them for a year. Or, you can quit but you can't put them or the course as a reference on a new position for 1 year. There's also some monetary compensation you have to pay if you pass the course and quit. If you fail the course there's no penalty 
Tomcat and Jetty are EE containers?
I do not really take issue with the example on the link. I guess I am more responding to the general vibe that annotations are bad. Sure anything can be abused but on the whole annotations make my life a lot easier.
I actually hate most of the system I work with, but the fact that with few annotations it will on compilation generate sources, with all the boiler plate to make the objects persistent in the ancient custom persistence framework this application uses, is convenient.
Ah, so you're also talking about Lombok? Or something similar? But Lombok is the perfect example of things that should've been supported by Java-the-language in the first place. It's useful, but it shouldn't be needed.
Ah, OK... Like ActiveRecords? Yes, those are useful in a variety of APIs...
&gt; Yeah, this is just what I said. God/Maven must always be right - clearly the problem is that the heretics just aren't trying to believe enough! I haven't really tried to suggest a technology. It's been like I'm trying to debate with a 21 year meth addict with a fried brain and who has an evangelical parent. At least your handle is appropriate. Glad you're out, it's been a waste of time for both of us.
Definitely some surprises. I'm shocked that Postgres was so low on the list
Eh, it shouldn't be needed, unfortunately the people in charge of those who write applications are the cause such contraptions exist. And I really prefer this than the old way of launching Rational Rose with some custom scripts to generate sources from the UML model. It's the lesser of two evils. It's also much easier to see changes in VCS. In another company we had some scripts for code generation and it was easy to make a mistake and hard to spot it. Luckily it was core of application so the errors there were rather quickly noticed in testing.
Just wait till you see what 'val' does with the compiler internals... The other classic is @Data where you have mutable fields being used to calculate hashCodes, and the one for constructors where the order of field declarations affects the constructor signatures.
They analysed the "top 5,216 Java projects on Github." I think it's likely that the top projects have at least *some* unit tests. I don't think I've seen a major open source project without unit tests. 
Interesting that bukkit is on the top 100, although I wonder if this had been done a year ago how high up it would have been now that people are migrating to spigot or sponge
Fair enough, although aspects are similar to keywords (e.g. `transient` or `volatile`) as mentioned in the article. They're not really configuration.
&gt; But a background inside the title/text field on the submission post might help ? We are having such as background in /r/javahelp to explain code formatting and still people get it wrong. I doubt the usefulness, but I will think about implementing something like this. Should be fairly easy and we cannot lose anything (besides proper posters getting annoyed by the amount of hints about code posting). **EDIT:** Message implemented in the submission text area. Maybe it helps. Who knows. &gt; Just mark them as spam and hide ? You could *report* them as "Other:" and type "Help request", and hide them if you want. Hiding only hides posts from your view, others can still see them. If a post receives enough reports, Automoderator will automatically remove it. &gt; Or would it be possible to include a radiobutton that says "helprequest" ? No, this is not possible. &gt; Maybe even then if it got reported by more than X people it gets autodeleted/moved/flagged for view by mod ? This feature is already implemented. A lower threshold triggers a message to us moderators, and if we miss that, a higher threshold will automatically remove the post.
&gt; reduce their rep by 100 AFAIK that's not possible in reddit.
Heh. The people running OC4J. I feel so sorry for them. "How does this work? It shouldn't work!" "Oh, it's OC4J."
@Inject, @Named, @ViewScoped, @RequestScoped, @ApplicationScoped, @Entity, @JoinedColumn, @ManyToOne, @Column, @NamedQuery and even @Depricated. These are all simple to understand and use. They provide great functionally with minimal effort. 
Some python developer wrote that.
This is why I opened the comment thread. So I could upvote this comment that I knew would be here.
idk about angry but I came here to make a joke about that too
&gt; Glad you're out, it's been a waste of time for both of us. One last thing, that's the one thing we actually agree on.
void method returning an int... but other than that, pretty cool
Double espresso, Breakfast extending Meal, and...what? Can't make out the top two lines on the left hand side! milk.foam perhaps?
Bastards.
I don't like that sandwich. Sandwich should be a class, and a builder pattern should be used to make it.
Won't compile, crash. Is that a bug we can report? hahah
yeah, those GTA programmers can't program eh?
Won't compile... it's a trap!
The probably don't even sell sandwiches.
Should have been changed to groovy when they updated the game for PC.
The modelers probably didn't check with the dev team.
besides the MISSING CLOSING BRACE
Someone should report this as a bug
Not sure how anyone can blame him. Mojangs fault for not disclosing the purchase and allowing people to basically work for free for them.
It would certainly speed up my inheritance from grandma.
Complete agree. I think I completely missed that last check box last time I installed Java and I am not even a non-programmer... Then again not too surprised to see it get added 
Must be lots of bugs in this coffee shop
Classic shitty legacy code, poorly named functions that don't do what you think they'd do
I appreciate the thought out response. I am pretty torn over this subject and its hard for me to decide which side I agree with. On one hand it is really horrible that he shut down *the* largest project that people had spent thousands of hours contributing to, over his own own feelings about mojang. On the other hand, I can understand *why* he was angry. I can't imagine that after all his contributions, learning that he was indirectly working for mojang for literally nothing in return would be a fun thing to find out. Mature me wants to say that sending a SWAT team to do that is really fucked up and should never be used that way against someone, but immature me agrees with you that it is pretty hilarious. Did he deserve it? Maybe not, but in my opinion he absolutely should not have done what he did in shutting down bukkit and continuing to send DMCA takedowns to spigot and other projects. As a server owner and dev I have seen the direct impact that he has had on the community and it is pretty sad. Everyone is arguing over which project will be the *new* bukkit, and spigot repeatedly making breaking API changes that are driving away devs and crippling legacy projects. What he did was all around just really sad and fucked over a lot of people that contributed to the community, but mojang should have disclosed that they had bought bukkit so that people knew exactly what they were contributing to. Sorry for the long response, this topic drives me crazy :/
false. because that one matches with the other big yellow one on the left. and even if they did intend that as the closing, there's still one too few. regardless, i find this a charming and awesome inclusion.
Apart from the somewhat aggressive tone, thanks for holding high the banner of us /r/java mods ;-)
I had this discussion a few months ago (aside: It resulted in me becoming mod to /r/java). We did not have the banner, the guideline text, the custom stylesheet and the automoderator rules. There wasn't even consensus that help posts should be moved to /r/javahelp. To me it looks like we're progressing nicely. Sure, a few posts manage to squeeze through the cracks, but overall, submission quality is good, trolls are kept at bay, and spammers are (mostly) sent elsewhere.
But then it should use a triple/double negative so you have no idea ifyou should tick out untick .
@Data lulls devs into thinking that they magically have equals and hashcode without having to use their brains and realize that hashtables and moving-target hashcodes are a bad idea.
The code no longer complies with the JLS, which breaks all sorts of tools.
I think you might be the only one with this problem.
That's what I meant with the 'aside from the easily avoided reasons'. Can't say I've ever made that mistake more than once. I am moving away from @Data though, but only because I constantly find myself overriding EqualAndHashCode and ToString anyway.
I google my problems, so I know it isn't the case.
&gt; http://arjan-tijms.omnifaces.org/2015/03/the-most-popular-java-ee-servers-in.html Main difference here seems to be in the way how the data is gathered. Voting online vs real environments being tracked for this data.
Tomcat and Jetty are Java EE containers. And the compatibility henk53 is referring is not to tomcat but to Java EE specification. Some containers are not officially Java EE certified, which does not make them less compliant with the specification. See more from https://plumbr.eu/blog/java/there-is-no-application-server
On the one hand, good coverage should give you good confidence that your code works. You can get code coverage tools like Clover or JaCoCo that will tell you which bits of your code is tested and which bits aren't, and you can use BDD tools like Cucumber to make writing good coverage tests easier. This means that you can be more confident in your code. On the other hand, sometimes things go wrong and it can't be helped. In that case, tools like dynaTrace or AppDynamics installed in Production will be able to monitor your application and record errors so that you can go back and see what happened and work out how to fix it. Note - these are very expensive, so it might not be a feasible solution.
I don't like having capitals as the first letter in my class's names. Am I a bad person now? :(
OC4J at one time was the best AS in the market ;) Back then it was called Orion and made by just 2 guys from I believe Norway (ironflare, they were called). Very small, very light, and the only server at the time that didn't crash under load.
with java you purposely expose the user to a shitload of malware. don't. write your shit in c++. 
Sound great except the standard and most productive Java framework for developing web applications uses them. My code would not be better without them, it would get much more complex.
You can code your desktop application in java and wrap it up in a windows installer. Then nobody but you needs to install java.
sure. or you can write it in the native platform and you dont even need to install java.
I've seen this is being reported. I'll allow it, on the grounds that by raising awareness, perhaps we can shame enough people at Oracle to have them revoke the deal with Ask.com.
I ported Hjson to Java and (hopefully) made it very easy to use. More information about Hjson (the format): http://hjson.org/
And they should address the texture in one of the patches. :D
I thought this was irl.... 
Just to clarify: The wrapping can also be done in a way that no actual Java installation takes place at all. The system will not have Java, only the application.
One of the graphic artists just added "professional Java" to their resume.
The method also doesn't accept a parameter of type Currency :(
What are the advantages of using this library over [HOCON](https://github.com/typesafehub/config/blob/master/HOCON.md)?
Hjson uses a very simple syntax (essentially JSON with optional quotes and commas). HOCON wants me to remember a lot of rules (merging, paths, substitutions, etc.). For details see http://hjson.org/
When you have your config in JSON (which is not the best idea but used a lot, especially in JavaScript projects) you will almost certainly fail because of either a missing or a trailing comma after you copy&amp;paste. 
I've seen a warning in the console, saying that the (security) baseline could not be verified (that jar was not signed maybe?), but this didn't block anything on my end, at least for already accepted (and updated to a new version) applications (fully signed). Oh, and is it possible that this problem doesn't happen under **8u45** that just got released 2 days ago ?
Just want to point out that /u/FridgeBoyLP found this beautiful store when we were playing Online together :)
This is called fuzz testing. 
Logging, emitting metrics, exhaustive testing at multiple levels (unit, integ, component, e2e, fuzz), rigorous cr standards, well defined team standards come to mind. 
I don't have that problem, though I can see why some might.
I'm still not understanding the point. How is the ifPresent check better that the NULL check?
jackson allows comments via JsonParser.Feature.ALLOW_COMMENTS https://github.com/FasterXML/jackson-core/wiki/JsonParser-Features
It happens even under 8u45, on Windows and Linux. But appears quite randomly: it might appear whenever you start an application or doesn't appear for hours. In our case SecurityException error follows by another one in class loader and causes unexpected errors in application. I believe that Oracle forgot to sign securitypack.jar which JRE downloads silently in the background. It's incredibly hard to contact anyone from JDK team to notify them. I tried /r/java as "last resort" but it doesn't help unfortunately :(
In that case I'd just use Hjson to convert it to JSON so you can use it with any of the available JSON libraries.
It's not. The other methods on optional are more interesting by far.
Ya, you can totally write zeros with Java too
Or why everyone should just be a java developer, the JRE bundled with the JDK doesn't have this option at all and doesn't come with it by default. 
I found it painful to even get access to. We settled on using Base instead.
Or people should stay up-to-date in a world where we have most people using evergreen browsers. 
Not just this month. It's already done: [7u80 is the last public release](http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html). Mind you, this is the *public* release. If you have a support contract with Oracle, they will continue releasing updates for you. OpenJDK will probably also continue releasing updates: http://mail.openjdk.java.net/pipermail/jdk7u-dev/2015-March/010279.html
It isn't designed to save them millions -- it is to make them millions. There won't be PUBLIC security patches, but you can pay for commercial support licenses that will give you access to them. We investigated getting one, but the cost is absolutely insane. You are right on about trying to upgrade a large enterprise system. The worst is the third-party dependencies. I can make our codebase use java 8 just fine, but making a random third party system we use for something or another that hasn't been updated in 5 years work can be...challenging.
I wonder if J2Swift is being worked on? Swift2J would be nicer, except the integration would be far more challenging with the richer libraries on the Java side.
What type of problems can occur when switching to a new version of Java? They are supposed to be completely backwards compatible.
Restricting critical bug and security fixes to support contracts is a real dick move .. That's not how you build people's trust in your platform. That also means that the fixes won't be committed to OpenJDK, I guess, in contradiction with [past claims](https://blogs.oracle.com/henrik/entry/java_7_questions_answers) that it was just the same as Oracle JDK with a few tiny bits here and there. Another case of crippling functionality and impairing security in the name of greed.
What? Bug and security features aren't restricted. They're freely available for Java 8. I for one don't want Oracle to waste resources on Java 7 at the expense of working on Java 9. If people are trying to save money by not upgrading, it only makes sense they should pay some of the savings to Oracle, or, better yet, the cost would urge them to upgrade, in which case we all win.
Search for thenewboston on YouTube, he has good quality tutorials including an introduction to java for non coders 
Should `Optional` be used in its generic form `Optional&lt;T&gt;` rather than what's done here? Is the bare form just shorthand for `Optional&lt;object&gt;`? How is it inferring the type of `m.getStudent().get()` considering the only place the type is mentioned is in the intialising line: `Optional studentsOnAlgorithm = Optional.of(new Student(50));` ?
fixing bugs in your code and then withholding those fixes from people unless they pay you large sums of money sounds suspiciously like BLACKMAIL
They ARE still using resources to fix Java 7 bugs and patch holes...they just charge people for them. The fixes are still getting made, so they aren't saving any resources by not releasing them...
Hehe I wish. We still have critical infrastructure running on java5, and we're still adding new functionality to it! God it's awful...
There was a rounding bug in 8 that was not in 7 that prevented my company from upgrading until a few versions ago. Edit: this is the bug https://bugs.openjdk.java.net/browse/JDK-8041961?page=com.atlassian.streams.streams-jira-plugin:activity-stream-issue-tab
Red Hat will provide support for OpenJDK for many years to come.
Yes you should use Generics, the blogpost is really bad! **Allways** use Generics when possible to ensure Type safety. Also use the map, flatmap and ifPresent methods instead of the isPresent + get. Thats the beauty of Optional, that you can use the functional way of processing something that might not be there.
You can always ask me stuff if you want. My skype is Ismaya0
And what happens in the case of something like Ruby, Python, or Closure. I'd rather take an explicit communication and policy then being forgotten.
just out of curiosity, what was that prof's teaching/testing style?
ninite. :)
I see. Well, you could work around it by rounding the number *before* displaying it, using `BigDecimal::setScale`.
&gt; Hjson uses a very simple syntax (essentially JSON with optional quotes and commas). HOCON has this too, in the Section titled "Unquoted Strings", it also has mutliline strings, and string value concatenation. &gt; HOCON wants me to remember a lot of rules (merging, paths, substitutions, etc.). It doesn't make you remember them, and why would you not want these things? HOCON allows you to omit braces, use `=`, `:`, or `+=` as a separator, use paths to represent deeply nested keys. You can reference array values by index. You can assign units to numerical values. Absent all these things, I fail to see how hjson is more human friendly.
While this is easier for humans to read, it also seems easier for humans to make mistakes with. It's more complex. While JSON is ugly, it's also really easy to remember the rules. For example: in JSON newlines are totally optional. Whitespace isn't significant. With this new format they're syntactically significant because of how commas work. JSON (newline is optional): [ a: b, c: d ], [ a: b, c: d ] Hjson (removing newline breaks code): [ a: b c: d ], [ a: b c: d ] 
It really depends on the country. For example, if you're Dutch: if it's made in your spare time and it's even slightly related to the company (eg, both involve programming. Not joking), it belongs to the company.
Thanks for the answer I took a look at base and it seems very interesting. Are there any specific features which base doesn't have and salesforce does. Anyway the straightforward JSON REST API I am used to working wtih as a young developer is really nice. And the company i'm working at now has a mailchimp account set up already and the price should be lower as well for them. So really again thanks for the suggestion.
Your JSON sample is missing the quotes. [ a: "b", c: "d" ] is still valid in Hjson. When you have one value per line (as it's usual in config files) you can omit the comma and the quotes.
Download appeared here: http://jboss.org/products/eap/download/?eap=6.4
I work in a huge java 6 project in a company everyone knows, at this point I think that the project would simply cease to exist rather than we switched to higher version.
Aren't we all? From what I understood though (no prove, just observations), this shouldn't really change their focus. They always have 2 branches in development. In this case the Java EE 6 line keeps getting updates, while they are developing the Java EE 7 line and releasing beta versions of it. It probably depends on whether they are able to release EAP 7 before Java EE 8 is released if they will continue updating EAP 6 after EAP 7. Java EE 8 is targeted for Q3 2016. It's probably going to get close. I fear they won't be able to release EAP 7 this year. My guess would be a target of early 2016, which JBoss style then slips to mid/late 2016.
I have pretty much the same fears as you. Here's what JBoss support responded us about the end of jdk 7 updates and the JavaEE7 implementation. It was in late january 2015: &gt; &gt; Could you please, let us know when do you plan to release a version with JDK 8 support? What about the JavaEE 7 implementation? &gt; &gt; Java 8 support is currently targeted for EAP 6.4, which is estimated for release in April 2015. Java 8 support for EAP 6.3 is still under investigation, and EAP 6.2 is not being considered. &gt; &gt; Regarding, EE7 implementation, EAP 7 is expected to be Java EE 7 compliant. The target date for EAP 7 is still in planning.
pm me, i can help
I know this sounds glib, but all the fixes are there in Java 8 for free. Supporting older versions for extended periods at no cost will lead to increased fragmentation. This is an obvious negative to the ecosystem in general.
SF probably beats base on feature set, which imo is part of the reason we didn't like it, it tries to do too much. personally, i found its interface extraordinarily hard to use. on top of that the high cost and difficult of integrating our systems into it made it a no-go. Base was simple and painless. There are some warts, like attaching content to contacts/deals is really awkward, and no web-hooks in the API. but the second generation API should be a lot better. since you're using java, and afaik, they have not released v2, we threw together a simple pile of code for accessing their api: https://github.com/complexible/basecrm
**Not *theNewBoston*.** His resources are terrible and totally frowned upon in the community (not only his Java tutorials, all his tutorials in general). Go for [Derek Banas](http://www.youtube.com/user/derekbanas/playlists), much better.
Spare me your unnecessary ad hominems. All they do is disqualify you as a discussion participant. I do give a shit about safety, but you have not provided an argument, you just painted an extremely blurry hazard picture about which I tried to get a clearer statement from you, but you just basically repeated you statement, not giving me any material to work with. Either you amend this, or I must not just disregard your opinion as superfluous, but will in light of your childish outburst ask you to send me a personal message with arbitrary content, so that I can permanently remove you from my reddit experience via blocking.
Will apple release their own jre 8 before then or has Oracle implemented proper font smoothing on OS X using their jre? 
&gt; What argument are you expecting? I was expecting that you substantiate &gt; simply having it copied in some weird folder does not guarantee that an exploit (current of future) will not (or cannot) take advantage of it. because if you really think of that as a potential hazard, I wonder if you're only running the most bare-naked self-compiled Linux systems. That's the level of care you effectively say should be taken. &gt; Can you say for sure that a drive-by download exploit won't be devised in the near future that can take advantage of a jre installed on the system (but not registered via the usual channels)? A Web browser can not take advantage of a software it doesn't know about or that isn't "officially assigned" to it like a plugin/extension. You're painting am image of Java being like a bomb waiting to explode, which is completely irrational. Suppose a Javascript (or other) Web exploit is able to access the local harddisk in places that are not "officially" supported/assigned to the browser or its plugins/extensions: Is it really relevant if what is accessed there is Java? What about Photoshop or any other software? Or what about just the file-system itself? If you could substantiate this diffuse threat scenario, you would have kind of convinced me of your argument, but not of the scale of care you intend to apply: Some breathing room must be there, some "risks" must be taken. Here you would say that this is wrong, but what I just said assumes a risk so low that it's asinine to realistically consider - which is why I also just said that maybe you could substantiate this threat scenario a little. Because so far, I still don't see why Java is the problem in that scenario you believe to see.
What I am gathering from this is that you're basically warning to put (Not even necessarily install, as I pointed out in my first comment.) any software on a system because it could be unsafe. Ok, fine. But you are clearly making Java out to be a hundred times worse than any other software in this regard, which I think is irrational. I think your message actually is: "Create software that doesn't require any runtimes. Anything else is just asking for trouble." If that is indeed what you're saying, then I can't accept that. (E.g. what about DLLs?)
I say go for "Java for Complete Beginners" from John Purcell. I did not watch this but I took his Spring tutorial and it was awesome. Also the "Java for Complete Beginners" it's free.
I would also personally vote for John Purcell's Courses. I did the Swing and the Design Patterns courses and they were awesome. The explanations are so extremely easy and the retention I had from doing the courses was great. I just listed the others because the MOOC is one of the most recommended ones and it's pretty hands on, and Derek Banas' videos are also really good, but IMHO he speaks a bit too fast (opinion of a non-native English speaker).
java 4 here.
This is why I avoid OpenJDK. Weird bugs that appear that Oracle's JDK don't have (not all the time, but it only has to crash your prod system once for you to be weary)
[All the way back to OpenJDK 6](http://blog.fuseyism.com/index.php/2015/04/15/security-icedtea-1-13-7-for-openjdk-6-released/) I might have issues with it, but by God do I respect it
Yes, any software that you install has a potential to screw up your system, but the alternative is simply not feasible. After all you do need software to simply do your work. I am not saying that anything that requires a runtime is bad, I'm specifically targeting Java. Java has (more than anyone else's runtime, a hundred times more) a history of such severe flaws that it is unthinkable to even remotely let it touch a desktop OS used by a normal user. Not even .net or python or perl or ...tons of other runtimes even come close. Are they safer that Java? No idea, but until proven otherwise, they certainly seem to be. As for going native: C or C++ are not "safe" languages. However, their dangers come from incorrectly using those platforms, as opposed to just using them (as it is the case with Java). When the bug is in your specific application, you have the ability to fix it. You don't have to wait for a 3rd party to do so. With a runtime you do have to wait for a 3rd party, since your code is as safe as it can be. But Java is the worst offender out there when it comes to runtimes. By far. It is irrational to even think of it as an appropriate platform to develop desktop applications.
Until a week ago, I was as well. And I know a lot of people that *should* be, but I'm not sure if they are as vigilant as I was. And then, well, suddenly my stake in the JBoss world vanished. I'm not sure how I feel about that.
Except for those who have to support customer products that aren't coded for 8, and won't be...
What the hell are your products doing, that they won't run on 8?
They aren't my products, they are other company's products. I work for other companies to support their customers (outsourced support). We use whatever tools they have available to handle their support. For example, there was a company that we supported for a decade that ran their customer information from an AS400 (and not one of the new ones that have been maintained)... So what do we get to do? Shell into the AS400 to handle customer stuff. If they have tools that were written by an inhouse dev that left or is no longer going to update the software: We have to use what they have available. It's their choice. The only thing I can do is control my end of things, but the bottom line is that the way Java is written (and how they deprecate things in new full versions as they do), backwards compatibility has always been a problem. Having 8 installed on our machines means we can't support our client, which means we lose them. Very simple math, and Oracle is making a very large mistake on this one. Don't want to patch it? Don't. You haven't anyways... But to hold the security patches ransom when you haven't had your new version out long enough for people to really test it and convert (some businesses take *years and years* to migrate because of the impact on business)... Not cool at all.
&gt; ll, you could work around it by rounding the number before displa Ah yea, that should work. The bug has been fixed since 8u40 so no problem now.
Your Clickbait Article Title Sucks Edit: Apparently par for the course on Takipi blog post titles.
I think that you and /u/desrtfx became mods out of the same discussion. No to diminish the work of the other mods, but since you two have joined the team with all the work on the custom CSS, the Hints, the banner, the message on the submission page, and the Automoderator rule, the quality of the sub really went up and the amount of uncaught code help posts went down. Kudos to all of you!
I believe you, but can you just give some examples of something that won't run on a new JRE?
Very cool. I had no idea that you could do this. Thanks for sharing!
One piece of software is an internally developed CRM that loaded as an applet in a browser built directly into another app (instead of the CRM being one app completely, it had an embedded IE frame running a java applet) that uses cross-server data communication that caused errors when transferring over to 8. I eventually finagled it to work abusing security policies, but that was just one example of one issue. Some of the function calls were giving errors because they didn't exist anymore or changed, etc. Again, that's just one example of how moving to 8 as a client where the software on the server side was coded for an older version (and actually, coded for much older than 7, to be frank. We were lucky that the upgrade to 7 was relatively painless but still had a couple of small issues crop up then too). If they'd have done more backwards compatibility (such as interpreting the deprecated function calls and utilizing them in the new manner "on the fly" with a notification that the old manner is deprecated and to use the new method for example) it wouldn't be that much of a problem; however, when you have a language that's been maintained for as long as java has you tend to run into those problems when you don't have a little more foresight. Honestly, I think the way they're managing the distribution (bundling with junk) and making things more difficult for java developers on the whole they are digging a grave for java that they may not be able to fill back up.
Although there are still some good things to come from JEE7 (like jaxrs 2), I thank the gods for now being able to use Java8 with the streams and lambdas. I thank them a lot &gt;_&lt;
Blackmail? You downloaded the JVM for free and suddenly they owe you something? They pay those developers to backport fixes because they get money for it. Would it be better if all they did was update the latest release? If you need security updates and uou cannot just update then 99/100 times you can afford to pay up. 
Well why would you expect to build your business on product without paying anything for it? If you are making money off of Java, Oracle should be making money off of you. 
There are still lots of websites with applets (specially scientific websites, algorithm websites, etc...). Any solutions on how to keep these applets supported except using other browsers?
But you can now package Android apps in a plugin, so it's even better.
No, use Firefox.
That's not the topic of discussion... at all.
At that point, you're probably running out of memory. A billion 1k records take 1 terabyte to store. Merging two sorted sets of them efficiently takes O(2 billion). Merging them inefficiently takes O(30 billion) or maybe 15x faster. For a freaking terabyte. Which you shouldn't be sorting in-memory anyway. 
Yet... They have not done this with JRE 8 yet... Update 25, 31, 40, 45
&gt;If they'd have done more backwards compatibility (such as interpreting the deprecated function calls and utilizing them in the new manner "on the fly" with a notification that the old manner is deprecated and to use the new method for example) Deprecated symbols in the Java SE standard library *don't* get removed. If this shitty app was trying to use symbols that no longer exist, then it was using symbols that were never supposed to be used by applications in the first place. That is and always was a bug in the app, not in Java. Whoever wrote this app was an incompetent hack.
and now, I have dropped support for Chrome.
It's distracting to see two variable names side by side, and wonder why its not throwing an error, then only to realize that one of them was a class without proper naming conventions.
Ok, go rewrite lots of stuff that works just fine. GO. Doesn't sound appealing to me. Don't get me wrong, applets suck.; but there should be an optional way to use them.
I'm saying that they are making a mistake by discontinuing security patches in a version that a great deal of their users still use. The fact that they're charging for private patches means they're still doing the development. If they were vanity patches that didn't do anything to close security holes it wouldn't be an issue... But it's literally about patches to fix holes that they have created in their own codebase.
Yeah it would I imagine. Don't get me wrong I dig OpenJDk. It just makes me uncomfortable to use it in prod lol
But the many issues that *I* have seen reported about Java were, as far as I remember, all security related, meaning: A Java program would be able to escalate its rights, or rather, if it were a Java applet running in the Java browser plugin, it would be able to do stuff outside the plugin's sandbox. That was my take, and hence I never install the browser plugin / never use Java in the browser. But once I decide to run a Java program locally, all bets are off, anyway - same for an EXE that I run locally. Because of all that you're saying, you must be convinced that Java did/does have *other kinds* of flaws. Is that so? Could you name an example? (I'm not asking for a bulletin link, just for a short description.)
JRE 8 is binary backwards-compatible with Java 7, Java 6, and if you aren't code signing and you are missing your permissions manifest file. Learn how to make a DRS "Deployment Rule Set" file to deal with JRE not having medium security anymore. JDK 8 Compatibility guide... http://www.oracle.com/technetwork/java/javase/8-compatibility-guide-2156366.html
https://news.ycombinator.com/item?id=9394050
I was going to comment "java applets are shit", but then I realized I was on r/java
Use the Canvas? I mean if you want an interactive application the only thing that HTML5 doesnt give you is access to the file system. Other than that, nearly everything that you can do in Java you can do in the browser (with the exception of cross site scripting) 
Any thoughts on why you went with a Map&lt;String,Object&gt; for configuration instead of a builder, a configuration object, or a set of constructors? I suspect you are using a Map in order to mimic Ruby's option hash, but this isn't idomatic Java and seems a bit error-prone. If you must use the Map for configuration, I'd at least provide some constants. Or an enumeration and change the configuration to Map&lt;MyEnum,Object&gt; to constrain the types. But I'd see about losing the Map in favor of something else. Also, it would be nice to provide a way to actually change the words being used. Hard coding them into the app doesn't provide as much value. As a user, I should be able to configure the word lists. Don't let this discourage you, keep working. **Edit**: If you are only using one method (StringUtils.join) from Apache Commons, I'd consider dropping the dependency and writing my own join method. But that's fairly subjective and I don't like having many dependencies if I can avoid them.
Thank you very much for the comment. That is exactly what I thought by writing this Java Version. I just didn't found any better way to use optional parameters without any order. Personally I really hate this map approach and it's ugly. To the dependency: I know, I just didn't found any better way for myself. So I just used the library to fix the problem temporary. Thanks, Atrox EDIT:// Update pushed, please take another look. This seems better for me now.
I use regular chrome.
The link to his blog isn't working for me. 
The UK is years behind the US as far as innovation in technology, so that's understandable. The larger finance companies that populate the UK would have gravitated towards Microsoft as a result of the (empty) patent threats and fear. That FUD strategy did wonders to blind companies with bad tech leadership. Here are additional sources: http://www.indeed.com/jobtrends?q=Java%2C+C%23&amp;l= http://www.google.com/trends/explore#q=java%20programming%2C%20c%23%20programming&amp;date=today%2012-m&amp;cmpt=q&amp;tz= Funny how a lot of the "emerging markets" are picking up on Java. The open source leverage is going to kick the UK into the information age dark ages if they don't shape up. Even Microsoft is seeing it as they rush to open source more and more of their stack. Unfortunately there is so much community and library already existing in Java (and scala, Kotlin, etc...) that there is probably more catching up to do than is reasonable.
You don't know what your talking about.. Obviously applets don't stand the test of time, but applets are quite useful for a lot of applications. They still are! For instance we have an application that does sound editing, using applet technology we had the possibility to port this software 1:1 to a Web page. 
Works w/o www. prefix: http://shipilev.net/
There is an old and buggy "appletviewer" program in jdk/bin folder (good luck with that ;)
That's a fantastic reply. A search on indeed.com US for java vs c# shows &gt;2:1 and nearly the inverse for itjobswatch UK.
&gt;Are you not a developer or are you just hanging around /r/java? I am a developer. &gt;You don't see any evidence of this being the case because you oppose the premise not on factual grounds but your emotional response to a private company making profit... Straw man argument. I see no evidence that any security vulnerabilities were created intentionally. That is a very serious accusation. If you expect me to believe that any of them were, you will submit compelling evidence to that effect. &gt;If you wrote a program that accepted data input and you fail to scrape the data and prevent sql insertion attacks, you put those security holes into the software. Really? Go demand Microsoft patch the vulnerabilities in Windows 98, then. See how that works out for you. &gt;You are obligated to fix it, not extort someone pay you to fix it. Demanding that you be paid to do specialty work (in this case, providing security support for obsolete software) is not extortion (unless the security bugs were created deliberately, which they were not).
&gt; I see no evidence that any security vulnerabilities were created intentionally. That is a very serious accusation. If you expect me to believe that any of them were, you will submit compelling evidence to that effect. Nothing I said suggested this. That was your interpretation. &gt; Really? Go demand Microsoft patch the vulnerabilities in Windows 98, then. See how that works out for you. You realize how long they supported the OS after the new OSes came out, right? They gave ample time for people to migrate to the new system. This is vs. Java's 7's 1 year mark after 8 was released. &gt; Demanding that you be paid to do specialty work (in this case, providing security support for obsolete software) is not extortion (unless the security bugs were created deliberately, which they were not). Again, the holes in security in the product was introduced because of the code that their developers wrote. Top this off with the EOS of all previous versions of java being *much* longer than that of 7, it doesn't follow their historical actions. Java 5 had a 6 year support life. Java 6 had a 7 year support life. 7 had less than 3. 7 arguably has a *much* larger userbase than either of the previous two. There's no logic in the EOS for 7 other than to extort money from the companies that run it.
Why on earth people downvoted this answer. This is the most "up to date" ansewr in this list (spring boot / jhipster perhaps as well)
the teacher in my opinion was lost, and everywhere with his examples and teachings, and most if not all of the time he's scrambling for answers 
Also consider using the java Chef cookbook to download and install Java -- https://supermarket.chef.io/cookbooks/java
The Head First Object-Oriented Analysis and Design book is an "active" learning book. It's also fairly fun to go through. It has a lot of exercises and tries different ways of getting you to remember the content. I tend to think of the Head First series of book as more workbook.
Neat.
I think you would have a lot of fun with this: http://www.the-editing-room.com/
I think you broke their website. Even the manual download is borked.
Perfection is achieved through training not tutorials. Spent at least 5000 (five thousand) hours actually programming then you will be able to reflect on how you can get there. 
Head First Design Patterns will walk you through how various OOP principles are used to create standard design patterns that are used very heavily. Great book. http://www.amazon.com/Head-First-Design-Patterns-Freeman/dp/0596007124
What are these Chef cookbooks? Are they for beginners, or advanced users? EDIT: my mistake, I confused this particular site with a book series
how do you handle polymorphism with hungarian notation?
How about a simple web-based game that you can deploy to a cloud infrastructure like Digital Ocean? Keep the game play itself very simple (maybe a very limited interactive fiction Zork-like, to keep the front-end simple) and focus on learning web-scale technologies. 
If you mean extending classes into subclasses and so on, I don't really care if a member variable is a member of the superclass or the child class, etc. I still prefix it with m_, it would get ridiculous if I'd prefix subclass member variables with their own prefix and so on. It's fine like that, at least in my head and I mainly code for myself so it doesn't matter so much. And after all, if you have an abstract class with member variables and make a class that extends it, all the private or public variables in the class you extended are going to be members of your child class even if you don't use them, so in that sense it doesn't really matter, just prefix them with m_.
Great, thanks for this advice and help. I've managed to get my hands on the Head First and Design Patterns books from a friend, so will work my way through them. I'm realising that there is much more to learning Java than just the language itself. Understanding OOP patterns and design seems just as, or if not more, important!
From someone having a very basic knowledge of Ruby, but a pretty deep knowledge of Java, it isn't really clear what actually needs to happen here or how it relates to JDBC. I would say make sure the bounty reflects what would be about a $40 hourly rate. 
Parse the information to a string to print it.
Look at [MessageFormat.format](http://docs.oracle.com/javase/8/docs/api/java/text/MessageFormat.html#format-java.lang.String-java.lang.Object...-) or [String.format](http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#format-java.lang.String-java.lang.Object...-). In your case, int number = 3; String.format("%04d", number) might do the trick.
Nope.
I've been making small content management systems (think Wordpress or Wikipedia) recently. It's a pretty good way to learn about web frameworks and databases.
&gt; We pick a day, everybody checks their code in Are you wanting everyone to rendezvous with completed, production ready code on this day? That seems like a hard thing to do unless you want broken, half-finished work getting checked into trunk.
Well to that point two things: 1. Projects that may be nearing a push to PROD (a determination each team/developer would need to make) could be branched. 2. Developers would know ahead of time that this would be occurring. I would say at least a week of very loud warnings telling developers to get their stuff checked in or at least in a manageable state. If for some reason a change falls out side the above two conditions, then I guess we will have to figure something out (i.e. give the developer/project a little more time). This should hopefully be the exception and not the rule. I will have to deal with reality and not what I want reality to be, but generally one should be making changes in such a way that checking your code in at the end of the day isn't an issue*. I'm not going to sit here and suggest that I always follow this practice, but definitely found my productivity and satisfaction to generally improve when I do (you start thinking of a problem in smaller chunks instead of one big issue, the frequent check-ins make you feel like you are making more progress). *If a person is working on a feature branch then that branch too should be formatted using the new standard. 
After the switch, use server side checks to reject commits that don't meet the standard.
&gt;The biggest problem to watch out for is mixing formatting commits with functional commits, which will make the commits much harder to read and merge. Yea I agree, which is part of the reason I want to push for the big clean cut-over approach. Otherwise you might get into an instance of some developers following the standards and others not and then you get the above issue. &gt;In our place we use the maven checkstyle plugin to regulate format, it fails early on in the build process if formatting breaks the rules. We are also using Maven (something I'm relatively new to as I came from an ant/ivy shop). I'll have to see about making this a part of our build. Though that may be a bit down the line as that will probably (certainly) be too much change to handle all at once. &gt;not setting their IDEs to autoformat on save. Hmmmm... I think the cost of a couple line breaks changing on occasion is worth it so as to ensure code is always pretty close to the established format when checked in. Otherwise you run into the issue of developers like yourself being afraid to alt(ctrl)-shift-f a file (something I do obsessively) because of the initial issue you brought up of mixing formatting changes with functional changes. Still though, I will talk to a couple of developers I know, who are far better than me, to get their opinion on this. I might be wrong... Thanks for the advice!
Hmmm... Maybe a good idea. Though I think a warning would be better (though that may not be practical/possible with how SVN or git works). My concern with rejecting would be if something was wrong or got messed up with the style file that was being use to validate the commits against. I'm guessing your shop does this, have you ran into any issues like the above? Does everybody use the same IDE? Is this a good example to go off of: https://gist.github.com/davetron5000/37350? 
I've read it and it's a nice book. What I especially like is that the book presents a problem, leads you towards a solution and generalizes it to a design pattern. Much easier to digest and understand than the GoF book. (Also, examples are much more interesting than the GoF's hypothetical text-editor.)
It is honestly a genuine concern I have.
We had multiple jobs per project. Every project used maven, so it basically boiled down to: job 1 (verify/deploy to company maven repository): maven clean deploy job 2 (formatting): maven -Pformat git commit -am "[jenkins] Auto formatting" git push job 3 (sonar/findbugs) // I've forgotten how exactly we did this So naturally there were an explosion of jobs. I ended up going with this: https://wiki.jenkins-ci.org/display/JENKINS/Job+DSL+Plugin Basically, it let you write a script to set up jobs. [ projectA, projectB, projectC ].each { // make main job // make formatting job // make sonar job } So adding a new project just meant updating that list. This is all specific to Jenkins, but I imagine Teamcity has something similar.
Even shorter: private static BigDecimal functionalSum( List&lt;BigDecimal&gt; listOfTxnAmounts ) { return listOfTxnAmounts.stream().reduce( BigDecimal.ZERO, BigDecimal::add ); }
&gt; setting aside the issue of buy-in So basically: * You've ignored the fact that no-one's approved this piece of work you're doing * You're planning to change the build system, force everyone to complete their projects on your schedule * You're devising a formatting system which you like, ignoring the preferences of everyone else. * Your plan revolves around changing a huge amount of code simultaneously and hoping the auto format that affects every line of code breaks nothing. * You're a new developer so you have little to no technical weight This is a stupid plan. Apart from anything else above, `git blame`'s SVN equivalent will blame you (or the automatic merge tool) for every single bug that currently exists in the code. You should get buy in first, then gradually re-format projects as they are changed. There's absolutely no value in re-formatting code that isn't being developed. The only pay off is bugs. Re-formatting improves code readability. If no-one's reading the code it doesn't matter. You may think: http://imgs.xkcd.com/comics/code_quality.png But everyone else thinks: https://s-media-cache-ak0.pinimg.com/originals/b6/e1/88/b6e1888d89160fd191277579a92e7a1b.jpg
Maybe you can wait for a while before trying to implement this invasive change? In the mean time, you can build some respect and trust of other devs. Nobody really likes this new guy who comes in, says everything is wrong and needs to be changed right now (especially if you're not senior/lead).
FYI: This should rather be posted in /r/javahelp. /r/Java is for News, Technical discussions, research papers and assorted things of interest related to the Java programming language but not for actual programming.
Code style is at the same time very polarizing for developers since it can interfere with their focus and their ability to quickly scan code, and there is no clear answer as to what is "right". It is probably impossible to come up with something that pleases everyone. I don't know if it will go well or not, it depends a lot on the team. Maybe try to get a few other members on board, or even better a consensus ? Since I didn't answer your question in my first post: reformatting the whole code base sounds like a bad idea, you're almost guaranteeing merge conflicts with files that people are working on. Have everyone install the formatter config on their editor and only reformat code when it gets modified.
You can access the filesystem through HTML5 - it's just sandboxed (i.e requires user input)
 (a, b) -&gt; a.compareTo(b) &gt; 1 ? a : b Won't it always fail? Because compareTo of BigDecimal never returns anything bigger than 1 ? Should be &gt; 0 probably
Thank you. I am the author of the post. I have updated the blog to reflect your comment.
BigDecimal has a max function you could use instead.
Have you tried testing how long this takes versus pre-Java 8? I ask because of this: http://stackoverflow.com/questions/23756966/why-is-stringbuilderappendint-faster-in-java-7-than-in-java-8 
Could you elaborate on what kinds of stuff you manage? I'm guessing you use something along with java, just html or some sort of program?
I wouldn't say that. It is just that you are not familiar with the syntax. Don't confuse familiarity with readability.
So this is the same as &amp; 0xFFFFFFFF? wouldn't it be better to be more explicit?
Repost
Your max function would also probably be a good use case for the overloaded Option version, as 0 could erroneously be returned as the max of a list of negative numbers
Also good to note that the jvm likely optimizes it away. If it doesn't immediately, the JIT definitely does. 
I understand the benefits of Optional, but it just *feels* like it makes your API less clean. It's too bad Java 8 didn't bring a standard @Nullable or @NotNull annotation to help with this. There are [too many options to choose from] (http://stackoverflow.com/questions/4963300/which-notnull-java-annotation-should-i-use) To me this is a better approach to handling nulls. Optional definitely gives more flexibility, but making Java code more verbose doesn't seem like the right direction. I should wish they had implemented the Elvis ("?.") operator. I saw today that C# is [moving forward with it](http://www.reddit.com/r/programming/comments/335b1s/the_new_operator_in_c_6/).
Aww, c'mon, don't answer this here! Because of YOU these questions keep popping up here instead of in /r/javahelp.
As one of the comments says... it's less of Java thing and more of a Javascript thing.
Rarely we use concurrency and multithreading on normal HTTP web server application programming (unless you code your server yourself). Mostly concurrency and multithreading are used in the backend batch application which communicate with the web application through some kind of messaging (eg. JMS).
This is exactly right. Optional is not intended as a substitute for if( x != null). It's intended for use in streams. The view that it's just syntactic sugar is mistaken. (And personally I don't agree at all with the author that it's somehow more self-documenting). 
Shouldn't that be something the Java to JavaScript compiler should take care of? I think it should at least be commented. A better solution in my opinion whould be to have a GWT utility class that has methods to handle these compatibility aspects. This way you can make things explicit to users and the GWT compiler can just use them as annotations / macros internally.
Start with spring jpa would be my recommendation. It allows you to hit the ground running and the interface driven repos are amazing. I would recommend a dto model for your API, that will allow you to modify your database/entity layer without API changes, leaving you open to swapping as needed.
1) yes, gwt should handle this transparently. it doesn't and there's probably some (not necessarily good) reason for this. 2) one of the comments on SO mentions that it is documented in the gwt compatibility page
Already on the sidebar if you look at the bottom
Anything to do with distributed systems; perhaps implement your own version of the Actor pattern. Allows you to break apart your applications into discrete parts that could either be running locally or remotely, with queuing and message-handling used to co-ordinate.
Yeah but easy to miss. Really would like to hear what /r/java thinks of some of the lesser known libraries on the list.
How did GWT get in there?
What do you want to write?
CDI stands for "container dependency injection", so while state can be injected, most injection is of class instances encapsulating some logic. CDI allows you to defer the definition of that implementation or state until runtime instead of compile time.
No, many implementations of CDI perform injection at runtime, but there's nothing defined in CDI that says it must happen during runtime. To clarify, CDI is a concept for expressing dependencies, and qualifications on how that dependency is resolved. Many implementations turn to reflection so that dependents and dependencies can have separate units of compilation, but there's nothing preventing you from using a bytecode engineer or an annotation processor to make the injection part of the compilation process.
**Context** not Container ;-)
So CDI is just a concept describing how the state of some object is assigned?
I've actually decided to use it in my most recent project and am pleasantly surprised how good the framework itself is, even though it was hard to set up at first. 
It doesn't suck, it pays my bills. 
**Contexts**, as long as we're correcting each other ;-)
Using flatMap() with Optional is interesting approach. Thanks for sharing. I might use that in the future. To be fair, your Elvis example would simply be: Baz baz = Foo.getFoo()?.getBar()?.getBaz(); In the example of needing a default, you would need to add another line like if(baz == null) { baz = defaultBaz; } However, in the case you don't have a default, then all you would need is the line above.
Great questions. Here is my experience: &gt; Can you incorporate third-party, JS-based components/widgets into a GWT application with ease? For the most part, yes. Some (a small number) of Javascript widget/component libraries provide Java-based GWT wrappers around their components. This will allow you to create and manipulate these widgets through Java on your client side by importing them as a Java dependency. For widgets/libraries that do not provide this (the majority), this can also be done relatively easy. I've done this for several libraries. Short version: you use JNSI ([JavaScript Native Interface](http://www.gwtproject.org/doc/latest/DevGuideCodingBasicsJSNI.html)) to communicate directly to the library that you want to use. JNSI basically allows you to create 'bridge' methods in Java that can take and return Java objects, but directly call your JavaScript library's API within the method, all in the Java class. As an example, you can pass a String to JavaScript's alert function in Java like this: public static native void alert(String msg) /*-{ $wnd.alert(msg); }-*/; Using that, you can call MyClass.alert("Hello World") from Java. You can see how that can be extended to call more complex libraries. It's not trivial, but it is definitely a reasonable option. &gt; Any time JS is obfuscated away from me (in this case, with Java) I get a little queasy. Totally understandable. In GWT 2.7 (current release), a new development mode is now the default, called SuperDevMode. SuperDevMode utilizes the browser's source maps to allow you to view and debug Java code from the browser. Chrome is very good with this. I can run my GWT app through Eclipse and debug Java client code in Chrome while debugging server code in Eclipse. For production, you can pass an obfuscation parameter into the compiler to leave the resulting JavaScript more readable for debugging purposes, as well. &gt; Also, I remember it feeling a bit heavy on the boilerplate--maybe my application was just too small to see the benefit of so many abstractions Another good point. As /u/yawkat mentions, the setup boilerplate can be a little overwhelming. However, once you get set up, the boilerplate is no more than the boilerplate you'd encounter in any Java-based application.
I'm new to all of this programming stuff, so thank you for your explanation. That was super helpful.
I like Java the language. While it's far from perfect, I think it got a lot of things right that C++ got wrong. I think the JVM is an amazing piece of engineering. I wish every VM could be as awesome. I fucking *hate and loathe with all my being* the horrible, ugly, bloated, bags of shit stapled onto the side of Java the language and the JVM. They take something wonderful and absolutely drown it in rotting pigshit. You can usually tell these because they have the word "Enterprise" or "Server" in them: JEE, JSP, JBoss, etc, etc, etc.
I have always liked java and I started liking it way more once I started to learn JS. It's fucking horrible to have a bug in JS and have no idea why the script isn't running. 
I love Java. It's a powerful and portable language. It has its problems but there is so much that you can do with the language. I cannot say why my engineering peers dislike Java so much. I think it has to do with a lot of boiler plate code and over architecture. 
It is puzzling to say the least. I would guess because it's an easy target. Also, there are SO many "Java programmers", that some people crank out really horrible code and somehow people blame the resulting code on the language. Baffling, really.
I agree. I actually enjoy debugging Java, JS on the other hand... it's painful.
Not really. Java is a good language for enterprise level applications and that keeps professional programmers employed. Its a mature language and has thousands of third party and open source libraries. This means its easy to write stable, scalable applications and ensures the pool of programmers that can be productive in the language is large and growing. 
Informative answer bud!
Different strokes for different folks. It's hard to find a software engineer without an opinion. It's even harder to find a tool that works for every job you might need it for. Java simply doesn't work for everyone/everything.
Most of those you mentioned are extremely outdated, Java is an insanely stable platform. While this is very good, it also has issues because it means certain technologies that should've died, don't. At least they don't change quickly enough. If you look at the more modern frameworks in the Java ecosystem, they are absolutely amazing and mirror other platforms. Play framework, Vaadin, Dropwizard, Spring Boot.... are all modern frameworks that resemble other ecosystems like Python, RoR and NodeJs.
&gt; There are only two kinds of languages: the ones people complain about and the ones nobody uses. * Bjarne Stroustrup
because they're not real software engineers
Java is flexible but verbose, python doesn't have the same flexibility but is much more concise, if I read that right 
If there was one overarching design goal in Java it was to build a language that supported large maintainable systems that could live forever. I've worked on Java code bases that are 15 years old and many 100s of thousands of lines long. The systems are maintainable because of static typing, garbage collection and the inability for "clever" programmers to create a mess like they can in C++ or perl for example. In dynamically typed languages, if you have a lot of programmers, you have to have very good code coverage so that when someone changes an interface in a big system then everything that uses that system will have its tests break. Those tests then have to get fixed by adopting the new interface. In a statically typed language the compiler tells you you broke something. It's like built in automated tests. One of the reasons twitter switched to Scala is that they had a lot of code in their system that was just checking the types of arguments passed in. You get that as a built-in feature with static typing. Another benefit of Java is that since compilers can do static analysis, the IDEs are much smarter. "Find code that calls this function" actually works. Automated refactoring actually works.
I have no problems with Java. However most Java-Jobs are boring web-applications. That is why I have a problem with (not java but) the Java Environment.
Same thing happened with Flash. There were a lot of people that came from an animation or design background that learned enough AS3 to be dangerous. It's cool that it was an inroad for them to learn to code. It wasn't so cool when they created huge memory leaks, out of control processes, and whatever else that tarnished it's rep.
Not necessary with the IDE and proper framework. I use spring boot + Intellij IDEA and manage to be as productive (if not more) as when I was a Python/Django programmer. In addition to that, I don't have to worry anymore with performance, deployment (even easier than Django because I can just run the jar), and stupid type error. Moreover, bug fixing is piece of cake in Java because everything is clear due to proper design pattern and type system. So IMHO Java + Ecosystem + IDE &gt; Python even for single developer.
In fact it's the opposite of flexibility. Python has so much flexibility that it makes it hard for multiple people to work together. Java is more rigid but the rigidity helps to ensure that when you connect two components they work together. Or to use the original analogy, Java ensure that both people are lifting in the same direction so that 40 people can lift 4000 tons. In Python you're likely to end up with 2 people lifting in different directions and they're lifting in the dark so they can't even tell.
I learned Java for college around Java 1.4, and the verbosity left a sour taste in my mouth. Since then, every time I was tempted to work on a Java code base, I was intimidated by the ~15 levels of nested directories and the XML-based build system. I am a big fan of the JVM and the language itself is not bad. I also don't like that I have to use a big IDE to be effective. 
Because people don't like their jobs.
Nerds like to find reasons to make them feel like they are better than other nerds.
+1 after 4+ years of java, I jumped on the JS Bandwagon... ...and here I am, missing java like an old friend.
&gt;So if [] [''] on hashmaps would simply translate to any method with a special java attribute like @getMapValue, @putMapValue. I'm sure there is some reason this is a bad idea, but I can't think of one offhand. I think that, if it were a language change, it would break any legacy code that has arrays of hashmaps. If it's a library that people can choose to add to their projects, with some sort of annotation processor and stuff that goes through the code before compilation, then maybe... but then they have to be certain no one in their project will ever need an array of hashmaps. It's super-unlikely, given that the user is already using Java collections, but I'd rather this be airtight. I would support this notion with some other syntax though.
Thanks for correcting! And yes, imho precision is important when talking about something :-) 
need I say $PHP ? 
Java's date handling is idiotic. It's had a lot of stupid bugs. For example, until JDK 5.0, calendar.equals(), which was supposed to merely state whether a calendar had the same value as another, actually *modified state*, which a comparison function should **NEVER, EVER** do.
WRT #3, Jodatime is STILL the best date library I have used bar none. MomentJS is a close second. php, LOL!. c++ spare me. python not complete. 
Being an enterprise-focused language, Java supports jobs for a hell of a lot of programmers in companies with HR departments that basically only know how to check off "X years Java experience" before hiring. These poor programmers turn out a lot of really bad code. Enter the junior programmer with an open mind, who sees a lot of really bad code. Ergo, Java sucks. Yes, Java is more verbose and has more boilerplate. But it is still possible to write clean, readable, maintainable code in Java. If you come across a MetaSmurfVisitorFacadeFactory, that's human error, not the fault of the language.
it's not *allegedly* easier to master PHP. It IS easier to master it. The problem is that most PHP packages suck because the people who made them had crazy OOP ideas and didn't take into account the webpage nature of PHP. The problem with Java is that you're stuck with a framework that's very probably sucky (JSF), or the hibernate ORM drives you nuts. EDIT: Oops, replied to the wrong comment. Oh well. 
Seconding this, as someone who works in a field where solid Date handling is critical we probably wouldn't be able to operate without Jodatime and MomentJS.
s/nerds/people/g;
My first problem with Java is when updater tries to install bloatware. I know how to avoid that - I even know how to uninstall that bloatware - but my customers don't necessary know it. It is extreme hard to explain for customers that they must not install that bloatware and why that bloatware is in installer. It just doesn't compute in my mind that some serious language platform is trying to install that stuff. It is like asking - please don't trust to this platform. (Of course you could also say that C# is just one big bloatware platform too...) Second problem is that I am so comfortable with Visual Studio, Resharper and C# that I really don't see much use for Java now. It is bit hard to switch to another environment and relearn everything. Also everyone around me seems to think that I am Microsoft fanboy - so I am getting only job offers related to C# :( Otherwise - I see Java and C# pretty much equal. Both languages have their good and bad sides.Thought, I haven't followed Java development lately - so not really in good position to see what is good/bad in Java.
Complexity does not make your language "deeper" (in a good sense, at least)
CDI stands for Contexts and Dependency Injection.
Look into OSGi?
I actually get the feeling most people think Java sucks because of Desktop Java, the constant updates, the ads and because C# looks way fancier. "It's an interpreted language, it's so slow!" and then proceeds to use Python/Ruby/&lt;insert new language here&gt;
Thank god we have the Java 8 JSR310 API now? LocalTime, LocalDateTime, ZonedDateTime, Instant, Period, Duration, etc...
Distributed calculation. Get a big data source, crunch numbers.
Python is easy to write code in. So easy that your average business analyst can write code with it. I have seen a *lot* of shitty Python code.
explain...
what do you mean?
Dynamic typing is really nice for quick scripts and the like, but... I want to punch the person who thought Javascript MVC + Dependency Injection was a good idea. And then kick the people who popularized backend javascript applications in the nuts.
Hello, CDI is not a small api in terms of features and it's not really a gimmick either. Why don't you look at the features instead of trying to put the "concept" in some drawer. I would start by reading the Apache OpenWebBeans docs on what CDI really is: http://openwebbeans.apache.org/cdi_explained.html Now words are just words, me as a CDI guy should instead talk about what I really like about it... 1. CDI uses proxies so you can inject shorter lived contexts into longer lived ones (ie @RequestScoped into @ApplicationScoped). 2. Because of proxies you can have circular dependencies. In theory this is poor design but in practice you actually want this to work sometimes (even though you might create a task for a refactor later on) 3. CDI has a really great event bus that can decouple logic and work magics for clean designs imo. When my app starts I do db-upgrades, load settings and other "do this first" tasks. After that I send an event that let's various parts of my app receive a call back that it's time to boot up. We use a lot of caching and have a lot of batches that read and write data. 4. The plugin nature of CDI allows for a framework like Deltaspike to write awesome plugins that works for both Apache OpenWebBeans and Jboss Weld. Other CDI implementations (ie CanDI) probably works as well but since they are not (afaik) involved in the Deltaspike project I guess there could be some problems. 5. Not sure it's worth mentioning the fact that CDI is typesafe because that's expected today imo. But anyways CDI is and is great at telling you exactly what's wrong in your definitions when the container starts. 6. Interceptors can be really, really good sometimes and the CDI version of this is pretty neat. 7. Performance (especially OWB ;) is really good because of heavy ASM usage. Yes ASM is a double edged sword but actually the earlier versions of CDI that mainly used reflection was to slow. This github repo from the OpenWebBeans PMC chair Mark Struberg and PMC member in deltaspike is pretty good: https://github.com/struberg/cdi-performance 8. Someone was mentioning picking implementation at runtime. This is very very easy with CDI and Deltaspike. We use this a lot to substitute with mocks for a faster development. For example when we have development mode we don't need to login, have remote services online, etc etc. http://deltaspike.apache.org/documentation/core.html#__exclude We use the dynamic lookup for excludes because we have this in a properties file. You can also do this great trick for a very dynamic lookup: https://gist.github.com/karlkilden/e69282b67c370de92711 
I'm not sure it's what's meant. I'd rather say PHP suffers(-red?) the same problems JS does: lots of pitfalls that can render anyone crazy trying to debug. 
Look into Apache Shiro.
Does anyone actually **prefer** PHP?
Because hobbyist programmers hate everything that's good. They also get intimidated by verbosity and the formalities of type systems. Haters gonna hate. https://youtu.be/XcuN5DNAEfw
I don't wish to be drawn into a browser flame, I took is as; "Java is much deeper and more complex HURR DURR PHP sucks its too easy" :-)
You should try JSF. It makes all that JavaScript pain go away. Well at least 95% of it anyway.
I think most Software Engineers like Java. There are a lot of people who tinker and write blogs who do not. I think the biggest issue is there is so much bad information out there it is hard to get started. Every year there is a new "modern" framework that we must use. In reality these things never get as much use in the real world as it would seem when you read forums and blogs. Java EE is extremely powerful and easy to work with. Additional dependencies should only be added if clearly needed. 
Aka the excuse to use when you don't want to hear criticism about your language. I hate that quote because it gives people an excuse to stick their fingers in their ears instead of listen to problems that could be fixable.
Well, the thing is, you're probably using it without knowing in detail what it is and how it works and that's perfectly fine. You can just say "give me an instance of this interface, I don't care how" and then you magically get it.
&gt;mandates running on a virtual machine (VM) that has a macroscopic startup time Maybe in earlier times, but it's a few ms at most now... 
When I see the word "enterprise ready" on a library it raises the potentially overcomplicated solution to a simple problem flag in my brain.
Developing Java applications became so much enjoyable for me once I started using JSF. No more spending at least half my time redoing the same front end components. Instead I can focus on the business logic.
Not sure what you are doing but there should be very little XML in a modern JSF application. Here is all the JSF related configuration XML for our applications. Most of it was generated by Netbeans. Faces config file &lt;?xml version='1.0' encoding='UTF-8'?&gt; &lt;faces-config version="2.2" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-facesconfig_2_2.xsd"&gt; &lt;application&gt; &lt;message-bundle&gt;Messages&lt;/message-bundle&gt; &lt;/application&gt; &lt;/faces-config&gt; Web XML &lt;context-param&gt; &lt;param-name&gt;javax.faces.PROJECT_STAGE&lt;/param-name&gt; &lt;param-value&gt;Development&lt;/param-value&gt; &lt;/context-param&gt; &lt;servlet&gt; &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt; &lt;servlet-class&gt;javax.faces.webapp.FacesServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt; &lt;url-pattern&gt;*.xhtml&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;context-param&gt; &lt;param-name&gt;primefaces.THEME&lt;/param-name&gt; &lt;param-value&gt;redmond&lt;/param-value&gt; &lt;/context-param&gt; 
EnterpriseFizzBuzz is a perfect example of a criticism against Java that just needs the community to fix it. We need something like the pythonic saying, to remind people to use the simplest solution possible and to spend the time to choose a good and readable name for their class instead of using the easy out and naming based on a verbose hard to read template. EnterpriseFizzBuzz is not a problem with Java its a problem with our community, Java can have much more concise and readable code than that.
Yes Java has been good at incorporating feedback, that's why I'm not in favor of brushing off criticism with quotes like this, we need feedback to improve.
You have to go back 11 years to find something to complain about?
Too. Much. Magic.
If you think Calendar is stupid check out java.net.URL.equals() which does a *DNS resolution* of the host part and compares the two *IP addresses* for equality ... yeah.
I almost never hear people complain about Python. I've only used it a little (plan on changing that this summer). I have generally assumed it was because of the tech communities general hard on for open source. People always talk about *any* open source alternative as automatically better. So I imagine there are definite complaints but I rarely see it expressed.
For your digestion, my biggest complaint is how the community has divided between Python 2.x and Python 3.x. Python 3 changed how a lot of things worked, which broke many existing libraries. So the developers of those libraries just kept on developing for 2.x so 3.x doesn't have anywhere near the 3rd party libraries available. Leaving anybody who wants the most recent language features between the rock (developing their own libraries) or the hard place (spending time to port existing libraries).
I say people who don't complain about JSF have never had to do advanced navigation or AJAX validations, or never required advanced components. Because i find it difficult to believe that you've never experienced headaches regarding the application life cycle. Have you never had doubts on whether you had to trigger some logic on the Restore View, Run Application or RenderView phase? That you NEVER wondered why your bean wasn't updated? That ALL your JSF programs run at the first time? How about this. What if you want to validate a field by ajax like checking for duplicate records, but still do processing of the other fields? How about handling uploads and then showing you a thumbnail of the image you've uploaded BEFORE saving to the database? Using GET navigation to avoid the F5 problem with form data and allowing you to generate search engine friendly navigation? How about using a REST module to do AJAX? No, one does not simply incorporate REST with JSF. If your requirements are simple, well OF COURSE you're not finding any problems with JSF. It's like someone not looking under the rug and saying "nope, looks fine to me". I mean, take a look at this shit. http://docs.oracle.com/javaee/5/tutorial/doc/bnaqq.html You need to MEMORIZE this shit. Otherwise, you'll find yourself in several problems, spending hours to debug. Here's a list of expert Java programmers who've had problems with JSF so much they've come to hate it. https://ptrthomas.wordpress.com/2009/05/15/jsf-sucks/ I've had to use JSF 2.0, before ViewAction was implemented, and trust me, it's a pain in the ass. The standard was horribly designed, and JSF 2.2 came just too late. EDIT: Check this quote from James Gosling himself. Here's what the father of Java has to say about JSF: &gt; I hate JSF with a passion. And JSF was done, you know, there are a few things that were done for, I don’t know whether they were stupid reasons, they’re just, it’s just the way the world is, so, Microsoft had this thing called ASF which was angle brackets and percent signs with BASIC code there, then they are [gestures] “in-between”, right, and they go on a marketing campaign saying, “this is the greatest thing since sliced bread”, they get all the journalists to go, “ohh, that’s the greatest thing since sliced bread”, they come to us and they say, “ooh, angle brackets and percent signs and code in between, isn’t that the greatest thing since sliced bread?” What’s your answer to that? And if your answer is “that’s stupid – you know, there’s a better way to do that”, the press by and large can’t parse your sentences. And so we did do JSF as basically a clone to ASF just because it was easier to explain to the press.And then it wouldn’t die. Here's another use case: JSF's components not being versatile enough, so you need to use extension libraries like Primefaces or Richfaces. Richfaces. Ugh. That crap forces you to load its own version of Jquery, and you just can't override it. Well, you can try, but then other parts break. so you have to load your own custom version of Jquery from elsewhere, and work from there. Since I replaced all the app's Richfaces components for jquery ones, most of my component headaches are gone. But see, it's because I've moved my problems from serverside to clientside. And don't get me started on Richfaces compatibility issues. Anyway, my point is, if you're just worried about the frontend components and never had to use and debug third party libraries, or never had the need to debug and navigate your app lifecycle, then you're either a genius, probably the next Bill Gates in the making, or your app requirements are so dull that they're labeled "ages 3 and up". EDIT 2: Rephrasing.
I mean, the points are pretty valid. I love the JVM and the libraries, don't like the cruft. Hence, Scala!
It comes in extremely handy for functionally testing the different layers of your app. For example, if you keep your external layers (i.e. service -&gt; data) at the Interface level, you can easily mock the Data Layer when testing your service with a framework like Mockito or whatever, and functionally test all different kinds of scenarios.
Most business applications rely on CRUD operations. Learning frameworks that help you Create, Read, Update and Delete data will go a long way. I would suggest that you create a simple requirements management system using Hibernate framework to manage the database interactions. Why requirements? Because you'll need to get used to dealing with them sooner or later! :)
Except Oracle hasn't deprecated java.util.Date eother
Seconded! I hate to bash Python too, because it's a pleasure to use. But, because of the problems you cited and especially because of the lack of static typing, it's a guilty pleasure at best. I thought Scala could replace it as my new favorite hobby language, but really that language just has so many dark corners. I don't know that I'm smart enough to use it really.
Nice article, thanks OP.
Python, Node.js, etc.
Another good thing about boot is that it's not only good for working prototype. You can use the same tools from prototype until production with ten thousands of concurrent users. With Python normally we have to modify something to get a decent performance once the app get busy.
I've had the same experience with Ext.Net, SmartGWT, and honestly, ASP.NET WebForms as well. I know these are large and complex APIs but seriously, figuring out the occasional weird issue with them is FAR less time consuming than continually reinventing the wheel with MVC style frameworks. That said, one can't get away with using component-oriented frameworks all the time; especially for external high traffic sites. 
In your experience, what would be your ideal java environment? Frameworks, libraries etc. I might do a new from-scratch project and I'd like to use something decent this time.
I can't come up with many reasons I need an anon function in python that a nested function wouldn't do the same thing. A function nested inside another is hidden from the outside world and because its named it is more readable than an anon function. Anon function is not a typical part of the definition of first-class functions. I've always just heard that as I can use a function in the same ways I can use any other object in the language, pass them, store them etc.
less cruft more parens? ;)
&gt; Java ensure that both people are lifting in the same direction so that 40 people can lift 4000 tons. In principle. In reality you're more likely to have 5 people lifting 3800 pounds, 25 people lifting the rest, and 15 lifting nothing or sitting on the load. Nobody knows why those extra 5 people are there or where they came from.
Thanks. I just mean something practical that the average person would use and nothing very specific. A calculator is a good one but I already did one of those before! Maybe some software that counts calories, or gym recording software, some type of software that saves notes and makes reminders etc.. just very basic things.
The cores are huge, as they include the whole heap, but evening but the jni entry point is obscured. No way to tell what's going on in the java tier.
Yes some of that xml can be placed in Java code might be better. I know all the JPA model classes can. I guess my answer is because the IDE generated it and I never bothered to mess with it.
That is awesome, I just forwarded that to my guy that said that :)
It's been a little while since I've worn my python programmer hat, but I can still recall some of my pet peeves from a few years back. Significant whitespace is not really a problem, but can be tricky for some people to get used to, especially when they're used to being able to be sloppy with their braces. The GIL is a huge performance problem. There aren't a lot of good integrated tools for the language. Python 2 had problems with nested functions and scope. IMO, the flexibility of ducktyping doesn't make up for the safety that static types provide (*definitely* becomes a problem with legacy code or large teams (~hundreds of people)). Anonymous functions have to be one-liners. Python 3 breaks a lot of stuff written for Python 2, which caused a significant split in the community. I don't dislike the language any more than the average language, but every language has it's flaws.
What is there to explain? if you hate on a language esp like Java you're severely limited your toolset.
I hardly every use while loops, but there are cases (e.g. iterating regex results, etc). Even now that I only work in Java8, even traditional for loops are replaced with the internals of `.forEach`. 
If I had to guess it's one or more of: * The author doesn't like Spring, thinks it's too heavy, etc. * The author isn't sure how to categorize Spring as the framework is so broad * The author assumes anyone reading the list already knows about Spring It is unfortunate that Spring MVC, HATEOAS and Spring Data REST aren't included in the REST frameworks. Ironically Swagger is despite being wholly incapable of documenting a REST service. To be fair 99% of REST services simply aren't REST so if you want a framework to build or document things that aren't REST they're great.
THIS! Decoupling via dependency injection makes unit testing and modular implementations SO much easier. Instead of worrying about building all of your own mock implementations during unit testing, you can rely on a tool like Mockito to inject Mocks in an "automagic" way. Also, you can create different implementations of similar functionalities without having to rewrite large parts of your code and allow the DI framework to decide which implementation to use.
The idea is that contextual dependencies are injected. This means that injection is not just injection an instance, but a PROXY. When this proxy is accessed, it resolves to an instance that's unique for the current context. The simplest and most used example is of injection a request scoped bean into a session scoped one. The session scoped bean can be concurrently accessed by multiple request thread, but since every thread has its own unique request scope, a call on the injected request scoped bean will resolve to a different instance for each bean. The historical inspiration for this was the way EJB beans work, specifically the @Stateless ones which also worked based on a proxy that resolved to a unique instance, and JSF native managed beans that introduced the concept of scopes. CDI is the unification and generalization of these two separate concepts. 
I only use for loops for counting etc. I prefer while loops, for no apparent reason
while loops for repeating code and testing for a condition that can change at any time.. while (skyisBlue()) { eatIceCreamForAWhile(); } For loops for iterating over a collection, or a known number of items... for(Day day : daysOfWeek) { if (day.isLikeSunday()) playSadSong(); } Although the java8 streams API is going to replace a lot of the latter... daysOfWeek.stream() .filter(day -&gt; day.isLikeSunday()) .forEach(day -&gt; playSadSong());
&gt; Once the port enters beta status it will become an enterprise only feature fuuuuu Similar projects: bck2brwsr: wiki.apidesign.org/wiki/Bck2Brwsr ScalaJS: scalajs.org
Magic? As long as you avoid At transforms there is no magic. Now the language is more implicit (like we know from context what you must've meant) but no magic. 
Go build a simple postgres-backed site in Dropwizard, if you've never worked with DW before. I'll give you a couple of days, then get back to me. It's *doable*, but a big slog. Compare with something like node, where you'll be up and running and making real changes in a couple of hours. I'm not a fan of node and prefer static typing, but this is the reality that keeps people away. Working in Java is cumbersome. Edit: honestly, I bored myself typing all this, it's such an oft-repeated statement...
Care to elaborate on what the "dark corners" of Scala were for you?
Looping n times, where n is known up front? For loop. Want something to execute zero or more times? While loop. Want something to execute one or more times? Do-while loop.
There's not any reason to use while loops either, but I'm not the one that downvoted you. You use the one best for the situation, like the top answer said. Fors for iteration or set number of reps and while for a condition that changes in a deeper method.
Why would you want to go off and replace a lot of perfectly fine for-each loops like that with slower-performing streams?
You save a line (or two) of code using the foreach's built in iterator. So the question would be why write more code to do the same thing? A: There are useful circumstances, like using the iterator to delete an item when iterating a collection. But just stepping through, I'd use a foreach loop.
mobile? web server? desktop?
AT was very polite :&gt;
I've done most of my PHP devs in CakePHP, and compared to other frameworks, it's heaven. Yeah it has this ugly SQL results rearranging, but you can easily bypass it. See, unlike Java, it's not "our way or the highway". You can extend or override whatever you want for your own convenience. So, no, it's not that PHP is easier for a single page with a simple form. ANY framework or language is easy for a single page with a simple form. The real problem is when your project gets complicated. My issue with JSF is that, as a component-based framework, you have to depend on the current implementation. What about extending your component's HTML? JSF is a joke; and until JSF 2.2, [adding custom attributes was just a no-no.](http://stackoverflow.com/questions/16666472/custom-html-tag-attributes-are-not-rendered-by-jsf) What about code comments? Even if you put your JSF code inside comments, IT STILL GETS EXECUTED. Unless you disable all comments and then they don't even render. So, you want to integrate your JSF pages with unit testing? Good fucking luck. You know what I had to do? I had to emulate the entire HTTP servlet so that it could be invoked correctly in a unit test. JSF is like a god damned twisted pipeline built by crappy contractors, and you have to build on it. No easy way of testing the output rendering of your JSF page. There's no simple function that allows you to "render this page into that variable" and voila. No, all the components just get in your way. JSF sucks so much for web development that the Java guys even had to make their own MVC framework, [it's only been approved in 2014.](https://blogs.oracle.com/theaquarium/entry/why_another_mvc_framework_in) Like, 10 years late. Templating in PHP? It's built-in already! [Check out this 2003 article about templating in PHP.](http://www.sitepoint.com/beyond-template-engine/) It's fucking beautiful. Before moving to Cake, I used that code for all my developments and I never had any problems. Seriously, JSF is patch over patch over patch over patch over a crappy JSP implementation. A good framework is supposed to help you, not get in your way. Now my question is: Do you know any decent action-based Java frameworks? EDIT: Fixed the part about custom attributes.
yeah, I'm not trying to trivialize effort that went into Jodatime, but some of my frustrations (and they are minor for most part) is stuff like why is SimpleTimeFormat, which is basically a string parser not thread safe?? I've used and written a bunch of parsers in many languages and once you construct the tree, that tree is (should be) read-only. http://stackoverflow.com/a/6840856/459146 Stuff like that just feels like sloppy programming on Java dev's part and these little things really crop up a lot in many parts of framework, which is another reason for existance of a bunch of Apache libraries to replace basic things like Array output streams. 
&gt;Another benefit of Java is that since compilers can do static analysis, the IDEs are much smarter. "Find code that calls this function" actually works. Automated refactoring actually works. This one is *huge*, and a big part of why I've started to dislike a lot of dynamic languages (exceptions for those with optional typing like Groovy). Being able to explore an API because the IDE automatically pops up with what's allowed where is seriously underrated.
yeah, that's the thing internet is full of opinions and some choices in Java language were made by opinion of primarily one guy. I don't necessarily agree with all his opinions though. For example, if Java was to have unsigned integers like *every other* mainstream language, that would probably have minimal effect on *maintenance of large projects*. And yeah, I agree given current language choices (especially on linux/unix) I would (and already did) also likely choose Java. Still if you ask me what I don't like about it, I'll come up with few things that bug me. I love C++ but do agree with you on all counts. It has its place but not nearly in as many applications as the world is using it in today. One of the best quotes I've read, "C++ is great as long as you only use 80% of the language. The problem is that every developer uses different 80%." And I completely stopped defending it when I was having a discussion with one of the other tech leads and he posed a question, "If I give you 4 contractors today to help out on C++ proejct, how much benefit do you think they'll add? what about if project was in C#" (this was windows but in this context we can replace C# with Java). And he is right, in some cases, adding people to c++ project actually has negative net effect and I've had to deal with that in the past. Whereas with higher level language, those guys could actually deliver a feature or two. But I do miss *my* c++ playground from previous company.
&gt;I just gave the simplest of examples of a foreach to answer the OPs question. I understand but it's misleading to suggest that that example should be replaced by a stream. Since, being built into the language, that `if` statement is already "pretty pure", and isn't less readable a "description of what the developer wants to do" than the stream `filter`call. And it hardly qualifies as "handcrafted control logic" "which would have to be constantly re-examined from release to release". On performance in general, I think it's unlikely that stream optimization could be less fickle between releases, because it's not any less complicated. I also find it very unlikely that stream optimization could *exceed* the optimization of a single loop if it ultimately does the same thing. The stream optimizations basically attempt to combine things so that you get the equivalent of the classical loop you would have otherwise written, if you could. When it's equally easy to write that loop directly, then one might as well do so. Even if currently-unforeseen optimization tricks are added in the future, and which turn out to be possible only for streams and impossible for for-each loops, it's not true that "streams are [present tense] generally better performing". I'm not saying streams are worthless: streams offer some features (like parallelism) that are awesome and otherwise not easy to achieve. But when for-each loops can work *and* are your preferred syntax *and* they're faster, it's mad to bring up streams as "going to replace a lot of the latter".
I believe you're talking about Date, not Calendar. And Date has been deprecated for quite a while. 
SO I get it, you're not a fan of JSF. I haven't actually used JSF. Spring MVC was the last semi-traditional system I used. I decided I dislike reloading pages. So.... I do my dev based on dropwizard and angular. basically REST APIs are all the server does. It's not "pure" RESTy because I do use a cookie+session to handle authorization. One could easily have gone with OAUTH on that too. There are some templating engines within dropwizard, but I've never used any of them. One could easily choose any of the other SPA javascript frameworks if you happen to have strong negative opinions about angular. Key tools: 1) use a configurable asset bundle to serve your static assets, so they don't get cached during dev. 2) launch DW within eclipse or other IDE capable of modifying java code on the fly (JRebel does an even better job ). In these ways a good fraction of your dev cycle is very tight with no compile relaunch step. 3) write unit tests against all your REST APIs, so you know they're solid from a functional and security perspective. I LOVE this combination. its fast to dev. fast to deploy. fast to run (req/sec). Easy to monitor (graphite FTW!) maintainable. produces "modern" apps. My biggest complaint would be that java doesn't have "case classes" http://www.scala-lang.org/old/node/107 OH man that would be nice. Considering Lombok, but haven't tried it.
&gt; It's not "pure" RESTy because I do use a cookie+session to handle authorization. That's an awesome combination. Where did you learn AngularJS, btw?
java.util.Date is [not deprecated](https://docs.oracle.com/javase/8/docs/api/java/util/Date.html), though it probably should be, as every Java programmer worth their weight in salt uses [joda-time](http://www.joda.org/joda-time/).
Yes, I am aware of the Date class' state of being on life support.
Also saw DukeScript at the weekend which is pretty cool. Write code in Java and it is turned into something which will run on Web, iOS, Android, even Solaris. In some cases it is also JavaScript. Nice exampel at https://blogs.oracle.com/geertjan/entry/contact_list_in_dukescript
This article mentions javascript, not java. I think it belongs to [r/algorithms](https://www.reddit.com/r/algorithms/) or [r/javascript](https://www.reddit.com/r/javascript/). "Java and Javascript are similar like car and carpet are similar." ~ Greg Hewgill. EDIT: I see it is already in [r/javascript!](https://www.reddit.com/r/javascript/)
Focus on either Spring or Java EE to start. Hibernate is an implementation of JPA, part of the EE specification. REST is not a framework, but can be implemented by Spring MVC and Java EE's JAX-RS. AngularJS is JavaScript, and we do not speak of it here. I kid. It's a very useful framework for making standalone javascript applications that tie into your REST API. Whatever you do, don't go near Ember.js.
Thank you for the Answer. can you please provide detail of any other java technology that i can learn and is useful.
* Start with Spring MVC. Create a small server side rendered webpage with all basic functionalities (like... a to do list). * Store the data in a database. Experiment with an in memory database on startup, and then expand to a relational or nosql database. You could try the more verbose way first writing queries yourself, and then move on to Spring Data for example which abstacts all of this away for you. * Once your data is stored you can turn this into a REST service using Spring MVC. You'll have to figure out how to do the conversion to JSON in Java (finding the right dependencies). Again you can implement the POST/PUT/DELETE and GET methods. * Once you've got all of that, you can experiment with some Javascript on the front-end. You can now turn your server side rendered application into a front-end app using AngularJS for example. That'll take some time starting from scratch but it would give you a good idea of how things work. Alternatively if you want a good tutorial series how to build a web app using Java on the back-end and AngularJS on the front-end, I can recommend: www.youtube.com/watch?v=fx7hoza7wIA -- However this will drop you straight into the action and without previous knowledge it may be a bit hard to follow... :)
This isn't your fault, but I have yet to see a usage of Java 8 streams that was readable. There is nothing about that last block that looks like it's a loop. 
Start with the standard Java EE stuff. CDI, JPA, JSF and EJB. The Java EE tutorals from Oracle are good. For more practical application try the Netbeans tutorials. They have all major frameworks and are easy to follow.
&gt; Because i find it difficult to believe that you've never experienced headaches regarding the application life cycle. Not really. I know people who don't know JSF use that term to scare eachother, but lifecycle just means that loading the view template, converting and validating parameters, calling out application logic and finally rendering is done in order. This is not specific to JSF. Every MVC framework deals with those concerns, and most of them perform them in a certain order as well. They don't call it "lifecycle" but it comes down to the same thing. &gt;What if you want to validate a field by ajax like checking for duplicate records, but still do processing of the other fields? Uhm use o:ignoreValidationFailed? This will validate, but not abort updating the model when one field fails validation. &gt; How about handling uploads and then showing you a thumbnail of the image you've uploaded BEFORE saving to the database? Use o:graphicImage. Our application does exactly this. Simple PrimeFaces dialog, uploaded image is stored in view scoped backing bean and a preview of it rendered inline via o:graphicImage. If memory serves me correctly one our junior devs build that in a few hours. &gt; Using GET navigation to avoid the F5 problem with form data and allowing you to generate search engine friendly navigation? From your backing bean do a redirect and include the parameters you want (this is a best practice PRG pattern, which is not specific to JSF). If you have initial request parameters on your form page that you like to preserve, use o:form with includeRequestParams set to true. &gt;How about using a REST module to do AJAX? What would you like to accomplish there? Pure service calls that return JSON data? gThat's the job of JAX-RS in Java EE. JSF is not a full stack framework itself, but just the MVC part of the full stack Java EE framework. You can also quite easily fetch rendered content from JSF via manual AJAX calls, e.g. $("#showMore").click(function() { $list = $("#list"); var params = { start: $list.find("li").length, component: "listRepeater" }; $.get(location, params, function(html) { $list.append(html); }); }); See http://showcase.omnifaces.org/components/componentIdParam If you want to have REST like URLs for pages you can use either PrettyFaces or Faces views from OmniFaces. See http://showcase.omnifaces.org/facesviews/ExtensionlessURLs &gt;If your requirements are simple, well OF COURSE you're not finding any problems with JSF. I don't think BMW or eBay have such simple requirements, and they use JSF intensively. See https://wikis.oracle.com/display/GlassFish/RealWorldJsfLinks &gt;You need to MEMORIZE this shit. You don't have to MEMORIZE that do get anything done :X This is exactly what I mentioned above. EVERY framework does stuff like this. JSF just explains in some more detail what it actually does, while your favourite framework of the day may say "it looks at the request and gets parameters from that, which it then converts and validated before handing them to your code and after which it renders the response". The exact same thing happens, but you chose to get scared because JSF put what happens a bit more exact into a diagram, while your favourite framework is a bit more vague about it. Weird. &gt;Here's a list of expert Java programmers who've had problems with JSF so much they've come to hate it. https://ptrthomas.wordpress.com/2009/05/15/jsf-sucks/ Funny that the guy couldn't find a single addition to add to his list after 2.0 was released, don't you think? His only attempts were a weak: "James Gosling hates it" (but it's well documented James meant to say JSP), and some incredibly pathetic reports about the JSF EG being disbanded (but this is normal procedure, happens after every version). &gt;I've had to use JSF 2.0, before ViewAction was implemented, and trust me, it's a pain in the ass. JSF 2.0 overal is pretty nice, only 1.x before it indeed sucked. 2.2 made it again better and ViewAction is a very nice addition, but in 2.0 you could use the preRenderViewEvent for pretty much the same effect. And it's not like other frameworks were totally perfect in their 1.0 or 2.0 version. Play, Wicket, RoR, you name it are all still adding features or redefining things were people say that it *could* have been in version 1.0. &gt;I hate JSF with a passion. Dude, seriously. ***READ*** the context, read some of the replies to this. He meant JSP! JSP was a clone for ASP (not ASF) and PHP. &gt;JSF's components not being versatile enough, so you need to use extension libraries like Primefaces or Richfaces. C'mon... JSF was explicitly designed to create a marketplace for components. It's not a question of needing extension libraries; JSF was build from the ground up to define a component model and extension points. The default components that ship with JSF are intentionally very basic. It's like saying that Java is not versatile because external jars with classes exist. 
&gt; Like, Spring, Hibernate, REST API, Angular JS Yes.
Learn SQL. Seriously. Get a testing database, preferably a large one (I love musicbrainz) and start learning how to pull data from different tables. Individual technologies have their niches, but SQL is used pretty much everywhere and is a very valuable skill for any entry level developer
Why not go near Ember.js? Any explanation of that comment?
&gt; What about extending your component's HTML? JSF is a joke; adding custom attributes is just a no-no. It's not, it's very easy! Just use p:[attribute name] where [attribute name] is whatever custom attribute you can think of. See your own link or http://jdevelopment.nl/jsf-22/#1089 
I have a better offer :)
Where do you live, if I may ask? 
Are you using SSL3? It's been disabled in [patch 31](http://support.blancco.com/index.php?/News/NewsItem/View/73/important-notification-java-8-update-31-disables-sslv3--support).
Agreed. I write c++ drivers for industrial automation, and I've found SQL to be very useful at times.
EJB isn't as wide spread as Spring. Oracle's documentation is too dry for me.
If required, SSLv3 can be re-enabled by commenting out the line disabling it in lib\security\java.security
Probably not much help, and you most likely already know this. If you happen to be a student, it's free. All you need is a .edu email address.
So i used to work at thales in cheadle and it wasnt great pay. Ended up moving to london and now im on a lot more. Just so much more choice. I did look at moving back eventually whats the market like for senior devs now? 
Yeah, I can found lots of things that are wrong with Java, but I don't think we currently have a better alternative for large projects. I think that [this great talk by Brian Goetz](https://www.youtube.com/watch?v=2y5Pv4yN0b0) nicely describes the challenges of evolving a language like Java, and also explains some of the decisions made regarding adding features. 
1) Indeed, super.clone() is possible within a class. Still, unless the clone method is overridden by the class, it's not externally accessible. 2) Nothing. Effective Java (see [here](http://www.amazon.com/Effective-Java-2nd-Joshua-Bloch/dp/0321356683/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1429796670&amp;sr=1-1&amp;keywords=effective+java)) has a whole item dedicated to the clone method. Try to get your hand on it. Here's a passage from the book. &gt; So what does Cloneable do, given that it contains no methods? It determines the behavior of Object’s protected clone implementation: if a class implements Cloneable, Object’s clone method returns a field-by-field copy of the object; otherwise it throws CloneNotSupportedException. This is a highly atypical use of interfaces and not one to be emulated. Normally, implementing an interface says something about what a class can do for its clients. In the case of Cloneable, it modifies the behavior of a protected method on a superclass. I've been programming in Java for a few years. I can't remember the last time I overrode Object's clone method. Copy constructors have always been a better alternative.
Ah, thanks. Still, they took too long to add that. Oh well.
Cool kids learn Play framework and Scala :)
Don't learn a framework, learn ideas, they last longer. :) What I see is mostly Java EE, but you can do Spring as well. If you learn Spring, you can switch to Java EE and if you learn plain Java EE, you can switch to Spring. Don't learn Hibernate, learn JPA (which means to also learn some SQL) and then figure out if you're going with Eclipselink or Hibernate (it doesn't really matter which one).
&gt; Clients of a method with a Annotation can't tell if a method has a @Nullable annotation without resorting to reflection. Why do you think clients want to know whether a method has a @Nullable annotation? I think it is for documentation and static nullness checking and cannot imagine its runtime usage.
Same thing here. I have a student account though but I can't use those for commercial projects.
Well until last week i walked in 15 mins to work last 5 years. Just moved central for the first time. Even then its 30 mins door to door for me.
I'm not sure it matters how bad PHP is from a language design perspective, it doesn't stop it from being one of the most useful languages for web programming. Java's not exactly free from blemishes either.
I'm still kicking myself for not rushing in when they had their "end of the world" sale... Well netbeans ain't so bad.
I have heard that you can get the difference back, if you miss a sale and ask them...
I'm on 12 and it still works. You can stay with any version you want, hes saying you can't get the "upgrade" discount for skipping from 12 to 14 for example.
&gt;In JSF, preRenderView was not perfect For sure, that's indeed why like you said ViewAction was introduced as well. &gt;I have a question for you. How long did it take you to learn all of this? It's a bit hard to say, I gradually rolled into it. I mean, it wasn't like I first studied everything and then started coding. I've been a long time JSF user though. Touched the bad JSF 1.2 days, but shortly after our company migrated to 2.0 and I basically grew up on that one. I felt like I knew a lot of things after half a year or so, but that was some 6 years ago.
I could have kept 13 instead of 14 and just waited for 15. Don't get me wrong, I like 14, but 13 was fine.
No it's GBP. Today 40k GBP = 60k USD Job went to a commentor on this thread.
I started with [Scala In Depth](http://www.manning.com/suereth/) as my introduction to the language. I figured I'd sail through that, then go learn Play / Akka and probably Slick well enough to be productive on a small personal project. Sounds reasonable, right? So I jumped into SiD, and full stop. There is no step by step building of concepts. The author switches context fluidly between theoretical terms and deep in-depth knowledge about Scala and Java pitfalls and mostly explains the concepts in terms of what to avoid. The examples outlining how Scala improve APIs was thinly justified and far too premature for my use. For me at least, that was not helpful. It's a terrible first book for anyone just starting Scala. Now that is more a criticism of the book than the language I realize, but you expect more from a book when the Foreword was written by Odersky. I probably expected too much out of it. Got a better starting point? Briefly, the language itself is only semi-interesting to me and I was much more interested in just being productive with it. I probably should have started learning Play instead, but there's a stubborn part of me that wanted to be thorough and learn the language and more about FP before I went there. I just didn't choose a very smooth path. 
Contact your university, ask them to reinstate your email account. I haven't been a student for years and my edu account is still one of my main email accounts.
JavaFX if you plan to make desktop/client applications.
It is free to use and there is a Maven and NetBeans plugin. Not sure what status on source is (everything is at https://dukescript.com/)
Is the free Community Edition not enough? Not even with plugins? I'm not trying to question your decision, but I'd be interested in which features you're missing. Maybe I'm missing out and I don't even know it!
I'm really eager for their next sale. Their licensing scheme is very sucky: &gt; For the EU customers: company VAT ID is not accepted for purchases from private individuals. For JetBrains the last of the freelance is equals to BigCorporation.
My organization uses Spring all the time. The others you mentioned we only use occasionally.
Bbbut it sounds too good to be true... sigh.
That's probably true. But there's probably still only 10% of the amount of people cranking out crappy Python vice Java...
Looking at your comment history, I can see that you're no beginner and that you're somewhat dissatisfied with both JSF and Hibernate. I'd love to spew out a totally next level recommendation here and be able to just rave about it, but that's not me. Probably the next direction I go with web apps will be to try out Play and see how that goes. Angular 2 is also looking interesting. Without constructing some totally custom framework which may even eschew Java and perhaps even the JVM entirely, that's about the best I could recommend if you want to try something new. 
Spring Spring MVC NoSQL
The decompiler with debugging support in 14.1 is just great. For a quick look, why the shitty library is doing what it does, it saves a lot of time not having to search the exact sources.
Are you talking about the commercial license, or the individual license? I think it's the former, i don't see any change with individuals. I gave up on commercial licenses a long time ago, it was always such a pain to convince my company to upgrade me. For me its worth the $100 every few years.
You are working remotely from your home and save 2-3 hours of your life every day by not having to deal with commute in a large city. You could also be living in a beautiful small place somewhere in the countryside where the cost of living is much lower. maybe suddenly 60K does not look like such a bad deal...
Installing plugin now. Have an afternoon of coding to do - will update!
You can find full time remote jobs that pay standard Java dev rates as well
cool. was not aware of that. Where do you find them? regular such as monster and dice?
I'm sending you a code to disable that. Go to the preferences dialog and it will let you select what you want to send, if anything.
It is still in the tos though. How can this be used in a professional environment?
You are correct, and we will be updating the TOS to clarify that of course if you do not send anything, we cannot and will not use it. The terms dealing with information that is logged don't apply to you if you turn off logging.
The ad is for a medical/hospital group Crossover Health. They, hospitals and medical groups, are notorious for paying shit wages and having crappy hours. They are the places you work if you are desperate, or unskilled/inexperienced, until you can move on to something better.
Individual license. Starting just recently (like a year ago?), IntelliJ moved to a licensing model where the "upgrade" license is only valid for something like 18 months after the original purchase and if you upgrade, the license year is back-dated to the end of the previous license. If you're after 18 months, there is no "upgrade" price. This makes the common practice of skipping a year between upgrades (for $99) a moot point since upgrading every other year would now cost $199 and keeping current would be $99/yr. Unless something changed from last year until now... note: I pulled 18 months out of my ass, I don't recall the exact terms edit: [source] (http://blog.jetbrains.com/idea/2013/12/intellij-idea-personal-licensing-changes/)
When you have a "somestrangelibrarymodifiedbysomeguythatsnotwiththecompanyanymore.jar" in your path that has a weird behavior and you have no idea where to get the sources, you'll thank the almighty Jetbrain ;) In most cases though, I agree - but having nice and helpful features is basically what sets the IDEs apart from text editors.
&gt; I can't remember the last time I overrode Object's clone method. Copy constructors have always been a better alternative. I'll write a copy method if I need one. Usually for objects stored in Lists. 
Working remotely is a pretty good perk though, honestly. It's not valueless and I think it's fair to factor it in to a salary negotiation. 
Yeah. Install it, I'll send you instructions to disable that.
The free one is pretty good. I use ultimate for all the Spring support, but that's not really a deal breaker.
I upvoted it. That's pretty reasonable, i think, depending on local living costs. 
You should post this to r/javahelp
Please read the big red box(es) in the sidebar. And once you head over to /r/javahelp, be sure to read the sidebar and its posting guidelines there, too. Oh, and please to mention that you're crossposting your question. There's no need to let two different subreddits mull over the same things seperately.
Sure they are. Lots of companies have cost of living factored into their salary. Its part of the reason the same job in Silicon Valley will pay more than the exact same job in Nebraska.
&gt;Ps. I'm not sure if talking about animals is good when it comes to CDI, because they are an entities (they have it's own identity), when CDI is about services. It would be great to have many dogs living their own lifes :) Okay, I was wrong there, and you are right. You don't typically inject entities, although there are some exceptions (exceptions prove the rule). Applications not rarely do inject a User entity of some kind that represents the currently logged-in user. In such case the User bean itself is not directly scoped, but it's produced by a producer method that's annotated with a scope. This will result in a proxied (scoped) entity, without having the entity itself be a CDI managed bean (which it should not be since JPA manages it).
Pretty much, for a junior position I'd be really excited for 60k. After 6 years I would expect at least 120 from a position asking for all those requirements.
I don't have any recommended readings, sorry I wish I had had some myself. What I've come to find is it's all about the culture of the company (and more importantly the culture of the developers). Look for companies that have engineers who seem happy with the company, the direction of the company, and most of all, seem happy to work with other developers. Nothing will turn you off more from this field then working in a dysfunctional team. In this realm, 1 bad apple will most definitely spoil the bunch.
I figured I could do better but now that my salary is a joke.... **P.S.** I don't work for that company.
It should be disabled by default...
the problem is that they are looking for an Architect level coder. No one with less than 5 years should even be classified as architect level
pay is incredibly location dependent. Good luck finding starter dev positions in remote (aka non-major metro areas) for over $60k, but head to seattle and a starter position easily passes $70k.
I found it to be less guidance and help, more black undocumented voodoo.
Eastern Europe maybe.
Seriously do the leg work yourself, Google for a few jobs in places you'd like to live and see what the job requirements are! They tell you exactly what they are expecting! 
Yet they ask for 6+ years of experience @_@. You can probably do better than $30/hr if you have 6+ years of Software Engineering experience. Maybe it's meant to be appealing because of the remote-ness of it all.
That wacky California income tax too. 10k less in a different city can sound appealing real quick.
because FUD and some legit bugs from a while ago
It's loaded with vulnerabilities and Oracle isn't good enough at rolling security fixes out quickly. http://www.javaworld.com/article/2104862/java-security/report-half-of-all-exploits-target-java.html
Has very little to do with Java directly. NSAPI and ActiveX are ancient APIs and Google and Microsoft don't want to support them any longer.
Don't just "use" Spring. I interview all sorts of developers who can use it, but don't understand it. Really dig into the docs AFTER you have created something. The difference between a good developer and a great one is knowing how something works, not just knowing how to work something. 
How does Microsoft feel about Silverlight then? Is there (or has there been) any indication that they're going to abandon it? I'm not a huge fan of it but it seems a little more recent.
I use it to digitally sign stuff (xml) with x509 certs. I haven't found another way to do it that's cross platform and cross browser(ish)
It forces a shit ton of companies to re-evaluate platform for the next updates of their various systems. While Applets are used only lightly on the web they are extremely popular with intranets as various vendor apps will bake in applets as their UI. From a technical perspective this is not huge but it is enough of a shift to cause IT/IS departments to reshuffle things giving competing platforms a chance to get their foot in the door. At the end of the day this is just a bonus, Applets are a huge liability in general just like all the other extension based runtimes. 
Thou canst not kill that which doth not live.
It is already abandoned.
I think the point is that if there are a fewer number of gaping security holes on the internet, it's easier for everybody to collaborate to fix those. If every company has their own standards, there are far less people working on any given vulnerability across the spectrum.
Oracle is plenty fast rolling them out. Since 2012 when there has been an in-the-wild exploit an update rolled out within a week. And there hasn't been one of those in over a year. These exploits are all for bugs that have been fixed in the most recent patch of Java. The issue is that users are horrible at updating Java. The reason Oracle doesn't go into any depth about what the security bugs are is because the exploit authors often see the patch in a regular security update, figure out how to exploit the bug before it was patched, and then roll out the exploit to violate unpatched machines. What is worse is that this out-of-data Java policy is partly institutionalized. Remember the huge Mac viruses from 2012/2013 that involved Java? Oracle had patched java months before, but Apple controlled the update path for MacOSX at the time and kept an older, unpatched, version of Java integrated into the OS. Because Apple didn't want to roll on Oracle's patch cycle was one of the (many) reasons they abdicated the support of Java on OSX and gave it back to Oracle. And that article is over a year old. The new hotness is exploiting SSL and SSH. (https://community.qualys.com/blogs/laws-of-vulnerabilities/2015/03/03/top-10-vulnerabilities--february-2015)
Very misleading click-bait headline. Microsoft and Google aim to kill NPAPI, a problematic and occasionally insecure browser plugin mechanism. As a consequence, plugins that use NPAPI will stop working. Examples of plugins that use NPAPI are: Java and Silverlight.
 I didn't read it that way initially, but I think you're right. 
I just started writing and googling. I think I had two throw away apps before there was something that was not really bad. My first was actually based on MongoDB because I just wanted to do something quick. It was quick, until I wanted to do any fancy queries and then it got ugly. If I were starting a new app now I would use typescript and deeply consider angular 2.0 as the target, so do whatever is needed to be as close to that as possible. The angular team is learning too. 
Can confirm, am software dev for medical billing company. Pay is $20/hr and cant find a better paying job. Currently hating life.
Stare into the fist of Dredd!!
Most people I meet think the complete &amp; total 180 degree opposite. Their tooling w/ ember-cli &amp; documentation is undoubtedly better than angular's right now, especially considering angular is in a really weird place between 1.3 &amp; 2 (with a horrible migration plan between the two) at the moment. That said, react &amp; friends &gt; both
I just don't understand it. As far as I know, there's nothing you can build in Java that couldn't be built easier with the standard web developer's tool kit (to some loose definition of "standard") **EDIT to specify:** in terms of the front-end; the server-side can still be in Java, of course. Just hook up a web front end with web sockets and you're good to go.
It's a mercy kill.
Nope, but I did try a new uninstall, registry wipe and then reinstalled. Finally now it works. I think oracle made a shadow update :D I do wonder what happened though. After trying it in IE11, it's still bugged. damn...
I was in the same boat as you until I started working with lots of different languages and tooling. I still feel Java is kind of clunky, but I'm now a big fan of static typing with inference (which unfortunately Java doesn't yet have). I can't tell you how many times I've had to basically guess or manually run through third party code in dynamic languages just because nothing's fucking annotated and I have no idea what's going on without mentally running the code in my head. I hate not being able to do automated refactoring. I hate not being able to explore the API just by having the IDE inform me what kinds of things are allowed where implicitly. I still think dynamic has it's place, but only if it can still fundamentally be backed by a proper type system and optional typing, like Groovy (or Clojure with it's type annotations).
I think it may require a proprietary HTML5 plugin, and Mozilla won't incorporate it because FOSS. Chrome and I think also Chromium have it though, and it works great, probably better than on Windows with Silverlight. 
Ugh, guess I'm stuck using wine for now.
Even as entry level it seems a little low to me, and they want 6+ years of experience with all kind of technology stacks. For comparison I was offered ~$70K starting when I graduated a couple years ago (Colorado). I do more build and deployment tooling/automation than straight application development, but it's all JVM stacks.
Maybe it's an experience thing but I dealt with the same problem as a Web Developer and it was way easier to figure out PHP and JS.
It's not like you can't just use an older IE version on company computers. 
I've used Firefox for way too long to switch. The moment I open Chrome it shows I support them, when I don't.
A bunch of prehistory is given in this [StackOverflow answer](http://stackoverflow.com/questions/26398951/why-is-cloneable-not-deprecated). Essentially the Cloneable interface is a marker on the class that Object.clone() looks for before it will proceed with the cloning operation.
I dunno, even this 'shitty wage' is a pretty big raise over my Dutch salary. But then again, in America taxes are not deducted automatically are they?
dont, it looks horrible, at least the last time i tried (maybe 5 months ago). You can link the *.fxml files to the external SceneBuilder for convenience tho. Sorry if its not that helpfull :/
Tried it and it's quite nice, but the calling home part is a problem for me here at work, so sadly I cannot use it... Maybe you could check out the TOS/PP of SwiftKey, which also calls home to get better suggestions, but it's an opt-in service, not the other way around.
I'm on my own here, unpopular, but even alone I will rue the day Java dies from the browser. At least it was a standard, well defined language and runtime. A solid foundation to be built upon even if it still needed work on browser integration and security. Modern web-development is an absolute fucking shitstorm: it pains me no end that newcomers think this unholy HTML + CSS + JS trinity was ever a 'designed' and desirable solution: it wasn't and isn't. It grew uncomfortably and sub-optimally, beginning with the IE vs Netscape friction of the early nineties. Yes Java and Applets in their known form are no solution for the web; but think of what could have been if the faith had been kept a little longer: JavaFX-like UI, with layout and content driven by cached repositories of digitally signed library dependencies, transferred between browsers via Bit-torrent like protocols and an improved, sandboxed subset of Java could be a much better featured and performant foundation of the web than the inane world of JavaScript frameworks we see today. Native binary transfers would making the entire web perform more efficiently than it does today. Hell, JS doesn't even have namespaces. I'm done here, fuck the Web, Desktop forever. Duke, I love you! TL;DR: Modern web-stack can go to hell.
As well as google's own GWT DevMode plugin I'm more than a little annoyed, because the alternative, deceptively called SuperDevMode, makes debugging much more annoying. 
Thanks for the heads up.
Where have you been? They were considering dropping Silverlight back in 2009 and the axe fell in 2011. http://www.ustream.tv/recorded/17254070 
I've been on netflix. 
It'd be a lot more applicable if you allowed people to use or add custom adjectives and nouns through the builder and allowed them to dictate if they want to use the delimiter, token etc! For example if a user wanted to randomly generate a username for an email account such as you see on First Time signup email service providers and a specific name was taken, then they could generate the name with a token on the end such as email123@provider.com 
Found it! Thanks!
I am also having a hard time interpreting this response.:p
Microsoft depreciated Silver-light long ago.
I agree with you. You should try JSF it still has all that garbage in the background but you rarely have to worry about it.
.setTokenLength(0).setDelimiter("") // =&gt; "billowingleaf" or .setTokenLength(4).setDelimiter("") // =&gt; "billowingleaf1234" It is already possible to remove the delimiter and/or the token. I don't really know the best way to add such a custom noun/adjective feature. If you want just send a pull request with your best way of handling this. Thanks, Atrox
Maybe if you're just surfing the web.. Nearly all of the IT infrastructure we have at my office has Java apps running for remote management. Obviously you can SSH (etc) into ... most ... of these, the majority of them require Java for firmware statistics/info. 
No no no no. Just don't launch anymore Java from a browser. Fucking download the app like any other app and run it. I maintained a jnlp app, it was one of my happiest days in my work career when we retired support for jnlp.
This. Developers should be learning better languages than Java anways..Especially these days. Java was cool 20 years ago and it seems like a large part of the dev-base for IT have been hyperfocused on Java. 
It's made a name for itself in the server space for a reason. 
&gt; As far as I know, one can't pay bills with ice cream... They want you to live at work. 
What better languages are you talking about?
&gt; better languages Please tell me how you define a language as "better."
Good. Now if only we could redistribute the runtime with our apps. I mean, do end users really need to know that they need a separate runtime to run our programs? 
That's very likely because you're simply not intimately familiar with the syntax of lambdas. Once you get used to the syntax, they can be much easier to understand. For example... I don't know how anybody finds this more difficult to read... List&lt;Month&gt; monthsWith31Days = allMonths.stream() .filter(m -&gt; m.getDays() == 31) .collect(Collectors.toList()); vs... List&lt;Month&gt; monthsWith31Days = new ArrayList&lt;&gt;(); for (Month month : allMonths) { if (month.getDays() == 31) { monthsWith31Days.add(month); } } And if I want to do a double filter... For example all months with 31 days which start with a J... List&lt;Month&gt; filteredMonths = allMonths.stream() .filter(m -&gt; m.getDays() == 31) .filter(m -&gt; m.getName().startsWith("J")) .collect(Collectors.toList()); List&lt;Month&gt; filteredMonths = new ArrayList&lt;&gt;(); for (Month month : allMonths) { if (month.getDays() == 31 &amp;&amp; month.getName().startsWith("J")) { monthsWith31Days.add(month); } } Now you have a compound boolean inside an if statement nested in your loop. You can easily add more filters, but adding additional criteria in the for loop becomes even more burdensome.
I like react too. I can put thousands of elements on the screen without terrible slowdown. 
So..legit reasons.
7 just got end-of-lifed by Oracle. It is now officially vintage. So there's that. Also, if your project is open source and no one is paying you to develop it for their specific purpose, do you really have any good reason to bend over backwards to accommodate the special needs of some lumbering megacorporate behemoth? I'm thinking not. Fuck 'em; you've got better things to do. On the other hand, if your project is *for* GAE or something, that pretty much forces your hand...
Income tax is either automatically deducted or you have to pay quarterly. There are other "payroll" taxes that always come out automatically. In any case taxes do come out of the 60k. 
Every language has its pros and cons. There are no "better" languages. Devs have been using C longer than Java. Should we move on from that as well to a "better" language?
No. I think you are better off just reading the weld, hibernate or jersey docs - they are much better. And a perhaps a book on ejb/jsf
Yes I do. PHP has been undergoing a renaissance. If you haven't used PHP this year with composer and a good framework like Laravel, you haven't used it at all. And PHP 7 is going to do for PHP what HotSpot did for the JVM - make it competitive with compiled languages. Don't be so quick to judge.
I'd recommend install4j. My biggest problem with jnlp was that it forces you to use the system jre version so you get lots of tickets like "I installed java x.y and now it doesn't work". Packaging your desired jre with install4j really helps eliminate these tickets and when you decide to upgrade to java x+1 features there's no fear of breaking the people who haven't upgraded their system jre. JNLP was a miserable experience for me and only slightly better than applets. Support cases dropped when I dropped it.
&gt; I don't think we currently have a better alternative for large projects. I think it is worth asking if large projects are a good idea? The best systems I've worked on were composed of may small programs with clear communications protocols among them. SOA, for instance, or even the unix shell.
Bullshit. Once it's compiled, what do you care which language level the code uses? 
Hard to say, hopefully hit 1.0.0 in a few months.
Well, ship has sailed on 6, but I think 7 is reasonable.
"I get that they want to ship "portable" code. But it seems dumb to keep reinterpreting/JIT-ing bytecode when I'm never gonna move that damn program anywhere else" This is a major contradiction. You get the benefits of portable code, but don't want portable code for yourself? To a certain extent, updating your Apple computer could be seen as 'moving your program' somewhere else (at least with Windows and various changes in CPU archs it was/is). Barring the JVM issue with Yosemite (which is a fault with Apple), I still think it's ideal that I can take Java code from one machine (Linux, Windows, Mac) and not be overly concerned about having to 'natively' compile and prepare my software. You're right though that this isn't as important for single desktop end-users, but it is when you're using the JVM for enterprise sized applications that get deployed in various types of places (i.e. hardware, OS, physical geographical locations, etc.). However, focusing primarily on desktop applications, I guess the major benefit is not having to maintain natively compiled software. It's got to be a pain when users from N number of OS's, hardwares, localisations, want you (the company) to provide binaries of their software.
For a general purpose library I wouldn't target 8. Most larger companies probably still run against 6 / 7.
Just use java 8. Early adopters of a library are likely early adopters of a JVM as well. By the time your library gets traction, java 8 will be more mainstream.
It depends on who you think your primary consumers are going to be. My primary criteria would be "What is the likelyhood that this gets integrated into an old code base?". If you are expecting people to mostly spin up new projects that surround this library then hit 8, for sure. If, on the other hand, you expect this thing to be put into projects that are long lived then I would say move more towards 6 or 7. But that isn't set in stone. After all, if you are thinking most of your clients are going to want to work with cutting edge tech, then making 8 a requirement probably wouldn't be so bad, even if the code base is old. The fact that 7 is EOL also makes me tend to say "just go for 8". Though this is just recent (my company hasn't moved off of 7 yet :() it doesn't seem unreasonable to expect that most actively developed projects would move up to an 8+ jvm.
What bothers me is that there's a loop in there that is hidden. Replacing it with a bunch of chained method calls doesn't make it easier to read, but harder to see the flow. 
I am not sure why you asked, but yes, I am developing one such browser: [gngr](https://github.com/UprootLabs/gngr). It is a major rewrite of an older project called "Lobo".
Since Java 8 is now the lowest officially supported version, I would say it is mainstream. Soon there will be Java 9. By "soon" I mean a year or so. Not that long really in the life of a library. Making one final version that would work on java 7 is icing on the cake before going to requiring java 8.
How do you view the presentation?
Thanks for the corrections, everybody. :) You learn something new every day.
Thanks, will check it out.
You need flash.
&gt; Fuck 'em That's so rude. You should ask: "How much would you pay me?"
This is a feature I love in c++
Because all of those loops are buried in the operation of sorting, which is what I asked it to do. I guess I just don't like the format of object.doThis().doThat().doSomeOtherThing() and spacing it as: object.doThis() .doThat() .doSomeOtherThing() seems to just be trying to hack around the fact that you're doing something that is inherently unreadable and the only way to make it better is to waste a ton of whitespace. I see this as the same kind of problem as when you have a function with many arguments and you line them all up with the open paren: object.doSomething(callSomeFunctionToGetAValue(), callAnotherFunction() someLocalValue); They both look bad because what you're trying to do is inherently unreadable.
I hate to be that guy, but [this](https://github.com/amelentev/java-oo) seems to be more complete. 
How is this magic done?
&gt; But it seems dumb to keep reinterpreting/JIT-ing bytecode when I'm never gonna move that damn program anywhere else. Perhaps (though I doubt it really bothers you as much as you think). But this has to do not with "the JVM", but with the particulars of how your JVM behaves. JIT caching -- the writing to disk of JIT-compiled code -- is something that will be added to HotSpot, possibly even as soon as Java 9. All this has nothing to do with the message you're getting, which simply has to do with a configuration file. You'd get the same problem with any native binary relying on DLLs.
FTA: &gt; This library allows to add operator overloading to your Java projects. This feature is normally not supported, however by creating an annotation processor it is possible to access the internals of the javac compiler (which is itself written in Java) and modify it to do our bidding. Doing so requires to access private code not part of the public Java API. As such, you must consider that it is experimental and that it may break unexpectedly at any point if Oracle decides to rewrite parts of the compiler implementation. Therefore it is more a fun experiment than a serious tool to build systems on. IOW - It's going to break.
Sadly, not really. 5eb63bbbe01eeed093cb22bb8f5acdc3 === 5eb63bbbe01eeed00000000000000000 is true.
Yeah, I don't really want to change my code to rely on something that's hacking private functions in javac.
Yup. We have been bitten by it in our large application. The fact that going from java 6 to 7 to 8 is a PITA because we are using private javac methods angers me to no end. (The developers that did it should be shot...). It would be only worse if we relied on a third party library doing the same thing.
Yeah, it's too bad. I've slowly come around to appreciating the Smalltalk way of doing this because it's uniform and trivial to hack. Everything is a message. Simple. 
Java 9 doesn't look to add anything of value for a java library. Even after 9 goes out I would probably still suggest 8 just because you aren't gaining much by requiring 9.
TLDR: Type Erasure is not going away with java 9, 10, 11 or ever. That is kinda sad. 
Or when you want matrix1 + matrix2 to work.
&gt; Buggy? Like the entire java language platform is buggy? Or just applets? Can you share an example of a java bug that caused you grief? I've never had the pleasure of writing applets. Bugs in Java? [Read the list](https://bugs.openjdk.java.net/secure/Dashboard.jspa), try to garner the mean time to a fix and see how widely spread the bugs are in the JDK. That's what I mean. It's not a bad thing, per se, to have bugs, it's also not a bad thing to take a while fixing them. It's only bad to have a lot of bugs that aren't fixed quickly in software that is deployed everywhere.
&gt; They don't have to be debugged together - they just have to have clear interfaces. You can do the same in-process. &gt; Until they don't fit on one machine anymore. Sure, but that's an entirely separate concern. Almost all large software projects are distributed in some way or another. They are also composed of loosely coupled modules, some integrated in-process via APIs, and some over the network. They're still very hard to build, and they're still mostly written in Java. The internet most certainly does not qualify as such a system. It is not specified as one system, and the level of coherence between sub-systems is not as tight as, say, that required in an airport management system, where most subsystems depend on most others.
Where is my elvis operator ?
Not really sure this is a fair test of a performance related 'behind the scenes' recasting I was talking about. I think this test is simply saying that there exists a bug in certain javascript implementations where integer comparisons are not correct (though I'm not sure if the bug is in the spec or in the VM). On my version of chrome Number.MAX_SAFE_INTEGER is defined as 9007199254740991. So it isn't really that surprising that 125893641179230474042701625388361764291 has some integer comparison problems. But that is sort of irrelevant anyway since javascript now has access to things like UInt32Array thanks to the webgl extensions of the spec.
Sarcasm? 
I avoid ORMs on long-term projects, for performance reasons. ORMs deliberately hide the complexity of the database, which means either you'll have some pretty fucked up joins going on, or you have to spend lots of time coaxing the framework into doing something that would take 10 minutes to do in SQL. Writing SQL yourself takes more development time, yes. But if you're spending more than 6 months working on the project, it's an insignificant time increase anyway. For shorter projects, using an ORM might make more tactical sense just to get to market faster. EDIT: in case anyone cares, I've only got about 4 years of experience under my belt, so my perspective may vary. 
A better example would be for objects that contain a array variable. I could define the [ ] to index the object
Using an ORM, IMO means you don't know SQL. We don't use an ORM at our company because our product is over 20 years old, they didn't have ORMs back then. Now there is so much code, it would take probably 6 months to move all of the SQL code to ORM code and the SQL code works and we have more control over the queries being run, so why switch.
Some abstraction layer above ResultSet would be welcome, but I'd generally prefer to avoid ORM. I've been burned many times on larger projects. It's just a leaky abstraction. Avoid if you have larger project. But, having said that, I've recently searched for a reasonable DB access library which would suit my needs. The only one is Hibernate (with Spring Data being far away on the second place). There just isn't anything else that is usable* in the java world :( So I use jdbc when I e.g. have just a single table. Otherwise hibernate because it enables fast development/iterations. But when you use hibernate, then ALWAYS 6-12months later you will swear and ask yourself why did you shot yourself in the foot (been there, done that, multiple times) * - 'usable' has very wide definition for me and means: rasonably: concise, performant, generic, flexible, extensible, no-lock-in, cheap (all the good stuff).
[Meanwhile](https://github.com/dotnet/coreclr/issues/793), .Net enter UNIXes.
Operator overloading allows to extend the meaning of operators beyond what they normally do. For example in Java everyone knows what `1 + 2` does. But what about `new BigDecimal(1) + new BigDecimal(2)` ? Sadly, it does not work in vanilla Java. With operator overloading, you can define what `+` means for two `BigDecimal`s and return the right thing... or something else. That's both the power and main inconvenient of operator overloading.
Used sparingly its wonderful. Even Java uses it for string concat, but just doesnt allow users to use it. 
because it's limited. it does not support all the features of a given database and you need to revert back to sql. because it adds additional magic which sometimes fails in a weird ways. because the magic is sometimes extremely expensive and it's non-explicit. All in all writing sql in the long run does not add much overhead and the other features (besides just the mapping row&lt;-&gt;object) offered by ORM are insufficent in more complex projecta and you need to write your own solutions anyway. But the think you're menitoning about lack of separation between entities and db is plain wrong. Put your db access code in DAOs/repositories. Limit use of ORM or your custom approach to those repositories. Do not let db-related code leak into your entities/domain model.
This is a feature I hate in C++. Seriously, why is ambiguity a good thing? The only time I've wanted operator overloading in java, is for BigInteger/Decimal (and probably other numerical classes). It would be awesome to use in those cases. but other than that? meh. it saves me a few key strokes list.add vs list + , but so what? and then overriding things like = and ==.. yikes.
you could look into something like ibatis I think its called mybatis now
Interesting. Not a lot of documentation on it, but it looks vaguely interesting. 
Would you still use sp's to access everything or would you possibly use more of a query in your DAO level and convert everything to a list of business objects to use? I guess I'm just used to Spring and using Rowmapper. Does anybody use that? Essentially just a List.
Why implement a bad idea?
At first I really liked the look of this tool. As I learn Haskell and Scala, I see Java's verbose-ness more and more, and this tool would have helped me type concise code more often. But I can't use this. Not only is the data collection turned on by default, but when I tried to turn it off in settings, I was not allowed to do so. If you want people to use your tool, don't do stupid shit. This is unacceptable, really.
Same here, we have several projects that date back 10+ years, and the effort to refactor the code for ORM would just not be worth it. 
I've worked on a project that used Hibernate for a complex database. I sympathize with people who don't want to use an ORM, but I'm not sure if I'm ready to say that ORMs are bad. If you do decide to use an ORM for a large growing product, I would suggest: * Think hard about where session open/close boundaries should be. * Think hard about where transaction boundaries should be. * Think hard about what has a small "owning" relationship and should be eagerly fetched, and what else should be lazily fetched. Realize that after your session is closed, lazily fetching is out. * Don't use the OpenSessionInView pattern. It's good for a quick start, but in the long term, it doesn't make any sense. * Don't use the Session-per-operation anti-pattern, where every small tiny database query uses its own session and transaction. * Put all of your object model code in a single project, separate from the rest of your code, with a well defined API for using it. * Always be aware of any changes made to the database. Make sure the database looks exactly how it would look if you designed the database by hand, before your objects. * Never serialize java objects using java serialization and store them in the database as a binary blob. It's really easy with a big team to haphazardly violate these rules and end up with an uncontrollable mess. Want to know the worst case scenario? Where I've worked on a complex database using Hibernate, they fell for the Session-per-operation antipattern. They also didn't know how to use eager fetching and everything was lazy. This meant that 99% of the time when they went to go fetch a related collection, they got a LazyLoadException since the session that loaded up the object was already closed. They didn't know what to do, so they started doing things like calling getters on every lazy relationship to load them before they closed the session. What they eventually did was create 2 versions of every object. One entity, another they called a "POJO" that was just a copy+paste of the original entity. Then they wrote conversion functions between the entity object and the POJO object. Every time they pulled something from the database, they would convert it into a POJO object and do the same pulling and converting for every related entity. They also had to convert from a POJO back to an entity every time they stored an object. Why? I guess because the "POJO" version of the object, they knew, would never give them a LazyLoadException. It was a big giant complicated mess. I've also seen objects that contained collections, which contained collections, which contained collections. They would grow in complexity over time. Then that object needed to be serialized over the network. Then it had to be stored in a file. In the end, we would have been better off just storing JSON. Sometimes you have to make sure the complications of an ORM are even worth it.
God, you can do SQL in an ORM for more complex tasks and do JPQL for simpler ones. You can even provide mapping providers for SQL if you want to use a query. If you know your ORM, there's no reason to go without it. You can do whatever you like to do, and have a lot more flexibility too. The only good excuse I can think of for not using an ORM is that they don't want to learn it. I suppose that would be fair enough, not everyone has to climb to the top of the software-dev pyramid, but please don't act like there are performance reasons, I've been listening to this bullcrap for more than 10 years now. It's really freaking tedious.
I've built some very large websites (millions of requests and millions of dollars). All of them use JavaEE spec to the fullest which usually means an ORM of some type (heck, even .Net Entity Framework is an ORM). Most people don't understand the value of an ORM so they code their own or have a data centric POV as opposed to an application POV (I think SPs are an anti-pattern since it was developed in a different time) or you might not be an agile/scrum/devops shop. 
I think I like your approach better. I guess the downside to this, is with the above library, it automatically works on BigInteger. I think (just looking at your code) yours also allows multiple overrides with different types. so you can have add(CustomClass a, int b) add(CustomClass a, BigInteger b). if so that's pretty neat.
He means Operator Overloading, not Object-Oriented.
I think the number is before tax. If you fulfill the requirements and make less than 60.000$ before tax in the Netherlands then you might be seriously underpaid (depends on the city of course). 
For this country I'm not underpaid. 60k is what a senior or consultant would make.
Until someone overloads the comma operator.
Yeah, but it is going to take a while to enter mainframes, IoT, car infotainment systems, electric control systems, robotics, avionic controls, factory control systems, smart cards, Blu ray players, navy and missile control systems, Soft real-time systems, ... .NET has quite a few design decisions that are better than Java, C# and F# are also great languages, but it has a lot of catch up with Java in terms of deployed platforms.
The important part in my opinion is translating values to and from programming language/database. I'm more than happy to write raw SQL to do what I want. But what gets you is having to map values back and forth. 
&gt; REST isn't very hard. That depends what you do with it. Writing a C4I application for the US Navy is hard. &gt; I think you've got a distorted view of the industry. I don't find that to be remotely true of agile companies. Maybe old line companies - but not innovators. I think you have a distorted view of the industry. The number of Java developers in the world is larger than the entire population of the San Francisco Bay Area. The number of people working in SV startups is less than 1% of the software industry, and none of them are building very important software, like that running power companies or air-traffic control software. Now, I don't know what you consider innovation, but IBM's Watson, probably the most innovative piece of software of the past decade, is written in Java. &gt; massive systems build out of loosely coupled components and they are no harder to build. First, if you think Google Maps -- just a component, right -- is easy to build, then you're not aware of the hundreds of people working on it. And Google Maps is tiny compared to the software running the US Navy. *If* your system is built of loosely-coupled components, *then* it might be easy to build, but many systems aren't and can't be. I have never seen any software built on top of Google Maps that can even be described as a system, let alone massive. They're mostly puny mashups. &gt; then its built wrong. Obviously you've never built an air-traffic control or a C4I system. What do you think? That the idea of building systems from loosely-coupled components was invented in 2005? We've all been preaching it since the 70s (well, I since the early 90s). You should at least once look at actual big software -- manufacturing control, military C4I, power company control, air-traffic control, airport management, central banking etc. -- to appreciate how different it is from something like GMail and Twitter, and how simple and small are those in comparison (both, BTW, are written by "agile" companies -- in Java).
Ibatis is a joke. Hibernate is useful for trivial things but have you ever had the special agony of doing joins using the CriteriaQuery? (17 years as professional Engineer)
Also available in Kotlin with the added benefit that you can reuse your Java code.
Arguably A.add(a,b) is worse, because static methods are less testable. Yeah, yeah you can test it by throwing different values into a + b, but defending it on the basis that you can handle the nulls is like arguing that all your code should be of the form A.method(a,b) rather than a.method(b), which is pretty ludicrous.
MyBatis isn't a joke. It works really well and is a lot les nightmareish than fucking about with CriteriaQuery. It isn't much more than a clean way of organizing your SQL and mapping results to objects. But if you're stuck with Hibernate, then CriteriaQuery and custom result mappers are pretty much the only way you'll ever end up **not** loading your entire fucking object graph :-) 
AOP for managing sessions is the best way to do it in my opinion, it relieves you from writing technical boilerplate crappy code. 
If ORM is the top of your software-dev pyramid, then I dread to think what's at the bottom.
Once you're writing your own queries and mappers, what's the point of having an ORM? I'd much rather use something like JDBI (or dapper in .Net) that's up-front about this in the first place. 
Few keystrokes you say? Some time ago I was implementing simple simulation of quantum tunnelling in Java and the implementation looked like this: http://imgur.com/jrRCSeG A debugging of these equations was a big pain in the ass.
I've generally found ORMs to be very leaky abstractions, objects and relations are different animals, and trying to mechanically map between them always leaves something to be desired. I may be biased since I tend to do more analytical work than CRUD, but there are other ways of making CRUD easier than trying to map an entire relational schema to an object model. JDBI and Jooq come to mind.
Because it's not one or the other. Overwhelmingly, I want to do both complex queries for performance and then map them to entities and also do simple ones, where I'm looking for a list along an index. Having an ORM caters for both of these scenarios, other, SQL frameworks just help with queries. 
Please show me an example of this. This is the exception, not the rule.
The same can be said about nearly any piece of technology. Knowing how to use an ORM implementation doesn't put you higher up on any pyramid. The only thing it says about you is that you know how to use an ORM. How many engineers don't understand ORM is entirely beside the point. There are many amazing engineers that don't know many things. If you think software engineering is a pyramid, then you're doing it wrong. 
this is what I have noticed, having to deal with XML crap is quite annoying. I miss coding with Java SE it was way more coding, now it's all the time dealing with XML
This is an example where "self-commenting code" could still use comments.
I was about to come say this same thing. If I need the performance I can extend a repo and write the actual queries. Otherwise I'm just going to use the ORM (currently really liking spring data).
&gt; Using an ORM, IMO means you don't know SQL WTF? This is the kind of elitist mindset of a shitty developer. You use tools to make your job easier. Let me ask, do you also do all your development in vi?
It's not worth the architectural compromises. Make lambdas integral to yout API and not a bolt on when you go to Java 8. If anything, make it Java 8 and *then* backport to Java 7 and make them use interfaces and anonymous inner classes. 
Java 7 is already EOL. 'Nuff said.
Comments would not help much here. AFAIR the problem was with the parentheses. Me or eclipse put one in a wrong place.
Care to explain why static methods are less testable?
vi is for people who aren't competent enough to dev in ed
How is a pure function less testable ? Every single functional programming language would beg to differ.
&gt; Writing a C4I application for the US Navy is hard. Yeah, and that represents what percentage of software development worldwide? BTW, you know you're [not allowed to control nuclear reactors](http://www.oracle.com/technetwork/java/javase/downloads/jdk-6u21-license-159167.txt) with java, right? ;-) So no submarine installs. &gt; if you think Google Maps -- just a component, right -- is easy to build Its easy to use - from any language you like. And a huge amount of mapping software is written in python these days - python OWNS the GIS world. FWIW, there's an open source version of Google Maps known as [mapserver](http://mapserver.org/) (written in C for performance - but you can see just how hard it is to do a google maps clone). The real point you're missing is that services can be written in any language you like and it is MUCH easier to write small simple services than large monolithic systems. &gt;the software running the US Navy wacky niche on one level (real time command and control of ships n planes and I doubt that stuff is written in Java - [last I looked it was low level C/C++](http://www.dodccrp.org/events/9th_ICCRTS/papers/169.pdf)) but on another level (administration and logistics), SOA makes the most sense by far. &gt;Obviously you've never built an air-traffic control or a C4I system. No, but I built telephone service order management, work dispatch, trouble ticket and provisioning systems all during the entire 90s - in Smalltalk and C++ mostly. Not so different. And I did systems for managing the manufacture of the Titan missile series (up to the IV) for MM. I know big software and I still fervently believe monolithic systems are too hard to build and vastly more fragile. I also worked at the Big River Book company - arguably the largest application on the web. That is completely built using SOA in a variety of languages, as is the systems at AWS that probably host most of your stuff these days - all written in a variety of small, easy to manage services in a variety of languages. Sorry - monolithic system development makes zero sense these days. It doesn't scale on a development level or a deployment level.
Instead of Java look into Prolog.
https://github.com/aima-java/aima-java
What do you mean by "monolithic"? No one has been building monolithic systems for a couple of decades, now (the way I understand the word). Do you mean distributed? Because most large systems have been distributed for ages, too. Do you mean each module is distributed? That's a (valid) decision that's mostly taken for fault-tolerance/ops considerations -- it doesn't make creating the system any easier. Anyway, suppose people decide they're going to write the next power-plant control system as microservices. Still, there's probably 4MLOC of essential complexity there, and assuming the split-up into services will not add *huge* overhead, we're looking at, say 5MLOC. Not huge, but not shabby either. Why do you think people would pick a language other than Java to write those, say, 500 micro-services? Why do you think they'll decide to split the codebase (which still has to be maintained by the same 100-developer team) among different languages? Sure, there might be a couple of other languages -- say, Python -- in there for the more scripty parts, but by and large, the whole thing is going to be written in a single language, and currently, there isn't any other mature, stable and maintainable language around. &gt; Yeah, and that represents what percentage of software development worldwide? Probably larger than SV startups. Just to give you a sense of how small a minority SV startups are, IBM, Oracle and SAP combined employ more people than Google, Facebook, Twitter and LinkedIn combined, ten times over (and I'm counting Google as a "startup" here). &gt;real time command and control of ships n planes and I doubt that stuff is written in Java A lot of (almost all) the new stuff is Java (and what isn't, is usually Ada). I'm not talking about hard-realtime embedded stuff (though Boeing uses Java for some hard realtime avionics, too), but about the large, C4I systems.
Just because some don't favor ORMs, it doesn't mean that they (we) don't implement a clever db layer to separate data source logic in a clean and OO fashion. From my experience, granular control over database implementation only takes a fraction longer in the grand scheme, but yields the benefits of added performance and better maintainability. SQL views and stored procedures, if implemented correctly, can totally replace an ORM if you have good engineers. Also, ORMs can become a big time and performance sink if you don't use them strategically Cons: Using hard-coded SQL makes it a bit tougher to switch dbms platforms without extensive modification of your code. If you think you may change your dbms in the future, you can use a query language (or micro ORM) which are essentially libraries which map Java code mapped to an agnostic SQL (so you don't need to write queries directly in your code)
Looking for developers to contribute, create examples and work on a large open source simulation or game (PM me for more info)!
i understand why he doesnt. hibernate introduces another layer that can be extremely confusing for newer devs and maddening for dbas. a simple function using reflection can map his resultset columns to any java object. i would shrug and find something else to learn. hibernate is only essential to your career if you plan to be a boring government java webapp drone.
&gt;&gt;What do you mean by "monolithic"? you said earlier &gt; why do people seem to think that serialized communication over a wire is somehow easier to compose than typesafe integration via simple Java APIs Which sounds to me you're building really big programs all hard linked into single executables. Regardless - when you're growing an organization organically, services are key to flexibility. Amazon.com is built that way and is larger and more complicated than any power plant control system with equivalent reliability requirements. &gt;Why do you think people would pick a language other than Java to write those, say, 500 micro-services? Because Java has a certain level of developer overhead and is less generally flexible and productive than languages like ruby, python, PHP and others where you can throw a highly capable service with a ton of features up in a couple hours and the reliability and scalability is every bit as good on modern deployment architectures. IOW, Java takes more man hours per feature to build than more agile languages. You seem to like denigrating "SV Startups". I don't work for one. I do, however, work for smaller, scrappy companies with lower budgets that are using their greater agility to take business away from larger, older companies. We can't all hold a gun to the taxpayers of America to pay for our software projects - some of us need to bootstrap our way into profits on a shoestring. But I did work for the company that just posted $5 billion in profits from providing highly agile hosting infrastructure that almost certainly your clients are using and while I used to think like you - I don't anymore because I've seen the astonishing scale and flexibility a good SOA architecture can provide. Best tool for the job is a better policy than declaring everything a nail and sticking with your hammer.
I never heard of it. Is it a crash course? Is it for beginners only?
Www.maxtrain.com this is the site for the training center, they do other specialized classes I just happen to be doing the Java apprenticeship course. This place is just here in my area I'm sure there are more near any big city that offer similar courses. 
Hi being obtuse here but a couple of errors while trying to run this in eclipse using java 1.8 version 45 jdk. These imports are not resolved import com.sun.source.util.TaskEvent and the maven clean package results in Caused by: java.lang.IllegalArgumentException: invalid target release: 1.8 at com.sun.tools.javac.main.RecognizedOptions$GrumpyHelper.error(RecognizedOptions.java:88) at com.sun.tools.javac.main.RecognizedOptions$10.process(RecognizedOptions.java:359) at com.sun.tools.javac.api.JavacTool.processOptions(JavacTool.java:242) at com.sun.tools.javac.api.JavacTool.getTask(JavacTool.java:199) at com.sun.tools.javac.api.JavacTool.getTask(JavacTool.java:68) Any suggestions?
Maybe I am missing something, but it appears that the last listing only serves to be able to write .collect(toAddStatementsRequest()) instead of .collect(collectingAndThen(toList(), AddStatementRequest::new)) Sure, it's slightly shorter, but now I must look at a helper method and an abstract class to understand what it does. 
Thank you. 
More people want jobs, and that is where they are. If the jobs were in Minnesota people would go there, and the prices would behave the same. Crappy views, snow, and all. 
Bullshit. So, New York City and Boston are beautiful places with wonderful weather? I've never heard anyone mention that they want to move to NYC because Staten Island is beautiful this time of year. I bet that Detroit, Milwaukee, Cleveland, and Pittsburgh must have been go to paradise destinations in the earlier parts of the 1900's. Those cities that are now Rust Belt shit holes, were all places people moved to in huge numbers at one time, and they moved there not because they were nice places with beautiful views that people wanted to live near, but because that was where the jobs were. The companies that started Silicon Valley in the 60's and 70's chose that location for a couple of factors, and the people flocked there for the jobs. The fact that it was a pretty place was immaterial to the fact that it was where the good paying skilled jobs were. 
Internet Explorer 12... I mean Spartan... enterprises will balk at this and pretty much say... No, I'm N-1 for our browser needs or go to Citrix to publish Internet Explorer... Oh wait... our Citrix plugin... This is a cluster waiting to happen. So a lot of shops will stay on IE11 until 2020 and 2023 for Windows 7 and Windows 8.1/Server2012R2 with IE11 support. I can also see Windows 10 will ship with IE11 installed with the option to upgrade to Spartan later for enterprises to adopt Windows 10 or have IE11 installed and Spartan installed like IE/Chrome having two options.
Yeah, [Text messengers](https://github.com/Ellzord/JALSE-Messengers), [Cows in a field](https://github.com/Ellzord/JALSE-HappyCows) and [Pong](https://github.com/Ellzord/JALSE-Pong). There is a full [wiki](https://github.com/Ellzord/JALSE/wiki) for learning how to use it.
&gt; I'm starting to really lean towards reddit being a haven for green devs that have no idea what they're talking about. I've noticed this across most of my subscribed programming related subs. Eh, I spent the last 2 years working on a Hibernate project, and your post sounds a lot like that to me. Let's see if I can remember the various issues: 1\. Was working on a legacy db, and Hibernate will screw you over if it turns out your unique primary key isn't actually unique. It will silently and with no error message return completely bad data. 2\. 3 different programmers were able to get a composite key working on an older project, but no on our newer project. Hibernate doesn't like composite keys. I'm personally not a huge fan, but it was a legacy db we had to interact with. 3\. Often had to duplicate code twice. Like I wanted a search to sort it's results, had to add the order by in both the original query, and on the property to get all of it sorted. And you want to run the same query later with different sorting? Well now that annotation on the property is a problem. 4\. If your annotations on your objects get messed up, like in a merge, Hibernate loops endlessly and gives you no idea where it happened. This is completely unacceptable. 5\. If your queries got big and there were issues, you have no ability to trace into them when using AOP. We kept getting a message about some id being set twice (not by us though, by the internal hibernate code). We finally hacked around that by making the query read-only, then we got other new, different errors on other queries. 6\. The legacy program we were converting ran "like" queries with wildcards on all search fields including numbers. Hibernate's Criteria api (that we were using for searches) is incapable of handling "like" queries on anything other than String values (ClassCastException). There were probably some more in there to. At the end of the day, Hibernate doesn't do anything you couldn't do by hand. Then the purpose of using Hibernate is to make things faster, easier, etc, but instead it make them slower, harder, and sometimes impossible instead. It was faster and easier to write sql queries by hand, than it was to use hibernate. And we didn't even get into performance tuning, which also ended up being a problem. But we didn't even get to that point. 
ORM's are hard to debug, and hard to maintain. I worked on Hibernate for the last 2 years, and I got fed up with something and just wrote the sql directly - I cannot tell you how much of a relief it is to just write something and have it work, rather than going through the mess that is hibernate.
Pretty much everything you describe here are Hibernate/JPA specific problems and not fundamental ORM problems.
Most of the problems sound like you and your teams mistake. I've never had problems with composite keys. I don't even get what you mean by you're not a huge fan, composite keys are very powerful when used proudly and are often a necessity in certain databases. If you need to order by you can do it in hql with named queries... Same exact thing as writing your own queries. If you need to trace your queries you can always turn on query logging but I've never had this problem so there may even be an easier way. 2 years working on hibernate isn't much. It also sounds like the project you're working on was poorly designed.
If you don't like hibernate try spring jpa.
I've picked up a couple extra books like clean coding and head first Java to try and attack it from different angles. It's a challenge but I knew that before I started. 
Yes there are! I stared freelancing this year and in the beginning I did only Java (2-3 projects). Currently I'm involved in some long-term JavaScript projects. I'm not exactly sure what do you mean by workflow, but for smaller project I usually do a proof-of-concept, for larger applications I provide a couple of diagrams like (use-case, sequential, etc.) I like to communicate with my clients often, just to make sure we are on the same page. I prefer audio calls over emails for general topics and emails for discussing the technical details. 
General unrestricted overloading may be problematic, but little wrong with limited and restricted overloading.
Links contain beautiful Java code as well.
AWS, Azure or Google Cloud....and wrap it into your existing offerings. Figuring out pricing for it can be interesting but well worth it in the end.
You mean like contracting? That's everywhere.
Yes, so far they already had some setup. The project I'm currently working on is the first which will require some form of setup, probably AWS. In general, as long as you get paid and you think you can/want to do it, there is nothing to fear!
Play framework + Heroku
Because objects are usually not just strings or numbers. Usually, you have to look up in your api to resolve the ambiguity that comes with "adding" complex objects - in which case you mid as well just resolve it with a proper method name.
yes (grails). Focus on solving particular problems vs just renting out your skills. If you're renting out your skills, people will want skills that fit in to whatever they already have. For web stuff, that will often be PHP or something else. 
I made that rate in my **1st** job, just out of college, 10 years ago or so. There's a hilariously absurd rate for someone with 6+ years of experience.
Java web-dev is so common, it's difficult to find a Java-job that's NOT web-development. As one who hates web-dev, and primarily Java, FML. As far as freelancing/contracting, yes, there are many opportunities out there. Can't tell you how to find them, but freelancing is running your own business. You'll have to work on your marketing and general business skillsets if you want to be successful.
I integrate JOOQ with Spring and use spring's transaction annotations to create longer running transactions around operations.
I could have told you that before java had generics. Breaking backcompat is not done under any circumstances barring security vulnerabilities with available exploits.
Value types are going to change java much more than many people have on the radar. What I find kind of disturbing is that they haven't yet figured out how to handle off-heap/unsafe memory primitives, which are nonnegotiable when doing high performance work, yet the current unofficial sun.misc.Unsafe hack will no longer work once jigsaw lands.
&gt; Not even with plugins? I'm using the Community Editin with almost no plugin (bitbucket). Which plugins do you find the most useful/can you recommend?
There are more high perf java folks than you give credit for. Apart from that, your comment is spot on - combined with the recent escape analysis improvements, the convenience of creating a lot of short lived objects will be much more common, because those now live on the stack, so they're dirt cheap.
The excuses where you try to change the subject to making claims about the design of the app, when the problem is that Hibernate would not do a basic task like using a composite key. Look how many times you try to blame a design I barely even mentioned for Hibernate being poor at doing what it claims it can do.
If you're going to do freelancing it's more of a question what's in vogue in your area. Often the customer has a system already and wants you to enhance it. Anyway, if you're going to randomly shout terms I'd like to shout JSF + Java EE ;)
I do not agree that it implies that you do not know SQL, but I do agree that it means that you do not take complete ownership of your software if you rely on an ORM for your data. You can google "leaky abstraction layer joel on software" if you want to read what is generally considered the canonical treatise on making these sorts of decisions. I know you will not like the answer because I have seen what you have written in other parts of this post, but it might help you understand why many disagree with you. And why many of us favor using libraries like JDBI, etc. over super bloated frameworks like hibernate and Spring.
If the + operator and friends would be overloaded ONLY for the Number interface, then it should all just work.
Any time you spend learning the Spring Framework and its sibling projects will be richly rewarded. 
At my company, Eclipse is the most commonly used IDE followed by IntelliJ. For testing, I've been using primarily TestNG.
What somewhat niche language are you talking about? Some relatively low profile language are in great demand (Scala, for instance). Anyway, learning a new language is almost always a good thing, it'll expose you more concepts. Java doesn't give you the most varied of experiences there, especially before Java 8, but even then. 
Do you have any recommendations on how to find work like that? Any job sites in particular?
As an aside, make sure you get a contract signed by your client and yourself before you start any work.
Don't think you're going to get anyone to help you out with questions that look like they came off a take home test dude... Just study up on the concepts and know them, you'll get the answer and with much better comprehension than someone just telling you straight up. There's no shortcuts in this field, take it from someone that's been there.
Yes: spring boot + postgresql.
I work at a small company, we use Eclipse as our IDE. You will be using a versioning system (we use git), so get to know how to use those. I used to use git to store all my homework, and I'm glad I got the experience with it. I would suggest getting to know Javadoc or Doxygen if you don't already. I never used it in school, and we just started using it at work, and it is seriously awesome. Honestly, I've never looked at IntelliJ, because I learned on Eclipse too, and its pretty sweet.
I use Spring JDBC and pretty much using Objects to communicate. Even for large projects, I find Hibernate to create a lot of problems rather than solving one. In the time, where requirements change very often, implementing an ORM framework is just an added complexity. Before you blame me, I am an Project Lead with 7+ years of experience in Spring, 6+ in Hibernate, 4+ in Grails. I worked in various Products, Services using Spring/Grails MySQL/Oracle/Postgresql. Almost 75% of projects which use ORM f/w's, get bottlenecks sooner or later and we had to do some alternate to fix it. One more thing is, ORMs doesn't offer much in terms of performance too! I was quite surprised to see it in hard way. ORMs are just an added complexity and layer and we are sacrificing performance/time for simple not wanting to write some SQL queries! According to me, use ORM only if you are sure you know that it will fit exactly your needs. Else, don't even bother to look at ORMs.
Also learn Maven for building projects. Learn to follow the conventions and you'll be able to pick up projects that use it much more quickly. 
I can recommend Play + Heroku too. Be warned, if you are getting into complex models/off the beaten path requests (such as client wanting to edit DB through Excel speadsheets... meaning Excel =&gt; CSV =&gt; Finding some way convert to YAML), also the SnakeYaml parser that comes with play does not allow for data with characters NON-UTF-8 or UTF-16 which becomes a problem when trying to create a 'CMS' experience. I enjoyed working with it, but make sure you cover your bases. 
Head first makes perfect sense to read while on/ before starting your course. However imo I would hold off on reading clean coding till after your course has finished. Reason being that as it is a short, intensive course, you should be focusing your attention on the material at hand and really understanding it while you have the tutors available to clarify things for you. Clean Code is a bit ahead of where you are atm. Please do still make the time to read it as you will learn a lot from it, but probably best to be deep into understanding and learning Java until you have finished your course and got your hands dirty making projects. Then read CC, and use those projects as something to apply the things you have learned to :)
It's there, but maybe not suitable to some works. In my experience, sometimes Rails/Express.js becomes better choice for heavy UI project where you need to prototype fast.
&gt; But $3k? Windows+OS X+Linux actually starts from $7.5K, and there is also the more expensive Enterprise Edition, but: If your project is genuinely non-commercial and publicly available (not necessarily open source), you can get a free license: http://www.excelsiorjet.com/free Otherwise, check out the Charity Bundles (start from $10): http://www.excelsiorjet.com/charity &gt; This capability ought to be part of the standard tool set. Not so long ago, Oracle started mentioning AOT in its longer term plans for Java. You know, after a big boring safe harbor statement.
I have tons of fun with JME3, just as a hobby. One time I made it run with groovy scripts as a method of populating the scene graph and attaching behavior to it. I also one time let Scala handle the methods that the groovy scripts were calling. A lot of people would consider this combination unholy, but it was quite funny that it worked. (this wasn't in JME3, but with Slick2D)
I think what you are looking for is [Spring pet clinic](https://github.com/spring-projects/spring-petclinic/). It is Spring showcase project that is great for learning. Read more about pet clinic [here](http://docs.spring.io/docs/petclinic.html).
Find a field that interests you, data structures, algorithms, AI, data analysis surely there will be something of interest here. You could have a look at http://www.reddit.com/r/dailyprogrammer which has problems for you to solve and some of them are quite involved. 
Most likely the same OP that posted [this](http://www.reddit.com/r/java/comments/33kwin/how_to_write_out_png_images_in_java/) a few days ago.
Jackson, purely because it's what I'm more familiar with. If I had to use gson instead I'd be completely ok with that; they're both very good libraries
It somewhat depends on the use case. Jackson can do streaming (de)serialization and gson does document level. If you are pushing large docs, Jackson performs better. Smaller docs and gson is better.
Nice, any other?
The head first has definitely helped break things down to help get a better grasp in unison with the course book. I agree though that clean code is directed at someone who probably has some experience already. Thanks for the advice. 
The gson api is better and its extremely simple to use.
No problem. Feel free to send me any other questions you may have. Despite being in the industry for a few years now I still vividly remember being where you were, although I was a Baker, not a Chef. Kitchen workers union - we stick together :D
&gt; BigInteger.valueOf(b).multiply(BigInteger.valueOf(n).multiply(x0)).add(BigInteger.valueOf(a).multiply(BigInteger.valueOf(m).multiply(y0))).mod(BigInteger.valueOf(n*m)) Or you would read CleanCode and end up with something like this: doMyVeryImportantCalculation(VeryImportantParameterObject parameters)
I hoped this was what Java 8's [CompletableFuture](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html) would be, but talk about a mess of an API. Good luck implementing all those methods. It is possible that with a few abstract classes it isn't so bad, but man was I disappointed at the seemingly useless complexity. Edit: Interesting [blog post](http://www.nurkiewicz.com/2014/11/converting-between-completablefuture.html) about converting between Observable and CompletableFuture.
I still hate being that guy. Your work is amazing, and I'm glad you did it instead of 'doing your homework', because: a) different approach b) maybe with enough people trying to force operator overloading in Java, Oracle will listen. Anyway, I'm not a total fan of operator overloading as a general thing, but I think Big[Decimal/Integer] must have it. Also, I'm not skillful enough to do what you did, so have my respects. 
If you don't mind, how did you transition from baker to developer and what was your experience from that. After years of sink or swim mentality my instincts are giving me a lot of anxiety for what it will be like after the program ends. 
For smaller jobs I prefer to use minidevs JSON smart library because it's faster than the two mentioned here. I really like the annotation based parsing used by Jackson, it makes it easy represent json objects as data POJOs. I love GSON and I would put it in between Smart (fast and "bare metal") and Jackson (heavyweight and feature filled), the APIs are very sensible and play nicely stylistically with Guava. 
Ditto. Makes it really easy to create Java REST clients as well, if needed, since you can share the same client object. Also integrates easily with Joda Time. 
Exactly what I came here to say ;) In my team, whenever introducing a foreign library in our project, we expose it through library-neutral adapters and facades. Helps us sleep at night, instead of biting our nails, constantly worrying if we chose right and if the library will be maintained long term.
Don't know any other. This should be enough for learning purposes. I sugest you to make a small spring mvc application. My first one was contact book app. I learnead a ton. 
As another option to add to the list: Jackson was quite literally the hotspot in one of my performance-sensitive apps until I swapped it out for Boon, at which point JSON handling essentially disappeared from my profiler results. Boon's dev seems to pretty regularly (when last I was checking back on it frequently, at least) bench the library against all comers and was/is always tuning it to keep it well out in front. I'm surprised Boon gets mentioned as infrequently as it does. (From what I read, Boon is also now Groovy's JSON parser, though I've not used it that way so I can't speak to it in that context.)
How would you define a large or small doc?
I wouldn't. I would benchmark it to see which one best suited my needs.
&gt; Also integrates easily with Joda Time. could you elaborate on that? I wrote a simple REST Webservice this weekend (just to play around) and used Joda Time and have all that joda stuff in my JSON. I changed my get method to return String and return the date as a String, but if I write a client and try to post a ressource I get an Error regarding Joda and that field. 
Agree completely. In fact, I had to dig into my code to see which one we were actually using at the moment on the project I'm working on. FWIW it's Jackson.
Don't forget [Genson](http://owlike.github.io/genson/).
better as in faster?
it's painful to use. if you need it (and you'll know when you do) then sure. otherwise, why bother? and other libraries appeared that claim/are faster than those. One library that i used lately from Java and C++ was msgpack. Really easy to use in both languages, is quite fast.
I think part of the cause of that trend is not dealing with db teams (at least in larger organizations I've seen)
&gt; extremely simple to use. wat GSON is far from lightweight/simple to use for what it does.
Knowing what topics are covered will at least allow you to look them up when you might need them, doesn't mean you actually need to study every detail about them. It will also help you understand the need/purpose for some of the popular frameworks out there. So if you have time, reading it and grasping some concepts will make your baggage a little bigger and that's always useful if you ask me.
You don't really have to mess around with the adapters or anything else in Gson apart from the two methods unless you want to customize how it serializes and deserializes certain objects. The (probably) ```org.json``` library is fine if you don't want actual objects and are fine calling ```getString(String)```, ```getInt(String)```, and ```getBoolean(String)``` everywhere.
Just use JSON or YAML and your operations folks won't hate you when they need to change a config and they only know Python/Ruby/Perl and don't want to learn a special API for dealing with your configuration language du'jour. 
How are you running your JEE application? 
I have a super small web app, with ejb, mysql, jpa, jsf and glassfish. Everything was working when suddenly I get always thiss error: cannot Deploy com.javaEE-integration deploy is failing=Application with name [......] is not deployed I have googled read SO there's not much info on that problem. Now it's not running, there are no warnings nor error messages in my project. I tried cleaning project, restarting server, uninstall and re installing server, everything and nothing works.
&gt; Everything was working when suddenly I get always thiss error Guessing you mean your application was getting deployed without a hitch till some point. Did you add any module/dependency after that *point* ? If so, try to revert that step and check if the application is successfully being deployed. Most probably this seems like some configuration problem within your project. 
see response to /u/TRY_LSD EDIT: for the lazy http://www.reddit.com/r/java/comments/340m5q/best_java_json_parser_gson_or_jackson/cqqdhr6
I'm pretty sure someone will give you this advice in the future, so let me be the first. Unless what you did is just the basic part of your software, the testing (and specially unit testing) phase should happen along with development. QAing at the end of the process will make things harder, such as having to change a lot on the architecture side, which will lead to even more tests and more fixes. It's pretty risky, so that's not a very good idea :P Otherwise, if that's not the case, well, ok, move on and here are the things I have worked with: - JUnit for unit testing - TestNG - Selenium for Test automation in web browsers - Takipi - Jenkins is a powerful tool that can give you nice graphs, showing your code coverage when used with a couple of plugins and making sure you keep delivering stable releases if you code your tests the right way :) I hope I was of some help.
Ah! I know what you mean. I think I miscommunicated a bit. I've thoroughly tested my code with Junits. I'm taking the mentioned steps so that if one day someone wants to do an *audit* of my work, I'll have something more formal to present.
Seems like over-engineering to me but maybe your projects switch up serialization technologies frequently.
Anyone still use org.json? Seems to be the favourite JSON parser of everywhere I've worked, although I prefer Jackson.
Not a fan of Boot, Archaius, Commons Configuration, etc.? One thing that jumps out is YAML support.
&gt; Is there anyway I can test them locally, connecting to mysql and all but without having to deal with a server? Your question is like "can i drive a car without having to deal with wheels rolling and the motor running.". You're writing a JavaEE application *that runs on a AS* – no it's not possible to run that application without having the server running. Its an integral part of a JavaEE application.
Then you have to deal with turning your objects into maps.... That's a pain in the ass GSON will just turn standard java objects into JSON, no extra code required. 
If you can abandon json. Proto bufs and captain proto are about as fast as you can get. Barring that, there are several non-json serializers for java that are wicked fast.
I honestly had no idea how great it was until I read this thread. So much wasted boilerplate...
Exactly. If everything was working and now it isn't, something will have been changed either on the app server/required external systems, or the application itself. The stack trace will almost certainly contain the underlying cause, albeit a potentially cryptic message - you should still be aware enough of your changes to know what it's on about though, even if it doesn't necessarily spell out how to fix it.
Try to explain your code better through the article. 
I use Gson because it's much faster _at starting up_. I have code which needs to spin up a JSON parser to produce a web page, and can't readily keep one running as a servlet. This would also be a consideration for mobile app developers.
I watched this recently. Though I already knew most of the content, I have to say that it is still very interesting and it is definitely very useful to beginners who want to learn how to build web apps with Spring. So content-wise I think you did a fantastic job. I suppose your presentation could be a bit more interesting :) but we are programmers and not media entertainers. 
&gt; Be aware that you are paying a fixed cost up front to eliminate a future risk. I am aware ;) Think about it like wearing a seat belt while driving. &gt; Sometimes I worry that we as developers are so afraid of risk that we cannot estimate, that we will go to extremes to eliminate it. I think calling writing a simple facade "an extreme" is unwarranted. It's typically not a lot of work &amp; often even saves time: instead of spending hours researching library choices, you pick one, write a facade and move on. Good architecture helps you to "skip" hard choices until later when you know more so they become easy choices.
I've used JPA2 via EclipseLink, and in retrospect I wish I hadn't. Just getting it up and running is an exercise in annoyance, what with needing to configure custom annotation processors into your IDE. The [query code](http://www.ibm.com/developerworks/library/j-typesafejpa/) for typesafe queries is horrific, and if you're not going to go with typesafe queries you might as well just be using SQL. Error handling is also horrible. Trivial problems like a bad password result in repeated pointless retries and pages and pages of backtrace, and sometimes security lockouts from the repeated login attempts. It's also really tough to take an existing database and work out how to persuade JPA2 to work with it, and generally I'm dealing with other people's preexisting databases. My feeling is: If you have a bunch of objects in Java, and you just need a way to store them in a database and fetch them back with reasonable performance, and you don't care what the database structure looks like, an ORM is an OK solution. Otherwise, it's just adding complexity.
The majority of the time I find I don't change the underlying frameworks and libraries of my app. Hiding everything behind my own interfaces and objects would arguably waste more time then fixing the project when I changed a dependency/version.
Ah, but [IBM Java 7 is supported until 2019](http://www.ibm.com/developerworks/java/jdk/lifecycle/).
Oops, hit the wrong reply button. Only issue I have with pet clinic is it's outdated. XML configuration, Maven, JSP/JSTL, JDBC, broken unit tests (commented out because they no longer work), a complete lack of NoSQL, no Boot, no Servlet 3.0+ initializers, etc. Please don't get me wrong, not saying it's *bad*, it just isn't *modern* for Spring. More modern examples typically use Gradle, Boot, Java configuration, Servlet 3 initializer and an embedded server. I will say this, pet clinic is great because there's far less magic than Boot, but Boot is documented well enough these days I can't not recommend it.
What you find in the *corporate world* is anything and everything, it varies from team to team. **Most Spring projects have recent examples and tutorials on their project page.** At this point I would highly recommend starting with Spring Boot and going from there. There are also great videos on the Spring Developer Youtube channel that have some samples that are reasonably complex with common architectures. Spring Boot with Spring Data and Spring HATEOAS is a great place to start if you're interested in REST services.
Personally, I use a custom JSON serlializer and deserializer, and then annotate corresponding Joda Time fields in my pojos. The serializing helpers make it easy to convert to a predefined json datetime format and parse a variety of client-side formats. 
If it's just unmarshaling you're after, my company has just open-sourced an extension to Jackson that makes unmarshaing complex JSON graphs easy. It adds annotation based restructuring of JSON into different POJO configurations using JsonPath as well as Jackson. We find it invaluable and our clients are extremely happy with it. https://github.com/elasticpath/json-unmarshaller
No thanks. Take your spam elsewhere.
Yay another spammer \o/ Haven't had much luck when you tried [the last time](http://www.reddit.com/r/java/comments/2mur4n/get_this_amazing_50_course_learn_java_with/)? Or [that other time](http://www.reddit.com/r/facebook/comments/2ua7sf/facebook_application_development_course_50_off/)? ^(^for ^deletion ^protection: ^was ^posted ^by ^"karimbaidar")
I use Jackson because its typically better supported by server-side frameworks, whereas Gson is more popular on Android. I use [jsonschema2pojo](http://www.jsonschema2pojo.org) to code generate so it doesn't really matter as its a plumbing detail that can easily be changed.
Yes. You customize when there's an edge case that most people aren't going to experience and Google doesn't feel the need to implement a solution for.
I think the Java 7 API still matters...See Binary, Souce, Behavioral, compatibility, etc. http://www.oracle.com/technetwork/java/javase/8-compatibility-guide-2156366.html
I'm also looking at an android sideproject and wonder if there is a concrete benefit to gson. Jackson still looks like it performs better on every result I can find.
Can't really think of anything publicly, but there's a bunch of enterprise apps out there written in Java to handle some pretty crazy stuff like trading and financial data. A lot of web applications are written in Java too, though you wouldn't be able to tell when using it.
Amusing to hear that Glassfish hasn't improved an iota since I last worked with it...
Well... I think there is value to taking the Java 7 cert then when ready... Take the upgrade exam... and certificated for both Java 7 and Java 8. Resumes searches, someone may need support for Java 7 and Java 8. Does it cost more... Yes... http://education.oracle.com/pls/web_prod-plq-dad/db_pages.getpage?page_id=653&amp;get_params=p_id:333
The 2 basic types of xml parsers are SAX and DOM. I'd suggest reading up on them and choosing one that meets your needs
just out of curiosity what do you work in now? android dev? spring? something related to JVM?
The Mars Rovers http://java.sys-con.com/node/39220 It's actually used in quite a few robotic areas https://youtu.be/B5EhaFSo8W0 https://www.youtube.com/watch?v=xH1yUXd9krU NYSE http://www.computerworld.com/article/2567440/app-development/ibm-builds-java-system-for-nyse.html Twitter http://readwrite.com/2011/07/06/twitter-java-scala LinkedIn http://blog.linkedin.com/2008/06/24/linkedin-is-99-java-but-100-mac/ Amazon http://highscalability.com/amazon-architecture 
And don't forget Eclipse, IntelliJ IDEA and Netbeans are all written in Java too.
The certifications are cumulative and built a top of the different language features. Taking and passing the 8 certification will also verify you understand 7 features. Feel free to take both, but it is not necessary IMHO. Better to take the Java 8 Programmer I and then Java 8 Programmer II certifications
YAGNI
Absolutely. You don't want to be dependent on your main competitor to decide what platforms you can deploy on.
This is doable, but Jetty isn't really an EE container. It's a bit of work to plug-in libraries for all the JSR's he's using. Even then there may be some edge-cases with functionality not being 100% compatible with an EE server (speaking from experience using Weld in Tomcat). TomEE is a full stack solution, and I believe you can embed it, so that's probably what I'd try.
&gt; This is doable, but Jetty isn't really an EE container. He doesn't like his current problem so I'm giving him a new one! &gt; TomEE is a full stack solution, and I believe you can embed it, so that's probably what I'd try. This sounds like a good tree to bark up. Sincerely, Richard Nixon 
Blu-ray DVD players run JavaME and almost all cell phones (including iPhone) run JavaCard in the SIM card. Nearly all Android and Blackberry apps are in Java. Most cheap feature phone apps run on JavaME (or least they used to).
[This game is made in pure Java 2D](http://www.scarypixel.com/). Here is an [old trailer](https://www.youtube.com/watch?v=1f9mQoSk_vc) for it so you can see it in action.
* Google: Gmail, Google+ (using simple servlet backend: http://highscalability.com/blog/2011/7/12/google-is-built-using-tools-you-can-use-too-closure-java-ser.html), and many more. * Evernote: Tomcat, hibernate, mysql, GWT, stripes (https://blog.evernote.com/tech/2011/05/17/architectural-digest/) * Linkedin * Twitter (replacing some Rails backend with Java and Scala) * Amazon * eBay * Almost every single banking and investment server side app. Most google apps are basically java for the following reason: https://www.quora.com/Why-does-Google-prefer-the-Java-stack-for-its-products-instead-of-Python
Maybe you should discover Dropwizard and then you would not need to worry whether that server or another has better or worse integration with some IDE. Dropwizard works great with any IDE, it's just plain Java without any of the EE magic and complexity: http://www.dropwizard.io/ 
&gt; OpenOffice OpenOffice is mostly C++. Only the database application and some minor wizards use Java. [source](http://www.openoffice.org/download/common/java.html)
[DbVisualizer](http://www.dbvis.com) is an awesome example of a Java application.
No, I just use it in production every day. And no one *works* for Dropwizard...it's an OSS project. It's just sad to see folks struggle with the same issues I had X years ago...still stuck in the legacy land with WARs, servlet containers, IDE plugins, etc. All I need is IntelliJ base community edition.
cool but all that yaml stuff seems discouraging. maybe I'll try it when feeling more comfortable
Sure. Mountains of XML in servlet containers config (e.g. adding a DB connection pool) is so much easier. :-)
Very useful
oh man xml sucks 
At it's core Spring is a [dependency injection framework](http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#overview) referred as the "Spring Framework". Over the years many other modules have become part of the framework, dependency injection is simply one module. In addition a number of different [Spring projects](http://spring.io/projects) have been developed around the framework. Spring is not an alternative to Java EE nor is it intended to be. Some modules within the Spring Framework integrate with Java EE technologies. Spring MVC is implemented using Servlets, a Java EE technology. Likewise Spring Data JPA is a project that integrates with JPA, a Java EE technology. Other parts provide an abstraction layer. They rely on the underlying Java EE technology but they provide a different API, usually this is to remove pain points. Finally some of the modules and projects *could* be used in lieu of a Java EE technology. However even in these cases you'll probably use *at least* one Java EE technology. You might use JTA, JPA and JMS but choose to use the Spring Framework in lieu of CDI and Spring MVC in lieu of JAX-RS. The Spring Framework and most of the Spring projects are OSS and maintained by [Pivotal Software](http://en.wikipedia.org/wiki/Pivotal_Software). There are also "community" projects and incubators that don't necessarily receive any official support. Spring Boot is a Spring project that is solely intended to make it fast and easy to build an application with the Spring Framework and other Spring projects. It uses conventions and classpath scanning to detect which modules and projects you've included and attempts to autoconfigure them with the recommended or most commonly used settings. Spring Boot makes a web service this easy: @SpringBootApplication @RestController public class HelloWorld { @RequestMapping("/") String home() { return "Hello World!"; } public static void main(String[] args) { run(HelloWorld.class, args); } } If you want to learn Spring and build web applications quickly Spring Boot is awesome. If you want to learn Java EE, which part? It's easy enough to add JPA for persistence in which case it's great for that. If you want to learn EJB on the other hand it's probably not the direction you're looking for.
Booleans take up zero bytes? Where does it store its state then?
Lots and lots and lots of web sites and web applications you use every day are probably Java on the back end.
Whoa! Why the downvotes? Almost every major game on Android is written in C++, not Java. There is usually just a thin Java wrapper to handle platform specific functionaliy like network access, input, settings and file management.
Take a look at the list of Apache projects, lots of things written in java or for JVM.
[JPCSP](http://www.jpcsp.org/) is a PSP emulator.
RPTools (a virtual table top)
[NASA WorldWind SDK](http://goworldwind.org/) and stuff made on top of that.
My paycheck is made with Java
Try huge swaths of internet backend web applications, particularly things that need to run at scale. Especially if you include other JVM languages like Scala. Things like Twitter and Netflix run on Java. Lots of Google and Apple server-side stuff is also Java. It makes me giggle when people associate Java with stuff like Minecraft, because desktop/client usage is a tiny fraction of what Java's really used for: server-side code, especially for large scale distributed systems.
I've looked at Shibboleth, but it's too overblown. I tried to create a simple test setup and didn't get it working to my satisfaction, so I dropped it. Also, I need a custom authentication mechanism (other than say, LDAP), based on smartcards.
Liquid Robotics, the company for which James Gosling now works, uses Java in their robots. 
Sorry to tell you, but you are in the wrong subreddit. Code help belongs into /r/Javahelp The various hints: + Big red box on the sidebar "PLEASE SEEK HELP WITH JAVA PROGRAMMING IN /R/JAVAHELP" + Big red banner when hovering over the "Submit Text" Button + Separate "Seek Programming Help" Button + Image in the textbox when submitting should have already told you that. Please post your question in /r/Javahelp. Be sure to read the *sidebar* and the *posting guidelines* there. You need to show what you already have in order to get help. Nobody will do your work for you. **Post removed:** wrong subreddit.
+ Bad English with spelling mistakes and horrible grammar + **Wrong** information (especially as /u/dzernumbrd pointed out the piece about the booleans) Completely useless spam.
Most products are ABAP, there are quite a few solution that run on their Java Application Server though. SAP Solution Manager being the main one. 
I'd say https://github.com/spring-io/sagan is a good one to discover in details. It's the official Spring website written with Spring and constantly developed in public. 
Cassandra (one of the top NoSQL db). Minecraft. 
It seems that Stream tutorials are the "gentle introduction to monads" of the Java world.
(Almost literally, inasmuch as Stream::of = unit and Stream::flatMap = bind)
Who the hell deals with mountains of XML? I'm forced to target WAS v8.0 at work, and I use Java EE 6. It's pretty much all annotations and not an obscene amount of annotations. Someone's doing it wrong if they're using tons of XML. The most XML that I typically deal with is an empty beans.xml for CDI, an empty faces-config.xml if I'm using JSF 2.0 as the presentation layer, or a persistence.xml that's relatively tiny (you don't have to list your entities in it). Once in a while, I need to change 1 setting in ibm-web-bnd.xml: the classloader policy from PARENT_FIRST to PARENT_LAST. I only see a few hills, not mountains.
cool, mine as well
`System.out.println("Me too");`
Besides indices, I question the wisdom of representing `Roll_No` as a string instead of a number. That query would be a lot simpler (and probably also a lot faster) if it just asked for every row with a `Roll_No` between 101 and 250.
I don't see free option in heroku
The information presented here is incomplete, of course, but sometimes, duplicating (`VARCHAR`) information can be much faster as you can avoid the unnecessary join to look it up. See this interesting series: http://www.databasesoup.com/2015/01/tag-all-things.html In this particular case, I suspect the bind values in the `IN`-list might be actual user selections (with gaps)
I suspect that concise Java is somewhat contradictory with fully qualifying types (as opposed to assuming imports)
Actually my experience shows we need it often and to good effect. I don't know how many of your projects live longer than a year, but I can tell you that "the best library for X" changes basically every year, and it feels great to be able to quickly swap them if needed and gain some the benefits at basically no cost. Also, I don't like when "YAGNI" is used as an excuse for doing purposefully sloppy engineering. The top reason a "codebase" becomes a "legacy codebase" is when it's a big ball of mud mixing in (soon to be outdated) solutions and (soon to be outdone and abandoned) libraries in a way that are impossible to tease apart. I'm not in the business of creating "legacy codebases" so I apply the minimal effort required to interface components in a flexible way.
thank you very much for the introduction to Spring
Spring MVC is a very complex framework. There is a lot of configuration just to get it up and running. Spring Boot is an additional framework that helps you get a Spring project started. A year ago Spring Roo was the project that was supposed to do that. Java EE uses a convention over configuration mindset so there is not need for something like Boot or Roo. Spring came about because at one point Java EE was difficult to work with. As time has gone on Java EE has become much simpler and Spring has become more complex. Spring is still very popular because there are legacy applications out there and a lot of people just choose it because they know it. It is also a huge ecosystem so some projects might use different pieces of it. There are some cases where Spring offers value but for a standard web application it just adds needless complexity. I suggest before adding a dependency to a project make sure it is really adding something of value. While Spring does rely on Java EE it also competes with it. Basicly CDI vs Spring Dependency Injection, JSF vs Spring MVC. Spring does not really offer anything to help with the Front end since it is an action based framework. JSF is component based so they offrer tools to create your web page as well. Take a look at PrimeFaces.org and go to the demo for some examples of JSF components. 
seems better to just stick with Java EE 7, so spring boot isn't very good a developing quick website? should I try with Ruby on Rails
Could be an H1B scam. Company sets a ridiculous low rate and then shows they need to hire an immigrant, because "they can't find anyone to take the job". 
You're creating a lot of churn and confusion for *literally* zero benefit, because it will never become an issue. While you've stated that you've used it often, I've *never* seen a case where we didn't either rip everything related to the third party lib out, or didn't change our approach altogether. YAGNI makes a lot of sense, and is a superior approach in this case. It's the same thing as creating an interface simply for the fact that you think you should create an interface for some class. If it comes to the point where you are creating a second implementation of something, whether that be with your own code, or needing to abstract some libraries implementation...do it when the time comes, right click, refactor, extract to interface. For gods sake though, don't go around creating those abstractions with no real need. You pay the price in up front time, decreased maintainability, and decreased readability. 
&gt; For gods sake though, don't go around creating those abstractions with no real need. You pay the price in up front time, decreased maintainability, and decreased readability. Decreased maintainability &amp; readability? I really can't reconcile this or the drama in your reply with the practice of using facades. Are you sure you know what [a facade](http://en.wikipedia.org/wiki/Facade_pattern) is?
&gt; based on smartcards. Then it's just standard X.509 Client Authentication and you can use whatever authorization scheme you want behind it. What possibly may be easier for you is front-ending your application server/container with Apache for the authn part and passing through the SSL attributes so your app can do the authz.
Many databases nowadays, such as Cassandra and Neo4j
Every single JNDI variable I've ever had to define (e.g. DB connnection pools) always required some XML changes in some custom servlet/app container config file. But more importantly, the whole code -&gt; compile -&gt; create WAR -&gt; deploy to app server cycle is such a waste (even if you can use some IDE plugins to make it smoother). With the likes of Dropwizard, Spark, Spring Boot it is now just code -&gt; compile -&gt; run that's it. Debugs right in the IDE too, there is no external process to attach too. Daily coding is just so much simpler. Try it. P.S. Nothing stops you from integrating DI within Dropwizard. We have everything wired via Spring internally.
one dyno (one virtual server) is free: https://www.heroku.com/pricing
[HikariJSON](https://github.com/brettwooldridge/HikariJSON) but it's only Java 8 compatible and it's still work in progress. 
I thought IntelliJ IDEA was written in c or c++. Are you sure? I'm not. 
For Spring development, definitely check out Spring Boot, which uses an embedded instance of Tomcat (or Jetty, if that's your thing). Super easy to get started, and sufficiently fast. Most of Spring's tutorials utilize it as well.
Embedded Tomcat/Jetty in Spring Boot is the way to go for new projects. On existing projects, my company uses Tomcat and WebSphere. I tend to like the Tomcat way of doing things over WebSphere, but it's really personal preference.
JHipster is cool for generating app scaffolding in Spring Boot + AngularJS by the way.
Use Spring Boot and an embedded web server (Tomcat/Jetty). I haven't touched an "application server" in years. This also lends itself well to platforms like Docker as well as microservice architectures.
Like the article says, I too don't care about integration with Mylin or new UML editors. Only 2 things *really* matter to me: 1. Stability 2. Performance Nothing else matters. Nothing... as long as these two issues still exist. I love Eclipse, but the weird bugs, the totally, totally weird exceptions that you find in the log of each and every Eclipse installation. The fact that Eclipse often for no reason whatsoever doesn't want to deploy or show the source of something. And that the only way to remedy it is the tired old project clean, close project, open project, clean again, restart eclipse, restart eclipse with -clean until magically some permutation of that resolves the issue :X
Do you think Spring is the better direction career-wise than Java EE? Even with the advances in Java EE 6 and 7?
Fighting with it today... I updated to sr2 and installed my plugins 1 by 1. After trying and remove a TypeScript plugin which didn't work, I couldn't debug Java - was getting a JDI Event Dispatch error. Suffice to say before that I couldn't even install what supposedly is a working plugin listed in the Marketplace (Nodeclipse). Missing repository crap like usual. It's at the point where I might have to change not because I can't find the feature I want, but because the platform usage is simply too unpredictable. I've been a long hold out, but I really need something to restore some faith. On a random positive featurewise note, I saw they accepted a bower ide contribution in JSDT. Cool stuff, but I really want everything to be more seamless. Is it OSGi? Is it the ecosystem? Is the API? Whatever it is, stability and performance have to get there.
None that I can think of.
I have to second this, check out Spring Boot. Makes it really easy and quick to create anything. 
I am not sure. It is hard for me to understand that some people like to do all the extra work it takes to make an application with Spring compared to modern Java EE. A lot of people seem to want to go that route though so who knows what the future will bring.
Considering I've been working with Java since J2EE 1.4 (including WebSphere, Tomcat, JBoss, Glassfish, Jetty along the way), I think I have a pretty good grasp on whether DW is better or not. 
Probably a dumb question, but why is this better than "mvn assembly:assembly"?
Javac - only trust tools that are self hosted.... Ie if the devs don't believe in it enough to use it why should you *cough*unity*cough*
System.gc();
Why do you assume I dont already know and have worked with Spring? I just want to refresh my skills by digging into a real-world middle size application, and not another god damn spring boot or hello world "this is how you get started and take it from there" app? 
I once benchmarked a Mongo table. 10k inserts a sec w no indexes. 2k with 2. Obviously Mongo sucks but use indexes sparingly!!! Don't throw in every query like dumb article suggests
I agree, learn maven. It's quite extensive but it's widely used an extremely useful 
Any idea why there are so many versions of GWT? The web dev space has lots of frameworks but I don't think any others have forked quite as majorly as GWT. It seems like lots of people think that GWT got things almost right but they all want to take it in slightly different directions.
spring boot isn't really faster than say spring with a full web app server, it's good for an embedded web app environment though. Comparing it to javaee would be apples and oranges they're both java web app fruit, but they're mildly different it's more taste.
SmartGWT is more of an application development framework and a set of rich / feature-full widgets. It's not a fork of GWT, it's built upon the underlying GWT technology. GWT does have widgets (that's the Widget Toolkit part of its namesake), but the widgets are more basic and low level. The real money-shot of GWT is its Java-to-Javascript compiler, which lets developers write *and debug* GUI code in the Java language even though it's running in a browser (having been converted to JavaScript). Vaadin is another framework which is built atop of the GWT platform. It specializes in letting your Java GUI/view logic run on the server instead of on the browser, as there are certain advantages to that design for some scenarios. MGWT is a widget library that focuses on touch widgets suitable for phones and mobile devices. None of these things fork GWT. Rather, they all take advantage of the great capabilities it offers, and provide various alternative application development framework approaches.
Was curious what all of the jigsaw ramifications were - will be an interesting update compared to 7 -&gt; 8
I wouldn't be upset at 3 GB of data with 4 GB of indexes --- as long as it is serving a purpose. As long as it is making things better not worse. If the server needs more than 4 GB of ram, then I would give it more memory. I would give it as many cores as it needs. As long as that server is making money, then the minor cost of hardware isn't really that big a deal. At the same time, I wouldn't add indexes that serve no purpose. Design PKs as something that is cheap and easy to join and compare -- like a 64-bit integer. PKs don't have to be visible to the application user. The PK is an internal feature of the application design to join tables. No user visible fields are ever the PK. That way, all fields are potentially editable by a user with sufficient privileges. For example, even an ID can be changed if it were incorrect -- without affecting any other tables or relations. No user visible field should be the PK. The PK should not be visible to the user. I never make an ID field (Employee ID, Student ID, Customer ID, Vendor ID, etc) be a PK. I use the terminology PK for such fields. I hate that the Hibernate documentation pervasively uses the term ID where it should be PK and FK. (Primary Key and Foreign Key, where FK is a field that points to the PK of some other table) 
Thanks for the explanations. I've been tempted to take a look a few times as the underlying idea intrigues me but I've always been put off by the apparent fragmentation.
Okay, here you go: &lt;dependency&gt; &lt;groupId&gt;com.noelherrick&lt;/groupId&gt; &lt;artifactId&gt;jell&lt;/artifactId&gt; &lt;version&gt;0.1.1&lt;/version&gt; &lt;/dependency&gt;
The trouble with screws is that you have to drill out the holes first. A nail just can be pounded where ever until it stops falling over.
Since Minecraft's inception, noobs have been criticizing the use of Java, yet it's still going strong :)
There are a couple guides on Youtube I used when I got started. What IDE and build tool are you using?
&gt; * internal APIs no longer available Hopefully we do actually get a public API for sun.misc.Unsafe before java 9, else some performance critical stuff will be stuck on Java 8 until that's fixed.
Nah, if you have a powered screwdriver and a soft material, you can just force drive the screws in too.
With good reason, game performed horribly at first.
Blame the worker, not the tools.
The tools can only be so good in this case, when dealing with garbage collection. I love Java, and use it professionally, but I would not use it for a game engine.
Yeah, it's pretty much confirmed that most of the useful functionality from misc.Unsafe will be provided in a public module.
Minecraft does not perform well, which is usually the criticism it receives. If you put it beside most C++ games Minecraft feels clunky and slow. The strength of Java is not that it performed fast for Minecraft but Notch was able to program it quickly and as Minecraft has been passed around between developers they still seem to be able to easily add to it. Java performs reasonably well and it maintains reasonably well. Java to me has been the language that's kind of an all-rounder, its decent in nearly every category you'd rate a language on. Being an all-rounder also means that it excels at very little compared to others which kind of makes it a boring language sometimes.
Not Java's fault, and plenty of Java-based servers run fine (Spigot)
I don't know how to help you then... all I can say is I felt similar to you until I forced myself to take a few hours and really understand exactly whats going on. This video helped me: https://www.youtube.com/watch?v=C_QbkGU_lqY
300 per instance is the peak I get with reasonable performance running Spigot on a 1271v3. It can definitely be improved, but compared with much simpler game servers (I'm talking Battlefield 4, GTA), it's not exactly worse.
So Mike, this is your new spam account, yes? After the last one [was banned](http://www.reddit.com/r/spam/comments/2yf0hc/overview_for_mikedoe187/) by the admins? And still spamming the same blog? Oh Mike...
I think C++ is the embodiment of a tool you have to crank manually with all your might. So something like [this](http://blokebuddy.com/wp-content/uploads/2009/12/wenger-giant-swiss-army-knife.jpg)
For non-swing people, 5 -&gt; 6 -&gt; 7 -&gt; 8 has been super super easy. Never more than a few minutes work for multi-100k line of code projects. Now there HAS been big PITA when unintentional bugs got introduced, like the early days of java7. But always waited about 2 months to upgrade, and it has been smooth.
I agree. But I think the development cycle is pretty valuable for java. Right now we have developers using different versions of linux and windows. It wouldn't be to hard to add even more environments to the mix and still develop without having to launch a VM locally. Another advantage is that your development machine can easily be a different uarch from your deployment server. While most everything is x86, if you want to run on something else it is possible (low powered ARM server?) without having a painful emulation layer.
I've never benchmarked it and could be wrong. But I believe the current FFI adds a lot of overhead. That means that if you are going to drop down to native code, you'll need to make sure that you doing a significant amount of work that overcomes the overhead of leaving the JVM.
True, but if you are in an impoverished region and don't have the money for an automatic screwdriver, than nails are the proper choice. Likewise, if you want the most efficient game engine possible, you're probably going to want to use some form of C. If you just want to make a game quickly, you grab unity (or some other premade engine). If you want to make a full game engine but it doesn't have very high requirements and you want it done quickly, Java will do fine.
Except managing the screw factory seems to be a major hassle. I went from making my building to managing a factory, when the hell did this happen? Wait, there is a factory factory? GET ME ONE OF THOSE NAO!
I've never used Vaadin before. What's the benefit of using it over Spring + (any JS Framework like Angular)?
Why this over JOOQ?
Cassandra, Solr, Lucene to start with
Maybe not stubborn. It is pretty easy to add a build/library dependency that is platform specific without even realizing it. Heck, it can even happen just because newer versions of OSes don't support the old libraries needed to build things.
Well OpenGL kind of sucks, to be honest.
[Link to the tweet](https://twitter.com/notch/status/593421975323836416)
In before armchair programmers enlight in us on how would they do it... Ohh wait!
What's the better API then?
Same experience here. Did all those upgrades, large code bases, never any issue to speak of.
okay, got it buddy ;)
Something something rails
That's a complaint against enterprise design patterns, not Java itself. Admittedly a lot of libraries also follow the factory design pattern but it's entirely possible to write Java without having to know about factories. Hell, with a little Spring magic you can get all the functionality of factories without ever writing any factory code.
&gt; Being the only option doesn't mean it's the best option. (ノಠ益ಠ)ノ彡┻━┻
┬─┬ノ(ಠ益ಠノ)
Anytime people talk about the inherent speed advantage that C++ supposedly has (spoiler alert: it doesn't), I press them to explain why this advantage would exist? A few answers that are obviously wrong: -You can use pointers in C. You can use pointers in Java too, you just can't do arbitrary arithmetic on them. This is very rarely a performance advantage. -Java is an interpreted language. Not after startup it isn't. It's running the same (or better) machine code that GCC produces for equivalent operations. -Java has garbage collection. This actually makes allocation faster in most cases, since you don't have to track as much to do deallocation. If you GC, sure there is a cost, but high-performance apps in any language simply don't dynamically allocate memory. There are a couple of points that *might* be valid: -you can allocate arbitrary objects on the stack in C++. It's just stupid that Java doesn't have this, but it's probably a minor point and its easily coded around. -you can write custom assembly. I'd argue this is to difficult and specialized to be useful in real development. Hardware changes to fast for this to be viable. Also you have to be *really* good to beat a dynamically optimizing compiler. That's about it. C++ isn't magically faster, it's just slightly lower level, mostly in ways that don't matter.
That is indeed what I meant. I thought my way of putting it sounded wrong... Really it could just be a bunch of developers using it incorrectly, because many games that use OpenGL are slow and crash many, many times more than with other graphical APIs. Though, of course, that's not OpenGL's fault. Maybe I'm just a little salty.
What did they use before OpenGL?
Pretty sure they still use DirectX mostly. They ported to OpenGL for Linux &amp; Mac support, and apparently saw some gains in some games.
Armchair professional Java developer please, and see my other comment
Yep. There's a lot that can be done, but there are also, like you pointed out, complexities, like transparent blocks. Also, as I mentioned before, because the world can change, you have to recalculate the joined chunks every time they change. This is OK for Minecraft usually, but for a game like Deposition, with real time physics, it's much harder to make use of those optimizations without the optimizing itself taking too long.
&gt; Another advantage is that your development machine can easily be a different uarch from your deployment server. This is not necessarily exclusive to Java. Early in my career, I was involved in some embedded systems work that used the same C codebase across real-mode x86, protected-mode x86, mc68k, and Win32/x86. Several modules I was involved in were developed/maintained as Win32 apps and then ported into the embedded targets. This was done as small part of an effort that took at most 30-40 person-years over 5 calendar years, so the costs weren't ridiculously high.
&gt; That would be a situation where a predictable environment is not being achieved. I think you're confusing predictability with consistency (or maybe homogeneity). &gt; If those problems exist in many situations, the developer is just being stubborn. It may also be related to the hardware/software stack that's been provided to the developer. In commercial settings, it's not uncommon at all that a developer has no choice over their development tools.
A few years ago, there was a great post by one of the JGit developers on the relative disadvantages of Java vs. C as an implementation language for git. It's worth a read: http://marc.info/?l=git&amp;m=124111702609723&amp;w=2 &gt; You can use pointers in Java too, you just can't do arbitrary arithmetic on them. This is very rarely a performance advantage. Many of the dangerous things that C lets you do with pointers that Java does not are useful to avoid memory copies. (pointer arithmetic, pointers into the middle of structs or arrays, and pointer type casts, etc.) Occasionally, it's useful to use pointer arithmetic to control the layout of memory structures to avoid allocations. &gt; -you can allocate arbitrary objects on the stack in C++. It's just stupid that Java doesn't have this, but it's probably a minor point and its easily coded around. How would you easily code around it? With a relocating GC, Java can reduce an allocation to a pointer bump, but still has significant costs to free the allocated memory. With stack allocation, both the allocation and the free amount to nothing more than a pointer bump. With this C function, the three ints are allocated and freed all at one with a single stack operation for allocation and a single stack operation for free. #define STACK_BUF_SIZE (4) void my_fn() { int buf[STACK_BUF_SIZE]; // ... stuff here } That's not achievable in Java, unless you trust the JIT compiler to optimize away allocations, which isn't nearly as trustworthy as the guarantees that C provides. ***edited:*** To correct embarrassing error /u/CubsThisYear pointed out in their response.
hindsight is 20/20. Dude had an AMAZING idea for a game that he wrote the base for in a matter of a week or so. 
That 11 second response time, though.
It's possible that writing the OpenGL code with the hindsight they'd had writing the DirectX code helped them produce better optimized code. I prefer OpenGL to DirectX for the reasons a lot of other people do (cross-platform, open source) but the anecdotal evidence from Valve doesn't really prove anything. Hell, they've been pushing SteamOS and Linux gaming pretty hard, it's in their best interests to suggest that you can get better performance from OpenGL.
Cool! I don't really know what zeef is, and I have been skeptical that it is a useful resource. But I can say for sure I would have loved to find this 2 years ago when I first started working with web backend Java. I just may have to share this with some of the newer Java web devs at my office!
Interesting article - hard for me to say how specific that stuff is to git. My first thought is that it would pretty easy to just implement a few functions in C and use JNI where needed. Also primitive collections are not a big deal IMO. There are several good libraries that provide them. As to avoiding GC, you just have to allocate all of your memory up front and manage it yourself, AKA exactly how you do it in C. You don't worry about the cost of freeing memory because you don't actually free it, you just reuse it. Note you don't do this for your whole program, only the spots where it matters. Finally your example about stack allocation is very confused. Java would allocate those 3 ints in the exact same way that C would, in the stack. The difference comes when you are talking about complex objects. But as I said, you can just preallocate them and the problem basically goes away. Furthermore, it's a dumb problem that is created by Sun/Oracle's resistance to change. C# has had stack allocation for years and it is conceptually equivalent to Java. My main point is that C++'s ratio of brokenness (lack of module system, arcane syntax, weird implicitness) to useful things is way too high a cost to pay in exchange for a small performance boost.
Not if you don't upgrade. Where I work we still run Java 1.6, because that is the corporate standard and the fucking review board won't get off their fat asses. We had a big upgrade this year from Java 1.6_20 to Java 1.6_37, I shit you not. They did not even bother to approve the last Java 1.6 release.
Yeah, I never said you couldn't do it in Java, I said it wasn't the intention of the language. By pooling you're ignoring what makes Java great, it's amazing JVM, and its excellent GC tools. If you're going to pool resources and implement your own memory management system, do it in language that needs to, and therefore has 3rd party tooling behind it already, such as C or C++.
Was it really an original idea, though, or was he just able to iterate on it faster? Minecraft was originally a clone of Infiniminer, right? He was just able to make Minecraft do more, and faster.
&gt; though the original decisions he made still plague the game today Because I'm lazy, and because you made the claim, can you give any particularly notable examples of where this is the case?
No, we're discussing it in /r/java 
There is a third group, who mock verbose over-engineered design. SimpleBeanFactoryAwareAspectInstanceFactory
Comparing Minecraft to other "C++ games" is a meaningless endeavour. Far far more often is it the design of the system holding back performance rather than the language it was written in.
see here http://melix.github.io/blog/2015/02/who-is-groovy.html a detailed history of Groovy language, in terms of community and core contributors. It's started without any funding. 
I would never dream of it. All hail the nail.
Yeah, Java is only used for tons of mobile games really well. However, I'd say that java is always about 5 years behind the performance curve of hard native code, but it comes with much higher portability and maintainability.
You can read more about zeef in a recent interview with it's owner, zeef is a Java EE startup ;) http://www.adam-bien.com/roller/abien/entry/a_java_ee_startup_filtering
Direct3D, I'm fairly sure.
Surprising considering a lot of large infrastructures run on Java and are highly performant.
I've been coding java for 10 years, i make six figures in the midwest unitedus states ie low cost of living. Its easy, tool chain is great, awesome libraries and frameworks are abundant ie this all make my job easy. None of this noise matter, I've got all these languages on my resume, but java pays.
Your Java 8 tutorials/posts are downright phenomenal; I've had many of them bookmarked right below the JDK + J2EE APIs since I started to work in Java 8 :) Here are my faves (probably very useful for others): * http://winterbe.com/posts/2014/03/16/java-8-tutorial/ * http://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/ * http://winterbe.com/posts/2015/03/25/java8-examples-string-number-math-files/ Edit: Extra love for *not* using a horrendous/broken layout for your blog like seemingly everyone else ...
The power screwdriver is called intellij. It generates the majority of the boiler plate. 
Thanks. I'm glad my posts are useful to you and really appreciate your feedback!
Captain obvious to the rescue.
Excellent, keep them coming!
Really? OpenGL is wrapped perfectly
Think harder... Mars rovers, Google, Netflix... to name a few.
It was many many years ago that I tried but I had a lot of issues in deployment. "Game fails to start distro x version y" or "Not working on windows x". I have been interested in messing with libgdx which appears to be a more comprehensive solution than the libraries I used in the past.
&gt; everything takes a factory wtf? i've seen/used few factories in spring, but by large ... nope. 99% of my spring based code doesn't involve factories. what the hell are these people doing? learned one design pattern and go with it till the very end (like the singleton....)? 
&gt; Finally your example about stack allocation is very confused. Thanks. It was a long day, and you're of course right. I've changed the example to be closer to my intent. Stack allocating temporary buffers isn't really possible on Java unless you trust the compiler to implement some fairly clever optimizations. &gt; But as I said, you can just preallocate them and the problem basically goes away. I don't know that the preallocation/pool strategy would work all that well for something like a stack allocated buffer. At the very least, it won't come close to matching C. Allocate a pool of `char[]`, and you have pointer chasing to get to the buffer, reduced locality of reference (even if the buffer is in the cache, it adds more cache pressure) and then the overhead of whatever algorithm is used to mange the pool. Switch to allocating segments of a single large 'char[]' can solve some of the issues, but then you need to be passing in both the base of the array and an offset into the array. This, of course, assumes that the interface being called supports both arguments, and even if it does, it means additional pressure on registers, etc. &gt;Note you don't do this for your whole program, only the spots where it matters. I'd be at least a little concerned about this approach if only due to the fact that switching from automatic to manual memory management isn't a search/replace type of thing. &gt; Furthermore, it's a dumb problem The fact it's a *dumb* problem doesn't make it any less of a problem. &gt; Also primitive collections are not a big deal IMO. There are several good libraries that provide them. I've had good luck with Trove. &gt; Interesting article - hard for me to say how specific that stuff is to git. Some of the stuff is relatively general. I've been hit with some of it, as well a few other issues, developing a small database system. (One specific example is the fact that there's no good way to definitely `munmap` a file in the standard API.)
It's been awhile since I've had to do something like this so I'm unclear on the details, but if you have the JVM running in debug mode you can then attach a remote profiler/debugger of some kind to the instance. Conceivably there should be one that can trigger the heap dump for you.
Thank you, great post! I'm about 8 years into Java development as a career, also with Matlab and C in my background, no web stuff. Great to read your insights like this. 
Great tutorial, thank you!
Thanks, I will take a look!
What's wrong with learning JS? It's a fairly standard language for developing UIs and learning new things never hurts.
Since the class you give as an example has the word Factory only one time at the end, then I presume you are unfamiliar with the FactoryFactory or the FactoryFactoryFactory pattern? XmlParser, comes from an . . . XmlParserFactory, which comes from an . . . XmlParserFactoryFactory, . . . 
Author here, looking for feedback.
You could start reading [Java ist auch nur eine Insel](http://openbook.rheinwerk-verlag.de/javainsel/). As far as I have seen, it's pretty good. Also ForgeWiki has an [entry](http://www.minecraftforge.net/wiki/Basic_Modding) about basic modding. 
Read the sidebar. Edit to expand on this: there's three subreddits linked that deal with learning to program. All of them contain a *wealth* of information for you to read. But you have to actually read these things, not just submit questions that were asked and answered before.
I took a look at Throwable and so long as you're calling "new" you're creating a stack trace, regardless of the arguments passed in. When you pass in a Throwable, all you're doing is setting your new exceptions cause to that of the arguments. //our new exception's cause is ex's throw new RuntimeException(ex); So comparing the cost of: throw new RuntimeException(); //vs throw new RuntimeException(ex); It is roughly the same. If you're worried about performance of throwing exceptions you could catch the exception and use the [Null Object Pattern](http://en.wikipedia.org/wiki/Null_Object_pattern#Java) or Optionals. 
Oh, I know they're there, all over the place, but they don't really have a place in my code. I have annotations, I request things to be injected, tell spring to do X or Y in the configuration, but by and large ... I don't call factories directly. It happens every now and then, but is the exception and not the rule. For example getting a current context of some kind, yea, kind need that factory, or other minor uses, in a couple of places. Not "healthy smattering" by any means. 
I'll make a guide and send you the link :)
Stack trace generation comes down to the implementation of https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html#fillInStackTrace%28%29 I wouldn't recommend getting tricky with this (I can't imagine it's ever worth it), but if you're set on messing with how stack traces are generated, you can implement your own exceptions with custom stack trace generation implementations.
Java is definitely a good language to begin learning programming with. Lots of people would debate this, as there is a lot of things that you need to learn before you can start making basic programs ("public static void main(String[] args)" - you'll know what I mean when you encounter it), but once you get past this, the language itself is really good. I would also advise you to make your programs in English (where you have the option to use your own language), as English is basically the "default" language when it comes to programming. There are *so many* resources available to learn programming. The three most common ways to learn to program are: books, web-sites, youtube videos. I personally recommend books, as they go into so much more depth than other methods, and they also tend to assume less. They also go at a pace you can control. I'm not going to recommend any specific books, but if you do want to do this, just do a google search for something like "best beginner java books", and you'll come across countless blogs and lists with advise on the best things to use. Anyway, good luck on your programming journey!
In that ticket someone said it got fixed in build 10049. I'm on build 10041 right now, updating to 10074 as we speak. I hope this works afterwards :3 Will respond then, thanks in advance! :)
Thanks. I do typically use the null object pattern. But sometimes when handling multiple exception from outside sources, I do think it's useful to condense the possible exceptions into a single exception class that is is specific to the module in my application. I probably still will most of the time, but I do like knowing the costs of my decisions. Usually I end up doing this with spring applications because spring loves exceptions. 
According to [this article](http://news.softpedia.com/news/Microsoft-Windows-10-Preview-Users-Will-Be-Able-to-Upgrade-to-RTM-466593.shtml), it looks like you'll be able to upgrade from TP to RTM.
Right, well that's interesting. I still wouldn't do it personally, I love that fresh OS smell too much.
T-shirts are pervasive, but they're not all created equal. A shirt that I can wear in public without looking like some kind of dorky billboard is worth keeping. An invite to an after-hours party that isn't a thinly veiled sales pitch is another big "get". Hands-on tech demos are good. People who actually know about and work with the technology are practically the *raison d'être* for the booth. Aggressive sales droids are bad. Pens, squeeze toys, and notepads are bad. If we know we're being mined for leads, we're going to give you bad leads. If you show us something cool that helps us do our jobs, and it's affordable, *and* you let us play with it, there's a very good chance we'll talk to our PHB's and coworkers about it when we get back to the office.
Looks useful! Won't get a chance to try it on an actual project until Monday, but glancing through the code there's one thing I wanted to mention since I maintain a few gradle plugins for our projects: Instead of using a vanilla named map for the formats and fudging configuration order with `afterEvaluate`, you should look at [Gradle's domain object containers](http://gradle.org/docs/current/javadoc/org/gradle/api/Project.html#container(java.lang.Class\)), which have lazy evaluation built-in in the form of iterator methods like `all`, which calls the passed action/closure for every object in the collection regardless of when it's added. You can also use the `matching` method on TaskContainer to lazily wire the dependency for the check task, because the returned collection is live. e.g. (groovy code, but you could use Java 8 lambdas too) project.getTasks().matching{ task -&gt; task.name == JavaBasePlugin.CHECK_TASK_NAME }.all{ checkTask -&gt; checkTask.dependsOn(rootCheckTask) } 
Throwing the exception itself has no cost (it's compiled down to a jump) -- all the cost is associated with filling in the stack trace.
I think my articles are not as detailed as the official docs. I try to find simple code samples which easily fit into blog posts and are as self-explanatory as possible. I want people to find an easy introduction into the topics without reading walls of text. I take your advice and cross-posted the link in /r/programming although I'm not entirely sure if it's that interesting for non-java devs: :) http://www.reddit.com/r/programming/comments/34hqu9/java_8_concurrency_api_synchronization_locks_and/
For years. Not very often, admittedly.
Depends, People might make friendlier REPL apis which can be called. Chaining these together in combination with lambdas might make most things not too verbose. Imagine opening a repl into your initialized JPA app to test a few queries. We might need nicer ways to define Maps and lists though, like a = {'a':1, 'b':2}
At that point, you might seriously consider just using Groovy for that kind of thing. It's basically a superset of Java as it is, and it has very nice map and list literal syntax: def a = [ a: 1, b: 2 ]
It's just a more compact way of sending in an argument when creating an object. E.g.: Human hooman = new Human(new Whatever()); is the equivalent of writing: Whatever whatevvs = new Whatever(); Human hooman = new Human(whatevvs);
 GregorianCalendar c = new GregorianCalendar(2015, 1/*Feb*/, 1); c.set(Calendar.DAY_OF_MONTH, 31); // set invalid day c.setLenient(false); // enable error checking try { System.err.println(c.get(Calendar.DAY_OF_MONTH)); // now throws IllegalArgumentException } catch (IllegalArgumentException e) { e.printStackTrace(); } c.setLenient(true); // disable error checking (default) // no exception; silently changes month and day! System.err.println(c.get(Calendar.DAY_OF_MONTH)); System.err.println(c.get(Calendar.MONTH)); You should probably consider the new java.time.* API ;)
I remember Vaadin giving away an O'Reilly sized book on their API at a conference once... I read it on the flight home. 
Imagine two classes: Human and Group. Group has the following overloaded constructor: private Human person; public Group(Human human){ person = human; } If you create a group anywhere, it'll have to take a Human object as parameter. So, when you create a group: Group someGroup = new Group(new Human()); You are essentially saying: I want to make a new group and I'll give the human it has to have to be created as a brand new object of Human. There is nothing really special about this; the only difference between this and defining / declaring the Human earlier, is that you don't have a reference to that human wherever you created that group.
I want repl for debugging!
Quite a few other JVM languages have REPLs that you can use right now, including ones that you can launch from Maven (or other build tools) with the correct classpath already set up for your project. Getting the classpath right is going to be the big pain point for a Java REPL to really be useful.
This is a conference in general recommendation. Give away large branded bags. Bags are designed to hold all the other give always from the conference. Bags need to be large so you can place the smaller bags inside your large bag. It's great for marketing because you'll have tons of attendees with your branded bag walking around the conference.
Bobblehead richard stallman I´m really liking!!! :-)
This was the first thing that came to mind. Java has had a kind of REPL available for a long time. Shame that the original was not better updated and integrated with IDEs and such (yeah I know, the idea of a REPL is to NOT fire up the IDE, but also in an IDE I would like to quickly try out some piece of code, if possible within the context of the project I'm working on).
this is my #1 wishlist for java. the IDEs provide immediate windows, but they're pretty limited. a REPL that could handle pure java would be invaluable ... set a breakpoint, drop into the REPL, write a bunch of code till you get the correct output, copy and paste back into the editor and continue
Doesn't a good IDE give you something more or less equivalent? I know IntelliJ lets you evaluate statements at a breakpoint.
Pen tool flashlight.
This would be fantastic!
kickass. Thanks a bunch. I briefely used Exercism.io for some C# refreshers a while ago, but I was always annoyed at no support for Java. Is there a tutorial on how to port an exercise? I really don't know how the system works on the back end, so my ability to help is limited until I can get that part solid.
Those lambdaj examples are bad. Rife with so many errors.
Being interactive like a REPL, and having interpreted bytecode are two different things. The interpreted bytecode works similarly to native executables. A java program starts with a main() method in some class, executes to completion, then exits. The Java language is designed around the idea of being compiled. Building a REPL for Java necessarily seems to require doing some thinking about what can be entered interactively and what happens in response. Can you enter a package statement? If so, can you enter more than one (in order to change what package subsequent classes are compiled under)? Can you enter an expression (eg: 3 + 5) that is not part of a statement, not part of a method, not part of a class? Can you enter a statement eg: System.out.println("hello whirrled"); without it being part of a method, which is part of a class? Can you enter a complete method, without surrounding it with a class declaration? I'm sure this is just the tip of the can of worms. 
Okay thanks for the reply. I confess I did not exhaustively read every single bit. Mostly the source code, rather than the output which I could picture in my mind. I did not realize that you expected to get output regarding the already traversed iterator. The use of an Iterable that can provide an already-traversed Iterator multiple times was a giant red flag to me. Especially since it did not have a comment explaining to not do this.
Sadly it's JRE 6 and just the JRE installed. It's a Windows machine, I read somewhere that you could send siquit to a java process which would trigger the creation of the dump if you used -XX:+HeapDumpOnCtrlBreak 
You should have a look at [Genson](http://owlike.github.io/genson/), it works out of the box with JaxRS, has nice integration with Joda time, JSON-P, JAXB and also scala! Another cool feature: you can even use constructors with arguments! Genson genosn = new GensonBuilder() .useConstructorWithArguments() .withBundle(new JodaTimeBundle()) .withBundle(new JSR353Bundle()) .create(); genson.serialize(...);
Can it also do something like Tidy for XML/HTML?
Download the free Spring Reference guides. They're well written and more informative than the published commercial books, in my opinion.
So, you unwittingly made our case: "using an ORM is a hell of lot more complex than knowing how to write SQL queries." That's why I stopped using it. It was too much work for too little benefit. Now, I live without it and am extremely productive, given my expert SQL knowledge. [Edit: been a professional engineer since 1997 and have used Java professionally since 1999.]
I prefer Spring MyBatis framework over any ORM. You will be closer to SQL it will be really helpful when it comes to performance tuning. Also, you can check on JDBI.
It seems like a lot of you guys have problems using the right tools in the right places.
I'll upvote in case you're doing Android or are stuck on anything earlier than Java8 then this makes sense. But if you're on Java8 you should be using the built in lambdas. To be honest, I felt like downvoting because the article doesn't mention any of that and it was published a day ago.
Spring, MyBatis, Dropwizard, AngularJS
Ahead of time compilation will actually be slower. JIT is a big reason why Java is so performant in the realm of long-running servers. JIT isn't overhead. It's an optimization step. The JIT will optimize (and [de-optimize](http://en.wikipedia.org/wiki/Adaptive_optimization#Deoptimization)) the code as it is run reactively to its performance profile. From wikipedia: &gt; One possible optimization, used by Sun's HotSpot Java Virtual Machine, is to combine interpretation and JIT compilation. The application code is initially interpreted, but the JVM monitors which sequences of bytecode are frequently executed and translates them to machine code for direct execution on the hardware. For bytecode which is executed only a few times, this saves the compilation time and reduces the initial latency; for frequently executed bytecode, JIT compilation is used to run at high speed, after an initial phase of slow interpretation. Additionally, since a program spends most time executing a minority of its code, the reduced compilation time is significant. Finally, during the initial code interpretation, execution statistics can be collected before compilation, which helps to perform better optimization.
The only factory Spring forces me to interact with directly is the one I created. Configuration of Spring has never been easier, even in an enterprise environment. In most cases where a factory might otherwise be utilized a builder is provided anyway, it's a non-issue. RestTemplate is a pain point. I think I've needed to use it once. Not at all indicative of Java 8 or modern Spring.
[Minecraft on xbox and phone had to be ported to C++](http://www.eurogamer.net/articles/digitalfoundry-vs-minecraft-xbox-360-edition). I'm not saying anything bad about Java, but it's not the best language for gamedev (but it will indeed work for some subset of games).
 try: print unset_variable except Exception, e: print e everyone lost their minds at this. I've no idea why to this day. I dont do it but I dont know why I dont do it. I know how to set up variables the part about "Exception,e" is what I dont get atm. edit: I was drunk yesterday and thought I was in /r/python . 
Catch "Throwable", not "Exception" - then you can swallow errors too.
 catch (ThreadDeath td) { // DENIED }
Translation: "Get off my damn lawn!"
I never thought of this :O I always add a "// Exception ignored because...". I may steal this idea and add it in
I think people are missing the meaning behind this meme...
This is known as the pokemon! Gotta catch em all! 
&gt; Accidentally read more than is available? Fuck up a possibly set mark? Doesn't throw IOException. (as I said, ByteArrayInputStream)
This meme is called ***bad advice mallard*** :|
Thanks for pointing. I have fixed the post. My intention was to help those who are already using it or have decided to use it. I have added a note: "As of Java 7, functional programming in Java can only be approximated through awkward and verbose use of anonymous classes. This is expected to change in Java 8, but Guava is currently aimed at users of Java 5 and above."
I got a couple of rotating USB splitters at a netsec event. They're cool. I use one for my keyboard but it's not enough to run the backlight without occasional hiccups.
Flash drives filled with thousands of photographs of Richard Stallman
You're fired. (Yeah I get the implied /s. At least I pray there is an implied /s)
It's more about asking whether you should take a cake and eat it with bare hands, or be formal and nice and get a fork / spoon and eat it in a good manner. Of course you can write Java code and good Java code without and IDE, but, if you're making some application that has a big code base and uses a lot of user built classes then life without an IDE will be : HELL! Doing Simple coding? Yes you can easily do it without IDE. Working on a project or making some application? Get and IDE to avoid getting dirty. 
 try { return s.getBytes("UTF8"); } catch (UnsupportedEncodingException willNeverHappen) {} // rant
what about that EOF Exception when reading a file ?
Y'all motherfuckers need some TDD. JUnit that shit up.
I like it when a stand has logic / math / programming riddle(s). 
Nooooooooooooooooooooooooooooooooooooooooooooooooooo At least log it
Not everyone on reddit subscribes to /r/AdviceAnimals or is familiar with the image macro subculture. There is a reason why many subreddits prohibit image macro posts like this.
Wrong crowd indeed. Not everyone on reddit subscribes to /r/AdviceAnimals or is familiar with the image macro subculture.
Good point! Catch throwable and in the catch block thread.sleep for 10 seconds! That will give your program time to recover... Right?!
Specifically? 
Ah. I'll deliver in a bit. On mobile. It's nothing special, heh. 