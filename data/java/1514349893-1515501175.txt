I rely heavily on this in Java, and didn’t realize that I was until I started to use Scalia a bit more. Even with type inference a lot of the time the IDE + Java is much faster when defining variables for me 
Don't you still have to have a persistence.xml to set up the persistence units? If there is another way I would be interested to know about it. The persistence.xml is one of the last XML files I still have around.
it is great to see jax-rs supporting a mechanism for server -&gt; client communications to alleviate pressure from client libs having to do periodic checks, especially with Rx taking off :)
Startup time of jvm makes it prohibitively expensive to use java for short lived programs. For example, it would be difficult to implement an effective replacement for the grep or cat program with java
I don't share this aversion at all! &lt;&lt; and &gt;&gt; for stream ops is perfectly clear. Piping for objecting chaining is totally clear to me.
Sometime ago I wrote a blog post https://sivalabs.in/2016/03/why-springboot/ explaining how you can build a web application using plain SpringMVC and how you can build the same using SpringBoot much easily. I hope it will help you understand that SpringBoot is nothing but Spring, but much easier to use because of it's AutoConfiguration mechanism.
How would that work though? Isn't the whole idea of primitives that they aren't objects? And then you use the wrapper objects when you actually need them to be? I'm just a hobby programmer, so I might be really off. 
Fair. 
Can be... Auto boxing tends to be ok no?
Thanks. I guess that makes sense, especially considering that C# has pass-by-reference while Java does not.
Most of the microservices in our project also have a corresponding client for the internal calls. These clients are all based off one 'base' client library. It's basically a wrapper around OkHttp with some convenience methods (like for doing a GET on an URL and directly mapping the response to a DTO). 
I am comfortable with Java's operator overloading. | for Exception handling, enums and + for string concatenation works, OK. Like I said maybe [] can be used for get. So I am not opposed to the idea compeletely, I just wouldn't want to be in the user's hands. Developers get *clever* and do insane shit all the time.
This is exactly right. James Gosling has said one of the goals when designing Java was to create a simple language, and the Java language specification names C. A. R. Hoare, which had strong opinions about feature-bloat in programming languages. I've heard plenty of times that C# is better than Java just because it has more features. It might seem counterintuitive, but I think that's not a good reason to claim a language is better. Simplicity is an important metric, and I'm convinced Java approach of being cautious when adopting new features is better for the language on the long term.
Operator Overloading. OMG that was bad. Note: If something can be used, it will be used and most definitly not sensibly.
Well, it really depends. Is your project specifically on android? You will have to go for native frameworks. If you want a [roject for different platforms (i.e Android, iOS) - you will have to use cross-platform ones. I have found a good list of Android frameworks recently here: https://vironit.com/frameworks-for-building-android-apps/ Hope this helps!
Which is not anything like a const method. A const method is a method that does not change the state of the object, without the downsides of making it static.
The problem with that plugin is how long it can take to build. I stopped using it after Travis started using the new environment, as some builds would break due to the time it took to download the files and generate the report.
We started using this recently after the 8000th Struts RCE vulnerability this year. I agree with the author, it's not an end-all-be-all security check, but it's a nice add. One thing to note is that it requires your project build to make external http requests which can slow down your build at best or break it randomly at worst. I've set this up as a separate daily job (could probably stand to do it weekly) instead of as part of the normal CI build &amp; deploy.
JPA seems to require persistence.xml. As far as I can determine you don't need persistence.xml if you use Hibernate directly, only if you use it for a JPA implementation. And of course if you avoid JPA/Hibernate like the plague it is then you don't need persistence.xml either.
It is horrible plugin. However it is essential, because there is nothing better. At least not free. 999/1000 times whatever it highlights is not even remotely relevant. Picks up incorrect versions associated with other dependencies. So you have to go exclude it. But at least that 1 time out 1000 you will be aware of the actual issue.
A good approach is to not integrate this into your build pipeline, but into a separate app sec pipeline so it doesn't slow down builds or cover up other errors. If you have some form of CI/CD, make that dependant on whether both pipelines have been successful. This way you can still build artifacts (e.g. for internal repositories), but automatic deployment only takes place when there are no problems. Bonus points if you configure your app sec pipeline to run at least monthly (even if there are no new commits) so you'll be notified when new vulnerabilites have been discovered.
Like, no they didn't? You have no idea my friend. There are some popular web apps, but &gt; 90 of all apps are still native (or, java/flash/etc, something that runs on the desktop and not in a browser).
Thanks. I added that to the post. 
And why the fuck wouldn't I "show up in this thread"? It's a java thread, which is kinda relevant don't you think?
Thanks, added such a recommendation to the post itself
Well, at least you are not adding 1000 dependencies to a project regularly, so it shouldn't be such an overhead :)
It is not 1000 dependencies you add. It is 1000 times it picks some "new" vulnerability up. i.e. when you update libraries, which I hope for the sake of your projects you do regularly.
But why aren't they objects? In some languages, literally everything is an object, so that you can call methods on any variable. Null would have a type that inherits from object. Then Object would have a method isNull() that only null's type would return true. Methods and functions can more gracefully fail when invoked on null.
I have been writing Scala recently, and I really like a lot of the things the language provides like Tuples, Pattern Matching.
According to the copenhagen interpretation, yes, quantum mechanics does have true randomness, mainly because the use of "hidden variables" was disproved. see: http://www.askamathematician.com/2009/12/q-do-physicists-really-believe-in-true-randomness/
I think you should read the question, it states what are weakest points of java, and not the strength of scala. I dont mean any offense, but new readers should not be misled, by such inaccurate answers
You were right, I answered it in the wrong way. 
Great!! ☺
Ecosystem maturity. Plenty of frameworks, libraries, and ability to search and find answers on stackoverflow with ease. 
&gt; They are foisted on us, but they are truly awful. Everybody writes their own design, none of the controls match the native window system etc. I don't use Electron apps if I can help it; they are slow and take up tons of resources. I share your opinion of web apps. &gt; I suggest you try JFormDesigner. I will check it out, out of curiosity 
Did I say it was? They mentioned marking parameters as `const`, which you can do in Java with `final`.
You can set up a proxy for the NIST vulnerability database it uses. [](https://jeremylong.github.io/DependencyCheck/data/mirrornvd.html) (Not my repo - but useful as a resource) Set THIS up to refresh nightly, then you can run build / assessment jobs more frequently. 
This could be implemented with a Maven profile.
Nice. I considered something like that (or a caching proxy) but it was simpler to do just once a day ;) Sometimes laziness wins out...
Oh totally understand. Sometimes ‘good enough’ is the right approach to take. The way I’ve done this recently is to have a security pipeline which grabs the NIST data and builds a Docker image of the mirror. As I’m deploying in a Kubernetes environment, I can then automate the rollout of this new image to all the projects which use it. They all have heir own build pipelines that just talk to this local mirror. It’s a total PITA to set up, but once it’s running it’s all pretty seamless. 
Can someone compare/contrast this to SonarQube?
But you didn't point anything out, you just replied with topics from physics, at random it would seem.
I literally have absolutely no idea what you are asking. I strongly suspect I am not the only one. You need to provide more details!
I have to find the kth term of fibonacci of a number using 35+1. So fib(35+1) mod 12334578(myid) = x numbers mod (myID number). And then use that and implent adt like Heap, doubly linked or avl tree. Obviously i dont want to post the whole assignment on here. 
Ok, I think you better seek out your teacher/professor/TA for help. I still don't understand what 36 has to do with the fibonacci sequence (36 is not in the sequence), or what any of this has to do with implementing a heap structure etc. I 'm guessing you don't understand the assignment--which is not a slight against you at all (I've had many assignments I didn't understand at first), but it means you need to get help from somebody who understands what is expected of you rather than anonymous strangers on the Internet.
It says the k th term is taking the index values from 1 to 16 which is calculated as 35+1? 
*Please* get help from somebody who knows and understands the assignment. I'm done here; I still have absolutely no inkling what is expected of you or how to help, or what "35+1" has to do with anything at all.
Pattern matching is currently being worked on. See [JEP 305](http://openjdk.java.net/jeps/305). Goetz said that tuples were considered, but that they would likely be less useful than value types.
First of all: you're in the wrong subreddit. The **sidebar** clearly states: &gt; NO programming help Plenty hints on the page (including the big red "SEEK PROGRAMMING HELP" button) point to **/r/javahelp** for programming help. Second: Never ask for help via PM. This is not tolerated in *any* of the programming related subreddits. Third: Show your efforts when you ask for help. Nobody will be doing your work, nor will you get complete solutions. Either is forbidden in the subreddits.
Ok
It offer true randomness for now, but who known if we might figure out something about that later. Ever heard about the two slit experiments and the pattern of light it generate? This is experiment is also used to actually introduce people to the world of quantum mechanics. What I say is there might be a grand scheme with a specific pattern we haven't discover yet. Maybe we still haven't figure yet what is real randomness.
&gt; You're just being pedantic The pedantry started with /u/deadlock_jones comment : &gt; Afaik there's no true randomness in the universe, just random enough. which they provided no evidence to support, and which clearly moved the discussion beyond Java into Physics. 
SonarQube scans your code for known vulnerabilities and bad practices. Dependency check scans your jars for vulnerabilities reported to NIST. You want both. Dependency check duties are probably better handled in a repository manager like Sonatype's Nexus, but for the open source project sitting on github, a maven plugin that does the job is still a good idea.
I think that Spring tend to make things complex which might produce errors and bugs within the code. Those can be handled using programs such as checkmarx but I think they better be dealt by programming slowly and taking in advance all possibilities.
This plugin can submit it’s report to SonarQube which can be displayed in the UI
It's not because you can do it that you should do it.
Any other security resources you use in this way? Interested.
Seems like creating a new anonymous inner class everytime you want to initialize a collection is... bad.
It's okay to complain. We should have higher standards for our development tools. Just because it used to be worse doesn't mean we should be complacent.
Kotlin is not any of those things. And comparing Java/Scala/Groovy to Clojure is ... pretty damn silly.
Yeah for a second a felt like 2007 again. Guys don't use this, it's an anti pattern and a bad hack. Java 9 brings nice collection factory methods, Guava has had them for years. Use them.
Does it check the hash of the dependency artifact against known hash? Alternatively, any other plugin which does that? I don't use maven much, but I depend on a project that does and I will share this info with them.
My current company uses java 8, former was switching to 7/8 in a few enviroments. It was a matter of old systems that were more difficult to upgrade.
* it has a type system that is comprehensible to humans * its collections are compatible with Java's * it uses angle brackets like Java instead of square brackets * type coercion is explicit
Can you elaborate on that? Is comparing Eta language to Clojure silly? And Eta to Scala?
That is indeed interesting, although I don't fully understand it, isn't it possible, that a single black swan event proves it wrong?
We run a nightly job separate to our regular pipeline producing the report because of the build time
**tl;dr** Just because they're all JVM-based doesn't mean they can be easily compared. Maybe I've misread what you're trying to say. And I apologize, I didn't mean to be rude. I interpreted you saying "We already had Groovy, Clojure and Scala" as implying Kotlin is a passing fad. I interpreted your argument as "since Groovy, Clojure, and Scala haven't dramatically changed the Java developer market, then why should Kotin be any different?" My point is that it's silly to suggest that Kotlin will fail on the basis of these other JVM languages not being particularly incredibly popular-- especially comparing Clojure. Kotlin solves a lot of problems which Java devs have to face every day, and yet it's similar enough to Java that the transition wouldn't be too painful. You'd need to learn syntax differences, a few new control flows, and some minor grammar changes. But you could do it without too much fuss. Putting Clojure in the same category as Java/Groovy/Scala doesn't make as much sense to me, because Clojure is a fairly radical departure in programming style from these other languages. Java/Groovy/Scala are all different in their own ways; but a Java developer could look at Scala and grasp the basic idea of what's happening based on the grammar semantics alone (... I mean. Maybe. It depends.) But Clojure is a fundamentally different **grammar** and programming philosophy. It's very different. Just because it's a JVM language doesn't mean other members of JVM languages will be interested in it-- let alone understand it. As for Eta language, I don't know. That's outside the scope of my knowledge.
Like already mentioned it's a bad idea and a hack. https://blog.jooq.org/2014/12/08/dont-be-clever-the-double-curly-braces-anti-pattern/
Double brace initialization needs to die in a fire.
I understand your point. I don't like the approach of thinking that Java developers are lazy or mentally limited. Many of them have a degree in computer science and know lambda calculus. So learning programming languages that are a little bit different from Java could not be that hard. Those who don't know about the functional style will have to learn it, with Java 9 or with other programming languages.
There probably will be. The current theory is far from complete, it can't explain a lot of stuff, but it still the best one we have.
Oh, for the sake of Grace -- just move the damned initialization into a static method. There's absolutely _no_ reason to do it in situ. 
Strange, it says that release date is in January everywhere, but I've just bought it and received all files right away.
But many Java EE projects were also started after 2013. Do your research and pick those ;)
Too bloated and complex
Java 9 ones are only for immutable collections and Guava is on the way out (forour projects, in favor of apache.commons and Java 8). But you can use `Arrays.asList(...)`.
Complex is very wrong word, even C++ cant be called complex
very nice post as usual One of the best Java blog
Nice post. useful
Coming from C++, I would say: * friends (at the end in Java we define the function public) * #define and #ifdef for the compilation only. 
do you have an example showing an effective escape analysis? A kind of real world example?
Nothing specific, but the approach is going to be applicable for anything which goes out and grabs stuff from the internet. For example, mirroring common maven / nodejs artifacts is always a good idea to stop people downloading random shit, and creating a dependency / security quagmire that tools like OWASP go mad over. On a wider note, I’m a fan of giving project teams the tools they need to do their jobs (so, decentralised ALM) but providing that tooling as Docker images a dev team can choose to run - but have those images version controlled and managed centrally). But that can be hit or miss depending on the maturity of the dev teams - sometimes it is just simpler to provide that stuff centrally as a managed service. Swings and roundabouts. 
Stellar job as always. I do wish he would consider setting up an RSS or Atom feed, though.
Yeah, in that case you're up a challenge :). Why are you abandoning Guava in favor of Apache Commons? The overall trend, I feel, has been in the opposite direction for the past 6 years or so.
Check out the whole series, https://shipilev.net/jvm-anatomy-park/, there have been 4 new articles targeted at different kinds of constant folding in the past few days.
Refactor to triple brace initialization
When I really want to initialize a mutable object within an expression, I use a helper method like this: public static &lt;T&gt; T let(T obj, Consumer&lt;T&gt; augmenter) { augmenter.accept(obj); return t; } And then the example from the article would look like this: private static Set&lt;String&gt; INITIALIZED_SET = let(new HashSet&lt;&gt;(), s -&gt; { s.add("11111"); s.add("22222"); s.add("33333"); s.add("44444"); }); It lets you have an arbitrary block of initialization code when an expression is needed without generating pointless and problem-inducing anonymous subclasses.
[I won't click that link because maybe the author should check on his/her title skills](https://en.wikipedia.org/wiki/Betteridge%27s_law_of_headlines)
Apache Commons is a much bigger and more comprehensive set of libraries, while Guava is a single-size-fits-all solution that is much smaller. I use Apache Commons for quality-of-life improvements that live in the Lang subproject, like ObjectUtils, StringUtils, ArrayUtils, Pair, MutableObject etc. and I use other Commons libraries when needed (IO, Imaging, CSV, Math, Text etc.), but I also use Guava for its collections (Apache Commons Collections, while quite large, doesn't suit my needs). 
If you clicked it, you'd see the author's actual title is, "Microservices in Java? Never."
Before I read it, I knew what it said. 'java is heavy and takes resources' First of all, sure,you can get your rest service running on a flavor of the week language and save resources, but: It's tried and tested; It has proven to scale extremely well. Most Java frameworks are built with horizontal scalability in mind. You can spin new instances and drop others automatically and transparently with, for example, kubernetes. I can have your Java microservice up and running in a self contained Docker image and monitoring included in under 3 days with spring boot. I'd like to see you hire a sizeable team to work on anything other than java /.net
We were using Guava mostly for list initializers and the stuff around Optionals and the Fluent API which became obsolete with Java 8. From apache.commons we're using StringUtils, NumberUtils and especially the FileUtils.
This is old and has quite a few comments below that highlight the mistaken direction taken by the author. Specifically, he used the wrong frameworks and settings. We write microservices in Java and use very cheap VPS's to accomplish that without a problem. 
Nice approach, definitely better than the double braces initializer stuff. Small typo: Of course you would "return obj;" from the let method. :)
The article is from October. The auther did some follow up with different conclusion: * [Microservices in Java - A second look](https://hackernoon.com/microservices-in-java-a-second-look-460ba3909c44) * [Debunking the Java Performance Myth ](https://medium.com/@elliot_f/debunking-the-java-performance-myth-29b842955a24)
I pre-ordered on Amazon but it’s out-of-stock anyway. I might get the Kindle version.
especially since the author claims that you always require &gt;1gb of RAM per java service - which is not a true statement - even more so on the problem he states to be "REST API reading files and sending a reply". This points towards some implementation problems in their original design like reading the file to memory instead of streaming it into a file and similar.
Safe to say yes. Better question is whether 9 is used... not so sure on that one, with modules message with everyone.
I haven't found eBook readers to be all that great for text books. In my case maybe a larger screen would help. I have found PDFs and electronic books in Amazon's cloud reader to be very helpful. I can have the book up on one screen, and my editor on the other.
I'm not a super expert here, but I can roughly describe it. Let's imagine function that needs a data structure to do a computation, then after the computation is finished a single value, NOT the data structure, is returned. If the program originally wrote the data structure allocation using: DataStruct ds = new Data Struct(); Then by default this would go on the heap. However, if the JVM or JIT or whatever can determine that the "ds" variable will never "escape" the scope of this function (or any functions it calls ), then this allocation can be moved to the stack frame of the function. Since it's no longer on the heap, no GC is needed and the data structure's memory would be "return" or "freed" when the function returns and it's stack frame is no longer. 
I ordered my in October is was supposed to be delivered in the last week of November, then they changed the date to beginning of December and then to 22nd of December, it's 28th and I still dont have it :&lt;
Spring Boot can kill performance? Is the pope a catholic?!
I ordered it from Inform IT, and they just notified me it’s being sent by UPS.
What a ripoff 
And the authors title is better than this one ?
lol
Yep, I'm glad I went that route 
He's still right on file paths. I got caught a long time ago when my Linux code ran fine but barfed on Windows because of a colon in the filename I was writing to. 
Java is not going to prevent you from doing things like adding colons to paths when it is unsupported on some platforms. It will however, give you all the tools and support you need to do it correctly. So using File.separator etc. CAN you write unportable code in Java? Yes you can. But CAN you write portable code in Java that compiles under linux and runs unmodified on windows/osX? Yes, I do that all the time. 
Same here. They've also had the web version available for a few days. I've been reading through that. 
A code like the follwing one does not escape on my computer (i.e. slower than not allocating the array) static int doNotEscape(int j) { int[] arr = new int[100]; arr[0] = 0; int res2 = 0; for (int i = 1; i &lt; 100; i++) { arr[i] = i + j; } for (int i = 1; i &lt; 100; i++) { res2 += arr[i]; } return res2; } 
Link https://www.amazon.com/Effective-Java-3rd-Joshua-Bloch/dp/0134685997
New coverage includes * Functional interfaces, lambda expressions, method references, and streams * Default and static methods in interfaces * Type inference, including the diamond operator for generic types * The @SafeVarargs annotation * The try-with-resources statement * New library features such as the Optional interface, java.time, and the convenience factory methods for collections 
I was surprised to learn that Joshua Bloch was initially lukewarm to lamdas/closures being added to Java. He explains his reticence towards adding them to the language in [this interview](https://www.youtube.com/watch?v=ZOwHiGCzZjo).
Maybe you should be an actual programmer before blaming language for something :)
What the actual fuck? You never read entire file into memory all at once unless it's something like settings which I can't even imagine what kind of program could have a settings file that was &gt;10MB.
So how to you know it didn't escape ? Even just writing/reading 100 point in "memory" (or caches) will be much slower than doing an equivalent calculation in registers. http://people.eecs.berkeley.edu/~rcs/research/interactive_latency.html
Here I got better title than those two: "When should you give programming advice? When you yourself aren't garbage at it."
I don't mean to suggest they're lazy or mentally limited, but rather that they're already educated in their domain. You can do functional-styled programming in Java and Kotlin. And it's possible Java devs can learn Clojure, of course! I'm not saying they can't. But it'll take time, money, and it'll require throwing a lot of existing knowledge out the window. Learning english doesn't make you Shakespeare. I'll make one last point &amp; I'll shut up, promise: I work as a Java developer in an enterprise company. The technology decisions we make are business-value driven. So when our team looks at Kotlin, we see *value*. The language offers many benefits to reduce bugs. It's backed by Google and the Spring framework. And training our Java developers to use Kotlin is much easier &amp; faster than training them in a fundamentally different grammar.
I find Spring is just horrible for writing applications. Especially, when the applications need to be 100% covered by tests. A code base for a well tested application will have a 20/80 split for code vs. tests, and since Spring's support for tests is just horrible using Spring makes your tests completely detached from runtime. There is no need to improve Spring either. Former problems resolved by spring no longer exist, and JEE provides superior support for writing apps especially when it comes to CDI , Rest, etc.
Streams exist no? I mean what is he doing, concatenating all the file contents to a string?...
This has nothing to do with Java, rather, it's a result of developer's mindset who is gullible to believing that one needs to include a hundred of dependencies before even the first line of the project is written. Java eco-system provides many libraries and tools to manage dependencies easy and developers just don't estimate the added costs correctly. Many other languages, especially new ones, either don't have the eco-system or developers come into the project with more simplistic mindset. A simple Rest service can be written in Java without using any of the third party libraries and be very fast, effective and memory efficient. 
I bought mine on the publisher's site, informit.com, a week ago and got the e-book then. The print copy shipped today. Check it out if you're bummed about Amazon not having it.
Apparently wasn't so obvious to him.
In terms of cost of running a business. $5k/yr is a fraction of a developer's time. This is a really crappy excuse to rewrite. Not withstanding all the other more technical "arguments" seem pretty bunk. 
I'll give you my top items: 1. Rich and robust libraries. Just look how many are on maven central 2. A packaging scheme that makes sense and is built-in 3. Popularity of language means nearly everything I would want to work with has java language bindings. 4. Availability of other languages to run on the same VM and be interoperable (scala, groovy, kotlin, jruby, jython, etc...) 5. Never a bad choice for someone looking to become a professional developer, lots of jobs 6. Robust reflection/introspection system 7. Tools like asm, cgilib, etc make it easy to make powerful extensions/libraries 8. With Maven (and gradle for the most part), a predefined structure for source files. 9. While more verbose, it's difficult to write really terrible/unparseable code. I personally find the code the most readable. 10. Good mix of backwards compatibility, new features and IDE support. 
set 10000 if you prefer A real escape analysis should define the array on the stack, so only 1 computation and that's it. So you should see no difference between this allocation ad no allocation at all (i.e; the array as parameter). 
Nope, this is bad and the author should feel bad. 
Would this be a good resource for someone who is trying to brush up on java knowledge and practices?
That ain't a great deal, I reckon you could read a decent blog series and just re-read Ed 2.
on [google play books](https://play.google.com/store/books/details/Joshua_Bloch_Effective_Java?id=BIpDDwAAQBAJ) as well. Not as cheap as amazon, though
An excellent resource!
**Sidebar:** **Do not post tutorials here!**
This, it doesn't really matter if the costs are a bit higher for the hardware if it makes it easier to find developers (java is a larger market) and / or you can develop faster because of libs/frameworks.
It's definitely an intermediate to advanced book. Mostly it'll take you from an intermediate Java developer to an advanced developer. It's also required reading for any Java developer.
[removed]
I thought static finals would not be constant folded as they could be modified using reflection. IIRC there are magic java.* packages where the compiler has been hacked to tell it that final means final.
I'd even go so far to say it has a lot of great general best practices. I don't write Java anymore but still think of sections in that book. It did a lot to influence how I think of API design.
Without seeing the code, no one can say for sure, but, yeah that doesn't sound like good design. Static import is the correct way
I've been waiting to hear the reviews as to whether Josh has as much useful to say about the Java 7/8/9 features as he did for the Java 5/6 features in earlier (excellent) editions. He hasn't been immersed in the Java ecosystem for most of the last decade since leaving Sun for Google so it isn't a matter of certainty that he can still speak authoritatively on the topic.
That is terrible. Classic case of prefer composition over inheritance...
Maybe a bit off topic but how effective do you guys find learning through textbooks as opposed to online courses (e.g. Udemy, edX, Coursera) - I like learning with textbooks for other subjects but have never tried with programming.
The intention was probably to rely on the IDE to autocomplete without having to prefix with `Assert.` Seems like a case for something like [assertj](http://joel-costigliola.github.io/assertj/) instead.
Would it really make that much of a difference? I guess we need to use plain Java or at least a more lightweight framework?
This is one of the books that is critical for doing Java programming well. I use this regularly. 
Bloch was key to Google Guava. A lot of what’s in Effective Java is included in Guava. I’m withholding judgment on his take on Java 7:8:9 but I expect to level up my game from this book as I did from the first. 
I surmise, a reduction from 1 Gb to 64 Mb indicates that the 1 GB service suffers from design issues rather than the implementation language as T=the author does not bother to explain these astounding memory savings. The thesis that Java should be never used for microservices looks to me like sensational nonsense. 
Dealing with static imports can be annoying (or was in earlier versions of various IDEs) so extending might be a good way to deal with it, you are not losing anything anyway. No need to be fanatical.
It's probably a holdover from when the test classes had to extend TestCase. When you did that, you got all the assert methods at the same time. So extending Assert would feel the same and your asserts would read like they'd been statically imported. But no, there's no good reason to do it and there are good reasons not to. Like having base classes for your tests that have common member variables and initialization code that subclasses share. I've used that a lot for tests that initialize spring.
..paperback when?
yeah it's too much code to share, but I felt puzzled reading through it. I'm changing it as I find it but just wanted to get a read from y'all here to see if I was overlooking something obscure.
how is dealing with static imports annoying?
[Here](https://hackr.io/tutorials/learn-java) is a list of community curated Java Resources
Just preordered a few days ago, and I'm excited to read it. Any chance for a refresh of Code Complete (3rd Ed) next?
Just released yesterday
He had some good reviewers though. :-)
Thanks for your response. Am I right in saying this book isn't really for a beginner?
I ran into this 'pattern' on a project. Code was written by a large 'consulting' company here in Holland where the unit tests for the code were written by a separate team of 'test consultants'. These people were just taught the basics of the grammar well enough to be able to write tests. All the tests inherited from a 'base class' that inherited from Assert. The base class had hundreds of additional assertion methods on top of what the Assert class has. Basically these were people that were taught "inheritance equals code reuse" and figured you needed to inherit from something to be able to reuse code. Fortunately for us the code coverage was horrible: they mainly seemed to have focussed on the getters/setters of POJO's and got stuck on the actual business logic, so we were able to just get rid of it altogether. 
I'm pretty sure that the closures proposal Bloch discusses in that interview is the "BGGA" proposal (named for the initials of the authors). It's quite a bit different from the lambdas that eventually went into Java 8. In particular, the BGGA proposal adds structural function types to Java's type system, as opposed to nominal types like everything else in Java. Another big feature of BGGA was "control abstraction" which is some support that allows one to use closures to create new control constructs. The argument was that adding something like try-with-resources to the language is unnecessary; given closures and a mechanism for user-defined control structures, something like try-with-resources could be created as a library-level construct. Needless to say, this would have added considerable complexity to Java. You can find out more about BGGA at [Neal Gafter's site](http://javac.info/). The OpenJDK discussion list is [closures-dev](http://mail.openjdk.java.net/mailman/listinfo/closures-dev). The closures debate raged through 2007 and 2008 over several different proposals, with BGGA and CICE being the front-runners. (CICE is Concise Instance Creation Expressions, which was championed by Bloch.) This article by Brian Goetz describes the two proposals: https://www.ibm.com/developerworks/java/library/j-jtp04247/index.html Some additional perspective is given in this article by Angelika Langer (of the [Java Generics FAQ](http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html)) and Klaus Kreft: https://www.javaworld.com/article/2077869/scripting-jvm-languages/understanding-the-closures-debate.html The discussion stalled for a while until Mark Reinhold jump-started the debate with his Project Lambda proposal at Devoxx in November 2009: http://cr.openjdk.java.net/~mr/lambda/straw-man/ This eventually led to the lambdas that were delivered in Java 8 in 2014.
Extending something to use public static methods is pretty useless. At least do Assert.assertX if you don't know how to use static imports.
 import com.sun.net.httpserver.HttpServer; public class Server { public static void main(String[] args) throws Exception { HttpServer server = HttpServer.create(new InetSocketAddress(8080), 0); server.createContext("/", new MyHandler()); server.setExecutor(null); server.start(); } HttpServer, is this really a thing or is he using java like he is used to use go? 
Java has changed a lot since 2011.
Unless the file already contains a static import, IntelliJ just does not autocomplete it easily. https://i.imgur.com/43OZ3I4.png Default test class template contains `import static org.junit.Assert.*;`, but you have to disable Optimize Imports on Fly", and make sure not to optimize imports before using some of them... Extending is way more convenient in IntelliJ unless they implement https://youtrack.jetbrains.com/issue/IDEABKL-6031 or someone makes a plugin.
This is just "old style" Java code, probably written by someone who (still) isn't aware of the static import feature. In the old days, people used to write interfaces with constants all the time: interface A { int CONST1 = 1; int CONST2 = 2; } interface B { int CONST3 = 3; } And then "implement" those interfaces in order to "conveniently" import the constant namespace: class C implements A, B { void m() { System.out.println(CONST1 + CONST2 + CONST3); } } Of course, since Java 5
I laughed at the last paragraph.
In Eclipse, you can use ["favorites"](https://blog.jooq.org/2013/10/27/top-5-useful-hidden-eclipse-features/) for this.
In hindsight I can laugh at it too. Back then I felt more like crying ;)
I gotta write a plugin for this for IntelliJ.
first edition of ineffective java out today. topics include: 1. paying $500k to adobe for an AEM license 2. Installing AEM 3. debugging AEM 4. bashing head against wall until death follows
That was the correct way to do it in JUnit 3. See: https://stackoverflow.com/q/2635839/448068
Yes, the ecosystem and the libraries (with Java 8 and 9). The language, though? Not so much. Watch the talk, it's short and it mentions the bad parts of the language that are there and probably always be there.
Look at the use of operator overloading in the new filesystem library in c++ STD ...
I'd be surprised if it doesn't exist. Otherwise, should be a feature request!
I think they tend to make things a bit complex when simplicity is the key. As the complexity tend to produce bugs that are hard to be detected later. I know there are programs that might help with it, such as checkmarx and others but as I see it, you have to keep things simple in order to achieve better solutions.
If you wish to focus on the parameters, java allows you to have a "constant reference" to the object being passed in, but not pass it in as a constant (and thus immuteable as far as the method is concerend) object. C++ const can mean that the object cannot change, that the reference cannot change, or both. (const const)
https://youtrack.jetbrains.com/issue/IDEABKL-6031
Yes, if you code Java you must read this book.
If he wanted something lightweight instead of Spring, I see no issue with it for testing. I would have chosen [light-4j](https://github.com/networknt/light-4j) (former light-java).
hm ok
First time doing thing like this, would love any constructive feedback on the article.
Where are the interns when you need them huh :)
Python is like this, definitely learn how to use it if you haven't already yet. It's perfect for pretty much anything from automatic boring stuff to prototyping any kind of application or even using it as a part of your final project. It also can run pretty much anywhere, is quite mature, and it's core is simplicity, that means you can be very productive in it as everything actually IS simple to use.
Cool. I added a comment there
But please do not change the code just because the IDE can't deal with it... Type "Assert." or change IDE.
Thanksfully they went with the solution we got now.
That's actually a pretty solid find. I don't use IntelliJ and I've only seen optional probably like once in my career, so I like that you go over it with examples in the beginning. The pictures are a nice touch too. The best part is, it isn't too long. I cannot explain how much I absolutely hate when I need a refresher on a simple concept like inheritance or reflection, and some autist feels the need to write 14 pages explaining something that can be easily shown with five sentences and a picture . Good on you, OP.
oh hm didn't know that I've never used anything but 4+
Don't do this. Either never let the getter return null or use annotations.
Not really. Extending for this (aka "is-a") implies your test cases are Asserts, which they're not. It's misleading, and doing misleading things to save effort is quintessential bad coding.
Agree with cloud reader, when i am in readin mod i turn monitor 90 degree and make background sephia but i think copy paste doesnt work on clous reader
I Disagree. The field remain the same so there is no problem with serialization (if you serialize by field, which you should) or equality (why there will be?). I don't see why there would be problem with any of other libraries. Using the Optional way, makes the api much more readable, enforced in compile time (annotation aren't), forces the developer to take action and you don't have to look on the source code to see if return type is annotated just by the method signature. As I said, this isn't silver bullet and you shouldn't use it anywhere. The annotations have it's place and sometimes are preferable (for example for parameters they are better than optional, don't use optional for parameters). But it a good technique that I found very useful. Regarding the API, I don't know exactly what you mean by that. If you talking about the function signature I think it's better. Much more clear the the annotation. If you mean the Optional API, I absolutely love it. For Stream api lovers, no reason to dislike the Optional api. Instead of stuff like Object o; if (data.getX() != null &amp;&amp; data.getX() &gt; 5069 &amp;&amp; data.getX() &lt; 380) { o = data.getX(); } else { o = DEFAULT; } You can write much more readable code: Object o = data.getX().filter(x -&gt; x &gt; 5096).filter(x -&gt; x &lt; 380).orElse(DEFAULT); Or any other combination.
Thank you!
You could try posting in the IntelliJ subreddit. Posting it here almost makes it seem like the IntelliJ crowd is desperate to gain new users.
Java on the desktop has gotten a bum deal. I have no idea why Electron sprang into existence when a perfectly fine cross-platform GUI toolkit already existed.
No. Extending your test base class which delegates method calls to various static methods does not imply anything like that. There is nothing misleading about that. 
What would null object store? Isn't expecting null to be an object is like trying to rob a hobo of his imaginary phone? Because null means that there's no reference to an object, so why would you want to point to an object when the point of null is to indicate that there isn't one?!
I was not familiar with the Intellij subrredit. So thanks for that! I done as you suggested. Intellij is great but I had no intention of converting any one to Intellij. I think the first part of the post will be (hopefully) helpful to all Java users. 
Could you elaborate on cases where it's a problem? For example I implemented bitarray for my project in uni without ever working with java in before, using signed byte array and it worked as I wanted it to as in memory it's still same 8 bits, only the integer value of it is represented differently.
It's easier for me because the structure of a book makes recall a lot better in my experience. I've also realized that physical books are easier. I love having a pdf and a physical copy, the pdf for searching and the book for actually reading the content. 
&gt; I don't see why there would be problem with any of other libraries. Many depend on POJO getters/setters. &gt; or equality (why there will be?) If you have a value, you need to either pack it or unpack the Optional. &gt; Using the Optional way, makes the api much more readable It gets cluttered &gt; forces the developer to take action It always does so, even if not necessary. &gt; no reason to dislike the Optional api There some things, e.g. `.get` method, no `ifEmpty`. &gt; i find more readable and maintainable code It's inflexible and annoying to debug. If you so want a one-liner, use the terniary operator.
I believe what they are referring to is that in Windows the popup trigger is detected on mouse release, and on a Mac it is detected on mouse pressed. So MouseEvent's isPopupTrigger() method needs to be called and return value checked in both mousePressed and mouseReleased for cross-platform goodness. So this would be a surprise to someone that doesn't know this, but is trivial to handle once you do know this. I actually haven't checked this lately in Oracle's JVM for the Mac but it was that way in Apple's JVM. I just got used to checking it in both places I have never bothered to see if it is still true after Oracle took over the JVM for the Mac.
You could say the same thing about `@formatter:off` and comments which disables IDE inspections... and it would be equally moronic.
This is ... not a good use of `Optional`. As per [Brian Goetz](https://stackoverflow.com/a/26328555): &gt; Of course, people will do what they want. But we did have a clear &gt; intention when adding this feature, and it was not to be a general &gt; purpose Maybe or Some type, as much as many people would &gt; have liked us to do so. Our intention was to provide a limited &gt; mechanism for library method return types where there needed &gt; to be a clear way to represent "no result", and using null for such &gt; was overwhelmingly likely to cause errors. &gt; &gt; For example, you probably should never use it for something that &gt; returns an array of results, or a list of results; instead return an &gt; empty array or list. You should almost never use it as a field of &gt; something or a method parameter. &gt; &gt; I think routinely using it as a return value for getters would &gt; definitely be over-use. 
It's not the same. Code formatting doesn't change the code design. Another example would be making fields and methods public just for testing purposes.
&gt; Many depend on POJO getters/setters. I like it less that library is depended on getters/setter. For example when using JSON serialisation, I prefer to serialize by the fields. It forces you expose information that you don't want it, clutter the code with a lot of getters/setters. If your object is restricted by such library, you don't have to return Optional. &gt; If you have a value, you need to either pack it or unpack the Optional. If you look on my examples, only the getter returns Optional, the backing field remains the same. Your equals (where the equality should happen) remains the same. &gt; It always does so, even if not necessary. It's more code. More code is more error prone. - If it is not necessary, then don't use Optional! Use it only when the value can be missing for some design propose (sometimes the client don't send some field, for any reason). - The code with Optional takes less line of code. &gt; There some things, e.g. .get method, no ifEmpty. I will take my statement back, there some bad stuff in Optional api but in general I think it is good. &gt; It's harder to read This is subjective. Probably the same stuff can be said about Stream vs For loop. I find it easier to read. &gt; , inflexible Disagree. I find it easier to insert/remove a filter, map operation to Optional (or stream) chain than changing an if condition. Especially if you write it in the following way (which I didn't do it because t writing code in reddit isn't fun): ` data.getX() .filter(x -&gt; x &gt; 5096) .filter(x -&gt; x &lt; 380) .orElse(DEFAULT); ` &gt; annoying to debug This is can be true. But the equivalent code isn't much easier. &gt; If you so want a one-liner, use the terniary operator. Which will really make it harder to read, inflexible and annoying to debug.
I modified the code a smidge to add a isPopupTrigger() check and ran it on my Mac and did a right-click and this is the output: mousePressed Popup Trigger? true mouseReleased Popup Trigger? false mouseClicked Popup Trigger? false On windows, if I remember correctly, isPopupTrigger would report as false on pressed, but true on released. I am unsure of its behavior on linux.
I like Brian Goetz but I didn't find in his comment an argument why would ` String getX() ` Is better than ` Optional&lt;String&gt; getX() ` (If by design X indeed can be missing and therefore null object) I think the second is better, more expressive. If they didn't intended it for that, I still think the code is helped by this. Also, in the following article by Oracle: http://www.oracle.com/technetwork/articles/java/java8-optional-2175753.html They seems to use Optional for such purpose in their Computer class, and demonstrate the advantages of optional getter vs traditional getter for such cases. (I added this and the article linked here by /u/_INTER_ to the post)
&gt; There some things, e.g. .get method, no ifEmpty. If you want to run code when optional is empty, you can use a regular `if` block. if (!optional.isPresent()) { // code } No need for a separate method, because there is no value to provide, unlike `ifPresent`.
It depends on the JSR you're part of and your role in it, honestly.
i like this idea. Is this for java only ? 
`ifPresent` expects a Consumer and let's me avoid the horrible if (!optional.isPresent()) { Foo foo = optional.get(); // do something } In Java 9 there's `ifPresentOrElse` but `ifEmpty` would have been more flexible.
Your not even getting x, but Optional of x. The article is not done by Oracle engineers but some Indian PhD. He's even using Optional in his fields...
&gt; If you look on my examples, only the getter returns Optional, the backing field remains the same. Your equals (where the equality should happen) remains the same. * You have a discrepancy of the field and the getter * You often don't check equality inside the class in question &gt; If it is not necessary, then don't use Optional! Is what I do and I don't wan't to deal with such code of others either. That's why we have an argument. &gt; I will take my statement back, there some bad stuff in Optional api but in general I think it is good. Agree. It has it's purpose &gt; I find it easier to insert/remove a filter, map operation to Optional And that's all you can do, hence inflexible. If you need to do more complicated things, you need to either move it into a method or you're screwed. For instance returns or exceptions. &gt; But the equivalent code isn't much easier [to debug] Well you debug as usual. &gt; Which will really make it harder to read, inflexible and annoying to debug. Exactly, but it looked like you were adamant on creating one-liners and sell it as more readable. 
If x is null, you're not getting x also, without a way to express and enforce the consumer to treat this. I've no idea why the nationality of the person who made the article is relevant. The article is not perfect but he clearly make a good case why the optional api version is better than simple api version.
Again, there is no value to provide. You don't want to call `optional.get()` after checking if an optional is empty, because... uh... it's guaranteed to fail.
There is nothing on the site except for an elevator pitch and a stock photo. &gt; I really want to do something good for this awesome community. If that's the case, I don't understand why visitors are required to "request an invite" before they can interact with the site in any way.
I'm checking if its present.
In Java 9 I can do: `optional.ifPresentOrElse(x -&gt; sucess(x), () -&gt; error());` But I find it would have been better if I could just write: optional.ifPresent(x -&gt; sucess(x)) .ifEmpty(() -&gt; error()); I could omit `ifPresent` if I only wanted to handle the error case. Also I could use `ifEmpty` as a method reference in Streams. The article is incredibly aweful.
&gt; Is what I do and I don't wan't to deal with such code of others either. That's why we have an argument. I do, I used it and prefer the one with Optional. It state the intention better, provides better safety and allows to use the optional apis which I find useful in many cases. &gt; Additional your beautiful chain gets immediately messy once you need to filter on a property of x but retain x in the chain: You can solve this issue if you have method on x that does this check. Law of Demeter stuff. This will help make the code better. &gt; Well you debug as usual. If you have several conditions on your filter, single step of debugging will go all over them at once. If any of the condition calling a function, you are in bad place. You can easily get lost on which condition you checking. You have alot of unneeded information like not null check and this &amp;&amp; or || that you can easily get lost. &gt; Exactly, but it looked like you were adamant on creating one-liners and sell it as more readable. one line != more readable and one line != less readable The stream api made essentially a lot of for loops one lines and made them more readable. In some cases it didn't. But if you ask me, I find a one line that state if the value is present take this value else take some default value, more readable than 1 or 4 lines (if the if statement is short enough) that does the same. 
Also regarding your example, the if not null version would like something like this: if (data.getX() != null &amp;&amp; data.getX().getY() != null &amp;&amp; data.getX().getY() &gt; 100) { // take X } else { // take default value } This is not better.
Thanks for posting this. Always love anything from Josh Bloch. The bad parts weren't that bad, really. The only one I've bumped into is unsigned primitives. I thought he might mention my pet peeve, which is that fields are package-private by default. How often do you need a non-private field? It would have saved me a lot of typing and visual clutter over the years if fields had been private (and maybe even final) by default.
No problem! And yeah, they really aren’t. As Brian Goetz stated, you’ll be able to more efficiently create unsigned types of your own with the introduction of [value types](http://openjdk.java.net/jeps/169). Mark Reinhold said that Java managed to get all of the defaults wrong, and still turned out to be of the most popular programming languages.
I was with you until your low-key racism.
A low effort way to get involved is to just join the open JDK mailing list(s). You can comment as you see fit without having to be vetted or provide any credentials. I did this to oppose the 18.3, 18.9 version scheme nonsense and was glad it made a small difference.
Those are not standardized annotations. I realize they're getting more popular and more popular everyday, but in my opinion, it's not a good practice to clutter the code with non-standard practices. Especially when standard alternatives exist.
I created the site for the purpose of gauging interest in my project and gathering a list of interested users that I can notify once the project is complete, not for spam. 
No it will be for any programming language that can be taught or learned.
&gt; gathering a list of interested users That's not spam, but e-mail farming, which is nonetheless questionable practice.
I does feel like Spring is written by a bunch of young and enthusiastic developers so you'll fit right in. Find a bug ( I am sure that won't be a problem ) you can fix and submit a test case and a fix in a pull request.
I know I'm going to get a bunch of downvotes (let them come, let me bask in your temporary feeling of power for downvoting this comment) but I feel that getters themselves should be treated as a code smell. That's the real problem and why everyone feels they need an approach like this. All the OO principles support exposing behavior over exposing state. Having public classes with getters and setters is just one step away from having global variables. Who cares if they're attached to objects? You can still fiddle them up from anywhere. Instead of using an Optional&lt;SomeType&gt; getSomeType() on your class, how about give it the behavior that the application needs. In other words, not this: User user = userService.lookupUser(userId); String emailAddress = user.getEmailAddress(); EmailService emailService = EmailServiceFactory.getInstance().getEmailService(); emailService.email(emailAddress, subject, body); But this: User user = userService.lookupUser(userId); user.email(subject, body); Think about it! Go look at your code today and look how the getXXXXX() methods are used in your application. You'll see its just a bunch of global objects exposing state and the real work getting done in procedural code. Might as well go back to writing in C. This is where Ruby has the leg up on Java because the whole method paradigm for Ruby isn't "call a method on a class" but "send a message to that class and let it decide what action to take".
Right, sounds like JUnit 3. It predated Java 5, so there were no annotations and no static imports. So `YourTest` &lt;: `TestCase` &lt;: `Assert` and that's how your test code inherited all the assertion methods from `Assert`.
I don't think you necessarily need to contribute directly to spring itself unless for some reason you really want to. Why not instead find an open source project that is using spring and contribute to that? I'm in no way knowledgeable about the process of contributing to spring directly, however I'd have to imagine it's a very involved process and would lead you to get very specialized in whichever package you end up contributing to. Instead early on I'd think it would be better to gain a wider breadth, that way you'll have a much easier time transitioning to a job that uses spring.
No alternative exists, so use "non-standard" ones.
It's racism if you interpret racism into it.
&gt; Im not really sure how this process works. The fuck off back in your hole and come back when you have 5+ years of industry experience and have figured it out. Right now you are guaranteed to be a liability and laughed at. (For sake of yourself - don't ever ever ever mention having anything to do with PHP in civil discussion again. We all have our pasts, we don't walk around hanging them out of our trousers in your faces for a reason...)
Why even have a `User` class? Just let the `UserService` send emails. Or wait, why should there then be a UserService? Just put it all into a global god class and good is /s.
Ok, so start small then.Just bugs.Granted, to fix a single bug i might have to know how the entirety of the system works from the annotation processing to the various drivers, but it will surely be a learning experience. &gt;I does feel like Spring is written by a bunch of young and enthusiastic developers so you'll fit right in. Sounded like an insult at first hahaha
Is there some app that you could write in Java + Spring Boot and deploy onto Heroku or somesuch though? Then open source the code yourself to Github? Honestly as a senior engineer who interviews candidates I like to see those personal projects. For a hiring decision, that would be worth more in my eyes than the fact you fixed a bug or added an enhancement to the Spring Framework.
I do have reasons to contribute to Spring itself, some altruistic some less so. First of all, i love the tool itself and i think it has greatly helped java keep up with modern times, and it would greatly help everyone if it continued doing so.I enjoy making (extremely simple ones so far) Spring boot apps much more than any other languange or framework i have used.And all the other spring projects like Spring data or Spring MVC are incredible. Secondly, most of the work opportunities in Europe i found at a first glimpse mostly want their engineers to know Spring or JavaEE.Contributing to a random open source project might be a great experience but i believe it would be a tremendous advantage to tell the technical interviewer that im actually contributing to the tools you expect your engineers to know.Please correct me if my notion is wrong. 
Yes, that's true for literally anything in life. Don't try to deflect your racism with vague obnoxious statements.
I have written a small website that uses hibernate creating the database and inserting dummy data with an applicationrunner.It's a mix of products, companies and transactions in a very simple form. It uses spring rest, MVC with thymeleaf/sass/a tiny bit of js,a simple login, fetches trade data with Jackson's objectmapper converted to json and displays exports etc, does a XML soap request to fetch company info and just has some basic navigation footer etc. Its not ready yet, it's very small functionality-wise apart from what i mentioned and the code is all over the place since im experimenting, so i cannot upload that yet.However i would really appreciate your opinion on whether that sounds okay-ish for a potential new candidate.
&gt; &gt; I does feel like Spring is written by a bunch of young and enthusiastic developers so you'll fit right in. &gt; Sounded like an insult at first hahaha Pretty sure it was ;-)
Yeah I think that's great!
Im really glad to hear that, since essentially i got limited shots to travel for interviews etc, got to be as sure as possible. Ideally ill combine the above with some javaEE i know, and some OO code i got in PHP, along with quite a comfortable level with data structures and algo and ill hope for the best. Thank you for looking into my post and taking the time to reply.
Java EE went through a rigorous design process and versions 6, 7, 8 provide clean API and programming model. Spring, initially, addressed issues of J2EE earlier versions and adopted some of the newer cutting edge concepts such as dependency injection, etc. JEE OTOH took time to learn from various requirements and implementations and designed a much better CDI / WebBeans framework. I would recommend looking and learning JEE APIs first before trying any of the Spring. In my experience Spring is an impediment to building applications nowadays. 
I get the sarcasm and understand where it comes from. When people hear a recommendation to put behavior on an object they often think they're going to end up with an object that has too many behaviors. But this advice is echoed by Martin Fowler, Bob Martin, and lots of others. Check out https://www.martinfowler.com/bliki/AnemicDomainModel.html. The "too many methods on one class" thing is not a natural byproduct of the advice to expose behavior and not state. Too many methods is the byproduct of a developer not exercising their intelligence and agency to maintain good application design? Devs just need take some responsibility and refactor if a class grows into God class realm. Split it out. If it gets to that point, it should be obvious that there are sets of behaviors that go together and you get the fun of figuring out good naming. But God classes have nothing to do with the choice to expose behavior rather than state. A class full of 10 getters is just as bad as one with 10 behavior methods.
Just a few things to bear in mind. Spring is the home of many projects that aim at easing the development of enterprise-grade applications. Each of these projects have its own release cycle, repository, team, development rules and relation to other Spring projects. For example, Spring Framework tracks issues in JIRA, while Spring Boot uses GitHub issues. It also means that contribution rules and the overall openedness for community contributions may vary.
According to Brian Goetz: &gt; The answer depends, to some degree, on the question "what is a &gt; getter" -- there's a fuzzy line between "getter" and "method that &gt; returns something." Obviously, there are useful cases for &gt; returning an Optional from methods. But in real-world code (for &gt; better or worse), most getters (like, 99%) are just return x. In &gt; that case, returning an Optional from a getter means you are &gt; using Optional as your state representation -- and this is &gt; definitely not what was intended (and falls squarely in the &gt; "zealous overuse" category.) ) I'm not sure who contributes to the Oracle Tech Network, but I would go with Brian Goetz on this one, who *actually designed Optional*. I would argue that a DTO (which simply returns a contained value) that has a lot of missing values is designed poorly. That is, the fact that you need `Optional` is a design smell for DTOs. In fact, the `Computer` class in the article is a demonstration of a violation of the [Law of Demeter](https://en.wikipedia.org/wiki/Law_of_Demeter), since the method chain is deeply entwined in the structure of the "computer", making it far more difficult to change in the future.
**Law of Demeter** The Law of Demeter (LoD) or principle of least knowledge is a design guideline for developing software, particularly object-oriented programs. In its general form, the LoD is a specific case of loose coupling. The guideline was proposed by Ian Holland at Northeastern University towards the end of 1987, and can be succinctly summarized in each of the following ways: Each unit should have only limited knowledge about other units: only units "closely" related to the current unit. Each unit should only talk to its friends; don't talk to strangers. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Possibly it's just a fact.
Using non-serializable Optional in DTOs sounds like no-no-no to me. 
/u/karianna he seats on the Java Community Process (JCP) Executive Committee (EC). You can also join vJUG and it's slack group where Martijn is also active or London Java Community where we have mailing list when I'm sure there will be plenty of people who will be able to answer your question.
In my line of work we deal with a lot of bit maps and there is a lot of bit shifting for comparison and it is just clunky as hell to use an integer for bit masking into signed bytes. Or to use an array of integers if you are going to be bit shifting the signed bytes. My rule in programming is to make everything as obvious as possible and it is hard to do that in this case.
While I get where you're coming from, I disagree with this: User user = userService.lookupUser(userId); user.email(subject, body); Does it even make sense for the user object to be able to send emails? It sounds like a lot of mixing of responsibilities. Also, what if we need this user class elsewhere? Do we have to drag around email dependencies as well? I would argue that finder methods shouldn't be so generic that you have to pull a bunch of unnecessary information to satisfy all possible use cases. I mean, what's wrong with this: userService.findEmailAddress(userId) .forEach(emailAddress -&gt; emailer.sendEmail(emailAddress, subject, body));
FYI - it's expected that the paperback version is going to start being shipped in Europe during the first half of January.
Thank you for the information and experience! I've played with Python briefly and coming from Java the whitespace stuff really drove me nuts. It's definitely on my list of languages to learn once I feel more comfortable in Java.
I've ever really only stored bytes for a colour in an integer (RGB in first 3 bytes of an int), and it quite readable, so I don't know what you're talking about, could you give an example where it's really annoying? I know that most of the time we use bytes as 0-255 as any other number, positive and negative for real use case is either integer or long, and I would also like if it was bytes from 0 to 255, just like in every other language, java is pretty new to me (only ever used in uni for last 3 months until last week), and way different from C#, so I don't know that much.
I would second this. If you can show me a project you built and answer enough questions about it , pretty much this is a hire right here. Ideally this is something which is both front and back end and is NOT trivial. It doesn't have to be an ERP system or something enormous. But I need to see that you carried the concept far enough that you were not simply pasting example from the intertubes and not really understanding what was going on. more details: 1) I'd like to see perhaps 6 to 10 entities in the data model. 2) It should have a user sign up system. Including properly storing databases, and keeping track of users sessions. 3) You should have queries that show you understand how the database actually works, so I'd like to see at least one complicated join ( or equivalent in hibernate ). 4) If you are hibernate centric, I WILL be asking you about SQL. You need to understand both sides of that complicated beastie. 5) front end should ideally be an SPA, but if you are holding to a server side page generation, then I'm still going to ask you about javascript on some level. 6) Regardless of SPA or Server generated, I will probably ask you about data validation and I will ask you about concurrent modifications and how they are handled. This doesn't have to be fancy, I just need to see that you understand the dragons that lurk here. I think you are on the right track. Keep it up!!
That it was not designed for that, doesn't means it could not be used in that way or it shouldn't be used that way. Optional is a tool they gave us that we should used as we see fit, if it can help us solve a problem I don't see reason why not. Optional was existed before in guava, and existed before in different languages. There is a case when an data object can have multiple nullable fields, I can think of request coming from different client, expanding objects with new fields. Some of the cases might be fixed in some other way, for a part of them this would be correct but there exists, a that is not a small part, that the best way would be keeping/adding nullable fields and then I would argue that having an Optional getter is better than having simple getter that we can't really know if the field is null or not. I don't see how the visitor pattern could help, but this sound like overkill, that leads to over-complicated code. Also could computer change in future? Should it change in the future? 
If you serialize your field, there should not be problems.
Total newbie question, except for being forced on by libraries, does modern Java serialize anything? It seems an outdated concept where you force the other end to also be Java, basically.
&gt; if it can help us solve a problem I don't see reason why not. As Brian Goetz stated, you can use `Optional` however you want, he's not going to stop you. &gt; I can think of request coming from different client, expanding &gt; objects with new fields This should be an internal detail which is exposed through top level methods. In Domain Driven Design terms, you should define an [Aggregate Root](http://thepaulrayner.com/blog/aggregates-and-entities-in-domain-driven-design/) which provides query methods for internal structure, not getters which reveal internal structure. This allows you to maintain encapsulation, invariants and internal consistency. &gt; Also could computer change in future? Should it change in the &gt; future? Who knows, but you paint yourself into a corner allowing clients to tightly couple to a structural representation, such that any change now introduces the possibility of breaking clients who depended on the structure. This is a real problem which the Law of Demeter addresses. &gt; I don't see how the visitor pattern could help In the particular case of the example, the Visitor Pattern provides structured navigation of internal structure which decouples the client from knowledge of the internal representation of the "computer". For example, the API presented in the article returns `Optional&lt;SoundCard&gt;`, but what if we want to change the computer to have multiple sound cards? This is trivial to solve with the Visitor Pattern, but not easily solvable with `Optional` while still maintaining consistency.
Because for the empty case, you can just use a regular conditional. `ifPresent` is provided to avoid having to explicitly call `.get`, but this is not an issue for checking an empty case.
adoptajsr.org and jcp.org both have getting started guides 
Contributing code to spring core or spring boot tends to be tricky. New features go through thier internal team process. Even fixing bugs can be difficult, because they are usually very reaponsive to bug reports and fix them themselves quite rapidly. Its probably easier to contribute to one of the less popular or incubating side modules.
&gt; In my experience Spring is an impediment to building applications nowadays. I strongly agree. Fortunately, the only times I have to deal with it these days are when fixing legacy apps. Although unfortunately, some of the Spring patterns seems to have found their way into some Scala libraries. 
Pivotal only does pair programming. So to contribute to Spring you have to find a buddy and write code together while holding hands. It's weird but they insist on it.
See if spring has any issues marked first timers only: http://www.firsttimersonly.com 
Good to know. Off my list of companies I'd like to work for.
Yes, it's more like case-by-case study of certain idioms and practices, you have to be aware of them. It's not horribly complicated, but it expects knowledge of Java (including the standard library).
You have an issue with Spring but yet you spend quite a bit of time writing comments about it. Why do you care what framework others use? 
We run it along mutation testing.
What? Thats gonna be a hard one i literally dont know a single person who has ever worked with java.Also i hope the last part about holding hands is not mandatory lol
There are contributing guides for most projects, you can have a look at ie https://github.com/spring-projects/spring-framework/blob/master/CONTRIBUTING.md for contributing to spring framework or https://github.com/spring-projects/spring-boot/blob/master/CONTRIBUTING.adoc for spring boot.
So in your opinion i should switch to contributing to JEE? I actually like it more than spring since it seems clearer than spring, but isn't JEE just the api? So i would want to get involved with implementations like glassfish or tomcatEE etc
Thanks for this, it's a really helpful guide to the important basics parts. Im surprised to see these kind of standards.I was expecting implementations of data structures from scratch, complexity analyzing, scalable architecture etc, knowing most core java + javaEE + spring etc, knowing how java does the loading etc internally...Perhaps i overestimate how hard it is to find work, because (i really dont mean to brag) your list sounds a bit easy for a job! Thats a good thing though the more knowledge the better. Thanks again for your directions and your time. 
I'd rather contribute to JEE. In fact, I was on a servlet committee for one of the releases and quite liked the process. There are also competing implementations for JEE standards, many of them are in OS space. Heck, you could start your own if you'd like.
There are several reason why I am commenting on Spring. The main reason is that I think that people who dislike Spring don't spend enough time offering their opinion. I'd like to fix that today and speak out for what I think is rather large developer base that despite Spring. I feel that speaking against Spring had become almost politically incorrect and people avoid criticizing Spring. In my experience Spring sucks big time and I'd like to see it done away with in the next year or so.
&gt; Immutable classes and persistent immutable collections While we're at that - and I know it's not coming - a sane collections API. Scala did a good job in this regard.
&gt; (runs away quick before the flames start!) No need to hurry, it has to download half the internet and then a minute to start.
I know, I don't want do an `ifPresent` check.
https://mvnrepository.com/artifact/com.db4o/com.db4o
You are funny. Spring has lots of value. An anonymous person on reddit who insults people isn't going to "do away with" Spring. If you think it sucks big time, write up an article that talks about the issues that suck. I'm guessing you don't know it well enough to do that. But, go ahead. you can post the link to your article here. We'll wait... 
it's dead jim unless you're interfacing with an existing codebase that depends on it, i'd use something else
tried that its not working anymore but found a zip anyway
It could _maybe_ be marginally interesting if you told us anything concrete.
Don't hold your breath for an article. If you feel Spring has a lot of value feel free to anonymoulsly say so. When enough anonymous people say it sucks it will be done away with.
I hope with the incoming value types they simply bring in "UnsignedByte" and "UnsignedInt" or something similar. It would be nice if that was finally made a part of the language.
You can declare it sucks all you want. Without facts to prove it, it is meaningless. Your only "fact" about unit testing is completely bogus. The applications I write with have 100% code coverage. So your 5 day old account won't make a difference for people using Spring. Sorry. 
There are a lot of things where you need to know it exists and kinda when it applies, but for which if you need the detailed facts you can look them up. This is fine. I still do it after 20+ years of professional coding. But if you give a blank stare when I ask what a race condition is, I will get worried. 
Why do you worry so much then? Is it possible that deep inside you agree with my opinion? 
Look at the history of this PR: https://github.com/spring-projects/spring-security-oauth/pull/581 It is a tiny change that fixes a security hole in Spring. See how much time it takes Spring to accept it. Now you can decide if you want to be part of this process or not.
You're arguing against using getter in general, not about using optional getters vs normal getters (which is what my post is roughtly) about. This is a different discussion, an interesting one and i think was on this reddit in recent time. In some case, I agree that there might be worthwhile alternatives. In some cases, I would say using the simple option is better. It usually more simple and is easier to understand. &gt; In the particular case of the example, the Visitor Pattern provides structured navigation of internal structure which decouples the client from knowledge of the internal representation of the "computer". In this case the client wants to knows some information about the computer, so it already knows the internal represntation. Should he know it? Maybe or maybe not. But it's clear how benfecial the optional getter, and how the the code is much better. I yet to understand how the visitor pattern can be applied here and help me when I just want to query the computer for it's soundcard usb version. Also having a getter that returns just soundcard won't help you in refactoring. There some cases that even won't be catched by the compiler, such as stuff like this: ``` if (computer.getSoundcard() != null) { System.out.println(computer.getSoundcard()); } ``` I think in many cases having optional getter, would make refactoring more easy that some normal getter that is backed by nullable field. This express the intention much better and forces the developer in refactoring taking into account the nullability of the field, rather than running into it in testing/production. &gt; For example, the API presented in the article returns Optional&lt;SoundCard&gt;, but what if we want to change the computer to have multiple sound cards? This is trivial to solve with the Visitor Pattern, but not easily solvable with Optional while still maintaining consistency. But what if we don't? Wouldn't using the visitor pattern be overkill? What if when we decide to make a change, we see that a different pattern would fit the new requirements much better, wouldn't the visitor pattern would be just a bother? &gt; As Brian Goetz stated, you can use Optional however you want, he's not going to stop you. But just because you can do a thing, you should consider if you should do that thing. In this case, I don't see why not using it. I think there is clear advantages of using an optional getter against using a simple getter. Either in safety, readability of the code, intentation stating and maintainability. 
Hand holds or the highway migo
of course i know what a race condition is, im not so bad with CS related knowledge, its mostly the very specifics of spring or JavaEE that i will have to learn.And damn they are HUGE
I don't worry at all. Spring applications have paid for college for my kids, a house among many other things. I'm not threatened at all by you saying it sucks. You can say it sucks all day. I'll still happily be paid to use it to make apps my clients want well past the time you get tired of bashing frameworks you don't understand on reddit. 
&gt;Spring applications have paid for college for my kids, a house among many other things. Thanks for proving my point. Building Spring apps is expensive, time consuming and complicated. Well done!
Surprised he didn't mention generics as part of the ugly. Losing the type information at compile time is unintuitive and can be annoying in certain situations. It's an understandable decision to maintain compatibility, but still. 
&gt; You're arguing against using getter in general Not precisely. It's rather a question about how you design your DTOs. I honestly believe that if you need `Optional` for a DTO, something is wrong with the design. The fact that the computer example violates the Law of Demeter is a symptom. &gt; I yet to understand how the visitor pattern can be applied here This is the classic example of the visitor pattern: computer.accept(new ComputerComponentVisitor() { public void visit (SoundCard soundCard) { System.out.println(soundCard); } }); Now it doesn't matter if there are no sound cards, one sound card or multiple sound cards. It doesn't matter how a computer is internally organized, meaning you are free to change it. With Java 8, you can even do this: computer.withSoundCard(System.out::println); The idea is that you let the computer do the driving, you don't dig around its internals. &gt; But what if we don't? You say that now, but can you predict the future? What bother does the visitor pattern or visitor-like patterns impose? The entire point of using Aggregate Roots is to encapsulate internal structure to prevent clients from getting overly involved in details, which makes changes harder to make in the future. This is the entire point of the Law of Demeter and why encapsulation is fundamental to OOP. &gt; In this case, I don't see why not using it. Personally, if I came across the situation where I thought I would need an Optional for a getter, I would think something is very wrong with my design. If you feel differently, then go ahead. Brian Goetz isn't going to stop you. 
FWIW, I've moved away from that stuff as too big, too complicated, and too slow. Consider smaller frameworks. drop wizard for example.
Some of us actually consider erasure to be pragmatic. I think he would be one of them.
I haven’t seen any proposals for that yet, but I wouldn’t rule it out. At worst, we can just create our own.
Thanks for the input everyone! I am currently using the Ionic/Angular framework(s) for cross-platform app development. JavaFX and Xamarin are two other frameworks I’ll be checking out here in the near future!
[removed]
For me personally, a well written text book far out weighs what an online course provides. 
if this is for a newish developer then... I wouldn't want you to be hiring me then with that wish list which is pretty impracticable for someone new. Anyone new to spring aint going to be concerned with the deep dark details of freakin hibernate/sql or concurrency issues. Seriously, there is way more to worry about just starting off. You should be satisfied enough that they can get the jpa annotations working so the whole thing doesn't blow up and they have something on github that doesnt look like a 5 min youtube tutorial copy and paste job. To build a basic crud app with user auth is big job (it took me a month hacking around with spring security every day to get it all to work) before I even touched business logic. 
&gt; Not precisely. It's rather a question about how you design your DTOs. In have no problems with getters in data types (no behavior, no encapsulation), but with object types (behavior, encapsulation). I honestly believe that if you need Optional for a DTO, something is wrong with the design. The fact that the computer example violates the Law of Demeter is a symptom. Strongly disagree. If you didn't ever need an absent field for any data object, then there 2 other priniciples that vioalted : KISS and YANGI. Even so, there times when you don't control the data, and that data can have missing fields based on weather conditions or any other reason. &gt; This is the classic example of the visitor pattern: &gt; You say that now, but can you predict the future? What bother does the visitor pattern or visitor-like patterns impose? The visitor pattern is huge overkill for the problem at hand or for any problem that you just want to query data and return it. If you would use it for the problem at hand (querying some internal grandchild field of soundcard), you then vioalte law of detemer in the same way. Even if you just query soundcard, where there is no visible indication for this, then you vioalte law of detemer in the same way. You just wrap it with lambdas. And yes, you gain somewhat flexiblity but you would gain the same flexblity if for example you have getter that return list of soundcards, or list of cards and just filter on it's type. (And there would be no need for optional in such cases). This express much better the relationship between soundcard and computer. It allows you to do stuff that are really hard to do with the visitor pattern, for example taking only the first soundcard or the some soundcard. How would you do that with the visitor pattern? You can but that would just lead to a bad code. Instead the resutling code took more time to write, takes more times to use, is more complex, is not natural and any new developer to the code will have to spend time to see how the class is used and will need to adapt his need to this pattern. And if you decide that in the future, when you have better understanding of the problem, and you not just guessing the solution, that other pattern is the solution the visitor pattern will just hinder you if you want to refactor, or will just stay in the code because its hard to refactor it out. Nobody knows the future, then there is no reason to predict it or apply something that you have no idea it will help you in the future but ceartnily not now. &gt; It doesn't matter how a computer is internally organized, meaning you are free to change it and clients would be none the wiser. And then you have some client that only cared about one of the soundcards will have it's functionality broke because it never expected to have 2 soundcards. He will instert easy fix, becuase this a code that he didn't touch for over than a year and he doesn't remember well why. And it will work. And after a while, because you so confidended that you don't break anything in the client you change the behavior of the visitor to run asynchornicly because it will help this new code (or existing code) you wrote. And then the code is breaking. Sometimes it's good that client code is breaking, it helps you enforce that the client have the same assumtions about the data as you do. If you have a field that you see now is can be absent sometimes, wouldn't Optional would help enforce this, clearly express this relationship, will force client to treat the possibility of absent value? And moreso it helps you find where the this is broken.
Here you go: final Obj res; Obj x = data.getX(); if (x != null &amp;&amp; x.getY() != null &amp;&amp; x.getY() &gt; 100) { res = x; } else { res = DEFAULT; } I don't know why so many people are so reluctant to introduce locals. I think that's my #1 review comment.
&gt; Don't hold your breath for an article. Then why are you wasting time? Spring sucks. Java EE sucks. All software sucks. Nothing new or special there. But some software does allow us to be productive and Spring fits right in there. Somewhere below you claim that Spring makes you personally unproductive, that's totally fine. What would be wonderful is ideas about why it makes you unproductive and how that could be improved. But if you're going to rant against one of the most used frameworks without offering any insights as to why you're just going to waste your time. 
&gt; The language, though? Not so much. IMHO both the API changes (streams, time API) and language itself (lambda's) in Java 8 made a huge difference in how I use the language. So much even that I don't want to use pre-8 Java at all anymore. 
If you use Spark (the 'big data' stuff, not the 'web app' stuff with the same name) it's used extensively. 
Most things in modern frameworks tend to prefer serialising to json or other formats. It's not helped that Java deserialisation contains a security gotcha if you're getting data from a potentially untrusted source. https://www.owasp.org/index.php/Deserialization_of_untrusted_data
Especially as pretty much every tool that takes advantage of them allows you to define multiple annotations.
So now your user class needs to know how to email? No thanks.
Does every post in /r/Java start with a bunch of downvotes by default? I understand the default downvotes for articles such as the millionth time that someone just creates a spring boot application with a rest service in it, but this is actually something that wasn't on here before. Seriously guys, this article is a pretty ok introduction to a new way of bootstrapping cdi in a Java se environment. What about it warrants a downvote?
That’s incorrect. Pivotal Labs does, indeed. The Spring team – distributed over the entire globe – mostly uses pull requests and remote code reviews of those. External contributions are very welcome, as tiny as they might be.
a possible reason is that such post might be considered as a tutorial? And tutorials shouldn't be posted here, as stated in the right-side: "Do not post tutorials here! These should go in /r/learnjava."
Why?
No problem with locals, I might have used it if I wrote similar code. but is this code better than an optional version? Some thing like this: data.getX() .filter(XType::hasYWithValueThatIWant) // or you can name it to be better suited to your needs .orElse(DEFAULT) which translates: final Obj res; Obj x = data.getX(); if (x != null &amp;&amp; x.hasYWithValueThatIWant()) { res = x; } else { res = DEFAULT; } Here you say the same with more statements, and I think it less clear what the code doing looking for. Also another advantages is what if you forgot checking for nulls? What if it was just introduced to be on safe side and it is not really needed? Having optional getter can help avoid this.
Should be about right for me then. Thanks for the response!
I'm exactly the same! I always assumed that with the amount of online courses available and the popularity of them that they were the best way to go. It's not often you see books get recommended to beginners for example.
I prefer declarative code to imperative code but code doesn't exist in a vacuum. The context of Java is that your version is *vastly* more expensive than the imperative form. The imperative form was good *enough* for decades and that didn't suddenly become untrue with the addition of `Optional`. As for paranoid null-checking, since Java's type system isn't null-safe that's a people-problem you combat by understanding the data flow. It would be nice if Java's type system were better but it isn't.
There are reason to load a file into memory. If it's an integral part of your application and you know what size to expect. Because obviously having an entire file in memory is going to be a lot faster than streaming it from/to your hard drive. But you need an actual use case that requires speed over low memory usage and absolute safety that the file will not exceed certain memory limits you set for yourself.
&gt; I did this to oppose the 18.3, 18.9 version scheme nonsense Thanks!
Yeah so like I said... Settings file? Nothing else fits, the only applications I can think of that load entire files into memory are for example photoshop or blender, and the latter can manage this only because one single triangle is just 3 vectors, not a gigantic bitmap for every triangle.
You may get lot's of subtle issues i. e. with tomcat sessions or frameworks https://stackoverflow.com/questions/1746550/purpose-of-serialization-in-webapplication http://www.baeldung.com/jackson-optional Also, creating Optionals that come out of the method scope leads to unnecessary load on GC. So I don't believe it's appropriate advice for general usage. 
I really like the fast setup and development using Spring boot. What would be an equivalent?
&gt; If you didn't ever need an absent field for any data object Why does the data object exist? A DTO is a data transfer object. It defines a specific protocol between a sender and a receiver, otherwise it is an unfocused bag of values. Defaults should be provided by the sender and the receiver should transparently handle nulls. For example, if the DTO is meant to populate a template or populate a row in a database. In this case Optional gets in the way. The template will probably not know what to with the Optional, neither would JDBC. You'd have to write adapter code for no reason. This is what I mean by Optional indicates poor design of a DTO. &gt; The visitor pattern is huge overkill for the problem at hand What is the problem at hand? That is the entire problem. I just proposed an alternative, based on no context. This is all hypotheticals. But the important point the Aggregate Root should implement the requirement, encapsulating access to the internals. It is totally fine for a query method to return Optional, but the way it is done in the computer example violates the Law of Demeter because it takes away control of the process from the computer. &gt; will have it's functionality broke because it never expected to &gt; have 2 soundcards. The problem is, why does the client need to know such level of detail? You are demonstrating the precise problem that happens when you break encapsulation and reveal too much about internal structure. Now you have clients which have made detailed assumptions about internal structure. The breakage is more than a compile problem, and might require significant rework by the client or an inconsistent API with tons of corner cases (like the Windows API). &gt; If you have a field that you see now is can be absent sometimes If it's a DTO, where I would put a getter, I would argue that Optional doesn't buy you anything and will probably complicate interface code. If it's an object with possible missing members, I would put a query method on an Aggregate Root, which is not a getter in the DTO sense, and an intended use of Optional.
Shame that for their shipping cost I could buy another book locally.
One example where we load the entire file in memory (or rather its parsed contents, but it makes almost no difference): Comparing 2 files as a whole without having to stream through both files simultaneously. Given that, yes this could be solved differently and is quite an old solution, at the time when performance had the highest priority and the application did nothing but this file parsing and resultin data import. This doesn't apply to microservices - but you get the idea.
because fuck pair programming. Top comment obviously a joke though.
I am curious. If this is a "new" project, why use it since it is no longer in development?
It's worth noting that he's focused on JEE.
??? You're trying to tell me that generating hashcode for 1TB size file is done by loading it into memory all at once?
No, you're strawmanning. I gave you a specific scenario that isn't hashing at all, but actually comparing entries (whether that be 250 or 100k per file doesn't matter for now). There's always new entries, old entries have gone and some may have changed. Each entry needs to be validated seperately. Also, not 30GB - 300-400MB per file. Nobody was speaking about creating some simple checksums.
college
Yes, if that is a contextually relevant behavior. See https://pragprog.com/articles/tell-dont-ask
Why does every user object now have at best an email service object in it or worse, email configuration information?
Before static imports, it was also very common to put constants in an interface, and "implement" it, so as to avoid extra-typing. Developers are a lazy bunch. In general, it's a good thing, but not always...
Strawmanning? Do you even know why checksums are being generated at all?
Actually, you don't know that. What if the user definition was like this: class User implements Emailable { // etc. } How it implements Emailable is its own business.
what are the aspects of db4o that your professor or team liked about it ?
You can open an issue and it will be discussed if it should be added etc. I've, tried, to get a few contributions added but they've suggested alternatives with existing APIs or techniques in Spring. Adding to the side modules is a lot easier e.g. we've got PRs into Spring Rest Docs. 
Please do implement that and show us how we're all doing development incorrectly.
There's plenty of resources on these ideas. I've already referred to a couple. These two articles also may be helpful. In the end, it's the object-oriented instead of the procedural approach. If you want to stick with procedural, no one is going to make you change. I feel that it would be a shame, though, since a lot of problems come along with the procedural approach. http://programmer.97things.oreilly.com/wiki/index.php/Encapsulate_Behavior,_not_Just_State http://programmer.97things.oreilly.com/wiki/index.php/Missing_Opportunities_for_Polymorphism 
Thanks, I appreciate the links. I was already at jcp.org and didn't see the answer to the question of what its like to be part of the process and how much time it takes, but I'll make another trip through there.
Awesome, thanks, I'm in Seattle and there's a SeaJUG but its kinda dormant or hibernating.
I joined!
&gt; What is the problem at hand? The problem at hand was always the example in the article, getting the usb version of field that can be absent. It was shown in the article how using the optional optional was beneficial in writing a better version of the code. The visitor pattern didn't help at all. &gt; DTO is part of an interface between contexts And because data object is an interface, adding another dimenssion to that interface indication that some values can be absent is helpful. &gt; If it's a DTO, where I would put a getter, I would argue that Optional doesn't buy you anything and will probably complicate interface code. It buys you alot. You can write better code with it (or worse code, but that can be done always). Its provide you null safety (enforce it). 
If I cared to such degree (of using optional against not using optional) for performance over, what in my opinion, is better and more readable code, maybe I should think of using a different language that is more performant. But of course maybe in some critical path of your system Optional shouldn't be there and you should also forgo objects and use primitives. But in general code, the advantages that I find with using Optional, far eclipses any performance issues that might encounter. Also in future, Optional are going to be value type (as part of project Valhalla) so any performance difference would be negligent (if it isn't already) to non exists. 
Because they weren't in Java 1.
Sorry, but I don't see how using optional getter backed by a field that isn't optional (which the article points to) are relevant to the links you referenced to. The second one even clearly says: **Keep in mind that Optionals should not be used as fields and we are doing this to illustrate the problem.** If you serialize by getters than you might encounter different issue. Such forgetting to create this getter. So in general I find using field is the best way, the correct way, to serialize objects. Regarding performance, I wrote about this a little bit in difference post. There is performance difference because using objects, but this difference shouldn't make you write lesser code. And as said, the performance difference will be removed in the future with Optional being value type.
I'd start by asking yourself what are the goals you'd like to achieve? Would you like to contribute to one of the JCP specifications (JSRs)? Or contribute towards the JCP itself, i.e. work on the processes that make up the JCP? Or yet something else? I'd recommend to gain experiences with contributing towards one more multiple JSRs and take it from there. In terms of required time, it's really up to you. I think if a JSR is under active development, i.e. lots of discussions going on, API drafts to be reviewed, APIs to be designed,, APIs to be implemented in the reference implmeentation, tests to be added in the TCK etc., four to eight hours a week gives you enough time to make a difference as a contributor. As a spec lead you'll spend significantly more time than that (it's more or less a full time job in my experience if a JSR is actively developed, and less again once the dust has settled). One thing to keep in mind is your goal shouldn't be to be part of the JCP but rather to improve a spec or the process itself. I've seen some folks being on multiple expert groups without really contributing very much (or anything at all). That's not helpful of course. There are some helpful community resources [here](https://jcp.org/en/resources/contents). Also you can follow [@jcp_org](https://twitter.com/jcp_org) on Twitter; the JCP team are very friendly and helpful folks. (Disclaimer: I'm the spec lead of [JSR 380](https://jcp.org/en/jsr/detail?id=380) (Bean Validation 2.0).
Nobody is talking about databases and nobody was talking about checksums (which are generated as a quickcheck for whether a file is still the same) - I just explained why they AREN'T relevant here. The point of my example was from the very beginning that there might be cases where loading 2 files into memory entirely when you need speed over low memory footprint is the right choice. My example was having to compare the entire contents of 2 files BUT not the files in their entirety (so no checksum, no single hash per file). I have a specific example in mind because at my workplace, some code like this exists from when speed &gt; memory was a high priority some years ago. Let me try to explain again and hopefully this time in a way that you understand. You have 2 files, these files contain entries, whether these entries are each line (unordered), XML entities or JSON objects doesn't matter for the case at hand. You have no control over these files, they're delivered to you. Whatever content is parsed is later stored, but that is also irrelevant for the case at hand. You can't simply compare 2 streams byte by byte. You have an entry - yeah you can build a checksum for each entry, but then you have to stream your second file (for every entry, at least in the most rudimentary implementation), find the same entry, build a hash and compare the two. Are you actually saying that repeatedly streaming files contents is faster than loading them into memory and building intersections between HashSets?
He doesnt really like them and knows there dead its a object oriented module and think he just gave it to us to make it harder.
100K entries or more in your example... XML and JSON... I don't fucking know where you work, but... 100K elements and JSON/XML shouldn't ever be in the same sentence, not said by anyone sane at least.
Of course you can stream JSON the same way you can stream XML. It Objects have a start token, so do arrays - they have an end token. That's all you really need for JSON and XML streaming, as long as your buffer is large enough to hold an entire object of (un)specified size. I don't know where you work, but sometimes you have to deal with whatever a customer delivers. In our case, it's often large-ish XML files. There are constantly people on this subreddit talking about how they're still using Java 6 at work, and you are surprised that some people are still supplied large XML feeds, instead of access to an API?
Must be very small objects then. It's still not that good for big files. As for using old versions, no I'm not, people are lazy as fuck, some still use python2 even though python3 is 10 years old.
He was only taking about Java 1, so it's still as (ir)relevant as it was at the time.
I like it, have you ever done it?
You might be right, but it would have to be simply because it is so ubiquitous among enterprises. So many big non-tech companies hire a gazillion developers (mostly outsourced) to do integrations/middleware and they naturally pick Java because it is inexpensive, mature, and flexible. And, those C-grade developers are not the ones contributing to the community, they just do a little programming and take long lunches and go home at 5PM. They are not the ones developing in their free time with new/obscure languages, since those naturally have a smaller pool of stronger/more passionate devs.
yea and it severely limited my reddit browsing and stock trading 
JUnit’s examples and tutorials are canonical and they use static imports. Extending Assert prevents your team from inheriting from abstract test classes. This is useful for generic tests for interfaces with extending classes providing a factory method to create implementation instances to test and/or provide additional tests for implementation-specific corner-cases.
Nice! BTW, check kotlin HTML dsl (using type safe builders) https://kotlinlang.org/docs/reference/type-safe-builders.html
This looks great actually. Nicely done
\*jealous *of*
It seems like every JAVA thread, you're going to get at least one Kotlin fanboy, ready with a have-you-considered-Kotlin, or Kotlin-has-this-too comment.
You shoud have switched to Clojure instead!
I love it. Well done.
I get where you're coming from. I think it's because kotlin is just a much better language and everyone who has converted is trying to spread the news
As Josh noted in the introduction, this talk covers only the language features and design decisions that were in Java 1.0. He refers to a talk he gave in the afternoon entitled *The Evolution of Java: Past, Present, and Future*. Unfortunately I cannot find the slides or video from that talk anywhere on-line. I believe he gave the same talks later in the year at Devoxx 2011, and while some video from those was on-line, it now seems to have disappeared. However, I can find a summary of the Past/Present/Future talk by an attendee of Devoxx 2011. I wasn't there, but it seems like it was the same as the afternoon talk he had given at OSCON Java 2011, for which I was present. Note that the summary is in French, but Google Translate does a creditable job. http://blog.xebia.fr/2011/12/01/devoxx-the-evolution-of-java-past-present-and-future/
If you hang out in r/cpp you'll see Rust fanbois doing exactly the same thing. 
Remember a few years ago on stack overflow when every js question had a "and here's how to do it in jquery!" unsolicited response?
Java already had a previous library:https://attic.apache.org/projects/jakarta-ecs.html 
Nice. Looks a lot like [ScalaTags](http://www.lihaoyi.com/scalatags/), which I was using in Scala.js and quite liked. 
Yeah, but that thing is retired for a reason :)
How does this differ from Vaadin?
Reminds me of the following someone was working on for Java https://np.reddit.com/r/java/comments/3hu94j/html_in_java/
I suggest an alternate approach to using Google's [Allocation Instrumenter](https://github.com/google/allocation-instrumenter). Look at the JVMTI event [VMObjectAlloc](https://docs.oracle.com/javase/9/docs/specs/jvmti.html#VMObjectAlloc). It's not very difficult to write a JVMTI agent (I did [one in Rust](https://github.com/cretz/stackparam)). I'm tempted to implement an allocation counter myself that conforms to the Google API if I had the time.
How is it similar? 
Can you make a website with it like spring mvc? The equivalent of javaEE (JSF) seems kinda horrible to be honest
I don't know what the problem is with that. It's always good to know things. This is good to know.
Thanks for the link! I tried looking for information about that talk after he mentioned it, but was not very successful. As a side note, thank you for all you have done to help evolve the language and libraries! The work you guys do is really amazing!
You should not be getting downvotes. You are not alone in this opinion. It was controversially first proposed (that I recall) by Allen Holub in (https://www.javaworld.com/article/2073723/core-java/why-getter-and-setter-methods-are-evil.html)[2003], who's written some excellent books on OO design. Many of the objections then and now are purely practical (so how do you access x?), and the solution is to use OO design so that you don't need to break encapsulation by allowing someone to reach into your class to extract a value. 
Now make abstraction over JavaScript
I seem to recall Groovy allowed a similar syntax.
It would increase the size of the code considerably, but if a Element had methods for attributes you could chain, you could restrict attributes to only valid attributes for each element. You could also have a `customAttribute(String name, String value)` method to make it obvious that the user was doing something nonstandard. This would mean that attributes would come after the content though, which would be a considerable change and move attributes away from the element name. The upside would be method discoverabilty in an IDE.
Nobody ever gives groovy any love even though it has very similar builders for html/xml and json.
Checked it out. Looks worse. Thanks. :-)
second that ;-)
I actually started exactly like that but it was hard to know what attributes belonged to want in deeply nested structures. 
yep...for over a year now...run into some issues with TreeMap legacy stuff...other than that no problems
People just love using JavaScript for some reason...sigh
At least that’s a library for the same programming language 
Damn, that's cleverly simple and pretty cool.
Thanks, I appreciate your saying that!
[removed]
Anyone tested this ? How does it compare to OpenJDK ?
It's a simple virtual machine to interpret openjdk source code and learnt from hotspot, only a toy for fun, but infrastructure are enough to interpret classfiles which it supports. There's actually no comparison.
[removed]
React == JavScript This subreddit == Java JavaScript != Java **Wrong subreddit**
Great example of what kind of stupid things you can do with kotlins dsl capabilities. Overloading unary plus for template bodies? I mean I like kotlin, but some of the community is way too much into dsls.
You’re welcome! Be sure to thank Dr. Deprecator for me, too!
2007 - JSP, MIXING HTML AND JAVA IS A BAD IDEA. 2017 - LETS HAVE A FRAMEWORK TO MAKE JAVA LOOK LIKE HTML
&gt;JVM brought our minimum memory requirements for each individual instance of service ‘x’ to 1GB of RAM I'm not sure what kind of "JVM" the author is using. At work, we use Open JDK in our docker images and Dropwizard as the framework for developing RESTful services and I have developed services which require no more than 128MB of memory when we spin up their containers in AWS and they run just fine. The premise of that article is that Java services use "1 GB" RAM and I have not seen a single service that uses 1 gigs of RAM and we have over hundreds of them. It totally depends on what framework you are using to build the services and what do you want to achieve through a service.
Looks a lot like [j2html](https://j2html.com/examples.html)
And Ruby 10 yrs ago: https://github.com/erector/erector
If you are going to produce HTML from a Java programming, then I would prefer to do it programmatically, and not in a template language. That's just my opinion, but I've done a lot of JSP and a few other template languages. Template languages are great for simple things but not well suited to abstraction. 
There is also a [HTML combinatory library](https://jaspervdj.be/blaze/tutorial.html) in Haskell.
Yea, definitely a controversial subject. It used to be the same for JavaScript vs. HTML. i.e "everybody" knows that you should keep them separate. But then React came along and said "actually...". 
Like TypeScript, Elm or PureScript? Or JSF 2.3?
React came out and it felt like back to turbo pascal... No fucking way!
Also it's interesting to see some energy consumption comparisons with other solutions and realize, that JVM programs are doing quite well: https://sites.google.com/view/energy-efficiency-languages/results
Templates are fine, but most of HTML templating is retarded due to how HTML works. But it can work nicely, Angular 2+ is a good example.
&gt; Settings file? Nothing else fits, the only applications I can think of that load entire files into memory are for example photoshop or blender, and the latter can manage this only because one single triangle is just 3 vectors, not a gigantic bitmap for every triangle. Having in-memory tables for high-speed DB operations is pretty common. I doubt reddit/twitter/google/discord etc. don't use massive in-memory indexes. This is mostly because of the speed of RAM not because random access is a necessity. Anything that requires random access instead of a stream loads data in RAM. If you write an algorithm that needs to work on a big chunk of data and needs random access instead of working your ass off to divide the domain of the problem you just add more RAM. That's why for a problem that has been in 1960 there is a space optimized solution, and for the same problem in 2018 there's a speed optimized solution. A very common example are games which load the video and audio before the game starts instead of loading it on demand. Now, of course, there are situations in which the loaded data changes in time, but what you see is always, always created with something that was loaded beforehand. Doing I/O to draw ruins FPS. Hell, sometimes games go as far as drawing an entire map and then clipping the part that you see just so you don't get any lag if you suddenly decide to focus on a different part of the map. That may be extremely expensive but it is a perfect example of why people use random access instead of streams and compute extra stuff instead of only what is strictly necessary. So yeah, there are cases when high speed random access is actually necessary, that's why people invented it, so they don't stream the same thing all over again. It's what gets the complexity of an algorithm from exponential to polynomial and from polynomial to linear. Knowing when to use what is just basic stuff for any programmer, they teach you that in college in data structures and algorithms class.
I used your lib for my “traditional” web app project (not REST API based). I enjoyed it :) thanks.
Cool! Is it on GitHub?
From the article: &gt;All logic is factored out of the classes and tied together in one large, procedural method with a lot of internal if-then-else constructs. I've never seen that. Seems like the typical strawman to show the "one true way" to OOP.
Haha no unfortunately, it’s a proprietary app. related to Facebook ads automation :)
I'm in progress of writing a very similar library :) There a couple differences though (e.g. Attribute is not a subclass of Html). I'm taking ideas from Elm: http://package.elm-lang.org/packages/elm-lang/html/2.0.0/Html
It's still a bad idea to mix presentation and view. The difference between the '2007 approach' and the '2017 approach' is that the '2017 approach' doesn't force a completely different second language to try to enforce that separation.
Just wanna say this work was really valuable in figuring out more of how hibernate is extensible. I managed to do this in a different way with user types only thanks to vlads insightful blog posts.
This is neat. Nice job!
Looks interesting. Only a simple stop-the-world GC (and GC is the hardest part of JVM, IMHO), but the rest is there - even reflection.
Since they are both JVM languages, couldn't you technically use Hiccup itself in Java?
OR just write html?
Comparing what a game does to a database... I'll take my leave to a more sane place.
Eh? I wasn't comparing them, they were two different examples of when you want to load large amounts of information in memory.
Are there JVMs not written in C++ ?
Thanks. Hotspot's gc is too hard. I only imitate dalvik vm's simple stop-the-world （stop all except gc thread）and then collect garbage method. GC is a hard domain so I can only make a toy like this;)
I think implement a simple vm is not so hard. Java VM Specification points out that. I think every language can... but the industrial product may not, C++ or even Java itself maybe a better choice.
This looks really cool! Better than using webpack even. Thanks for sharing it.
1-8GB of assets for a single game is nowhere close to amount of data internet or any commonly used database has and has nothing to do with this argument.
&gt; start small then The other option to start to build up community recognition (regardless of whether it’s Spring, Apache, JBoss, whatever) is documentation work, which is often an underated form of contribution. 
What's the difference between custom jvms like this one and the non custom jvm(s)
Of course :) I have not seen any that would be more advanced than a toy project, though. But if you include [hardware ones](https://en.wikipedia.org/wiki/Java_processor), you would probably find some. After all, Azul C4 was only initially available on a specialized hardware. But even among "regular" languages other than C++ you could find some: https://github.com/maxmcc/rust-jvm
**Java processor** A Java processor is the implementation of the Java virtual machine (JVM) in hardware. In other words, the Java bytecode that makes up the instruction set of the abstract machine becomes the instruction set of a concrete machine. These are today the most popular form of a high-level language computer architecture. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
&gt; "I didn't eat a donut yesterday No, the correct analogy would be "I hadn't eaten a donut *before* yesterday", which would, as /u/grauenwolf correctly points out, imply you have eaten one since then.
The SubstrateVM, from Oracle, is implemented in Java. It's not a 100% compliant JVM though. JikesRVM and Maxine, where implemented in Java as well, and I think they were 100% compliant, but they were research projects.
If you read what I originally said, it was "Java didn't have constructors in interfaces before generics were introduced in 5.0, either." So if you really want to pick that nit, it would be "I didn't eat a donut before I ate a carrot, and I didn't eat a donut after I ate the carrot, either."
They're working on it as part of OpenJDK in [Graal](http://openjdk.java.net/projects/graal/) to rewrite parts in Java. There's also an engineer I know at Azul who is working on a sort of Java in Java in Java thing which will theoretically be able to apply JIT optimisations to the compiler and its runtime as well as your own code (plus Java is easier to use than C++, no question about it).
One of the biggest differentiators between the various JVMs in existence are the garbage collector algorithms and implementations. Most commonly used JVMs are written in C++, though there have been projects that attempted to write them in Java itself (with some minimal Java bootstrapping environment to get some machine code instead of bytecode when compiling).
Using rust as the main language is a good idea~ Azul C4 is very advanced in garbage collection algorithm. It implements real time gc. I heard lots of people using it give positive comments.
Thanks for sharing! I've learnt a lot.
My little project is learnt from hotspot which imitates its operation mode, and imitates dalvik vm's gc algorithm. Other custom vms I don't know but this one mimics hotspot's operation principle. Non custom jvms are huge projects, this one is only a toy. Besides, non custom jvm supports all jdk library but this one only support what I implemented, like simple multithread. If you use this one to run socket, that may be impossible. However it is not hard to support them because some native methods like sockets, are support by os. So we directly call socket lib is okay, but it will be naive because non custom jvms do a lot of optimisations and make them very robust. However I'm only a college student, my coding level limits the implementation:(. Also, non custom jvms has lots of optimisations on runtime bytecodes, using JIT instead of only interpretation. This one uses only interpretation so it is not effective. So they are not comparable;) We make toys like this, only for fun or learning real jvm;)
There are no non-custom or custom JVMs. The concept does not exist. There are, however, conformant JVMs and non-conformant JVMs (that is, it implements the specifications or does not). However, beyond that, some JVMs are better than others (even if all are conformant), and they differentiate themselves via JIT, via GC algorithms, etc. Essentially: look at me at how fast I can run this code, natively.
[removed]
Thanks for pointing out the fault. Actually it should be: stop very short time in milliseconds for TB level memory.
Yes, I read it. It makes no sense. Your analogy is still incorrect as if it were correct then you would have said "Java didn't have constructors in interfaces before generics were introduced in 5.0, and didn't have them after either". Since you said nothing of the sort your argument doesn't hold.
"Didn't have them after, either" was meant to be inferred from the rest of the thread (the "either" is really important because what else could "either " have been referring to in that context.) I expect that most people on /r/java would know that there aren't constructors in interfaces today, particularly in a thread which is discussing how there aren't constructors in interfaces. Sorry for not being completely 100% clear.
Thanks - I'm glad you like the idea :). The huge selection of books is exactly why I created the list. Wanted to read some books but didn't know where to start. The list makes it easier to decide.
I'll just leave [this](https://reddit.zendesk.com/hc/en-us/articles/204536499-What-constitutes-spam-Am-I-a-spammer-) here. You should really, seriously think about your behavior. Spamming **multiple** subreddits is never okay.
I have seen this article pop up today three damn times in my home page. And it happened last year as well. 
If you look at OP's history, you'll see that they literally have spammed lots of subreddits.
C4 is smarter than that. They put a GC marker inside the OOP so the code knows if the object it uses is about to be moved by the GC. Due to this worker threads cooperate to a certain extent with the GC thread. Thus achieving "real time GC" - a GC that happens while real work being done on the objects in memory.
* Spring MVC is a complete HTTP oriented MVC framework managed by the Spring Framework and based in Servlets. It would be equivalent to JSF in the JavaEE stack. The most popular elements in it are classes annotated with @Controller, where you implement methods you can access using different HTTP requests. It has an equivalent @RestController to implement REST based APIs. * Spring boot is a utility for setting up applications quickly, offering an out of the box configuration in order to build Spring powered applications. As you may know, Spring integrates a wide range of different modules in its umbrella, as spring-core, spring-data, spring-web (which includes Spring MVC, by the way) and so on. With this tool you can tell Spring how many of them to use and you'll get a fast setup for them (you are allowed to change it by yourself later on). So, Spring MVC is a framework to be used in web applications and Spring boot is a Spring based production-ready project initializer. Source :- stackoverflow
Cool read...
Anyone knows why item 73 of the second edition (avoid thread groups) was retired in this new edition?
This guy gets it ;) 
Nice work. I am developing some similar, but aiming for * Compile-time enforcement of HTML grammar, using marker interfaces * Templates have model type parameters, method references for model properties * JSTL like constructs (foreach, etc) * Rendering into any Appendable A unit test with sample code is here: https://github.com/guppy4j/web/blob/master/html-impl/src/test/java/org/guppy4j/html/tag/RenderTest.java Still early work-in-progress, with only a small subset of HTML elements and attributes supported.
The article says JDK10 is round the corner! How near are we to JDK10 release?
I was going through some of the react videos on Talkery (full disclosure - I created/run Talkery) and found this one which I thought would be interesting for you guys. I’m not a big java developer, but love react as a front end technology and the idea of separating your front end client from your backend service. [Direct YouTube link](https://youtu.be/P6rwKHnXUJI)
So what JVM runs the JVM?
JDK 10 is in ramp down now and planned for release on March 20th. http://openjdk.java.net/projects/jdk/10/
That's not really a valid reason. Generics were added to C# 2.0 and they managed to have backwards compatibility and not have type erasure.
It's a valid reason as to why they weren't mentioned in the video.
This article is trash. The content is simply lifted from [this DZone ref-card](https://dzone.com/refcardz/design-patterns). but even worse, author messed up and copied the image for Memento, but the text for Command.
* And the typos in the only original line: "*many plances*" * And this line links to github for a NodeJS project. Which is not Java. In the last twelve days, /u/ratneshsinghparihar kept submitting "articles" of the same blog/website and this NodeJS project/framework. This is spam to get people to know/use that framework.
Either another JVM or you can compile the Java to machine code so it doesn’t need a JVM to run.
We waited 3 (?) years for JDK 9 and now only half a year later JDK 10 will come out?
yes of course for unit test, but how about component or integration tests, or components out of your control?
So isn't this pretty much service testing within the testing pyramid?
You can get the native thread id from jstack, but you need to convert the nid field from hex to get the LWID. I wish the JVM would pass through thread names to the OS.
To me the interesting part is that it's the JVM implementation that decides how Java threads are mapped to OS threads. "Java is multithreaded" is not so black-and-white as it appears.
Eh, if the implementation always uses native threads (as they say), it's black and white. Also, the JVM itself is multithreaded (for garbage collection and just-in-time compilation) independent of any Java code's thread usage.
Der Thread Name sollte ab Java 9 auch an das OS weitergegeben werden: https://bugs.openjdk.java.net/browse/JDK-7102541
The thread name should be passed to the OS with Java 9: https://bugs.openjdk.java.net/browse/JDK-7102541
Until [Loom](http://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html) comes to reality and save as
I'm believe that on earlier versions of linux which didn't have mutithreading, that they did indeed use user threads. If you are doing an N:M mapping of threads though, you may run into some problems with native libraries requiring that your user thread stays with the same kernel thread or that two different user threads are mapped to two separate kernel threads. 
The solution described in the article is to mock the other services that this micro-service depends on. While this looks like "end-to-end testing" for the service itself, it is certainly not "end-to-end" for the whole system (which is much more interesting problem). So what happens if I really need to test the whole system (i.e. that spans microservices)? Performance testing would require that. Also an alternative to Arquillian-cube-docker is testcontainers. https://github.com/testcontainers/testcontainers-java
[Java had green threads in 1.1](https://en.wikipedia.org/wiki/Green_threads#Green_threads_in_the_Java_virtual_machine), but they were replaced by native threads in 1.2. Most languages that provide green threads struggle with blocking or slow I/O locking the whole program. Native threads avoid that by blocking in the child thread, rather than the main thread. The trade-off is that native threads are managed by the OS scheduler, which has less information about what kind of work you're trying to do than your program will. If you abuse threads (spawn more than you have CPU cores, for example), you'll pay a cost in excessive context switches. Green threads can optimize this as you don't need an OS context switch to change your execution context, just some stack management. For general purpose use, language designers would rather avoid very negative performance outcomes (blocking I/O), rather than an optimization that only matters in one programming paradigm (lots of nonblocking threads).
&gt;This should be an internal detail which is exposed through top level methods. In Domain Driven Design terms, you should define an Aggregate Root which provides query methods for internal structure, not getters which progressively reveal internal structure. This allows you to maintain encapsulation, invariants and internal consistency. How do you reconcile this with the JEP to provide fully destructuring pattern matching and the associated ADT capability? If Java's going to be a language that lets me bind variables in a pattern match down to the Optional level (`case Foo(Optional("someString"))`) then why are we still talking about encapsulating our DTOs? I'm just going to match on them anyway, extract their elements, and operate on them.
I haven't tested myself but this looks like a thing: http://docs.paralleluniverse.co/quasar/ 
Thread switch is 30ns in my 2015 i7 laptop. I'd like to see a non trivial application where this overhead is a real concen.
&gt; Anything that requires random access instead of a stream loads data in RAM. Actually, memory-mapping files or even plain old seek()+read() works just fine. The OS will keep frequently accessed regions in memory anyway. Manually copying large chunks of data from disk into resident memory is a waste of resources most of the time.
I fixed the terrible grammar: &gt;#How ***do*** Java ***threads map*** to OS ***threads***? &gt;***That*** JVM ***threads map*** to OS ***threads*** is a commonly read statement. But what does it really mean***?*** We create ***a*** Thread object in ***Java*** and call its start method to start ***a*** new thread. How does it start ***an*** OS thread? ***And*** how ***is*** the run method of the Thread ***object attached*** to the OS thread that is executed? &gt;To explain what happens inside ***the*** JVM, I have created a very small example at &gt;https://github.com/unmeshjoshi/jvmthreads &gt;Assume that we have to implement ***the*** java.lang.Thread class ourselves. What we will need to do is as ***follows***. &gt;##The Thread class. public class Thread { static AtomicInteger threadCount = new AtomicInteger(1); public void run() { System.out.println("Running Thread " + threadCount.getAndIncrement()); } public void start() { start0(); } private native void start0(); } &gt;***This*** simulates Java’s Thread class. It has only two methods, start() and run(). To create a new Thread, we just need to create a new Thread object and call its start method***:*** new Thread().start() &gt;The magic happens inside the start method, which invokes a start0 method which is declared as a native method. The ‘native’ marker tells ***the*** JVM that this is a ***platform-specific*** native method (written in C/C++) which needs to be invoked through ***Java Native Interface***. JNI is a native method interface specification for Java and it ***details how*** native code can integrate with the JVM and vice versa. (https://docs.oracle.com/javase/9/docs/specs/jni/design.html#jni-interface-functions-and-pointers) &gt;##Generating a header file for native method declaration. &gt;***The*** JDK has a tool called javah which generates a header file for classes declaring native ***methods***, which then can be used for native ***method*** implementation. Try ***the*** following commands***:*** &gt;A header file for ***the*** Thread class can be generated as follows***:*** &gt;&gt; cd src/main/cpp &gt;&gt; &gt;&gt; javah -classpath ../../../target/scala-2.12/classes -jni com.threading.Thread &gt;The native method looks like ***the*** following***:*** /* * Class: com_threading_Thread * Method: start0 * Signature: ()V */ JNIEXPORT void JNICALL Java_com_threading_Thread_start0 (JNIEnv *, jobject); &gt;The first argument is the JNI interface pointer as explained here. The second object jobject is ***a*** handle to the Java object on which the native method is called. In this case it’s ***a*** pointer to the Thread object. &gt;##Native C/C++ implementation. &gt;We need to implement function Java_com_threading_Thread_start0. This is implemented in threading.cpp***.*** &gt;##Creating ***Linux*** ***threads*** with pthreads. &gt;For creating threads on ***Linux***, we need to use ***the*** ***pthreads*** interface. ***Pthreads*** is part of ***the*** POSIX standard which defines ***a*** C language interface for creating and managing threads. Linux provides ***an*** implementation of pthreads. The thread is created by calling ***the*** pthread_create function. pthread_t tid; if (pthread_create(&amp;tid, &amp;attr, thread_entry_point, arg_to_entrypoint)) { fprintf(stderr, "Error creating thread\n"); return; } &gt;*tid* is the ID of the newly created thread. &gt;*attr* is ***a*** set of thread attributes we need to set***.*** &gt;*thread_entry_point* is ***a*** pointer to ***a*** function which will be called from ***the*** new thread***.*** &gt;*arg_to_entrypoint* is the argument to be passed to thread_entry_point***.*** &gt;The entry point function we pass to ***pthread_create*** is where we should ***invoke*** ***the*** Thread object’s run method. &gt;***To access the Java Thread*** object from a separate ***Linux*** thread, the entry point function needs to have access to ***the*** JVM JNI object and ***the*** global JNI reference to ***the*** Java Thread object. &gt;We do that by creating a wrapper object called JavaThreadWrapper***:*** JNIEXPORT void JNICALL Java_com_threading_Thread_start0(JNIEnv *env, jobject javaThreadObjectRef) { JavaThreadWrapper* args = new JavaThreadWrapper(env, javaThreadObjectRef); &gt;The constructor of JavaThreadWrapper gets access to ***the*** JVM reference and creates a global reference to ***the*** ***Java*** thread object. &gt;(To ***learn*** more ***about*** local vs global references have a look at &gt;https://docs.oracle.com/javase/9/docs/specs/jni/design.html) &gt;##Calling ***the*** Java Thread object’s run method. &gt;The entry point function when invoked in a separate thread now ***needs*** to invoke ***the*** ***Java*** Thread object’s run method. &gt;The code ***is as follows:*** void *thread_entry_point(void *args) { std::cout &lt;&lt; "Starting thread_entry_point"; JavaThreadWrapper *javaThreadWrapper = (JavaThreadWrapper*)args; javaThreadWrapper&gt;callRunMethod(); delete javaThreadWrapper; return NULL; } &gt;The run method is invoked through JNI ***in the following way***: void JavaThreadWrapper::callRunMethod() { JNIEnv *env = attachToJvm(); jclass cls = env-&gt;GetObjectClass(threadObjectRef); jmethodID runId = env-&gt;GetMethodID(cls, "run", "()V"); if (runId != nullptr) { env-&gt;CallVoidMethod(threadObjectRef, runId); } else { cout &lt;&lt; "No run method found in the Thread object!!" &lt;&lt; endl; } env-&gt;DeleteGlobalRef(threadObjectRef); //delete global ref before detaching the thread. } &gt;As you can see, we literally created a ***Linux*** thread for every thread object created. ***The*** JVM does something ***very*** similar. &gt;For reference have a look at following source files in the JVM codebase. You can ***check out*** ***the*** JVM codebase from http://hg.openjdk.java.net/jdk9/jdk9. &gt;The code for creating and managing threads is in ***the*** following files***:*** &gt;jdk9/hotspot/src/share/vm/prims/jvm.cpp &gt;jdk9/hotspot/src/share/vm/runtime/thread.cpp &gt;jdk9/hotspot/src/os/linux/vm/os_linux.cpp &gt;##Running ***the*** sample code &gt;Refer to https://github.com/unmeshjoshi/jvmthreads which has instructions to run the code. 
[removed]
It is, but sometimes it is worth it. I have built a non-trivial REST services using only a thin (custom) layer on top of either raw servlets or their native equivalents in jetty/undertow (embedded). Performance and memory footprint are hard to beat. This stuff is really *really* fast. Interestingly enough, the main reason to do this was not performance, but lacking support for non-blocking data streaming in JAX-RS. If you are restricted by your tools, build your own. Edit: I still use Jackson for JSON processing (with some custom token-stream based parsers/generators for selected objects, and ObjectMapper for the rest) and lots of other libraries of cause. No need to re-invent the wheel if there are good libraries available. The trick is to only add what you need, and not start with a full featured framework or application server from day one. 
Coroutine is different, it is a stackless implementation.
Thats is great. Since im a new grad self learning javaEE i probably dont see me implementing something like that in the near future haha. But its really interesting to see people doing such things from scratch, great work!
Isn't SSE a dead technology already? Why would anyone use SSE instead of WebSockets? (serious question)
This approach is not useful for most REST services out there anyway. Dropwizard is small and fast enough, and even full EE application servers are getting leaner and leaner nowadays if you choose the features you use carefully. Custom stacks like these are also a pain for new developers in the team, and a technical burden that wants to be maintained. tl;dr; Don't try this at work, unless you really have to ;)
I was mostly looking for a project to make to get me a java job easier, since i got no previous experience. And i have no ideas at all so i was thinking about implementing something low level like that just for the github points. Of course i wouldnt use it on a real job.
This is hardly an e2e test. It is mocking communications to external services, including parts developed in-house, it is more of what is called "component test". The mocked parts should be alive and kicking as the real deal to have a real e2e simulation.
Huh. I didn't know that. Thanks for sharing!
Thanks for this. English is the writer's 3rd language.
Agreed. If it includes mocking at all, I'd say it isn't even addressing true EndToEnd testing.
So, what is the answer?
B. Click the link to find out why
&gt; Correct answer is s = s + 1;. This expression is invalid because s and 1 on right hand side of expression (s + 1) are promoted to int. The result of int addition cannot be converted to short without explicit cast. For further details on promotion of numeric types read[ Binary Numeric Promotion.](https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.6.2) &gt; &gt; All other choices are using compound assignment operator +=. According to Java spec, the compound assignment expression `s += 1` is equivalent to `s = (short)( s+ 1 )`. In other words, there is an implicit cast to target type in compound assignment expressions. Therefore, all other three choices are valid. Checkout [Compound Assignment Operators](https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2) section 15.26.2 of Java spec for more details on compound assignment expressions. s += 1 `=&gt;` s = (short)( s+ 1 ) //news to me.
Yes, I would have assumed that others would be invalid as well for the same reason. You would think `s += 1.0` would throw an error because a short plus a double is a double.
I never really understood the JSP criticism. It has its place and is super simple, especially when using JSTL
It seems like in every **Java** thread you're going to get at least one Groovy fanboy, remorsefully reminding the kotlin fanboy that geoovy got it right, first
My company is using it for new projects.
This is the best tl;dr I could make, [original](https://www.ccn.com/switzerlands-blockchain-developers-receive-180000-salary-pay/) reduced by 82%. (I'm a bot) ***** &gt; Blockchain developers in Switzerland are in high demand, with many on salaries amounting to as much as $180,000 a year. &gt; The reasons are: 1) highly skilled blockchain-experienced devs are very hard to find; and 2) Switzerland is well known to be one of the most expensive countries on earth. &gt; According to Bertani, it&amp;#039;s &amp;#039;almost impossible&amp;#039; to find good distributed ledger developers due to the fact that ICO companies with enough cash to splash tend to attract the developers with higher paid salaries. ***** [**Extended Summary**](http://np.reddit.com/r/autotldr/comments/7nu87h/180000_salaries_blockchain_developers_in_high/) | [FAQ](http://np.reddit.com/r/autotldr/comments/31b9fm/faq_autotldr_bot/ "Version 1.65, ~275942 tl;drs so far.") | [Feedback](http://np.reddit.com/message/compose?to=%23autotldr "PM's and comments are monitored, constructive feedback is welcome.") | *Top* *keywords*: **Switzerland**^#1 **country**^#2 **developers**^#3 **Blockchain**^#4 **Swiss**^#5
A component test can test just some subpart of the whole service, in this test you are doing from the start to the end of the current test. It is true that you can think this as a component test, but notice that a component test can just test a small part, not the whole as explained here.
Nope, the terminology here is important. You are confusing unit and integration tests, which run the code as whitebox, and mock injected classes and function calls with mocking libraries (e.g. mockito) with component tests where the setup seals your whole service as a Black box and fakes the external world just like you did with the Stub service. In a component test the application is a whole, it is not partitioned.
https://www.youtube.com/watch?v=hcY8cYfAEwU
It looks similiar to a session cookie encryption used in play (I think it was..). And I don't think it's good idea to track state like this. Problem with it is that concurrent (ajax) requests can overwrite the token (cookie), so the app can end up in unexpected state. Even if you serialize requests and use token per service, users tend to click around and open tabs, so the problem still exists. Not saying it's not solvable, just that it's not that easy.
What happens is that you throw some information away. If class A has method a(), and class B extends A and adds a method b(), then if you do: A foo = new B(); Then you can call foo.a(), but not foo.b(). Why use the B constructor if you only need an A? Well, maybe B has a different constructor, or a different implementation of the a() method. Why not just make foo a B, then? Maybe you want to replace it later with an instance of A, or even a different class C which also extends A. Also, in many cases, it won't be a single object, but a List&lt;A&gt;, which may contain instances of both A and B. Also, you can always take your A, check if it's an instance of B (with the instanceof keyword), and then cast it to a B. 
Huh interesting, I may have to play around with it and see if I can grasp it better lol
I disagree with what you mention since integration tests can be run as black box and component tests as white box, I recommend this lecture which clarifies a lot https://martinfowler.com/articles/microservice-testing/ For me component tests (where a component is a class) can be used to test a number of classes and you can use any fake thing for example for db. In case of integration tests is for testing the integration parts against real services. 
Is this abusing JWT a bit? I thought it was supposed to be used for authentication/authorization only. I would imagine you could end up with a pretty large token if you weren't careful.
Typically you want to post this kind of thing in /r/javahelp as this sub is for news, technical discussion, research papers, etc. See the sidebar to the right. :)
it casts the double to short automatically when += is used. 
Thanks for the great information Gunnar!
Ah gotcha, my bad! On mobile and just assumed lol
[removed]
Yes, the guys behind quasar technology are somehow helping oracle in this one. From a custom hack to a real improvement in jvm!
Let's tear this down and take it one step at a time. First of all, this: String x = new String(); is a mix of 3 utterly unrelated things. It's shorthand for: String x; // variable declaration new String(); // create a new instance x = (some expression); // assignment. Let's explain these separately: `String x;` means: Create a variable, name it 'x', don't initialize it to anything, and restrict this variable to either (A) point at nothing, or (B) point at some object for which the compiler and runime can absolutely 100% guarantee that the thing it is pointing has the type 'String' somewhere in its chain of types. (For example, 'new ArrayList' returns an object that is a j.l.Object, a j.u.List, a j.u.AbstractList, a j.u.RandomAccess, and a j.u.Serializable, and a j.l.Iterable, and more – _EVERY_ interface implementing by it or any supertype, and all the supertypes. An arraylist is ALL those things). `new String();` means: Go to the heap and create a String object; String (the class) knows how to do it and invoking the string constructor is done as part of this. After this is done, there's a new object on the heap, and we have a pointer pointing at where on the heap this string lives, that's the value of this expression. `x = (something)` assigns the value of that pointer to the x variable. Now x points at the string so created. Put it back together and now it's perfectly sensible. Going back to your `ClassA` and `ClassB` stuff, `ClassA a = new ClassB();` does: 1. Create a variable named `a`. Restrict it to point either at nothing, or at an object that is definitely a `ClassA`. 2. Go to the heap and make a new object of type `ClassB` (note, because the definition for ClassB says it `extends ClassA`, all instances of `ClassB` are also of type `ClassA`). 3. Assign the memory location of the object created in step 2, to value `a`. This is a legal move; the compiler can ensure (as can the runtime) that this pointer definitely is pointing at a valid location, and it contains an object which is a `ClassA` (it is in fact an instance of ClassB, and all ClassB's are ClassA's). 
Feedback and ideas most welcome
I work in testing and, alas, i have to admit that the biggest wall when switching jobs and companies is exactly the terminology. I use the standard terms from ISTQB, maybe Martin Fowler follows another. It doesnt matter, what you call component is unit/integration and what the article says contract is component, but we weren't discussing about this in the first place, this is easy 1 to 1. Can we agree that "end to end testing" aka "System integration testing" means functional tests in a fully integrated scenario without any fakes? Where all the real services are up and running along side you service under test? Where the database is a real deal, maybe not with production Oracle DB with flyway migration but a simpler MySQL instance with an empty DB as starting point (given that we are not doing performance testing, just functional)? Because my point is that the OP is wrong about this, and again, several testing and quality standards have clear definitions about what e2e means.
I've got a toy project I'm working on that has a solution for this. It's not strictly speaking a Microservices architecture - it's a Spring Boot backend and a Create React App frontend. What I've done is: * Backend builds a Docker container using the dockerfile-maven-plugin * Frontend is built using Maven - using the frontend-maven-plugin - and also builds a Docker container (using nginx) * End-to-end tests are written in Node as well (don't hate me) and also build a Docker container * A Docker Compose setup that * Starts the database * Starts the backend * Starts the frontend * Starts a Selenium Hub * Starts a Chrome Selenium Node * Starts the End to end tests * Runs using the "--exit-code-from" flag so that when the End to end tests finish the entire cluster shuts down, and the pass/fail of the tests is returned This works remarkably well. I can build and test the entire stack on my machine against a real database, real deployed services and know that the whole thing works. I've even got the screenshots coming out of the tests using a Docker volume mount. Extending this to microservices would be relatively easy - just add more containers and link them together. The only part of the entire system that isn't real when testing it this way is the authentication. I'm using Google+ auth at the moment, and I've added in a dummy authentication route so that my end to end tests can run without needing real Google credentials. Even that could technically be done calling the real Google services, but that then means that I can't run the tests without a reliable internet connection.
Reminds me of JavaScript arbitrary type coercion weirdness... well played
Very cool looking judging from initial use. May try this during work at some point, looks promising
I love laying in bed reading 500+ page books on my ereader, instead of trying to hold up a 10 lbs book.
The Kindle eReaders have screens too tiny, IMHO, for text books. I have never able to read text books casually laying down. Not beach reading. If I am reading a text book on programming at some point I am going to want to sit up and type something in somewhere.
In 8 years of professional Java dev I haven't used `short` once.
Look up the @PostConstruct annotation, that's where the majority/all of your data loading actions are likely to live. JSF handles the controller part for you - see the top answer at https://stackoverflow.com/questions/10111387/understanding-jsf-as-a-mvc-framework As I understand it you ought to be looking at another layer as the data layer (@Stateless EJBs and the like), and it's these beans which you should be injecting into your classes called from a facelets page.
Great, if you find it useful, you can take it to the next level by downloading Codota and connecting Codota to your IDE. It then gives you context-sensitive code predictions based on what you write in the IDE.
Wrong sub, try /r/javahelp
Please see the sidebar about where to ask for help - when making your topic in the other subs include details of what you've attempted, no-one's going to just do your school work foe you.
It's a personal project not school work but thanks
You're not wrong, Walter, you're just an asshole.
You'd almost certainly want to forget using JSF if you want responsive interaction on your page. Doubly so if you're thinking about a mobile version too. My main experience of JSF is a huge bundle of state being sent with every request (although I'm sure that was just our developer's fault).
Huge amount of state is either pre-jsf 2, or when you explicitly enable both client-side state saving en full state saving. Both are not the default and especially the last one is rarely if ever needed (it’s only for compatibility with ancient components)
As /u/johnwaterwood said you can set 'client' in the STATE_SAVING_METHOD parameter, so that's not a big problem. 
If one is going to be a drooling idiot not even bothering to copy paste code but instead just follow autocompletion suggestions why not cut out the middleman and just start using node.js or PHP?
Maybe? I have an application with nearly 300 pages. JSF is a great fit as there is a low number of active users and templates allows me to reuse tons of code. Is it the best platform for building the next 500 million user web app? Probably not, but despite peoples hopes most of their apps aren't going to outgrow JSF's capabilities. Keep in mind that often the loudest voices evangelizing a technology with often never earn a dollar of revenue with their app.
You can, but doesn't that open up potential security risks related to the how the state is read back from the client? I was thinking somewhere it involved deserialization, but I'm now doubting myself on that.
&gt; You can, but doesn't that open up potential security risks related to the how the state is read back from the client? Since JSF 2.0 it's mandated for that state to be encrypted. It's a bit like how JWT works. Yes, there's potentially data in there that can be used to do nasty things, but if you trust that decryption / the signature is safe / valid you're okay.
Relevant username
Yes. Don't. (UI is nice though. You/your company could have some gigs doing something useful and applying your UX skills there.)
Sorry for the late reply, been busy. You're correct on all points. This level of compile-time correctness seems a bit extreme, but very cool if you can make it work. Doesn't it require **a lot** of code though? It would be great if you could have a look at j2html and see if any of your ideas could be implemented. I don't use j2html myself anymore, but I feel responsible for improving the project because of it's popularity. I'm pretty good at reviewing and merging PRs if you want to contribute.
Kill yourself
I recently forked the j2html repo and cloned it to my workstation at home. That makes it easier to navigate the code and review it for good ideas, etc. You are right about the "lots of code", in the sense that with my approach each HTML element and attribute has to be its own (small) class. All those classes consist mainly of constructor(s) and static factory methods. I was going to generate much of that code, using something similar to your TagCreatorCodeGenerator. But I have so far not put very much time into the project because there is always other priorities that distract me, including my family. :) Regarding pull requests for j2html: Do you see a realistic path towards the features / design goals I described? My approach brings some clunky looking generics with it. Maybe it is better if I prove it out more in my own project and get some feed back from potential users, before I even consider proposing changes to j2html, which is pragmatic and seems to work well for its user base. What do you think?
I thought this code search was really neat and the UI was very well. It is very cool how relevant stack overflow posts pop up for certain classes. Awesome Work!
Because predictive code auto completion and copy pasting someone’s else’s code are entirely different things. 
&gt; In monolith approach, you store the products of the shopping cart in a server session, if the server went down then all products of shopping cart were lost as well. This is simply not true. Where do you get this stuff? There are plenty of monolith applications out there that have a reliable HA backstore (PG/Oracle/redis/whatever) and if the app server goes down the sessions are *NOT* lost. This is how all applications worked before the microservices craze. Developing a monolith application and doing wrong design decisions are two separate things.
I don't think so. Going from int to double is going from smaller type to larger type. Going from int to short is larger type to smaller type. Saying double dub = 3; causes no issues for example. The cast isn't necessary
Really nice. I've never been able to read documentation, I always need to see it implemented in the wild. Bookmarked.
As a heavy IntelliJ user, how would this search be better than IntelliJ? IntelliJ suggestion/completion engine is very very good.
* [libGDX](https://libgdx.badlogicgames.com/news.html) (26 days ago) * [FXGL](https://github.com/AlmasB/FXGL/releases) (4 days ago)
As @chrisgseaton saids, SubstrateVM, JikesRVM and Maxin, may be and so on. 
Two more: https://github.com/jMonkeyEngine/jmonkeyengine https://github.com/methusalah/OpenRTS
Naughty, Adam, naughty! What if I'm disillusioned software genius who's badly crashed for private life blowup reasons, acquired bad case of alcohol dependency and struggle with addictions and depressions seeing how very same people I loved are now reaping 100s of millions in publicly traded stock thanks to the lines of code I wrote before they dumped me as having served the purpose? What if I'd do, what would you say then, you big mouthed vegan self proclaimed libertian vegan earth lover with BTC obsession, you?
&gt; It is very cool how relevant stack overflow posts pop up for certain classes. Stack overflow is _not_ documentation. It's _not_ an acceptable documentation. It's like trusting wikipedia when doing research with actual consequences. I hope you aren't paid for doing anything that involves creating new code. You shouldn't.
That FXGL lib looks nice :D glad someone tackled FX. New Question: Does JavaFX have a future?
What? JMonkeyEngine's first commit in GitHub is in 2011, not 2014.
I’d say get over it!
 libGDX is great.
Tried some adhoc technology keywords in search. Such as CQRS, DiscoveryClient etc. No sufficient results as of now. but this concept has tremendous potential, Need to reduce latency marginally. It is working very well If I paste some lines of code.
For Swing applications there are two multi platform look and feels as well as an optional native look and feel. The native look and feel doesn't work right in Linux as it will always default to the GTK look. JavaFX has a single default look and feel(I forget the name). You can change the look and feel yourself easily via CSS.
None personally. Making a JavaFX application in pure Java is super simple once you figure out silly API quirks. I wouldn't recommend ever using a GUI tool except for dirty mockups. 
&gt; What if I'm disillusioned software genius who's badly crashed for private life blowup reasons, acquired bad case of alcohol dependency and struggle with addictions and depression seeing how very same people I loved are now reaping 100s of millions in publicly traded stock thanks to the lines of code I wrote before they dumped me as having served the purpose? Kill yourself x2 &gt; What if I'd do, what would you say then, you big mouthed vegan self proclaimed libertian vegan earth lover with BTC obsession, you? At least you know how to read. Your writing needs some work though.
He just said the stack overflow posts were relevant for his search, no need to be pedantic...
Real men use vim. /s
IntelliJ suggestions are "token level" and based on what exists in your class. Codota's suggestions are "snippet level" and based on how people actually use it. See here https://www.youtube.com/watch?v=aQ8_1dm1obw&amp;feature=youtu.be&amp;t=42s
Try searching by specific classes or methods
Id like to find code in Java only. Is it possible?
You are not a very nice person, you know that?
Seconded the javafx grid system is super nice
capsium.css is javafx default. https://gist.github.com/tmazeika/c90c03c645d18722ddb0 
Yes - https://app.codota.com/search
If i'm going to start big project or migrate big Swing project to web i'd like a stable and backward compatible solution not one that keep changing every two days and needs tons of work to maintain. 
Well, there are companies willing to bet their future on JavaFX. http://gluonhq.com/
&gt; Is this abusing JWT a bit? It's definitely a bad usecase since there are no benefits and a lot of downsides to using them in a shopping cart.
I'm actally using libgdx for my game now and I really like it especailly with kotlin!
This is a pretty slick idea 
Doing a GUI by hand is like writing in LaTeX. A good visual tool will generate about the same code plus give you a preview to iterate quickly until you like how it looks (and behaves) plus some more fancy stuff you wouldn't initially think about like i18n, bindings, etc. Even if you need complex parts you can separate those into custom components which the tool could import and use. The thing is to have a *good* tool. If you check a box it should generate a single new line, not reformat everything so your commit looks like compiler output and it's impossible to code review.
Hi Reddit! I converted the best Java snippets on Stack Overflow Documentation to create this free Java PDF book, any feedback (even negative) is appreciated as it will help me improve the PDF book; which will then benefit everyone :)
This is the hot one at the moment afaik.
&gt; generate about the same code This is irrelevant to JavaFX since SceneBuilder doesn't generate java code. It generates FXML which is a documented format that JavaFX can load. The biggest problem with form builders for Swing are that they are code generators and once you use a form builder you are pretty much locked into that tool. JavaFX has greatly improved this situation with the introduction of the standard FXML format. I would never use a form builder for Swing but I have been using SceneBuilder. Although I am not 100% sold on it yet. It doesn't really seem to make anything easier that I just can't do by hand. I think I can code one by hand as fast as I can create one in SceneBuilder, or at least pretty damn close. I haven't yet reached a verdict on SceneBuilder vs by hand.
I want it to generate code though, that's the goal. I'm ok with being locked in to NetBeans too because it is free and in its current version, I actually like it. The UIs I'm trying to build are complex, and not very practical to build purely programmatically. I tried doing Swing in IntelliJ but I found myself actually missing how NetBeans held my hand. I am not a regular Java programmer though, so that's another reason. I've been programming for 20+ years but not much with Java so I really like the way NetBeans handles things.
&gt; I want it to generate code though, that's the goal. I'm ok with being locked in to NetBeans too because it is free and in its current version, I actually like it. The people after you may not like being locked into Netbeans. 
First [Bash](https://www.reddit.com/r/bash/comments/7nv2b2/bash_notes_for_professionals_book/) and now Java... Thank you very much BROgrammer2018!
Uhm. There's this thing called 'copyright' and I'm pretty sure that according to the SO ToS the copyright on all answers on SO lies with SO. So that might be pretty darn illegal and I'm sure they can afford better lawyers than you. IANAL though.
From official Stack Overflow Documentation license.txt &gt; All content contributed to Stack Exchange sites is cc-wiki licensed, intended to be shared and remixed. We even provide all our data for non-beta sites as a convenient data dump, seeded by us. &gt; &gt; http://creativecommons.org/licenses/by-sa/3.0/ &gt; &gt; But our cc-wiki licensing, while intentionally permissive, does *require attribution*: &gt; &gt; Attribution — You must attribute the work in the manner specified by the author or licensor (but not in any way that suggests that they endorse you or your use of the work). &gt; &gt; So let us clarify what we mean by attribution. If you republish this content, we *require* that you: &gt; &gt; 1. Visually indicate that the content is from Stack Overflow Documentation. It doesn’t have to be obnoxious; a discreet text blurb is fine. &gt; 2. Hyperlink directly to the Stack Overflow Documentation archive located at archive.org. &gt; 3. Indicate topic and example IDs where the content came from. &gt; 4. List the contributors (found in contributors.json) with a link to their profile page (e.g., https://stackoverflow.com/users/12345/username). &gt; &gt; This is about the spirit of fair attribution. Attribution to the website, and more importantly, to the individuals who so generously contributed their time to create that content in the first place! &gt; &gt; Anyway, we hope that clears up any confusion — feel free to remix and reuse to your heart’s content, as long as a good faith effort is made to attribute the content!
A good to hear. I was totally wrong then. Carry on :)
I think another thing to note that is technically covered in this article but not super straight forward. Let's say you write client projects like a rest API client using rest template in a separate repo, separate maven project with it's own class annotated with Spring boot configuration. Then you include it as a Maven dependency, your code compiles, your ide is happy, but when you try and run your app, you get the bean not found. If your client is com.example.client and your app is com.example.api, even though it's a maven dep and it has its own config class, doesn't mean your API will know where to find that bean. So in you application class you need to add "com.example.client" to the component scan. It may be tempting to just make your component scan super wide with "com.example" however, from what I understand this can be a very bad thing and slow things down greatly.
this doesn't appear to offer anything that wasn't already available on eg google and searchcode. you're not (afaict) storing the AST, you can't search for arbitrary code, you can't navigate (eg, clicking on a highlighted term brings up a blurb but won't show usages) and you have a very limited corpus 
As long as you keep things simple and tidy, you can have a lot of fun with JavaFX. It's also the only official and maintained GUI library and you can expect it to be supported for a long time.
If you're looking for something super simple (write your own http handlers), check out [Spark](http://sparkjava.com/). [Javalin](https://javalin.io/) looks pretty neat, too. I've not used it, though. 
198 Chapters? What an abomination.
Having a degree or an internship doesn't mean shit. Companies need a way to evaluate candidates' ability to use logic and reason. Companies aren't interested in wasting their own time any more than they're interested in wasting yours. FWIW it took me around 9 months to get a job, and was as frustrated as you are. But stick with it!
I just feel like with any other job people get interviewed once and they don't have to jump through so many hoops like programmers do. We get questioned so extensively it's annoying as hell.
Thanks a lot. You are doing god's work. People like you are an inspiration for me to contribute to this wonderful community of programmers!
There is [Spincast](https://www.spincast.org/demos-tutorials/hello-world/quick) if you want to try something different... As many other light frameworks, the HTTP server is embedded ([Undertow](http://undertow.io/) here) so it's easy to develop. If you need something very basic, you could even use Undertow out-of-the-box, without any additional framework! (I'm dev on Spincast) 
As someone who does hiring: &gt; These people should just do their do diligence and read your &gt; resume. I will skim the resume to get an idea of the candidate and if they would be a good fit. But I've interviewed so many people who seem awesome on their resume but bomb the interview on basic stuff that I don't trust resumes. &gt; They can give you some coding questions in that interview. I do this, but these are whiteboard sessions, not real coding. Also, there's a limited amount of time that I can devote to this when interviewing candidates, because I have lots of candidates to interview and I have other work to do. I actually like coding tests because it gives me a better idea of how candidates think and the kind of code that they write. I actually like taking coding tests myself because I think they are fun. &gt; Instead if you apply to a dozen companies you end up spending &gt; 40 hours a week just complying with all their ridiculous demands. My wife is a doctor. The demands of IT companies in interviews are nothing compared to what she has to go through when interviewing for medical positions. Not to mention, all the stuff she has to do to keep up her license to practice medicine. Sometimes, I think we programmers whine too much about how hard we have it, especially when compared to what people in engineering and medical fields have to go through.
Resumes don't mean anything. I've interviewed plenty of people with much more experience than you who couldn't code at a basic level. Things like spring are just buzzwords that underqualified candidates put in their resume to get past recruiting firms. Also have having experience doesn't mean anything if you were an AWF who had their hand held as part of another contract. With all these staffing agencies flooding the market with subpar candidates companies need a way to weed out the weak ones. While it does suck for someone interviewing understand it's necessary. 
&gt; I have a feeling I could show you the most complex UI in the world, and you'd still tell me how I could do it programmatically. Likely true, because I am skeptical such a beast exists that is too complex to code programmatically. 
I've remembered the potential vulnerability I was thinking of; it involves (a) disabling encryption on the state, (b) using MyFaces, and (c) was essentially the opposite to how I recalled the issue, i.e. using server state saving wouldn't keep you safe - so totally unrelated to what was mentioned here. https://issues.apache.org/jira/plugins/servlet/mobile#issue/MYFACES-4133
[Jooby](http://jooby.org/) Is a micro framework that comes with embedded server. really simple to get started with
DropWizard
&gt; You'd almost certainly want to forget using JSF if you want responsive interaction on your page. Doubly so if you're thinking about a mobile version too This has **nothing** to do with JSF and **everything** to do with CSS. I've used bootstrap to make a JSF app that is 100% responsive and works fine on mobile.
You've misunderstood my usage of "responsive".
And I guess you're just (t)rolling out the old "___ is slow" mantras.
If by ____ you mean "round trip to the server", then yes.
Thanks for the feedback. Let me clarify the facts: We are actually storing the AST, it is a semantic search based on code, not text. It's not something you can do on Google. We can search for any arbitrary combination of classes or methods. What do you know about our corpus that makes you say it's limited? And yes - we should (and plan to) add better navigation when clicking a highlighted term - that's actually is useful feedback!
&gt; I think we programmers whine too much about how hard we have it. Yeah, why can't you fuckin' guys work for $60000/year in places like San Fran or New York? Fucking primadonnas. /s
Preface: There are only critiques below, so I want to state up front that I am glad that you have done this. Thank you. My initial reaction is that the ordering seems off, or just not really considered. It's titled "For Professionals", so maybe that goes along with it being more of a reference than a read-straight-through type of book, but seeing Streams long before Collections and Lambdas doesn't feel right. Your Algorithms book may be a better example of this. Chapter 2 is Sorting, and Chapter 3 is Bubble Sort, but then Merge Sort is Chapter 12, Insertion Sort is 15, Bucket is 22, Quicksort is 23, and so on. Ignoring that each sort algorithm is a completely different chapter, rather than sub-chapter of Sorting, they're scattered about so I can't easily find all of the discussed Sorting algorithms. If they were all sequential chapters, I could easily find the block of sorting algorithms and scan through to find what I need. There are also embedded links to the Stack Overflow documentation pages, which no longer work. For example, page 28 in the Java book links to https://stackoverflow.com/documentation/java/114/classes-and-objects and http://stackoverflow.com/documentation/java/84/java-overview/7980/command-line-arguments. These should probably be converted to internal links to the relevant section of the PDF, or removed if that section wasn't included.
&gt; why can't you fuckin' guys work for $60000/year in places like San &gt; Fran or New York? This is a different kind of whining. If you find yourself in this position as anything but an entry level programmer or working on an immigrant visa, you either need to improve your negotiation skills, networking skills or your programming skills. Programmers are skilled labor in high demand. We suffer far less from income disparity than unskilled labor who have no choice but to accept whatever they can get because they are easily replaceable.
I try to avoid recruiters as much as possible and instead apply to companies directly. Too much hit or miss with recruiters, as most of them aren't technical enough to know whether you are a good fit a specific position, leading to a lot of wasted time.
Constructors are introduced in section 46, page 430, and the `static` modifier arrives in section 65, page 510... O_o
Another fan of Spark here, having used it for both simple REST APIs and full-blown web applications. It's light, efficient, and most importantly very simple to use.
&gt;**No surveys, no job offers!** Such content will be removed without warning.
Just saw all those PDFs you made, as a student I really appreciate it. 
My advice, assess what's reasonable and a quick 'Best of luck' to that which isn't.
&gt; Please rank your primary programming languages by frequency of use: *This question is required. &gt; Order the items from the following list. First select an item with the spacebar to show a menu of possible ranking positions. Next, click a ranking position to order it in the ranked list. Note the menu will display more ordering options as you add items to the ranked list. What the f... Worst UX ever, doesn't even work in latest Firefox. 
Not to mention inheritance being introduced in chapter 2, long before classes and objects...
Maybe you didn’t see the part about three whole years of Java on a daily basis. What could he possibly have to prove?
Thanks man :)
These days I am more leaning to github.com to check candidate's contributions instead of looking at their resumes. 
On mobile you just click them in order
In my current job, which I love, the interview had zero coding questions, and there was no test. The interviewers were both highly intelligent software developers (who are now my coworkers), and they understood what is important and what isn't. They did ask questions about appropriate use of design patterns, architecture, and further details on previous projects that I had listed in my resume. Guess I got lucky, because it's been my favorite job so far.
Maybe you should ask this in /r/javahelp. Java applets are not supporter by any modern browser. I think they work with old versions of IE and nothing else. I don't know more than that but if someone tells me that a solution to a problem is based on applets I'll find other way.
Thank you for your time. i'm gonna follow your advice and post in /r/javahelp
Thanks for your empathy, stranger. 
That he doesn't just stackoverflow solutions.
How the hell do you get a bachelor's in cs without coding?
Hello. To do what you want, use JSP technology. This will allow you to create web pages with the necessary data. JavaServer Pages (JSP) is a technology that helps software developers create dynamically generated web pages based on HTML, XML, or other document types. Link to wiki (https://en.wikipedia.org/wiki/JavaServer_Pages). For example, if you enter the address www.example.com/products/{product_id}, the servlet can return a page with data corresponding to the product with "product_id".
I just click and dragged. Worked fine for me.
by photoshop-ing one and super confident in the interview, never tried myself, but made one for a friend years ago, from academic scores to certificate, and he's kinda confident on how he project himself, got the job and been hopping around company ever since with above average pay on his job scope.
All my good stuff is in company closed source github ;)
Thanks for replying! But I don't couldn't find how to assign www.example.com/product/{product id} to a jsp or a servlet, how do you do that?
&gt; Companies aren't interested in wasting their own time any more than they're interested in wasting yours. That's completely wrong. The person doing the recruiting has a job just like you do, they need to "look busy" just like you do, they need to say magic words to the boss to make it look like they're smart and working just like you do. They're getting paid for their time. You're not. They're more than happy to screw around if it means they "look like they're working" because they get paid for it.
Guice 
Really good works!
this is a fantastic work. Will be coming back to this search often.
A new release of Flying Saucer with OpenPDF as renderer: https://github.com/flyingsaucerproject/flyingsaucer 
Same here. But this is trait of smaller companies I guess. I stayed out of corporations for my whole carrer. I am used to be recruited and recruit, but in both cases after nice conversation about projects, preffered approaches I always ended up with coding test. But nothing big. It was always something between 15-30 minutes long. Result did not have to work or compile, even. There was a problem to solve and the approach and way you think was the most important. 
These examples allow you to write a simple application that will accept requests, receive information from the database and output the query result on the JSP page. By this link there is a good tutorial that allows you to create a web application using JDBC, Servlets, JSP and etc: http://o7planning.org/en/10285/create-a-simple-java-web-application-using-servlet-jsp-and-jdbc By this link already using the Spring MVC framework: https://www.journaldev.com/14476/spring-mvc-example 
Spring
Some universities do coding in languages that have little real-world applicability. Like oCaml or what it's called. I've never seen a job ad with that. Of course you code, but it's not like it gives you a lot of points in the job market
I've seen people with 10+ years of Java experience do incredibly stupid stuff which would be revealed by such a test. 2 hours is overkill. You can't tell how good people are but you can tell if they suck. 
&gt; I just feel like with any other job people get interviewed once Heck no. Developers are in high demand relative to most other trades. In many/most other jobs where that's not the case getting only one interview means you didn't make it, and one of the many other applicants got further in the process. 
&gt; I would like to know your views on Java applets for modern Web applications. Applets are dead and are being removed from Java. They are deprecated in the current version of Java and will be [completely removed down the line](https://www.theregister.co.uk/2016/08/24/oracle_reveals_java_applet_api_deprecation_plan/). Applets have been dead for a while and are going to be completely removed. The only way to keep using them is by forcing your users to use completely outdated insecure browsers with outdated insecure browser plugins and outdated insecure Java Runtime Environments. If that's not enough to convince management that there should be a migration path away from them you're probably working for Equifax. 
This is called routing. There are many web frameworks for Java (too many almost, a new 'light weight' framework gets created like every week or so ;)) that handles this for you. So if you really want to 'only' use servlets then you are basically building a routing component yourself. So your course depends on if you really want to keep using just servlets. Since you appear to be quite inexperienced why not try using a small simple framework like Ninja? And when it comes to "all batteries, tools and whatever you might need"-included Spring Boot is more or less the de facto standard. 
I knew a guy who for coding assignments would give programs written by other people. My roommate used to earn money writing programs for people doing their BSc. In other words - easily.
&gt; uses generics beautifully? jOOQ and jOOλ have some quite funky usage of generics :) Here's a method from [`Function16`](https://github.com/jOOQ/jOOL/blob/master/src/main/java/org/jooq/lambda/function/Function16.java): default Function10&lt;T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R&gt; applyPartially(Tuple6&lt;? extends T1, ? extends T2, ? extends T3, ? extends T4, ? extends T5, ? extends T6&gt; args) { return (v7, v8, v9, v10, v11, v12, v13, v14, v15, v16) -&gt; apply(args.v1, args.v2, args.v3, args.v4, args.v5, args.v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16); }
[PrettyFaces](https://www.ocpsoft.org/prettyfaces/) makes this very easy, so you don't have to do perform any black magic with the request URI inside your JSP/JSF. JAX-RS isn't the right tool for *serving* pages.
/r/learnjava or /r/javahelp 
Would be neat to be able to read it online.
Hah, cool idea - thanks for sharing. With jOOQ, this could be done e.g. by loading a file of a format like this: ID NAME -- ---- 1 John Wakefield 2 Mike Rillis 3 William Constance ... load this through [`DSLContext.fetchFromTXT()`](https://www.jooq.org/javadoc/latest/org/jooq/DSLContext.html#fetchFromTXT-java.lang.String-) And then insert it into the table via [`DSLContext.loadInto(USER)...`](https://www.jooq.org/doc/latest/manual/sql-execution/importing/) I'll need to blog about this immediately! Thanks again for the idea :)
This looks awesome. Downloading now. Thanks for making this.
Such code. Much wow.
Here I agree with you, Thymeleaf is an excellent alternative to JSP. Simply, In work, I was more confronted with JSP. 
Yes, Flying Saucer has good CSS support. If you are already using it, then I suggest upgrading to this.
Last time I used JSP was in an internship back in 2000 :D I quite liked using it. I even developed my own 'forum software' (basically a PHPBB clone) in JSP. So nothing at all against the technology but Oracle basically more or less removed all references and documentation on it. So it's easy for beginners to get stuck on.
At one of the places I worked before there was pressure from the top to loosen up our recruitment standards. Also part of the questioning is to see how candidates deal with stress and what will they do when they don't know the answer. If they claimed to be experts o CV we would ask as hard as possible to see if they didn't lie. And we still had candidates with years of experience, writing java non stop who apparently haven't heard of a loop before. 
Cool, this [data browser thingy](http://jailer.sourceforge.net/data-browsing.html) looks very useful. I've had similar ideas in the past, but never got around to actually implementing it.
And how do you verify it's the person applying that passed the test and not their friend ? We had candidates who on skype interview would have someone else connect to remote coding tool (we could see the connections). 
The fragments seem alright, but there is no structure or order. I don't think I'd use it over Stack Overflow if I had internet access.
[BIRT](http://www.eclipse.org/birt/)
[removed]
Sure I believe that all our applicant's degrees are real. But a degree isn't everything and there's people that I went to uni with, who have the same bit of paper I do and there's not a chance I would ever hire them. We stopped sending out a coding test because a lot of applicants didn't send them back (ie they just disappeared) or they sent back rubbish solutions. Our process is now Resume to HR who does a first pass filter, then you talk to one of the tech leads to check you're not completely full of shit, then we invite you in for a pairing session, if you get passed that, then a final quick talk with the CTO which is pretty much a formality to getting an offer. We find the pairing session to be much better than the take home test. Applicants can bring in their own laptop if they want, or they can use mine. We even let them choose the language they want to work with since we'll interview anyone with good dev skills. I'll then describe the problem and we then work together on a solution. If the applicant gets stuck, I'll make suggestions to keep things moving. We want to see how you work. When do you make commits, write tests, what gets tested. If you can't remember something like how to open a file, then the browser is already open for you to search (as long as you don't search for "how do I solve &lt;problem&gt;") that's how people work, so we want to see it. Ultimately we don't care if we get to a working solution and most of the time we don't and we make that clear at the start. We just want to see that the applicant can actually code. So to answer OP's original question as to why we do it - it's because we only end up offering positions to maybe one in ten applicants because so many people bullshit on their resumes. I've read some awesome resumes with great experience and was genuinely looking forward to meeting them, only for the person to have absolutely no idea how to code in the language of their choice. So yes, it's insulting. Insulting that people bullshit on their resumes and waste five to six hours of our time applying for a job that they're clearly not qualified for.
For future: please post such questions in **/r/javahelp** as is clearly outlined on the page.
Vavr is immutable collections tool, well written. Can gain a lot of knowledge about collections and immutability. 
You just need a little anxiety or social phobia and you'll look like you never programmed before. Not everyone is overconfident you know. But people that never experienced this and will not give you a chance are often the loudest about understanding and diversity.. 
BIRT is an alternative to Jasper, but I have only had bad experiences with it. Especially when generating large Excel reports, BIRT can consume all available memory and crash the JVM. Jasper can be configured to use the file system to ke6the memory low. 
So you would take the test once per how often ? Plus as a rucruiter I probably want to ask you questions while you code, see if you catch up on mistakes. It's quite valuable to see how someone performs under stress. 
I actually found the Wicket source code also to be interesting to read, mainly because it's a different style to a ton of other web frameworks
One of the last projects I did, we had around 18 (if I remember correctly) microservices. And just booting them up and getting them ready for a single test run was a major pain. Let alone testing them end-to-end without mocking. To me this is a really undererstimated problem with microservices, with no perfect solution (that we found)
Thanks you so much .We are indebted to u .
https://www.tableau.com Nice visualizations, not cheap though :(
I just see a peorder option on amazon https://www.amazon.com/Effective-Java-3rd-Joshua-Bloch/dp/0134685997/ref=mt_paperback?_encoding=UTF8&amp;me= The book is not released?
&gt;**No surveys, no job offers!** Such content will be removed without warning.
I feel your pain, but just two cents from the person who had interviewed more than 100 people for a position of a Principal SE with upper-100K salary base. Those people with flourishing resumes can't write a damned loop to find a maximum number in an array of integers. They can't write a function to compute the factorial recursibvely. They can not even reverse an array, not mentioning the reversal of an array without using a temp variable for swap. Someone mentioned once that in order to find a maximum item in a stream with unknown length you need some specialized library. So yes, I don't trust a bit of things in the resume (including degree, especially from India) until I ask couple of basic questions about this thing or that experience. Still, two hours is an overkill. It takes me about 30 minutes to understand if a person in front of me can program, without the traversal of a tree in funny ways or solving NP problems.
Take a look at [light-4j](https://github.com/networknt/light-4j) and [light-rest-4j](https://doc.networknt.com/style/light-rest-4j/). It is designed to have higher throughput, lower latency and smaller memory footprint. (I am the author of the frameworks) 
This is the way to go if you have weeded out all those bullshit-pushers and have someone who seem to fit the job. The relaity is that for whatever reason people tend to think that they don't need any degree or qualification to get into IT, because it's sort of "cheap money" for anyone who can turn on a computer. And this "fake it till you make it" is very ugly when you have a colleague who has absolutely no clue what an array is.
Yeah I don't really like working with outside recruiters. They call and email you so much and waste so much of your time. I agree too that they're all very hyper and extroverted. I usually only talk to in-house recruiters (someone who works at the company I'm applying to).
Pentaho. They've got a tool for doing all your transformations (Kettle, aka Pentaho Data Integration). You can do reporting directly from the transformations or you can push the data up to their server. They're mostly open source and distribute a Community edition for free and an Enterprise edition.
Yeah - I've seen iText as being recommend for "quick and dirty" which may be sufficient. I was hoping to have the same system generate the PDF and CSV - so I could generate the CSV myself, but my preference would be have the same "code" generate the different formats so they reconcile with each other Google is indeed my friend here - unfortunately it doesn't always show the most recent frameworks. Jasper is always recommended - and you find yourself reading StackExchange reports from 2011 and you wonder "has the world moved on in the past 7 years!!" thx
was quite a fun survey, feel like they needed to reasonably base the word "regularly". "How many programming languages do you use regularly" in the last 2 weeks? 1 in the last 6 months? 6? 7? maybe Felt they might have got more accurate answers if they said something like, "in the last 2 months"
So my comment on the recursive thing you said is that I would be hard pressed to think of an example in my ~7 years of working with Java where I actually needed recursion to do what I needed to do. I mean yeah it's absolutely needed in some fields but for me I'm over here writing Microservices, Restful endpoints, querying databases, writing sql, working with the product owner to figure out the business logic, swatting my Scrum Master to get off my back because I didn't do my Agile retrospective. Stuff like that. I don't use Recursion in my applications ever. And I sure as hell don't go home after working 8 hours to do "fun" coding puzzles where I need to use recursion. So when I go into an interview and they give me a God $%*# recursion problem or some other funky weird shit I'm just like wtf is this and how is this showing you what kind of programmer I am for real world applications. If these tests and questions asked me things like Spring Boot questions, day-to-day sql questions, AWS stuff, Agile, Rest practices, Java containers, maybe Java 8 stuff like streams or lambdas maybe to throw in some flare, things like that I would be happy to answer. But stop giving me ducking puzzles to solve I'm not a puzzle master.
When you say large - how big do you mean? 10x1000, 100x1000s of line? My understanding is excel is limited to 1 million rows but I don't know if that is even feasible. BIRT seems like a viable alternative to Jasper .... 
the $70 per annum professional edition seems ok? It looks pretty for sure - but that is not really a primary concern. Have you used it for data manipulation and transformation?
Have you used it? Any insights - easy to setup, easy to maintain, support for exports etc - any info appreciated. thx
Good Stuff Have you used any other reporting frameworks?
Another technique I later moved to was loading data from CSVs and creating insert statements for tables with the same name as the CSV file. E.g. jdbcTemplate.execute( Csv.toSql("classpath:/data/EURO_PROJECTS.csv") + Csv.toSql("classpath:/data/FX_Rates.csv") )
I'm currently studying CS in Frankfurt, Germany amd my uni is basically hardware and theory only. Almost zero coding lessons. Complete bs. But too far into it to change now.
I have fell in love with Spring Boot. Finished my thesis some time ago and used Spring Boot for back end and React for front end. Spring Boot is really great option especially for REST!
This amazes me. I'm currently working on a cs degree and I have had to write plenty of code already and I still have a year to go. 
Looking forward to the results. It was rather extensive.
It is quite easy to learn. When I started at school 4 years ago, our first big project was Android game. It was made with Libgdx. Good thing is that it comes with good 2d physics (Box2d) which is used i.e in Angry Birds I can highly recommend.
&gt; It's quite valuable to see how someone performs under stress. It's called Sadism. You're a sadist.
&gt; Why do I have to complete a two hour programming tests for every job I apply to. Having interviewed a lot of candidates with comp. sci. degrees and multiple years of work experience, my impression is that the majority of them are not actually competent to code. Degrees and work experience are, in my experience, almost completely uncorrelated with programming ability, and there's no better way to see if someone can code than to watch him code.
I don't see the connection wasm to applet. As far as I can tell they're very different ... everything. 
There's [DynamicJasper](http://dynamicjasper.com/) or [DynamicReports](http://dynamicreports.org/) hiding the complexity of Jasper.
I hear you, and you know - it's just like some people do understand the recursion and some don't. No insult here, just a silly joke. To me the ability of writing some recursive or mutual-recursive things is the same level of competence as traversing an array in a loop. This is just some bacis knowledge that shouldn't wear off even if you never used it for 10 years. To some extent, you hardly call someone a programmer if one doesn't understand how XOR works (not on the hardware level but logically), and I bet that most of Java devs nowadays don't use it quite often. Doesn't mean that it coule be an excuse to not answering `what is the result of 10 xor 10`
Exactly this. I have just started to work as software architect and most of our code is Java. I've seen so horrible things. Programmer can do so many wrong things with Java. There is too many of those "it does compile" guys who think they know how to code. Writing good code is far away from code that compiles. For the OP I just say that do a lot of own projects. Saying "I have a degree" does nothing. I do have a degree and so do many of my former class mates and yet I've managed to build a career while they sit at home complaining why they are still unemployed. This career is all about what you have done because it reflects what you can do. A degree and mentioning those ridiculous NASA things (I've been there as well) are yet nothing. Do small projects and build impressive portfolio.
If you're confident there will be no stress. I won't try to lead you off into bad answers with "are you sure?", I'll only ask that if I think your answer wasn't correct, to make sure there was no miscommunication or "brain fart". If you don't know the answer you'll probably stress. I'll see if you own to it, try to figure it out, while telling me you you're not sure, or make a total ass of yourself by being absolutely 100% sure your answer is good while me and my colleague are trying to hint you that it's not. I won't ask questions to stress you. I'll ask them to asses your knowledge of the topic. I won't ask any cryptic API shit but I want to be able to judge how much you understand the core concepts we work with. And I want to see you code, so I'll give you some simple coding tasks, on the level of palindrome detection. Not because they're difficult problems, but because they let me see how you think, I can see how you react if we ask you to refactor some part, we can ask more questions regarding your choices of algorithm. I don't care if you don't remember if it was .size() or .length() for String. If the candidate is generally giving impression they would fit well in the team I WANT them to pass because if the candidate passes I won't have to do interviews for some time. And none of this is possible with a one time test signed by some company which may have different standards.
Sure. Look up my answer to the comment above yours.
nice!
Ok, but that's another problem. Just say directly you need to see the candidate live code and stop inventing proxy problems. Ad stress. Some people are not confident by nature. You've probably no idea about stress and anxiety or social phobia.
Ok, but that's another problem. Just say directly you need to see the candidate live code and stop inventing proxy problems. Ad stress. Some people are not confident by nature. You've probably no idea about stress and anxiety or social phobia.
Sure I don't, the fuck you know about me? What proxy problems? I'm not trying to add to their stress, but most of the time interview itself is stressful enough, and I want to see how they behave. People can become toxic under stress, and every place I have worked at so far had periods when everyone was stressed. And we still had to do our jobs and interact with each other.
Maybe the hover alert for "Submit Text" should be change from "PLEASE SEEK HELP WITH PROGRAMMING IN /R/JAVAHELP" to "PLEASE SEEK HELP WITH PROGRAMMING, USAGE, AND INSTALL in /R/JAVAHELP"?
Mmmm I see most of you recommend using an external framework so I'll give it a try. I have heard of Spring Boot and Spring MVC, do you recommend Spring Boot over Spring MVC?
If it is only the software developer who creates the reports, I think you'd be better off just writing your own application that fetches the data from the required sources (there are libraries for that) and producing the required format (there are libraries for that too!). Whatever system you pick -- BIRT, Pentaho, Jasper -- those are all terrible complex systems. Yes, they all work, otherwise they all wouldn't exist today.
Compile a Java app, use a JVM bytecode to Wasm compiler and voila a Java app running on the browser just like the old applets. Some ongoing effort, http://teavm.org 
Spring is not light-weight either.
Same here. I'm currently working in a small company (10 employees including management). When I was invited for interview for larger companies (which had 500+ employees), they gave me a very detailed questions about Java and software architectures (I was applying for junior level position, having about 1 year of commercial experience then). In the small company when I currently work, I was only asked about tasks and projects in which I participated in. The questions were about my role, problems I experienced during doing these tasks. No strict technical questions.
Which report designer? There are several and they are pluggable. Saiku is one of the more popular open source ones.
e.g. [Light 4J](https://github.com/networknt/light-4j)
Somewhere in the region of 100x1000 rows, if I remember correctly. While using BIRT, that brought the 32GB heap JVM to it's knees and never finished. Jasper could handle that easily. 
I assumed the programming test is one of those automated online tests companies give *before* getting to speak to a real person. Of course, when in person, the employer is free to re-test the candidate.
Thanks for the advice, I'll give it a try
It's used a lot in thing Big Data. It's not used for manipulation, only displaying. The same goes for Jasper pretty much, which is a fucking mess to work with and has made my professional life hell plenty of times. Also Jasper will not generate a CSV for you.
Spark Java http://sparkjava.com/
&gt; lightweight 1. of thin material or build and weighing less than average. 2. lacking seriousness, depth, or influence.
Could you please point me to your algorithms notes. I can’t seem to find it. Thanks a lot for your work.
I found jasper very frustrating to develop in, and we transitioned into using phantom js to convert our html views into pdfs. Its way easier, and I think more maintainable. [see this](https://aboullaite.me/phantomjs-generate-pixel-perfect-pdf-reports/) 
But ... what's the point? Then entire purpose of web assembly was to take that native application and run it in a browser. More specifically (and where the standard emerged from) run a demanding game with reasonable and acceptable performance in a browser. Running an applet (or a java desktop application, swing of javafx) makes no sense and has no purpose.
Allow me to add some more. Those Export classes. The ones that consume JasperPrint and emit, PDF, Word, HTML, etc. You don't have to save the intermediate JasperPrint from the engine into a file. You can connect a JasperEngine class with one of the export classes (I should say objects not classes). Each export object, writes into an OutputStream. So this could be a file, or a live HTTP connection where you are streaming the HTML exporter to a browser. Or the Word or PDF exporter's output stream could be streamed to a browser over HTTP so that the browser is receiving it as a download file. This is how I implement my reports in a web interface. When the user runs a report (eg Start Report button), a download dialog box appears and the user can save the file (say, PDF) to a file. That way my web application is never trying to "print" anything. The user get's a PDF file. They can keep it, print it, save it, later re-print it, etc. Similarly, if the user picked Word as the output format, and click Start Report, a download starts, but the browser is saving a Word document that still looks like beautiful report pages that can be printed. So again, it is complex. But you can build an incredibly sweet report and data export mini-framework around it in a web application.
fuck, if a guy can pull that off, hire him - not only is he a good coder but he can sell too
Any of the Apache Java projects
x86 is actually for 32 Bit, if you have 64, dont limit yourself :)
Hi user3141592654! Thanks for all your good notes! This weekend I will be fixing the sorting of all the chapters
If you like Eclipse, WindowBuilder is really amazing for Swing.
I really like https://www.http4k.org/ but i would prefer just Java8 -- not sold yet on Kotlin 100%. I'm working on a small port of the minimal stuff (HttpHandler interface) to Java8. Things I like: - Functional - Mostly copy-on-write / immutable - no dependency injection (but +1 to dependency inversion) - no magic (classpath, reflections etc..) - modular - middleware paradigm
I actually work for one of the larger defense contractors, but in a fairly unique software lab environment that is small (about 30 of us, and only 6 developers).
Refactoring legacy code: it's probably easier and safer to just rewrite it from scratch.
Not at all. The whole point of WebAssembly is to eventually replace JavaScript and turn the browser into a general purpose VM. Everyone is already playing with porting their favourite native language, Java, .NET into WebAssembly. I bet even Adobe might be playing with a WebAssembly backend for Flash. So be prepared for the time when we will get huge WebAssembly blobs with everything rendered via Canvas or WebGL.
If it is a "living" project this is simply not possible. Usually we still have to implement new features while we start refactoring our code. And the refactoring is a long term goal. If we would simply start from scratch we could not implement required new features during this period. Additionally many companies have QA processes or need to be externally certified, which is much more simple with a change of a project than recreating it.
I especially like Doug Lea's abundant assignment expression style :) e.g. public final void run() { final CompletableFuture&lt;? extends T&gt; a; final CompletableFuture&lt;? extends U&gt; b; final BiConsumer&lt;? super T,? super U&gt; fn; final CompletableFuture&lt;Void&gt; dst; Object r, s; T t; U u; Throwable ex; if ((dst = this.dst) != null &amp;&amp; (fn = this.fn) != null &amp;&amp; (a = this.src) != null &amp;&amp; (r = a.result) != null &amp;&amp; (b = this.snd) != null &amp;&amp; (s = b.result) != null &amp;&amp; compareAndSet(0, 1)) {
That better be a fucking game, because it doesn't make any sense whatsoever to call drawLine() on a canvas to draw a text field when you have the browser nicely supporting you with an input type="text". There are very good reasons for webassembly to exist and expand. Porting plain old desktop applications is not one of them.
Did you benchmark spark java on the nexus5x vs payara micro?
JUnit 5 has pretty good design. Code can be found [here](https://github.com/junit-team/junit5/) Analysed by University of Delft students [here](https://delftswa.gitbooks.io/desosa-2017/content/junit5/chapter.html)
Yea, been using it for years. At the simple end, you can use the designer to build reports and their viewer servlet to expose them (as "live" reports), no need to really get your hands dirty. At the other end of the scale, they provide pretty comprehensive API's for both building reports (rather than using the designer) and for generating reports (rather than using the viewer, which is what we use it for). The only real downside I've found is that poorly designed reports perform poorly, and unfortunately, since we let our users build their own reports and we just use the API to generate them we don't have any control over the reports we try and generate so it ends up causing us some headaches occasionally when we need to step in and help our clients tidy up the reports they build. The main performance issue I see is people using the built-in "join" data sets to join two data sources together (rather than for example having the underlying database do the join) since it appears that when it does the join it pulls in all the data from both sources and does the join internally. I guess it could be a lifesaver in certain circumstances (you know the data, it's small, they're from different sources, etc) but used indiscriminately it's a killer. I know enough about the report designer to get the basics done, but all of our clients use it to create their own reports and they don't seem to have problems producing the types of output they're after (and there's a quite a range in the level of sophistication of our clients), and I haven't used the viewer servlet at all, but I believe it's possible to have quite interactive reports where the user can modify parameter to change the report on the fly. I've spent most of my time with the API 's building our own components for inclusion in reports (mostly map related components), adding additional output formats and data sources, and using the runtime API to generate the reports upon request, and while I wouldn't say they are trivial to work with they're well designed and documented, flexible and have plugin points for just about everything. There's also lots of support for writing event handlers in JavaScript within the report designer, which can help with simple to intermediate programmatic customisation of the report, beyond that it's possible to link in your own Java classes if you need even more control. If you're creating your own reports for your own data sources and schema then I don't think you'd have a problem with the basics getting the output you're after (in the formats you want) with little work. And if you need more down the track I'm sure BIRT will be able to accommodate it. Because it's built on OSGi you can include as little or as much of its functionality as you need^* If you don't need charting then don't include the charting bundles, don't need PowerPoint output, don't include the PowerPoint remitter bundle. ^* Our apps are built using OSGi, so that's a given for us, but I believe it's also possible to just include a handful of monolithic Java libraries to get the functionality, but I can't attest to how much you can pick and choose in that situation, so YMMV. It may well be that BIRT is overkill for what you're after, but I think it's at least worth a quick download of the designer and a play to see if it'll produce what you're after out of the box. Cheers.
Current ongoing activites among Go, Rust, Scala, Kotlin, Java, C#, C, C++ show otherwise. Yet another example, www.hanselman.com/blog/NETAndWebAssemblyIsThisTheFutureOfTheFrontend.aspx
I mean to the idea of a test results site. I don't like the idea, I think having some git repository is better one, because it really shows how do you normally code.
/r/javahelp also just posting the screenshot does not help. And try googling, just run with admin rights.
Which version of Java are you trying to install?
Try the link in my post.
Runing with admin r. doesn't work... I googled that but all i saw was some scamming programs...
Alternatively to Oracle installers you could try: * Red Hat (need to create an account): https://developers.redhat.com/products/openjdk/download/ * Github page: https://github.com/ojdkbuild/ojdkbuild In case the .msi doesn't work either, download the .zip and unzip it at the location you want. Set the JAVA_HOME variable as described [here](https://confluence.atlassian.com/doc/setting-the-java_home-variable-in-windows-8895.html).
OK thx, if mincraft works (Im novice modder) ill be grateful
To piggyback off this, as a startup employer I can’t trust what’s on your resume. I want to see how you code and how you problem solve, which requires me to ask you to solve a coding problem. The other decision makers on my team need to evaluate your abilities as well, so you end up spending an hour for each of us four engineers that are evaluating you. “But why? This take so much time?!” Well if I hire you, it means that my Series A company is going to spend a large amount of resources to pay you (we are in California, where engineers are fucking expensive). And we have to answer to our investors. If we say “oh he has a good degree and experience” but we don’t dig to see how you are, then they won’t be confident. But if you did well on the tests, then we can tell our CEO and investors “this guy nailed the interview, and we interviewed him for four hours” etc etc. I’ve literally passed on Stanford and Yale grads and had boot camp guys do amazing on their interviews. I’m had my hopes destroyed by getting my expectations up by “guy worked at Google and graduated from Brown” only to have them destroyed during the interview. I don’t even care where you got the degree anymore. I don’t even read resumes anymore. All I care about is if you can pass my interview question and how your mind works. Hope this makes sense.
Yeah - I'm starting to think that the reporting systems may be too expensive (time wise) to use for a few reports. Once the data is loaded, reconciled, merged, cleaned and transformed the reports should "fall out" of the data. I think the reporting systems will not solve the transformation issue - e.g. I will have to build that anyway. In my case if PDF is suitable for summary reports then I should be fine without a full reporting system. The CSV is just a data dump really once the hard work is done. 
Thanks for the excellent summary. My only concern now is that as I only have a few reports that a full reporting system may be too much overhead. As I would be learning from scratch would you say Jasper has a steep learning curve or can a few meaningful reports be generated after a few days of work - assuming the data is available?
This one time they created the Pascal language to teach programming. Then I got a job where it is still used on a daily basis...
Very cool. I mainly use java at work (and sometimes some .net stuff with c#), but with python becoming so big I thought I’d try to build my skill with it. I got a book about Machine Learning with Sickit-learn and TensorFlow done in python so I could get introduced to the more statistical and big-data side of programming (and of course the ever cool Deep Learning/Neural Nets) while also brushing up on python. But this will be a great resource so now I can take some of the concepts from this book and work them out in java. 
How do I run .jar files with this ver? (9.0.1-1)
Good luck finding money to halt project development for two years to rewrite the entire project from scratch.
Great post! It's always super informative when someone can explain why something is wrong (or not best practice) and then shows how to improve it. Well done.
Just curious, if you don't mind, could tell us why adding new features is a horror to this legacy project? Is it because of a lack of use of specific design patterns?
Get yourself Effective Java in the third edition from Joshua Bloch!
I think Effective Java should be read after reading an introduction book like Java: The complete refrence
**Sidebar** -&gt; **NO programming help, NO learning Java related questions!** 
Please, check /r/learnjava.
You seem to have downloaded Java 9. On console (provided you set JAVA_HOME): * Java 9: `java --permit-illegal-access -jar YourJar.jar` * Java 8: `java -jar YourJar.jar`
Core Java for the Impatient or Core Java SE 9 for the Impatient by Cay S. Horstmann (he has a few similarly-titled books, you want this one).
It's not just design patterns. The worst thing about legacy code is the lack of documentation. So it's code that works but nobody knows how. If it's well written then you can manage to understand it and implement new features. But if it isn't? Also, sometimes the feature you want to implement is not compatible with the existing structure. That's when you are forced to refactor everything and migrate to a maintainable implementation.
I find Core Java more "readable". I can't explain why. Maybe it is just a personal preference.
There is a version for '* for the inpatient'. Any thoughts around that? 
I prefer to read something lighter when I’m going through a medical procedure.
[removed]
I find myself using Validate.notNull (as in apache commons lang library) fairly often. It's a simple function that takes an Object and optionally a String. If the object is null, it throws a NullPointerException with custom message or a default message if none is specified.
Objects.requireNonNull ? (Since Java 8 I think)
I wasn't aware this was in. Thanks for pointing it out!
Close by is `Objects.equals`, which comes in really handy when either operand could be null.
It's less typing than an if-throw construct an will be inlined by the jvm anyway. 
A function I call waitOnCondition that takes an Object lock, and a BooleanSupplier and waits on the object until it is notified and the condition is true.
We use it on the boundaries of the system. So not internally, only in the parts where invalid values (controllers for example) might come in. 
I would like Java to have built-in equivalents of C++'s `pair` and `tuple`. Performance might not be that different from a hand-coded one, but the convenience would be certainly palpable.
I don't think that's a practice I would encourage. Relies on multiple bits instead of wrapping everything up in a callback or a future. 
JavaFX has a [Pair](https://docs.oracle.com/javase/8/javafx/api/javafx/util/Pair.html).
I mainly use it for functions not on the critical path. As I work with systems low on resources, all those not null checks can add up. For those functions I try to stick to primitives because can't be null anyway.
Heh didn't know about this function, I'm using Guava's checkNotNull.
Oh dear $DEITY, why are you working at this low of an abstraction? There are tons of tools to help.
Apache's commons-lang has these.
Any time I start a new project I always end up writing my utils for writing and reading files from the filesystem. One for a generic filesystem location, one for the resources folder, another for Properties files, and so on. Now, File IO is in general painful in any language, but in Java it really sucks, eg. diving into InputStreams and BufferReaders (NIO in Java8 makes it simpler but not too much). Most of the times I forget the little differences between using the runtime ClassLoader or the SystemClassLoader (d'uh!). I always lose a couple of hour on Stackoverflow. And if files are not character oriented but byte oriented, then is gets even worse, and you end up sparing yourself big pains and move everything to a wrapped Apache Commons. I love Java but I have never understood while file IO is always so painful. 
All written by me except for 'VTextIcon.java' (found in Inet): src/org/common/libraries/enumerations/ExitCode.java src/org/common/libraries/etc/ArgsParser.java src/org/common/libraries/etc/CyclingSpinnerListModel.java src/org/common/libraries/etc/InitCheckException.java src/org/common/libraries/etc/MessageHeaders.java src/org/common/libraries/etc/ReadLabelContentsInBracketedText.java src/org/common/libraries/jpanelwithjcheckboxes/JPanelWithJCheckBoxes.java src/org/common/libraries/jscrollpaneshowingarrayofjpanels/JScrollPaneShowingArrayOfJPanels.java src/org/common/libraries/jscrollpanewithtablerowswithboxandstrings/JScrollPaneWithTableRowsWithBoxAndStrings.java src/org/common/libraries/messageinnewframeandthread/MessageInNewFrameAndThread.java src/org/common/libraries/utilities/AfterSearchItem.java src/org/common/libraries/utilities/ExternalProcessLauncher_Forget.java src/org/common/libraries/utilities/ExternalProcessLauncher_Wait.java src/org/common/libraries/utilities/File2TextConverter.java src/org/common/libraries/utilities/FileAsArrayList.java src/org/common/libraries/utilities/FileLister.java src/org/common/libraries/utilities/FindTextInFiles.java src/org/common/libraries/utilities/GenericFileChooserFilter.java src/org/common/libraries/utilities/HintsToWindowManager.java src/org/common/libraries/utilities/IsDirFilter.java src/org/common/libraries/utilities/IsDirWithNameFilter.java src/org/common/libraries/utilities/IsFileFilter.java src/org/common/libraries/utilities/IsFileNotDotNameNotBackupWithExtensionExceptExtensionFilter.java src/org/common/libraries/utilities/IsFileNotDotNameNotBackupWithExtensionFilter.java src/org/common/libraries/utilities/IsFileWithNameAndAnyExtensionButFilter.java src/org/common/libraries/utilities/IsFileWithNameFilter.java src/org/common/libraries/utilities/JFileChooserHighlightedItemReader.java src/org/common/libraries/utilities/MathTools.java src/org/common/libraries/utilities/SearchInFile.java src/org/common/libraries/utilities/SearchResult.java src/org/common/libraries/utilities/TimedReadStandardInput.java src/org/common/libraries/utilities/WithNameFilter.java src/org/common/libraries/videoinfo/CollectionOfVideoInfoObjects.java src/org/common/libraries/videoinfo/VideoInfoObject.java src/org/common/libraries/videoinfo/VideoInfoObjectSelectionConditions.java src/org/common/libraries/videoinfo/VideoInfoSystemData.java src/org/common/libraries/vtexticon/VTextIcon.java 
I write this line so often, everytime our REST-Requests are validated by the 1.) Resource 2. Controller 3.) Service 4.) Repository 5.) DAO etc. 
YAGNI is for features. Not for security and maintainability.
May I suggest: public class Pair&lt;A, B&gt; { private final A first; private final B second; public Pair(A first, B second) { super(); this.first = first; this.second = second; } @Override public int hashCode() { int hashFirst = first != null ? first.hashCode() : 0; int hashSecond = second != null ? second.hashCode() : 0; return (hashFirst + hashSecond) * hashSecond + hashFirst; } @Override public boolean equals(Object other) { if (other instanceof Pair) { Pair otherPair = (Pair) other; return ((this.first == otherPair.first || (this.first != null &amp;&amp; otherPair.first != null &amp;&amp; this.first.equals(otherPair.first))) &amp;&amp; (this.second == otherPair.second || (this.second != null &amp;&amp; otherPair.second != null &amp;&amp; this.second.equals(otherPair.second)))); } return false; } @Override public String toString() { return "(" + first + ", " + second + ")"; } public A getFirst() { return first; } public B getSecond() { return second; } }
 static public boolean isEmpty(String s) { return s == null || s.trim().length() == 0; } the String.isEmpty function only returns true if length() is 0 so a whitespace string " " is not empty and as it is an instance method calling it on a null String will generate an NPE.
You can just add the static imports to the test class template in IntelliJ
Wow, somebody really likes functional programming. 
I think they are waiting until data classes are available, so they can avoid what they had to do for primitives with the Stream API: OptionalInt, IntStream, ... which they have to depricate then.
You should look at apache.commons `StringUtils.isBlank()`, which also returns false on control characters. Technically, a white-space is not an empty String.
.
Most utilities are covered by apache.commons or guava. What I was using on few occasions: public static &lt;T&gt; Predicate&lt;T&gt; distinctByKey(Function&lt;? super T, ?&gt; keyExtractor) { Set&lt;Object&gt; seen = ConcurrentHashMap.newKeySet(); return t -&gt; seen.add(keyExtractor.apply(t)); } Which allows me to do e.g. the following: `persons.stream().filter(distinctByKey(Person::getName))` [Source](https://stackoverflow.com/questions/23699371/java-8-distinct-by-property) 
A class full of static methods that take a vararg and returns a collection, e.g. CollectionBuilder.arrayList(1,2,3); CollectionBuilder.hashMap(key1, value1, key2, value2);
Having dependency on JavaFX just to have a pair is unacceptable, unless you are already using it.
Read again what I wrote: "Default test class template contains import static org.junit.Assert.*;, but you have to disable Optimize Imports on Fly", and make sure not to optimize imports before using some of them...
There's a lot of good programmers without github contributions. 
Uh JavaFX has a pretty tits Pair&lt;K V&gt; It's part of java core (I think?), but you have to use the jdk.
and Arrays
Arrays.asList
https://docs.oracle.com/javase/9/docs/api/java/util/Map.Entry.html
I said ed expicitly that i have to use it for reading binary files
And that's also in there.
Correct a whitespace string isn't technically empty but it depends on the context in the application as to whether you need to check for missing data or not. Having a white-space only string might pass the "has data been entered into the text field" validation but the data itself isn't valid. So this is just a quick check for that. As to Apache Commons, I've never understood the need to pull in an entire 3rd party package for functions like this when it is just as easy to write them. If I had need of a large number of utility functions that it provides it might make sense, would again depend on the context of the code.
Sometimes you want an actual ArrayList as the list wrapper returned by Arrays.asList doesn't implement the entire List interface (in particular, add)
 List&lt;T&gt; list = new ArrayList&lt;&gt;(Arrays.asList(t1, t2, t3, t4,....));
It's only a little messier. Now do that for a HashMap.
Dumb question, a lot of people are using Spring Boot. I see a lot of one Controller applications with Spring Boot. With more complex applications, let's say you have 100 end points, does each end point have a separate Spring Boot instance and then how do you test that locally? Do you fire up 100 instances of spring boot?
* I like the initial compilation step that may reduce some runtime errors * The JVM is well engineered despite sometimes being resource intensive. * Well designed, top industry standard libraries 
From what I've seen, it might be appropriate for Java to have `Pair.of(5, "a")` rather than `makePair`.
Wicket has a cool, testable framework for HTML4.0 MVC applications. But how does it handle new ajaxy single page apps?
You might like Kotlin :)
Warning, the link to jcentral uses http instead of https. This is a really bad idea.
Yes, it gets messier for Map. Something which I use is `ImmutableMap` from Google Guava, only limited to 5 key-value pairs. Map&lt;K,V&gt; imMap = ImmutalbeMap.of(k1 ,v1,k2, v2,....k5,v5); Again if we want a mutable collection, pass it to a map constructor `new HashMap&lt;&gt;(imMap)`. Good thing is, if we are on Java 9, we can use factory methods `Map.of()`, `List.of()`, `Set.of()`.
&gt; Regarding pull requests for j2html: Do you see a realistic path towards the features / design goals I described? My approach brings some clunky looking generics with it. Maybe it is better if I prove it out more in my own project and get some feed back from potential users, before I even consider proposing changes to j2html. The current j2html library is pragmatic and seems to work well for its user base. &gt; &gt; What do you think? I won't be merging any breaking changes for a while, but it's something to consider for v2. I actually wanted to try creating a full version of the concept described here: http://benjiweber.co.uk/blog/2015/08/21/html-in-java/ 
 public static boolean isNumeric(final String input) { return IntStream.range(0, input.length()) .allMatch(i -&gt; Character.isDigit(input.charAt(i))); } If you're really determined to use streams to iterate over a String, then: public static boolean isNumeric(final String input) { return input.chars().allMatch(Character::isDigit); } is less insane. `sortCharactersInString` is a real sledgehammer though - a regex and a stream of strings, just to sort some chars.
&gt; To avoid future naming collisions, let’s follow [java naming package conventions](https://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html) and rename packages to this form: ... &gt; `roller.coaster.tycoon` The package name is really bad. It uses dots to separate arbitrary words. This is generally a bad practice. It leads people to think that `my.cool.project` is a good package name. And features can be packaged in `my.cool.project.server.component` or something similar. If you really want to use such phrases use `rollercoastertycoon` or `roller_coaster_tycoon` (ugh). To really comply with the java naming conventions `com.craftinginjava.rct`, `com.github.gerardszczepanski.rct`or even`com.craftinginjava.rollercoastertycoon` would have been the right choice.
Thanks for the heads up, I’ve fixed this now. 
Nice, thanks for fixing it.
I tend to find the re-usable useful ones are in Apache Commons already.
 public static &lt;T&gt; T[] concat(T[] first, T[] second) { return Stream.concat( Stream.of(first), Stream.of(second) ).toArray(i -&gt; (T[]) Arrays.copyOf(new Object[0], i, first.getClass())); } Call me old fashioned, but: T[] arr = Arrays.copyOf(first, first.length + second.length); System.arraycopy(second, 0, arr, first.length, second.length); return arr;
Why not just use ArrayUtils? http://commons.apache.org/proper/commons-lang/javadocs/api-3.1/org/apache/commons/lang3/ArrayUtils.html#addAll%28T%5B%5D,%20T...%29
Yeah, but what's the point of writing a library that just redirects all methods to another library.
The CPU should not be that slow and I guess the problem is Payara Micro uses too much memory. I am interested in the performance of other light-weight frameworks without Java EE and Spring. 
I get your point. Just saying that you should have commented one level up.
Can't remember the last time I used it.
Wouldn't it be better to return a **Stream&lt;T&gt;** of elements instead of a materialized collection? More freedom to the caller.
Using lambdas and streams is a functional style of programming.
What about @NotNull
I'm with you on file IO and used to have huge pains with date/time before using Joda Time and now Java 8 Time, my gosh how the world was terrible before those.
Still supporting Java 6 (I know), so it's doing things like: Y[] map(X[] x) { Y[] y = new Y[x.length]; for (int i = 0; i &lt; x.length; i++) y[i] = map(x[i]); return y; } But of course, that's now solved with `Stream.map().collect()`
lets be more specific: AbstractMap.SimpleEntry&lt;String, String&gt; pair = new AbstractMap.SimpleEntry&lt;&gt;("key", "val");
This a fantastic thing to help me learn streams, I've read a textbook, made notes, but nothing compares to real life examples. Thanks!
Wouldn't this be more about value classes and/or generic specialization? With just data classes, you would still need your PrimitivePair classes 
&gt; real life examples. These are about as far from real-life examples as you can get...
What /r/chris13524 said to address the "functional programming" aspect, but it may be worth noting that primitives (boolean, char, byte, short, int, long, float, double) aren't Objects, but yes most things in Java are Objects. I'll have to see more about the upcoming ([value types](http://www.jesperdj.com/2015/10/04/project-valhalla-value-types/)) to see where they fit into all of this. There are object variants of the primitives (Boolean, Character, …) that are Objects, and there is auto[un]boxing that can move between primitive and object variants of those, but it's still good to know the difference between primitives and objects. 
I'm writing a game so perhaps it's a different circumstance? I need to wait for conditions which are met by code that is being called on other threads. For example, I have a waitOnCondition that waits for the game's exit status to be true before calling the shutdown code, the exit status occurs under multiple circumstances such as the window being closed or the escape key being pressed.
Nice, will take a closer look tomorrow for my day job
Able to solve puzzles programmatically or being good with algorithms does not a good developer make. And that’s what annoys me the most. If that’s what a company is really looking for, then OK, but to create these complex coding challenges is disingenuous and (as mentioned earlier), is evidence of a flooded labor market and a lazy recruitment process. Sucks, but that’s the way it is and developers need to figure out a) how to differentiate themselves and b) find the employers who don’t use those practices. 
I think skipping the list creation could be seen as valuable, but it's not like it's consequential in 99.99999% of cases. I used `Arrays.stream(elements)` recently and only did that because I didn't feel like doing `Arrays.asList(elements).stream()...`
Meh, I prefer clean code over small jars. It doesn't cause any problem to my app in production. 
I'd be interested to know how to improve my code, but concurrency is pretty hard to discuss because it requires so much context. I'm writing a game, so that may be part of why I'm doing it this way.
I'm quite sure that /u/lukadeder is only criticizing the implementation of `concat(T[], T[])`, not the existence of a `concat(T[], T[])` utility function. If that utility function lives in a private `ArrayUtils` class or a library does not matter much. Using an external dependency for trivial stuff has nothing to do with clean code.
I cannot live without these: public static &lt;E&gt; Iterable&lt;E&gt; iter(final Iterator&lt;E&gt; iterator) public static &lt;E&gt; Iterable&lt;E&gt; iter(final Stream&lt;E&gt; stream) public static &lt;E&gt; Iterable&lt;E&gt; iter(final Enumeration&lt;E&gt; enumeration) Also lots of easy-to-inline stuff to save some typing or bugs caused by typos: public static boolean equalOrNull(Object a, Object b) public static void notNull(Object... values) throws NPE 
while this code is bad (unnecessarily using streams, no license) it raises an interesting point. we can "easily" share jars with maven, but there's no technique for sharing a single method or class (short of making a jar for it) 
Didn't look at the source code, but I personally would not use a 3rd party dependency for something so trivial. Already have something like this setup for before, after and exceptions on all api hits. &lt;50 lines of code with AOP. Can create util and ship it as part of your squad's internal util library for max re-usability.
To be honest, OOP and Functional Programming are orthogonal. The presence of one does not necessarily preclude the possibility of the other's presence.
I see your logic, but the point is that some folks can be very particular about what libraries can be used in a project - some companies that I have worked in had very strict guidelines in place, especially for open-source libraries (their greatest fear was having to maintain the library if development suddenly stopped, rather than performance). 
and also telling us "it doesn't work" doesn't help us at all helping you. Also if you want to mod, you might consider installing the JDK and not a JRE.
Sorry, but not interested. My use case is very particular to Competitive Programming, and "getFirst()" and "getSecond()" work just fine when you are not using an IDE.
Just tested out the type inference feature, and it's pretty sweet! Sample code: import java.util.Map; import java.util.HashMap; import java.util.Set; import java.util.HashSet; import java.util.Random; import static java.lang.System.out; public class VarTest { static class Pair { int first; int second; public Pair(int first, int second) { this.first = first; this.second = second; } @Override public String toString() { return "(" + first + ", " + second + ")"; } } private static int getValue() { return 42; } private static Pair getPair() { Random rand = new Random(); return new Pair(rand.nextInt(100), rand.nextInt(100)); } /* // this doesn't work - yet private var getName() { return "Fubar"; }*/ public static void main(String[] args) { var x = new HashMap&lt;String, Integer&gt;(); x.put("One", 1); x.put("Two", 2); x.put("Three", 3); x.put("Four", 4); x.put("Five", 5); for (var e : x.entrySet()) { out.printf("%s : %s\n", e.getKey(), e.getValue()); } out.println(); var foo = getValue(); out.println("foo\n"); for (var i = 0; i &lt; 10; i++) out.printf("%d ", i); out.println(); var pair = getPair(); out.println(pair); out.println(); /*var name = getName(); out.println(name);*/ } } Sample run: $ javac -version javac 10-ea $ javac VarTest.java &amp;&amp; java -cp . VarTest Five : 5 One : 1 Four : 4 Two : 2 Three : 3 foo 0 1 2 3 4 5 6 7 8 9 (42, 98) Noooiiice! :-) 
Yeah cool. Java is becoming more and more like Javascript. I wonder what the performance penalty is on this, if any.
`var` as a return for will never work. It is only for local scope variables.
I agree that it looks nice for things like: var x = new HashMap&lt;String, Integer&gt;(); However I would prefer if it did not work for things like: var foo = getValue(); We are going from the type being written twice to it being written 0 times. My preference would be to see it exactly once. But I am happy for var anyways.
Probably no performance penalty at all because it is not like Javascript. The type in these cases can be inferred at compile time (so it should not have any difference in the bytecode and so no difference at runtime).
Never say never! Even getting type inference this far was quite unimaginable a fews years back!
I will complexify the learning of the Language. Each time there are two ways to do the same thing, it is not easy to teach it In addition, I don't see any advantage with the recent IDE which can deduce the type for you. For instance it complexifies the reading of the code written by someone else 
Does IntelliJ even support JDK 10? Maybe you could an example of what you mean. It's not very clear to me what you're trying to say!
Thanks for this. It definitely seems like a great addition, especially for short lived objects.
I think hence the limited type inference as an experiment. C++ has also a version of `auto` hell which I agree does make things difficult to read and understand, but it will be interesting to see if Java ever goes down the full-blown type inference route. That being said, something like `var foo = &lt;complicated type declaration&gt;` is more for ease of typing and reducing visual clutter. Does an IDE do that today? I mean on the LHS.
Type inference is not dynamic typing.
I'd say it is pretty firm never. AFAIK, there aren't any statically typed languages that allow a "var" return (ok, Dart did it, but they view that as a mistake). There are a few problems with var as a method return. First. What type should it be, no really, what type exactly? If I return a HashSet&lt;Integer&gt;, should the method give back a HashSet, Set, Collection, an Iterable, or an Object? What if I decide that a TreeSet or an ImmutableSet is better? Now I've made a potentially breaking change to my API! And what if in one spot you return a HashSet and another spot you return Collections.emptySet? What is the return type supposed to be? You may say "Set, duh!" But how is the compiler to know that? And what if you accidentally return a Long? Then the return type would potentially be Object, without any compiler warning that you are making that change. And then further, if anyone wants to use your method, How will they know what it returns? Do they have to read and understand all of your code BEFORE coding against it? It will never happen. You can search out talks on var from people like goetz, and they all say about the same thing.
You can ask a suggestion for the type. Maybe it does not work all the time. However, when it is really complex I am not sure that it is an advantage to not know the type
I disagree. If you've been using lambda's, there is a good chance you've already seen type inference in action. I've yet to run across a lambda that it isn't fairly trivial to deduce what the type is based on context.
IntStream distinct also boxes the entire array!
I'm sure it would do - IntelliJ certainly doesn't just search for the text of the class name. It has a model of your program and will apply the same algorithm to work out what type the variable is as the compiler does.
I agree that it can be useful sometimes, like in the cases you mention. However some aspects are dangerous. Removing the type is not a good idea in general espacially for the beginner 
This exactly what is going to be bad. In C++ sometimes this is almost impossible to know the type, so we let the compiler to deduce it. At the end, the code work but it is imossible to read it. Look at the new C++ code, with a ton of template. It is really difficult to read it. Java is maybe verbose but you have almost no effort to read/understand the code. So, the time you need to read the code is not long. When thinks are really complex I have some doubts about the advantage. Try to read a PROLOG code 6 months after you wrote it and you will understand. Each line is VERY important. Honestly this is not an advantage but a drawback
Sigh.... who has really seen the future? "Never" is a pretty strong word.
Agreed.
So all dynamically typed languages are impossible to read, write, and maintain? Most Java IDEs provide excellent auto completion, figuring out what the type is will be trivial in java in day to day coding if you are using an IDE. So that leaves those doing java dev without an IDE, which, honestly, why? I see them as the same people that would argue against syntax highlighting.
hmm, didn't realize that C++ added that in 14. The argument for why not still stands though. What does C++ do when the type is ambiguous? And how does it handle multiple return types?
No, your argument is valid. Even I don't think that it's a good idea to insert it in every conceivable place, and with C++, they don't really have an equivalent of Java's `interface`, so it works better for them. That being said, I have seen cases where the compiler is unable to determine the proper type for `auto` and it fails at compile time with an ambiguous type error message. As for multiple return values, all the return types must agree otherwise it is again a compile time error.
More like Scala you mean...
&gt; Never say never! Even getting type inference this far was quite unimaginable a fews years back! Er... not really, C# uses a similar object system to Java and has support this same feature, using the `var` keyword no less, since 2007.
A Java `interface` in C++ is an abstract class only with pure virtual functions.
It's a compiler feature, so there should be no performance change at runtime, only at compile time.
I'm not saying one should go full retard importing libraries. But I think it's better to use code that has already been written and tested for the more generic stuff and focus on your business logic. 
Well yes, obviously we can never know for sure. I am simply choosing to be optimistic that they will stick to their choice and not make this mistake.
all dynamically typed languages are difficult maintain FTFA
Not sure why the facility to instantiate without invoking a constructor is necessary for mocking frameworks. They have to weave bytecode anyway to add mocking support to the class so why can't they just add a constructor which doesn't do anything while they're at it?
Here's an edge case use-case. Because I'm maintaining a code generator, I have many classes of the type: `a.b.c.d.e.f.ClassName` and `a.b.c.d.e.g.ClassName`. The class names are the same, but the packages are different. `var` will really help here, because I can write tests like these: var f = getInstanceInPackageF(); var g = getInstanceInPackageG(); Instead of fully qualifying the two types all the time. There's really no value in some cases of writing down the actual type name. Of course, another feature that would be nice to solve the same problem is partial imports, e.g. import a.b.c.d.e; // Importing a package And then // Now, "f" and "g" behave like top level packages f.ClassName = getInstanceInPackageF(); g.ClassName = getInstanceInPackageG(); Combined with local imports (i.e. imports with a scope of a method), that would be a really cool solution. As you see, there would be several ways to do the same thing, but they do add value in some cases at the relatively low price (in these cases) of learning the feature.
Type inference has been seen in action since Java 1.0. Good old: StringBuffer sb = new StringBuffer(); sb.append("x") .append("y") // Whoa! Type StringBuffer is inferred, here!
That is not what type inference means, and that is not type inference. Append is simply returning this (type of which is the type of the class) so method calls can be chained. 
&gt; In C++ sometimes this is almost impossible to know the type, so we let the compiler to deduce it. At the end, the code works but it is impossible to read it. You can write bad code in any language. But you are right: Java is known as a very expressive language. Annoying to write manually (without IDE help), but easy to read, parse and analyze by humans and code. This changes a little bit with the addition of `var`. 
You don’t need to worry about templates affecting code quality in Java, though. 
Oh I am so on that!
They're really not the same though. An interface forces you to implement the methods unlike C++. Also, I was talking more in terms of the contract of class... kind of like C++'s concepts.
That is a very interesting (and novel) use case! Even though it may appear a bit weird, you're right - I have had cases where several different libraries have had the same class defined in them, and I did have to type the whole type every single time. Of course, with `var` if we can keep our mental model of the different classes straight, then it should not be any problem! And frankly I don't see why - languages like Haskell have full-blown type inference and no one ever complains about type annotation not being present. Of course, explicit OOP brings about complexities, but in the current form I think `var` is quite nice! :-)
Or the compilation speeds! :D
Okay, fine. I am willing to be broad-minded about it. Can you point to some resources that you had mentioned where these issues have been discussed? I'd like to form my own opinion on them - especially interested about the backward compatibility part. Granted Goetz and others are the ones actually knee-deep in it, but it wouldn't hurt to still consider the points with a fresh viewpoint!
Hahaha! The JEP does mention about breaking people's source code what with surely someone (a lot, maybe) of people having named their variables `var`. It will be interesting to see how many codebases are broken (even though it may not be a huge fix).
For import use case I'd prefer to have simple sugar similar to python's, like 'import X as Y'. No idea why it's not in place after decades. Hate tons of package names in converter classes.
It was just an example, I know that after reading all your comments the shopping cart example was not the best example to set, my idea was to just add something that everyone could understand. My project was not a shopping cart but due to restrictions I cannot say what it was, so I decided to create an example which seems it confuses more than other thing.
Good point. Most modern programming languages do have this feature indeed.
Thank you for the links!
I find videos of how to do IT tasks to be more time consuming and more work than simply reading a clearly written "how to". Every now and then I get irritated when I Google on how to do X and all I can get are video tutorials. Six minutes to learn which 3 clicks I need, versus 1 minute to read it. The best thing for me are clearly written, brief instructions, with a *good* example.
You're right! :-) ... I had forgotten about Voldemort types entirely. 
OCAML for example mixes both.
You cannot create instances of C++ classes with pure virtual methods, thus being forced to fully implement them. 
You cannot create instances of C++ classes with pure virtual methods, thus being forced to fully implement them. 
&gt;but there's no technique for sharing a single method or class It's called StackOverflow :)
Sure, but you can have static functions throughout and still get by without ever creating an instance (even though it would be quite useless, but it would still avoid enforcing implementing methods) whereas that wouldn't work with a Java interface - you would still need to implement all the methods. A more apt comparison would be C++'s abstract class with pure virtual functions and Java's abstract class with only abstract methods. In any case, I was talking about how an `interface` in Java is more like Haskell's type class in that it defines the behaviour that a class must absolutely conform to.
Type inference streamlines code, and has proven successful in multiple languages, including old mainstays like C++. It doesn't complicate code, it simplifies it. C++, C#, Scala, Kotlin, Haskell, and other already have it. Java is really one of the last languages in it's class that doesn't have it. 
Actually, Kotlin does support type inference in methods and fields — even on interfaces.
Something like this does not work though, right? fun foo() { return "Hello" } fun main(args: Array&lt;String&gt;) { println(foo()) }
Not really, as you are forgetting about Java's default methods. You can use C++ "interfaces" just like Haskell type classes. As parameters they guarantee that whatever is being called obeys to the expected set of behaviours. In templates, type traits, enable if and if constexpr can be used to validate type parameters. If you inherited from such class and don't implement all pure virtual methods, at very least the linker will complain.
Purely from purpose of understanding, would these 50 lines of code be able to handle mocked objects (encountered in integration tests), file objects and be optimized for performance? If possible could you share your version so both of us could learn a thing or two from code samples? Perhaps I should list all subtle features of this library in the readme, such as printing file size if its a file object.
I'm not a security expert, but this looks fishy to me. This is essentially doing key = h(&lt;bigbang&gt;) where h is a deterministic function (based on the current time), right? If an attacker knows your &lt;bigbang&gt;, he can just calculate h(&lt;bigbang&gt;) himself and issue his own JWTs. This adds only obfuscation. You really need to rotate the &lt;bigbang&gt;. If you don't want to accept old tokens, there are [registered claims](https://tools.ietf.org/html/rfc7519#section-4.1) you can use, like "exp". Your JWT library of choice should support them.
I'd gladly accept any constructive criticism/feedback.
 fun foo() = "Hallo" fun main(args: Array&lt;String&gt;) = println(foo())
I know, but that's what I mean. It doesn't really work if you want to have a complicated function (with a block) because if you don't use `return`, then it returns `Unit` by default. So it really doesn't work in a lot of circumstances.
Minecraft is an excellent platform for a final project. 
&gt; AFAIK, there aren't any statically typed languages that allow a "var" return Just off the top of my head: C++, Scala, Haskell.
It certainly *could*. IntelliJ's Find Usages is surprisingly bad with public fields, though, and sometimes even just parameters; to the point that I usually change those manually. [Edit] *Bad* here manifesting as an excessive amount of false-positive occurrences.
At the same time, `getValue` is a pretty terrible name for a method unless it's in a very specific context. You should be able to have an idea of the parameter and return types of a method from its name.
you jest, but golang supports depending directly on github. in that light, importing directly from stackoverflow isn't **that** that much of a leap ! npm's answer has been a gazillion micro-packages, which has it's own problems. the options in java are: * maven dependency on the full jar * copy/paste from stackoverflow * proguard or shading there's a huge amount of open source java code out there, but the vast majority is locked up in monolithic jars/projects and as a result, is of limited value as a library. eg, i recently wanted to parse an http request that had been saved as a file. there are dozens of java servers that can parse the request, but i was unable to find one that exposed that functionality at the library level 
How would you instantiate an `interface`? 
Is there a guide or something? 
Because of [opportunity cost](https://en.wikipedia.org/wiki/Opportunity_cost). Given all the things they *could* be working on the ability to disambiguate ambiguous class names *probably* has virtually no return on investment. Anecdotally, we have probably a hundred in-house ambiguous classes in a 500k LOC package, plus all the third-party dependencies, yet we only need to disambiguate a couple of classes a handful of places. It's just not an issue, despite being annoying when it *is*.
Checkout this soft ford of http4k i started for Java8+ codebases https://github.com/fzakaria/http4j Reach out if you'd like to contribute. The idea is to have a very small surface area HTTP toolkit. No chunked encoding, no WS, no Streaming to help keep the code very minimal.
Lot's of points from recent thread. :) One more downside of Optionals overuse is how generics work with inheritance. 
Personally, I think I'd be okay with it inferring the interface all the time. e.g. after "var myMap = new HashMap&lt;String, String&gt;();" the type is Map&lt;String, String&gt;. If I had to settle on this being something I have to explicitly request, then a concise way to quickly indicate "use the interface" could be nice. Something like "var myMap: Map = new HashMap&lt;String, String&gt;();
I think that IDEs will display hints for the inferred type, like IDEA displays field name when you pass litterals to functions to give some context.
Shamir algorithm was used to split the big bang part into several parts.
Make an ascii chess board where two people can play against each other by taking turns at the same computer. You move by entering chess notation, and after each move, it displays an updated board, including pieces that have been taken.
Modding Minecraft is not simple and the code is also not the cleanest. Probably goes over what a Java novice can do unless you're very ambitious: [MineCraftForge Documentation](http://mcforge.readthedocs.io/en/latest/) &gt; This documentation is only for Forge, this is not a Java tutorial.
Yea, though for some reason I have to point it out again and again.
Cool! Is there like a guide or something because I have no idea how chess notations work.
Run on i5 4core/4thread desktop. With such sad numbers for Payara Micro I highly doubt the ranking will be any different on Nexus5x. Framework | Max Throughput | Avg Latency | Transfer ---------|--------------|-----------|-------- Light Java | 1,344,512.65 | 2.36ms | 169.25MB Spark Java | 194,553.83 | 13.85ms | 32.47MB Payra Micro | 24,768.69 | 118.86ms | 3.50MB [Source](https://github.com/networknt/microservices-framework-benchmark)
That type on RHS is a design error. People that write such code should not get an incentive.
I don't know what the fuck is Mosaic reader, but I'm not reading an article published on that awful platform.
their goal is to reduce boilerplate code; neither of these are accomplishing that
Nothing earth-shattering in there, but some welcome improvements nevertheless. Streamable result sets scares me for what will inevitably turn up in some code reviews!
Yeah that's a good point.
Goetz said `var` will be a reserved type name, so any variables with that name will continue to work. Classes and interfaces, though, will not. Lombok uses the name `var` I believe.
Java has had type inference for quite some time, just not local variable type inference.
That argument has always bugged me. I mean, we got parallel streams (almost no one asked for it), the seventh-or-so attempt at tackling asynchronicity (and CompletableFuture still got it wrong), we got `Set.of()` et al now, which are useful, of course, but have the same opportunity cost as many other things. I keep complaining about the lack of multi line strings, which in their simplest form have almost no cost at all apart from the overhead of product management ("just" allow newline characters between opening and closing `"`)... It's more a matter of coordination and prioritisation, or in other words, someone has to actually do it (every time I complain about the lack of multi line strings, I'm told to create a JEP).
Hello, this may come as a surprise but my largest portion of income at the moment is from modding Minecraft. I use the Sponge API which has many new advanced things like Spigot or Bukkit do not have. One thing you definitely need to know before entering is that the code will be incredibly messy. Documentation and watching others do it online will help you a lot 
Yes, this is /r/java. But saying it's unimaginable when it's been a standard feature for over a decade in a language that *literally* started as a Java clone* is just silly. *Specifically, it started as [Visual J++](https://en.wikipedia.org/wiki/Visual_J%2B%2B) before Sun sued Microsoft over it because it added things to Java that didn't work on non-Windows platforms. Microsoft then developed it into its own language (C# AKA C++++) and developed the .NET standard library/API alongside it.
**Visual J++** Visual J++ (pronounced "Jay Plus Plus") is Microsoft's discontinued implementation of Java. Syntax, keywords, and grammatical conventions were the same as Java's. Microsoft discontinued support of J++ in January 2004, replacing it to a certain extent with J# and C#. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
A lot of these snippets suffer from poor performance.
What on earth is wrong with you? As I mentioned before, I am talking about the feature being in Java, not just its existence in other languages. Hell, ML had it ages ago!
This is just a quick test of the feature, not production code.
Does it include GUI? Cause we're advised not to include that. Otherwise how will I be able to symbolizes chess pieces? 
I disagree. When you are typing complicated declarations a thousand times, the difference is palpable. Secondly, by reducing the declarations, the code actually becomes clearer - the type is clear enough from the RHS anyway. Moreover, the sample program is a test program just demonstrating some possibilities - it is not production code. Also, I don't see what's awful about using 'var' in those contexts? Iterating over the map? Perfectly useful. About returning from methods? Even the proposal mentions similar cases, with better names than this artificial example of course, and other languages have been doing the same for years. Using it in a loop? Hell, why not? I suppose it's what the JEP itself says - a very polarising topic. That does not mean there is only one way to go about it.
You are joking, right? Being literal is one thing, but...
A good summary. Being a very strong proponent of using Optional to properly type POJO/record/data class fields, I've never found the two first objections to be remotely compelling. Brian Goetz's opinion seems to be completely inconsistent with his suggestion that it be used in method returns - getters are a method return! The end result seems to be a message like "strongly type the possible absence of values returned from service methods, but don't you dare have the same strong typing on your data representations". Why we should embrace strong typing on "getFooFromDatabase()" but not on "foo.getBar()" has yet to be explained. His opinion is also inconsistent with his push to add destructuring pattern matching to Java (`Optional` types are perfect candidates for destructured binding!), but I'll hold off on that one to prevent this becoming an essay. ;) Serializability is a valid concern for those who use it, though given that it's been a security nightmare, is a security nightmare, and will likely continue to be a security nightmare I'm not sure why people do. Effective Java's chapter on serialization pretty much says "never never never use this", advice I'm happy to take. And even if you do have to serialize your data classes, just having your getters wrap fields in `Optional` lets you have your cake and eat it too - something [Immutables](https://immutables.github.io/) already does for us automatically. It's the third and final issue that I think actually has teeth, outdated reflective libraries that can't handle `Optional` types. We've found that using recent versions of maintained libraries has meant we never have any issues with handling `Optional` returning methods or fields. YMMV, of course.
It's exactly what I need! Returning spring's StreamingResponseBody or Java ee's StreamingOutput is pain!
I believe his point is that in production code the method name will give enough information about the type of the var to make "var" usable. 
That's the point of ASCII, aka text. You will draw a "GUI" using characters...
Or errors. I swear I’m at least an order of magnitude more productive on big Java projects because I don’t have to deal with compiling Boost.
Oh.... Thanks dude
&gt; I meant: the content can be consumed in both ways, but independently. It's like audio book vs printed. 
&gt; Brian Goetz's opinion seems to be completely inconsistent with his &gt; suggestion that it be used in method returns - getters are a method &gt; return! Brian Goetz never said that `Optional` was for method returns in general. He has a consistent position on the distinction between *result producing* operations (like query methods on services and objects) and return of a data value (i.e., getter). Quoting Brian Goetz: &gt; The answer depends, to some degree, on the question "what is a &gt; getter" -- there's a fuzzy line between "getter" and "method that &gt; returns something." Obviously, there are useful cases for &gt; returning an `Optional` from methods. But in real-world code (for &gt; better or worse), most getters (like, 99%) are just `return x`. In &gt; that case, returning an Optional from a getter means you are &gt; using `Optional` as your *state representation* -- and this is &gt; definitely not what was intended (and falls squarely in the &gt; "zealous overuse" category.) The `Optional` type in Java was not conceived as a generalized sum type, used for describing data representations as in a programming language like Haskell. Traditionally, getter/setters are used for DTOs and JavaBeans which have been used in Java is as a protocol for data transfer (consistent with OOP), completely unlike how data types are used in Haskell. For example: public class JdbcUserDAO implements UserDAO { @Autowired private JdbcTemplate template; @Transactional @Override public void saveUser(BasicUserDetailsDTO userDetails) { template.update( "INSERT INTO (username, password, email_address) " + "VALUES (:username, ENCODE(DIGEST(:password, 'sha512'), 'hex'), :emailAddress)", new MapSqlParameterSource() .addValue("username", userDetails.getUsername()) // Null password is a logic error. Let Java raise the error instead of Postgres .addValue("password", Objects.requireNotNull(userDetails.getPassword())) // Email address is optional .addValue("emailAddress", userDetails.getEmailAddress()); } } Suppose you used Optional: public class JdbcUserDAO implements UserDAO { @Autowired private JdbcTemplate template; @Transactional @Override public void saveUser(BasicUserDetailsDTO userDetails) { template.update( "INSERT INTO (username, password, email_address) " + "VALUES (:username, ENCODE(DIGEST(:password, 'sha512'), 'hex'), :emailAddress)", new MapSqlParameterSource() .addValue("username", userDetails.getUsername()) .addValue("password", userDetails.getPassword()) .addValue("emailAddress", userDetails.getEmailAddress().orElse(null))); } } What did `Optional` buy in this case? The vast majority of cases in which JavaBeans and DTOs are used *in Java*, `Optional` adds a useless wrapper for which the `null` value should simply pass through. Heck, now that I think of it, even in Haskell, you wouldn't use `Maybe` with data types: data EmailAddress = Address String | NoEmailAddress data BasicUserDetails = BasicUserDetails { username :: String , password :: String , emailAddress :: EmailAddress } The `Maybe` type is better for result producing *computations*, and Algebraic Data Types are better for representing missing *data*.
&gt; Iterating over the map? Perfectly useful Hides the type and you're forced to look it up with very little gain overall. Maybe the HashMap is instantiated 1000 lines to the top or in another package. Makes Java even more dependant on good IDE support. Still impossible with review tools. It's implicit inference instead of explicit and cristal clear declarations. &gt; About returning from methods? Even the proposal mentions similar cases, with better names than this artificial example of course As above. Additionally: The example in the JEP is bad practice. Well, they are architects, nothing else to expect... &gt; and other languages have been doing the same for years. Thats not an argument at all. Dynamically typed languages totally fail in that regard: Type inference brings the language **visually** closer to those, though of course and fortunately still compile time safe. C# had to release code guidelines e.g. to be cautious with *var* at method returns and still people misuse it left and right. The same for other languages. Why did Java have to follow those? Java was favoring readability over writeability... thats the past now. &gt; Using it in a loop? Hell, why not? Because you could have just written `int`. It has the same amount of characters as `var` while keeping it explicit.
I'm not always necessarily using an ExecutorService, and they aren't really "tasks" that can be delegated/completed. For example, I use the method when waiting to receive the connect status/game world from the server, which happens on its own. The condition could be met before calling the method.
I've noticed that about lambdas too, and i did not like it. I had to spend some time figuring out the type, instead of just routinely going over the source. And my biggest grudge against Python is specifically its lack mandatory type specifications in source. So i have to follow a parameter trough 3 levels of source code, just to figure out its type.
Indeed: `var list = (List&lt;String&gt;) new ArrayList&lt;String&gt;();` vs. `List&lt;String&gt; list = new ArrayList&lt;&gt;();` 
The nice thing about Java is/was that you didn't have to encode the return type in the name because you'd always know the returned type... until this change of course. 
I can't say that var is a better solution than your generic type in your helper method. Ofcourse that list of sets of maps of etc. doesn't look nice either. Maybe you should create a special type for that, with its functional (as in business-functional) meaning, something like 'class MyDatabaseTable'. You now have a few generic nested collections with no relation to what you are trying to solve. Var won't solve that either, but rather hide its meaning even more.
You don't need anything else for a future. Just create a custom one, or set the results on a CompletableFuture where you find the state for the condition. The point is that you are using two bits, where semantically it's the same event. 
You can do both. You verify the basic URL to avoid the connection, but all URLs can only be parsed by crazy regular expressions. There are several discussions on that on StackOverflow. But the only way to know if a URL exists is to establish a connection to that. But just by knowing it is working once does not conclude it will always be up since you are hitting on a different service.
If you subscribe, you can download a PDF of the entire issue.
With text, as /u/Aposperite said. Either using two letters per piece (w or b to signify white or black, followed by p for pawn, r for rook, etc), or [you can get fancy](https://en.wikipedia.org/wiki/Chess_symbols_in_Unicode).
Ty so much for the help man! 
Just like Lambdas which have negligible usefulness, we lost the var fight already. Java is doing like C# and going the way of the ballywhoers.
I think it was published in 2006, but if I recall correctly, Brian Goetz somewhat recently said that the only changes he would make in a new edition would be additions. The fundamental and really important parts regarding memory consistency, the Java Memory model, Happens-Before relationship, etc., is still relevant. I would say that there are somewhat newer approaches, though you still need to know that other stuff. Unless you are doing 100% pure functional programming, or not doing any kind of multithreading, you will need to learn that. Incidentally, I believe that those parts are part of the reason why many, Brian Goetz included (especially in Java 8, but also in future versions of Java that are being worked upon), are seeking functional programming to a higher degree.
Must read/mandatory for intermediates+ sounds right.
Almost certainly operations that should have been in the original query.
I'll look into it thanks dude!
use interfaces for functions/class members. that gets the same job done.
I don't follow. Let's talk about the following toy example: @Value.Immutable public interface Address { String address1(); Optional&lt;String&gt; address2(); String city(); } How should we represent this such that a) it's clear to people reading the class that "address2" might not be present and b) we receive compile-time guarantees around unsafe access to that field (excluding someone doing something ludicrously and deliberately dangerous like calling `get()` or casting, which is easily caught in code review).
Try Google. I saw some promising results when I did such.
You don't think I tried. I couldn't find anyone that works. 
&gt; still want to limit my lists and maps to the more general List and Map Limiting to general interfaces make sense only in *public* API declarations.
(1) /r/javahelp (2) My experience with image metadata is limited, but you'll want to investigate the [ImageIO API](https://docs.oracle.com/javase/8/docs/api/javax/imageio/ImageIO.html), which can extract metadata from supported formats. Consider third-party add-ons for better support, such as [TwelveMonkeys](https://github.com/haraldk/TwelveMonkeys)
Sorry, but not buying any of your arguments. Hides the type? Give me a break. If you are obsessed with a language that doesn't use an IDE, Java really is not the language for you. Moreoever, I have been using `auto` in C++ for far more complicated types (yes, even without an IDE), never ran into that issue. I don't suppose short-term memory should be that short. And if this were an issue, I guess the Haskell folks are screwed seeing as to how they have full-fledge inference. Ridiculous. Dynamic languages fail at that? Again, not buying it. Your whole argument is based purely on subjective speculation. I have used Common Lisp and Python for years without any problems whatsoever. The mail discussions that another user had shared seems to sum up your conundrum pretty well about how people have been complaining about Java's verbosity for years, and yet when they try to do something about it, the same people crib about it. Well, guess what, these features are here, and there's no going back. The last bit, how many times do I have to reiterate that the sample code just shows where the new feature could be used - it is not a recommendation. 
I think you meant that as a response to /u/redditsoaddicting, and I agree with your argument. For good or bad, any serious Java development does happen on an IDE, and so this feature "harms" Java even less than it does in other languages. I believe the JEP discussions were right about this being a very "polarising" matter.
Tyvm. After realizing the Scene Builder is being maintained changed my mind. I also learned that Gluon provides a mobile library allowing you to make Android and IOS apps with JavaFX too. Pretty cool.
That's my point though - even though this example is purely demonstrative, you can have situations with private methods which will never be part of the public API, and you can get away without over-engineering it especially when the private method simply returns some unprocessed data. It does save a whole lot of typing and visual noise without introducing another layer of indirection just for that.
At this point you're come full circle. Might as well just use the already existing syntax: Map&lt;String, String&gt; myMap = new HashMap&lt;&gt;();
Can you elaborate on lambdas negligible usefulness? I don't think you are right but I just wonder what your arguments are.
**Kerckhoffs's principle** In cryptography, Kerckhoffs's principle (also called Kerckhoffs's desideratum, assumption, axiom, doctrine or law) was stated by Dutch cryptographer Auguste Kerckhoffs in the 19th century: A cryptosystem should be secure even if everything about the system, except the key, is public knowledge. Kerckhoffs's principle was reformulated (or perhaps independently formulated) by American mathematician Claude Shannon as "the enemy knows the system", i.e., "one ought to design systems under the assumption that the enemy will immediately gain full familiarity with them". In that form, it is called Shannon's maxim. In contrast to "security through obscurity", it is widely embraced by cryptographers. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Mocked objects - yes. Don't use file objects, however, yes, it should, there's nothing unique about them. At the moment it would depend on which File implementation is used as it will just call to string on it. But that can easily be amended, as it simply was not considered due to not having to deal with files. No optimisations where done, from testing it and looking at visual-vm it did not impact the performance negatively in a substantial manner. (Can't tell exact figures, have been awhile). I mean, its a simple intercept on every single rest API controller call. Logging args before hitting inside of the controller, and then after it goes through service logic and just before controller responds. And third scenario is if there is business or any other exception. I am on holiday this week, but next week I can put something together for you to take a look. But yes, a more detailed readme would also be helpful, if you were to explain all those intricacies about performance optimisation and additional logging for specific file types, i.e. file size.
That's about generic wrapper for subclass can't be used as wrapper&lt;base class&gt; problem. So you have to unwrap your Optional from getter to combine with other optionals you have in caller class. Just try to imagine delegating getter that should return Optional&lt;Base&gt; based on Optional&lt;Subclass&gt; from other DTO, like: return Optional.ofNullable(x.getBase().orElse(null)); Of course, you can also use &lt;? extends base&gt; in some places, but it adds even more pollution and complexity to your code. IMHO, you SHOULD NOT even have a line of getter/setter code commited in your project and even think about problems like how your fields/getters work with your frameworks. Moreover, since you can't consistently use Optionals in getters in whole project (you can't!, because of external dependencies, generated code, i.e. from wsdls and in DTOs related to some frameworks that have issues with Optionals), adding Optionals in SOME places is even more misleading and error-prone, to me than just having nullable fields. I agree that default nullability is an issue in java, and like how Kotlin deals with it, but I strongly disagree that using optionals in fields/getters is anywhere close to solution. And it looks more like a new-age anti-pattern that could become popular nowadays and will be hated in a few years.
Yes
How about just using `new URL()` and catching `MalformedURLException`? Be careful though, URL is a horribly broken class; URI is better but doesn't restrict to just URLs, i.e. "urn:foo:bar:1234" is a valid URI, but not a valid URL.
C'mon, how comes in Scala or Ceylon opportunity costs somehow different than in Java? &gt;we only need to disambiguate a couple of classes a handful of places You are most likely just not working on the projects with complex architecture having lot's of DTO layers.
**Sidebar** -&gt; **NO programming help, NO learning Java related questions!** These should go in **/r/javahelp**
I mean the one which is their "Crystal Reports" type solution. So not the ones embedded in the BI Server but the standalone version. 
The examples should have really put those resultStreams into a try-with-resources statements. If the stream is really lazy (as promised in the article, but not as implemented in the `javax.persistence.Query` default method), then we'll get resource leaks all over again after finally educating all the juniors about correct JDBC usage. Of course, it would be great if there was such a thing as an [auto-closing stream](https://stackoverflow.com/q/34753078/521799), but that's not possible with the current stream design.
It is amazing how deep layers of complexity arise, when one avoids initializing its objects oneself. But who am I to say, I do the same, just not with runtime reflection. ¯\_(ツ)_/¯