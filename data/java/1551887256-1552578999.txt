Thank you for pointing that out. I'll look more carefully. I think it would be more useful to make that info available on the r/java page.
&gt;Organizations that want to run on a secure JDK have had to upgrade the JDK at least every six months for about a decade now. Not exactly, what organizations have been able to do is retrieve and apply security patches as they came out so long as they were running a version of Java still being supported. Java 7 was supported from release in 2011 through 2015 openly and 2022 with extended support. Java 8 was released in 2014 and open support until this year when the new licensing kicked in. Java 9 was a boondoggle released in 2017, support ended in 2018 and wasn't widely adopted. Java 10 then really started the cycle released in March 2018 supported thru Sept 2018 but Java 11 is listed as an LTS candidate. &gt;I think you should also research what the new version numbers mean, because it seems to me you may have misunderstood. To reiterate, companies now need to do fewer big upgrades. I'm aware of what is being *stated* it means, but as I previously pointed out I have been involved with Java (very deeply) since Java 1.0.2 and there have been many upgrades causing issues. You mention the "Chrome versioning" but just how many recent Chrome changes caused push back from users? Citing that as the model doesn't do much to allay concerns. Considering the fact that the new module based approach is still so new that few open source packages support it and that there are still large numbers of "deprecated" features in the current code base, simply dropping a package out of the standard module or removing a long time deprecated feature could have a major negative impact to an enterprise system that by design moves much slower. All you need to do is look at various forums to see a decent number of questions regarding the fact Webstart was dropped. Webstart based applications are used quite a bit internally at many organizations. Large enterprises, one of the backbones of Java usage, quite often have feature release cycles that take 3-6 months for various reasons including impact to customers. Now they're being told without a license from Oracle basically during every feature release cycle they also have to assume a JVM upgrade cycle which will necessitate additional planning and testing. So for now AdoptOpenJDK is at least an option to allow the enterprise to control what it releases when, assuming you're allowed to use it. But you have to ask, if Oracle's new model is so much better, why is there even an AdoptOpenJDK offering that continues to provide the support for older versions? 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt; they were running a version of Java still being supported. They were running *major* versions that were being supported. Major versions don't exist any more. &gt; Java 10 then really started the cycle ... Right, but Java 7, 8 and 9 were major releases, 10, 11, 12 etc. weren't. JDK 10 was a release of roughly the same size as 8u40 (both had 12 JEPs). JDK 9 had ~90. &gt; Citing that as the model doesn't do much to allay concerns. All I'm saying is that both major and minor updates under the old model required full regression testing, and both occasionally caused breakages. The new model is not directly comparable to the old one, but the new feature releases are certainly not major releases (but they're not quite minor releases, either). I can understand that any such change may be a cause for concern, but I don't see how it's reasonable to *assume* that a model designed to make upgrades easier would make them worse. I can understand this assumption even less if it is based on comparing feature releases to major releases, which they clearly aren't. &gt; could have a major negative impact to an enterprise system that by design moves much slower. True, but it could also turn out to have a very minor impact. In any . event, this change was absolutely necessary. A non-modular JDK was not maintainable, and Java could not continue with the major/minor release cadence and remain competitive. &gt; every feature release cycle they also have to assume a JVM upgrade cycle which will necessitate additional planning and testing. In that regard they would be wrong but only in the sense that the semi-annual update releases have always (in the last decade) been quite big (&gt;10 JEPs), and have always required planning and testing. &gt; But you have to ask, if Oracle's new model is so much better, why is there even an AdoptOpenJDK offering that continues to provide the support for older versions? First, AdoptOpenJDK exists as a viable option *because* the new model allows for it, now that Oracle open sourced the JDK (AdoptOpenJDK is building code developed mostly by Oracle). Second, people still mistake the new feature releases for the old major releases. Third, even those who understand the new feature releases may prefer a less gradual upgrade process for their own reasons (and the new patch releases will be much smaller than the old minor releases). Some of those people will use free builds by Adopt, some will use free builds by Red Hat or Amazon, and some will pay Oracle for a subscription and help fund the continued development of OpenJDK. 
I feel like this is mostly right. REST is the thing to use for CRUD when your data *is* hypermedia. (Those HTTP methods (get/post/put/delete), all about CRUD) But if your business data isn't hypermedia, then trying to change it's shape to meet that standard just so you can have a REST api is adding more complexity than is needed. (Also, none of your business data is hypermedia, unless you're Wikipedia)
&gt; Any suggestions? Yes, read the sidebar.
If I might be so bold, you may want to give kotlin a try. I like to think of that as a sort of next generation java. Http://try.kotlinlang.org
public static void main(String[] args)
Go google stuff, I guess. It’s perfectly coherent.
Codegym.cc is a great place to start
Wrong subreddit. Such questions belong in /r/learnjava. The /r/learnjava sidebar (old reddit) has some highly recommended tutorials, one of which is on Udemy. From the sidebar of /r/learnjava: &gt; &gt;**Free Tutorials** &gt; &gt; * MOOC [Object Oriented Programming with Java](http://mooc.fi/english.html) from the University of Helsinki &gt; * [Java for Complete Beginners](https://www.udemy.com/java-tutorial) &gt; * accompanying site [CaveOfProgramming](http://caveofprogramming.com) Do the MOOC. You will not regret it. ---- As for taking notes: handwriting is the most efficient way as the retention is much higher than when typing the notes. ---- **Removed** - wrong subreddit
Codingbat
&gt;Right, but Java 7, 8 and 9 were major releases, 10, 11, 12 etc. weren't. JDK 10 was a release of roughly the same size as 8u40 (both had 12 JEPs). JDK 9 had ~90. Correct and there is absolutely no way you can ensure the same level of upgrade won't happen in the new model unless there is an intention to basically stop improving the platform. &gt;All I'm saying is that both major and minor updates under the old model required full regression testing, Agreed but the old model allowed for sufficient time to introduce the updates, the new model is a 6 month cycle unless you purchase a license. &gt;True, but it could also turn out to have a very minor impact. Doesn't matter if it is, what matters is when it isn't. &gt;remain competitive. Competitive against what? Java as introduced by Sun never tried to be competitive, in fact Sun's stance was anyone could implement so long as it passed the Java Testing Suite. Being competitive is only a n issue if your goal is profit making. &gt;In that regard they would be wrong but only in the sense that the semi-annual update releases have always (in the last decade) been quite big (&gt;10 JEPs), and have always required planning and testing. Semi annual releases were not major number release, they were generally bug fixes and security fixes. Most places were comfortable with light testing if the version went from 1.8.0_b98 to 1.8.0_b102 or even to 1.8.1. Going to 1.9 kicks in a different level of rigor. &gt;now that Oracle open sourced Sun open sourced Java starting in 2006. HotSpot was GPL'd that year and the bulk of the JRE was GPL'd in 2007 as well as the Java Class Library. OpenJDK appeared right after in 2008. Oracle didn't buy Java until 2010. 
Abandoned. 
It didn't mention using headless packages if your distribution has them. That keeps from pulling in a lot of extra packages.
&gt; there is absolutely no way you can ensure the same level of upgrade won't happen in the new model unless there is an intention to basically stop improving the platform. I don't understand what you're saying. &gt; Agreed but the old model allowed for sufficient time to introduce the updates, the new model is a 6 month cycle unless you purchase a license. The old model had very significant semi-annual releases, that you *had* to upgrade to stay secure. The new model is also based on semi-annual releases, like before. We've changed the name we give those versions, as well as relaxed the restrictions on what changes they can contain. Nevertheless, they contain a similar number of changes as the old update releases, not the old major releases. &gt; Java as introduced by Sun never tried to be competitive, in fact Sun's stance was anyone could implement so long as it passed the Java Testing Suite. Being competitive is only a n issue if your goal is profit making. Not at all. If a product is not competitive it dies. If you think that, say, Python and Node.JS aren't trying to be competitive, then you're not paying attention. Also, funny you should mention Sun. The reason Oracle owns Java and OpenJDK even though it didn't create them (and the reason it's doing a better job than Sun stewarding it) is because Sun didn't know how to make a profit. Which is also why it's dead. &gt; Semi annual releases were not major number release, they were generally bug fixes and security fixes. No, they were not. 8u20 and 8u40 contained about as many JEPs (not bug fixes but enhancements) as 10 and 11. We've changed what the numbers *mean*. True, the new feature releases are not exactly like the old minor releases, but they're also nothing like the old major releases. &gt; Most places were comfortable with light testing if the version went from 1.8.0_b98 to 1.8.0_b102 or even to 1.8.1. I can't control what people are comfortable with, but I can state the easily verifiable fact that JDK 10 and 11 were roughly of the same size as 8u20 and 8u40. I understand people are confused about the meaning of the new version naming scheme. &gt; Oracle didn't buy Java until 2010. Yes, and until JDK 11, the Oracle JDK contained quite a few important features that had not been open sourced until then. JDK 11 is the first release ever where the entirety of the most popular JDK is open source.
&gt; I have been working in Fintech for about 19 years. C'mon Tony, you have been working in banking. 
Hah. No, I don’t think I have ever actually worked for a bank, trust, or a hedge fund. Anything that actually handles other people’s money. 
Will look into this at my company after the EmailOps effort is finished
Building a backend with GraphQL is so much nicer than building a rest API it's not even funny. 
Great to see more time put into Spring HATEOAS. Been using it for over two years in production. The HAL spec is the key win in my book. It makes linking to related entities very intuitive and discoverable. 
Not sure where all the hate is coming from in this thread. Excited to try out the Affordance and Hal Forms APIs. I've also found Spring Data Rest to be incredibly useful and get full featured endpoints out quickly.
It looks like in your [submission](https://www.reddit.com/r/java/comments/ay735o/java_hollow_triangle/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
The "is the link present" concept does work well. Also, if you resolve rels correctly, the client doesn't have to hard code any URLs. Use of templated URLs and you gain the ability to evolve your API with minimal impact on clients. This approach has proven useful in my experience. One pitfall is trying to calculate available links for resources on collection especially if any require calls to other services. In these cases I typically provide a request variable which tells the controller weather or not to include actionable links on the individual resources. 
Kotlin is an alternative to Java. It's not a Java killer, Kotlin was created to be used in TANDEM with kotlin. Hence why it's 100% interoperable. Andrey Breslav (lead kotlin designer) said this. Not exactly word for word but that was the sentiment. In my mind, Kotlin is a great java alternative. I used to work in Java 100% of the time, but now I work in Java 1% of the time. Kotlin is shorter and easier on the eyes. Less stuff to fill up the screen while having the exact same capabilities. I've rewritten most of my libraries (most are pretty small but I have a lot of them) in Kotlin. Extension functions are a prime example . It's syntactic sugar but it conveys the idea a lot better than a static function that takes the "extended" type as the first parameter. `classInstance.extensionFunction(param)` looks a lot more clear than `extensionFunction(classInstance, param)`. AND you can use syntax as if you were already in the class (public access only though). Data classes are another one. Sure you can re generate the getters setters equals and hashcode every time you want to add or remove a field from the class, or you could `data class ClassName(val param: Type, val param2: Type)` and be done with it. And "paid shills spewing garbage"? Really? How very grown up of you. Personally, I like Kotlin and recommend it to Java developers because it doesn't completely interrupt their workflow and you can do the same thing with less on the screen. Kotlin is concise. I always stress that you don't have to toss your old Java code, that you can keep using it with Kotlin, as that seems to be a big thing for more experienced Java developers (who tend to have more libraries written by themselves in Java, something something sunken cost fallacy or whatever).
[removed]
Imo, you should never cast an interface back to a different class (tbh avoid casting in general). Your parameter is an interface for a reason; if you expected the class, ask for the class, not the interface. Ranting aside, if *you* know the object is a certain class, and you want to call a method from that class that isn’t available in the interface, you cast it, or else your code won’t compile bc it won’t recognize the symbol. Early is during compile time. Late is during runtime. Polymorphism is the general understanding/concept that an object has multiple conformances. Overloading is the practice of change the expected inherited behavior of an object.
Thank you so much... Also I just saw rule 1 sorry but thank you anyways
Oh whoops. Didn’t even notice which subreddit I was in. Try r/learnprogramming
https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String) **Returns** the index of the first occurrence of the specified substring, or -1 if there is no such occurrence.
Try blueJ. It is easier to work with at the start. 
Spring made a nice thing even better. Gave the docs a quick scan, will definitely try it out and give it a test flight in one of my apps. Thank you for making Java great, you’re one of the heroes of my time \o/
Intellij all the way, hands down the best IDE in the Java ecosystem.
Management decided, and I am but a lowly worked drone
Why do you hate it?
Smells like somebody doesn't understand the concepts? 
If you code to the interface as you should casting is gonna happen eventually to hit implementation specific methods. You just need an instanceof check. 
I use Java because to me, Java == Job. (and Python == PHD) . =P
Try adding some hazelnut creamer or sugar.
All these people telling you to use a different ide and no one telling why they use java (ide usage is completely subjective by the way, try a few and see which you prefer). Java is a very common and very powerful language. The ecosystem of libraries and frameworks is huge. You'll find that a lot of companies use java somewhere along the line. I prefer java because it is the language I am most comfortable with, it is nice to work with, is cross platform, and is very readable. It is also a great beginner language because you don't have to worry about memory management. 
Android
To a degree, you just get used to some parts sucking and you barely even notice them after a while. The libraries keep me tethered to the java platform as a whole, because I need to deal with XML (including annoying standards like XML-security), I have to be able to read and write Excel files, create and merge PDF files, build X509 certificates on the fly, and stuff like that which is all pretty annoying to do unless you have decent libraries for it. And honestly, Java isn't even too bad. It's a fine, simple language that just gets used in terrible ways. My preferred language would probably be Go, but I suspect that I'd take a big hit in terms of available libraries, and I might end up hating it anyway.
&gt; What reasons do you all stay using Java? Because once you get past the hurdle that is understanding OO programming (what you're probably stuck on now) it's actually an awesome powerful and quite easy to use language. Before I started my CS degree I used QuickBasic, Assembly and some C and it took me quite some time to unlearn some of the bad stuff I taught myself (global variables everywhere!). It was quite frustrating to not 'get' the static vs. not static stuff. Once I got past that I noticed I got stuff done a lot faster than I did before. Don't worry; you'll get there too.
handler.yml? No, thanks.
I assume you meant aside from MS Paint https://ms-paint-i.de/
Instance of String.includes() checks for particular word in a string and returns true or false instead of a number like indexOf().
I think you mixed up overloading vs overriding. At least it is not clear to me what inheritance has to do with overloading speicifically. *Overloading* - same method name, can refer to and run code from inside different methods, depending on type, order and number of arguments (everything is different about the method signature except the name). *Overriding* - a method behaviour/implementation from a class or interface is overwritten in the inheriting (child) class. In order to override and not overload the method signature should be exactly the same. More in depth explanation with examples: https://www.programcreek.com/2009/02/overriding-and-overloading-in-java-with-examples/ https://dzone.com/articles/everything-about-method-overloading-vs-method-overriding
I too like Intelli J better. What do you hate about Java? Its so easy and close to spoken language, code explains itself basically.
Also why do I use Java? Because my PM and Project Lead decided that our application is to be written in Java
I have spent 20 hours in the last two days trying to get some junit working and eclipse doesn't enjoy the fact that I'm on Linux for some reason. 
This seems to be common amongst the industry. So I shall get used to using whatever language is required of me...
I think that I hate eclipse. I usually use vim and eclipse is so slow and buggy. In order to do just about everything I have to either go to a stack overflow page or read the documentation. It just feels like the learning curve for eclipse is super steep. 
The problem is that I understand the bad coding habits that I have and how to avoid them, but the way that school works I have so many assignments that I do not have time to write 'good' code because I just have to pump out stuff that works. I'm glad that the industry works this way.
I feel that not being able to manage my memory limits me because I am always getting Null Pointer Exceptions. I also am not a fan of how much GUI there is in eclipse, but there are so many background files in eclipse that using a text editor seems frightening. 
I have tried caramel and sugar before but never hazelnut, what benefits does hazelnut add as opposed to other creamers?
Did you really just come to a community about a thing, when you barely know the thing (taking a class), and complain about it? What did you expect? Anyways: * High performance * Garbage collection * Easy to read * IntelliJ * Huge community
Why does Python == PHD ?
The thing I hate about Java and other IDEs is that there is always so much to type for the most basic tasks. I use NetBeans 8.2 as this IDE generates all of the boiler plate code and you concentrate on the business logic.
I would like to believe that I understand the concepts, but what do you mean by the concepts because I am certain that there is an infinite amount of Java knowledge that I do not possess.
I am required to use eclipse for school sadly.
I have heard alot about this IDE and will most likely try it in my free time. The only issue that I have heard of is that IntelliJ is resource intensive (RAM).
I expected these exact results.
Java is not an IDE, but I understand what you're getting at. If you like basic quick programs so much, why don't you use python?
What libraries do you use for your CSV files? I have to work with a couple of them right now.
Library vendor here: that's where the biggest market is.
That’s a bit of a beginner issue, then? I don’t want to teach you any lessons, you hate what you hate and it’s none of my business. But going through difficult issues and solving them is the definition of learning - you will go through all kinds of situation in all languages, in all systems.
What does NullPointer has to do with memory management?
Do you know of any good tutorials to learn the eclipse debugger, I believe that if I understood more about debugging I could spend less time trying to get my hacked together code working and spend my time writing 'good' code. I am a beginner with Java, but not with programming. I guess I have forgotten what it feels like to be new to a language.
`Mono&lt;CollectionModel&lt;EntityModel&lt;Employee&gt;&gt;&gt;` Me thinks [Imgur](https://i.imgur.com/XiS8rpv.jpg)
Literally Nothing, that is just my most commonly thrown exception.
Yeah, after fluent / annotation based configuration I do not want to go back to configuration files. But that may be a matter of taste. In any case, I'm thankful for the article title to include the word "Microservices" instead of being just "Introduction to Light 4J framework".
To be honest, you don't give much room for proper responses. You don't say what specifically you hate, if you have experience with other programming languages or IDEs and if you can compare them. Most people here are way beyond your level of experience and will probably give answers that more relate to the java ecosystem or high level advantages than say "I like the way a static void main(String[] x) is required for a class to run".
We’re looking to evaluate Micronaut, which looks a lot like Spring but can compile to native with Graal. 
After reading your other comments in this thread I am fairly certain that you are beginner with Java and programming in general. It feels like you are trying to do too much at the same time and that you should start with less. Nobody jumps into a language and is a pro from the start. It gets better over time, the twentieth language you learn will he easier to master than the second or third, but there will never be a master immediately. What languages and environments are you familiar with? 
Sorry, I know Java is a programming language. I meant writing software in Java and using other IDEs in general.
I left more room for proper responses in my edit, but I do like the way a static void main(String[] args) is required for a class to run.
It is a robust language and has a robust eco system. There are so many books, courses and other sources to learn from and over time a lot of best practices have been established. The language itself is robust because it does not throw away old features and just evolves. Especially since Java 8 it is a pleasure to work with. It is also good if you are looking for a job as Java is still one of the most used languages especially in the enterprise business. However I also prefer Python regarding machine learning or tool creation as it is much easier to hack something together with it while Java is done for long living projects due to its stability.
.metadata and .settings have nothing to do with Java and everything with Eclipse. Usually Eclipse doesn't autogenerate anything apart from what it tells you. As a beginner ignore anything that's not in your src folder. Also, Strings are not final except when you declare them as such. They're immutable (meaning changing them results in a new object, more or less) but you can change them.
I definitely still feel like a beginner, so I take not insult. The only thing that I learn is that there is so much that I do not know and I take pride in that because it leaves nothing but an opportunity to grow more. As for Languages and Environments, I would say that I am most familiar with C++ and then Pyhton. I have dabbled with most of the common WebDev stuff front and back end with alot of SQL. I currently run a research based website which is just a whole bunch of Javascript. And yes, I would like to settle down and "master" one language instead of being mediocre at all of them. As for environments, I prefer to use Vim, but I have used the most common associated environments for the languages that I have listed. (CLion, IDLE, Postgresql...)
I feel like Java is better for very large long term projects when compared to Python because it is extremely easy to get something running and going in Python, at least for me, than it is in Java.
This is exactly the kind of thing that I wanted to hear. I personally thought that all Java required those files to run because they were causing me a ton of trouble with my git repo.
Then sit back and start small. Eclipse is a damn huge IDE and is very, very powerful and complex. To just get started with code and even some JUnit it's totally enough to just use BlueJ, which could even be very good for you since you like to use VIM. BlueJ is a very small and basic editor, but it helps seeing the connections between objects and it can run tests just fine. After you feel safe with using BlueJ and Java you can start diving into the deep world of AutoCompletion, Debugging, auto generated code, plugins and so on. Seriously, I've used eclipse for years and still don't know everything. 
It just annoys me because learning the Eclipse IDE on its could be an entire class, let alone learning Java in it. I think I am going to switch from Eclipse. Do you know if other IDE support JUnit4?
:-( Sry for you
Yeah, I really don't get the reasoning behind this.
But, if I can switch without many issues. I will give it a try. My only true requirements are that I need to use JUnit4 and have a debugger because some of our assignments force this.
https://www.youtube.com/watch?v=_3X61zDcu4s
Not what I was expecting, but I like!
That's not really how Oracle makes money. They get you to use one piece, then allow your engineers to freely download everything from their site, which leads them to download and use all kinds of things you didn't originally plan. Then Oracles hits you with an audit, finds you using all kinds of stuff you need to pay for, and hits you with as big of a bill they think they can possible squeeze out of you.
*Programming help* questions belong in **/r/javahelp**. Still, first point to look at is the [**Official Documentation**](http://www.oracle.com/technetwork/java/javase/documentation/index.html). See [`.indexOf()`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#indexOf-int-)
Would String.indent apply in compile time where string is constant?
Every Java IDE I know supports at least basic JUnit. So you should be fine to just get a feeling for Java by using BlueJ. It works fine for simple test, when you reach the point of "Mocking" you will be gone from BlueJ anyways. 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Very interesting, thanks for sharing!
Last time I checked, Micronaut selling point is the AOT compilation, GraalVM support is not very stable at the moment. Check these [issues](https://github.com/micronaut-projects/micronaut-core/issues?q=is%3Aissue+is%3Aopen+label%3A%22relates-to%3A+graal%22) I've never actually used Micronaut though, so I might be wrong.
NullPointerException doesn't have anything to do with managing memory. NPE's aren't really difficult to deal with if you correctly understand what they are and how they work. Perhaps you are missing some fundamentals? Honestly, if you are having such troubles with NPE then memory management would be even more troublesome for you, because it is notoriously difficult. I'm not really sure what background files you mean, nor why using a text editor would be frightening?
Not currently. This might be possible after JEP 303 and friends land though.
I personally use Intellij over eclipse 99% of the time
Wrong subreddit. Such questions belong in /r/learnjava.
I think the example for String#transform is really bad. This method is convenient when it is used in stream or for chaining calls. Example: https://bugs.openjdk.java.net/browse/JDK-8203703 
You don’t have to use the native image compilation. Micronaut gives you a lot of things even when targeting the JVM
I wonder what justified its addition to `String`. This looks like something that might be useful on any type, but better be added as an extension method when needed (yes we don't have those). public static "extension" &lt;T, R&gt; R transform(T self, Function&lt;? super T, ? extends R&gt; f) { f.apply(self); }
I envy eclipse but Java is good. Keep in mind it's much harder to fuckup in java than c++. IDEA helps a lot. Also the sheer quantity and quality of libraries are superb compare to any other language. It is a no brainer why people like java the ecosystem is amazing if you compare to anything else. 
You will find NullPointerException in almost all popular languages. You've mentioned you used Python and C++. NPE (under other name) can happen in both of this languages. In fact NPE in C++ is more dangerous. In Python it is harder to worse static analysis tools. 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
We've gone full circle and back to Struts v1!
Don't like this: https://quarkus.io/guides/cdi-reference#limitations
Needs more blockchain /s
Wow that shows how much I paid attention last semester
Its fairly easy, just add a .gitignore file to the project root that contains a ".\*" line. That keeps all files and directories that start with a dot out of git.
&gt;I don't understand what you're saying. You're arguing that 6 month forced upgrade cycle (assuming not paying for LTS) isn't a big deal because there won't be major changes between each, I'm saying that is not something that can be guaranteed. &gt;that you had to upgrade to in order to stay secure Upgrades from 1.8.0 to 1.8.1 are not considered as substantial in standard software development versioning schemes as going from 1.8 to 1.9. So there is an expectation that an upgrade from x.x.0 to x.x.1 or x.x.3 is backward compatible and significant changes were not introduced. That has been an accepted model in software development going back decades. &gt;Not at all. If a product is not competitive it dies. If you think that, say, Python and Node.JS aren't trying to be competitive, then you're not paying attention. I asked why is being competitive an issue if your goal is not to profit from it? I'm aware of the other options as I stated in my first post, I'm reviewing possible alternatives to using Java. &gt;Sun didn't know how to make a profit. Which is also why it's dead. So you admit the whole point here is to make a profit from the Java community. Except for the first year when JavaSoft was a separate division of Sun, Sun's only attempt at making money off Java was by licensing of the test suite. Sun was always a hardware company. Oracle bought Java in an attempt to make money off Android and that didn't work out so now Oracle is going after corporate enterprises. &gt;8u20 and 8u40 contained about as many JEPs (not bug fixes but enhancements) as 10 and 11 Between 8u20 and 8u40 there were not structural changes, reading the release notes there were a few new deprecations, enhancements to Nashorn, fixes for JCE. Let's look at just a few of the release notes for Java 11: * The deployment stack, required for Applets and Web Start Applications, was deprecated in JDK 9 and has been removed in JDK 11. * Without a deployment stack, the entire section of supported browsers has been removed from the list of supported configurations of JDK 11. * Auto-update, which was available for JRE installations on Windows and macOS, is no longer available. * In Windows and macOS, installing the JDK in previous releases optionally installed a JRE. In JDK 11, this is no longer an option. * In this release, the JRE or Server JRE is no longer offered. Only the JDK is offered. Users can use jlink to create smaller custom runtimes. * JavaFX is no longer included in the JDK. It is now available as a separate download from openjfx.io. * Java Mission Control, which was shipped in JDK 7, 8, 9, and 10, is no longer included with the Oracle JDK. It is now a separate download. &gt;Yes, and until JDK 11, the Oracle JDK contained quite a few important features Not according to the [history of OpenJDK](https://en.wikipedia.org/wiki/OpenJDK) : &gt;When initially released in May 2007, 4% of the OpenJDK class library remained proprietary. By the appearance of OpenJDK 6 in May 2008, less than 1% (the SNMP implementation, which is not part of the Java specification) remained, making it possible to build OpenJDK without any binary plugs. The binary plug requirement was later dropped from OpenJDK 7 as part of b53 in April 2009. Since Java 7 the OpenJDK and OracleJDKs have beeb built from the same primary code base with a couple of exceptions such as * Oracle JDK includes Oracle’s implementation of Java Plugin and Java WebStart. * Oracle JDK also includes third party closed source and open source components like graphics rasterizer and Rhino respectively. * Oracle release included a few additional JCE cypher suites Oracle dropped WebStart, Rhino was removed, Java Plugin is gone, JavaFx was dropped, BouncyCastle provides the missing cyphers and enterprise systems generally don't need a graphics rasterizer. So exactly what did Oracle opensource that wasn't already done?
**OpenJDK** OpenJDK (Open Java Development Kit) is a free and open-source implementation of the Java Platform, Standard Edition (Java SE). It is the result of an effort Sun Microsystems began in 2006. The implementation is licensed under the GNU General Public License (GNU GPL) version 2 with a linking exception. Were it not for the GPL linking exception, components that linked to the Java class library would be subject to the terms of the GPL license. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Just watched a talk from Tomasz Nurkiewicz in regards to that, as a Scala developer I just think Java is still lacking the necessary abstractions to make that simple/painless but I'm sure it will get to the point where writing reactive code will become trivial and easy to maintain.
Do you need a passivating scope in a microservice? This is really for for AWS lambda type services. 
&gt; You're arguing that 6 month forced upgrade cycle (assuming not paying for LTS) isn't a big deal because there won't be major changes between each, I'm saying that is not something that cannot be guaranteed. I'm saying that a 6-month upgrade cycle with potentially big changes has already been in effect for the last decade. &gt; That has been an accepted model in software development going back decades. This doesn't change the fact that the new feature releases are not major releases in the same sense that 7 or 8 were. &gt; I asked why is being competitive an issue if your goal is not to profit from it? And I answered that if you're not competitive you die. So if Java is to remain viable, if must be competitive. It must also somehow generate direct or indirect revenue -- just as platforms of similar size, like .NET, Swift and Android do -- or it would not have the resources necessary to maintain it. &gt; Except for the first year when JavaSoft was a separate division of Sun, Sun's only attempt at making money off Java was by licensing of the test suite. Sun was always a hardware company. Oracle bought Java in an attempt to make money off Android and that didn't work out so now Oracle is going after corporate enterprises. You are very mistaken on the fact. Sun and later Oracle funded Java's development by making money off it in several ways: licensing to embedded/mobile devices (the JDK had field-of-use restrictions), commercial features in the JDK that enterprise users paid money for, and even that annoying search toolbar. Now that Oracle has completed open sourcing the JDK it's changed the monetization strategy. For the first time ever, the JDK is completely free, and with no field-of-use restrictions, and the toolbar is gone too. In addition, the price for enterprise support has been dramatically reduced. If you've never paid for Java, you're now getting more for free (all the previously commercial features), and if you have paid, you're now getting much more for your money (because prices have been cut). &gt; Between 8u20 and 8u40 there were not structural changes, reading the release notes there were a few new deprecations, enhancements to Nashorn, fixes for JCE. True, but there were still big changes, and full regression testing was required for those semi-annual releases. Like I said, even 8u202/11.0.2 broke Clojure. &gt; The deployment stack, required for Applets and Web Start Applications, was deprecated in JDK 9 and has been removed in JDK 11. Yes, but that change was announced well in advance. That deployment stack was no longer supportable (by Oracle, at least). &gt; In this release, the JRE or Server JRE is no longer offered. Only the JDK is offered. Users can use jlink to create smaller custom runtimes. But that's better for everyone. Anyone can now build and distribute a JRE if they like (in fact, AdoptOpenJDK even builds such binaries and makes them available to everyone). &gt; JavaFX is no longer included in the JDK. It is now available as a separate download from openjfx.io. I don't think that's is a big change. It doesn't require any code changes. &gt; Java Mission Control, which was shipped in JDK 7, 8, 9, and 10, is no longer included with the Oracle JDK. It is now a separate download. Ditto. &gt; So exactly what did Oracle opensource that wasn't already done? JFR, mission control, AppCDS, ZGC.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I think the term "lightweight" should be banned in framework descriptions. They all claim to be "lightweight" - heck Spring still claims to be (though that's ridiculous). Anyway, just a drive-by comment.
I don't care about missing parts, I care for giving partially implemented api. I don't get why don't use a full weld implementation, for a bunch of megabytes?
I think it is partially implemented to keep the boot time and footprint as low as possible. This is a first swing and maybe they will find ways to implement more in the future.
So why not to contribute to microprofile instead? This proliferation of "micro" "small" "subatomic" frameworks is dissipating effort, IMHO
Hey, (I'm one of the co-founder of the project) We definitely want to push a lot of our work back into the various standards. But, before you standardized, you prove that it's useful in a project before. What we do in Quarkus requires to rethink Java framework expectations in how they boot. Java frameworks abused the dynamic nature of the JVM platform and do *a lot* of repeated work at start up time. Don't get me wrong, I love the declarative model. What Quarkus sows is that you can embrace it AND do work at build time to gain memory usage and startup time. Likewise, the closed-world assumptions of AOT optimizations (like in GraalVM), do require to give away some expectations. We see the move to AOT as one of these juncture moments for Java like @annotations have been. Some will reinvent themselves, other technologies will stay behind.
why would you still try to make java survive by making it something totally different?
Reasons I'm using Java: * Job * Familiarity * JVM is awesome (and I think the JVM and Java go hand in hand) * Real crossplatform: not only supporting Windows, Mac, Linux but also less known / older platforms, embedded and mobile, runs on pretty much everything (again more a JVM thing) * Huge ecosystem: tooling, community, libraries, frameworks * Diverse area of application and industries: embedded, mobile, desktop, server, web, science, big data, finance, health, gov, commerce, cloud, ... * I actually like the "feature set": GC, static typing, strong typing, nominal, OO, FP (to some degree), control structures, standard lib, ... * Mindset of the community: Quality and performance first, importance of documentation, security, giving it thought and getting it right before hitting 1.0.0, ... . This is in stark contrast to like PHP or JavaScript. * I'm a consistency fanatic. Over time best practices emerged and pretty much everyone does it the same way, names things similarly, reading Java code is "boring" and thats good. You immediately grasp whats going on, you get the intent, it's mostly not "clever", overabstract code but explicit. * Well tested and testable, open-source, community not commitee driven * Language interop, especially with GraalVM and Panama I think you need to go step back and restart from the very basics. Compile and run a HelloWorld by hand without using an IDE. Take a weekends time to finish a beginner tutorial (e.g. [this one](https://javabeginnerstutorial.com/core-java-tutorial) or [this one](http://moocfi.github.io/courses/2013/programming-part-1/)? I simply googled for one that doesn't need registration) I think you're frustrated because everything is new and your instructor simply sucks. 
Ugh, i gave it a try 2 weeks ago. This is essentially unusable, for example HTTPs don't work out of the box, @Cacheable is not working when running as native, but it's working when running in a JVM, etc. I didn't even get it to generate the reflect.json when using @Scheduled. This needs more time to get usable.
or use a specific Eclipse .gitignore. For example this [one](https://www.gitignore.io/api/eclipse). And then: git status git add . git commit -m "add .gitignore" git push git rm -r --cached . git add . git commit -m "retroactive remove ignored files" 
You can run Spring Boot as Micronaut application: https://micronaut-projects.github.io/micronaut-spring/latest/guide/index.html
Likely a mismatch on your concept of classes. From your C/C++ perpective, a class object is a 'malloced struct', and a class variable is a 'pointer to the class object' (it defaults to NULL). You need "foo = new MyClass(parm1,parm2);" where MyClass contains a constructor with two arguments. Classes can have one or more constructor methods. Constructors are methods in the class named the same as the class. If you do not create a constructor, a zero argument one will be created for you.
I'm not familiar with JavaFX, but WPF is very similar to modern web UI development. It's separates the layout (XAML / HTML) from the logic (.cs / .js) and from the styling (styles / .css) It also supports data binding from the view to the logic. For someone who is familiar with WPF it's very easy to move into Angular web development.
Hibernate generates an UPDATE statement that only increments the version while leaving all the other columns unchanged: UPDATE product SET quantity = 5, version = 2 WHERE id = 1 AND version = 1
I think I definitely prefer String capped = title.transform(Example::naiveDropFirstWord); .transform(Example::naiveTitleCase) .concat("."); to String capped = naiveTitleCase(naiveDropFirstWord(title)).concat("."); and `transform` is better than `map` in this situation; you can only ever go from a `String` to a `String`.
Having the \`map\` method would imply working on some form of container which is not the case. I'm glad they went for \`transform\`.
Honestly, I was super surprised to see something like this added. Especially keeping in mind how careful the team is to not introduce unnecessary bloat. But hey, here's your convenience method for chaining method calls on String instances!
/r/fellowkids
I love the Java programming language - perhaps you consider to that to be too old school but the Java language is still incredibly popular and many of those users would love optimization for the cloud native world. Where super fast startup and small memory footprint can have a dramatic impact in the extreme scenarios represented by containers/Kubernetes/serverless. I know people who were "forced" to move to Node.js or Go for their microservices/functions - they can now stay with Java. (disclaimer: I work for Red Hat)
Have you got any links on best practices/architectures for graphQL? 
Yep, map would make sense if it was mapping individual characters.
But that we have already with String#chars().map() :)
The update uses the same column values it has loaded previously, hence nothing will be updated. This default behavior allows you to batch statements automatically and to benefit from statement caching. If you don't want the default update mode, you can use [`@DynamicUpdate`](https://vladmihalcea.com/how-to-update-only-a-subset-of-entity-attributes-using-jpa-and-hibernate/), and then n=only the modified columns will be updated.
Guess I was/am confused. Hibernate includes the quantity, though unchanged, in the update statement? I was questioning why the "quantity = 5," line was in there.
Apollo puts out some good blog posts about designing evolvable GraphQL schemas, it's a good place to start
&gt; Just switch to a different language / environment / platform Like what? At least you could given an example and explain why it so much better than Java. That way people can agree or disagree with you and explain why. Your current statement is a bit lacking of substance.
&gt; I think the example for String#transform is really bad. Even someone joked about it on [core-libs mailing list](http://mail.openjdk.java.net/pipermail/core-libs-dev/2018-December/057054.html): &gt; On a side note: regardless of the name, I bet we'll see some `string.transform(String::toLowerCase)`
There are plenty of languages, depending on your level of expertise and area you want to specialize in. For general purpose development, modern C++ (when used well) is a better choice than Java (when used well).
I see the world is overwhelmed by my sarcasm powers ;)
Even windows is popular. So what? It is trash. And it remains so. Java is a clear example of MOL (money-oriented-language). It is not platform independent; it is a platform. like MS Windows, it is a commercial proprietary platform (in the oracle jdk), backed by a commercial entity. That is not the case of ISO c++ or ISO C or other standard languages defined by a real committee and not a multinational. That is, you can write software for Java/JVM or C#/Intel and in both cases you are developing code for a single proprietary commercial platform, and you are writing code tweaked to the benefit of that corporation. There are standard and free (as in freedom also) languages to use, out there. Why being stuck with such underpowered and legacy (read= proprietary) tools? Unicuique suum.
And I replied you why is it so. That's how the default update works in Hibernate. Read my answer for more details about it, the reasons, and the workaround.
&gt; If you don't want the default update mode, you can use @DynamicUpdate, and then n=only the modified columns will be updated. Maybe I should open my eyes? No longer confused...
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
And aren't some of these limitations dictated by Graal and SubstrateVM requirements?
Why do the mods not remove these shit posts? Move to javahelp
It wasn't entirely a shit post, but I can remove it for you if you'd like.
If you're anti-Java or think it's trash, why are you even in this subreddit and trolling?!?!
And when you look at the TechEmpower benchmarks, Java toolkits/frameworks frequently outperforms all of them.
It literally goes against rule 1 of the sub. 
Roger Roger
\&gt; For general purpose development, modern C++ (when used well) is a better choice than Java (when used well) It's 2019 and there are still people spewing out stupid shit like this. Let me guess: you are 22, in your first real job, and you spend most of your time coding 500 line programs in Vim...
&gt; This problem could have been solved by adding that method even to Object itself With what method signature?
openjdk is totally free. java is the most open platform out there. MS windows is totally proprietary. c++/c is open (but it is the root cause for most security vulnerabilities). When you write java-code you are not locked in and you can run it on most platforms.
Why generics is still not supported after compilation after so many years? 
Emmanuel, I'm curious if you have found any optimizations from Weld, Hibernate etc trickle down into the non-quarkus builds of those libraries. &amp;#x200B;
&gt;You are very mistaken on the fact. Sun and later Oracle funded Java's development by making money off it in several ways: licensing to embedded/mobile devices (the JDK had field-of-use restrictions), commercial features in the JDK that enterprise users paid money for, and even that annoying search toolbar. No I'm not mistaken, I was there. Yes there were multiple targets Java platforms with different licensing. Prior to Sun eliminating their "planet" divisions, JavaSoft had its own revenue targets. JavaSoft was going around selling licenses to Java to everyone from IBM to Unisys. But those licenses were for the the compatibility kit to test their own implementation of Java and be able to call it Java. Unisys wanted to embed Java into their database, but to be able to say "we have Java embedded" their implementation had to pass the test suite. This was the whole issue behind the Microsoft lawsuit, Microsoft called their implementation Java but it did not pass the compatibility tests because Microsoft made some platform specific "enhancements". So they stopped developing on it, renamed it J++ to get around the issue, then dropped it in favor of .Net. That lasted a little over a year and Sun realized that model was not sustainable with Java as a separate business unit and the others like SMCC and Sun Professional Services had the same issues so they were merged together. SPS and JavaSoft conflicting on who provided professional services to Java customers was another issue. J2ME - Java2 Micro Edition - was targeted at the embedded systems and phones. Sun provided reference implementation to these but phone manufactures implemented their own. Sun, Nokia and Vodafone created and licensed the compatibility kits. Sun made very little money licensing Java, most of that was from licensing the compatibility kit. Sun tried to build Java products like the Java Web Server Framework and they bought other products like NetDynamics. None of those Java products were big sellers. Sun's model was agree on standards and compete on implementation and that is how they ran Java. They hoped that Jini or the Java Chip would be the big money makers as Sun was a hardware company, but they weren't. That is why Jonathan Schwartz stated Google did not need a license for Android so long as they didn't call it Java which they didn't. &gt; Like I said, even 8u202/11.0.2 broke Clojure. Clojure isn't enterprise Java. It runs on the JVM but isn't a component of it. If things change that break Clojure that happens, if things change that break standard Java enterprise applications that is a different issue. &gt;If you want assurances that over the next 20 years Java will not undergo major changes that are necessitated by a changing software environment, There's a really big gap between 20 years and 6 months. &gt;JFR, mission control, App CDS, ZGC. They are all hugely useful features. So you just proved my point, Java was already open sourced by Sun, Oracle simply open sourced some of the tools they created.
I absolutely agree... Try opening the Javadoc of Spring or Micronaut. There are almost 400 packages in both of the projects. Unless you are a god gifted developer, there is no way getting a conceptual overview of these projects can be considered lightweight in any way. &amp;#x200B; Give me a single-jar framework, with an API of no more than 100 classes tops and we can talk.
&gt; No I'm not mistaken Yes, you are. In addition to licensing the TCK, Sun/Oracle licensed Java for mobile and embedded devices, charged for support/commercial features, and had other monetization avenues, like the search toolbar. &gt; If things change that break Clojure that happens, if things change that break standard Java enterprise applications that is a different issue. That change may have also broken pure Java applications. &gt; There's a really big gap between 20 years and 6 months. Right, but, again, JDK 10 and 11 were as big as 8u20 and 8u40. &gt; So you just proved my point, Java was already open sourced by Sun, Oracle simply open sourced some of the tools they created. The most popular JDK, Sun/Oracle's, was at no point 100% open source until JDK 11. &gt; Not necessarily for enterprises who generally deploy the JRE as part of the platform image, then stack the app server and war/ear files on top of it. They can still do that.
Really happy to see GraalVM as an aspect of this project. I really hope to see it in more places. I feel it is the most exciting development around the Java ecosystem.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Why would I need this? 
I was asking myself the same question the other day. I use Java because my job has a large codebase in Java and Android uses it too. But I agree that the first steps in Java, especially Java IDEs can be painful. Eclipse can be very non-intuitive (most useful options are in the middle or at the end of huge menus and submenus; basic things are separate plugins; etc.). I tried NetBeans three or four times before I was sure it could replace Eclipse for me. You should try to learn the parts separately: what is Java, what is Eclipse, what is Maven, what is JUnit. Maven and Gradle download hundreds of megabytes on first use. If your internet connection becomes slow you may blame Java or Eclipse or Android Studio for being slow but it was just a large download that's taking too long to finish - that happened to me. I discovered the reason when I tried the command line tools, they at least told be what they were downloading at what speed. Some Java tools are finicky, especially when you need to integrate them. They work very well once configured (or if you copy a known good configuration), but you should be prepared to spend a day (or a week if you are a beginner) to set everything up if the defaults don't work at first. I remember I did spent a whole day adding a database driver to Wildfly setting esoteric options and then I found out it works if I leave most of them blank (d'oh). All of them are memory hogs. If your machine has 2GB of RAM, forget it. If it has 4GB, you can run one IDE perfectly well as long as it doesn't spawn too many additional processes (gradle daemon, emulators, application servers, etc.). Things start to get good at 8GB of RAM. HOWEVER, once you get past all these hurdles, it's not that bad. Most syntax and type errors are diagnosed even before you save your code; autocompletion works well enough; and you have access to many libraries and tools.
I'm not familiar with those two books. The current version of Java is 11. There were many major changes in the language at Java 8. I would get a Java text book that covers Java 8.
Defining new classes only to solve the problem of constructors with same signature feels like a serious overkill for me. * Multiple classes (especially worse on Android) * Useless inheritance * Reduced readability This feels like to be an anti-pattern on the same level as [double brace initialization](https://stackoverflow.com/questions/1958636/what-is-double-brace-initialization-in-java).
&gt; Do you need a passivating scope in a microservice? Absolutely yes.
&gt;A change that is years in the making will finally take place at some specific point in time. Yes it will but previously the version being used was continuing to get available updates and security patches meaning we had time to plan our migrations. Unless you pay for a LTS or are allowed to use OpenJDK then you no longer have that option as patches stop after 6 months. &gt;was at no point 100% open source until JDK 11. I already pointed out where that is factually wrong. The JDK was fully open sourced in April of 2007 with the release of OpenJDK 7 b53 which dropped the remaining binary plugin. All Oracle has done is open source addons - the default platform, hotspot VM and class libraries were done by Sun. &gt;Sun/Oracle licensed Java for mobile and embedded devices, charged for support/commercial features, and had other monetization avenues, like the search toolbar. Sun licensed the TCK for mobile but phone vendors did not have to pay to use J2ME. If they didn't want to build their own they could use the Sun reference implementation and licensing that is licensing a product, not the JDK or J2ME. Sun did not charge for updates or security patches, the support they charged for was providing assistance to organizations trying to use Java. And you've brought up the toolbar multiple times now, but that was not a charge to the users of Java, they charged the toolbar provider to have it bundled with the installer but installation was optional.
Type erasure was, and still is, a very pragmatic compromise. [JEP 218](http://openjdk.java.net/jeps/218) outlines a plan for specialized generics over primitive and value types. These specializations may be reified.
&gt; Yes it will but previously the version being used was continuing to get available updates and security patches meaning we had time to plan our migrations. You mean the major version. Those no longer exist. Saying whether major versions continue to get free updates or not is nonsensical, if there are no more major versions. But if you want to compare, say, Nashorn was deprecated for removal in 11. Now you've got the free upgrade to 12 and probably 13 or however many feature versions until it is removed to prepare. You are correct that we've started removing things, and we're committed to just one feature version with a deprecation warning. This, however, is one of those things that is dictated by the pace of change in software on one hand, and our limited resources on the other. &gt; The JDK was fully open sourced in April of 2007 with the release of OpenJDK 7 b53 which dropped the remaining binary plugin. This is simply not true. For example, applets and WebStart were part of the Sun and then Oracle JDK, and have never been open sourced. &gt; Sun licensed the TCK for mobile but phone vendors did not have to pay to use J2ME. If they didn't want to build their own they could use the Sun reference implementation and licensing that is licensing a product, not the JDK or J2ME. What difference does that make? Phone vendors paid Sun. &gt; Sun did not charge for updates or security patches, the support they charged for was providing assistance to organizations trying to use Java. And Oracle does not charge for them now, either. It's just that what Java versions mean has changed. If you're now on JDK 11 and want to stay secure, you'll get 11.0.1, 11.0.2, 12, 12.0.1, 12.0.2, 13 and so on completely free, and none of those versions are a major upgrade. &gt; but that was not a charge to the users of Java, they charged the toolbar provider to have it bundled with the installer but installation was optional. Again, 1. Java has become *more* free, and support has become cheaper. 2. Oracle does not charge anyone for using Java, but for support, and 3. I don't see what difference the monetization process makes. Microsoft doesn't charge for .NET support but does charge for its use; same for Apple and iOS. Every platform of this size must be funded somehow, and all companies that make platforms of this size monetize it. If you can think of a better way to fund OpenJDK's development, please suggest it.
It looks like the committed a few months ago to update it to the 2.3.1
Hey Emmanuel, first I want you to know that I appreciate all OSS projects that push forward the java ecosystem ;) your comment is totally understandable, GraalVM is such promising and AOT is very intriguing.. Probably giving away expectations for me is hard, I'm very comfortable with Thorntail and I sacrifice boot speed in exchange of full api implementation (with fraction slicing). Good work and good luck!
Can you expand on that a bit? When I think of a microservice I think of something that isn't going to need to hold any state server side between multiple request. If it is then that data is likely persisted to a database so any any instance of this micro-service can handle the request.
Of course. But JavaFX benefited from being designed later and they avoided some of the poor design choices of WPF like the deep integration with XML. 
How is it *still* a pragmatic compromise? They should get rid of that ancient compatability workaround now.
We use [Vocareum](https://www.vocareum.com/) and JUnit test cases to grade student submissions. We also have a library to check for coding standards.
As the JEP states: &gt; Parametric polymorphism always entails a tradeoff between code footprint and specificity, and different languages have chosen different tradeoffs. Erasure is one of those tradeoffs. The language architects took some time to deliberate, and decided that erasure was the most practical path forward. Had they required that generics be part of the language from day one, we probably would have gotten something similar to C++ templates. In order to maintain compatibility and efficiency, erasure won’t be going anywhere.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
JUnit and SonarQube?
Agreed. I use the static approach, which is nicer to read than the \`new\` keyword, anyway.
What library?
C# has refied generics. It's efficient. They broke with the past. Java keeps erasure only for compatability with pre Java 5. Thats ridiculous.
It looks like in your [submission](https://www.reddit.com/r/java/comments/ayjwx5/java_developers_who_know_python_what_do_you_use/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
C# learned from Java and decided to make their bytecodes parametric. This allowed them to more easily implement reified generics. I don't expect Java to break compatibility and ditch erasure anytime soon. The JEP even states the following: &gt;It is not a goal of this effort to produce fully reified generics.
We use a proprietary library, but I have heard of others, such as [Checkstyle](http://checkstyle.sourceforge.net).
&gt; I don't expect Java to break compatibility and ditch erasure anytime soon. I find that problematic. The long they wait the worse it gets. It will also hinder proper development in other areas such as union or intersect types (one can dream). Even Go is finally thinking about adding Generics. Refied of course.
Indeed, looks like that Java SE 6 book is from 2007, while the latest Java Programming covers Java 9.
If you mean intersection types in relation to type parameters, that is already possible: `public class Box&lt;T extends A &amp; B &amp; C&gt;`. 
Style I think is the hardest part, but as others have said my university uses junit for functionality testing, as far as testing for things like efficiency I think they test execution time on a given data set(again with junit). As far as style the most they checked with that wa that they made us javadoc our program. At which point you can skim the java doc and run the tests to get an approximation.
The reason to have some limitations is not about a bunch of less megabytes; simply put some things are not possible within the constraints. Not possible, or very hard .. some capabilities could be extended later, but possibly some specifications could need being modernized.
Personally I think that's lazy but I digress. As far as solution correctness and efficiency that can be effectively handled through automated testing. I'm not saying it's impossible, but checking for style automatically is going to be a lot of work.
Maybeadd checkstyle and findbugs too. The real benefit to using these tools and not some proprietary academic tool is that these are the tools your students will be using when they graduate. Getting them familiar with them now would be awesome.
One thing I've learned over the years is know-it-all's are really fun to work with. 
Have you explored Java interop with Jython?
...unit test
Pandas can't be used with Jython right now because it requires native extensions. Your best bet would be to build a microservice around the Pandas code using [Flask](http://flask.pocoo.org/) and call that from your Java code.
&gt;Applets and WebStart were part of the Sun and then Oracle JDK, but were never open sourced. Those are the binary plugins mentioned as part of the 4% that wasn't open sourced along with sound and font management because Sun didn't have permission to open source them. They were on track to get that when Oracle bought them but the binary plugin was still proprietary as late as 2013. That is why the IcedTea project was started to replace those pieces. So Sun didn't have the rights to open source those pieces. &gt; And Oracle does not charge for them now, either. Then what is Oracle charging license fees for if not for providing patches and updates to LTS versions so users can stay on them longer and not be required to adopt a new release every 6 months? Let me give you the real world impact. I'm working with a large financial services organization. They have a large investment in services architecture so many deployed JRE instances across multiple data centers and DR sight. In addition they company has built up a large pool of internal applications written in Java used on the desktops, some Webstart some direct. Most of this is running on Java 1.8 release. The firm needs to pass a PCI audit and vulnerability scans are now identifying a required update in this JRE, but that now requires a license to access. Finance has determined overall cost for the licensing will me in the multiple of millions. So we're researching options. OpenJDK is being looked at but there is concern having to absorb releases every 6 months. AdoptOpenJDK offers supported 1.8 releases still but there is concern whether that will remain long term. So we are looking at whether we replace the webstart and desktop apps with web apps, should we consider replacing services with something like Node.js. So you might claim "Oracle doesn't charge for updates" but the reality is that is exactly what is happening. Either pay for an Oracle license or spend time rewriting on alternate technologies or be prepared to upgrade every instance, server and desktop, every 6 months. &gt;Every platform of this size must be funded somehow, and all companies that make platforms of this size monetize it I'd argue GCC is much larger and doesn't have this problem. 
Not about post but pray for me as I have my AP comp sci midterm tm 
You could do something similar to how hacker rank does it. Basically, have them create a program that takes input and gives output. Give them example input and expected output, then test their programs against more expected output. You can automate this by accepting jar files and running each program with the input and make sure it has the right output each time it's run. 
Title font doesn't match the overall feel of the module or whatever it is
&gt; data https://adoptopenjdk.net/
I would just come up with some kind of CI pipeline :). For CI look into spotless. For accuracy provide your interfaces ahead and then write unit tests. From there you could go as simple as using spot bugs/checkstyle or you could look into sonar.
Uh I don't know about your tests, but there are generally 10s of solutions to a given problem.
&gt; Greetings I teach basic java programming to a class of students, and like every subject there are exams wbere they write code and we check it. It takes us a lot of time and manpower to check all these test, is there any program to automatically compare the their exam with our solution? I was thinking about writing automated tests but we also check for efficiency and style. Thanks
&gt; we also check for efficiency and style
&gt;Personally I think that's lazy but I digress. ??? So writing a computer program to perform computations isn't lazy, but when the computation involves "is a different program correct" it's lazy??? This statement doesn't make any sense. We invented computers to do things for us, not so we could continue to do things computers could do just as easily. &gt; I'm not saying it's impossible, but checking for style automatically is going to be a lot of work. If Eclipse can format code automatically, then it is also trivially easy to check that the code is formatted correctly. Well, in that case, it should be trivial for students to format the code correctly to begin with...
I don't know much about data science so these may be a little off, but take a look at \[TableSaw\]([https://jtablesaw.github.io/tablesaw/](https://jtablesaw.github.io/tablesaw/)) and \[DeepLearning4j\]([https://deeplearning4j.org/](https://deeplearning4j.org/)). Also see \[this recent video\]([https://www.youtube.com/watch?v=Ytja2JuVMlw&amp;list=PLX8CzqL3ArzVUm14nYq4E8\_i0b3g2LpC2&amp;index=25&amp;t=659s](https://www.youtube.com/watch?v=Ytja2JuVMlw&amp;list=PLX8CzqL3ArzVUm14nYq4E8_i0b3g2LpC2&amp;index=25&amp;t=659s)) for a list of other libraries or frameworks to look into.
Now when I think of it... I feel ashamed for that idea.
Faculty and instructors get paid to do work and I think by trying to automate a significant part of it they aren't doing that part of the job at all. So fine do that, but I'd advise we cut your salary commensurately.
Performance can be measured. Efficiency requires a human to check.
With some sort of auto-devops tool set as well ... last time I had do something like this I used gradle and created the smaller programs as subprojects with sonarqube (which includes findbugs) and junit.
HackerRank!
[Micronaut](https://guides.micronaut.io/micronaut-function-aws-lambda/guide/index.html) might be worth checkout out as well.
Hi Burr, is this a redhat project or is it a sponsor only? I see that rh projects are deeply involved (hibernate, resteasy, infinispan,...)
Automated style checking is hard if you haven't given the students the exact style you'll be checking and that would be plain frustrating for the students to get right.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt;Faculty and instructors get paid to do work and I think by trying to automate a significant part of it they aren't doing that part of the job at all. So fine do that, but I'd advise we cut your salary commensurately. Don't worry; there's plenty of other work for them to do. Like, you know, hold office hours. Or do research. You know, things the faculty and instructors are supposed to do. Your idea simply makes no sense. The whole point of computers is to automate things and make our lives easier, not purposefully avoid it and intentionally make our lives harder for no discernible reason. It's that kind of backwards thinking that prevents e.g. fully automated trains and forced airlines to buy 3-person 767s when they could easily have been flown with 2. It's just purposely wasting money to justify jobs that shouldn't exist.
Findbugs has been replaced with spotbugs now. https://github.com/spotbugs/spotbugs
Guys I have just started learning generics in Java but the comments suggest that it's not useful. Should I learn it completely or skip it. I'm learning by complete reference.
You're still going to check / help students I'm assuming? It's very possible to write really horrible code that still gives the correct result. You can't rely 100% on unit tests. Maybe it's an idea to let students peer-review (in addition to your reviews) each other's work? It's a good skill to learn anyway.
I find the example case not good, because that just seems to be bad design for me: one should just expect `Iterable&lt;String&gt;` or maybe `Iterable&lt;CharSequence&gt;` as part of the constructor, and then have the calling code do whatever it is needed to convert the input data into the right and expected data type. Otherwise you'll have way too much knowledge in this class (e.g. introduction of new `String`-like types could result in adding different constructors). To be honest I do not really see the initial problem - as in I don't think it's a problem, because I don't see a use-case where you would do something like this without actually making the class generic, and have meaningfully different inputs (which then matter!): ```java class A { A(Iterable&lt;String&gt; i){} A(Iterable&lt;Number&gt; i){} } ``` But if somebody would serve an example like this I'd like to take a look at it!
Java's generics do provide compile-time validation for your constructs, so they are absolutely useful. It's the runtime behavior that is the issue here, for instance, if you'd like the type parameter of the generic to somehow change runtime behavior, because that information is usually lost in erasure. A common case where this comes up is wanting to create an instance of the class mentioned in the type parameter T, e.g. some kind of smart collection where you want to instantiate either the collection or the element on behalf of your caller. People end up trying some variant of "new T()" and it doesn't work because by the time this code runs, Java has no idea what T is (and of course T should also be constrained to be a type that has a callable no-argument constructor).
But then if one of thkse students figure out that it's just the game of inputs and outputs, then it'd be quite absurd. I believe unit testing could be a simple way in which one could add the least requirement of logic to be portrayed. 
&gt;But then if one of thkse students figure out that it's just the game of inputs and outputs, then it'd be quite absurd. Why would it be absurd? That's an exact mirror of professional life. The input should just be unpredictable and different from the example dataset.
So let's say I want to print that right triangle of asterisks. Now the output could easily be maintained by printf statements. But the actual logic of dependent for loops matter. I hope you're a little clear now. Didn't mean to offend your opinion. All I am saying is that it wouldn't work out in most of the cases. 
That's a terrible progranming exercise though. You're not manipulating an input...
It was just a metaphorical example to real problems mate. You're not manipulating an input, but the algo of processing that input can be gimmick-ed.
Thank it and then discard it.
*Effective Java* presents that as its very first item, no less: &gt; Item 1: Consider static factory methods instead of constructors. And one of the reasons it gives to do so is precisely to avoid the problem of constructors with the same signature.
Generics are extremely useful. If you are building non-trivial applications you will find yourself writing generic code on a regular basis.
Generics are supported after compilation. For example the reflection API is full of methods for reflecting on generic types and inspecting generic type signatures at runtime. Type erasure has the highest "whinge" to "actually being a problem" ratio of virtually any language issue I've ever seen.
It looks like in your [submission](https://www.reddit.com/r/java/comments/aynw7b/so_i_recently_saw_an_ad_on_my_local_train_station/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
why should I adopt a free implementation of a proprietary platform and language when there are better alternatives available?
You cannot skip generics. The Java API oozes generics. Most every library you'll ever use, uses generics. Any decent IDE will warn you if you do not use generics where you're supposed to. You cannot skip generics. You may try to, but they won't let you. Unless you're writing some kind of low-level, C-like routine using only primitive types and arrays like this was 1996, chances are you're gonna come across generics the moment you write more than 10 useful lines of code. Asking if you can learn Java while skipping generics is like asking if you can learn English while skipping adjectives: you can try to, but you gonna be confused as hell, won't be able to write anything meaningful, and everybody will look at you funny. You cannot skip generics. --- That being said, you might probably still do okay if you just read over the more advanced aspects of generics, like wildcards and bounded types, and save actually understanding them for when you actually need to use those.
yawn, totally. This is so original. &gt; It's 2019 and there are still people spewing out stupid shit like this. Can you even argument, or are you here just to insult? You have clearly no clue about the history of both languages, if you are a strong java advocate. Or maybe you do earn money by doing monkey-clicking GUI in JavaFX or you are writing JEE crap, I don't know and I am not interested also. By the way, Java has no intellectual value whatsoever; it is a corporate language, created by a corporation (no, C++ was *not* created by AT&amp;T and it is defined by a non proprietary ISO standard). If the language suits you, I have nothing to add about you. Also, what nvi/Vim has to do with this? It is totally unrelated; hence, you are spamming useless comments in my inbox and you are reported for harassment and wasting my time. Having a pleasant day, and please take into consideration the idea of educating yourself if you are planning to have a career in computing.
I do not care about openjdk, since there are better alternatives available than using java at all. Also, your further statements are plain wrong and incorrect. Please read the news, the web, or any book about computer security, even if it is not completely jvm related, you should take hints that adding layers of abstractions by itself *decreases* security in a system.
Depends how these assignments are handed to you. You can setup a CI/CD pipeline (easiest via Github) and add there all sorts of quality gateways, including tests, static code analysis, checks for duplicate code etc :)
Can you even realize how are you contradicting yourself in this comment? *This* is funny. I do not think you would have fun at all working with me, but the reverse may apply.
Not sure why people are downvoting you, that comic is definitely /r/fellowkids material.
\&gt; Multiple classes (especially worse on Android) &amp;#x200B; There're two solutions, you can try to use first with factory methods if you have class count limit like on Android &amp;#x200B; \&gt; Reduced readability &amp;#x200B; This is very opinion based statement - as for me second solution is more clear and easier to read. &amp;#x200B; \&gt; This feels like to be an anti-pattern on the same level as [double brace initialization](https://stackoverflow.com/questions/1958636/what-is-double-brace-initialization-in-java). &amp;#x200B; It doesn't have something in common with double brace initialization issues - nested classes marked with \`static\` won't produce runtime classes with pointer to \`this\` of base class (what is the main problem of double braces) &amp;#x200B;
Java generics aren't THAT useless. I use generics all the time. 
ok, but C++ generics are absolutely awful and partly destroyed the language. There are few problems with Java generics but a huge advantages in reagards to C++ ones
&gt; So Sun didn't have the rights to open source those pieces. I know. I don't understand how this is relevant to the fact that for the first time ever, Java is now completely open source. &gt; Then what is Oracle charging license fees for if not for providing patches and updates to LTS versions so users can stay on them longer and not be required to adopt a new release every 6 months? I don't understand what you mean by "a new release." Even if you stay on LTS you need to adopt a new release every six months to get security updates. LTS is for those who don't want a new *feature* release every six months. But it's hard to compare this directly to the old situation, because the old situation didn't have feature releases, it had major and limited update releases. &gt; or be prepared to upgrade every instance, server and desktop, every 6 months. You had to upgrade every instance server and desktop every 6 months for the last decade. What concerns you is that instead of calling an update version 10u20 we've decided to call it 11. Now, it is true that the feature versions are not exactly like to old update versions. But it is absolutely impossible to claim that while upgrading 8-&gt;8u20-&gt;8u40 was an unacceptable burden, 11-&gt;12-&gt;13 etc. is not. We believe that the total upgrade effort will be *smaller*, but we don't know for sure. It is impossible that you've been able to determine that the effort would be *greater*. &gt; should we consider replacing services with something like Node.js. You definitely should because the Node.js ecosystem is known for its stability. But you should perhaps also consider not panicking about naming changes, and realizing that you can try and actually see what the upgrade costs are. In the meantime, *if* things go terribly wrong, you always have the option of staying with 11 through Adopt (which does exists now), or even, God forbid, have the large financial services organization pay Oracle $25 a month per server ($2.5 per desktop) until you move to Node. &gt; I'd argue GCC is much larger and doesn't have this problem. GCC is somewhat smaller, and its maintenance burden is *much* smaller. OpenJDK requires several hundreds of full-time engineers.
My professor usually provided us with skeleton code with certain methods empty. The skeleton code handled input and output, so we didn't have to worry about formatting. Then the professor could just use a script to execute all of our submissions with whatever inputs (usually different inputs from the test inputs he provided us, to prevent hardcoded solutions). Any programs that didn't compile or threw any exceptions got a zero for the assignment. Programs that produced incorrect output were heavily marked down. Then the professor would go through all the submissions manually (at least the ones that compiled and didn't throw an exception) and mark down cases of bad style (bad formatting, poorly-named variables/functions, use of magic numbers, etc) or efficiency (usually the assignments were based on topics being taught in class, so we had to implement whatever algorithm the "right" way). I think the grades were usually roughly 50% based on output correctness and 50% based on code quality. The benefit of providing skeleton code with I/O is that all submissions will output in the same format, so writing a script to compare submission output to the correct output is stupid easy. If you're grading more than just the output/correctness, I'm not sure there's really a good answer other than "do it by hand". You can try unit tests or sonarqube, but I think that's going to be more trouble than it's worth, especially since you'll probably still have to go over the results manually for false positives/negatives (ie cases where the tests fails but you want to give credit anyway, or cases where the tests pass but you want to take points off for something). 
Why all the bashing in the comments in this thread?
I'll give it a try. Thanks!
Great - let us know what you think!
Framework tiredness, SEAM memories, fed up with hypes, etc I guess. Most of us either Java/Jakarta EE or Spring, and would like to see those being improved on a constant bases. There's something to say for trying things about before feeding it back into Java/Jakarta EE and/or MP, but still. 
Is this related to how IBM sees the future of Jakarta EE?
I'm not going to sign up just for a demo, sorry. You should make it possible to at least use the demo application without signups. Also, from your agreement: &gt; 4.1 Licence. You grant Diffblue a **worldwide**, royalty-free, **transferable licence** to host and use Your Content and the Tests for the purpose of (i) providing the Product to you; and (ii) running tests on Your Content **to improve the Product and Diffblue’s other products.** Nope.
Thanks for your feedback, I'll pass it on to the demo team. For what it's worth, I agree with you about the sign up. IMHO the demo should at least do something useful without requiring a sign up. &amp;#x200B; I can't really comment on the licence text - I assume we are reserving the right to use code provided in the demo to improve our code analysis and test generation algorithms. &amp;#x200B; &amp;#x200B;
DiffMerge. It lets you compare two files side-by-side, and points out where the differences are. It was designed for CI, but it sounds like it would work well in your situation also. It works with the IntelliJ IDE, and probably others. 
I took a class in functional programming in uni where we had to submit code. You had three tries and you could tell that they were just compiling and running your code against a unit test, but without disclosing the tests. I guess you could do something similar. 
Because it *still* increases code sharing. Can you try to explain you see the passage of time as having somehow changed the nature of the trade-off? Reification is pretty rarely useful in reality, most people who think they want it for some use-case or another are off the mark in my experience. Obviously there are exceptions to that, but avoiding specialization costs OTOH is useful in just about every Java program ever written. That said, specialization is coming, though whether it will only be available for specializing over value types or whether it will be possible to opt-in to specialization in other contexts remains to be seen.
I like the idea a lot, but I don't like uploading my company's IP... But I'll try it on my open source projects.
Awesome, thank you for checking it out.
[Autolab](http://www.autolabproject.com) is used by a number of universities for automatic grading. But not sure about checking against a specific style guideline.
Nice concept, but closed source and proprietary, so no thanks.
Thanks for taking a look -the tool itself will definitely remain closed source, but I think there is a hope that this demo and any tools like it that we build in the future will be of benefit to the open source community. &amp;#x200B; We do provide some open source tools in the form of [cbmc](https://github.com/diffblue/cbmc) / [jbmc](https://github.com/diffblue/cbmc/tree/develop/jbmc) which do Bounded Model Checking for C++ and Java.
Generating unit tests after the fact reduces the benefits of unit tests, no?
Not necessarily, unless perhaps you are observing strict TDD practices and maintaining 100% test coverage as you go! I appreciate your point though. I think this tool is really to help fill gaps in your test coverage. &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B;
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I understand why you want to do this but there are two things horribly wrong with this: * You should not stuff license transfers of code somewhere in an EULA or something. People should be very aware of what they do; pasting production code into your tool would be grounds for firing in many companies. * Your license is way too broad. There is no reason at all to restrict it to only DiffBlue. There is *definitely* no reason at all for that license to be transferrable. As it is now well meaning junior developers might be 'tricked' into using this to generate tests for their production code. There needs to be big fat warnings that this tool should never ever be used for this in it's current form.
well thats true
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Sounds more like old fossils unable to adapt. Neither JEE nor Spring even got async/reactive right yet.
That is even the best performing solution. Congrats to the student figuering that out. Now you could make it more difficult by having input n that varies the size of the side.
Absolutely. For Hibernate ORM, we did push upstream all of our optimizations and they do improve things. For Weld, it's different. We decided to reimplement CDI for Quarkus as it does everything at build time and Weld was too proxy heavy for our objective. It is named Quarkus ArC. Note that our improvements span beyond these projects. For example we did improve the PostgreSQL driver in the process.
Awesome. Thanks! 
I'll make sure this gets back to the relevant people, many thanks for your in depth response!
* Functionality: [JUnit](https://junit.org/junit5/) Tests * Performance: [OpenJDK JMH](https://openjdk.java.net/projects/code-tools/jmh/) Benchmark * Codestyle: [Checkstyle](https://maven.apache.org/plugins/maven-checkstyle-plugin/), [Spotbugs](https://spotbugs.github.io/spotbugs-maven-plugin/), [FB Infer](https://fbinfer.com/), [Google ErrorProne](https://github.com/google/error-prone) 
&gt; LTS is for those who don't want a new feature release every six months This right here is the issue, enterprises want long term stability and want to take on **new features** on their schedule. Up until January of 2019 that approach did not require a paid license, now it does. &gt;But perhaps you should also consider not panicking, No one is panicking, the organizations I'm working with are running the numbers and determining if they potentially have a financial expense starting in 2019 they didn't have before. What is happening now is a correct cost benefit analysis, is it cheaper to pay the LTS support license cost which will be an ongoing charge or cheaper to consider alternatives that might be one-time costs that put control of adopting new features back into the hands of the planning teams. Likeliest outcome is use Adopt's supported Java 8 and plan to move to alternatives. But questions are being raised around OpenJDK because, as you yourself pointed out in another thread, Oracle *owns* that too, so there is concern that Oracle could pull the rug out from under AdoptOpenJDK if they decided too. &gt;$25 a month per server, until the migration is complete, Correct me if I'm wrong, but Oracle doesn't do month by month nor partial licensing, for them it is minimum yearly covering all required licenses. Understand I'm not arguing that Oracle doesn't have the right as the new owners of Java to try and monetize it, you bought it you do what you want with it. I don't agree with the constant marketing of how great the new model if you don't pay for support is, but that is based on my experiences with version changes of many tools. Building major systems on a tool that provided long term support (as in more than 1 year) without cost, that allowed time to plan for absorbing new feature releases to now being required to pay for those security patches or accept any changes decided upon by Oracle every 6 months is what is causing the rethink. 
YAGNI seems to me to be insufficient - interfaces require no work to implement and equally no work to maintain. Why can be gained by excluding them?
I would recommend Java: The Complete Reference, Eleventh Edition. Currently going over it to catch up introduces changes since we're going to migrate to Java 11 soon. Once you got that down, Java 9 modularity is also a must.
Wow, you're really on a crusade here, aren't ya
I am not, I am just bored trying to explain software and PL history to incompetent kids who only are capable of insulting and write hideous innuendos.
Well, if your just using pandas to read and create csv files, then there is a library in java called opencsv, as for the ML/Datascience staff, there is DeepLearning4J, but if you really know your stuff, then you can code in any language.
It definitely applies. The question shouldn't be "What can be gained by excluding them?" but "What can be gained by \*including\* them?" And the answer to that is: nothing. Martin Fowler [wrote about this](https://martinfowler.com/bliki/InterfaceImplementationPair.html) (in a slightly more nuanced way). My favorite points are: * If you ever need a second implementation for that class, you can simply use the "Extract Interface" refactoring. It takes seconds. * Having interfaces everywhere actually hides cases where you do have multiple implementations. I think this practice became popular when mocking frameworks were becoming popular but couldn't easily handle actual classes, so using interfaces was required to write unit tests. Mocking frameworks have come a long way since then.
Thanks, I should include a hint that modern mocking frameworks can indeed mock concrete classes ;).
Bull. Spring has WebFlux for quite some time now.
You can also pass a Foo::new as a pointer to your constructor, and then use that to create your T.
Same for me. I'm not gonna to register just for a demo
&gt; This right here is the issue, enterprises want long term stability and want to take on new features on their schedule. Up until January of 2019 that approach did not require a paid license, now it does. This is incorrect. The old limited update releases, like the new feature releases, contained significant new features. A free option of getting *just* bug and security fixes never existed. &gt; But questions are being raised around OpenJDK because, as you yourself pointed out in another thread, Oracle owns that too, so there is concern that Oracle could pull the rug out from under AdoptOpenJDK if they decided too. Why would Oracle want to do that? After all, it just completed open sourcing all of the previously commercial features? Over the past decade, Java has never become less free, only more. If you weren't concenred about this before, why would be concerned about this now, when Oracle has just made Java more free than ever? &gt; Oracle doesn't do month by month nor partial licensing, for them it is minimum yearly covering all required licenses. I'm not sure, and you may well be right, but that's the monthly cost (perhaps for an annual subscription). &gt; Building major systems on a tool that provided long term support (as in more than 1 year) without cost, that allowed time to plan for absorbing new feature releases to now being required to pay for those security patches or accept any changes decided upon by Oracle every 6 months is what is causing the rethink. I think you have misunderstood the recent changes, then. What long-term support meant before and what it does now are two different things. Before there was no option not to upgrade without new features; now there is. Before there were major releases; now there aren't. 
It's an opinionated style guide, but also mostly defaults from IntelliJ linting. I like the point about serialization. I definitely prefer immutable DTOs, but it has proven difficult when using frameworks such as ModelMapper to handle object mapping. 
Interfaces are good since you can share the interface definition to others without sharing the implementation. For example, what I like to do, is to create a JAX-WS/JAX-RS API artifact, that contains only: * interfaces for SOAP services /REST controllers, annotated with the proper JAX-WS, JAX-RS annotations * DTO definitions This API is built and shared via a Maven repository (access can be given to customers). That way, the implementation is not shared, there is nothing extra to document (an implementation + a wikipage describing the interface can mismatch), and the other side can use the definitions as proxy classes (like via CXF or RestEasy) and use the service without worrying about proper mapping. In this way, clients (even internal clients) can be developed in no time, without declaring mappings twice: one for the server, and one for the client. They both share the interface metadata. So you need interfaces to share those. Think about interfaces as "C header files". Shows the API, hides the implementation (that resides in linkable object files). 
/r/javahelp If you are on a *nx box you would have your operating system package manager get it.
What about this [link](https://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase7-521261.html)? You probably want 'Java SE Development Kit 7u80' or 'Java SE Runtime Environment 7u80'
I hear you -it's certainly a barrier. Thanks for the feedback.
+1 for immutable DTOs with @JsonCreator.
I think you should definitely pass the license comments on. I wouldn't touch this with a 10 foot pole if any of my IP is in question. I realise you're only doing this for the purpose of improving your service, but almost any company will have a problem with this wording.
Go to Oracle, make an account, and go into their archives. Or you could try jdk Java net (Oracle GA).
I have done already, as I can see that a lot of people agree with this sentiment. For what it's worth, I think that it's a good general principle not to upload any code that constitutes IP to a third party. Re your last point, if a company wants to use the service, it is available as paid-for product (Diffblue Cover) which would have IP suitable licensing.
&gt; similar number of enhancements in 8u20 and 8u40 to 10 an 11 Similar numbers don't mean similar significance. Changes from Java 8 to Java 9 introduced the Jigsaw modules, removed JavaDB. Java 9 to 10 removed javah, 10 to 11 removed JavaFX, Java EE, CORBA. The only significant changes in 8u20 were disabling DES TLS cipher suites and removing of Symantec root certs that were considered no longer in use. 8u40 introduced enhancements to Packager, Nashorn, JavaFX, deprecated - but not removed - some APIs. The level of change between 8u20 and 8u40 was much less impactful to users than from 8 to 9 or 9 to 11. &gt;Before there were major releases; now there aren't. JEP 322 specifically states &gt;$FEATURE is incremented every six months: The March 2018 release is JDK 10, the September 2018 release is JDK 11, and so forth. &gt;We do expect most feature releases to contain at least **one or two significant features**, and for update releases never to include incompatible changes. So how do you differentiate between 6 month **feature** releases and **major** releases? &gt;Oracle just completed open sourcing all of the commercial features. If you weren't concerned about this over the past decade, why would be concerned about this now, when Oracle has just made Java freer than ever? Key word there is **commercial** features. As already discussed what you show Oracle open sourcing were addons, the core JDK and VM components were already open sourced, not by Oracle, by Sun. &gt;Oracle has just made Java freer than ever? And yet you made the point elsewhere that Oracle **owns** OpenJDK. But if as you keep saying everything is now fully open sourced *by Oracle* why does Oracle still maintain its own build of the JDK and not simply redistribute the builds from AdoptOpenJDK? Are you saying those two are absolutely identical in every way? &gt; Long term support means something quite different from what it meant before. Correct, long term support is available via a support license, where previously a version like 1.8.0 was released and it received patches and updates for around 2 years after, sometimes longer, that were available via the standard updater tool. &gt;Before there was no option to upgrade without new features; As shown from the release notes above, upgrades of 8u20 to 8u40 did not remove features (adding something doesn't generally break code) and there wasn't concern that there would be any breaking changes. From 6 to 7 to 8 we accepted there would be breaking changes and always did full rounds of regression testing. From 8 to 9 to 11 we are seeing pieces being fully removed that now need to be replaced and as the JEP states the only releases that are confirmed not to have incompatible changes are the one or two update releases during the 6 month period.
Don't you need interfaces for Spring to proxy classes by default?
Spring uses cglib if the class has no interface
You're being silly. This has nothing to do with airplane staffing or automating trains.
Maybe things have changed, but there was a good technical reason to use interfaces. If you use interfaces, Spring uses java.lang.reflect.Proxy to create the objects it controls. If you use objects, it has to jump through hoops. In my experience, reflect.Proxy is more likely to just work as expected in unusual cases (AOP, Transactional, Spring security, etc.). For that reason, I recommend interfaces for all Spring beans.
Is there any reason you want to use an obsolete Java? Why not use Java10/11?
&gt; The level of change between 8u20 and 8u40 was much less impactful to users than from 8 to 9 8-&gt;9 was a major upgrade. I don't agree about 10-&gt;11. Removing, say, JavaFX, is of little significance. &gt; So how do you differentiate between 6 month feature releases and major releases? Like this: * [This is what a major release looks like](https://openjdk.java.net/projects/jdk9/) * [This is what a feature release looks like](https://openjdk.java.net/projects/jdk/12/) &gt; As already discussed what you show Oracle open sourcing were addons, the core JDK and VM components were already open sourced, not by Oracle, by Sun. No, they were not addons. JFR, App CDS and ZGC are very much at the heart of HotSpot. &gt; But if as you keep saying everything is now fully open sourced by Oracle why does Oracle still maintain its own build of the JDK and not simply redistribute the builds from AdoptOpenJDK? Are you saying those two are absolutely identical in every way? OpenJDK is an open source project. Oracle distributes binary builds for the main platforms it supports (Linux, Mac, Windows). Anyone else, like AdoptOpenJDK is free to build for whatever platform they like. I don't know what the Adopt build process is, so I can't tell you if the outcome is identical in every way, but the source code is. &gt; where previously a version like 1.8.0 was released and it received patches and updates for around 2 years after But 1.8.0 was a major release, and some of those updates were as big as today's feature releases. 8u20 didn't receive patches after 8u40 came out. Major/update releases are gone. &gt; upgrades of 8u20 to 8u40 did not remove features (adding something doesn't generally break code) What we care about is not the probability that anyone's code would be affected by a release, as that probability is very high, and was always high even for update releases. What we care about is, for a given application, what is the mean time between breakages due to updates, or, better yet, what is the average cost of upgrade for an average organization. We believe that the first metric would stay the same as before or maybe go slightly up, and the second would go down, hopefully significantly. &gt; From 8 to 9 to 11 we are seeing pieces being fully removed Yes. This is not related to the release cadence, though. Part of the reason we had to introduce breaking changes in 9 and subsequently remove pieces from the JDK is that the JDK was no longer maintainable in its previous form. If you can come up with a way that would allow us to continue maintaining the JDK and adding all the improvements people want for the next 20 years without removing anything, let us know.
The issue with generics aside, the example class in the article looks exactly like examples from this video: [Stop Writing Classes](https://www.youtube.com/watch?v=o9pEzgHorH0) &gt;This is not a class. Or it shouldn't be a class. The signature of "this shouldn't be a class" is that it has two methods, one of which is `__init__`. Anytime you see that, you should probably think: "hey, maybe I just need the one method". Anytime you see this you'll know that you should have just written a function". In fact, the description of that class is literally a verb phrase.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Login: `blubberblubber@trash-mail.com` | Password: `Blubberblubber1`
Is Google broken for you?
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
If there’s only one class that will implement the interface it becomes cumbersome. Are cglib proxies really that bad? 
Wow, this was a pretty evil agreement, good thing I didn't stuff any of my employers code into that.
Can you please expand your statement, or please provide some pointers to some resources. I am a spring noob. 
You really want to avoid operations that have a reasonable chance of failure in a constructor. This also is one of the reasons it's a bad idea to call overridable methods from the constructor.
I'd prefer F#'s `|&gt;` operator (or anything similar) (title |&gt; Example::naiveDropFirstWord |&gt; Example::naiveTitleCase).concat(".") This should be a language feature, not a quirky method on a single JDK type
&gt; you really want to avoid operations that have a reasonable chance of failure in a constructor I'm not disagreeing, but that explanation just leads to another question, *why is it bad practice to have a failure in a constructor*.
It's not, as long as the constructor is the one throwing the exceptions, usually for reasons involving arguments passed to the constructor. If it's failing for more than that, then the constructor is tightly coupled to the environment. Barring unavoidable environmental failures like OOM (at which point, you really have bigger problems), a constructor should work regardless of the environment it's executed in.
No. Modern runtime will make it a String Builder under the hood. It's only an issue, if you add to the same String through different loop cycles. Likewise your two superfluous variables will likely get inlined by the JIT. 
The compiler doesn't make it Stringbuilder when concatenating in a loop - [https://stackoverflow.com/questions/1532461/stringbuilder-vs-string-concatenation-in-tostring-in-java](https://stackoverflow.com/questions/1532461/stringbuilder-vs-string-concatenation-in-tostring-in-java)
I don't know if this is universally good advice, but in my own code I like my constructors to do as little as possible. I prefer to have the objects being passed in be fully constructed. This has made it easier for me to mock things out or test things. I think this is a form of dependency injection.
No. You are effectively not in a loop here, because your concatenation doesn't jump cycles. 
See the AOP section of the Spring Reference. 
Because the state of various other data structures that contain that class may become undefined when an exception is being thrown. Now, in STL specifically, they have taken great care of providing exception guarantee in most cases, so even if an exception is being thrown at some point your map or vector or stack will remain in a known valid state. This cannot always be said of custom structures that you may have created in your program. Another issue is slowness. And the constructor of the object is very easy to invoke inadvertently (a missed RVO by the compiler, copy operations, etc.) leading to slowness of the application. As you can see what I described here were bugs essentially. Bugs in your program or in data structures that when coupled with a constructor that does IO can have bad consequences. If you're doing everything right, you will not have these issues. In a 100K+ lines of code codebase though, is quite hard to do everything right all the time.
"help with programming" posts should go to [/r/javahelp](https://www.reddit.com/r/javahelp).
[https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-pfb-proxy-types](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-pfb-proxy-types)
yes and to add to that, if constructing an object requires performing operations that may fail that's likely a code smell of bad design. `new`ing up an object and expecting it to perform as of you had called a method to perform an action are totally different things. 
Maybe it depends on the version (we're on an older version of Spring), but we've had issues with Spring Security annotations, @Transactional annotations and CGLIB. Like for some reason we can't combine @Transactional, constructor injection, and CGLIB. It just doesn't work with our Spring version. So half our classes can use constructor injection cleanly, and half have to use property injection. Also people do dumb things like marking methods as final, and tracking down bugs involving that is a serious pain. It's just personal experience, but things work 100% of the time with JDK Proxies, and maybe 95% of the time with CGLIB proxies.
Why not put the method in the Item class itself, like: String getKeyString() { return this.name + "_" + this.type; } also you can then use it nicely in a stream: List&lt;String&gt; keys = items.stream() .mapToObj(Item::getKeyString) .collect(Collectors.toList());
Wrong subreddit. You’re looking for /r/learnjava and /r/javahelp. You should be able to Google this though. 
The short answer is that Spring uses instances of the Proxy class to provide a dynamic implementation of your interfaces. This is kind of magic because normally the interfaces need to be known at compile time. If your class does not implement interfaces though, the Proxy class cannot be used. In these cases, Spring uses cglib to create a completely new class that did not exist before as a subclass of your class; dynamically at runtime. There is also compile-time weaving if you don't want that to happen at runtime, but that's a special case. This differentiation has some pitfalls in some cases. As an example, you cannot autowire a UserServiceImpl (implements UserService) because Spring will create an instance of Proxy. You would get a ClassCastException at runtime because that instance of Proxy is no subclass of UserServiceImpl, even though both implement UserService. If you try to autowire PetService (with no interfaces), this would work because Spring would create a subclass of PetService using cglib. There's actually a setting to force the usage of cglib but generally it's better to just use the interfaces
You generally want exceptions where people can catch them, i.e. when people do try-catch-finally blocks, this is where they expect exception to be thrown, not during initialization, initialization can also happen outside of constructor, ie. if it is a static variable (aka private static final Logger = new Logger()), you cannot really catch exception like that. This makes things even worse if you are including third part library with exploding objects, i.e your JVM shuts down before you enter your main(), because somewhere the object failed to initialize, and this is not even an object you use or need from the library.
The constructor has *one* job. To initialize this object with a sensible state. If that requires for example reading from a file, then that's okay in my opinion. However, don't do anything that isn't integral to the object's existence. 
If only... &amp;#x200B; Iterable&lt;String | Text&gt; &amp;#x200B; Sigh...
Yep, in OPs example is not going to be an issue because they're creating a new string in each iteration. But String keys = ""; for (final Item item : items) { final String name = item.getName(); final String type = item.getType(); keys += name + "_" + type; } is inefficient, because each loop will create a new `StringBuilder` object on each iteration. It's more efficient to do it manually. StringBuilder keys = new StringBuilder(); for (final Item item : items) { final String name = item.getName(); final String type = item.getType(); keys.append(name).append('_').append(type); } 
I think you've misunderstood. Your example is as efficient as explicitly using a `StringBuilder`, but is clearer. 
And please no dtos that duplicate the entity exactly.. 
I always thought that you needed @JsonProperty with @JsonCreator. But it seems not anymore! Good grief this will change my code on Monday.
I wish JPA had a similar mechanism that allowed for immutable objects (opposed to immutable entities).
In addition to some of the excellent comments of others, I'd add one more reason: unit testing. You didn't say what your constructor is writing, or to where (i.e., to disk or to network), but do you really want to be writing I/O every time you do unit tests on your class? In my work environment, for example, our code is built by a Hudson continuous integration server using Maven. Every Maven build runs unit tests. We certainly don't want to fill up the Hudson server's hard drive with crap just because a unit test called `new` on something.
In a language like C++ it was a problem because if the constructor failed you had no reference to the allocated memory to be able to deallocate it. Java has garbage collection so that's not a problem.
An automatically generated unit test is sometimes better than none. 
I think the only caveat with cglib proxies (non interface proxies) was that you can't make your classes final. I don't remember any other real life difference between them.
I could see this being an issue with static initialization which could block on the IO operations which then blocks on the synchronization of the class loader on the first load of that class.
&gt; Also people do dumb things like marking methods as final, That's actually a very dumb thing to say. It is a very sane decision to mark classes or methods final. It's the framework which forces us do write dumber code (i.e. non final) than we should. 
`Iterable&lt;? extends CharSequence&gt;`
Right. I meant that it is a dumb thing to do with classes that you know will be proxied by Spring, since Spring cannot intercept those final methods.
Actually for DTOs I would even go further and make them strings public without any getters. What's the point of getters on final Strings in a DTO?
&gt; In a language like C++ it was a problem because if the constructor failed you had no reference to the allocated memory to be able to deallocate it. This is incorrect, no memory is leaked if you throw an exception in a constructor in C++. This is well-documented : https://isocpp.org/wiki/faq/exceptions#ctors-can-throw &gt; Note: if a constructor finishes by throwing an exception, the memory associated with the object itself is cleaned up — there is no memory leak. 
Not sure I fully agree with this. Constructors should validate their arguments, and handling a valuation failure by throwing an exception is invariably preferable to allowing the object to be constructed in an invalid state.
I generally expect new-ing up objects to use a minimum of resources. For intensive tasks such as IO, putting that work in say a factory (yuk) or even just a build method on the class itself can alert the user of your class that something more than just the usual provisioning is going to happen. 
Despite this being Java forum, you appear to be referencing C++, where exceptions in constructors is even a known technique. Herb Sutter has written extensively on making C++ code exception-safe.
&gt; To initialize this object with a sensible state Exactly. And if it can't do that it should throw an exception rather than leave the object in an invalid state.
You can still use streams without the method on the item object. Just use a lambda instead of a method reference.
We could always ask on a mailing list.
You are not wrong, but from design stand point, and future proofing, validation is probably better before creation, nor during. For example, what of the data you are validating needs more information that your object does not have, I.e your object keeps track of time worked, but validation rules today specify that information cannot be entered during holidays, and in the future they make another requirement that you can enter information when you have overtime improved. Validation rules may change, validation may require information not in the object, and changing the constructor may break dependencies, so not the best long term approach. That is why most of the time, constructors are light.
I know that, personally I think it looks better.
&gt; There's no need to clutter a class with a trivial method if it's only going to be used in one place. 
We don't know the full use case here. If this is something that happens to *every* key then it absolutely makes sense to have it be a class method - if it happens more than once then it should probably instead be called only once and saved as a class member. Actually, the list being called 'keys' makes me suspicious about the entire thing here.
&gt; and explain why it so much better than Java I guess you missed that part didn't you? You do like to make off-the-cuff remarks without really anything behind them do you? You say C++ is better than Java and give no explanation at all why you think its better. Okay... here's a reason why Java is better... it has GC, and I really can't imagine in this day and age I really don't want to bother micro-management of object dispose when its something that can just be done automatically. I'm sure you can come up with some reasons why C++ is better but you really don't make much of an effort at arguing your point.
There's indeed a tremendous amount of engineering behind the JVM, it's jit compiler and GC. Just wait until Graal VM goes mainstream... its only going to get better.
Ah, fair enough. I was writing based on the folklore that was around in the '90s when I was a C++ programmer.
And what if I need to read content from a file to initialize the object properly? That's IO. If I instead don't want to do IO, then I would have to defer reading the file, or even checking that it exists (because that's also IO). And arguably that forces me to create the object in an 'invalid state' because it points to file that may not exist, or not have the data in a format I expected.
&gt; interfaces require no work to implement and equally no work to maintain. That's simply not true. I currently work on a huge code base where this anti pattern is unfortunately in place. Whenever I have to dive into the code (e.g. for investigating a bug) I have every time this totally useless indirection before I come to the real code, multiple times, depending on how deep I have to dig. This costs time and it is distracting.
He has also written extensively on how hard it is to make it so. As for being a Java forum ... I didn't realize. I'm subscribed to both, as I write in both languages daily.
Sorry then. I didn't understood that right the first time.
I don't beleave in these kind of sweeping statements. You shouldn't either. Just focus on writing an API so that you feel like it would be 'pleasant' and 'logical' to use. If that includes doing some IO in the contstructor (like for example validating an argument that points to a file, by checking that this file exist and reading some or all of its contents to initialize the object's state from it) then why not? Bottom line, if your api makes sense and is easy to use (which includes considerations on how you want to deal with errors, which may happen when you do IO in the constructor)... then its alright. IMO. Example: Let's say I store 'Calendar' appointments in little json files. And I have a class called 'Appointment'. The class has a constructor in which we pass in a 'File' pointing to the appointment data. To me it makes good sense that 'new Appointment(File)' would read the file as part of the initialization of the object and that it should throw an error if that File doesn't exist or has bad data. I'd much rather have it throw the error then than at some time later when we try to access the appointment's attributes. So here... I see absolutely nothing wrong with doing IO in the constructor. I actually expect that it should!
Could you specify the dependencies a parameter in the constructor?
What dependencies? I don't quite understand what you are saying. 
Yeah that's why we currently don't even run their code but just read it and grade it. I don't think they really review each other, I will look into that solution. Thank you
In other words, Instead of reading the required data from a file inside the constructor implementation, specify the required data as a a parameter in the constructor
I guess you could, but I'm not sure it makes a lot of sense. The data in the file contains information specific to how that class works, and the format in which is stored really shouldn't be anybody else's business. So I'd rather have the class be responsible for reading and parsing that file. But sure there are other ways and maybe we could use something automatic like 'jackson' or whatever. I just don't think just making blanket statements like 'you should never do IO in a constructor' are bit silly. Consider what you want your API to do, how you wanna use it. Then go ahead and do it. If it seems logical then I see no problem with it.
The class that represents the data and the class the parses it can and should definitely be two different classes. They are two separate concerns. 1. It allows multiple versions of the data format. 2. Makes it easier to test the system. 3. Facilitates future change. 4. Allows for retry when IO fails. You don't have to do it ofc. but any reasoning for it relies on the assumption that: 1. The format won't change 2. Tests aren't needed 3. The program won't change 4. IO won't fail, or if it does so can the program Which is a pretty tall order.
You constructor injection example has no @Autowired annotation on the constructor
'_'
I'd rather have a factory or builder for that though.
lol. you are indeed debugging in production. the meme was true all along.
This breaks the single responsibility principle. You want that type to do its thing and also read and parse a file with configuration. Here is when you want to use the Factory pattern.
I agree that the blanket statement doesn’t apply to all situations The constraint that a file must be read from the file system is kind of rigid though. What if you want to use the object in a unit test where the file system is not available? An object that requires that some file resource exists at runtime is a hidden constraint that is not obvious to the users of your interface - kind of like a global variable. It’s generally not a good idea but I wouldn’t say it’s a hard rule. It all depends on the context of the system you’re working on in the end
Give anything that is needed for object creation to the constructor. If the file content cant be aquired the object cant be created. There's no invalid state. 
r/forhire. 
SRP is never a valid argument unless you are talking about an abstract interface. You can do better than parroting platitudes.
Wrong sub. Read the rules.
wrong place, go somewhere like [here](https://www.makeuseof.com/tag/6-websites-hire-awesome-programmer-freelancers/)
That just offset the problem one step back. So you have a `MyClass` that needs a parameter on initialization, and you have a `MyClassConfigProvider` which is able to parse the file and provide the config. So if you want to instantiate the `MyClass` - it would need to somehow call the `MyClassConfigProvider` which is presumably passed as an argument into constructor, which will read the file. So looking at the call chain - IO still happened in the constructor of `MyClass`, but hidden behind a method call. Alternatively, creating the `MyClassConfigProvider` would read the config preemptively, which means... in it's constructor. 
In my mind there are some technical reasons like others have mentioned. If you need to call a particular superclass constructor there is a limitation to ordering, which may prevent you from constructing a valid class. But the main reason is the principle of least surprise: calling a constructor doesn’t feel like you are doing anything. Everyone knows how easy it is to construct a class. So if you perform lots of IO which could block, timeout, add latency, potentially require retries, people are going to be surprised. Often you would create a factory method or even better a builder, which gives you the opportunity to manipulate the builder and even check validity superficially before going to disk or network. 
Paying how well? Senior Java dev here. Message me what you’re paying and if it’s acceptable, I’m down.
It looks like in your [submission](https://www.reddit.com/r/java/comments/az0469/java_training_in_bangalore/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
This. IO *should* always be processed as its own object. This eliminates a lot of problems that can occur when you're trying to calculate or run several things at once. Look at it this way: Would you assign one variable for two separate variables, and then roll the dice on whether or not you get the right answer? Not a good idea... 
I agree with this, but I think theres a bit of ambiguity with OPs question. I think in this case, he should practice having a separate IO class with specific constructors that parse for what hes searching for before passing that data to another class to do "something." Exceptions should catch on execution, and proper logging will give him/her a good idea for debugging. 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
just see the thread, I was attacked on many front by java zealots, and I replied politely. Please follow the thread if you are interested. Please note that (if you wish) C++ can include GC, but obviously this is are a terrible design choice in a general purpose system language. And you can also run java without a virtual machine, if you wish. So my objections are about the current major implementation of java, not on the semantics (which I nonetheless find ugly also, compared to C). To make it short and easier even for you: &amp;#x200B; Java has no intellectual value whatsoever; it is a corporate language, created by a corporation (no, C++ was *not* created by AT&amp;T and it is defined by a non proprietary ISO standard). If the language suits you, I have nothing to add about you. &amp;#x200B; Java is a clear example of MOL (money-oriented-language). It is not platform independent; it is a platform. like MS Windows, it is a commercial proprietary platform (in the oracle jdk), backed by a commercial entity. That is not the case of ISO c++ or ISO C or other standard languages defined by a real committee and not a multinational. That is, you can write software for Java/JVM or C#/Intel and in both cases you are developing code for a single proprietary commercial platform, and you are writing code tweaked to the benefit of that corporation. There are standard and free (as in freedom also) languages to use, out there. Why being stuck with such underpowered and legacy (read = proprietary) tools? Why rely on a openjdk which is nothing but a free replacement for something that should have not existed in the first place and was not designed by solving problems (like C and C++ were) but only to make Sun dollars? and now, Oracle? [https://www.aspera.com/en/blog/oracle-will-charge-for-java-starting-in-2019/](https://www.aspera.com/en/blog/oracle-will-charge-for-java-starting-in-2019/) &amp;#x200B; Please consider the option of educating yourself if you are planning to have a career in the field of computing. Stroustrup's FAQs are a good start. &amp;#x200B; [http://www.stroustrup.com/bs\_faq.html#garbage-collection](http://www.stroustrup.com/bs_faq.html#garbage-collection) &amp;#x200B; &amp;#x200B; &amp;#x200B; [http://www.stroustrup.com/bs\_faq.html#Java](http://www.stroustrup.com/bs_faq.html#Java) &amp;#x200B; &amp;#x200B; &amp;#x200B; [https://www.quora.com/Is-it-a-design-fault-that-C++-itself-has-no-garbage-collection](https://www.quora.com/Is-it-a-design-fault-that-C++-itself-has-no-garbage-collection) &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; Unicuique suum. &amp;#x200B;
In this case it might be warranted. I have been burned (and burned myself) by coupling the fetching of data and processing of said data. Mainly, if you load a file in the constructor, then that data must come from a file if you want to utilize this class's abilities. This is problematic if you want to test the class with in-memory data, or if there's a case where you want it to pull the data from a URL, S3, etc. 
You don’t need @Autowired if you class only has one constructor.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Since Java 8, a compiler flag can expose parameter names at runtime. That flag is what enables this magic. You need [a special Jackson module to support it](https://github.com/FasterXML/jackson-modules-java8); Sprint Boot 2 includes that module, and maybe enables the setting behind the scenes. Personally, although I hate the verbosity of `@JsonProperty`, I intensely dislike the idea of exposing parameter names as a public interface. I find that `@JsonProperty` and its ilk are much more robust to careless programmers' changes.
Nah. Have a look around. You are not the first that has to deal with this problem. The pattern is always something like this: main: val parser = new Parser(parser settings) val data = parser.parse(path to file file) Parser: parse: val bytes = read bytes from file val a, b, c = interpret(bytes) return new Data(a, b, c)
Trivial fix is to pass InputStream that can be used to read the content instead of a filename or a File instance.
I'll add an entry on this :).
Yeah. You are correct. From [oracle documentation](https://docs.oracle.com/javase/tutorial/reflect/member/methodparameterreflection.html): &gt;You can obtain the names of the formal parameters of any method or constructor with the method java.lang.reflect.Executable.getParameters". However, this feature then creates: &gt;&lt;...&gt; larger .class files, and the Java Virtual Machine (JVM) would use more memory. In addition, some parameter names, such as secret or password, may expose information about security-sensitive methods. I don't know how I feel about this. On one hand its very convenient. On another, Spring Boot's opinion is starting to be a little too intrusive. &amp;#x200B;
You are absolutely totally wrong here. C/C++ has a lot of undefined behaviour. https://sgros-students.blogspot.com/2017/01/vulnerabilities-in-cc-code.html Those do not exist in java (a buffer overrun in java generates an exception). That means every single mistake the programmer makes can end up in a security problem. Almost all viruses uses mistakes made by a c-programmer.
Looks quite useless. 
How do you expose entities to the "outside" world if not via dto/view class which is immutable?
In which language the JVM is currently (2019) implemented? What about my other remarks?
If you use this module and comply with all the preconditions listed [here](https://github.com/FasterXML/jackson-modules-java8/tree/master/parameter-names) you can even do without annotations! This enables you to have a true model class without any notion of JSON which Jackson should be able to (de)serialize properly. So no more DTOs!
It looks like in your [submission](https://www.reddit.com/r/java/comments/az2jf8/failed_to_execute_goalpackage_javaxpersistence/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
No, intertwining concerns is just clunky design, sweepingly and objectively. It's just a question of how much you can get away with. In small, private, inconsequential app/API, who cares? It works, you move on. But in larger projects you'll be paying taxes, if not immediatelly, then months after you've first written the code and want to change it. For example, imagine having 50 Appointment-like classes. All can build themselves up in ctor(File). First, it's lots of code. Second, it's unwieldy as soon as you start adding or changing features. New format? New ctor. 50x. Want to read from network stream? New ctor. 50x. Now make sure they all work, somehow. If you separate IO and application logic concerns, you get rid of this multiplication of work. Create those objects from an InputStream with a deserialization library like Jackson. Your application logic (the 50 classes) now doesn't care anymore where data came from and how. Change behavior of deserializator, change the InputStream, you've changed it for all 50 classes without touching them.
If you're asking about the performance behaviour, you're asking the wrong question. It is almost never the case that any micro-optimization whatsoever will have any observable impact on the actual performance of a real application. Remember that the JIT and other subsystems work better when they have more code to analyse. Microbenchmarks are a dangerous, irrelevant distraction for normal application programmers. &amp;#x200B;
Not really crazy about it, if I was code reviewing it I would question it. If there's additional boilerplating you need outside of just initializing fields I would implement a builder pattern or some kind of "initialize" method.
You should still never put IO in a constructor. If you need to read a file to initialise an object, then create a static method to do the IO part and pass the results to the constructor which can then remain pure. 
You have to be careful about using entity's passed from a controller and then persisting them to the database. https://rules.sonarsource.com/java/tag/spring/RSPEC-4684
If you step into the code with a debugger you'll see where the `StringBuilder` comes in. Also I recommend using Intellij IDEA. It has an inspection that recognizes the really problematic form of concatenation in a loop and can fix it for you with a single keystroke.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Even if the problem is offset one step back, making it an explicit parameter communicates the otherwise hidden requirement that a config file or provider must exist at runtime. For that reason it’s probably a good idea. Also, it’s up to the config provider function to decide if io is needed or not - maybe it’s cached from a prior invocation or maybe it’s just hard coded and in memory 
There are many implementations. One is in java (graalvm). One of the authors of hotspot (Cliff Click), mentioned that he would never implement it in C++ if he was doing it today. Nothing has changed fundamentally in 20 years (regarding safety). Java got bad reputation because of bugs in how applets were implemented. Applets are not used anymore.
If you're doing io in the constructor, you're binding your object init, and hence your class directly to that particular io. I'd prefer to abstract that into a separate factory or builder. Consider you create a Good based on some file data. If you bake it into the constructor, Foo knows lots of details about the filesystem. What if you then need to materialize a Foo from a db? Or a web services call?
Keep in mind that MicroProfile is a collection of microservices-related specifications that are implementation agnostic. Quarkus implements MicroProfile through [SmallRye](https://smallrye.io/), which is an open source implementation of MicroProfile specifications which have now been "Quarked" (integrates into Quarkus using its extension mechanism). As an open source project, any MicroProfile implementation can utilize SmallRye's spec implementations. As a MicroProfile co-founder, I take your point to heart. As a Red Hat employee, I do foresee taking what we learn from Quarkus and contribute back what the MicroProfile community deems applicable. To reiterate what Emmanuel said, we MicroProfilers don't want to try to bake innovation into specifications too early. Hope this helps give some perspective from both a MicroProfile community member and Red Hat employee.
&gt; our code is built by a Hudson continuous integration server using Maven Is this 2009 or 2019? Sorry, I couldn't help myself. You're fine and your comment is great. :)
We do really need this feedback, though. Even if things are not technically possible, this kind of feedback helps set our compass in the right direction.
You do not seem to understand that adding layers of complexity and abstraction in a certain system increases by default security flaws. Also, you do not mention that the current major Java implementation is certainly not graalvm, thus is not written in java (bootstrapped). The current java implementation is a C++ program. I could not care less about the opinion of one of the hotspot authors. The fact that he could not learn proper and safe C++ does not imply that I should use oracle jdk or openjdk instead of C++ (and its subset, C) with a dozen of other languages for most of my work (Perl, Python, Awk, Bash, and many more). Java was never a success in any area, beside maybe mobile development. But most mobile apps are not made in Java (except for android, but people are so much disgusted by java - by reason - that they wanted to swith to kotlin even in android). Good day to you.
Yup, thank you very much!
If you are one of the millions of active Java developers who are building enterprise-style applications (e.g. REST APIs talking to a database or streaming/reactive components talking to a message broker) then you save on memory and startup time, plus you can compile to a native executable for a further reduction in memory and startup time. These savings are notable in a cloud world where you pay for the slowness and extra memory with monthly Op-ex dollars. Also for when your application moves from simple GET/PUT/POST/DELETE to one of streams (websockets, Apache Kafka, AMQP, MQTT, etc) which can have bursty traffic patterns. 
See, you were able to use technical justifications with concrete examples to support your argument. And you did it without mentioning SRP once. &gt; No SOLID bullshit is needed when you know what you're doing. No amount of SOLID will help you if you don't. 
[jdk.java.net](https://jdk.java.net) only has versions from JDK 9. Azul (who I work for) provide a free binary distribution of our Zulu Community edition, available here: [https://www.azul.com/downloads/zulu/](https://www.azul.com/downloads/zulu/) &amp;#x200B;
A few days ago, [GraalVM](https://www.graalvm.org/) released a new version with some [Numpy support](http://www.graalvm.org/docs/release-notes/). Maybe Pandas also work? 
Azul (who I work for) provide a free binary distribution of our Zulu Community edition, available here: [https://www.azul.com/downloads/zulu/](https://www.azul.com/downloads/zulu/)
No it's ok, we're also still on Java 7. Government projects tend to be slow like that. But I see no reason my comments wouldn't still apply to newer technology. ʘ‿ʘ
It looks like in your [submission](https://www.reddit.com/r/java/comments/az5tv4/java_files_wont_open_exe_or_jar/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I think we're probably on the same page. I think each of the SOLID principles are good to learn, but more-so the why of them. For instance, in a code review, I probably wouldn't mention the Interface Segregation Principle, but I probably would say, "hey, I noticed you're throwing a lot of UnsupportedOperationException in this class. maybe we could split up its interface.". Or "design hasn't decided on how we're going to calculate scores, so lets just abstract that out and we can figure it out later". These are terrible examples, but that's just off the top of my head.
RAII - resource acquisition is initialization. Good modern practice dictates that a program shouldnt fail when its simply requesting memory, as if you catch an exception youre almost guaranteeing memory leaks that way. If something requires setup, its best to do lazy initialization which tracks the first time an object is utilized and does a first time setup under the hood
Java is the most popular language today (https://stackify.com/popular-programming-languages-2018/). There is no such thing as 'safe c++ or subset'. It has pointers and many insecure things. Just look at the changelog of any large c++-program (like chrome, linux etc). There are security-fixes every WEEK (going on forever). Cliff click is not exactly an amateur-programmer. Java:s libraries are implemented in java itself. That makes its safety really high. That is very different from python etc (where a mistake easily can be exploited from the net). If you want security/safety java is very good. There are some severe drawbacks with java (like *5 memory-consumption compared to non-gc-languages). Kotlin is very similar to java as it usually runs on the jvm.
 OpenPDF 1.2.11 released, with a fix for the signature wrapping attack. For details see [https://pdf-insecurity.org/](https://pdf-insecurity.org/). 
Most people don't actually learn the SOLID principles, they learn meaningless bastardizations of it. For example, nobody still believes that every class should be inheritable and only via inheritance should new methods be added. Yet we hear Open Closed Principle all the time. ISP doesn't have anything to do with Java style interfaces; it's a strategy for dealing with overly large C++ header files. Yet people keep parroting SOLID, using the exact same benefits that were attributed to the original meanings. At this point SOLID is just superstition, completely divorced from its original context and meaning. 
&gt; For instance, in a code review, I probably wouldn't mention the Interface Segregation Principle, but I probably would say, "hey, I noticed you're throwing a lot of UnsupportedOperationException in this class. maybe we could split up its interface.". Good, because that's LSP. (The only part of SOLID that's actually a principle.)
Without knowing the context you could not tell why it is not a perfect solution...
good point and definitely worth remembering, but i'd still rather handle those cases where that is possible than just blindly adding dtos in front of every single entity for the single case where it is a potential issue. You may often have apis where is never a problem and just doing all this duplication and copying is a waste of effort.
[Three months ago](https://www.reddit.com/r/java/comments/a1f0y7/openpdf_126_released/eaqggpc/) you were told to stop posting these here. Obviously, you have no interest to comply with this. As a consequence: good bye. You are **banned**
If you're doing io in the constructor, you're binding your object init, and hence your class directly to that particular io. I'd prefer to abstract that into a separate factory or builder. Consider you create a Good based on some file data. If you bake it into the constructor, Foo knows lots of details about the filesystem. What if you then need to materialize a Foo from a db? Or a web services call?
Devoxx Belgium Lamdas and Streams Masterclass I enjoy these two speakers and they touch on a lot of newer features. https://youtu.be/ePXnCezwRuw
Red Hat started this project and we hope to see numerous OSS contributors leverage Quarkus to bring even more frameworks/APIs into the mix https://quarkus.io/guides/extension-authors-guide
It looks promising. Are there any plans to add spring-boot or micronaut support? 
You may be interested in [Java Futures, Devoxx 2018 Edition](https://youtu.be/4r2Wg-TY7gU) and [FP vs OOP: Choose Two](https://youtu.be/HSk5fdKbd3o). Both are from Brian Goetz, Java Language Architect.
How low can you go? Ultra low latency Java in the real world - https://www.youtube.com/watch?v=BD9cRbxWQx8 Really great talk looking into what it takes to write fast Java. 
It's really annoying to test, you're better off just doing the I/O outside of it and passing the data into the constructor as a parameter.
You do not seem to understand that I do not care at all about "popularity" if there ought to be such a thing in a professional field, since even windows, arguably the worst operating system ever designed, is extremely popular. So what? It is backed by a huge corporation (just as java is). No technical or intellectual merit whatsoever, just marketing, and dollars to be made. Kotlin runs on the jvm, but it is a completely different language, with different semantics, and the rest. Are you talking about java, or the jvm? I think you are confusing between the two. That would not surprise me, given the level of ignorance and fanaticism and hype in this subreddit. Again, Stroustrup FAQs are a good start. http://www.stroustrup.com/bs_faq.html Of course Java has pointers. In fact, just about everything in Java is implicitly a pointer. They just call them references. There are advantages to having pointers implicit as well as disadvantages. Separately, there are advantages to having true local objects (as in C++) as well as disadvantages. C++’s choice to support stack-allocated local variables and true member variables of every type gives nice uniform semantics, supports the notion of value semantics well, gives compact layout and minimal access costs, and is the basis for C++’s support for general resource management. That’s major, and Java’s pervasive and implicit use of pointers (aka references) closes the door to all that. So you do not have a clue of what you are talking about at all, just about everyone who upvoted you and downvoted me. Nevertheless, I had a good laugh on you all. Greetings from Europe. Cheers.
Why should I care who you work for? I used to work for a IT consultancy firm that makes about 8 times the money that RH makes in a year. So what? Your comment just seems to be out of ignorance. If people were forced to switch to Go, why should they remain in java? Languages are just tools, you know. You do not have to remain in a single language for the rest of your life, lol. Even windows is popular. So what? It is trash. And it remains so. Java is a clear example of MOL (money-oriented-language). It is not platform independent; it is a platform. like MS Windows, it is a commercial proprietary platform (in the oracle jdk), backed by a commercial entity. That is not the case of ISO c++ or ISO C or other standard languages defined by a real committee and not a multinational. That is, you can write software for Java/JVM or C#/Intel and in both cases you are developing code for a single proprietary commercial platform, and you are writing code tweaked to the benefit of that corporation. There are standard and free (as in freedom also) languages to use, out there. Why being stuck with such underpowered and legacy (read= proprietary) tools? Unicuique suum.
lol gross
The Atlanta Java User's Group just finished their DevNexus this past week, which I believe is the second-largest annual Java conference in North America after JavaOne (maybe the largest one now if Oracle's new "Code One" doesn't count). There won't be anything up yet this soon, but in the past they've always posted the conference videos on YouTube some time afterward: https://www.youtube.com/channel/UCQweMZq2VAZqPisncB3ZgTw There were a few interesting sessions on migrating from Java 8 to 11, and optimizing/profiling/tuning applications. As with last year, the most recurring theme was severless-serverless-serverless. In fact, if you already have a passing familiarity with serverless, it's kind of a dud because there isn't much new to add to the hype cycle since last year. Unless somebody makes a serious challenge to Amazon, every one of those sessions either sounds like an AWS commercial... or else isn't relevant because it isn't talking about AWS. ¯\_(ツ)_/¯ However, the story last year was that you shouldn't use any major libraries or frameworks with serverless Java, because it adds too much bloat. This year there were a bit more options to discuss. The developers behind Grails presented a lot on their new [Micronaut](https://micronaut.io/) super-lightweight framework, which is sort of a Spring Boot clone that uses compile-time dependency injection rather than all the runtime reflection. As of course the Spring guys are already pivoting [to do the same thing with their stuff](https://github.com/spring-projects/spring-fu).
https://vimeo.com/javazone
The team is more focused on enhancing integration of standard like CDI, JTA and new new MicroProfile specs
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Short answer: reuse StringBuilder as dpash suggested. Long answer: if you are using IBR JRE, create new StringBuilder(a.length() + b.length() + 1) on each iteration and put result in keys with keys.add(new String(sb)); In this case, StringBuilder and String will share the same char array which will have exact size to hold the result, no memory wasted.
Java is popular because it is a nice environment to work in. I have 39 years of experience of programming (Java, C, C++, assembly, etc.) and i know what i am talking about. Kotlin is a language which can run without the JVM: https://kotlinlang.org/docs/reference/native-overview.html Java does not have pointers. It has references. Those can not be manipulated to point to invalid memory. Java also can allocate object on the stack (if it can proove the lifetime of the object). There is no special syntax for this. See here: https://dzone.com/articles/escape-analysis
I have x years of experience does tell me exactly nothing about you. How can I know how much good you are? Certainly, showing a x years of experience is not a valid benchmark to this. There are "IT" people who do "java" for a living since 20 years (since Sun JDK 1.0), and never seen even java 1.5, let alone 1.8 lambdas. I am skeptic about thinking you have a clue of what you are talking about actually --see my and your previous comments in this thread. If you are still advocating the fact that java has not arithmetic pointers but references compared to C (and its superset, c++), I think you should consider the option of learning to read other people replies. In my previous comment, you will find my opinion about the topic. Also, please note that C++ has evolved quite a bit from C++ 98. By now, you should know (2019) that up-to-date C++ programmers never use pointer arithmetic (or barely) since they relies on standard algorithms and containers; for instance, it is a mistake to use C arrays in C++ when you do have vectors which are flexible, safe, and just as fast. I think you should consider the options to educate yourself. Again, FAQs are a good start. http://www.stroustrup.com/bs_faq2.html#pointers-and-references Have a pleasant day.
Thank you, I'll keep an eye on the project! Hope to see a demo on the next redhat open source days
Sorry, but I have to tell you to stop **self promoting**. You are gravely exceeding the **reddit wide** tolerated **10%** of all contributions. You have next to no participation on reddit other than promoting your own stuff. This is unacceptable. Please, **read** and **follow** the [**reddit rules for self promotion and spam**](https://www.reddit.com/wiki/selfpromotion). Reddit is neither a blogging, nor a self promotion platform. Should you continue to self promote you will face a permanent and irrevocable ban from here. **Removed**
&gt;Developer joy How is this different, if at all, from something like jrebel? Does it recompile in container? Is AoT significantly slower than JIT for long lived microservices. Is this targeted primarily at FaaS workloads? Does this work cross platform (ARM)? With native images? How does this differ from the sum of its parts? Is it purely AoT + Docker + Vertx +... or is there some custom Quarkus bit that makes it a value add? Thanks. 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Java lacks pointer-arithmetics (which saves it from unsafe code): https://stackoverflow.com/questions/1750106/how-can-i-use-pointers-in-java You can call it pointer or references if you wan't. In C/C++ there are many ways to crash the program (undefined behaviour). That is not possible in Java. I am perfectly aware that there are more modern ways to program in C++ today. The language however cannot remove it's unsafe history (without major changes). The problem is solved in Rust where unsafe code is a compilation-error. I can't see anything wrong i have said in this thread.
As a general recommendation, though often his talks can be quite long, I have to recommend anything by Venkat Subramanium. Some people arent the biggest fan of his accent, but the content is always top notch
The very fact that you call something "C/C++" as if it was the same thing says it all. I am not interested anymore in teaching you how these languages do actually work, as I would need a couple of weeks at least, apparently. Rust could start from zero, hence with no backwards compatibility it would have been very hard to design a language that was (in appearance) worse than C++ (that, in turn, had to be compatible with billions of line of code of its (it is spelled its, not it's) ancestor / subset, which is C, which, yes, was primitive indeed, and also relatively low level, although it is a high level language). Please note that hundreds of major safety critical systems (from jet turbines to the mars rover to all the java projects which are naturally implemented in the jvm which is nothing but a c++ program) are deployed in c++. The same cannot be said in rust, at least for now (2019). So, millions of people have become sufficiently competent c++ programmers; they are the ones that let you browse this webpage (most browsers are written in c++, as well as the critical network infrastructure that underlies them all), and let you do your daily routines without even noticing. If they could, why should you remain a lame java programmer? You can write good c++ too, perhaps. And you could use a plethora of other languages, to accomplish your tasks. Java on the contrary is not strictly needed for anything that I know of. As C# is not also. Please refrain from filling my inbox with further comments. Have a pleasant day.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [Spring DevTools with Jib and IntelliJ IDEA \[x-post from r\/java\]](https://www.reddit.com/r/programming/comments/azhpmx/spring_devtools_with_jib_and_intellij_idea_xpost/) - [/r/springsource] [Spring DevTools with Jib and IntelliJ IDEA \[x-post from r\/java\]](https://www.reddit.com/r/springsource/comments/azhpge/spring_devtools_with_jib_and_intellij_idea_xpost/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
You don't have to teach me anything i already know. Rust was invented by mozilla and is used in their browser. It was done only to prevent all safety-bugs that C++ could not prevent. It is a big success (no such bugs and no performance-loss). I have written lots of code in C++ (I prefer Java as it is much more productive). Java runs many webservers (very popular if you need high security like banks). I also use java to run on microcontrollers (with 32 KRam) and on the browser (using GWT).
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I'm a little late to this, but want to offer my opinion. I think the primary way you should be grading these exams is the same way professionals *should be* "grading" their work, using automated tools like SonarQube, checkstyle, spotbugs, but most importantly automated tests. This not only easier for you as a teacher but introduces your students to the importance of using automation. Automation, beyond saving man hours, has two other very valuable qualities, repeatability and audibility. Repeatability allows students to experiment. If a make this change, how will that change my "grade"? Audibility allows students to view exactly why they are getting their "grade". However there is a potential problem here. What if students; don't put asserts in their tests, skip tests, or don't properly test some sections of code? This is where [mutation testing](https://en.wikipedia.org/wiki/Mutation_testing) comes in. In short mutation testing is a tool that will make modifications to (byte)code, for example turning a == to a !=, and checking to see if a test fails. If a test fails that means the mutation "dies" if no test fails the mutation lives and means that code isn't being properly tested. I would recommend using [pitest](http://pitest.org/). It's been a minute since I last used it, but remembering being pretty simple to use as well as customizable. I know implementing this would be trivial, but I would highly highly highly recommend using automated testing, and tools like SonarQube, checktyle, et al.. The lessons students will learn from using these tools and techniques will be invaluable to them in their careers. 
It looks like in your [submission](https://www.reddit.com/r/java/comments/azkp0y/while_loop_project/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I haven't actually thought about THEM using it, it's actually a really good point and I will consider it. Thanks! 
DevTools caused some pretty hard to track down classloader issues for us, took me a while to work out what it was (can't really remember the details now). Anyway it seemed to pretty much always restart our spring boot APIs anyway so no big loss
Very useful! Thank you for sharing.
The [Javadoc documentation for this constructor](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html#%3Cinit%3E(java.lang.String)) explains, "Unless an explicit copy of `original` is needed, use of this constructor is unnecessary since `String`s are immutable." I cannot recall a time I've needed to use the `String` constructor that excepts a `String`, but there is [discussion on this on StackOverflow](https://stackoverflow.com/questions/390703/what-is-the-purpose-of-the-expression-new-string-in-java/390854#390854).
watched this on 2 speed. its great. thanks for sharing
You definitely should! Automation and specifically automated testing are severely under-appreciated in our field at-large. And if it wasn't entirely clear, with pitest you don't have to also write stubbed out automated tests for your students and/or force students to write their application in a way that strictly conforms to how you wrote your tests. Which is good because it forces students to learn/encourages creativity. You should be able to with SonarQube and pitest (or possibly even pitest alone) define rules that say you must have X% code coverage and pitest can actually validate students *really are* testing their code. Not going to hand-waive that this will be easy or trivial to implement. But it should definitely be possible and it will reduce your work around grading tests while also teaching students and extremely valuable skill (sorry, if I sound insistent, just automation and automated testing are two of my big passions).
Yet another option: `String blabla = String.valueOf("blabla")`
It looks like in your [submission](https://www.reddit.com/r/java/comments/azlvmw/stuck_on_battleship_problems/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Thank you for these
Thanks for this. 
Great thank you
Thank you for taking the time to write this up
Wow there are a lot listed there! Thanks 
Ah yes I believe I have watched some of his in the past. I will seek them out again, thanks 
You’re welcome!
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Huh DC.5 DC.6 I didn't even know those other ConcurrentMaps existed I've always used ConcurrentHashMap
Is there somewhere I can see this compared to Spring? I can't find anything on the web on an initial search. 
Good point, I couldn't build with \`--enable-headless-only\` when I tried. I assume it's not supported on mac?
Effective Java by Joshua Bloch 
There's Spark, Spring-boot, good ol` Java EE (Jarkarta EE), and more frameworks that all ultimately can do the same thing. Why would I want to use Spincast over the previously mentioned? 
&gt; Please consider the option of educating yourself if you are planning to have a career in the field of computing. Stroustrup's FAQs are a good start. Well, I do have a Ph.D in CS and if there's anything I learned. It is that anyone who says X is better than Y as a unqualified statement is most certainly wrong. Things simple aren't that simple depending on what it is your are most iterested in optimising sometimes X &gt; Y and sometimes Y &gt; X. If there's a zealout here, it is you. I don't beleave Java better than C++ and I also don't beleave C++ is better than Java. Only zealouts beleave their language of choice is the best, no matter what, and anybody who says otherwise is stupid, wrong etc.
A better way to do this would be to move jib to a ```prod``` profile and make your ```dev``` profile the default. That's pretty much the _standard_ (for whatever that word is worth this day and age) way of handling that. (that i've seen anyway)
I agree. If deployment should fail if the file is missing or not parsable then finding out earlier saves time.
Codewars and exercism.io where you do you problems and compare solutions with others might get you in the loop for any cool solutions out there for simple toy problems. Design patterns haven’t really changed. Maybe concurrency patterns have changed significantly? Refreshing yourself on promises/futures might be a good idea. 
the limitation is obvious，but is fantastic.
Third edition.
I never said that C++ is a better language than java whatsoever, but just that modern good C++ code is generally a better choice than writing good java code. Also, the current java major implementation (2019 jvm) is nothing but a C++ program. And that is a fact. I do not care which are your proclaimed qualifications, since you could tell anything and we do not know each other. Please consider the option of actually learning to read.
Of course, java can also run without a virtual machine. There are implementations that force the language to behave in such a way. But it was not designed so. &amp;#x200B; An java was not designed to solve any problem at all. Java was designed just to give Sun money by locking programmers with a proprietary platform and environment. And now that Sun does not exist anymore, it is Oracle that makes money off of this non-ISO, proprietary, language. Most serious big banks use C++ for their infrastructure systems and for HFT, naturally. But this does not say much about whether c++ is "better" than java, or not. I just wanted to correct your inaccuracies. Why on earth would you be more productive in java compared to C++? Is perhaps because you have a huge pre-chewed library? You should definitely start to learning to program, then. That means, write your own algorithms, not copy-paste code like all the java and c# monkeys who are out there. I am not saying that all java programmers are stupid programmers (although most of them are): for instance, Gosling is a great person and a good computer scientist, the only flaw is that he wanted to make money from something that Ritchie and Stroustrup wanted to give us for free (and ISO - standardize also). Stick to openjdk if you have nothing better to use. But fortunately there are better alternatives. Also you should consider the option of learning to read. I commented the rust background compared to C++ earlier. Bye.
and that says a lot about java lol
I be to disagree: I want the default to be no profile, so that it eases the work of the Ops team. Otherwise, there's a high probability that it will be forgotten during the deployment process. And no, even automated deployment tools won't fix that because they will get re-written, re-configured, re-migrated, re-whatever... and it's going to take a while to understand where the issue is.
OP has completely missed lambdas, which has radically altered how we write Java.
Especially when the realworld example looks like this: https://github.com/spincast/spincast-realworld/blob/master/src/main/java/org/spincast/realworld/controllers/ArticleController.java
Good God, burn it with fire
in my experience there is a higher likely hood of a young engineer on the team running default profile pointing to prod resources and screwing something up than there is an ops person causing problems. If your going to have a problematic run wouldn’t you rather it be an important server fails to connect because the resources are mocked instead of a local dev machine connecting to important resources? I actually never use default profile. My application.yaml has `spring.profiles.active: local` to make it pretty explicit what a thoughtless pull and run will do 
Thanks for taking a look!
There's a new project that's trying to bridge the two worlds pydatavec: [https://github.com/deeplearning4j/pydatavec](https://github.com/deeplearning4j/pydatavec) 
https://github.com/leventov/java-concurrency-checklist#safe-local-dcl &gt; The above code could be fixed as follows: &gt; void cleanup() { &gt; MyClass lazilyInitialized = this.lazilyInitializedField; &gt; if (lazilyInitialized != null) { &gt; lazilyInitialized.close(); &gt; } &gt; } That is surely a fix to the NPE, but is that really a fix? I think there is no guararantee that a thread might see that non volatile field to make that local assignment in the first place, thus the if block might never be entered by another thread. 
I have a different experience. In most real-world organizations, production profiles are not available to developers, exactly for the reason you mention (junior developer screwing things up in production). Plus, in the case they are, firewall rules prevent them to be accessed directly. From our exchange, I think you're more oriented toward being dev-friendly while I'm more concerned about being ops-friendly.
You could make the default be too deal with a prompt requiring a specific profile if you are worried your ops team won't remember it
Your perception of 'most real world organizations' is incorrect in my experience. The modern pattern is to not have an ops team and to operate in a "you build it you run it" model. Your automated test suite for your CD pipeline should be able to easily detect "the app isn't running" or "the app is running in the wrong environment" before it ever even gets actual traffic
Streams and Lambda expressions are the new big thing so that might be a good place to start. I can’t think of much else that changed significantly. I wish I had better references for books but the internet has its usual plethora of tutorials.
There are rare cases where I needed this, many years ago. Disclaimer: I'm pretty sure regex and string don't work like this any more. The situation (iirc) was that a user was was reading a file into a string, extracting a small portion using a regex, then continuing that process with many other files. This would eat memory because the regex engine would give you results that pointed into the original, large string. (In many cases this is ideal, but not this one) The string constructor guarantees a *copy*, so doing `String result = new String(matchedBit);` would ensure we lost the reference to the original.
I get the idea of making most structures immutable, but is there a java programmer out there who doesn’t know that final data structures *are* mutable?
Unfortunately, yes. I'm interviewing quite a few people as part of my job, and, as mentioned in the article, a surprising number of people don't know about this, hence the motivation to write this. Then again, people who don't know this most likely also won't read blogposts. Oh well :-) 
I have seen beginners assume that final local vars are something special. Because just preventing reassigning local variables seems (and probably is^(1)) relatively useless, beginners often assume that it does something more and may assume that is does something like `const` in C++. ^1) It's not really bad, but it adds an additional keyword/boilerplate and the benefits aren't that obvious to beginners at least.
&gt; most likely also won't read blogposts I would say quite the opposite. There is a very low signal to noise ratio in the self aggrandizing blogosphere. Also you may not realize this but we hear this constantly on reddit. But none of the "mutability is bad, Mkay" crowd seems to realize it is just another tradeoff.
I agree, but I think the underlying issue is that many devs don't understand the concept of immutability.
Let's agree to disagree on that. That might be true in Silicon Valley, but not here in Europe. Most organizations are still doing waterfall, monoliths and year-long project planning.
I'm not in silicon valley, but am in the US.. Nobody here uses waterfall anymore, and haven't for years. 
Hence, blogpost. I'm trying to explain to people, but also to myself, what benefits of immutability vs mutable code is.
Well, I hope I contributed to a more neutral or balanced view. If I haven't, please let me know, and I'll change my writing style! 
I guess it was the "Then again, people who don't know this most likely also won't read blogposts" part when 99% of them are just crap assertions by attention whores. I did take a look, and yes, you are not dogmatic about it, and I appreciate that, but I don't read blogposts much anymore, after encountering so much crap. And if the title is clickbait, I put it in the crap pile, fyi. People who know this, don't need to read your blog too. So it seems a little cheap to bait new readers that way.
Or just don't want to use it, because it is "easier" to work mutable objects.
Thanks for that. Regarding the title: "Immutable data structures in Java" is exactly what it's about, instead of 'you won't believe what most Java developers don't know about ....' Nobody would read that. I hope. 
well, my expectations (life is short, I use patterns on occasion) after seeing countless "purity" evangelists, was that this was going to be more of the same. Just a perception fyi. Glad to see someone being pragmatic about it.
&gt; Because just preventing reassigning local variables seems (and probably is1) relatively useless If you're passing a lambda which has a reference to a locally scoped variable, that variable will need to be final so it can't be changed from under the feet of the lambda.
Yea, streams and lambdas! You got me. Although if OP did codewars, usually at least one of the top answers is a concise stream/lambda solution. I was hoping they’d get inspired there. 
From a language semantics point of view, it's a somewhat arbitrary decision. Other languages (e.g., Kotlin) don't have that restriction. But since we're talking about Java here, yeah, this is correct.
Multiline strings were removed from jdk12 and you're asking for operator overloading...
Brian Goetz discusses operator overloading [here](https://www.youtube.com/watch?v=jDU-JALUDd0&amp;t=23m45s). He agrees that operator overloading would be nice, but only in the context of numeric types. This is something they will eventually explore in [Project Valhalla](https://openjdk.java.net/projects/valhalla/).
Ive been working with Java for 5 years and didn’t really ever think about it until I started using lambdas in the past year or so. It just didn’t matter since we almost never use final. I probably would’ve failed this interview question a year ago, just from not encountering it before.
The last discussion about this on openjdk seems to be from 2011 https://bugs.openjdk.java.net/browse/JDK-4905919?jql=text%20~%20%22operator%20overloading%22 Personally, I think it's unlikely to be added. Are you familiar with Scala? It has all those operators on their collections, like ++, +:, /+, :+, ::, :\, ::: . It is not immediately clear, what operators do on any class. They basically add another DSL you have to learn. With methods, you have (hopefully) a descriptive name that tells you what it does. http://www.lihaoyi.com/post/StrategicScalaStyleConcisenessNames.html#when-to-use-operators So, it's not really a disadvantage, that you can't overload them.
OK, I get it, it may be a tad tricky. We at my company do something similar during interviews. We ask the applicant to spot the errors in a bit of code, and one of them is using a variable outside the block it was declared, but a couple lines after the declaration. Most people fails that one, but most also acknowledge that they never had to really think about it while writing code.
/r/javahelp /r/netbeans 
Let's dig a bit deeper. If you don't do waterfall, you are probably using some sort of Agile. From my understanding, Agile makes it so that the product owner is co-located with the team (for non-remote teams). I've never seen that. I've seen business analysts being sometimes co-located with the team, but they were not POs. In Agile, the PO chooses at every sprint what features the team will work on. When he/she considers it has enough bangs for his/her bucks, he/she will call it quits. I've never seen that, because of capacity planning - imagine that: all those highly paid developers not actually doing anything because the end of the project was not planned. I could (unfortunately) go _ad nauseam_. So either Europe is very late regarding Agile - which I'm very well prepared to hear, or you've only worked for the few companies that actually do what they preach. Given that those examples do not originate from technical reasons, but from organizational reasons, and I don't really think American companies are more advanced than European ones in this regard, I'd tend to favor the second hypothesis (or another one I didn't think of).
Next time, please post in the appropriate subreddit. This problem is *Netbeans* related, so it should be in **/r/netbeans**. Were it *Java programming* related, it should be in **/r/javahelp**. **Removed**
Ugh maybe I need to learn kotlin then. I use for-each over .forEach a lot over this
&gt; When an object is immutable, it’s hard to have the object in an invalid state. Hold my beer
It doesn't need to be marked final though. Effectively final is good enough ie. the variable isn't changed even if it isn't marked as final.
&gt; Today Java no longer makes use of green threads: they switched to native ones back in 2000 I think they [switching again](https://youtu.be/eOWsEHibxbU?t=1292) ;)
`System.out &lt;&lt; "Hello" &lt;&lt; System.lineSeparator();`
Yes, we do have product owners colocated with the team. They manage the priority of the backlog. In our case, we actually deliver our software (to production) pretty much on every commit that passes our test suites (not just in releases at the end of a sprint). We often separate delivery from release using feature toggles that are generally short-lived - (once a feature is released and is not going to be rolled back for some reason we remove them from our code) - using something like togglz or more recently, LaunchDarkly When we do development we tend to have high level ideas of what will be done for the upcoming quarter (with an even higher level idea of the direction we believe we will head for multiple quarters) and then each sprint within a quarter is working away at the stories that compose those features / epics ... But the biggest difference between agile and waterfall is that in our approach we are constantly trying to figure out ways to incrementally ship working software that provides value to someone - and we also try to get feedback on what would be the next valuable thing to iterate on... The goal is to prevent waste caused by overbuilding or building something that isn't actually valuable. (But you are probably familiar enough with agile to understand the main driving principles of it)
With reflection, you can make 5 + 5 equal to 8. That doesn't really count.
I don't think you can overload operators with reflection maybe I'm wrong?
I wasn't 100% honest, you need to abuse boxed classes: public static void main(String[] args) throws IllegalAccessException, NoSuchFieldException { Field field = Integer.class.getDeclaredField("value"); field.setAccessible(true); field.setInt(5, 4); Integer five = 5; System.out.println("5+5 = " + (five + five)); }
This is one of the best/worst things I've ever seen. I've never even considered using refelection on core classes like that!
I'm glad I learned it. I still write new Java code but Kotlin is generally my go-to language these days.
Immutability in Java 101 &amp;#x200B; `public class MyClass {` `public static class Bar {` `private final String text;` `private final Foo foo;` `public Bar(String text, Foo foo) {` `this.text = text;` `this.foo` `= foo;` `}` `public String getText() { return foo.getText(); }` `public Foo getFoo() { return foo; }` `}` `public static class Foo {` `private String text;` `public Foo(String text) {` `this.text = text;` `}` `public String getText() { return text; }` `public void setText(String text) { this.text = text; }` `}` `public static void main(String args[]) {` `Foo foo = new Foo("I am mutable and I am happy with that.");` `Bar bar = new Bar("Look, I am IMMUTABLE! Feels good!", foo);` `foo.setText("No, now you are mutable too, dude!");` `System.out.println(bar.getText());` `}` `}` &amp;#x200B;
&gt; Edit: hold up does Integer have a value map all the way up to INTEGER.MAX_VALUE? No, only the integers between -128 and 127 are cached by default. This trick wouldn't have worked with a number outside that range.
Huh...I'm gonna have to hit up the openjdk source to see how that works
In C++, `final` is called top-level const. But many people think `final` is low-level const. 
Once you use reflection, all bets are off. However, if you start reflecting an immutable that I’m using as a hashmap key and things break, then that’s the person who is doing reflection at fault - not the library writer. 
[2 + 2 = 5](https://codegolf.stackexchange.com/a/28818) from code golf Stack Exchange. No operator overload needed. 
Yeah he showed me...I hadn't considered using reflection on system classes
This, combined with misplaced trust in autoboxing, leads to code like this: &amp;#x200B; Integer first = 5; Integer second = 5; if (first == second) { // do something } &amp;#x200B; Which works perfectly reasonably right up until either value is outside that -128, 127 range and then fails very confusingly.
This is a different solution and impacts integer literals. The code ends with: System.out.printf(“%d”, 2 + 2); The code on ideone: https://ideone.com/o1h0hR
They don't pay $5 an article and certainly neither do they pay an average $80 like the owner claims (lol). **but** they do pay at a rate that computes at about $2/h or less. This is how it works: you get paid for the article and they are basically **huge scumbags** when it comes to accepting the article. They'll make you spend countless hours on endless reviews. So imagine the quality of courses written by people willing to work for 1 or 2 bucks an hour.
Definitely no. Baeldung is just a very low-quality content farm that happens to rank well with google's algorithm.
final and const (in C++) are completely different concepts. final follows a class declaration, to prevent any other class inheriting from it. const has a few different uses, but the common case is making a variable immutable and limiting the the API of a const class object type to only the member functions declared as const. 
this is really pathetic, now he is paying to shill for his site.
You're absolutely right. But here I am just talking about the difference between `final` and `const` when applied to a local variable, not about the general difference between `final` and `const` keyword.
&gt; Final references don’t make objects immutable Non-empty arrays are good example. Even JavaFX developers [made that mistake](https://openjfx.io/javadoc/11/javafx.graphics/javafx/scene/input/TransferMode.html#ANY) in public API ;)
Fixed in java 7u6. https://bugs.java.com/bugdatabase/view_bug.do?bug_id=4513622 https://javarevisited.blogspot.com/2011/10/how-substring-in-java-works.html I used to be able to pull up java 6 string code and compare it side by side with java 7 on grepcode... but not anymore. 
This only holds for older versions of Java. You can no longer access non-public fields/methods in java.base without JVM settings &amp;#x200B;
Yuck `if(address.getCountry().equals("Australia") == false)` Should be `if(!address.getCountry().equals("Australia"))`
Be this, it should: `if(!"Australia".equals(address.getCountry())`
Minor nit: I'd suggest to make the members in `Person` and `Address` final, not the least to ensure safe publication to other threads. Also the `addresses` collection might be wrapped into the unmodifiable one in the constructor instead of each time when invoking `getAddresses()`. Lastly, depending on how/where `Person` is instantiated, a mutable reference to the addresses list might still escape / retained by the caller. So to make it truly immutable after instantiation, a new collection would have to be instantiated in the constructor.
Oh Christ please no. From my experience with C++, this will be abused. There are very few situations where operator overloading is suitable. The results are lines where magical things happen without obvious signs that custom methods are being called. Java is better for not having them.
Sure. Or avoid hardcoding current country. `if(!getCurrentCountry().equals(address.getCountry())` 
&gt; So to make it truly immutable after instantiation, a new collection would have to be instantiated in the constructor. I agree. Example code: List&lt;Address&gt; addresses = new ArrayList&lt;&gt;(); addresses.add(new Address("Sydney", "Australia")); final Person person = new Person("John", addresses); System.out.println(person.getAddresses().size()); // prints "1" addresses.add(new Address("Melbourne", "Australia")); System.out.println(person.getAddresses().size()); // prints "2" Fix in constructor: public Person(String name, List&lt;Address&gt; addresses) { this.name = name; this.addresses = Collections.unmodifiableList(new ArrayList&lt;&gt;(addresses)); }
Surely, this has been discussed (and obviously rejected and/or postponed) many times. Try it if you want...
I thought this constraint was annoying until I wrote some JavaScript, which doesn't require finality, and spent hours debugging it.
Tried my luck here: https://mail.openjdk.java.net/pipermail/core-libs-dev/2019-March/058900.html
I realize I may be in the minority, but I find this one of the ugliest features of c++... 
I’m sure. I highly doubt it would be a top priority at this point, but maybe one day.
How is this compared to jenv?
While I would LOVE operator overload in principle, this is a perfect example of why I think operator overloading MUST NEVER BE ALLOWED. &amp;#x200B;
Yeah, I wonder why they choose this operator for standard IO. It smells like "junior developer learns a new skill and wants to use it in situations where it they are not useful"
C++ has a comma operator that you overload. Because no one ever suspects a comma is going to do magic.
That's probably for the best. `forEach()` should probably only use method references. `Sysyem.out::println` is the usual method I use. If you find yourself reaching for `forEach` you're probably doing some side effect and not using a functional approach.
And Java uses the same word in multiple contexts.
`java.time.*` FTW. Seriously, just stop using `java.util.Date`.
This was introduced in Java 8, prior to this they had to be explicitly final (for anon classes). It's a welcome change.
The upper bound can be increased (but not decreased) in OpenJDK with a command line flag, but the lower bound can not. The defaults are defined in the JLS as a minimum range.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Given the lack of frequent country changes, an enum is not an unreasonable decision in a project that's going to be frequently deployed. I think there's only been four major changes over the last decade: * South Sudan * Eswatini * Czechia * North Macedonia Let me know if I've forgotten any, but we're still looking at most, on average, once a year. If you're not frequently deploying a project this might be the wrong approach.
Sort of my impression of what happened with scala. They were nice to have, but then scala people took them to extremes where you'd have things like &lt;&lt;-&gt;&gt; defined because it looks neat. That became somewhat of a standard practice which really hosed scala readability.
Honestly, what I really want is for the JDK to have more math like libs and for them to overload operators internally on their own numeric types. I do not want to be able to overload myself, I just want to be able to say \`BigInteger bob = tim + 1;\` Similar to how we have String s = "fish" + 1... only not so insane. I don't generally advocate for the JDK to increase it's API size, but it would be really nice for it to have more Math capabilities (like a Matrix, for example)
I did not mean that errors in Linux are because of C++. I mean that the same kind of problems occurs in both languages. I don't think Sun or Oracle has earned a lot of money with Java. Oracle earns most from it's database. Banks use Java a lot. Not fun to use a platform which can be hacked. In C++ the tooling is a joke compared to Java. Have you tried IntelliJ. The IDE can parse the language fully for autocompletion etc. That is not so easy in C++ because of macros. Build-times in C++ is also horrible (try compiling Chrome). We talk hours, not minutes. C++ lacks a large amount of libraries of high quality.
&gt; C++ code is generally a better choice than writing good java code What about all the security problems caused by buffer under and overflows? You can't get those in Java. C++ is a relic that just doesn't protect the user of the language in anyway from making buggy code that reads/writes outside the bounds of their own arrays, corrupts the memory and opens up the program to all kinds of security vulnerabilities allow attacker to execute arbitrary code. &gt; I am not an english native speaker Neither am I. &gt; so you are not excused for your ignorance Oh dear lord, this is reddit post. Not doctoral thesis. Typos happen and I don't care to really proofread it a hundred times. Why do you have to fill your post with insults all the time. Anyhow. Good day to you Sir. I won't be responding any further to your insults after this. It is clear you are nothing but a troll. And your staunch defense of C++ shows you aren't exactly up on the latest developments in programming languages either. Take a look at Rust for a more modern alternative.
Making the fields `final` in the immutable class is still required to ensure safe publication in a multi-threaded environment. Also see the concurrency section of https://javachannel.org/posts/immutability-in-java/ for this
C++17 is way more modern than Java. Take a look at concepts, and at generic programming. Java generics are just a naive attempt to try to replicate that. Also, the fact that the current major java implementation is nothing but a C++ program refutes everything that you wrote in your previous comment. &gt; Java. C++ is a relic that just doesn't protect the user of the language in anyway from making buggy code that reads/writes outside the bounds of their own arrays, corrupts the memory and opens up the program to all kinds of security vulnerabilities allowing an attacker to execute arbitrary code. You are not excused if you can't use the language. Only a poor craftsman blames his tools. I blame java for being nothing useful for the computing community, aside for novice programmers, maybe.
IDEs? Burn these things with fire. You have no clue of what you are talking about. How many minutes would chrome take to compile and run if it was written in Java? Oh wait, only a fool could write such a supposed-performance-based program in a compiled/interpreted language that runs on a virtual machine.
The two share "env "in their names, yet serve two entirely different purposes. jEnv manages multiple "java environments" e.g. java 8, java 11, etc and allows you to switch between them seamlessly &amp;#x200B; java-dotenv helps manage a "java application's configuration" and does so in accordance in with [12 Factor tenet II Config](https://12factor.net/config)
With C++ compilation time is not of O(N) complexity (more like O(N^2) (where n is number of lines). It is because of parsing header-files + preprocessor cannot easily be optimized. Java compiles everthing in a single-pass. Java can also hotreload (instant reload of modified code). Read more about the problem here: https://news.ycombinator.com/item?id=14734171 If it was in java it would compile MUCH faster. Take any large java-program like graalvm and try yourself. A Chrome in Java would occupy much more RAM however...
One thing I really love about Spring Boot is its configuration support with multiple profiles and the ability to override everything using java properties or environment variables. Makes it very easy to create docker images where you have external configuration, because the docker env values override the application.properties file in the jar. This sounds like this does exactly the same thing but for non-Boot applications.
Doesn't storing env variables in the app itself present a security risk? Like, does this not defeat the purpose of env variables in the first place?
How does it compare to [MicroProfile Config](https://github.com/eclipse/microprofile-config)?
It looks like you need to create a different string in every iteration. In this case, there's no need to create a StringBuilder manually. Remember, the Java compiler and runtime will always try to optimize string concatenations(*), but the compiler only looks at **one expression at a time**, so every + concatenation (or group concatenations, as in "x"+"y"+"z") will have its own StringBuilder (and that's OK in your case). The main benefit of creating your own StringBuilder manually is that you can reuse it to build a String in multiple steps. That's a huge performance gain because you avoid creating an always growing pile of garbage Strings in every iteration (concat some strings, throw away the old ones, concat again, throw away again, and so on). (*) in the past with a StringBuffer; in Java &gt;= 5 with a StringBuilder and in the most recent versions using specialized code with invokedynamic
exactly.
dotenv is compatible with the best practice you are eluding to. It encourages the use of environment vars and provides a mechanism to manage them more easily. it always treats the actual host environment as the authority. java-dotenv is a java port of the original ruby lib. it's fairly ubiquitous across languages e.g. javascript/[node](https://github.com/motdotla/dotenv), [python](https://github.com/theskumar/python-dotenv), c#/[.net](https://github.com/tonerdo/dotnet-env), [ruby](https://github.com/bkeepers/dotenv) [go](https://github.com/joho/godotenv), and more
Where do you suggest one store them? Nearly every project I work on stores variables in the tomcat environment it runs in / inside the dev environment of each developer. This allows a user to have different settings in a test environment that does not propagate into staging and prod. How would this project, which seems like a good idea, store per environment (rather than per repo) variables? &amp;#x200B;
Wow, good spot, thanks for that. I've updated the article accordingly.
I find the ! so hard to miss, that I rather go for == false. IntelliJ doesn't like it either, so you're not alone in this ;-)
I'll hold your beer, and while holding it, I updated the code. Those fields are final now too.
You don't need the unmodifiable wrapper in the constructor as long as you do it in the getter. Where you do it depends on how much you trust yourself to not modify the list by mistake.
I envy you, it seems very close to the principles I've read about... and never seen in practice where I worked!
For ever example of useful operator overloading you can find 100,000 terrible ones. (Literally every single instance in the C++ code base at my work. Why overload a factory class's + operator for strings? To log to the current internal state of the factory to a file at the file path denoted by the string of course! And then return a Boolean to signal if the logging threw any errors... .... .. .... ..) And for every example of useful operator overloading you can define a well named method which does exactly the same thing. So what if your matrix class can't overload +, you can define a .plus() method. Most of the time you probably wouldn't even write the entire method name, instead doing an auto complete after a character or two.
It looks like in your [submission](https://www.reddit.com/r/java/comments/azz3yi/sr_software_engineer_role_at_sf_ai_company/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
This project seems to intentionally not support profiles. In which case, I suggest having an `env.example` in your repo (without any sensitive data) that explains the changes each developer should need to make. You'd also add `.env` to `.gitignore`. When it comes to deployment you'd ship the `.env` alongside the deployment artifacts. (Or in the case of Docker image, you'd use Docker environment variables)
It looks like in your [submission](https://www.reddit.com/r/java/comments/azzcgb/program_to_enter_n_positive_integers_and_negatives/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
It looks like in your [submission](https://www.reddit.com/r/java/comments/azzqjl/anyone_one_know_the_best_way_to_learn_more/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Lot off people doors not understand this. Buy to thier defense, you rarely need to think about it with OO. As FP is becoming more popular, those started to become more relevant. Please check out this blog post on an easy way to make immutable data object in Java https://nawaman.net/blog/2019-03-11 . :-)
Nobody, including IntelliJ likes this. You are literally the only one. 
&gt; Effective Java by Joshua Bloch Published in 2001! Yea, I know there is now a 3rd edition, but I still would recommend something more like "Java in a Nutshell (7th edition)" which will cover a lot more material.
Good article. I like to ask where 'final' can be used in interviews (it's like 'const' in C++... damn near everywhere!) and while many candidates know it can be used for a field they often don't know it's just reference immutability. FWIW I like to do the \`Collections.unmodifiableList\` bit in the constructor instead of the accessor\[1\], as (1) it's more intention-revealing (IMO) and it avoids the (probably not-worth-optimizing-anyway-but-oh-well) creation of a new object for every call to the accessor. \[1\] On a separate-but-related note, mutators are evil but accessors are mighty damn sketchy.
Thanks, I've opened an issue [https://github.com/code-review-checklists/java-concurrency/issues/1](https://github.com/code-review-checklists/java-concurrency/issues/1). However note that adding volatile to the field doesn't fix the visibility issue; cleanup() can miss any concurrent initialization happily as well. It really reveals that lazy initialization without a happens-before edge with cleanup-like methods is always broken, regardless whether the field is volatile or not. &amp;#x200B;
why is it called java-dotenv instead of kotlin-dotenv?
I agree, it can be easy to miss the single ! character.
&gt;For ever example of useful operator overloading you can find 100,000 terrible ones. For every example of useful operator overloading, I'd have one more than I do now. I mean, I get it, it can be abused. But it can also be done right, and honestly, I'd rather have it with the potential for abuse than not. I'm sick of `.add()` and `.minus()`. &gt; Most of the time you probably wouldn't even write the entire method name For me it's more about reading than writing. Given Fraction a = new Fraction(1, 2); Fraction b = new Fraction(3, 4); Fraction c = new Fraction(5, 6); I would much rather read this: Fraction d = a + b * c; than this: Fraction d = a.plus(b.times(c));
Nice one! Never heard of FunctionalJ, looks interesting!
This M1, and Maven’s plug-ins as they convert to 3 for things like surefire-did milestone change meaning on me? It was always a not-release-ready thing in the past...
Every single time I see this I think 'why are they bit-shifting these... oh right'.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt; Significantly faster binding of large numbers of configuration properties That's huge for me. I had to write my own property binding because loading a YAML file on startup (roughly 5000 properties) would take 10 seconds on my i7.
No mention of the JMM?
Your immutable type looks like the inmutables object. Also your domain name doesn’t seem to map somewhere useful https://i.imgur.com/HgoZdgf.jpg
Well Mr Know-It-All started on his BS in Computer Science 2 years ago according to his comment history... So you better listen to his career advice....
Sorry for the typo ... it is [http://functionalj.io](http://functionalj.io) . :-p
Thanks to share with us...
Have you tried using the font "Fira Code" with ligatures? [https://github.com/tonsky/FiraCode](https://github.com/tonsky/FiraCode)
Yes, it can be abused and if you call a method \`plus\` in Java, it does not say any more than using the operator +, does it?
You can do such ugly things without overloading the shift left operator also: ``` Operators.shiftLeft(Operators.shiftLeft(System.out, "Hello"), System.lineSeparator()); ```
[Google is your friend](https://www.jetbrains.com/idea/features/editions_comparison_matrix.html)
i know, but i didn't find good informations, or i would not ask here
you can do pretty much everything with intellij community edition. THe only additional thing I found on enterprise/paid edition is the nice database integration with great ui and sql shell with autocomplete and all that. You can just use phpmyadmin instead. You can also debug code and do web development
I want to say that it depends on what you need, which technologies and framework you use and if free alternative of Intellij ultimate support is OK for you.
interesting, to be honest i always used external tools like phpmyadming, well thanks i will keep using intellij and hope to master it :) thanks. 
Why allocate an object upon each invocation when it can be done a single time in the constructor?
I've used Eclipse, IntelliJ CE, and the paid-for version of IntelliJ. There's exactly 1 feature I wish was present in the community edition, everything else just feels excessive. In fact, I use maybe 15% of the features of IntelliJ CE, and that's been my IDE professionally for 2 years now. Go with the community edition, unless you really *NEED* some of the extra features. As for Eclipse... Let's just say I've never heard of anyone switching to Eclipse from IntelliJ.
Have used nothing else at work for the last 3 years
Nah, I use == false too for the same reason.
JS is the language which makes you appreciate Java, that's true.
Just use Lombok and its @Value annotation on all data classes.
Seems like premature optimisation to me. If your getter is being called so much that it makes a difference, you probably want to rethink a lot of things about your design.
Keep in mind that for commercial usage of intellij you need a paid license... I doesn't matter though if it ms a personal or if it's a business license. (see: www.jetbrains.com/store/terms/comparison.html#LicenseComparison)
There is a reasonable database plugin you can use that does a decent job.
For java it's fine and yes you can debug servers etc. 
That only applies to the ultimate edition. You can use the community edition for everything just fine, including commercial usage.
This is completely and utterly wrong. The Community Edition is under Apache 2.0 License. Direct quote from the site: &gt; Community Edition is open-source, licensed under Apache 2.0. Projects like Android and Swift use Apache 2.0, so you're in good company. **It can also be used for commercial development.** What you have linked are the terms for the standard editions, not for the Community Edition.
Aha, thanks! Didn't know that! I stand corrected
The main reason for me to get Ultimate was the JavaScript support actually. I'm mainly a back-end dev but sometimes being able to help out with some of the Java/TypeScript work is appreciated. For 'regular' Java work CE is just fine. Most of the stuff Ultimate offers is (very nice) quality of life stuff, but nothing you can't do without.
So true. Spring framework isn't supported good in CE. Some specific file formats aren't highlighted (Freemarker templates for example). There are less instruments for working with database. But more or less this IDE is fine.
 &gt;&gt;For ever example of useful operator overloading you can find 100,000 terrible ones. &gt;For every example of useful operator overloading, I'd have one more than I do now. People can't cope with simple inheritance and you want to give them one more thing to shoot me in the foot? No thanks. In case you wonder I've worked with C++. Amount of black magic happening is insane. Typical C++ interview question is "brackets overloading". And yes it is used in projects. About your example. Is "new" a factory invocation? I think you should post full declaration of your class.
It looks like in your [submission](https://www.reddit.com/r/java/comments/b05we3/need_to_update_my_chops_whats_new_in_enterprise/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Yes it is, it doesnt have the web part. Js/JSP however you don't actually need it. In most cases it is not crazy good like the Java one so you can type on your own ;) 
Would this port work for your needs? https://github.com/jamescarr/zerorpc-java/blob/master/readme.md
FYI, here's the talk Abstract Chatbots are here - you no longer necessarily talk to a human when you contact your insurance agency. Whether that's a good thing remains to be seen, but it sure is interesting for us as developers. The primary goal of my talk is to show you how you can use DeepLearning4J to build a neural network for answering frequently asked questions. I will show you how to build, train, test and use a the neural network in a basic chatbot. This talk is aimed at developers who have heard of neural networks, but don't want to get involved in all the math behind it. This is a not-so-scientific introduction into the wonderful world of chatbots and AI.
I did see this before and I think it would help, but the last commit to that library was 5 years ago. So I am a bit skeptical using it in production. But other than that I am wondering what is the best practice in general to call Python code from Java. I would think it is a common problem, but I cannot find good resources on this topic.
What are you trying to do specifically? &amp;#x200B; Rather than having Java attempt to call Python, can you have Python deposit the needed data "somewhere" in a readable format, e.g., .csv, and then pull the .csv data using the Java web app?
Spring is undeniably the king of server side Java web development. "No one" uses application servers anymore. Jetty seems to be the most popular server. *Interactive* Java web apps are "always" written with a JavaScript frontend, server side templates are dead. My favourite combination is [Javalin](https://javalin.io/) (web server framework) + [Vuejs](https://vuejs.org/) (frontend framework).
Why don't you use aws Kinesis? Let the Java listen an event that you emit from the Python. But I am not sure if the Kinesis supports python. I have not checked it. 
Had a very similar problem where I work, except the data science components were written in R and the web application was in php/laravel. What we ended up doing was setting up a web API in R with plumber. This allowed us to interface with the php app and let us use the R runtime for some of the more complex calculations. You could do the same with Flask for python, to create simple web APIs
Well, I could do that, but that would not be synchronous. As the end user changes some parameters and/or input data in UI, Java needs to pass them to the Python layer and immediately show the results returned by the Python layer to the user. The Python layer does some complex calculations (image processing and more) on the supplied data.
 Here are some concepts you should try to understand AND apply: * refactoring (helpful when adding new features to existing code) * test driven design (helpful when starting with only business requirements) * domain driven design (especially helpful when working on larger projects) * design patterns (always helpful but often difficult to recognize the opportunities to introduce them) There a couple of good books: * Effective Java: [https://www.amazon.com/Effective-Java-3rd-Joshua-Bloch/dp/0134685997](https://www.amazon.com/Effective-Java-3rd-Joshua-Bloch/dp/0134685997) * Clean Code: [https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882) * Head First Design Patterns :[https://www.amazon.com/Head-First-Design-Patterns-Brain-Friendly/dp/0596007124](https://www.amazon.com/Head-First-Design-Patterns-Brain-Friendly/dp/0596007124) (the GoF book on Design Patterns is a bit too much for beginning programmers in my opinion, just make sure you get the updated version of the Head First book) * Refactoring: [https://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672](https://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672) Then there are a couple of frameworks/tools you could familiarize yourself with: * Maven * Spring (Boot) * Junit * Hibernate (or another JPA framework) * any UI framework but be aware that the Java world still doesn't have a single one that stands out for all purposes
It's been my experience that people who don't like linq tend to be ones that don't understand it's core concepts of chained delegates and expression trees.
Amazing. Thank you very much. 
I always used the free edition until I encountered a project that ran on non embedded application servers. Then I made the boss pay for a license. Worth it.
Calling python scripts is easy, but handling their results in Java is going to be a pain, whatever you choose. Have you consider just using Django or whatever preferred python framework to expose a json api and reverse proxy it to your web client? That way it will look like is served by the java web backend. 
Do you any have control over the python scripts? If so, you could have them spin as services that communicate over ports, listening for any calculation needs you may have. (As a bonus, the python scripts could live on another machine.) 
I'm surprised no one has mentioned Jython. 2.7.1 is pretty sweet.
I would keep things simple if things need to be synchronous. Wrap the Python API in an HTTP endpoint so you can invoke with simple GET parameters or by POSTing some JSON and get the results back as JSON. This should be trivial to do in python and is easy to consume from the java web app. If it is just going to be for 1 or 2 api calls, there is no need to go for complicated RPC libraries.
People most certainly still use application servers, especially in “enterprise” scenarios. I’d say the competition is between Wildfly/sub projects (upstream for commercial JBoss) and maybe WebSphere due to “Liberty”, or Tomcat if you’re bundling a container with your software, or Jetty/Undertow for other use cases. Spring has certainly taken lots of mindshare, so much that by JavaEE 7 many of Spring features were built into the standard-it really drove where JavaEE went. And yeah, people prefer Spring Boot, but again there are edge use cases-it largely automagically does lots for you. Spring has two stacks now, one more traditional servlet and one non-blocking called WebFlux. There are lots of frameworks for pages and there’s a contention between JSF/Thymeleaf kinda things and using browser-based things like Angular/React/Vue that mostly make REST calls. CI/CD wise, it’s probably things that can be compiled into an executable .jar, so Spring Boot again. Other solutions *exist*, but... yeah. Those can be rolled out using whatever containerization tech you want - Docker, Docker Swarm, K8, and so on. No direct resource links for you, but Google remains your friend. If you want formal reading/video training, a myriad of sites exist now too (paid); I like Safari Books and Udemy at the moment.
I have been using community edition at work for the past 4 years. I haven't noticed any features lacking. I own intellij ultimate and don't bother installing it unless I need to do something in another language. I mostly bought it to support the company. Community edition has more features then eclipse any day
That same argument be made for mutable state though. Objects don't magically mutate themselves. 
If you're using Spring, especially Spring Boot, the Spring Cloud stack is very big for deploying Java microservices into containers, in particular: * [Spring Cloud Configuration Server](https://spring.io/projects/spring-cloud-config) * [Spring Cloud for AWS](https://spring.io/projects/spring-cloud-aws) * [Spring Netflix](https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html), in particular [Zuul](https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#_router_and_filter_zuul) for API gateways, [Eureka](https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#_service_discovery_eureka_clients) for service discovery, [Ribbon](https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#spring-cloud-ribbon) for client side load balancing and [Hysterix](https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#_circuit_breaker_hystrix_clients) for failover (circuit-breaker pattern)
Have you taken a look at https://immutables.github.io
I haven't read books in a very long time (shame), I prefer going through online guides. If you're building "modern products" using Spring, Spring has plenty of [guides](https://spring.io/guides) to give you hands on learning in various topic areas. I also like the [Spring Petclinic](https://github.com/spring-petclinic) demo, which demonstrates a variety of different modern architectures in a real app. Since the Spring Petclinic application has been around for so long, you can actually see for yourself how Java application development patterns have evolved over time (if you're interested in that kind of thing!)
I would note that the latest version of zerorpc is two years old as well. It doesn’t seem to be a highly maintained library. As far as using python code from java I don’t know since I haven’t done it. However, you may want to look into Jython as it runs on the JVM. https://www.jython.org/jythonbook/en/1.0/JythonAndJavaIntegration.html
Not really no. Thanks, I'll have a look at it, maybe that will look a bit better! 
Maybe this https://developer.mailchimp.com/
This is ok if you don't have to care about GDPR :)
The way we did it in a previous project was that the Python services used Flask and exposed simple REST endpoints that were quite easy to interface with from the Java services.
In terms of technology, Spring Boot + Tomcat is absolutely dominating. More importantly, if the project failed, I have a hard time believing it's because of the technology choice, especially if it's Java (JVM) vs C# (.Net). Secondly, if you ask such questions, are you sure you're the one to lead this project?
Why don't you use [Jython](https://www.jython.org/)? If the scripts are Python 2.7 you can just run them inside the Java application natively. Jython/Python compatibility is very good so long as people don't use C-only modules. I've used Jython a lot and it works very well, even if development seems to have stopped in 2015.
It's unlikely the data science stuff, which is probably using libraries like NumPy, is going to work in Jython.
I’d use grpc services
If you're feeling adventurous this is a great opportunity to check out Graal even though the Python support is experimental [https://github.com/oracle/graal/blob/master/truffle/docs/Languages.md](https://github.com/oracle/graal/blob/master/truffle/docs/Languages.md) If this is a serious project I'd probably look into exposing the Python stuff as an API using i.e. http/json or perphaps gRPC. Or even just shelling out to the scripts using Java [https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html](https://docs.oracle.com/javase/7/docs/api/java/lang/ProcessBuilder.html) or similar.
Sure. The Jython team is working on version 3 compatibility, but C libs are still a problem.
Jython's a non-starter, since the Python scripts are presumably using NumPy and various other bits of the CPython ecosystem. GraalVM might be an option -- I don't know how mature the Python support is, but it's in there. There are some Java/Python bridge projects out there: Py4j, JPype, and Javabridge are the ones I know of. Last I checked, JPype was pretty clearly dead but the other two seemed promising.
I think there are already some excellent ideas in this thread, but I'll add some food for thought. If you're using SQL on the backend, you could have a function that passes your parameters from the UI to SQL in real time, and then have the python script listen for field/table changes, and then have it update your UI component in real time as necessary (more than one way to do this whether or not it's the UI checking or the python passing the update to UI through the calc function). It's a bit more complex, but I think it would give you some robustness as far as scalability goes. Just an idea. I hope you find a good solution!
&gt; Our data scientists are thinking of opening their Python APIs as ZeroRPC based endpoints and expect me to write a Java client to call their APIs. (I Googled and there is not a lot of information on this). Is this the right way? This is *a* right way. You can either run Python programs as executables or over some form of RPC. REST/HTTP is probably the most popular way, and HTTP libraries are universally available. ZeroRPC is just another way to do the same thing. Apparently, there is a [Java client](https://github.com/jamescarr/zerorpc-java).
Any mail sender API can be abused. Of course you have to use it responsibly within the law and good taste.
what are the major differences?
Oh yes. I have. :-) It is a great library. There are some differences between the two though. The one I made here focus on supporting functional style programming. As mentioned the blog, feature such Lens, required value enforce and validation are important when do domain modelling. Together with @Choice (discriminated union), they forms Algebraic data type which are widely use in many FP. :-D &amp;#x200B; If you have yet done (and are interested), please look at [https://nawaman.net/blog/2019-03-11](https://nawaman.net/blog/2019-03-11) . Any feedback at all is welcome. :-D
For me the problem with such services is that data is send through unknown servers. I don't know what happens with the data on them. \`contact-service\` is simple and can be run on premise.
This is the best solution IMO 
One can’t complain about a mutable object being changed. However, if a library creates an immutable object and someone goes in with reflection to change it and things break - it is entirely the fault of the person who used reflection. 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
This is what Jython was created for!!!
This makes me very happy! [https://bugs.openjdk.java.net/browse/JDK-8211304](https://bugs.openjdk.java.net/browse/JDK-8211304) was effecting a free (but not open source) tool my team uses. This release should make it easier for the upstream maintainers to update their dependencies and solve the issue.
https://github.com/javafxports/openjdk-jfx/blob/jfx-12/doc-files/release-notes-12.md#release-notes-for-javafx-12
Release notes at - [https://github.com/javafxports/openjdk-jfx/blob/jfx-12/doc-files/release-notes-12.md#release-notes-for-javafx-12](https://github.com/javafxports/openjdk-jfx/blob/jfx-12/doc-files/release-notes-12.md#release-notes-for-javafx-12) I am excited about the MacOS bugfixes. 
Application servers seem to be a thing of the past now. All aboard the springboot train.
I guess the most noted change is the version number :) &amp;#x200B; I quickly looked over the changelog (\[here\]([https://github.com/javafxports/openjdk-jfx/blob/jfx-12/doc-files/release-notes-12.md#release-notes-for-javafx-12](https://github.com/javafxports/openjdk-jfx/blob/jfx-12/doc-files/release-notes-12.md#release-notes-for-javafx-12))) and found nothing earth-moving. 
Iirc mailchimp has a gdpr contract which states exactly what will happen with the data. 
Good to know! Thanks!
Nice, thank you!
I hope not. It's a terrible idea. The only thing I'd like would be a static set (+-/*%^) for things extending Number. But built in - no overloading them.
there's no need for a site just generate data or download any dataset really. model a dataclass and parse your data into a collection. and there you have your playground. convert the collection to a stream and have fun..
You should add a license if you want others to use it.
Yeah and Kotlin makes the same design mistake. Fail.
Is there a technical reason there's no build for 64-bit ARM processors? None of the ARM linux distros I've looked at have it. It seems like AWS a1 instances make infrastructure a non-issue.
I don't think the kotlin community has really rallied around operator overloads like the scala community did. At least, looking at kotlin libs I'm not seeing a whole bunch of crazy space ship operators.
Not yet but they still did it. How many more times do we have to make that mistake? 
What's premature about that? Effort is exactly the same, and it's clearly better. Make immutable stuff immutable, not immutable-upon-read :)
Thanks! Just added
I found the exercises here useful and fun: https://github.com/stuart-marks/LambdaHOLv2 Stuart Marks is on the technical staff at Oracle .
Not a recommendation per se, but this subreddit is useful to look through: /r/JavaConferenceVideos/
Spot on!
Would love to give a try to Graal. Somebody in the team is exploring gRPC. But already tried using ProcessBuilder and is painfully slow. 
I did :)
Thanks!
This was the original plan, but I was looking for something with little overhead I can do on the fly.
I wish people used undertow more (eg spring boot using it as default). Seem so elegant and smalls jars too. I once used it with a desktop swing app and worked like a charm.
I have been using Intellij community edition for work for last 8 years and its awesome. you don't need the paid version (its freaking expensive!!) if you are not doing something which is only available in paid version. 
I didn’t work on the dotnet project. I’m not why it failed. I’m the guy with the long track record of successes they are bringing in to make sure that doesn’t happen again. The client has expressed an interest in using Java on AWS. I’m an AWS pro but have been more focused on other tech stacks like rails and php/Laravel and Lambda/Python. The Java is an implementation detail. Pick a stack and build with it. Nobody ever failed because they picked jetty over tomcat or Apache over nginx. That said, it would be good to jump on the thing with most mindshare.
http://code-exercises.com/programming/tags/java8-lambdas-streams/ Not too many exercises but it's a great start. 
&gt; Development of JavaFX 13 is already in full *swing* Wait, what? ;)
Much appreciated
Have you thought about putting a queue in between them like RabbitMQ or Kafka?
me too :)
&gt; However note that adding volatile to the field doesn't fix the visibility issue Can you elaborate on that? I understand that every volatile read on any thread which happens in a time after a volatile write will see that volatile write. Is my understanding wrong?
It's unclear whether these Python scripts are remote or can be executed on the same machine. If they're able to be run on the same machine, I wouldn't worry about setting up an RPC system, why not just exec out to a shell and run python there? This is synchronous, and you can either read the stdout of the python process, or read from disk somewhere after it's done.
JavaScript has a much better story around functional programming and immutability. The ergonomics of Java streams are very poor, especially w.r.t. checked exceptions. All JavaScript linters will warn for unnecessary use of `let` over `const`, so it should be relatively easy to determine if non-local state can be mutated.
Have they changed it recently? When the company I work for did a project to verify that all our data handling contracts are GDPR compliant we discovered that mailchimp reserves the right to sell user information for marketing purposes, and mailchimp refused to remove that clause. This isn't compatible with GDPR because you need to allow the user the right to opt out. (This was 1-1.5 years ago, so my memory of it is a bit fuzzy)
Mocks should not be injected. If you've come to the point where you need DI to run your unit tests, you aren't writing unit tests, you are writing scenario/integration tests. And, if that is the case, you shouldn't be using mocks but rather Test implementations of the various DAOs that your system needs.
&gt;Mocks should not be injected. If you've come to the point where you need DI to run your unit tests, you aren't writing unit tests, you are writing scenario/integration tests. These are still unit tests because the code that is being tested (i.e. the UserService class) is not dependent upon a dependency injection framework. ``` @Test public void testAddUserWithoutName() { UserService service = new UserService(null, null); RuntimeException e = assertThrows(RuntimeException.class, () -&gt; service.addUserAndAddress(new User(null), null)); assertEquals("User name required!", e.getMessage()); } ``` What scenario am I running here? What external system am I integrating with? You might want to check what constituents those types of tests. &gt;And, if that is the case, you shouldn't be using mocks but rather Test implementations of the various DAOs that your system needs. So just redo what mockito does under the hood then? 
I agree. I could keep expanding the list. BigDecimal, BigInteger, int, long all compatible. Have a standard BigMath library with trig and other functions for BigDecimal. (There is code for BigDecimal that I've seen over the years.) But how about Dates! `var date2 = date1 + numDays;` `var numDays = date2 - date1;` `var date2 = date1 - numDays;` Now suppose there were a standard units package of some sort where you could have: `var veloc1 = 3 * mile / second;` `var accel1 = veloc1 / second;` (and the units stick with the values and are compile-time type compatible) I can go on thinking of amazingly useful applications of operator overloading. And maybe it should be only restricted to Java internals. But then it is limited to only work with only Java internal types. But having seen the abominations of operator overloading that C++ brought us, I would still rather keep operator overloading absolutely forbidden. The results of letting the monkeys loose with operator overloading are far, far worse then the benefits. So back to: `var bigDecimal3 = bigDecimal1.multiple( bigDecimal2 );` &amp;#x200B;
Yes, you can do such ugly things. But most people would not be tempted to do so.
IMO HTTP/JSON is the right solution unless it's too much data to be performant via text serialization, then some type of binary-on-the-wire RPC is the right choice - gRPC/Finagle/etc.
How is this better than this: @RunWith(MockitoJUnitRunner.class) public class TestMockitoInjection { @Mock private BoringService service; } Also, if a unit test suite requires dependency injection into test methods for *clarity*, doesn't that indicate that the unit test is way too big and unfocused? The Single Responsibility Principle applies to tests, too!
Not at all. Personally I do not do much Android development, but my little experience in the Android Studio IDE it is a very easy to use and set up enviroment. It may feel a tad overwhelming when you first get in and having to set up the IDE, but afterwards everything is the same. As long as you know your basic Java conventions and how to create an object and reference methods to access useful tools. Then you will be just fine. If you have never worked in a GUI environment you may find yourself struggling. A good book recommendation for Android Studio: [https://www.amazon.com/Android-Studio-3-3-Development-Essentials-ebook/dp/B07NG48MXL/ref=sr\_1\_3?keywords=android+studio&amp;qid=1552421669&amp;s=gateway&amp;sr=8-3](https://www.amazon.com/Android-Studio-3-3-Development-Essentials-ebook/dp/B07NG48MXL/ref=sr_1_3?keywords=android+studio&amp;qid=1552421669&amp;s=gateway&amp;sr=8-3) &amp;#x200B; Perhaps make your multiple choice app in Java as a software application before trying to develop it as a mobile application. &amp;#x200B;
Compared to mobile programming, Java is not hard.
/slowgolfclap
No, you don't even need to use Java if you don't want. 
&gt;How is this better than this: I explain that under the section "The Case for Injecting Mocks as Method Arguments". &gt;Also, if a unit test suite requires dependency injection into test methods for clarity, doesn't that indicate that the unit test suite is way too big and unfocused? No, because I'm talking about how we can further add information in a test case signature. &gt;Shouldn't the test method name be enough. Sure, but at least with JUnit 3 or 4, we didn't really have the option to pass in mocks (or anything) in as method arguments. So the only way to communicate the intent of test was with the method name. You arguing it was a choice to put all that information in the test name, when it was really a constraint. &gt;Should we not be leaking implementation details through the test results? Isn't it the entire point of a test to verify the implementation details of the system actually works? Why not then communicate that information in a functional way in the test result? Before JUnit 5 we could only say "Here is a test and what it is doing" (i.e. a test and its name) now we can say "here is a test, what it is doing, and what it is interacting with" (i.e. a test, it's name, and the passed in mocks/dependencies as arguments). Do you see how the latter provides more information? &gt;The Single Responsibility Principle applies to tests, too! I agree, how does referencing a method argument instead of a class variable violate single responsibility? 
Is there really an expectation of the user experience being synchronous? IMHO it's totally fine to present long-running jobs as batch jobs and provide some user interface to monitor the progress and download the result. I'd much prefer that over a "synchronous" user interface that just hangs for an hour and shows a loading animation. Paypal's transaction history export feature is quite nice for example.
What do you use instead?
&gt; You arguing it was a choice to put all that information in the test name, when it was really a constraint. Not really. I put that information in the test name so that the test report can kind of look like a requirements document. &gt; Isn't it the entire point of a test to verify the implementation details of the system actually works? Yes, but at a different level of abstraction than the code it is testing. The philosophy I follow with writing test classes is that the test methods document the requirements of the system, and should not convey how the requirements are implemented. So, I don't really care what the dependencies are *at that level* because they can change, and are not really relevant to the requirements of the system under test. From my perspective, if the dependencies made it to the JUnit test output, I would consider that noise that distracts from what I consider the purpose of a test suite to be. &gt; Do you see how the latter provides more information? More information is not always better. I would consider the list of dependencies to be noise.
Kotlin but you could also go hybrid app and use Flutter or Xamarin.
I would look into [jep](https://github.com/ninia/jep). IT embeds cpython and communicates with it through jni.
&gt;The philosophy I follow with writing test classes is that the test methods document the requirements of the unit under test, and should not convey how the requirements are implemented. So, I don't really care what the dependencies are at that level because they can change, and are not really relevant to the requirements of the system under test. Fair enough. However, this is new(ish) functionality. It seems you are primarily still using JUnit 4, so you can't even do what I describe *even if you want to*. What I am saying is you developed a perfectly fine philosophy based on a series of constraints and now are trying to argue you'd have come to the same conclusion/philosophy now that those constraints are no longer valid. It's like a pre-Java 8 developer arguing why imperative coding is superior to functional coding, without realizing that pre-Java 8 they didn't even have a choice. I'm not saying you're wrong and I'm right, instead I'm suggesting take some time on what I have suggested. Ruminate on it. Maybe you will still not like it and that's perfectly fine.
He's not using DI, at least it is normally used. He's basically suggesting that you create a new mock at the start of each test, rather than defining all the mocks used in all the tests as properties on the test class. So if you have 5 mocks total, but only 2 are used in this particular test, you only create the 2 you need for this test. And the mechanism he uses to create the 2 mocks is defining them as arguments to the test function with an @Mock annotation.
Well, should you be allowed to instantiate UserService with null properties? I think that's wrong, and you should always instantiate UserService with a non-null UserDao and AddressDao. So you would always need mocks of those two classes.
No one mentioned java.lang.Process? If it's just a script, start a new process and read their stdout. Works like a charm.
&gt; What I am saying is you developed a perfectly fine philosophy based on a series of constraints and now are trying to argue you'd have come to the same conclusion/philosophy now that those constraints no longer apply. I would have. I'm very skeptical of introducing new features just because they exist, without a rational reason for doing so that runs contrary to established wisdom. Your Java 8 example is spot on. Some people absolutely went nuts with those, adding them everywhere, even where it didn't make sense. Just because lambdas exist doesn't mean that `for` loops are obsolete. Just because Java can (sort of) implement functional idioms doesn't mean you should jettison imperative (or worse, believe that lambdas and streams make Java a functional programming language). &gt; Maybe you will still not like it and that's perfectly fine. I probably won't. I'm a less is more kind of guy. 
Do you normally null check the values being passed into the constructors of your service classes? I rarely do, I rarely see code that does either. If a service class is in some way interacting with a dependency when it is being passed into its constructor then it would of course makes sense at that point to pass-in a mock because the code under test is interacting with the underlying dependency. That said, I agree passing in "null" to UserService looks a bit weird, and perhaps that *might* be an argument against such a practice (it confuses other developers/people who look at the test code). But passing in a dummy is just adding overhead without providing value. At least to that point, if the null stuff is causing someone that much stress, it would be an important teaching opportunity.
Sorry, I didn't mean that you're the reason why it failed. I'm just not sure if: "last time it failed in C#, let's go for Java" is really a constructive way of thinking. And I agree that it's an implementation detail, but one which has effect on the people around you, the hiring, etc. And like I said, Spring Boot, Hibernate, Tomcat, Maven or Gradle (both work fine), running on JDK 8, 11 or maybe Kotlin, depending on the team. Just go to https://start.spring.io, and you can see a list of technology there, plus it helps you to create a starting project quite easily. (You could package it up in a container, I am not sure if it would add much, it mostly depends on your experience I guess) Good luck with the project!
Your understanding is wrong, because Java Memory Model doesn't define *time*. There is no such thing as "happens in time after" about any two events in different threads (and within the same thread, actually, too). Java Memory Model defines *executions* consisting of *action*. The corner of this is that *if* some read action in some thread sees the result of some *write* (or similar) action in another thread, then ... certain things.
If async processing via messaging is acceptable, you could use a message queue like RabbitMQ. It decouples your code bases and allows comms between services written in different languages, and can be useful if you want to replace/rewrite a service. Latency can be an issue, although I think ZeroMQ might be fast (but I haven't used it).
Ok, but what about the happens before relationship a volatile write establishes against a volatile read. I was under the impression that this is the case. Are you implying that this loop might never end if another thread is setting running to false: volatile boolean running = true; public void run() { while(running); } 
Which part of "things of interest related to the \*\*Java programming language\*\*" is so hard for Kotlin blogspammers to comprehend?
I’m going to show my ignorance here, but would you only use JavaFX be for thick clients? Spring/DropWizard etc seem the dominant choice for web layer. I’ve never needed to learn it if I’m honest, hence I’m curious where it best fits. 
What if you setup some kind of IPC, with unix sockets or tcp sockets, or datagrams? The simplest and most "raw" way of having two completely separate processes to communicate using simple user defined protocols? You can expose your python script collection via a python socket server, which will be responding to requests from your java app
I think so. Where i work, we have at least 2 large scale projects using JavaFX which are used to as a UI to operate machines we build. It's one of the better desktop UIs I've used.
Hi, good on you for advocating immutability and for writing and article about it (and also for using new Java 9+ constructs like `List.of`). I see you've updated the code to add `final` for the field declarations in response to comments from others. That's good, but there are benefits beyond safe publication. Of course, it prevents code in the class from accidentally modifying the field. It also kicks in a bunch of additional checking by the compiler, required by the language. Specifically, a final field is checked to ensure that it is assigned exactly once along every path through every constructor. (This is called "definite assignment".) This prevents you from accidentally leaving a final field uninitialized or from accidentally assigning it twice in a constructor. There are still some improvements possible with the `addresses` field. As others have pointed out, it's necessary to make a defensive copy in the constructor, in case the caller passes in a mutable list. As the code stands now, it does that, and it wraps it in an unmodifiable wrapper in the getter: // constructor this.addresses = new ArrayList&lt;&gt;(addresses); // getter return Collections.unmodifiableList(addresses); This leaves the `addresses` list mutable throughout the lifetime of the object. It may be that there is no code in the class that modifies it right now, but in the future code might accidentally be introduced that modifies the list. This would mean that the list view returned by the getter might appear to change over time. (Also, since any unmodifiable wrapper is as good as any other, there's only a need to create it once.) One way to improve the code is like this: // constructor this.addresses = Collections.unmodifiableList(new ArrayList&lt;&gt;(addresses)); // getter return addresses; This prevents the code in this class from accidentally modifying the list, since the direct reference to the underlying mutable list exists only in the unmodifiable wrapper. But wait, there's more! In Java 10+, you can do this: // constructor this.addresses = List.copyOf(addresses); // getter return addresses; The `List.copyOf` method creates an unmodifiable list containing a copy of the argument. It's unmodifiable itself; there's no wrapper. But if the caller passes in an unmodifiable list (such as one from `List.of`) then `List.copyOf` avoids making an unnecessary copy.
Sorry, mixed up the tools, I was thinking of mailgun not mailchimp. They store messages for 72hrs, Metadata for 30days and you can delete everything you want, or are asked to do so. 
thanks
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
What do you use for you day to day work? Web apps or desktop?
" Our data scientists are thinking of opening their Python APIs as ZeroRPC based endpoints " &amp;#x200B; Unless there's some unfathomably high latency requirements, tell them to use json over http or f off.
I just started learning on codeacademy and reading this forum reading some of these posts is so overwhelming.
Take baby steps. I like the Spring Guides because they let you practice a technology in a bite sized pieces. But I have found that the best way to learn stuff is to work on small projects that use the technology you're interested in learning. For example, I'm creating a version of Spring PetClinic which uses Cassandra, a database I'm interested in learning. You'll never learn it all, the well is too deep. But, you can always keep learning. 
You could pick up a book by Daniel Liang(intro to programming wirh Java) and then open the chapterters for respectively topics. Theres a Lot o exercises in there, from the basics to advanced.
It isn’t very hard at all, but I would suggest you ensure follow one of the tutorials provided Oracle if you’re new to object-oriented programming. A lot of people who go off on their own fail to learn basic OO principles.
For a concrete example of intentional use of something like `new String("kaki")` \[or simply `new String()` in this case\], see the the OpenJDK [core-libs-dev mailing list](https://mail.openjdk.java.net/mailman/listinfo/core-libs-dev) thread "RFR(L): 8218628: Add detailed message to NullPointerException describing what is null." with specific attention to [Peter Levart](https://github.com/plevart) posts located [here](https://mail.openjdk.java.net/pipermail/core-libs-dev/2019-February/058473.html), [here](https://mail.openjdk.java.net/pipermail/core-libs-dev/2019-February/058474.html), [here](https://mail.openjdk.java.net/pipermail/core-libs-dev/2019-February/058561.html), and [here](https://mail.openjdk.java.net/pipermail/core-libs-dev/2019-March/058948.html). That [particular example](http://cr.openjdk.java.net/~goetz/wr19/8218628-exMsg-NPE/03-PeterLevart/src/java.base/share/classes/java/lang/NullPointerException.java.sdiff.html) uses `new String()` rather than literal `""` (or other literal string) to ensure that the logic being conditionally executed (providing an extended NPE message) only occurs in the intended case (when the [NullPointerException](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/NullPointerException.html) is instantiated via its [no-arguments constructor](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/NullPointerException.html#%3Cinit%3E())) and does not occur in the inadvertent case \[such as the caller invoking [NullPointerException(String)](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/NullPointerException.html#%3Cinit%3E(java.lang.String)) constructor and passing it empty string or literal string matching that used by `NullPointerException`'s no-arguments constructor\]. Without the `new String()` forcing a unique `String` instance, it could be possible for two different string variables to be seen as the same identity reference using (`==` evaluates to `true`) due to sharing the "[constant reference with somebody else via string interning](https://mail.openjdk.java.net/pipermail/core-libs-dev/2019-February/058474.html)."
Everyone's throwing out some complicated solutions but are they run on the same server? If so, just shell out to them.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
 &gt; There's exactly 1 feature I wish was present in the community edition Whats that one feature? 
Introducing a potential point of failure in the creation of an object...sounds like bad juju
+ /r/learnjava for questions about learning Java - the sidebar (old reddit) has plenty good and free resources + /r/javahelp for help with Java programming + /r/androiddev for android development questions **Removed**
The dl4j team is very supportive. Can't wait to introduce my company to the the project. 
As a reluctant dinosaur, you may not be aware that Kotlin is running on the JVM. That's Java under the hood, improving where Java failed. 
Where is the strong in your example? It seem to be all integers. But to answer your question, you can get an integer from a string. For example, in Java you could write: int myInt = Integer.ParseInt("10"); The value of myInt would be 10.
Sure, in a way! You can use a ``map`` with an integer as key and a string as the value. This way you can easily choose the corresponding student for a specific integer value. But if it is just about choosing a random student out of the whole collection of students, a simple list alike structure would be sufficient. If it offers efficient index access like an array or an ``ArrayList``, you can simply generate random numbers in the range of the collection elements and choose the student behind the chosen index. I don't know whether Java's standard lib offers functions like Python's ``choice`` which does exactly what you need: selecting a randomly chosen item out of an collection. But I would bet other libs like *apache commons* or Googles *guave* will offer such a function, if it misses in the jdk. 
I don't know if you worded this really weirdly or if I am just misunderstanding. Say we assign each student up to \`N\` students a number from 1 to 20 we can just create an array because the numbers we assign each student are continuous. In the case of it being non continuous (like a UID or UUID) you likely want to use a \`Map&lt;T, Student&gt;\`. Then you can store each student/fetch them without using if statements and \`N\` fields. 
Sounds like you want to create a map&lt;Integer, String&gt;. To create your map, loop over the list of students. In each iteration, put(i, student) in the map. Then generate your random number between 1-20. Finally use map.get(randomNum). This will return the student in the map with that key. 
Great this is what I'm looking for. We havn't covered it in class though since i'm half way in the intro to programming course, is it something complex that I should probably wait till I learn it in class and not jump ahead or is it something easy and straight forward? We havn't gotten to arrays yet. Thanks!
Strint "Joe" = 1 String "Linda" = 2 .... Math.*random*() suppose you get the number 2 System.out.print linda &amp;#x200B;
Yeah it sounds like it pertains to maps and arrays which I dont think we've yet covered in the course. Thanks!
You sound like me 15 years ago or so, this is probably what you are looking for: String[] names = new String[] {"Joe", "Linda", "Jack"}; int randomIndex = (int)(Math.random() * names.length); System.out.println(names[randomIndex]);
Programming help should go in /r/javahelp. What you are looking for is much easier than you think: + Make an array of String where you store the 20 Students + Pick a random index **Removed**
To all the people suggesting you use a Map: why not a simple ArrayList? `List&lt;String&gt; students = new ArrayList&lt;&gt;();` `// code to fill your array` `Random random = new Random(System.currentTimeMillis());` `String randomStudent = students.get(random.nextInt(students.size()));` &amp;#x200B; &amp;#x200B;
Oh sweet, thanks!
Now I see what you mean. One way that some string can be referenced by an integer is in arrays. So, if you created an array such as: `String[] arr = {"Amy", "Boron", "Clarice", "Daniel", "Ezequiel"};` Then the string "Amy" has the index of 0, which is an integer. So if you do: `int num = (int) Math.random()*4;` You get an integer from 0-4 and you can retrieve those strings with: `arr[num];` So, the full program might be: `String[] arr = {"Amy", "Boron", "Clarice", "Daniel", "Ezequiel"};` `int num = (int) Math.random()*4;` `System.out.println(arr[num]);` And a sample output might be: `Amy` There are other approaches to this, but this seems the simplest to me. Good luck!
A spring feature: Showing a warning for field injection and an alt-enter quick fix for turning it into constructor injection.
Full confession: I've used Swing and FX only a little bit. What would you see as its features vs. the typical web app today? I've done a fair bit of desktop development. I'm not an expert per se. But it seems like web apps have caught up in almost all respects, except probably performance. When you consider most architectures today contain a REST layer, there doesn't seem to be much point to a desktop client of any flavor. What advantages do "rich client" or desktop as it is known today, present from your point of view? I ask only as someone who wanted to remain with desktop development, but could not simply because of market natural selection. TIA.
What’s the benefit in the Address class of the private variables with getters? Since they’re final anyway, why not final public with no getter?
Actually, the JVM has C++ under the hood. But we are working on that ;)
The article compares Kotlin to the Java programming language. It is explicitly targeted at java developers. How is that not relevant to this sub or related to the Java programming language?
[/r/Java](https://www.reddit.com/r/Java) is for News, Technical discussions, research papers and assorted things of interest related to the Java programming language, not for help with Java programming. Such "help with programming" posts should go to [/r/javahelp](https://www.reddit.com/r/javahelp).
Because the Java Bean spec doesn't like that, and languages like Groovy and Kotlin (and maybe Scala?) don't like that either. Frameworks like Jackson and most other frameworks work on getters. So, in theory you're right, there's not much difference, but in practice, there are some caveats you need to keep in mind.
Awesome contribution, thanks for that! I've updated the code with your code examples, and thanks for the Java 10 reference!
You don't need a DI framework to use DI. And test implementations are still mocks even if they aren't created using a mocking framework. And the difference between unit tests and integration tests is blurry at best. A unit doesn't necessarily mean a class or method.
why the function SubstanceLookAndFeel donesn't have function like setCurrentWatermark setCurrentTheme how can i set them :( ?? &amp;#x200B;
Performance :-)
Because it"s just another desperate attempt to push more Kotlin content into this subreddit. Anyone interested in Kotlin is perfectly capable of subscribing to the Kotlin subreddit.
Yes. May be you are working for IBM which has enough money to reproduce error within next week with a team of 10 engineers &amp; same number of managers. I just fix it in an hour ))
Its only weird because you are not used to it. :-) I'm a long term Java guy *trying* to learn Python ( I keep forgetting what I learn through disuse ). I find Python to be very readable and refreshingly disciplined.
Try to read YAML. That's what's making me crazy :-P
I code in both Java and Python for work. Love both. Would be nice if Python was compiled though. :p
The hardest language for me to read was LISP. I tried all of the tips, but to no avail. Most of the advice was "learn not to pay attention to the brackets". Um, duh, hence we have Python.
Nice article. I wish I could use more Vert.x in my job. It really is one of the most pleasant and well written frameworks I have tried.
There’s a Python to C [compiler](https://cython.org) where the result can then be compiled to native binary libraries.
You are not alone, i find hard to read any kind on language that doesn't requires ";" or brackets. Even worse if i have have to guess the var types ...
But it won't do checks for stupid shit like exceptions being raised though, will it?
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
For me, it's like punctuation. Compare the following two lines, one with punctuation and one without: &gt; A horse walks into a bar. The bartender asks him, "Why the long face?" &gt; A horse walks into a bar The bartender asks him Why the long face The punctuation isn't *necessary*, but it goes a long way for helping the cognitive process of parsing the sentence by letting us know where one sentence ends and another begins, quotations, etc. Same goes for Python: yes, it shows that braces aren't necessary to designate scope, but they help cognitively.
I’m not the biggest fan of Python, but I’ve kinda come to like the braceless approach as long as some IDE shows me where longer methods end. It forces indendation. There’s nothing worse than unindented code imho ;)
Nope, because exceptions don’t exist in C.
Jython is also an option.
I’ve been learning swift coming from a java background and it’s incredibly weird. Having to specify the return type with an arrow has me think I’m doing Java Lambdas. Then loops and conditional statements require brackets so it’s even weirder. Gotta say the language is quite organized tho with the placeholders in arguments and what not. 
No, you're not, but that's just because you're not familiar with it. It's one of the first things you get over when you dive into something like Python.
I'm a huge spring proponent but dagger is really awesome thanks for that!
Yes. getting bothered over something like brackets is abnormal. 
CPython is compiled though, as is Java. Just not maybe in the way you're imagining.
I programmed on Java for many years when I started Python. For the first time it was very uncomfortable for me to deal with these indents and missing brackets. But after some time, spent on writing python scripts I feel ok with the python code requirements. Just keep going and in several months you will notice that it is ok for you.
I used IntelliJ and switched (back) to Eclipse... :-)
It's not the lack of brackets that bother me it's the fact you cant even use them without a error... I just want structure
To understand this correctly, AdoptOpenJdk take the code from OpenJDK and then support it? So, Oracle says that the OpenJDK and Oracle JDK are basically same starting version 11, will that be the case for the AdoptOpenJDK? Will the AdoptOpenJDK version match == OpenJDK == OracleJDK versions? 
I've always found brackets to be visual noise, so I have no problem with no brackets. What pains me is to try to parse code of any level of complication without types (static typing). I've tried to debug that code...take the nightmare that is java enterprisy code, and add another additional layer of complexity and confusion to it. (shudders)
I agree so much on this. Strong types and and braces makes it absolutely clear what is happening, making the code easier in the long run.
It seems like you don't want it to be compiled, but static checking ofsyntax and type: https://en.wikipedia.org/wiki/Type_system#Static_type_checking
https://raw.githubusercontent.com/tarsius/paren-face/master/parentheses.png
That is essentially correct yes!
That was exactly my ( downvoted ) point: LISP coders learn not to see the parenthesis, and they go by indentation That begs the question of why use the parenthesis at all? The designers of Python must f had something similar in mind. Instead of relying on punctuation, the decided to rely on indentation and get ride of most of the punctuation.
I coded in languages with brackets for decades, and now code in python with no problem. It's not unorganized, your brain just has to get used to seeing blocks defined by indentation instead of brackets.
I also hate it when I put in a quick print statement to debug something in python only to forget to put in the requisite whitespace to not break the code.
Calling CPython compiled is a bit of a joke. The "compilation" is nearly one to one with no optimization into Python byte code. Then the Python VM executes the bytecode at the language level it is implemented in. On the other hand the JVM translates bytecode into relevant assembly directly. Which is why technically every language on the planet is "compiled". But a language like Python is more interpreted than combiled, and generally when people refer to compiled they mean it's has only the CPU's ISA as an major intermediary.
&gt; LISP coders learn not to see the parenthesis, and they go by indentation That's not true. There's sevaral reasons for parenthesis: 1. There are ways of indenting the same thing. 2. Parenthesis are also used to disambiguate things. Aside from math, an expression like `(lambda (x) (car x))` is impossible to figure out if you skip parenthesis. 3. It makes it really, really easy to write code that transforms other code. All code (in all programming langauges) is parsed into an Abstract Syntax Tree before it is compiled/type-checked/executed. Compilers use AST to make optimzations. In lisp, it's trivial to see and modify the AST because the AST matches the parenthesised-lisp code exactly. It's why lisp has amazing macro abilities.
That was my feeling when I started using Python too. Plus list &amp; dictionary comprehensions are really nice. This was before Java 8, but even afterwards the comprehension syntax looks better to me. Then the pain started: The lambda syntax, the fact that `(1, 2)` is a 2-tuple but `(1)` is just an integer with parentheses around it (`(1,)` is 1-tuple, incidentally), the fact that set literals use the same tokens as dict literals so you have to use the `set()` constructor to make an empty set. The multiple ways to assign values to a variable (`=`, `as` for `with` and `except`, and soon `:=` for comprehensions). The fact that ``` except SomeException as e: raise e ``` replaces the stack trace for `e` but ``` except SomeException as e: raise ``` does not. The fact that stack traces aren't part of the exception object at all. The fact that exceptions can't be chained. The [dependency management](https://xkcd.com/1987/). The frickin GIL. Most of these are just syntax issues and, even when taken together, they don't make Python a bad language. But they do limit what I'll use it for. Python makes me appreciate the caution Sun/Oracle exercises when extending Java.
Imo any language that enforces shit like whitespace can die and never come back.
Python is a powerful scripting language. Java is a powerful programming language. Both are different and each one is useful in different ways. Good developers learn multiple tools. Its stupid to compain about or compare look and feel over everything else.
It's because you're used to seeing brackets so often. But once you get into python and code for a while you'll hate that bracket. Now I feel like remove a heavyweight for the good of my finger.
No. I feel pain when l see if statements with no braces. if(someBooleanMethod()) //Single line of code for if statement //Code unrelated to if statement
&gt; The fact that exceptions can't be chained I agree with many of your points (though I consider some of them very minor) but the above one is simply not true. Python has implicit and explicit exception chaining. The latter is written as \`\`raise ERROR from CAUSE\`\`
So, use a proper editor that provides the visual or interactive code structure for you? Every python editor that's worth something provides optional visual block feedback and -folding.
Imo, your editor should provide the appropriate visual clues and folding options for blocks. If it doesn't, switch editors. I consider braces to be visual clutter.
No braces is still better than new-line braces or do-end, prevalent in C#, C++ and Ruby (and sometimes Java code, *sigh*)
Oh my god thank you. I had no idea. It looks like they added it in [Python 3](https://www.python.org/dev/peps/pep-3134/), which is probably why I didn't know about it.
It's not a Python compiler then is it? It's a compiler for a vaguely defined non-standard language that looks a bit like Python. And you can of course implement exceptions in C. How do you think the Python interpreter does it if it can't be done in C?
I don't use python that often was mostly for assignments, what's good ide for python
What are you doing in AD that is AD specific as opposed to generic LDAP? &amp;#x200B; What are you doing that can't get away with an ordinary mocking framework to simulate network communications or even bog standard object mocks?
This is the right answer.
A horse walks into a bar The bartender asks him: Why the long face? Your example is wrong because in Python newlines and indentation replace the punctuation. Once you are used to it, it's just as easy to read.
Got it, thanks.
Let me know if you find something. I'm gonna give RotaryJihad's suggestion and play with generic LDAP. I googled a bit and found this http://directory.apache.org/apacheds/advanced-ug/7-embedding-apacheds.html.
r/Kotlin is over there ---&gt;
It looks like in your [submission](https://www.reddit.com/r/java/comments/b0p9oj/jtable_populating_to_fields_after_clicking_only/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
PyCharm is one.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Try Pascal/Ada/PLSQL and similar languages. \`BEGIN END\` all the things!
&gt;Lisp has all the visual appeal of oatmeal with fingernail clippings mixed in. – Larry Wall
Be thankful. Java's exception checking is more of a huge PITA than something helpful.
That's why both Rust and Swift removed parentheses around the condition: to make braces necessary: if cond { stuff(); } // fine if (cond) { stuff(); } // whathever, grandpa, you can keep writing it like this if (cond) stuff(); // get out.
I've heard somewhere that LISP syntax was basically meant to be a 'temporary' thing. It basically was just a convenient way to write out parse-tree of the language and keep the parser super simple. This seemed like a good idea to protoype the language. The sentiment was that they'd make a 'real' syntax and parser later. Then.. they didn't. But they got some neat things in return, like being able to easily have lisp programs represent lisp programs as data and manipulate that data. But I guess what it all boils down to is... making a 'pretty' or 'easy to read' syntax really never was much of a consideration into Lisp's design.
I never understood why people get so hung up about semicolons. I do appreciate a language with clean and readable syntax. But semicolons really never bothered me, and if it makes the parser's job easier, and the syntax less ambiguous... I'm all for having them. Take js for example. They made such a huge mess of the language syntax, with the whole 'optional semicolons' thing... and then sensible people come along and write something like jslint so that you can check you put those semicolons to avoid a bunch of common bugs causes by ambiguities that happen when people routinely omit them.
Why do you want to make fun of AD? :(
Anyone care to explain why you're downvoting /u/AnAirMagic? He is very clearly explaining why you can't just remove the parens, and he is right! My guess is the downvoters are some pythonistas who have never written a macro in their life.
It probably won't. I don't see a JEP for it.
I once got into a heated debate with a co-worker once over some JS if statement brackets. The bug I had went away immediately after adding brackets. My co-worker insisted it was something else. 
check this out https://github.com/graalvm/graalpython
You should create an EFSP
Wrong subreddit. /r/javahelp is for Java programming questions, /r/learnjava is for learning Java. If you're looking for ideas, look into /r/ProgrammingPrompts, and in [**Where Can I find practice exercises and project ideas?**](https://www.reddit.com/r/learnprogramming/wiki/faq#wiki_where_can_i_find_practice_exercises_and_project_ideas.3F) from the /r/learnprogramming wiki. If you need a well structured course with lots and lots of practical exercises, do the MOOC [Object Oriented Programming with Java](http://mooc.fi/en) from the University of Helsinki. **Removed**
Thank you!
Python is to Java what slang is to language. I like python because it's not filled with bs like ; #, int, double. You just Yo python, here is a numba, deal with it and python is like 'yo np'
Python is just so easy to abuse when coming from java IMO. I think it takes a little more discipline. 
I code in java, typescript and python. If specifically brackets is the topic, I think I am okay with it. The "step in" we do in java inside the bracket is still there, so it's fine. But if you are talking about organization, I literally hate it when I see people writing unstructured unorganized code. Feels unhygienic, as if I missed a bath or a forgot to brush, ah just makes me sick.
Why would you want to? How about creating an interface that describes what specific information you need, and mock that. Then create an adapter that implements that interface which you can write a simple integration test for which connects to Active Directory for real. Remember, dependency inversion is [not the same thing](https://lostechies.com/derickbailey/2011/09/22/dependency-injection-is-not-the-same-as-the-dependency-inversion-principle/) as dependency injection!
I'm curious, what prompted the switch? 
There are two options - [ApacheDS](https://directory.apache.org/apacheds/) or [UnboundID](https://ldap.com/unboundid-ldap-sdk-for-java/). If you are using Spring, then [spring-ldap-test](https://docs.spring.io/spring-ldap/docs/2.3.1.RELEASE/reference/#using-embedded-server) will help you.
Vert.x and Dagger are both java libraries. I'm not sure why the author chose to use kotlin over just using java... but, here we are.
What do type aliases buy, practically, over type inference? Shorter method names?
I think the guy who came up with Perl should not be criticizing Lisp. Even modern mental health care has great difficulty helping people to achieve complete recovery from having programmed in Perl. If you learn Lisp you will be a better programmer for the rest of your days. (And its true IMO/IME) &amp;#x200B;
Na dog, they serve different purposes. Shit’s orthogonal. Type aliases allow an API to create nicknames for preexisting types, so that later when you want to change a million lines of code, you can quickly rename the alias rather than say, `string`, which would have a ton of false positives.
There is a real beauty in the fact that there is a very simple syntax for the data structures of the language. And then the language is written in its own data structures. Imagine if the only way you could write Java were as arrays, lists, expressions -- eg simple data structures. There WERE NO SYNTAX. Only data structures. Then imagine there were simple literal ways to write the data structures. Imagine the utility that any conceivable data value can be printed out -- and read back in again! You don't need any JSON / YAML, etc. &amp;#x200B;
A consulting company recently came in and was walking us through the source of their app. There was a 100 line method with around 5 while loops and a couple if/elses in the middle. No brackets. 
And what does that buy you over having your public API return an interface? I'd argue your public API is already screwed up if you are either returning or taking a "Map.Entry&lt;List&lt;Integer&gt;, Map&lt;String, Object&gt;&gt;" About the only place I've seen sprawling types is when generics get involved, and in that case, you probably should be rethinking things if you have these kind of types being handed around.
I had no trouble learning Python some years back. Probably about Py 2.6 or maybe 2.5? My only grip was this: Sometimes in Java I deliberately introduce a set of curly braces around statements: `private void foobar() {` `int x = 25;` `fob( x );` `{` `// New scope so these variables are limited in scope.` `int y = 27;` *. . . . more code involving use of x and y . . .* `}` *. . . now y is out of scope, but x is still visible.* `}` I sometimes wished I could do that in Python. Begin a block of statements indented further in where new variables in that scope weren't visible when the code were outdented one level again. You can't even begin new lines at a different intent level -- it is an error! Even if I could merely do this for organization purposes would be cool, even without the sometimes benefits of minimizing variable scope. But it's not a huge gripe.
Ugh, so I spent an hour or two but couldn't find an example of launching Apache DS programmatically in embedded mode. Does anyone have an example similar to https://github.com/bane73/ApacheDSEmbedded but for 2.0?
Spot the dot NET programmer. In Java String is capitalized. :-) I have often wished it were possible to subclass String in a way that you cannot modify it, just have a new name -- which is assignment INCOMPATIBLE. Now imagine having new industry standard types such as: HtmlString and SqlString, just as an example. You could not accidentally take a String value an assign it to an HtmlString. Such assignments would be required to go through a conversion function: String s = request.getParamenter ("foobar"); HtmlString htmlSafe = HtmlString.fromString (s); An unsanitized input, like s, cannot be sent back to a web page, and accidentally contain, say, an evil SCRIPT tag. The only values you can render into a web page, such as in a JSP or JSF would be an HtmlString. Similarly JDBC would only accept statements formed from an SqlString. You couldn't accidentally assign an unsanitized String to an SqlString. And similarly for other language or interpreted types. This could eliminate format string attacks. The assignment is doable, just via a function call. This is the gist of an idea -- not fully worked out in all details.
Thank you!
They are pretty pointless when you have value types.
JavaScript: "We hear you like brackets"
I hate Python so much.
Same. I grew up on C though, so that may be why.
You guys are crazy, i don't hate any language, just php.
JS has an especially bad rule for what happens when semicolons are omitted. It's a total non-issue in most languages that have optional semicolons.
Go, actually. I wrote a Windows Phone 7 app in C# once and diddled with F# but that’s about it for .NET
Right. In the end I figure they thought all of that was worth the 'weird' syntax with all the parenthesis. I'm not one to argue against this. I do think its worth it. But the fact does remain the syntax really isn't designed to be nice for human readers. It just isn't, that particular concern was sacrified to get other things in return.
Every time I try to use jython I just run in to odd little incompatibility issues, and libraries that won't work with it. It feels like it's fine if you're using stdlib and writing everything else yourself. But when pypy exists, I'd rather go down that path. 
not to mention kebab-case
I can't argue with that. But with the major web stacks eventually moving to wasm, that probably won't be as big an advantage in the future.
 A horse walks into a bar, The bartender asks him, "Why the long face?" vs A horse walks into a bar The bartender asks him: Why the long face Both are perfectly legible, it's clear who's speaking. The minimal punctuation doesn't provide any strong value under these circumstances.
I do that in all my applications. Takes a ton of boilerplate and hacking with generics and inheritance. Type aliases would do away with most if not all of that.
Semantic expressiveness.
Kotlin blogspammers is everywhere on the Android sub too and thinks they have the perfect solution to every software problem. 
Me: "Hey that number was supposed to be a string!" Python: "Gotchu fam, take this with you. str()" 
Why is it so hard to understand indentation for Java guys? Serious question.
When I was in studies my professor was a real hard on for brackets 
I learned Python before Java so it might explain why it is easier for me to understand, but it still doesn't make sense the other way around. I however, have been guilty of typing a `;` at the end of a statement in python. 
What is the recommended replacement for Eureka? 
Use Ruby or Haskell. By the way, infix is also ambiguous, so try LISP! I’ve been bitten by significant whitespace twice, once when a Web SSH UI screwed up hard tabs, and again when 2600 magazine dedented my entire Python script. Just one more reason Ruby is better.
I browsed a Perl project twice. And now I'm crying again. Make it stop!
I use both, it's just something that you get used to after awhile if you program in it long enough.
&gt;Me: "Hey that number was supposed to be a string!" &gt; &gt;Python: "Gotchu fam, take this with you. str()" Relationship goals right there :')
Use Java and Python, identation has some good points, like removing lots of closing braces, it doesn't makes me easier or harder to read the code. But what bugs me, is that you have to mix code style and code structure.
I have a harder time adapting to dynamic typing. All those variables flying around and the only way to tell what they are is to look at their usage. Gets especially fun when dealing with 4 or 5 dimensional tensors in machine learning. 
How about JavaScript and its optional semicolons? Ug. I am not a fan of context sensitive whitespace. And then there's ruby where because `?` is part of a valid identifier, the code `x?y:z` is a syntax error and needs to be written as `x ? y:z` instead.
OH god I hate ruby. Function calls that dont require (), implicit returns, and variables without declaring them can suck a big dick. 
Can't imagine how one could have a Lisp without brackets... Just doesn't seem possible. 
It looks like in your [submission](https://www.reddit.com/r/java/comments/b0tst0/rantdebate_the_era_of_frameworks_and_tooling_and/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Oh trust me, there are many, many terrible ones. JavaScript is actually awful if you don't avoid using the shitty bits. Visual Basic and most other crap by Microsoft is terrible with the notable exception of F#, Perl, shell, Ruby, Scala, R, Fortran, COBOL, the list is long. 
He should give Clojure a try for many reasons. I say that unironically because it's a great language and Hickey has an impeccable taste. 
I used to hate Python because it was using indentation instead of curly braces or BEGIN/END or something similar but now I am used to it.
I freaking hate YAML. 😡
I went from a Java job to one in Ruby, Python, and JS. And I might go back to Java for my next job. You get used to it, it becomes more readable. Both ways are fine. Remember: you can write shitty and unreadable code in any language. Good IDEs and linters are your friends.
Do you mean braces?
Absolutely. I love Clojure.
I feel you. Indent is crazy in Python. 
You can sort of roll your own with phantom types the give it a map function such that transformations in strings can work on your type as well. Now you don't have a any subtyping relationships between the different string wrappers due to generics. Not really the same thing, but I use that approach for currencies that I don't want to mix up. Sure, someone could use raw types, but that's easy to spot automatically.
So you'd wrap such unwieldy types through an interface with a method that returns these instead of returning them directly? Or what do you propose when you get really unwieldy types?
I don't feel pain, but it just feels so unnatural... I feel like the brackets are the basket and code inside are the fruits, and that python is a basket of fruits without the basket
hmm maybe ruby 4 should get that. dang, i usually champion `end` as strictly better than python, nevermind iterator chains
Nah dude we all in the brackets squad. People always hate on the "verbosity" of Java but personally there's about a billion ways to increase productivity that doesn't involve weird syntax. It's nice and structured.
Internal to a class or a set of your APIs, something like this is probably fine. However, when you start talking about what you are exposing in your public API, my listed example is bad all around. It exposes implementation details. It doesn't tell you anything about the object. And ultimately, it exposes a feature set that you probably don't want to support (for, example do you really want your users to call "setValue" or "compariWhngByKey"?) And what about the internal generics? What is that List&lt;Integer&gt;? What is that Map&lt;String, Object&gt;? Do you want to support all of the functionalities of both of those? When you make a public API like this, you are bound to have run into just a boat load of problems when your users ultimately start calling methods you didn't want them to. The lazy programmer will say "Oh, well, those idiots shouldn't have done that!" the smart programmer will use the language tools to prevent that from happening in the first place. So, what would I propose? First off, I wouldn't return Map.Entry. I'd either return a "Pair" or a dedicated interface to perform whatever purpose that entry was meant to perform. I may chose to have that nasty object as a field in my implementation, but I wouldn't give the user the slightest hint that it is what I'm doing. For the two types, again, I wouldn't return the List or map, but rather a "Identifiers" and "Foo". Even if they just wrap directly over a list or map. I probably wouldn't expose all of the list and map functions to the end user, or even most of them. I might have a "asList" or "asMap" method, but those would copy the internal object and then let the end user do whatever it is they want with it. Type aliasing doesn't provide any protections or implementation hiding. At best, it provides the users context for what things are. At worse, it makes it really easy to expose implementation details. I've dealt with far too many systems that return their internal implementation details (or worse, extend collections with non-collection functionality). It becomes far to easy to mutate those classes which can be unexpected and super hard to diagnose later on (For example, did you know that a submap of a navigable map mutates the parent map when modified... ask me how I know this.) One of the most powerful tools of Java's data model is hiding implementation details and forming API contracts. The best way to use those contracts is to start out as restrictive as possible and then expand as need arises. That doesn't mean that I don't ever return Maps or Lists of things. It just means that I don't generally expect my public API to expect those unwieldy objects. Further, those objects are never references to internal fields of my class (always either a copy or something generated from something). As a rule of thumb, once your generics are 2 levels deep (Map&lt;Integer, Map&lt;Integer, Object&gt;&gt;) you are probably getting close to the point where a new object is in order. Definitely, if you are at the point where type aliasing would be a huge QOL improvement, you should be considering making dedicated objects.
It's like default for liquibase so my team started using it for that purpose. OMG nothing is validated, no schema as in XML version also liquibase has the worst logging ever.
We’re using Liquibase too, but with XML config. I still don’t really like it. Most of my YAML interaction is with Kubernetes and ElasticSearch. Bleh. 
You should check out [Nim](https://nim-lang.org/) :)
No, I felt that way at first too. You get used to it quickly though.
At this point it would break to many things
You can do the same thing in Play, which uses Java. https://github.com/playframework/play-java-dagger2-example
Lisp M-expressions. McCarthy loved them, everyone else on the other hand just went ahead and use S-expressions. Which coincidentally allowed them to bypass the years of dev time to get a compiler up an running, as they only had to hand compile an eval function for S-expressions. &amp;#x200B; IMHO, M-expressions were absolutely hideous, so S-expressions were beautiful in comparison. 
I can’t stand python for a lot of reasons. Why it’s so popular I’ll never know. 
I guess javaBrains is better 
This is what I tried recently. There were some subtle differences between them and Microsoft's LDAP unfortunately, but if you designed with these in knowledge from the start things'd probably work out well.
I wish Java had this! Here's why I realised it was important: With some software that worked with Android devices, we had a bunch of device identifiers: the "english" name, the model identifier, the serial number, a few extra low-level things. When these are all strings, it's easy to give a method the wrong one when it just asks for a string called "id". We created an abstract `Id&lt;T&gt;` class that just wrapped a value. This comes with a performance cost, and is a little more verbose, but was totally worth it. That said, I'd love to see something supported on the language level.
I'm not making any money with my articles, that's only creative common content. As long as there will be Java Dinosaurs reluctant to understand that the Java language has been flawed for so many years and needed an upgrade, there will be people to spread the Kotlin knowledge. 
I would say that lack of brackets and retarded closure definition by whitespaces is the **least** of Python's problems. But yes, that makes Python code and YAML extremely hard to read. You basically need to read through code to figure out boundaries of code. And their weird overtness to defining variables (and instead just assigning value to name, as if it was already declared) doesn't help either. It's freaky.
New line braces are weird since you're wasting an entire line to define closure when you had already done it a line above it with function or loop definition. The rest are perfectly fine - sure, begin-end is more verbose than { ... }, but it still gives you clear beginning and end of closure (for both dev and compiler), unlike Python where you have to figure them out visually
But that's only because JS is terrible.
&gt; if (cond) stuff(); // get out. Wha's wrong with it? If anything, &gt; if cond { stuff(); } // fine is the awful one that should get out. Omitting braces around single expression closures is so normal that a lot of languages (Scala, Kotlin) allow it even in function definitions
Even though the code examples are in kotlin, vert.x itself is a polyglot Java framework. All concepts in the blog can be applied in Java too. Or Groovy or JRuby, etc...
Yo, let me treat that number as a floating point just because!
Then add the real problem of [dangling else](https://en.wikipedia.org/wiki/Dangling_else) on top of this. A parser i wrote still can't predictable deal with these, fortunately i don't execute the parsed code so it's not that of a big deal.
**Dangling else** The dangling else is a problem in computer programming in which an optional else clause in an if–then(–else) statement results in nested conditionals being ambiguous. Formally, the reference context-free grammar of the language is ambiguous, meaning there is more than one correct parse tree. In many programming languages one may write conditionally executed code in two forms: the if-then form, and the if-then-else form – the else clause is optional: if a then s if b then s1 else s2 This gives rise to an ambiguity in interpretation when there are nested statements, specifically whenever an if-then form appears as s1 in an if-then-else form: if a then if b then s else s2 In this example, s is unambiguously executed when a is true and b is true, but one may interpret s2 as being executed when a is false (thus attaching the else to the first if) or when a is true and b is false (thus attaching the else to the second if). In other words, one may see the previous statement as either of the following expressions: if a then (if b then s) else s2 if a then (if b then s else s2) The dangling else problem dates to ALGOL 60, and has been resolved in various ways in subsequent languages. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Well you 'should' use whatever you and your team fancy. But of the two JUnit is used the most by far, so it's more likely that other developers have experience with JUnit than TestNg. Both are easy enough to pick up though. TL;DR: doesn't matter.
I've used JUnit and Spock. They both have their advantages and disadvantages. Spock works with Groovy which is less strongly-typed than Java (read: not at all typed) and you can integrate it with Selenium and other test automation tools if you need to. JUnit is the more traditionally Java written framework with, arguably, the better support because of its longer time on the market. It also integrates very well with just about any automation framework you can think of. 
It's fine to program in Perl (if nobody will ever look at the code again ;-)). 
&gt;But it's not a huge gripe. Yes, defining a new function/method to have new scope instead of inlining a scope is not too bad.
Aye I can attest to that! 
jUnit. No need to look any further. At least not in today.
In JS semicolons aren't really optional, but rely on ignored parser errors. The parser tries to continue adding things to an expression and it has to fail internally to make the semicolon optional.
Junit and mockito.
use junit (base) + mockito (mocks) + assertj (validation)
Brackets usually refers to square brackets, but can apply to other types. "Braces" would have been less ambiguous though. https://en.wikipedia.org/wiki/Bracket
There was a time when TestNG took a big leap ahead of JUnit, but JUnit has long since caught up and remains industry standard. On most projects I use a combination of: * Junit as test framework * Mockito for mocking interactions where required * Powermock for the tricky bits with legacy code bases
Those guys dont have manners.
**Spam** somewhere else
Ur mother a spam
Nowadays( as of Python 3.6 or 3.7ish) you can add a "type hint" to your python variables like x: int = 5
I came to suggest Spock for groovy. Glad I'm not the first.
Can confirm, porting python to C++ is no fun.
I consider myself a competent Java programmer, yet if I need to do a small project, it will take me less time using python
No you’re not! :D
Nice :) while we're at it, here's a small reminder to keep your Selenium tests object-oriented: [https://www.amihaiemil.com/2017/01/24/selenium-and-junit-the-right-way.html](https://www.amihaiemil.com/2017/01/24/selenium-and-junit-the-right-way.html) 
Try /r/javahelp for that. Good luck! :)
Thank you, Bill. Off-topic: I like your blog. I subscribed to updates. Thank you and please keep sharing!
Commenting to save the thread in my inbox.
I'm out of the loop. What is being worked on? 
Excellent blog post, I wish I knew this when I've started writing Selenium tests! You should share it on /r/Selenium as a thread.
Thanks! Done: [https://www.reddit.com/r/selenium/comments/b0ze6m/keep\_selenium\_tests\_objectoriented/](https://www.reddit.com/r/selenium/comments/b0ze6m/keep_selenium_tests_objectoriented/)
says a Kotlin blogspammer paid by Google. Google obviously has a hidden agenda. 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I'll start by listing another language I just remembered that does it the Rust way: Go. There's also a language that always requires both braces and parentheses: Perl. But that's classic Perl: it'd die if it couldn't impose pointless punctuation on the programmer. Anyway, back to subject. The only reason we have parentheses around conditions is because B did it, and B did it everywhere, except for `switch` for some reason. &gt; Omitting braces around single expression closures is so normal that a lot of languages (Scala, Kotlin) allow it even in function definitions. Notice a difference between this Kotlin code: fun f(i: Int) = 1 and this B code: f(i) return (1); (Yes, B required parentheses for `return`.) There's an equals sign, which means that in Kotlin function declarations and conditional statements are two different things. Most languages with single-statement function definitions use an extra operator (usually =). In other words, the code is separated from the prototype, by either a brace or an equals sign (or their equivalents). &gt;Wha's wrong with it? Quite a bit. First problem with the B style if is [this famous ambiguous statement](https://en.wikipedia.org/wiki/Dangling_else): if (cond1) if (cond2) foo(); else bar(); // where does this belong to? Then there's the famous Apple bug: https://www.imperialviolet.org/2014/02/22/applebug.html Furthermore, in semicolon-using languages there's a risk of accidentally adding a semicolon after the condition: if (cond); foo(); There's no wonder most style guides for languages with B-like syntax recommend to always use braces. &gt;Meanwhile omitting parenthesis around condition makes it unreadable I disagree. You start reading the condition from `if` and finish before the first opening brace. In most cases the programmer has been sane enough to not put braces-containing expressions in the condition (if the language even allows that), so it's fine. In contrast, if the delimiter is a matching parenthesis, and the condition also contains parentheses, lots of them, then you have to count. If you say "braces are too small and easy to miss", then I say: stop using Courier New and get a real font. As final sidenote: obviously, you couldn't just add this syntax to Java today, as the parser wouldn't know if `new Foo(){}` is an object of an anonymous class or a `Foo` followed by an empty branch.
It looks nice. Have you seen [Testcontainers](https://www.testcontainers.org/modules/webdriver_containers/)? It looks like it is doing very similar thing. This is a little unfortunate that we have so many solutions for the same problems which in fact looks very similar. Does `selenium-jupiter` fully support nested test suites from JUnit 5?
Have a look at JUnit 5: [https://junit.org/junit5/docs/current/user-guide/](https://junit.org/junit5/docs/current/user-guide/)
Don’t even try /r/javahelp. JavaScript is not Java. 
Yes, I know TestContainers. Both projects share the usage of Docker, but IMHO they are different, which is good for the testing community. TestContainers allows to use any Docker container for tests (e.g. a database or whatever). They first used JUnit 4's @Rule, and now they support JUnit 5 as well. Selenium-Jupiter is JUnit 5 from the beginning, and it is focused in providing browsers (local, remote, or in Docker containers) with a minimum boilerplate (using JUnit 5 capability for dependency injection) for tests. Regarding nested tests, yes, it is supported in Selenium-Jupiter.
FYI, here's the talk Abstract It seems like keeping up to date with Java nowadays is an enormous task. Gone is the era of big, delayed Java releases that span years. We're now getting a new major release every 6 months. What's up with that? You're probably still developing on Java 8, even though Java 11 is already available. Join this session to get an overview of what's new in Java since Java 8. We'll give an overview of the module system (Java 9), the local-variable type inference feature (Java 10) and the new HttpClient API (Java 11). Expect lots of advice on how to get from Java 8 to Java 11. It's time to embrace the newfound agility of the Java platform!
I have been using TestNG for years and to this day I find it easier and cleaner to write tests with it. In most cases they are similar, but for parameterized tests, I found TestNG's @DataProvider is simpler and cleaner to work with. It also easily allows tests to depend on each other, which is great on the rare cases when you want that (e.g. test1 modifies data, test2 uses that data and applies further transformations, test3 tests a report that can only be generated after test1 and 2 complete, and so on). Last time I checked, JUnit has no equivalent to testng.xml either. When working with in memory databases for testing, testng.xml lets you declare what is the sequence of tests classes to run, which ones can run in parallel, etc. Ideally you want a clean state for each individual test but with in memory databases that can be tricky to manage and/or too slow.
I do a small site in Django because someone else wanted that, and I don’t know if it’s because I don’t practice enough but I’m still faster in Java. I would convert that thing to spring boot in a second, given the opportunity. Is there a specific thing that you could recall that you would consider easier/faster?
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
More and more parts of the OpenJDK are written in Java instead of C++. Most of GraalVM is written in Java.
sorry, I cannot help you with the exercises, but here are few great talks about the subject: one of my favourite developers: [https://www.youtube.com/watch?v=1OpAgZvYXLQ](https://www.youtube.com/watch?v=1OpAgZvYXLQ) these guys know what they are talking about, but the presentation is not amazing: [https://www.youtube.com/watch?v=ePXnCezwRuw](https://www.youtube.com/watch?v=ePXnCezwRuw) however in the second part of this talk they go into very cool examples. I believe, that the link from @esotericnumeric is actually from this presentation. good luck :) &amp;#x200B;
I would love to see the same comparison in a language where they don't waste space on heap allocating every tuple.
Wonder if any of these people advocating the Java release train thundering through have to deal with corporate financial institutions that move on everything at a speed that would make continental drifts look like Schumacher
I'm not a huge fan of your aliases. They can add confusion (it's not obvious when you are using an alias, and you have to Airways remember the real type of the alias) and they don't have type safety (if I have an alias for String called Name I can still use them interchangeably. I can use any String where I expect a Name and a Name can be used anywhere a string is needed). This defeats the benefits of types. What I would much rather have is `newtype` or value types (don't know of a better name). These really are types and give you type safety without the overhead of wrapping the value in a new object. While ailiases are not, Value types are actually being added to the language and I can't wait for them to come.
Thank you!
These are helpful. Thanks!
No, and they don’t care. Why should they? If you want to stay on JDK 6, feel free, but know that your support costs will balloon out of control. You can still target JDK 6 compilation with Java 11 code.
This is also what I use.
This is pointless, please everyone stop writing these comments.. Downvoters don't care or need to explain why, it's because they disagree or don't like it. Also, scores change - the guy above you now has more points than the one above him. Come on, y'all.
Why they should? Because it's going to kill Java as a viable system if they don't.