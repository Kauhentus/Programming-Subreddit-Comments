It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](http://www.gwtproject.org) - Previous text "GWT" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
I haven't seen this before: function runDailyJob { local -a args=$@ env[0]="-Dsystem.ecs.version=$CONFIG" env[1]="-Dsystem.ccmr.environment=$ENV" env[2]="-Dspring.profiles.active=daily" env=("${env[@]}" $args) nohup $JAVA_HOME/bin/java -Xmx4096m "${env[@]}" -jar $JAR &gt;/dev/null 2&gt;&amp;1 &amp; } As in, I recognize what the end result would be but.... what language? and why is it defined as a function? As opposed to the poster just providing the run command without all the variable abstraction?
&gt; I refer to the way the web was originally designed OP mentioned Roy Fielding, whose REST thesis describes how the web [actually works](https://www.ics.uci.edu/~fielding/pubs/dissertation/evaluation.htm). The web is about publishing hyperlinked *resources* identified by URI, and HTML is simply the *base* representation of that resource. But the web is not at all limited to HTML. There'son HTTP has an `Accept` header. A key feature of the web is to be able to return representations in different forms, such as in different languages or different formats, allowing information to be provided in a way that works best for the receiver, whether that receiver is English or Dutch, or a web browser or a mobile application. The problem with JSF (and all component frameworks) is that they apply UI semantics to the HTML, instead of treating HTML as a way of sharing information, which makes it harder to consume that information by non-UI clients, which goes fundamentally against the design of the web.
Wow... this syntax is exactly Typescript. 
A java equivalent to this would let you write java to be run directly in the browser. It would replace the JavaScript or typescript. 
I'm not sure, but I think [Vaadin](https://vaadin.com) either does support or will support WebAssembly.
I've tried GWT, not exactly as smooth sail as Blazor and it compiles to JS which cause a bunch of issues too i.e. slow compiler, non-compatible libraries, JS interopt problem. 
Vaadin looks promising, but it depends on GWT behind the scene if I remembered correctly? 
It is what I do. But outside of my day job, is hard to find a clear objective and crack a cool project.
.Net's WebAssembly support and Blazor itself is in experimental status.
Blazor is actually pretty fun and productive compared to any SPA frameworks that I've tried. There's no analysis paralysis and you won't spend a day setting up project. Since it translate to Web Assembly, compilation is very fast and the generated code is quite performant for such pre-production project. 
I wonder if Primefaces should start thinking about doing something similar to Blazor :)
&gt; Java verisons are going to be far less substantial and there are going to be a million of them that's actually the whole point. big bang releases are neat for news articles but not much else.
&gt; J2EE ಠ_ಠ
&gt; Angular is directly inspired by JSF Source ?
I am saying that Java 6 is bad.
Oh, good point.
http://teavm.org/
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
That's interesting
IIRC, Blazor leverages Mono's WASM support which is just a CIL interpreter in WASM. Your C# is not AOT'd to WASM.
&gt; IIRC, Blazor leverages Mono's WASM support which is just a CIL interpreter in WASM. Your C# is not AOT'd to WASM. My mistake, I stand corrected.
Forwarded to other co-workers. Long indeed, but well worth. Thanks for sharing!!!
This is a shell script defining a function :-)
I guess the link could have been in English... Just telling ;-)
Indeed! The presenter isn't the most charismatic fellow out there, but there are some good nuggets in the talk. Hope they find it useful as well!
I actually enjoy his way of presenting. But what I like the most is that I had a professor who also would start the class like him, well dressed, hair neatly combed. But by the end of the class had already tugged out the shirt, hair was a mess, looking tired haha. Compare his first image, with after 1 hour, and he will be looking like my old professor (:
Someone posted an article here two or three months back showing how posts here get linked to on some of the several different openjdk mailing lists, and then readers there brigade the posts here up or down depending on whether the original post was praising or critiquing something close to their hearts. I hadn't made the connection until reading through the write-up. (It got downvoted into oblivion after being linked to on, like, one of the graphics lists.) I know they're separately run, but describing their users as disjoint groups would be disingenuous at best, and I also know you're not intellectually dishonest. Still, the "his experiences doesn't match mine therefore he's lying" crowd gets around, and I think I'm giving up on the reddit side of things. I'm still looking forward to some of the upcoming features, but I'm tired of getting trashed for daring to say that expression switches might not be the best thing since sliced time, or that the 9 release could have maybe been better handled.
Hahaha... yeah, I observed that too, after the break. That must have been a rough lunch! :D
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
http://www.dictionary.com/browse/handy?s=t
Any reason why `java.time.Instant` isn't included? From what I understood, `Instant` is the right object for application timestamps, and then convert to a zoned object when displaying to the end user. 
Ok, I thought he meant something else :)
Fixed ;)
Will it ringfence all my synergies and realise the low hanging fruit with time to market agility?
Probably worth mentioning that this isn't about the old (Vector API)[https://docs.oracle.com/javase/8/docs/api/java/util/Vector.html] - the article's actual title is "Vectorised Algorithms in Java".
😂
Yeah it's not like you have to be a Java expert to get into the book. I would say it's definitely more for intro to mid level but even advanced Java users would find it useful. When I first read it, I had to do some additional research into certain topics (e.g. really digging deep into the static keyword to understand the item about why nested static is preferable) but the book is very good about breaking different broad topics into granular items and best practices and giving a thorough explanation on why to do it. One thing I really like is that the book constantly references itself. The book will always mention other items in the book so you can see how all the items strengthen each other. Not everything in the book is about Java some things are more about writing clean flexible code and following good object oriented practices. I constantly finding myself re-reading and writing more notes in it especially as I see things come up in work that relate to items mentioned in the book. I've made it a habit to always bring it with me whenever I travel for work just to make sure I have it.
Let me ideate on that we can touch base.
Well i work with react and use `create-react-app` \([here](https://github.com/facebook/create-react-app)\) and i don't have to setting up things for my project. There is a lot of helper to start a project for react (nextjs, razzle and others) I know that angular 2\+ have `angular-cli` \([here](https://cli.angular.io/)\), ember the same \([here](https://ember-cli.com/)\), vuejs too \([here](https://vuejs.org/v2/guide/installation.html#CLI)\). I'm curious, what is your spa framework ?
Ping me later so we can set up a date for a date for a business review meeting
I don't know if this makes me want to scream or cry. I am also from Denmark, I have been writing java code for 15 years, I try to write several thousands lines a month to make sure I stay up to date on all the new things. I have project son GitHub, I have solved over 2000 problems on hackerrank / leetcode / etc. I have experience with a good portion of the java library/build/ide etc. ecosystem, I just *love* everything java. Over the past 3-4 years I have sent out over 200 applications to any position I can find with the word java in it, anything, and as of today I got a total of **zero** responses or itnerviews, not even a single mail asking for clarifications on anything, just let down after let down, a barrage of 'sorry we are moving forward with other candidates'. Just... how.
Can have a scrum of scrums fo our continuous integration to iteratively deliver our elastic architecture?
Obviously a troll. How are lambdas implemented?
That caused some cognitive dissonance for me. Not wrong, not useless, but somehow... it of place for Java. "use byte, short and float when memory is an issue"... Or maybe, "not Java"? How many floats vs double do you have to use to offset the vm starting cost? On a more productive note, I'd add that those types (especially byte) are useful when reading raw data, for example when communicating with non-Java software over a network. 
Oh I cam here to make fun of their for using that shit.
it's supposed to be an incubating module in java 11. that means supported, with a good chance it will change and evolve. if you're ok with that, and are capable of transtitioning your code, you should use it.
Javascripters should pay attention to this one: **Step 5 – Use Object for everything** 
Great pattern! I think this is why JavaScript is such a hallmark of stability and a pinnacle of language design... Jokes aside- ES6 and TypeScript for the win!
Im curious by what you mean.. do you have an example of problems youve had? I only ask because we've started migrating our apps to spring boot with a heap of profiles(messy as hell, but thats more due to egos) so im interested to hear from peoples real world experiences.
I was told : im getting no interviews, the problem is my resume, if im getting the interviews but no jobs, the problem is me. So to me it sounds like your problem is not selling yourself well enough in the resume, rather than your skills as from your comment you obv have the experience.
I know.. r/Whooosh
Hilarious! great post. 
Maybe it's not really required to be portable and serializable which would make it impossible.
I'm still a bit confused. I'm not very experienced with the Java releases and different JDKs. The "panama stuff is not mentioned explicitly here: http://openjdk.java.net/projects/jdk/11/ But from what you're saying, in two months I should be able to download an OpenJDK release with a "beta" mode SIMD api? 
The funny thing about this is that Java is actually dying so even the “good” parts don’t redeem it. 
I'm back interacting with Java on a daily basis after a 4 years break. It's been surprisingly good.
this is what I recall, so it might not be accurate. but iirc, the incubating modules should be present, but gated behind a flag to activate them.
Try Scala or Kotlin! They're like Java except without all of the unnecessary boilerplate.
This is the most angry thing I've read today.
Good point! Thanks for spotting that. Editing code in WordPress should be done carefully! Step 8 - write all your Java in WordPress?
Nice, but I think it is all around SOLID and KISS principles. 
**Sidebar** **Do not post tutorials here!** And, **read** and **follow**: [**"What constitutes spam? Am I a spammer?"**](https://reddit.zendesk.com/hc/en-us/articles/204536499-What-constitutes-spam-Am-I-a-spammer-) Your submissions and constant self promotion indicate that you are a **spammer** which is not tolerable.
It's really not.
In **Step 3 - Nothing is really final** the value doesn’t appear to change, even after setting it reflectively, because the variable is a so-called *constant variable.* These are final fields whose type is a primitive or `String` and that have a constant expression as their initializer. Constant variables are inlined by javac, so setting the value reflectively has no effect on compiled code. See JLS section 13.1, item 3. [link](https://docs.oracle.com/javase/specs/jls/se10/html/jls-13.html#jls-13.1)
&gt; Java is actually dying What makes you think that?
Why do you think it's dying? Are there any stats supporting that?
Hahaha
And to add to this, for final Object fields this trick might appear to work at first, but after the JIT has run over the accessing methods, the object reference is inlined and setting the field value no longer works.
&gt;Thanks for your time, and oh, if we get over 2,000 responses we’ll donate $1000 to Devoxx4Kids! When we pass 3,000 responses we’ll top that up to $2000! So now there really isn’t an excuse whatsoever :o)
seems very limited in usage. just use jooq lambda for the checkedfunction instead of throwing WrappedException which the devs will have to catch specifically.
I suspect this is because supporting the java.time.OffsetDateTime class will cover the support of Instant and ZonedDateTime. According to the documentation: "It is intended that ZonedDateTime or Instant is used to model data in simpler applications. This class may be used when modeling date-time concepts in more detail, or when communicating to a database or in a network protocol."
Yes, it only “works” if you set the final field with a constructor parameter. Fun fact- if you change it reflectively in the second case (final field on a class), it won’t work in code, but IntelliJ debugger will show you the changed value. What a joy to have the debugger and execution disagree! Scary fact- I saw this done for real in a test code...
How to write horrible Java: Write code in Java.
Less **self promotion**. Reddit is not a self promotion platform. More active participation. But commenting your self promotion links is a no-go there. --- I say it again: You cannot just keep posting **only** your material. This is against **reddit wide** policies.
Got a similar background, i watched the Videos on youtube by Derek Banas for basic syntax differences back then. Even the "learn in 30 minutes" Videos are easy to follow imo. Then for some practice you couls give tutorialspoint.com a shot, its free and has tons of Content. Hope it helps :)
Check the FAQ's of /r/learnjava and /r/javahelp
If you use Kubernetes to deploy microservices you'll probably use the kubernetes internal stuff to handle configuration. We still use an application-test.yml for integration tests and application-local.yml to start services locally though, so we don't really not use them. ;)
\&gt;seems very limited in usage This is intentional. It does the two things described. \&gt;instead of throwing WrappedException which the devs will have to catch specifically Try.either\(\) automatically unwraps a WrappedException, producing an Either of the original exception or the expected result.
Why do you read /r/java if you hate Java?
Because I am a Java programmer.
A class will have at least one constructor, even if it's an abstract class. For the constructor of an abstract class to be called, a subclass would need to be created. Having a test create a subclass is probably worse, but if someone is pursuing code coverage, they'd probably do it anyway.... An interface is unsuitable for a utility class, since it's almost impossible to prevent someone from writing a class that implements the interface. If there's already a `Foo` interface, the ability to put static methods into that interface might avoid the need to create a separate `Foos` utility class. But this isn't always appropriate. Having a private do-nothing constructor is still the right thing for utility classes. It's really an atrocity that someone was forced to call its constructor reflectively in order to increase code coverage numbers.
So i thought about your answers and realized that an abstract class can’t be final, so far so good but what about just using an Enum?
If you mean type inference in Java 10, you have woefully misunderstood the feature.
Maybe we should make private do-nothing constructors throw an exception instead? 
Maybe you should consider a new profession, if only for the sake of your health.
You’re right. I make good money, but I just don’t like it anymore. Do you do computer related things other than Java?
That's why we have a preprocessor that wraps every string literal in `new String("literal")`, and every int literal in `new Integer(42)`, etc. prior to compilation.
JDBC didn't include it either
No, that would be "praktisch", but that's not practical to use here.
Automatic type inference has nothing to do with Object. A lot of strongly and statically typed languages does it. You're supposed to use it in local scope where it's not ever ambiguous what the actual type is.
We want to read content, not be asked to take surveys. &gt; Surely we want r/java's opinion represented in those big industry wide surveys, don't we? No I don't really care what people think about Java in their surveys. If their survey is unrepresentative that's their problem not mine.
No, Java case expressions must be either a constant expression or an enumeration value name.
I'm glad there's a couple of extra tips for C++. 
Because developers hate Java, it’s unpopular and dying, and surveys would make that too evident to the “this is fine” circlejerk here
That's actually what I do and recommend.
The intent of interfaces is to describe a type, so I'm against that. Never thought about an abstract class -- it would work but I make utility classes `final` to inhibit subclassing. (Yes I've seen people subclass utility classes....) 
Perhaps you might want to have a look at Clojure. Give yourself few weeks to let your brain to get used to parse Lisp and to a different paradigm. Or, for a much less radical change and easier to monetize time investment, you could acquire an expertise in Kotlin.
Funny on the front page today is survey....
Report it and it’ll disappear. 
Switch != if 
Or you can improve the quality of the subreddit. Anyway, if you’re commenting on it, you didn’t ignore it. 
I'd argue its really dated, since it is 12 yrs old already... but not bad. It's like the Windows XP of Javas... lol
Ugh true, I did love Windows XP. I bet you're like a fucking wizard on Java 6 design patterns by now. Hopefully lambdas don't make you cry. ~_^
Vaadin 8 uses GWT, but Vaadin 10 (already in Beta), drops usage of GWT in favor of Web Components. https://vaadin.com/blog/vaadin-s-frontend-direction
How are you ignoring it if you’re here talking about it?
Thank you 
Oh, so you're going to double down on your misunderstanding. It's a bold strategy Cotton. Let's see if it pays off for him.
It allows them to remove code and modes. Imagine they want to start using a new bytecode. With perpetual support they always need to include the compiler path which does the lower older encoding. With it, they can delete it that generation. In otherwords, it simplifies the compiler.
I was agreeing with you. 
Type inference means a type exists under the hood. I think it's pretty clear I get that. Piss off with the condescension nr ibferiority complex. If you need that to feel superior on something so petty that's super sad. 
Lmao "java is dying" is the new "iphone killer". 
I looked at \[jool\]\([http://www.baeldung.com/jool](http://www.baeldung.com/jool)\) for exception handling, and I can make a few points. 1\) Unchecked.function\(...\) \[catches Throwable\]\([https://eclipsesource.com/blogs/2012/08/08/to\-catch\-or\-not\-to\-catch\-throwable/](https://eclipsesource.com/blogs/2012/08/08/to-catch-or-not-to-catch-throwable/)\). trylambda only handles Exceptions. 2\) trylambda's CheckedFunction extends the standard Java Function, so it can be used anywhere the standard Function is used. Same for trylambda's CheckedSupplier and CheckedConsumer. jool's CheckedFunction is a separate interface only designed to be used with jool. 3\) I do not see an Either\&lt;A,B\&gt; in jool. Perhaps I overlooked it. Throwing a UncheckedException in the middle of stream processing would kill all the stream processing. The purpose of trylambda is to allow deferred exception handling, as in the case of the url connection example. If one url returns connection refused, I will likely find it undesirable to kill a whole batch of urls processing.
Yeah problem here is, you can't make an abstract class final. So that's a bad idea for utility classes. You could use Enums which can't be subclassed and have a private constructor but maybe that's bad practice. Would be interesting to get some thoughts :).
Please, next time, follow the rules and post *Java programming related questions* in **/r/javahelp** as the plenty hints on the page and in the sidebar clearly indicate. **Post removed:** Programming help
surveys can definitely be abused, but more broadly the moderators seem determined to prevent this sub from being anything more than a link farm almost every interesting technical discussion gets some moderator nastygram posted in it about "no programming help" and presumably deleted soon after 
Always thought C++ didn't need any tips for that, with it being a main design focus of the language and all
Well I could say the same thing to the OP and you - just because you want to see survey links doesn’t mean others do. So there’s little point arguing like that.
Surely, but you used the term _we_.
Yes - it’s the Subreddits established rule.
I guess what I mean is - what's the point of asking why a subreddit that says it doesn't host surveys isn't hosting surveys? That's how it's set up. That's who it's for - people who want Java content but not programming help questions, job offers and surveys. If that's what you're after, then yeah this isn't the subreddit for you. Not every subreddit has to be perfectly suitable for everyone.
I’m not saying it has to be. Not all surveys are created equal, though. I agree that this subreddit shouldn’t be flooded with help questions, surveys, and job offers, but surveys from people like those in charge of evolving the language and platform should be allowed. Without them, we all likely wouldn’t be here.
How's memory usage?
I briefly tried it. Kind of disappointed that it could not compile the program into a single EXE and nothing else. There's a directory with their run-time, etc. that are required to go along with the compiled program. Performance didn't seem any better than when using a JVM.
That sounds reasonable.. what about handing over a self contained install or difficulty in reverse engineering?
Excellent. Glad you have that covered.
And how do we discuss openly about these rules, and how do we change them? 
I haven't used java 10 yet so haven't ran across that yet; however, when I do use java 10 that will annoy the hell out of me so I voted for the issue.
You could try [NullAway](https://github.com/uber/NullAway). It's a plugin for [Error Prone](https://errorprone.info/), which does compile-time warn/fail checks for various things. I think Error Prone itself also has experimental checks for @Nullable and friends but they're disabled by default, last I looked. IIRC NullAway assumes that fields, method return values, and method parameters are non-null by default, and you have to annotate them with @Nullable to say otherwise, but local variables can be null.
Don't know, we've never shipped to production, nor ran our software
I am wondering this as well.
Catching Throwable is bad, because you shouldn't try to catch and handle Errors, you should just let the application die.
Awesome, thanks for your input :)
Wrt checker framework, not only does it require a lot of stdlib to have been annotated by their team (I've found plenty of places where it's not), but it does not work properly with Java 9+.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I haven't found anything better than `public final class FooUtility { private FooUtility() { throw new UnsupportedOperationException("Instantiate a utility class? Are you daft?"); } }` (okay I don't actually use that for an exception message). It's more-or-less idiomatic and communicates the intent. Really though, it's a case that Java just doesn't handle well. 
I disagree with you, therefore I downvote your comment. I also downvote the boring surveys. No need for moderating neither you nor the survey, though.
Why did they get to occupy *the* java brand subreddit though? Who are they and who gave them the entitlement?
Yep! I have posted a few, [like this one](https://www.surveymonkey.com/results/SM-87Y6K3BY8/), and they have eventually been removed. Sad!
&gt; legitimate java ecosystem engagement. Spoken like a true ~~shill~~ developer relations strategist.
You looked at Vavr? They support Try, Either, and checked lambdas.
Would Lombok work for you? We've had a lot of luck reducing code with that.
Autocloseable please? https://github.com/javaee/jpa-spec/issues/77
how do you feel about the diamond operator?
I've heard of this method, it's the best way to avoid performance issues. Also number of incident tickets is extremely low, resulting in happy management.
First I've heard of it. Naturally I'm biased, but at a glance I think the trylambda API is an improvement. For instance, I see they have Try.withResources1-Try.withResources8. Without looking, I guess their internal code looks like try (res1; ... res8;) {} Where trylambda works by nesting. try(res1;){ try(res2;) {...}} Allowing as many resources as needed as well as providing targeted error handlers at each level of nesting. Also, vavr Either is an interface. It seems that would allow definition of new Eithers besides Left/Right. trylambda's Either is a closed class hierarchy. Either is an abstract class with a private constructor to prevent class instantiation. Only the two final static inner class descendants Left and Right can reach it.
If possible it always be used on any class with type parameters. Generally it should be the most specific interface the objects you want to store/use/etc all have in common. Sometimes it should be a concrete class depending on usage. The actually use of the type parameters can vary a great deal from storage to utility classes though, so it's hard to say.
Any serious company killing it's Devs with legacy Java versions deserves to have this enabled over night. 
You could use Optionals in your code, sonarqube does also some checks
Configure it as error level.
Did you even read the question? Lombok generates runtime null checks, not compile time. You even failed to mention that Lombok has null-checks. As it stands, your comment is the answer for a completely different question.
Optionals would not protect you from the following code: public @NotNull Optional&lt;Foo&gt; getFoo() { return null; } A compile time check would.
I like Error Prone. It works as a replacement compiler for Maven, so it drops in fairly easily into the build and doesn't slow it down considerably. 
Never knew lombok had a notnull annotation. But what's it's use though? wouldn't the runtime throw the same exception without the annotation?
Yes, but the main advantage is that the exception is closer to the error rather than at a later stage. If you assume that a parameter passed to a method is non-null, you'll get an exception at the start of the method rather than further down. This applies even more if it's a constructor that sets a member, which only throws an NPE when a public method is called.
You can configure IntelliJ to treat null related errors as compile errors, see null4j : https://github.com/cosee/null4j/blob/master/README.md
Self-employment is always an option if you think you can create something that will sell. That's the path I took, and future employers were impressed that I was writing apps and selling them on my own.
Self-employment is always an option if you think you can create something that will sell. That's the path I took. I worked part time in a job unrelated to programming and wrote an app for a niche market that I sold. When I applied for jobs later, employers were impressed with what I had done since it not only proved my ability to code, but also my ability to communicate with end users.
Yeah but that's particularly bad code. If that is getting in your code base you have other bigger problems. Using optional should make null checking obsolete.
I don't know why you are being downvoted, this is the correct solution. It's literally the point of optional.
You've taken that example at face value. Replace with returning directly from another method that accidentally returns null. Now your method is returning null too. Optionals do not free you from checking for nulls. Optionals in tandem with static and runtime checking of nulls protect you from NPEs. Optionals on their own is not enough.
Not java's optional; it was designed to represent the notion of stream operations that have no answer (such as .findFirst() on a zero-length stream).
How does what you said, disagree with what I said ? You have just defined an example of a null value.
I am now.
&gt; Write explicit null-checks (x.getClass() is a cheap way to do it Is it faster than if(x!=null) or x!=null?...:...? 
lol typo
The point is that this interface is NOT ENFORCED by the language. Any library method could return a null at some point and if you aren't careful then you're going to get an NPE. Hell, even an Optional object can be null. 
&gt; Replace with returning directly from another method that accidentally returns null. It's not quite that bad. If you have another method that returns a nullable reference of some type, that can't be converted directly to `Optional`. So it's somewhat difficult to accidentally return a null `Optional`. Of course it's still possibly to explicitly return `null`.
`Optional` is suitable for any return value that might be absent, whether from a stream or from some other source. See `ProcessHandle`, the module APIs, and the new HTTP/2 APIs. There are other places in the JDK that still return nullable references, and in principle they ought to be retrofitted/augmented to have `Optional`-returning overloads, but it hasn't been done yet.
That's up to application server vendors, as only the dropped modules from Java 11 would block running Java EE 8 on top of it, and those could be added back as jars. Of course, a properly modularized Jakarta EE spec and implementations aren't even being planned yet, so I would guess "years" would be close enough.
I've just posted a survey to see whether /r/java readers would like the rule prohibiting surveys to be relaxed.
Note that no moderators have participated in the discussion thus far. It seems draconian that a survey on a purely technical issue (such as the one you posted) would be removed. However, it is a survey, and the rules clearly state that no surveys are allowed, so presumably the removal was justified on that basis. That said, it seems to me that some surveys ought to be ok and others are not ok. I'm not sure how to characterize what surveys are ok though. Perhaps you or others can make a proposal about what kinds of surveys ought to be allowed.
And my point is if your coders are returning null optionals - they are the problem, doesn't matter what the language does. 
You can't retrofit existing API like that; it would break backwards compatibility.
Possibly. The JDK core libs themselves do this. The odds that it'll have any measurable effect whatsoever on your codebase are very small.
See this answer by Brian Goetz (who led the work on lambdas and the stream APIs): https://stackoverflow.com/questions/26327957/should-java-8-getters-return-optional-type/26328555#26328555 
Ah I see. Thank you
I have noticed that, and hope some sort of discussion occurs. I’m sure we can design a fair algorithm to determine worthiness!
Fwiw, `Option&lt;T&gt;` is where modern java is going, for the "type `T`-or-sentinel" problem. Also, it's worth noting this is a special case of a union-type `T`-or-`S` (e.g. I have a function that can return a `String`-or-`URLConnection`), where the 2nd type is just a singleton/null-ish type.
It sure does matter what the language does. Some languages simply disallow null and indeed Optionals work in these languages as you would expect. So... yes, stronger static verification outside of the language is useful. Besides, I just remembered the OP is talking about NotNull rather than Nullable, so Optionals don't even really come into play here. Despite what you said earlier, this is not what they should be used for. Only ever return Optionals, don't accept them, let the caller decide what to do in the event of a non-existent value. You promote excessive checking by passing the burden down, this is one of the reasons the NotNull annotation is even used. 
Option&lt;T&gt;? I don't think that exists. Optional does, but existing API cannot be retrofitted, and isn't supposed to be. See amongst many other sources, the very words of Brian Goetz on the purpose of Optional. It's certainly not to bulk replace all methods that might return null. The direction java is going is instead things like getOrDefault and computeIfAbsent (proof? Well, those were added; an optional-returning get method isn't in j.u.Map and could be, but it isn't). 
I've started writing some of my own Error Prone checks to trap some common design problems we hit in our internal APIs, works really nice - altho the documentation is largely non-existent so it's a bit of grok the source of the existing checks, and trial and error. 
I realize that. If a library were returning null optionals, I'd probably stop using it as its a bad sign. I have never encountered this, have you ?
Of course. By “retrofit” I meant to modify an existing class to add an overload with a different return type, leaving the old one in place.
That answer doesn’t say anything about streams. Optional was *introduced* with streams and it was first used with them, but that doesn’t mean it’s intended to be used only with streams. It’s perfectly reasonable to use Optional with other methods that might not have a result. Consider `ModuleFinder.find()` for example.
Yet there are no overloads taking/returning them in e.g. `ResultSet`, and last I checked some drivers (MySQL at least) don't actually support them...
Kotlin interface method default implementations are not visible in Java 8 as default methods for example. Generally, Kotlin is mostly aiming at Java 6 for compatibility, and instead of supporting Java 8 functional interfaces, streams and so on, they mostly reinvented the wheel with a more limited, and not compatible version (KFunction, Sequences). 
I was in a q&amp;a session avlbput this at Devoxx UK last week. Honestly, it doesnt' look bright. The session was almost deserted and the peple on stage spent aout 30 minues talking just about the naming mess (javaEE -&gt; ee4j -&gt; jackartaEE). After that, we finally saw a roadmap and what they plan is. as soon as the oracle -&gt; eclipse code drop is completed, expected Q3 2018, thry will try to build the new Glassfish. Then they will release a JakartaEE 8.0 ( or 1.0, again 10 minutes spent discussing the version number). The specification versions will be 1-to-1 with JavaEE 8, so same requirements (i believe, jdk 7? Not sure). No plans at all for after that, i asked if there is a plan to integrate with modern tooling like Microprofile or Vert.x that are is Eclipse as well, their answer was ¯\\\_(ツ)\_/¯. 
\&gt; CoffeScript became irrelevant because it wasn't nothing without the systems language, JavaScript. Not at all, CoffeeScript became irrelevant because ES6 adopted most of its features. 
Sure, CoffeeScript never hit a huge market share on the FE, but it was a viable option and offered real benefits over ES5. Same with the Java alternatives.
You can read whatever you want in what you find on the internet
Can people please just stop using and linking Tiobe? It's a complete rubbish index that's based on a weighted average of hits in a number of search engines. It's an utterly rubbish way to measure popularity. All it does is measure how 'sensitive' a language is to false positive hits in a text index. The only thing that makes Tiobe, a device created to get traffic to a consulting company, credible is people claiming they are credible. 
&gt; Yet there are no overloads taking/returning them in e.g. ResultSet In more recent discussions around ADBA, it has been made clear that the many many overloads have been "regretted". ADBA will only have API akin to JDBC's `T ResultSet.getObject(int, Class&lt;T&gt;)`. You could argue in terms of API consistency / regularity, of course, and I invite you to propose the methods on http://mail.openjdk.java.net/pipermail/jdbc-spec-discuss &gt; and last I checked some drivers (MySQL at least) don't actually support them... That last time was more than 3 years ago: https://insidemysql.com/mysql-connectorj-5-1-37-has-been-released/ Fact checking is king, these days :)
That's very good for you! :)
Not only performance issues. Vulnerabilities, UX problems, ordinary bugs, and change requests. All gone!
Everyone's always growing double digits. This is every manager's wet dream! Where can I buy stocks?
Thanks for adding to the conversation :\)
Until Java has value types (or even non-nullable types), `Optional` is only half the solution. 
The person you're replying to works for Oracle in the JDK team.
"strictly" and "TIOBE" in the same sentence doesn't make much sense. The complete analysis isn't worth it because of TIOBE.
js
 &gt; With perpetual support they always need to include the compiler path which does the lower older encoding. There is no backwards compatible compiling as far as I'm aware. For example `invokedynamic` (Lambdas, etc.) are not compiled into Java 6 compatible code, the compiler simply refuses to compile it. So it's not, at least not as far as I am aware, "we have this big compatibility layer for Java 6" but rather "we have to fail if we encounter this". Also, I'm afraid that this is just one more push to make sure that people use the paid LTS versions.
Thanks for sharing your experience! I sadly don't have a lot of real world experience with Kotlin. Couple questions: - Where does the targeted JVM show? Did you mean perfomance-wise? - How exactly does reduced boilerplate lead to spaghetti code? - Is there a reason why you say the functional style causes spaghetti code? Is there something that compelled have functional-style code in a Kotlin project that you wouldn't have in a Java 8 project? Also: Implicitly typed public properties are typed. Changed the implied type should be done as carefully as changing the explicit type. It should also give you the same compiler warning. And just because you can doesn't mean you should. Maybe you should talk about coding conventions with your team (especially with your spaghetti code in mind)? And I really never had a problem with lack of documentation. I always found what I looked for. Granted, as a Java veteran I did not look at the String documentation.
&gt; Where does the targeted JVM show? Mostly in compatibility with newer Java libraries that uses streams or functional interfaces. Mapping Streams to Sequences or KFunction to a Java functional interface is often ugly. You can use the Java stuff in Kotlin obviously, but that is then again not idiomatic Kotlin. &gt; How exactly does reduced boilerplate lead to spaghetti code? Difficult to say, but as you can write Kotlin code more compact, a Kotlin function that is only 10 Lines large can easily have an "internal complexity" of a Java function that is 30 lines large. Kotlin code looks still okay-ish when in Java, you would have created some helper functions, and in the long run that easily leads to bad Kotlin code in my experience. &gt; Is there something that compelled have functional-style code in a Kotlin project that you wouldn't have in a Java 8 project? The `.?` operator and similar things sometimes make using `null` more attractive than other methods of handling errors or missing values, but having nullable values also makes the code difficult to manage in the long run as you often forget why some things can be null and error handling becomes less explicit than say, checked exceptions. &gt; It should also give you the same compiler warning. And just because you can doesn't mean you should. Maybe you should talk about coding conventions with your team (especially with your spaghetti code in mind)? The compiler(IDE warning is relatively new IIRC and still, a property is part of an interface of a class and I think you should be forced to think about the type you want to use. Obviously we as a team review each others code sometimes, but it's just in my experience that Kotlin leads very quickly to writing spaghetti code, and I never had that problem in Java. &gt; Granted, as a Java veteran I did not look at the String documentation. The Java String documentation also has lot's of interesting infos for veterans, like about multi character chars (ints vs. chars), codepoints. it also has practical consequences, for example the Java documentation for `CharSequence` says that `CharSequence.toString()` should return a String that contains exactly the chars that the `CharSequence` represents. In Kotlin, there is no such guarantee, so strictly speaking you'd need to use a different method (copy each char separately or something like that) when you want to convert an arbitrary `CharSequence` to a String.
Looks like Spring has won. I hope they're happy now.
In Payara's case, the target is to be compatible with JPMS when Java 11 comes out. That means that Payara Server/Payara Micro will run on Java 11, not that it will make use of modules yet. There is a lot of discussion on the mailing lists at the moment about how to proceed, but Jakarta EE still has a long way to go. The roadmap is best described in [this InfoWorld article](https://www.infoworld.com/article/3269210/java/java-roadmap-eclipses-jakarta-ee-enterprise-java-takes-shape.html)
In Payara's case, the target is to be compatible with JPMS when Java 11 comes out. That means that Payara Server/Payara Micro will run on Java 11, not that it will make use of modules yet. There is a lot of discussion on the mailing lists at the moment about how to proceed, but Jakarta EE still has a long way to go. The roadmap is best described in [this InfoWorld article](https://www.infoworld.com/article/3269210/java/java-roadmap-eclipses-jakarta-ee-enterprise-java-takes-shape.html). It seems to be behind a paywall now, but it used to say that when everything is transferred to Eclipse, there will be an Eclipse GlassFish 5.1 which will be Java EE 8 certified in Q3. Then, the Jakarta EE 8 certification will be ratified and there will be an Eclipse GlassFish 5.2 which will be the first certified Jakarta EE 8 server with a target of Q4. Jakarta EE in Eclipse is very much a community effort and the discussions are all happening publicly like, for instance, should we make composability a key part of the platform? What about profiles, should we create more? There are a lot of reasons to be optimistic about Jakarta EE. In my opinion, the way that MicroProfile has developed is a good template for what to expect from Jakarta EE. It's already attracted new companies - Lightbend and Microsoft in particular. While Jakarta EE might seem to be a bit stalled right now, there's a lot of behind-the-scenes work going on. The "real" work (as I see it) is continuing in MicroProfile though. I fully expect those specs to end up in EE4J - whether they get to be part of Jakarta EE 9+ is, in many ways, up to the community (though I suspect they will).
Since it says "No surveys, no job offers!", I can only assume that the rule was once created to ban commercial surveys, where companies / marketing agencies abuse reddit for market research. The very thought that technical oriented surveys like the mentioned Baeldung ones could also exists didn't occur then. Now the mods are perhaps upholding a rule for the sake of upholding a rule, without giving any thought to why the rule was actually needed. It's like taxi drivers in the UK were required to have a bunch of hay on the passenger seat. That rule was created to make sure a horse always had something to eat, when horses were still commonly used for transportation. Of course when horses stopped being used for that, the hay rule didn't make sense anymore.
The last big project we wrote was using pure java ee / cdi and it worked out really well.. I just recently jumped on the spring boot bandwagon and I don't think I can ever go back. Spring has so much support. I'll keep an eye open however
I've used Kotlin in a Java codebase. It's pretty close to 100&amp;#37;, haven't ran into any issues in practice.
I'd like something that can be compiled with Graal's `native-image` tool: http://www.graalvm.org/docs/getting-started/#native-images. AFAIK only https://hc.apache.org/ can be compiled through that. Sadly, it uses unbounded Thread queue (`Integer.MAX_INT`) for receiving incoming request...
I think you are misunderstanding me. When you say "Target 6/source 6" you instruct the compiler to use only language features and bytecode from 6 era Java. Which means that if newer bytecode comes along (such as invoke dynamic) that the compiler might want to use, it can't, it must use what was available 6 era. As far as I know, setting a target different than source is unsupported. What is and will always be supported is running 6 jars. While the compiler may no longer be able to make a 6 compatible jar, the VM will always support them.
Ahhh, the truth reveals itself!!! You don't want surveys because you don't think the opinion of the common guys count huh? I know your kind!
&gt; Last Friday I saw Mark Reinhold – Chief Architect of Java Platform say that they regret putting Serialization in Java. Apparently, around 1/3 security flaws in Java come from Serialization alone. Also, we are meant to use JSON, or databases or something like that… Could someone explain this to me? Why is Serializatiom bad/why does it cause security flaws? 
I hate it when Scala zealots try to derail Kotlin threads with their "Scala does that too!" comments. **Please** be better than that.
&gt; It's certainly not to bulk replace all methods that might return null. I'd suggest it's to get the type-system to catch (what would be) Null Pointer Exceptions, at compile-time. That is, to patch the problem that there is a value which type-checks as `String` and `List` and `Date` and ..., and in-practice is used as a sentinel value purely because it's easy to get it past the type-checker. Both `getOrDefault` and `computeIfAbsent` are extremely useful even when `null` is nowhere in the map. (I hadn't known about `computeIfAbsent`, thx for pointing it out.) An `Optional`-returning `get` would indeed make sense. (I can only speculate: rather than add another method `getAsOptional` they opted to just let people type `getOrDefault( …, Optional.empty())` themselves.) Anyway, I suspect we're in overall agreement. Both `@NonNull` and `Optional` are ways to get the type-system to be able to detect NPEs before they happen. For writing new code, I lean towards using the solution which relies on the core object-system, and you prefer the (less-typing) route of annotations. And maybe you're right, maybe future Java 12+ will double down on `@NonNull` rather than `Optional`. I suspect not, and was just providing my counterpoint to the discussion.
He was more saying why can’t the surveys just be posted, not telling you specifically that you must take it. Allow the post and if people don’t want to take it, then they don’t take it. But those who care to contribute can contribute. 
Useful article.
how is this dockers fault if your environment runs out of memory ? i think you dont understand the advantages of dockerd applications
Java "Microservcies" Blog . :/
It's not that easy. What are effectively "Java EE" jobs are expressed in vacancies in a lot of ways. If you search for: java (jboss or wildly or Weblogic or WebSphere or glassfish or j2ee or "java ee" or jee or jsf or jpa or cdi or ejb or jms or eclipselink) -spring [link](https://www.indeed.com/jobs?as_and=java&amp;as_phr=&amp;as_any=jboss+wildly+Weblogic+WebSphere+glassfish+j2ee+%22java+ee%22+jee+jsf+jpa+cdi+ejb+jms+eclipselink+&amp;as_not=spring&amp;as_ttl=&amp;as_cmp=&amp;jt=all&amp;st=&amp;salary=&amp;radius=25&amp;l=&amp;fromage=any&amp;limit=10&amp;sort=&amp;psf=advsrch) You get **5827** jobs. Searching for java spring -jboss -wildly -Weblogic -WebSphere -glassfish -j2ee -"java ee" -jee -jsf -jpa -cdi -ejb -jms -eclipselink [link](https://www.indeed.com/jobs?as_and=java&amp;as_phr=&amp;as_any=spring&amp;as_not=jboss+wildly+Weblogic+WebSphere+glassfish+j2ee+%22java+ee%22+jee+jsf+jpa+cdi+ejb+jms+eclipselink+&amp;as_ttl=&amp;as_cmp=&amp;jt=all&amp;st=&amp;salary=&amp;radius=25&amp;l=&amp;fromage=any&amp;limit=10&amp;sort=&amp;psf=advsrch) Results in **6423** jobs Without the exclusions it's 11463 jobs for [Java EE](https://www.indeed.com/jobs?as_and=java&amp;as_phr=&amp;as_any=jboss+wildly+Weblogic+WebSphere+glassfish+j2ee+%22java+ee%22+jee+jsf+jpa+cdi+ejb+jms+eclipselink+&amp;as_not=&amp;as_ttl=&amp;as_cmp=&amp;jt=all&amp;st=&amp;salary=&amp;radius=25&amp;l=&amp;fromage=any&amp;limit=10&amp;sort=&amp;psf=advsrch), vs **12108** jobs for [Spring](https://www.indeed.com/jobs?q=java+spring&amp;l=&amp;radius=25). There's a few more variants to try, but the main problem is that for Spring you can search for "java" and "spring" and get various accurate results. For Java EE it's a whole slew of names. But when looking at it a bit ore accurately, one sees that they are fairly equal with Spring only recently having overtaken Java EE. I did very similar queries a few years ago and then Java EE was slightly ahead. The fun thing is that Spring fans have been saying for almost as long as that Spring exists that Spring is way ahead, but that's not true. 
I guess a lot of this is kinda just preference, as I think the later reads better than the former. 
It isn't Dockers fault. It is Java's problem. It can't see the limitations put in place by Docker. Java is falsely under the impression it can use whatever the entire system has available. This means Java doesn't see the limit, doesn't do anything to try and keep below this limit. To fix this you need to either instruct Java that there is a specific limit OR you can use the new experimental flag to point it towards cgroup so it sees Dockers limit.
I have asked them to join in a PM. You can, too: https://www.reddit.com/message/compose?to=%2Fr%2Fjava
&gt; The sad thing is, that now Spring is the 'standard' Spring isn't a standard, it's a product. &gt; getting a job requires you to sign up for the 'Spring' religion. The Oracle DB is one of the most widely deployed databases out there, and pretty much any Java job will require PL/SQL knowledge. Does that make PL/SQL a religion? This just goes to show how [right](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html) Uncle Bob is. Don't follow the Spring religion or the JavaEE religion or the Oracle religion. Frameworks, app servers and databases should exist in the periphery of your application's architecture. Your religion should be to write Clean Code and pure business logic (say no to `@Autowire`, constructor injection 4ever!). Then, it doesn't matter what job you find yourself in.
I believe Oracle is fixing this. Newer version of java would be honouring Docker's limits https://blogs.oracle.com/java-platform-group/java-se-support-for-docker-cpu-and-memory-limits
I haven't seen that pattern in the JDK yet, do you have a particular case in mind? `java.util.Objects::requireNonNull`is a lot clearer and explicitly designed for this.
Non-nullable types is actually a feature that's missing from Scala. One of the biggest things missing from the language in my opinion.
Besides that field injection is a crime anyway!
&gt; From Java 9 onwards there have been extra options added to the JVM: That was actually back-ported to Java 8 ages ago, 8u151 by heart. We're on Java 8 and have been using that option for about 2 years. 
Effective Java is the bible of this language and has recently released it's [third edition](https://www.amazon.co.uk/Effective-Java-Third-Joshua-Bloch/dp/0134685997/ref=pd_lpo_sbs_14_t_0?_encoding=UTF8&amp;psc=1&amp;refRID=3T4CA7DG1964JW794GQC)
The information is out of date, check /u/nutrecht's comment and this: https://blogs.oracle.com/java-platform-group/java-se-support-for-docker-cpu-and-memory-limits If intentional, the article is click bait. 
You didn't read the post did you?
It looks like in your [submission](https://www.reddit.com/r/java/comments/8jluhi/can_this_code_be_improved/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Which information is outdated? The link you mention states the same as the article, there are flags to allow the JVM to see the cgroup information. But this isn't default behaviour, you'll need to omit the Xmx flag and add the two mentioned in the article. 
True, the flags have been backported and this was mentioned in the article. You can use these flags from 8u131 and later. I've updated the article a bit to make this more clear.
Consider yourself lucky, some work colleagues still have to deal with Java 1.4 running on Red-Hat 5 servers.
Why would you like to kill the java-process by docker ? Or throw an out of memory-exception. Both things will stop your application (your users will not be happy). Why not do a heap-dump instead so you can debug and fix the problem (there is an jvm option for that (-XX:+HeapDumpOnOutOfMemoryError)). Any C-program can use ALL your memory on your machine + Swap. Give the jvm all avaliable memory on the machine (it will not use it unless necessary).
I was not concerned about reverse engineering. As for installers, I don't need many features for that, so a simple SFX that extracts files to a few places is enough for me.
I'm not sure this answers your question, but `@lombok.NonNull` is compiled to a NPE-throwing null check.
Hopefully your application is written in such a way that it’s clustered and that there are retries in the clients so that a server crash isn’t event noticed by your users :)
&gt; True, the flags have been backported and this was mentioned in the article. Well you added it after I mentioned it. But you're welcome I guess :) Also there's some backticks that accidentally ended up in your post after your update: -Xmx`cat /sys/fs/cgroup/memory/memory.limit_in_bytes` 
You're welcome :)
&gt; -Xmx`cat /sys/fs/cgroup/memory/memory.limit_in_bytes` Uh, it doesn't seem like you should be setting the heap portion of your JVM to use the total memory available; it's not the only memory used by the JVM. Add them both and you'd go over. 
How? Simple: I've written [a library](https://github.com/Hexworks/zircon) which is so compatible with Java that no one noticed that it was written in Kotlin until my users were asking for some Kotlin dsls.
I still have some Java 5 Websphere systems to deal with. But those are pretty stable, and soon to be discontinued. 
Cool, I'll give that a shot. Off the top of your head do you know if you can backport Kotlin code to Java 8? lots of jobs I see are still on Java 8. Edit: i should honestly just do my research - feel free to point me in the right direction
No cuz there is get/set which is better :)
Let me preface this by telling you that I am speaking on behalf of myself, not of the entire mod community. I fully understand the desire for high quality surveys that could drive the Java ecosystem forward. Yet, I find it alienating that *you*, the *community*, is now arguing about the *"No Surveys"* rule that was established because of *multiple requests* from *you*, the *community*. We established the rule because at a time the subreddit was flooded with low quality surveys and with plain and simple programming help masked as surveys ("[Survey] should I use X or Y for Z?). I have looked through our *moderation log* and found that we, the moderators, do not actively remove any surveys. It is *you*, the *community*, who *report* these posts *multiple times* until the amount of reports exceeds the threshold for our *AutoModerator* to remove the post. Personally, I find it sad that quite often perfectly valid, good quality, interesting posts (including surveys) get downvoted to oblivion and/or reported multiple times so that they get removed. Also, the moderation log hinted a pattern that posts from certain users (of which quite a few are active in this discussion) get frequently downvoted and reported. In reddit's terms frequent downvoting of content is considered spamming. It is very disturbing and sad to see that as soon as certain users post anything, they get downvoted and/or reported, no matter how high quality or interesting their content may be. So, in the matter of the surveys I have to brush us moderators off because we are not the culprits here. *You*, the *community* obviously have something against this content because otherwise it wouldn't get reported sufficiently often enough to be removed. Same applies for "Spam" reports. Certain users automatically seem to get downvoted and reported for spamming - often only mere minutes after their posts. I won't publish the names of the users that receive frequent reports, so there is no use in asking. 
Good
How can the rules be adapted? No surveys from anyone is a bit ridiculous.
Let's open the discussion a bit further: **You, as the community, are now asked to come up with a practical rule** that can't easily be misused. Still, keep in mind that the rule must remain as simple as possible, yet, it should have as few loopholes as possible.
Can we implement some sort of approval process after outlining the qualities of a worthy survey? I would be willing to assist.
Decade plus for vars. Sure, it took some time, but just because C# jumps on pretty much every bandwagon out there does not mean that it necessarily is a good idea. I still find the usage of var everywhere in C# code super annoying, but luckily modern IDEs such as Ryder (built on the superior platform of idea) help reason over this mess. For the getter/setter stuff we have Lombok. Check it out. 
I am absolutely not opposed to your suggestion, but I have to think about feasible ways to implement it with respect to the lifetime of posts. An approval process would probably be doable, yet, the problem with reddit posts persists. What would happen if an approved post gets reported often enough to exceed AutoModerator's removal threshold? (Exactly what is happening currently.) There is no way that the reports coming in can be "ignored" by reddit and the Automoderator. There is an "Ignore reports" setting, but that doesn't really do much in terms of incoming reports. It should stop the reports from coming in, but for some reason (that only the creators of AM know) AM still counts the reports. In such a case, we mods would need to constantly keep an eye on the moderation log and reapprove such posts. Reddit's system knows something called "Approved submitters". Again, this is just to allow people to post in subreddits where no open discussions by everyone are allowed. AM can detect approved submitters and automatically approve their posts - at the time of the post being created. AM has no concept of state and so, later reports would again trigger the whole mechanism. I doubt that there could be an AM rule created that checks for the combination of "approved submitter" and "report threshold" and then keeps the post approved. Sure, we can now argue that most likely such surveys would be low frequency and that we could do all of that manually - and I even agree on that point. The only drawback is when we mods are offline and then not looking at the moderation log. Again, a post could disappear because of AM's report threshold and then be lost until a mod digs through the log. Well, all the above were just my immediate thoughts on the matter. As I said in the beginning, I need to think about it.
Can the AutoModerator threshold vary? Might we also be able to tag the surveys, and allow users to choose whether or not they are hidden? I’m thinking of something in terms of the NSFW tags I’ve seen.
&gt; Can the AutoModerator threshold vary? Unfortunately not. The threshold is only a constant. &gt; Might we also be able to tag the surveys, and allow users to choose whether or not they are hidden? You *might* have brought up a good idea here. Tag - no, but *flair* yes. Using a special *flair* that can only be set by certain people (which, AFAIK is possible on reddit) could make it possible to create some form of a "do not ever remove" rule. Very good thinking! Thank you!
Please, recheck my last comment. I've edited it while you were replying. I had misread your statement a bit and added further clarification. My concentration is not the best today. Been a long day with a very short night...
Java 9 is deprecated. [Java 10 got some love for docker.](https://blog.docker.com/2018/04/improved-docker-container-integration-with-java-10/)
Just use Lombok dude. It's way better.
Except for the part that it's reviled by portions of the Java community.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Yes, it shouldn’t work, it isn’t using the container and other JVM memory next to the heap. It does seem to work though... docker probably is a bit lenient here
I'm the moderator in r/JavaServerFaces (although that one did die a little), but I've seen it happening that a post I posted myself there was immediately flagged as spam, but being moderator there I could also immediately approve it again. Something in Reddit's system is or was not so smart there. It's probably more of a discussion for meta, but what Reddit might need for the spam reports is perhaps what DZone or Stackoverflow has (or had, haven't been active there for a while), which is simply listing the people who reported it as spam. That way you see if it's the same people over again. I guess with my frequent posts here I must be a target too, as I frequently get comments along these lines whenever I post something about Java EE. 
I’ve made one app which was a simple game where you guessed numbers that’s where the bulk of my java knowledge comes from in terms of strict coding. But I have worked with no sql and sql databases when it came to containers and cloud computing.
Java concurrency and, Java8 syntax and constructions (All new things like Executors, Functional Interfaces, lambda syntax, etc). Also some framework (Spring or something like that)
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Really? Who says? I'm a professional Java user who loves Kotlin and so do all of my coworkers.
What? Do you mean to say getters and setters are better? Because... Nope.
Java is looking at implementing data classes that are essentially classes with simple fields and no other logic than getters and setters. Kind of like structs in C#. I myself switched over from C# 5 years ago and still miss auto properties. I used to miss LINQ, but luckily Java has streams and lambdas now. 
&gt; "No java.util.Objects instances for you!" http://hg.openjdk.java.net/jdk10/master/file/be620a591379/src/java.base/share/classes/java/util/Objects.java#l58
I said portions of the Java community. I have co-workers that love it, and coworkers who hate it. Personally I think it sounds cool, but not worth learning. 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Title gore.
You should see the bytecode that Kotlin compiles to and you'll see why Java is still preferred over it.
If, for whatever reason, you need to use an older version of Java, first consider upgrading because you really should (anything Java 8u131 does not support these options), if you can't, then I raised a PR for Jenkins docker a while ago to automatically decide this a sensible limits and set the correct flags. The code is originally based on Fabric8 Java images. You can use the same approach for your image. The PR is at [here](https://github.com/jenkinsci/docker/pull/451). 
Tl;dr: do some homework on what the position requires such as asking for a job description or reaching out to a developer to find out their toolsets - then study accordingly. Ask for a job description and try to figure it out from there. It's really hard to say from the information you've given. The questions can range from "can you print hello world from scratch" to being able to articulate java software architecture design. If you mention data bases, make sure you can answer questions on topics like jdbc and connection pooling. Some folks mentioned object relational mapping and dependency injection, find out from an internal source if they're using j2ee at all, and if so, learn about the topics if you're not familiar. Going over the top level docs can help too if you have time. 
yup you see wanna read something get[ctrl+space] wanna set something set[ctrl+space] wanna check something is[ctrl+space] properties sucks too much scrolling I am lazy! Piece :)
True, let's forget about Kotlin. But Kotlin solves the null pointer exception...
The page for data classes can be found [here](http://cr.openjdk.java.net/~briangoetz/amber/datum.html). You will be able to add other methods, as well as add your own implementation for methods like `equals()`.
It's better then the current implementation 
If I was going to have us switch to something else it'd be C++ or C# definitely not Kotlin. Java is fantastic as-is, and the features of Kotlin seem...unnecessary. 
No.
Java has bindings for a lot of the ai frameworks, so I don't see why not if you're more comfortable with Java than a more targeted language.
Just run straight on the native OS. The JVM is already a virtual machine with its own containment.
&gt; but luckily modern IDEs such as Ryder Not really : https://youtrack.jetbrains.com/issue/IDEA-188689 Same issue in Visual Studio for 10 years now...
Yes. Because it means the Java APIs are much easier to learn and explore. If I don't know what something might be called I can go .s and get all the setters, .g and get all the getters. In C# I have to know WTF everything is called or do what I usually have to do - scroll down alphabetically over and over again.
Like Scala is so 2015 and dead. So will be Kotlin. In a couple of years I'll be able to say Kotlin is so 2018.
That's because you haven't had to maintain anything long term with it yet...
&gt; Most applications in production today are still using Java 8 This made me die a little inside. I work on a multi-million dollar DoD program where we're still stuck on Java 7. I dream of being able to finally use the advanced features of Java 8.
You should see Java code and you'll see why Kotlin is still preferred over it. But in all seriousness I feel like your response is an attempt at a thought terminating cliche. Why would the bytecode be such a deal breaker?
Yep effective java
Docker is not a virtual machine, it is a configuration manager.
What do you mean? It outlines that you will likely be able to here: &gt; The default implementations of constructors and Object methods is likely to be what is desired in a lot of cases, but there may be cases where we want to refine these further, such as a constructor that enforces validity constraints, or an equals() method that compares array components by content rather than delegating to Object.equals(). The natural way to denote this would be to declare explicit versions of these members, and have this suppress the generation of the implicit member.
I seen it, so I preferred Kotlin
I teach Java (in 80 hours modules, so just the basic). The lack of HTTP client and JSON capabilities in the JDK API is quite embarrassing. 
I am right now...
Experience has taught not rely on finalizers on GC languages and on Java's case, the `finalize()` method is deprecated as of Java 9. https://stuartmarks.wordpress.com/2017/04/17/deprecation-of-object-finalize/ https://docs.oracle.com/javase/9/docs/api/deprecated-list.html
But I believe this is a good starting.It is the same story we had with date and time API but finally got something good as part of JDK and I am hoping the same for the HTTP client.
Does the new client support TLS (and maybe 2-way TLS) in a straightforward way? Apache is painful in that regard, okhttp is a little bit easier.
For example we use Spring and we decided to never use @inject or @Autowire, we only do implicit constructor injection and explicit @bean declarations.
This debugger setup on a touch bar is a no brainer! I will definitely try it, will see how it blends with my existing muscle shortcut memory.
&gt; The fun thing is that Spring fans have been saying for almost as long as that Spring exists that Spring is way ahead, but that's not true. I think the only one that cares enough to hand craft two searches to fit your own personal view is you. Do you really believe forcefully excluding any vacancy that for example mentions JPA isn't going to exclude a ton of vacancies? Aside from that; this is just really silly. How both stacks work is incredibly similar. It's very common to see vacancies for java back-end developers where spring or java ee experience is asked. You guys keeping up the whole "spring fans" or "spring religion" spiel to create an artificial divide where there is none is exactly why Java EE is failing. It's not the technology; it's the people behind it. Without a strong inclusive community open source will die and that's exactly what happened here. To the detriment of us all; competition drives innovation. 
I think that Ceylon suffered from some odd decisions in language design and a lack of marketing. Something like variable Integer count; is just annoying! Why didn't they use the `name: Type` style that works much better with type inference? Why a long word like `variable` instead of a short `var`?
I am evaluating kotlin and find it nice to code golf in due to all the nice extension methods on collections but then again I could just use something like vavr anyway with real immutable persistent collections. However when building applications using something like spring boot, I am not sold on the benefits of kotlin as I dont think there is that much code reduction. When you start using JPA annotations, and have a few relationships then kotlin and java classes end up looking pretty much the same in terms of readability. I am 50/50 at this point, will probably keep trying to use it and see. 
It would have been just the same as `final var` (just shorter), so not immutable at all. I believe at least Scala behaves the same way with `val`..?
[Grokking Algorithms](https://www.amazon.com/Grokking-Algorithms-illustrated-programmers-curious/dp/1617292230) This is the best one yet.
I think their idea is that it would be shorter to type and would mean people would use final by default more than they do now.
Sure, but it's still no immutability, and not even mentioned in the article - that final object's state can change to whatever if the object itself isn't immutable.
The "modern" alternative to finalizers is ReferenceQueue with PhantomReferences or a [Cleaner](https://docs.oracle.com/javase/10/docs/api/java/lang/ref/Cleaner.html) (which is a high-level abstraction over that). However you should be aware that references like this always put additional load on the GC and should be used with care.
Yea that's true, it's kind of tangential.
The problem with those certs is how they concentrate on mostly-irrelevant details and mostly show you are good at memorizing those details. Knowing the semantics of final fields is useful. Knowing the parsing inticracies of intentionally misleading code is not, because we have coding standards and linters and ides to *prevent* such code.
In my opinion final-by-default for local variables would be a good thing, just for code clarity. Sure, there's no runtime benefit but when programming in languages like kotlin (which do have val for locals) I find myself using val for locals most of the time anyway. The biggest reason why people don't make locals final in java is probably because you need the final keyword. A `val` would change that.
What do you do that all of your methods are just getters and setters?
That is true, but it would be a little step in the right direction. By the way: true, deep immutability checked by the compiler is planned for Kotlin.
&gt; Using optional should make null checking obsolete. Yes, except it doesn't. No matter how hard you want it to, it doesn't. In a different language it would, but in Java it doesn't. You can react to that fact with denial of reality; that would make you bad at your job.
No you're not - I can tell because you used the word "I".
Kindly fuck off.
Lol.
InteliJ is much better than Visual Studio which is what I was comparing to. 
I work with apps with 20 devs. Call me when you're doing that with Kotlin rather that writing some mobile app in your momma's basement. 
We have five scrum teams with eight developers each. Half our new webapplications are written in Kotlin, starting with small tools two years ago, to larger enterprise apps today, having already fully delivered several projects that are currently being maintained. Condescending much?
Most of the time my local variables are effectively final anyway because I do a ton of declarative coding and Java requires that the local variables you use be final or effectively final. Having "val" to make that explicit to people reading the code would be helpful
Excelsior guy here. You can try asking this question in [product forums](https://www.excelsior-usa.com/forum/forum/2-excelsior-jet/).
Why do you think Java would be more maintainable then Kotlin? I would say it is the other way around because Kotlin encourages some Java best-practices and reduces boilerplate hiding the relevant logic.
Kotlin does not encourage best practices as it includes arbitrary operator overloading which was the feature that killed SmallTalk. I guess people don't learn their lessons. 
The best book for a deep understanding\(not for fresh users\) with tons awesome notes.**Matters Computational: Ideas, Algorithms, Source Code** Author publishes that book absolutely free on his website [https://www.jjj.de/fxt/fxtbook.pdf](https://www.jjj.de/fxt/fxtbook.pdf) Or you can buy the book on Amazon: [https://www.amazon.co.uk/Matters\-Computational\-Ideas\-Algorithms\-Source/dp/3642147631](https://www.amazon.co.uk/Matters-Computational-Ideas-Algorithms-Source/dp/3642147631)
[removed]
I enjoy learning a new language regardless of what it is as long as the educational materials are good. So, I try to choose something that is very useful. My /u/GoogleSearch-Arma2OA , my suggestion would be to do a practice job hunt. See how many Java jobs are available versus how many Kotlin jobs are available.
You don't have to switch. You can have both in same project.
From further down, where the concrete proposal is discussed: &gt; Explicit implementations of implicit methods. Allowing explicit implementations of implicit members -- especially equals() and hashCode() -- is a tradeoff; they allow greater flexibility in using data classes, but increase the risk that the invariants will be violated. As a starting point, we propose that the user not be able to override equals() and hashCode(), that overrides of reader accessors are permitted but the returned value must be equals() to the appropriate field, and that toString() can be overridden as desired.
Seconding CLRS
Operator overloading (thought not strictly, but practically existing) in Scala might be an issue, but operator overloading in Kotlin is limited to a few operators. And you know what, C# and Python (and many other languages) have this feature for years and these languages are still very widely used. 
That is incredibly annoying. As much as I like Java, the verbosity is one of the bigger dislikes I have about the language. \`\`\`\`\`\`\` 
Get CLRS after you've learned the basics! It's pretty much the algorithm bible.
This has to be the lowest effort post I've ever seen. Good job! 
Writing new apps in Kotlin is literally the opposite of maintaining aga old codebases in Java. Kotlin is absolute ass btw. 
Okay, mind explaining why you think Kotlin is absolute ass?
Nicely summarised, I think it's worth adding PretenureSizeThreshold to Part 2 which determines whether newly created objects go into Eden or into Old, this flag made a massive difference to the performance of our app. Our service was doing many http calls and dealing with some large responses. We found some of these went straight into Old and stuck around in memory for a long time, even though one may assume they would have been available for GC immediately after transforming them.
Do you need to do anything special to get the touch bar to show up? I'm not seeing it.
I don't believe this should be used over Netty, at least not yet. I still have a lot more work to do and many more features to implement. Nevertheless, this framework provides a very simple client-server relationship that seems to be similar to Netty, and I'll be benchmarking them together soon to see how SimpleNet fares. Also, thanks for the license and gitignore suggestions, I've just fixed both.
Did you add an override for intellij to show the function keys when its in focus? I had to remove that override before I saw the new context.
Lombok wither is kind of that. Also known as a "copy mutator", though copy is misleading in a way.
Totally disagree, I really like the new style - very easy on the eyes, very consistent and modern. However, I can understand how it might raise issues for people with colourblindness. Maybe have a toggle to colours in the settings somewhere. Release to release intellij keeps looking better, which is great. I don't really get what you mean by half of them looking disabled? https://imgur.com/Z1KFmQ5 
Their build passes the TCK suite. I used to work for a jvm shop where Azul OpenJDK was the default (not the commercial one) mostly because they offer easy to use RHEL/CentOS/deb repository. It was when JDK8 was hot and cool but not very widespread among official repositories (Debian squeeze, I am looking at you). I remember we hit a problem that crashed their packaged JVM but not the OpenJDK package: same version, same code, same server. It was about Spring and its generate bytecode. Nothing dramatic nor a showstopper: we just upgraded dependencies and the problem went away. Certainly combinations that crashes the OpenJDK but not theirs exists. That problem reminded me that who build OpenJDK is not an invariant. 
Error 2 is connected to error 3, so start with error 3 instead.
How do you fix error 3 ? 
Thanks 
Gray is a color of disabled things. Everything in your image looks disabled. With colors I could easily see where is the blue Maven, now I have to search for it, those icons add nothing to the text, because now they are less identifiable than the text, totally defeating their purpose.
Intellij master race
I think you are correct. :-)
Because the two lines to do it otherwise are not good enough?
I can see how `writeString() ` might be convenient, but there is already `Files.lines()` for reading, not a huge issue to limit that to 1, or do something else useful and more flexible than just reading one String. There's also `readAllLines()` which reads the whole thing. Unless I'm misunderstanding something. 
When could peeple just shut up and appreciate this free Java IDE? It costs zero $$$ and it does its jobs.
Thanks. I will add it to the post. Which version of JDK do you use in production?
InteliJ made me love Eclipse again, with its continuous indexing and having to turn off most plugins so that my laptop doesn't sound like a propeller plane getting ready to take off.
If anyone is still interested, the change has been [postponed until JDK 12](http://mail.openjdk.java.net/pipermail/jdk-dev/2018-May/001210.html).
Apart from this giving a minor convenience, I don't really see the point of it. What's wrong with `new String(Files.readAllBytes(Path)[, Charset])` or `Files.write(Path, String.getBytes([Charset]))`? If it feels too bloated, you can just easily export these to a one liner helper methods. If the new methods bring any performance benefits, then disregards my comment, and let's do this.
&gt; Our prices are very reasonable compared to some of our... competitors. https://i.imgur.com/vVkoPPU.gif 
I wish there were an OpenJFX build from Azul. Would you ever consider doing that?
i literally write final next to every single declaration. it's muscle memory at this point. if i'm writing code and java says "dude you change that, it's final" it makes me stop and think whether i'm doing the "right thing".
this sounds like great is the enemy of good.
`Files.readAllLines` strips all the original EOL characters and `Files.write` uses platform EOL which is anti-WORE ;)
Is it out yet? It doesn't seem to be available from the update sites.
Do it with Google Guava: - CharStreams.toString(Readable r) - ByteSource.asCharSource(CharSet).read() There is no need to have every utility method in the SDK. There's the same in the Apache realm afaik.
Thanks for the hint. Played with NullAway - works fine, but I would prefer a tool with assumption "everything is Nullable by default". Do you know if it is possible to configure NullAway to do that? If I don't find a better variant, I will go with NullAway. Build works significantly slower with ErrorProne compiler, btw. Built time jumped from couple of minutes to 12 minutes for me. But at least, it works.
I already did. But it is not what I want - I need to enforce that check in compile time for the whole build. If that check only works in IDE, then it will not work when developer actually runs build - we usually do it in command line. As for Null4J - looks pretty interesting, thanks for the suggestion. I like that it provides default rules for the class level. Looks useful.
It will not help - developer may ignore it or just not notice it. I need to enforce it on a build level, call it from maven. So far, combination NullAway + ErrorProne gives a pretty good result, except I want "Nullable by default" policy and NullAway pushes "NotNull by default", which requires more modifications to existing source code.
https://github.com/typetools/checker-framework/issues/1224 ...flat doesn't work. I have found that checker framework was awesome, but does not seem to have the team size/effort to maintain it henceforth. I would probably recommend against it, but it's the only one that does the flow checking that I am aware of.
lol not using vs code
If the same or similar utility method shows up in multiple realms, and probably lots of application codebases reinventing the wheel, where do you draw the line that it should be in the SDK? Genuine question.
You mean WODE.
Where do you have this info from? Could you give me a source, i'm very interested? Thx
You can get builds of the base Eclipse SDK from http://download.eclipse.org/eclipse/downloads/ Personally, this is what I use, not the full packages you find on the main download page. This is basically just JDT and PDE.
I like the idea of making pretty much everything final, too, but it does increase clutter.
Both have their own strengths, weaknesses, and use cases. Hibernate is huge/bloated and has most of the things you need out of the box to do what JDBC can do and more. But using it in certain situations is overkill. You can do a lot of things in JDBC with simplicity and specialized business cases. If you see your project to grow a lot in the future, you can use Hibernate to save you time in managing many things for you (e.g. transaction management, caching, ORM, etc.).
JDBC + JDBI.
JDBC has a really horrible API. Spring JdbcTemplate or Apache DbUtils make JDBC less painful to use. Also, MyBatis is a good middle ground. Not as bloated as Hibernate, but not as barebones as JDBC.
I used JavaFX with NetBeans on a couple thingies I wrote for a friend a couple years ago. It's pretty slick, and it created a jarfile that works seamlessly on Windows, Mac, and Linux. I honestly don't get the hate NetBeans gets; it made everything so much easier.
Jooq as a SQL builder is not bad. The codegen stuff isn't necessary unless you really want to use it.
Also, a pathetic standard library is what leads to NPM dependencies like `lpad`. But I think there is a line to be drawn between putting too much in the SDK and not enough. For example, reading/writing file contents to a string could be useful (even though there are slightly more [verbose alternatives](https://www.reddit.com/r/java/comments/8jw6td/jdk_add_methods_to_files_for_readingwriting_a/dz3bdew/)), vs an API for calculating the [levenshtein distance](https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/StringUtils.html#getLevenshteinDistance-java.lang.CharSequence-java.lang.CharSequence-).
ebean
I'm pretty sure it's not possible to change NullAway's default assumptions. There is an open issue about that on GitHub: https://github.com/uber/NullAway/issues/94 There is also an open issue in Error Prone about performance problems: https://github.com/google/error-prone/issues/994 You could try disabling the specific checks that the reporter identifies as slow. `-Xep:CheckNameGoesHere:OFF`. Maybe there's a way to disable all the built-in checks and then turn on only NullAway or only the checks you care about. You mentioned elsewhere that you want the tool to work with "Java 9 and newer". I'm not sure what the compatibility story is for Error Prone and Java 10+. For example, I don't know if it's possible to use `var` in your code if it's being compiled with Error Prone. I tried and eventually [gave up](https://github.com/TechEmpower/tfb-status/commit/e9b0c190599d4d3209a9c28d7bbd4231a7a57f95) in a recent project.
Thanks. I use the base platform as well but usually install through the installer :)
This is the kind of post that seriously depresses me. The article seems to be written from a viewpoint that is entirely oblivious to the fact that hibernate is a higher level of abstraction built on top of jdbc as a primitive. It also gets the acronym for jdbc wrong. This makes me double plus sad.
Having each classfile declare what types it will use as values seems like a pretty unfortunate solution, but value types are important, so whatever they need to do to get them implemented...
I prefer slim SDKs, which is not quite what the JDK ships. I have to say the line is kinda arbitrary. You can say lets limit the utilities to primitive type manipulation and that should work, but then again I'm not too sure you could manage a project without NIO for example. That said there's plenty of my projects which do not require reading anything to plain Strings, which can be quite bug prone anyway. So arbitrarily the line is drawn on average usage. 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Well bot! That sucks.
some good and some bad. some of the things you discuss are more or less a matter of opinion, but others are definitely more progressive looks at the language. 
Who even uses `Files.write` and `Files.read`? `FileOutputStream` and `FileInputStream` handle this in a much more gracious way, especially with try with resources.
I actually really like the java syntax because it contains a lot of ideas in it. For example, System.out and System.in map to the stdout and stdin of the command line. You want you send out a message to stderr? Use System.err. You want to print out a message in its own line? System.out.println You don't know when you want the line to finish? System.out.print You want to format message so you don't have to build up a string? System.out.printf You want to do all the above but for error messages, change out for err Now, realistically you should use a logging library to capture boiler plate details, like where the log came from, when it was created and what thread sent it. But even those logging api support verbose ways of formatting logs.
This was mentioned in a [presentation](https://de.slideshare.net/abreslav/future-of-kotlin-how-agile-can-language-development-be). It was a feature in the Kotlin developer survey performed by JetBrains and it was mentioned in the [Kotlin Forum](https://discuss.kotlinlang.org/t/what-is-meant-by-immutable-data/3294/2) several times.
It probably won't be necessary as openjfx will be distributed on maven central sooner or later. maybe azul will make a mega\-openjfx jar that works on all platforms instead of being platform specific, but I don't know what the size requirements of such a package would be.
I also wish IDE/Editor related news would not be swarmed by people talking about how their preferred tool is superior. One could argue that if most people are complaining, it should tell you something. Problem is, for every tool there are more people who don't use it than who do, so the comments always look like this.
Honestly, the only "Java 10 support" thing is \`var\` support, which was added a couple of months ago already. The support for Java 9 is still not completely there.
Different people, different stories. When I switched from Eclipse to IntelliJ a few years ago my reasons were: * the whole workspace design. Since I had projects from different backgrounds and conventions - I ended up with several one-project workspaces. Also plugin for gradle couldn't generate a standalone project, so it created a workspace. I tried to get used to it for several years, but always found it flown by design, * similarly perspectives. I don't want several modes for my editor all the time. I want one mode, which might be customized per project, * as much as IntelliJ's indexing annoy me, it never pissed me off as much as basically any Eclipse's command taking ages, * quality of pluging was lower - every now and then I got NullPointerException than crashed the Eclipse, * managing plugins was an overall mess - when I upgraded Eclipse things simply broke and I had to install and set up everything from scratch. Over the time I ditched the idea of one Eclipse to rule them all and I've downloaded separate bundle for every task without any configuration. If it broke I deleted it and downloaded that particular bundle again, * no one cared about UI and UX - ratio of indents between icons to their size was ridiculous, small images and galaxy-scale spaces between them. By default cluttered by a lot of useless tools. Too many menus everywhere. Perhaps things changed. But I still remember Eclipse from back then, and I guess many IntelliJ advocates as well, and we all compare current IntelliJ vs memories of Eclipse horror from the past. Now I am not even curious if things changed.
`Files.lines()` is implemented using `BufferedReader.lines()` if it can't use the better `FileChannel` implementation. http://hg.openjdk.java.net/jdk9/client/jdk/file/65464a307408/src/java.base/share/classes/java/nio/file/Files.java
Made the switch a year and a half ago. Indexing in IntelliJ is pretty fast for me tbh. Eclipse is incredibly slow and all its tasks block each other. Plus workspace corruption all the time, especially when working with application servers.
Not to mention any overhead in the software will be dwarfed by the file access to begin with.
TBF I don't have to like things just because they are free, especially if I have other free alternatives. 
I completely agree with you. However, maybe it's Intellij's design that is awesome as opposed to Eclipse being "ugly".
&gt; Given that there will be no free LTS release from Oracle as of JDK 11 Woah woah woah, hold on. AFAIK Oracle will no longer be providing free LTS for releases *other* than those (like JDK 11) marked as such, but said LTS releases will still be free. Am I wrong? Where did Oracle say the contrary?
You're not wrong, Walter, you're just an asshole.
Thank you both. I'll purchse the book. I have also started learning Spring Boot to get me up and running quicker. Is it also something you would recommend?
Might be, that was one of the initial goals of 4.8.
Thanks a bunch, i saw it in the surveys, but was Not aware of a discussion around it, so i thought they dropped the topic. I wonder If there is any rough schedule for upcoming language features currently.
I disagree - I think Eclipse Che looks great! The dark theme there looks much better to me than in the desktop Eclipse. I wish the two projects would collaborate a bit more on look-and-feel, even if it was just that the more modern looking icons from Che got adopted.
Hi everyone, I initially posted this under the programming sub\-reddit but I realized it's actually focused towards Java developers that are curious about Kotlin. I was surprised that there wasn't much written about defect reduction so the goal is to raise awareness.
I had never come across Eclipse Che! How is it different from the standard Eclipse? From my understanding of their website, it's supposed to run in a browser, either hosted remotely or locally. Am I missing something?
It's not bad. Spring boot was something new last time I used spring. It is something we are evaluating for use in our project right now again. There are worse alternatives ;)
These 'defects' don't really motivate me to even try out Kotlin. Apart from nullpointer defect, I've never encountered any of these in the past 6 months. And when I did encounter an NPE, I was actually using the null values to represent a missing value and would've encountered them when using Kotlin as well. For me Kotlin just seems something that tries to achieve everything, it is bloated with random keywords, and I actually hate the one line class definition. It's syntax can allow too many things, and it becomes very much hard to read when multiple random blocks are nested into each other with some expression that defines how this block will be executed. AFAIK there is no possible way to fallthrough in a switch statement. I want my fallthrough please.
I have access to the pro edition at work but I don't even use it. The only thing I could actually use is the SQL client but I prefer SQLWorkbench/J for that. Community edition is legit.
You misinterpreted the article. The article doesn't claim that using more code is a defect. It claims that having that portion automated guarantees that the automated bits are implemented correctly which avoids common defects. Regarding the bashing part, the article strictly displays examples of defects which are possible in Java and which Kotlin would avoid. So it's not opinionated or bashing but instead very much factual
Falltrough is pretty much obsolete: ```when(x) { 2, 3 -&gt; ... 5 -&gt; ... }``` It's a really bad idea to use falltrough in cases where you want to share _some_ code anyway.
You're probably much better than the typical developer since these defects are actually very common according to several studies. Regarding null, when you use a nullable type in Kotlin, the compiler forces you to decide how the null scenario should be handled everywhere it's used \(note that assigning a nullable variable to another is allowed since the contract is still maintained\). Many companies spend a significant portion of their dev / qa budget on fixing defects and these are the defects that have been found to be the most common in Java.
 switch(x){ case Y: case Z: //do something, tinker locals //fallthrough comment case W: //do the actual thing break; } It is a rare use\-case but I rather use this than export the common code to another function. The function could have too many parameters, as locals needs to be passed to it, and could take the code out of context. When it is possible, I too export the common code to a function. Depends on readability really.
This should go in the Kotlin subreddit. Probably not enough cult followers over there though, eh?
Yea [Lombok](https://projectlombok.org/) is great. Has an excellent IntelliJ plugin.
&gt; Many companies spend a significant portion of their dev / qa budget on fixing defects and these are the defects that have been found to be the most common in Java. Your reasoning is incomplete, and the step you skipped smells like it's wrong to me, which would make your reasoning here incorrect. Your reasoning here is: 1. Companies spend a significant portion of their dev/QA budget on fixing defects. 2. this list of defects are amongst the most common defects in java code. 3. Therefore, addressing these defects significantly reduces your dev/QA budget. This is false reasoning. I'll fix it for you: 1. Companies spend a significant portion of their dev/QA budget on fixing defects. 2. this list of defects are amongst the most common defects in java code. 3. __The cost to fix a given defect is more or less constant regardless of what kind of defect you're fixing__. 4. Therefore, addressing these defects significantly reduces your dev/QA budget. 3 is required to make your argument make sense, and I really don't believe it. Let's look at null which makes the easiest counterargument here: 1. yes, NPEs occur. Not nearly as often as blogs like yours like to harp on about, but, hey, let's posit that these do occur very frequently. 2. NPEs usually point directly at the problem. You follow the stack trace, usually it's instantly obvious what is null, and from there it's usually instantly obvious where you went wrong. In other words, the 'turnaround' time from noticing the bug to fixing it is measured in a handful of minutes at most. If the bug is noticed during testing/writing that makes the impact of such issues on QA/dev budgets pretty much irrelevant. ANY bug that gets as far as production is of course a much bigger deal, but in order to use this in your argumentation you'd have to posit that significant amounts of unexpected NPEs make it to production, and that these NPEs are significantly worse than the 'aware' alternative (for example, if an NPE is caused by an incorrect setting, say, the DB JDBC url isn't configured, well, had you been aware of the chance of null you'd have... thrown an exception. The difference in dev/QA budget saved between these two cases is pretty much null (heh). 3. Lots of NPEs wouldn't just have magically disappeared had you used typesystem carried nulls. Oftentimes null indicates lack of value and an NPE is caused not so much because someone straight up forgot about that being an option but more that they did consider it when writing the code, and thought: That cannot happen here. In type-system-carried lack-of-value scenarios such as Kotlin's explicit nullable stuff or using an Optional&lt;T&gt; type, this would manifest either as [A] a straight up: Get me the value, and blow up if it isn't there because I know that can't happen (which would reduce the resulting behaviour to be effectively equal to the NPE result), or [B] a more insiduous functional style: Map the value onto this lambda, which would be considerably _worse_ than the NPE: Here your code would then silently do nothing when the unconsidered 'not a value' scenario occurs, which is usually a bug that'll take many orders of magnitude more resources to identify and solve. 4. The introduction of type-carried nullity is also a cost in general: It takes more effort to write code. This goes two ways, in that the API being explicit about lack-of-value or not can also save time, but if you want to make the case that this is 'just plain better' by throwing around research and QA budgets, well, you can't make that case without taking this factor into consideration. For example, if I want a method that takes a list of strings and I work fine both if the strings are nullable and if they aren't (I accomplish this by checking for null when reading, and ensuring I never add null when writing, and for an encore, that I only add things that were already in it), then we need a third nullity: List&lt;@NeverNull String&gt; allows me to not nullcheck when reading, but List&lt;@Nullable String&gt; allows me to write nulls into it, which makes a List&lt;@NeverNull String&gt; and a List&lt;@Nullable String&gt; type siblings and therefore entirely incompatible. We need a third nullity: List&lt;@EitherNullity String&gt;, where the compiler ensures I nullcheck on reads and ensure I either never write, or only write things of the same bound, and if the compiler gets to do that, I can now write my List&lt;@EitherNullity String&gt;-accepting method. Kotlin doesn't allow you to write it, its type system isnt complex enough to be able to express this. I bet it's a rare occurrence that you need it, but I'm just making the point that there are also benefits to leaving this out of the type system. In java such a thing is doable. 
[Project Lombok](https://projectlombok.org/). @Data is your friend.
This article isn't great. I personally love Kotlin, but other than stricter null behavior there is nothing here that really prevents defects.
It's actually a really good API. To build other APIs upon.
Here is what is Oracle have announced. There are now two binaries available from Oracle: the traditional Oracle JDK (java.oracle.com) which is provided under the Oracle Binary Code License (with field-of-use restrictions). There is also now an OpenJDK binary (jdk.java.net) released under the GPLv2 with CPE license. As of JDK 11, the Oracle JDK will still be available for download and can be used in development and testing for free. If you want to deploy it into production, you will need a commercial support contract with Oracle. The OpenJDK binaries are free, but *every* release (including those Oracle designate LTS) will only have updates available for six months (until the next JDK release). For confirmation from Oracle, watch this presentation (I've put the link to the important slide), https://youtu.be/YauqubC8FKM?t=1281
We do have one. We're surrently evaluating customer demand before we go ahead with committing to the resources required to provide builds as updates are added. Keep an eye on the Azul website.
[This](http://cr.openjdk.java.net/~briangoetz/amber/datum_2.html) is from a few months ago but is the most recent writeup I can find on status/motivations. You can find a lot more discussion on the amber mailing list since then. Expression switches are a little further along (the motivation for those ofc being pattern-matching down the road, which is related to data classes). It's an incremental process and there's a lot of work left to do but they already seem to have invested a lot into this.
Pretty sure I've been using Apache Commons IO FileUtils to do this without issue for a decade. Considering Commons Lang and Commons IO are by default included in all my projects, this isn't really something that's helpful to me these days. 
Thanks, that is great news!
Grokking Algorithms seems pretty good. If you're more of a visual/audio learner [these lecture notes](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/) are good too. They use the CLRS book. 
&gt; it is bloated with random keywords Examples? It's not as though they don't do anything. I think this can be seen in pretty much any modern language. Read any C# recently for example?
There are a lot of features Community Edition [doesn't support](https://www.jetbrains.com/idea/features/editions_comparison_matrix.html). Even for things that I expect it would have been supported like CSS or JS. Even popular Java framework like JavaEE and Spring is not supported in Community Edition. I have student license so I'm using it but without the license I'm sure I'll need to move to Eclipse.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I loved this book back in college \- and now you made me remember that someone stole my copy =\(
This new client can only be used with modules? how about using it the traditional way?
Awesome, but I hope to find soon some opportunities to work with an supplementary character in a supplemental plane \(0x10000\-0x10FFFF\).
*Clojure avoids entire categories of Kotlin defects
Equality defect is prevented because you can use one operator? In all my years programming I haven't once had a problem because I used == instead of .equals(). The main problems come with .equals() implementations being bad. Switch defects, I'll admit when has many more powerful features than switch but that doesn't make switch defective. I just see this as a weak, click bait article grasping at straws. And I LOVE kotlin, I find the experience of programming with kotlin to be amazing compared to regular Java. However, that doesn't mean I'm drinking kotlin koolaid.
I just hope we get something similar to scala patern match soon after that
Is there any way I could get a similar thing for VisualVM?
&gt;ull which makes the easiest counterargument here: Unfortunately, you're over\-analyzing it. Lets look at the big picture. Eliminating popular defect categories means that the rate of new defects is reduced period. The benefits from this statement doesn't require that all defects must have the same cost. A single defect that's prevented means one fewer defect to log / troubleshoot / investigate / fix / re\-test / update release notes / etc. So we can use the saved time to either fix more defects or implement more features. Although the cost is important, it's irrelevant to the actual topic at hand. It's obvious that some defects are easier to fix than others and sometimes a defect presents itself through side effects but these statements are not what's being discussed. This article shows over 25 types of defects which Kotlin helps avoid.
And introduces many other issues and complexity / behind the scenes magic.
&gt; Missing break is a common defect which causes accidental fall through Anyone who compiles without Xlint warnings enabled deserve this bug ;)
&gt; Equality defect is prevented because you can use one operator? In all my years programming I haven't once had a problem because I used == instead of .equals(). The main problems come with .equals() implementations being bad. It’s a papercut. An issue that has affected nearly every developer at one point or another. And one that once you’ve made that mistake, you are not very likely to repeat. But it is still a weirdness that just should not exist. 
Agreed, it's pretty easy to extend, but I have a few issues with it: It lacks support for non-primitive Types like Integer, which makes dealing with nulls clunky. java.sql.Date, java.sql.Time, java.sql.Timestamp and dealing with timezones are a mess.
Agreed, the constructor at the top just seems silly, using things like "shl" and "shr" instead of &lt;&lt; and &gt;&gt; like everywhere else, 1.toFloat() instead of (float)... I like a lot of features kotlin brings to the table but I prefer java.
kotlin doesn't belong in this subreddit 
&gt; that hibernate is a higher level of abstraction and ignores the dozens of other tools in the same space 
How to use an external API to do your entire project
Switching language is a really _really_ big cost associated with fixing a defect. In the end, if you find null sufficiently annoying that it's worth switching languages for you, go for it. I wasn't the one that started arguing in favour of kotlin based on vaguely logical sounding arguments, that was you. 
What I pointed out was the platform. It does not mean that similar features across all languages uses the same tech?
If Java devs are curious about Kotlin, they will check out the Kotlin sub for information.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Shl and shr trips me up too. But 1f and even 1.toFloat() is more ergonomic to read than weird Java prefix operators such as casts. I would rather have methods for instanceof and casts like Scala does though. (stuff as? Stuff)?.foo() Noisy parens. How about stuff.as&lt;Stuff&gt;()?.foo() 
You're referring to the easiest scenario of accidentally using "==" instead of ".equals\(other\)". Note that Java doesn't allow using ".equals\(other\)" on primitives so the other types of equality defects which are presented in the article are much more sneaky. Regarding "switch", again, you didn't seem to read the article since the article isn't saying that "switch" is defective. The article presents several types of Java "switch"\-defects which Kotlin can avoid. The presented defects are some of the most common Java defects based on studies. Presenting facts with specific examples is as good as it can get so it's definitely not click\-baity or grasping at straws as you're claiming. Let's stick with the facts and keep emotions aside but definitely point out if you find any flaws with any of the claims that are made in the article.
*Frege and Eta avoid entire categories of Clojure defects ;)
Meanwhile, Kotlin introduces an entirely new category of defects, namely Kotlin fanboys, who spent their entire day lurking in Java forums, desperate for an opportunity to, apropos of nothing, squeak their favourite catchphrase, *"Kotlin* does this better".
The fun part? You could probably write a generic reified inline extension method to do that cast.
"people can do bad things with new stuff so we shouldn't have new stuff." - your entire argument there.
The maintainers of these languages avoid whole categories of users.
I dunno what you're trying to say, but whatever it is, Kotlin does it better. /s
Step 1: Omg guys, the new stuff will be so much better! Step 2: New stuff shows up, extra work learning it, doesn't improve anything. Does make things more complicated. Step 3: Repear starting at step 1.
Feels kinda ironic since you're the author of Lombok, which has definitely influenced Kotlin in some ways (well, feels like that to me). Not picking any side in the debate here though. 
Stream is one of the best things to ever happen to Java. I have no idea what he's smoking. It's great for complicated series of otherwise highly imperative code to make it declarative and functional, and much easier to read and reason about.
Ofc, never said it did, just adding some relevant information to the discussion. This is a Java sub, so it would be a bit silly to suggest nobody would be interested in that. And if we're talking about what helps people now I still think it's pretty relevant to consider this. For example, a company: retrain/rehire staff with skills in another language, or just wait for the more measured advancement of the product you already use? Both take investment and time, both come with different types of risk :/
If you've paid any attention to Java language development you'd know that these have been on the roadmap for a long time. Of course, nothing is for sure, but it's pretty certain that they're coming at some point down the line. I still don't love programming in Java, and it's definitely true it doesn't help anyone now, but it's a lot more in motion than maybe, might be coming.
They really should have devoted more time to DL4J which came up in the end of the talk, but it honestly seemed like she didn't know what she was doing or talking about.
I agree, it's a problem. More of a problem with habit and the standard library not having a good solution for years. As opposed to, say, Scala where even though null exists (by technicality) it's never in the standard library and if you don't interface with too much Java code you can pretend like it doesn't exist and just use Option[T] instead. Kotlin's solution is also good, though it isn't ideal IMO. I'd prefer a language where null does not exist at all and is expressed entirely in monadic types like Maybe in Haskell.
Yeah, I don't mean to be too hard on conventions, precisely because there's probably a tipping point where these conventions become so standard that you can start to eliminate null checking. However, working on a large codebase that is a decade old, despite still being relatively modern, using `Optional` just seems like a losing battle in some ways. For a new project, I would definitely try to be really diligent about returning `Optional.` 
Exactly because it's opt-in and not opt-out. It's a shame, because supporting val / var gets you there. I suppose "the architects" at Oracle know best and mutability will continue to be the default.
I assure you, it's not. Kubernetes is complicated because the problem it solves is complicated. Docker swarm is simple because it doesn't solve those problems. You might want to ask anyone running it in production how that's working out for them.
Very unhelpful. Problem statement: flame graphs don't help you debug allocations as they relate to garbage generation (and therefore) / time spent in garbage collection. Solution statement: debug allocations offline in another environment, because instrumenting allocations is super expensive but also fundamentally changes the performance profile of every line of code you execute. This is better suited to being internal documentation about how to interpret your flames than a blog post.
Keep writing for loops to transform data and looking like a clown.
&gt;Switching language is a really really big cost associated with fixing a defect. There's a cost, therefore, you need to do a cost/benefit analysis. It's true that there definitely is an up\-front cost with switching to a new language due to training / ramp\-up. If you look at the total cost over a short duration, it's definitely more expensive to switch to a cleaner and safer language if your intentions are to complete a small project and then stop programming in the new language all together. However, we would continue to reap the benefits well into the future since we will continue to use the language afterwards. Kotlin brings other benefits as well in addition to reduced defect rates \(there are a ton of articles that talk about benefits\). Since the cost is incurred one\-time / up\-front, you need to decide whether to continue coding in a less productive and less robust language or pay the one\-time cost and forever benefit.
I wonder what portion of the Java market share comes from Android given the millions of Android apps. What would happen to the Java market share if the majority of Android apps switched from Java? Would it be a large enough impact to make Java lose it's #1 popularity spot?
&gt; It's great for complicated series of otherwise highly imperative code to make it declarative and functional, and much easier to read and reason about. Oh oh oh, 5 buzzwords. Sooooo great for buzzword generation. Notice how the pro-stream people aren't bothered by taking 5 lines of a mess to read just to return a collection as null if it's empty? Doesn't even register to them. 
This isn't for Java developers interested in Kotlin. I've had to write in both and this just reads like more of the fucking Kotlin cult bullshit that I continue to see.
&gt; There is no step 3. Bye. I'm 100% sure you'd get along well with the people running the TSB disaster. Spring boot guys! Spring boot! Uh, how about we make sure that people aren't able to see other peoples accounts and transfer money from... I'm bored you aren't saying any of the words I want to hear. Lambda! Streams! Spock! Groovy! But our code doesn't actually work at al... You're fired! Oh, groovy. So magic. 
Omg guys, we **reinvented** the for loop! Now you can write it - differently! I does exactly the same thing as before! Except also it's a huge pain in the ass to debug. We reinvented the for loop and made it worse! Good job guys!
I used to really like Java myself and used it for over a decade. It's important to keep an open mind for your own benefit since nobody purposely wants to use an inferior option in general \(not referring to Java\) so I wouldn't sell myself short by limiting my options / considerations. I dismissed other languages in the past as well as the drawbacks outweighed the benefits \(eg. I dismissed Scala due to the complexity &amp; tooling\). Kotlin strikes a really nice balance, has many benefits, and makes the transition really easy due to Java interop and tooling.
There's absolutely no doubt they write pretty terrible code, that is my experience though with the buzzword bingo crowd. 90% of the code they write is terrible. We're writing a rest endpoint and the "architects" had this idea that it should return a different status code if there's no data rather than returning an empty json collection. I'm not a fan, but you know, you gotta go with what they tell you to do. It's not like it's an impossible task just a poor way of doing it. &gt; And five line lamda/filter/collect chain can be pretty neat.. Not when the same thing could be done in a way that's not a nightmare to read with a simple if/else block. 
This article is not just about Kotlin since the very title makes it clear that it's comparing against Java. Therefore it falls under the category of Java related technical discussions.
This comment does nothing but continue my point. You start off "sympathetic" and end the same way: "but kotlin is better".
Sucks for me, I run intellij via VNC on a linux box (from my mac). I would love to be able to hit a run button from my keyboard. I pretty much do now, but the touch bar would be cooler.
you could write an article listing things that a refrigerator can do that java can't do. and that article wouldn't have anything less to do with java than this "article"
As you note, the String constructors that accept a arrays without copying them are package private, and to make them public would break String's immutability. There is an existing mechanism for calling package private APIs from elsewhere within the JDK; see (System.setJavaLangAccess)[http://hg.openjdk.java.net/jdk10/master/file/be620a591379/src/java.base/share/classes/java/lang/System.java#l2073] and the SharedSecrets stuff. It's kind of clunky but it serves the purpose. StringBuilder must copy its array into a new String, because the StringBuilder can continue to be mutated, which mustn't affect the new String.
Java's lack of null safety is really painful in teams. Often documentation is lacking and I have to figure out what can be null or not. This often leads to bloating code with a bunch of unnecessary null checks
Good points, thanks. I initially planned to include a section about sealed classes as well but I was surprised to keep discovering additional types of defects that Kotlin prevents so I stopped here since the article was getting long. It's amazing how many improvements could be made to Java. The second part will showcase a ton more prevented defects \(including a section for sealed classes\).
I think your use case will not be possible. You should look into remote development capabilities of IntelliJ instead.
The hardest thing I've ever had to do is explain what an ADT is to a Java programmer lol. Such an important concept
One of the ideas behind project Lombok is to make Java nicer by way of a much smaller and far more easily reversed step, compared to switching languages.
Yet your comment and the article bring the absolute opposite-- nothing but pure fanboyism. No one language is objectively better than another at all things. This is plain and simply impossible. Yet these articles only show one side-- the positive side. This plain and simply infuriates me. This occurred with (Swift, iirc?), Scala, was a thing in the Python V Java internet war that lasted more than a decade but has seemingly died down recently, and is still a thing with Java V C# (for what reason though, I have no clue, this is the most confusing that I've seen because the arguments on both sides explicitly limit themselves yet they still are paradoxical). And now it's a thing with Kotlin. These forms of thinking are nothing more but language level considered harmfuls, which for those unaware are themselves [harmful](https://meyerweb.com/eric/comment/chech.html). These were popularized by the in-hindsight moronic gotos considered harmful essay (moronic because whether you like it or not, while rare, gotos do have a decent use case), and have spawned countless equally mornonic considered harmfuls. I saw two that said if blocks and else blocks in code are harmful, respectively. But the problem is for some reason the Kotlin circlejerk seems to be the strongest. One of the core members of the Kotlin team had the nerve to call Kotlin "Java 2.0", ignored the fact that Kotlin *literally compiles down to* ***shitty*** *Java*, shitty because it takes performance hits for no conceivable reason at times, such as in for loops. Oh and he was angry at the idea that Java might take a few ideas from Kotlins deck in regards to `var`. Excuse me? Kotlin took some ideas from Scala's. And....fucking Java's! Every language has it's use case. There is no objective better. Okay, maybe in comparison to Brainfuck and other esoteric languages. But probably not, hey, I'd bet on the fact that in some niche thing Brainfuck is better than all else. These articles and statements are harmful (haha!) to the communties they are dropped into and to programming as a whole. Show the complete picture. Show both the positives *and* the negatives, *of both sides*. Then *maybe* make a recommendation for *single use cases that the writer* ***has sufficient experience in***. But again-- recommendation. With reasoning. On a limited scope. Not "X is better than Y at all things because X does features a through f better (and no one figure out that g through p are worse, please thank you)". Do the above. Not this fucking elitist bullshit that the Kotlin community is doing at the force of a comet colliding into the earth.
I mean running IJ from your computer and setting up your remote environment for development. So IDE is on your computer but JVM and so on are on the remote machine. I never did it for Java but it’s really convenient for Python.
Interesting....
Spring Data JPA
I'll be happily waiting for that to show up sometime 2028.
If you wrote this a few years ago I would agree.But it seems Java is mooving faster these days ( I really hope I'm right)
Seems to be but in practice the only thing we've really gotten since Java 8 (which was ages after Java 6, with Java 7 being fairly minor) is the 'var' keyword.
meh anyway Scala is better than Kotlin ( scala fan boy here)
A system horribly flawed that barely fixes any problems and caused more than its currently worth.
Looks nice, but why? Yes yes I know: "Because why not?" But serious question: Do people really actively wait for maven to finish often enough to use this tool? Tell me about your workflow please.
This is why I hate attending of Microsoft talks in Devoxx, they just presenting their API and using java as a Big word to have more people interested in the talk
Since maven 3.5.3 you have built-in feature of module build progress so it is easier to tell estimates. But still maven output is really verbose(try getting JUST module version in terminal output) and I would like to have such functionality out of the box.
What would be better is to show a percentage of each dependency - this way we can monitor whats slowing down things down.
I have no doubt that it's coming, and could already be read between the lines from the first announcements before last JavaOne. I guess the only pending issue is that they (hopefully) first deliver on their promise of binary Oracle JDK == binary OpenJDK. And as per those tweets, that may very well happen with 11, so they could drop free LTS with "clear conscience". Maybe even stop delivering free Oracle JDK at all when free alternatives are good enough. Sounds like good business for you guys, as I doubt many companies that want/need commercial support want to pay extra for their JDK when not using with Weblogic or other Oracle products...
Looks nice! I like Maven but often think it's output is neither CLI-parseable enough (e.g. for bash manipulation) nor pretty enough. This makes it pretty. I can imagine a lot of work went in... As a suggestion, there should be a way to make it part of the `mvn`command, with an alias or a link.
I too love Scala, but I think we would do a better marketing if we didn't act like Jehovah's witnesses. But I guess building some stuff that people love and use and then showing them: "I did it this way and it works and is fast and its readable" is much harder than fanboy gospel.
Data classes and sealed classes will be making their way to Java. Brian Goetz discusses them [here](https://youtu.be/qul2B8iPC-o?t=24m57s).
go away shill.
The article wasn't calling it a defect to have more code. It looks like you quickly skimmed the article and jumped to conclusions without actually reading it. The claim was that portions that are automatically generated at compile time are guaranteed to produce correct code. This avoids the defect types that could have been accidentally introduced manually.
&gt;Effectively final variables can be used in try\-with\-resources. Helps keep code clean when multiple closable objects need to be handled, e.g. input and output stream. &gt; &gt;Graal JIT compiler. Yeah, Graal is really nice. Since Kotlin compiles to JVM bytecode, it will be able to be used with the Graal virtual machine. Try\-with\-resources is a perfect example where we needed to wait for language improvements. Kotlin doesn't have a special language\-level construct for try\-with\-resources because this is just a simple utility function \(inlined lambdas are neat\). Adding utility functions in Kotlin almost seems like you're adding new language constructs so we don't need to wait for new versions of the language for these type of enhancements.
Primitive types are treated differently in Java. The best\-case scenario for a generic function would end up auto\-boxing primitive values. This could have scalability issues especially if used in a tight loop due to the added pressure on the garbage collector.
With jersey/jackson I'm able to have pretty nice and effective data classes. Yes, I have to have a default value for each constructor argument so it has a no-arg constructor, but it still doesn't end up being that much work. here is an example of a data class POJO that I have serializing to JSON using Jackson/Jersey and it's really not that bad. @XmlRootElement @XmlAccessorType(XmlAccessType.FIELD) data class PersonDTO( var personId: Long = 0, var name: String = "", var phone: String = "", var email: String = "", var panel: String = "", var member: Boolean = false, var returning: Boolean = false, var present: Boolean = false, var panelId: Long = 0, @field:XmlJavaTypeAdapter(LocalDateAdapter::class) var becameMemberDate: LocalDate? = null)
Defect is maybe a strong word. Maybe a flaw in language design?
For long builds, if I’m done with everything else, I leave the room. It would be nice to able to set a timer more precisely. 
I found the need for this tool when building large projects (10 mins + including unit and integration tests). I wanted a way of quickly checking the progress and seeing an ETA so that I could coordinate my workflow around the build.
Tl;dr: The author talked about the following three things: Parallel full GC for G1 Application data class sharing Graal Was hoping for some metrics. :/
boolean eq(Object a, Object b) { if (java.lang.Class.isPrimitive(a) &amp;&amp; java.lang.Class.isPrimitive(b)) return a == b; return a.equals(b); } 
Great suggestion, as /u/Ek_Los_Die_Hier points out we can do this by adding a bash function ~/.bash_profile. I will add this to the README, thanks :)
I'm sure that JDK 11 will align the Oracle JDK binary with those produced from unmodified OpenJDK source. The last piece was the Flight Recorder JEP (328), which was moved to targeted status last week. However, even with this complete, things will still be hard for enterprise Java users. If you use the OpenJDK binaries they may be functionally equivalent to the Oracle ones but they will only have six-months of updates. To continue to use Java and receive security patches and bug fixes (for free) it will be necessary to update your JDK every six months. This could well include breaking changes (both additional features and the removal of deprecated ones). Few users wnat to have to do that, which is providing more business opportunities for us. Aside from indirectly promoting our alternative, I think it's only fair to make people aware of what's going to happen in September (and then January next year when JDK 8 public updates stop) so they have as much time to plan for this as possible.
agree that this is a cool tool but seems rather unnecessary. I use Maven every day for work and have never wondered..."If only they had a progress bar".. but I appreciate the creativity. cool stuff
But why in Python?
Needs to be adapted for Windows.
This looks really nice, and I can see that someone who uses Excel on a regular basis can use this. One thing: on the download page, you list support for the free version as 'during evaluation' which is 30 days. How does this expire? I mean, can't I just download it again to restart a 30 day support period? I recommend to clarify this a bit more. Keep up the good work!
Yeah, I mispoke. I mean "traditional" Java GUIs with Swing/AWT. The default themes are pretty nasty for those, but the API is well designed. I'm assuming that if schools "still teach Java GUI" they are teaching Swing/AWT... 
Agreed, though the default styling with Swing isn't very pretty... but with some work you can make it look pretty good. 
Thanks! :) The evaluation is tied to your PC, so if you re-download it then the evaluation period doesn't restart. You can of course keep using the free version after the evaluation period has expired though. With regard to support, even after the evaluation period of course we will answer questions and try to help as much as we can, but priority will be given to licensed users.
I think you need to provide more information about what your expected outcome is. This helps in all specification problems in finding the correct solution. In general, if you are creating an html editor, then j2html (as suggested) might help you get started, if you are just wanting to display html, Freemarker (or JSP/Thymeleaf/Others) will do that. If you are creating a tool to generate html and edit nodes, you need to regard html as a tree of data, and then traverse it, while applying some form of transformation on the branches. Treating html as text is usually not the way to go about in working with it. 
No they aren't. Swing has good look-and-feels available in the JDK. 
What is the licensing for this?
It's a commercial product. You can read the license agreement by clicking the 'terms and conditions' link on the download page (on the form that appears when you click the download button), or it's also included in the download. I hope this answers your question.
If you use magic frameworks like Vaadin, Spring or JavaEE you have to use the Ultimate edition, as the Community edition is not aware of several contexts.
What I'd really like to do is to get input via JavaFX GUI and generate an html with a list of the input. The thing is I want it to be able to also edit and append or delete certain entries of the list of input. And thanks! I will search about it more.
Your definition and my definition of reasonable are vastly different: Max # of supported servers Price/year (Standard Support) Price/year (Premium Support) 25 $12,000 Not available 100 $28,750 $34,500 1,000 $86,250 $103,500 Unlimited $258,750 $310,500 
What I understamd from this, is that you have a list of some sort of input (as in an Array), that you want to edit that list, and then press a button in a GUI to generate an html document as a result? If that is the case, look into Freemarker. It is a simple to understand templating library, with enough power to to pretty crazy things, if you need to.
java bytecode is a pretty literal translation of the source. the only optimization that you really see is reusing registers for different variables as the scope changes. and that simplicity is one of the great strengths of java - instrumentation is trivial all the magic happens in the jit
Ahh. Makes sense.
It's a way great way to start learning lambda expressions .
The maven-profiler extension is what you are looking for. https://github.com/jcgay/maven-profiler
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
That's exactly right. It runs a JVM (you can choose whichever JVM you want) embedded in the Excel process and handles all the function registration and argument marshalling between Excel and Java.
I also need to read this html later on and be able to edit it. About Freemarker... I'll look into it! Thanks again.
&gt; Why use lambdas in Java? &gt; A more concise syntax After using lambdas for a while, I find that code is harder to read when I read old code I don't remember at the moment. Oh well, I might be doing something wrong. I'm still learning
Would not use Hibernate again if I had a choice. It's not quite so bad that I'd refuse a project with ot, but I'd prefer to avoid it. I wrote a personal project with jdbc. It's more straightforward, but **extremely** verbose and repetitive. Welcome back to needlessly checked sql exceptions, rewriting setup code over and over, etc. What I'd use now is Spring's JdbcTemplate. Cuts out the boilerplate and checked exception annoyances of jdbc, but leaves in the direct control. I'm using it at work it works well. Jdbi looked similar without the overhead of getting spring running, but spring was a better resume buzzword. 
Username checks the f*** out!
Thanks for clarifying on the other comment how AM works. When I said "moderators", that was due to my lack of knowledge on how things work. Please take my comment as "Moderation should fight...." not "moderators".
You mean like `(a,b) -&gt; b.foo(a.bar(b))`? You can put the types in there, too: `(Baz a, FizzBuzz b) -&gt; b.foo(a.bar(b))`
If garbage collection no longer "stops the world" that would be a profound development. I'm sure there have been many hacks because of "stop the world".
great point. use them only when appropriate. developers can get carried away with shiny new toys. 
Not really in-depth... But it is a nice tutorial
Yes, on ArchLinux I enable it with `/usr/lib/jvm/java-10-openjdk/bin/java -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:+UseJVMCICompiler -Djvmci.Compiler=graal `
GitHub gives you 5 ( I think) private repos. I believe Bitbucket will do unlimited private though, if that's important to you 
private repo on github costs $7/month
Bitbucket.org also offers free private repos
It's a must for Android development and is very commonly utilized. Android Java moves much slower than OpenJDK. Kotlin vs Java 6 is night and day. Kotlon vs modern Java it's open for debate.
I used Excel VBA for years and still do now and then. How is it "complex" or "brittle"? O.o Still, it is nice to see a Java tool for Excel.
Yeah I kinda find the same thing with them. Even though I've gotten better the more I've forced myself to use them, sometimes it still takes a second for me to grasp what exactly is going on. That's okay for the most part, but what is really bothersome is how much they seem to confuse other people who aren't familiar with them. At least right now in Java, for the most part they are almost more trouble than they are worth.
Why not? Could have been written in Ruby or JS for all it matters. For small tools like this where performance doesn't really matter, it could have been written in brainfuck for all I care
There's gitlab
At first, make sure you understand HTML markup and CSS styles, otherwice you will be upset about ugly servlet pages Secondly, i can look up for you some other ways of building HTML pages in java Feel free to message me, i’m a beginner too, but i have a lot of experience xD
It's like $7 for github per month. I used to host my own repo but it is really just easier to pay for it.
Lamvdas to me demstrate why Java is "verbose". Code take more space it's clearer to read. Lambdas are more compact but not more readable in my opinion, it actually takes me longer to figure out what they're doing compatred to Java7 equivalent code.
Or just name your variables... 
An actual in-depth look at Lambdas and Streams, [Get a Taste of Lambdas and Get Addicted to Streams by Venkat Subramaniam](https://youtu.be/1OpAgZvYXLQ)
gitlab is great. it's private and it's free and has all of the same features as regular git minus everyone being able to see your contribution count (basically a visual representation of how actively you code)
should be a maven plugin.
just have your own VM somewhere and install gitolite and dont worry. have everything you need.
You might be able to help me. For example, if you had `email` a value type `Email` like so data class Email(val value: String) How would you convert to json using `@JsonUnwrapped` or do you only use primitives everywhere to avoid it?
+1 for gitlab
I understand your point, but you can't say it's freeware... It is opensource. You can [check out](https://github.com/JetBrains/intellij-community) the code and submit a patch. It has a different version that is not opensource, sure, but that does not make Community version any less open source. Red Hat has versions of their software that you cannot download without a paid account and do you call those freeware as well? 
&gt;tofiffe sure sure, but in my opinion the extension functions are a bad thing, sure it's shorter to just use an extension, but more often than not such functionality is added to a class that has little to do with it \(and of course you have to import the correct one, since many people write similar ones\)
Because Python is a good scripting platform with good support cross platform, that has supplanted a lot of other scripting languages by default? While I appreciate that this being /r/java there may be some that would have preferred Groovy, I personally would use Python for any scripting that requires anything more complex than basic bash. Especially if I don't know what the destination box that it will be run on.
You could always go for cygwin or cmder for pipe operations.
Sorry, but I want my err output clean... try {...} catch (Throwable ignored){}
Yeah I agree with the other responses. I actually started writing a bash program to see if I couldn't minimise the dependencies. But alone it wasn't powerful enough so I chose the next scripting language that is as comfortable with being Python. It also had the cross platform console colouring and really great progress bar libraries that I needed. Java isn't as rich in this regard. 
It's not that VBA is complex as a language, but the code written in it can often end up being complex as it doesn't have such a well developed ecosystem of libraries. Often VBA programmers are forced to re-invent the wheel or do things in a way that is more complex than could be achieved with the types of data structures, language features and 3rd party libraries that are available in other languages. By brittle, I mean that changes can often have unintended consequences. This could be true of any software, but the tooling for VBA isn't as advanced as other languages and so it can happen more easily. This can be more of a problem when one person has been responsible for a spreadsheet that's built up over years, and then they leave and someone else who is not so familiar with the code has to maintain it. Without unit testing or any kind of code analysis any changes to the code are more at risk of unintentionally breaking something else. Finally, because VBA is embedded in the workbook itself, when a spreadsheet gets shared around or emailed between people, if a bug is later discovered or some external system that the sheet depends on changes, tracking down all uses of the workbook (or bit of code that has been copy and pasted between multiple workbooks) within an organisation is hard. By deploying the code externally from any workbooks (on a shared network drive for example) the problem becomes easier to manage. Also, using source control for VBA is not commonplace (though technically possible), whereas it is for development in many other languages (including Java/Scala/Kotlin).
You have the same issue with Commons libraries.
can we have an idea of the price?
As someone coming from Haskell, where the syntax for lambdas is nearly identical: Yes, they will become much easier to read over time. Being used to this style of programming, they just seem natural. And then sometimes I run my head into a wall I didn't expect, because they're not *quite* like Haskell's anonymous functions. 
Also, I should have mentioned that you can use it for free with some restrictions (see https://exceljava.com/download.html). The free version should be adequate for small personal projects, so if that's your use case then it won't cost you anything! If it is just personal use you're after and you feel the free version isn't sufficient please email me to let me know as that would be helpful feedback.
Yeah did that. It was complaining about python env.
So, about OpenJDK LTS: - Support until the next feature release - LTS support until the next release (but *not* by oracle engineers - possibly adoptopenjdk will get an "official repo"?) and possibly longer - Oracle will provide OpenJDK builds *of the current feature release* - no mention of LTS, so maybe no official LTS builds?
As an enterprise user, I'm really skittish about the notion that I can't ignore non\-LTS releases. 
So I've never actually used JsonUnwrapped before so I had to Google it. If you see my example above you annotate the data class the same way you would a normal Java class. Any annotations that would go on a field need the field prefix (again see my example). Just keep it simple and it just works.
Why? I get that you don't want to deploy to customers, but as a enterprise user you should already have a CD-Pipeline and it shouldn't be expensive to constantly let it run your tests and build with non-LTS in addition to running it with LTS and thus all the deprecation warnings should be available to you as early as possible and you have now 3 years to ensure that everything works fine instead of having to become increasingly scared when your LTS version comes close to EOL.
Is there a way to enable it for all runs?
Will they preserve backwards compatibility and still allow the current switch \(and still allow accidental fall through\)? Having safer options to choose from is definitely a good thing even if they do preserve backwards compatibility.
Yeah of course they'll preserve backwards compatibility with the current switch. As for allowing fallthrough with the new expression switch ... this is a point of contention on the mailing lists. There has been a lot of discussion about it but iirc one of the proposals is to have a colon form (as we're all familiar with) which does allow fallthrough, and also an new arrow form which doesn't need the `break` keyword, doesn't allow fallthrough, and looks something like: int result = switch (something) { case "one" -&gt; 1; case "two" -&gt; 2; case "three" -&gt; 3; } I'm not sure whether the above would need a `default` or if expression switches just come with an implicit throwing default, you'd have to read through the recent amber mailing list archives for more details.
[removed]
I think it remeberes these flag between testers, try the command above and later try java -version it should say graal is enabled
SVN for a new project?
I do not agree.
You presume that we've finished the transition away from waterfall. That is decidedly not the case, and won't be the case for so long as we have that damned mainframe. You also presume that we haven't just started talking about CICD. Again, not the case: we're only now *struggling* to get CICD up and running. Last, dev environments that don't match PROD are an exercise in frustration. I absolutely do not want to come to rely on new features that aren't there in old versions, which *will absolutely happen* if I'm developing on a newer version of the JDK than I'm targeting. For example, we're on Java 7 at work, and I'd give quite a bit for default implementations and lambda expressions. But they're not on the target machine. The issue isn't deprecation. It's new stuff being in the dev environment that isn't in PROD.
Okay. :) 
Agree that the change wasn't for the best. It requires some retraining of what is what for very little upside. 
There are three negative points IMHO: 1. Debugging and looking for memory leaks: all these anonymous instances make almost impossible to find roots. 2. Much more easier to write noodles. 3. Cascade lambdas. No problems reading modern java code, but that blows my mind.
My single thread mind is totally happy to find some order in Java and that world. But, as a developer in industry: Legacy projects, sweet legacy projects. :\)
1
Even one bit will be enough, depending on how you write/read it.
0 If the file exists, it means it's true, otherwise it's false
It’s not that, the objects of a class have a boolean field and to get the max size I need the amount of bytes the boolean can take when I write it
&gt;Compiles down to Java, compiles down to JVM bytecode\-\- seriously it's more or less the same, you can even easily compile the bytecode to Java Hmm, you didn't read the first paragraph or even the entire first sentence of my response. Read it again and that will show why this statement is incorrect. Regarding performance, Java 8 lambdas perform significantly worse than inlined Kotlin lambdas \(especially capturing lambdas which are the most common\). Here is an article with benchmarks that shows pros as well as cons:[https://sites.google.com/a/athaydes.com/renato\-athaydes/posts/kotlinshiddencosts\-benchmarks](https://sites.google.com/a/athaydes.com/renato-athaydes/posts/kotlinshiddencosts-benchmarks)
Why aren't you using serialization or JSON? They'll handle this for you. 
I would but I’m required to do it this way
Looks like Instrumentation returns the size of any object in bytes https://stackoverflow.com/questions/9368764/calculate-size-of-object-in-java
Documentation I can find says one byte if you're using the writeBoolean function. https://docs.oracle.com/javase/10/docs/api/java/io/RandomAccessFile.html#writeBoolean(boolean)
Either 1 or 0. Possibly both, depending on the size of your computer 
Why can't you ignore non-LTS releases? You can use LTS-only releases if you want.
It’s for an exam, we have to use serialization random access files and db4o but thanks I’ll ask there next time
If you have 8 separate booleans you can store them all in one byte 
random access file???? bloody hell that takes me back a bit! I would say 1 
Doesn't asking people online defeat the purpose of taking an exam? Have you really learned anything if someone else gives you the answer? Not trying to be a jerk, but you're doing yourself a disservice by not putting effort into this yourself.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
One byte is all you need to store a boolean in the simplest way possible \(without bitwise operations\). To convert between boolean and byte you can use the ternary operator `byte b = boolVar ? 1 : 0; boolean c = byteVar == 1 ? true : false;`
Not everything is web development. You don't need a special file format like JSON if you're serializing some known data, especially since the OP is using a random access file.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
-1
Thanks for contributing! Wish the main project could get this behavior, is there a enhancement request @ Apache?
this is trivial with spark. root@master:/# spark-shell Spark context Web UI available at http://172.22.0.2:4040 Spark context available as 'sc' (master = local[*], app id = local-1526784177284). Spark session available as 'spark'. Welcome to ____ __ / __/__ ___ _____/ /__ _\ \/ _ \/ _ `/ __/ '_/ /___/ .__/\_,_/_/ /_/\_\ version 2.2.0 /_/ Using Scala version 2.11.8 (OpenJDK 64-Bit Server VM, Java 1.8.0_162) Type in expressions to have them evaluated. Type :help for more information. scala&gt; import spark.implicits._ import spark.implicits._ scala&gt; val someDF = Seq( | (8, "bat"), | (64, "mouse"), | (-27, "horse") | ).toDF("number", "word") someDF: org.apache.spark.sql.DataFrame = [number: int, word: string] scala&gt; someDF.coalesce(1).write.parquet("file:///app/data/sample_parquet") scala&gt; :quit root@master:/# ls -lah /app/data/sample_parquet/ total 12K drwxr-xr-x 6 root root 204 May 20 02:51 . drwxr-xr-x 253 root root 8.5K May 20 02:51 .. -rw-r--r-- 1 root root 8 May 20 02:51 ._SUCCESS.crc -rw-r--r-- 1 root root 16 May 20 02:51 .part-00000-c17d5420-02ff-431a-8b3c-bf9afdb013c6-c000.snappy.parquet.crc -rw-r--r-- 1 root root 0 May 20 02:51 _SUCCESS -rw-r--r-- 1 root root 576 May 20 02:51 part-00000-c17d5420-02ff-431a-8b3c-bf9afdb013c6-c000.snappy.parquet 
The nice thing is that all one has to do is lift these files from the **`arvo2parquet`** project and can then use the Apache Parquet Java libraries as is - just as my project did: `com.tideworks.data_load.io.OutputFile` `com.tideworks.data_load.io.InputFile` Just change the package name to suit the program they're dropped into and then follow the examples seen in methods: `com.tideworks.data_load.DataLoad.writeToParquet()` `com.tideworks.data_load.DataLoad.readFromParquet()` As to how to instantiate `AvroParquetWriter` and `AvroParquetReader` using their builders. These builders for instantiating these two classes work exactly the same way if were creating them for the Hadoop hdfs scenario. That is what is nice about this solution approach.
We did a similar thing at work. https://github.com/HunterSherms/Pojo2Parquet
yeah, bringing in incremental data already set in columnar format - Parquet - looks to be something that will be a common theme in this big data community looks like we've confirmed one another on its desirability And basically the approach I used can be followed to trivially make adapters to work with any manner of streaming-oriented storage system. Well, other than the reader will need to support random access seek - so that implies has to be a file and not just a pipe.
delete
Sure, you may find the price unreasonable. Remember two things, though 1) we need to employ people to provide the support, they don't come for free and 2) what I actually said was "...very reasonable *compared to* our competitors". Check the Oracle list price and tell me our prices aren't reasonable :-)
I rarely if ever use the commons libraries, for the most part I don't need to. When I do need them it's still a little bit clearer since it's grouped in appropriate subclasses, which is fairly easy to read Javadocs to.
Does it have to be HTML? You can easily write, read and manipulate XML with Java, and if it needs to be human readable to create a XLST stylesheet for it.
You have to test with each release so you'll get deprecation warnings. If they deprecate something in one release and then remove it in the next one \(unlikely, but possible\), jumping ahead to the next LTS will make you skip that transition phase, resulting in errors instead of helpful warnings.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
IMHO, by specifying them all in java @argfile only.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Nice! I have been meaning to get started playing with Keycloak and microprofile!
it's truly amazing 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You may not want to use Spark and other tools in Big Data stack. However Spark does not force you to use HDFS, you can read and write to NTFS, EXT4 or S3 file system.
Have you looked at Jdbi 3?
I've only just heard about ebean the other day. How has your experience been with it?
I upvoted but it is painful trying to do query limits and doing column ordering. I ended up using antlr to do string manipulation on the SQL query.
&gt;... it is painful trying to do query limits and doing column ordering. I don't get what problems you faced. Can you provide some code or pseudocode?
Here's a stack overflow question related to what I was talking about [https://stackoverflow.com/questions/16790529/dynamic\-order\-in\-jdbi\-sql\-object\-queries](https://stackoverflow.com/questions/16790529/dynamic-order-in-jdbi-sql-object-queries)
I see now. I never liked SQL Objects and only use the Core API so I didn't have to face that problem.
Spring Cloud Gateway and Unit Tests have nothing to do with each other. Unit Tests are separated from the environment and Spring Cloud is the environment. Since you are using dependency injection, it would be better to inject mocks into your controllers for tests, so that they are tested in isolation. For testing Spring Cloud integration, I would boot up the full app and test with HTTP in a real functional test. This is way better than trying to figure out how to partially set up Spring Cloud, chasing down dependencies.
I'm personally a fan of simply rerunning the edited classes associated test class. I've never really felt I need a plugging to automate this procedure for me.
While moving away from Ant is an improvement, I am not sure that Maven is the best possible choice. Why not Gradle?
Same, never really been a fan of automatic test run-on-save. To often it runs when I don't care, such as when fixing compile errors, or other changes I'm in the middle of and don't expect tests to pass. Or, it starts running, I fix I small mistake and then either have to wait for the tests to finish and then rerun, or kill the sequence and restart it. I'd rather just press the button.
I'm fond of plain old JUnit -- I roll the tests that are local to each component of my product suite into their respective Maven/Gradle/whatever builds, and in my CI rig (I still kinda like Jenkins) I keep a parent project that does integration tests, Selenium stuff, and so on before the per-platform jlink, bundle, sign, install tasks. So: small cheap tests close to the components, big expensive tests as the components get integrated in CI.
Most IDEs allow you to setup a "Run Configuration" for your testing framework. You can then setup the configuration to run a Test Suite when related classes are modified. Alternatively, you can setup Gradle, or your favorite build framework, to run tests when classes are modified, usually during automatic builds. Good IDEs will provide a UI to show the result of builds that run tests.
What’s Java OS?
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
great read. it's hard to find good articles that speak to the different programming paradigms that can be practiced with Java. Also, do you think that Java 8 lambdas and stream API are sufficient to replace the Scala programming language?
Bamboo from Atlassian. They are generous with FOSS projects.
I don't think those are enough to replace Scala, but you will find that some features found in Scala will be coming to Java soon, such as [data classes](http://cr.openjdk.java.net/~briangoetz/amber/datum.html) and [pattern matching](http://openjdk.java.net/jeps/305).
Continuous Testing is not just merely about re\-running tests while typing, which you can easily do with a simple shortcut: it is more about shifting the focus from tests to the production code. Take NCrunch, for example which is a magnificent continuous testing tool \(unfortunately, only available for C# on Visual Studio\): after the test is written, it continuously runs it, it calculates the covered production code and it decorates it adding annotations just like the compiler would do with compilation errors. [https://i.imgur.com/afWkMVz.png](https://i.imgur.com/afWkMVz.png) With tools such as NCrunch, after you wrote the test, you can forget about it and concentrate on the code. When something is bad, it's not "a broken test", but "some broken line in production code". NCrunch helps identifying the offending line in the production code, and it does it in real\-time, and decorating the source code, exactly just like the IDE does when it highlights a typo with red underline. There is a short demo video on [ttps://www.ncrunch.net/](https://www.ncrunch.net/), it is worth a watch. Unfortunately, I haven't found anything just complete as NCrunch for the JVM...
In-depth is relative. Add your commentary to the article itself and add your thoughts so others can learn. Your feedback is appreciated. 
I think it's easier to use since it don't have the concept of entity manager. And the query API is much better. The only problem is it's not that popular as hibernate is.
A static nested class is a nested class that is static. No shit Sherlock.
I found it interesting. Especially the anonymous classes. But, I've only been learning Java for a couple months.
This is a badly re-written mash-up of articles referenced in the article. Just read [this one by Jenkov](http://tutorials.jenkov.com/java/nested-classes.html) instead because it explains WHY you might want to use nested classes. 
I find calling Java “declarative” strange. Query languages like SQL are declarative, in that you literally describe the data that you want, and there is a query planner that figures out how to get it done. Well-designed Java code may have some methods that are “declarative,” but that’s a result of the developer’s choices rather than language features. The article’s example is declarative-ish, I guess. However, I think the example is much more likely to confuse readers — especially those readers not already familiar with the declarative paradigm — than to educate them. 
Yea it's a tutorial. There is no way to justify calling it in-depth
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
The title of the post is misleading. The JVM doesn't check exceptions. As far as the JVM is concerned, the concept of checked exceptions doesn't exist. There are no checked exceptions. Throw whatever you please. The 'throws' clause of any method is like a comment. The JVM completely ignores this. It's javac that does the checked exception thing. The trick described in the blogpost fakes out java. You can use [lombok's @SneakyThrows](https://projectlombok.org/features/SneakyThrows) to make this work without the utility method. (disclaimer: I'm one of the lombok developers).
I don't really understand the point. Do I understand this correctly: it marks lines covered by failing tests and at the same time not covered by succeeding tests as erroneous? How does this help in actual debugging, since you still need to write tests for new code and still gain no info about the *context* (i.e. Input data) of failing tests from the inline "failure coverage" data alone? This sounds more like a mediocre addition to the already-flawed metric of line coverage than a useful development tool.
Yes, you are totally right, the first article seems a little awkward. “cascading lambdas” and “functional purity” articles are awesome because these two points generally don’t be discussed by articles for fresh Java developers, but rise problems like as code readability and liability.
I like two articles from that series: “Cascading lambdas” and “Functionality purity”. 
Article with misleading title that's basically the most widely known "surprise fact" about checked exceptions with a hint of click bait in the title *checks username* of course!
I know it's just an example, but if the first one were real code I think most people would write this instead: public static void findNemo(List&lt;String&gt; names) { for(String name : names) { if(name.equals("Nemo")) { System.out.println("Found Nemo"); return; } } System.out.println("Sorry, Nemo not found"); } No need for "garbage variables" unless you follow "Do not return early" to its ultimate consequences.
Misleading article that's basically the most widely known "surprise fact" about checked exceptions with a hint of clickbait in the title, reposted to 3 different subreddits *checks username* of course!
Okay, that's it. You haven't learnt anything despite **several** warnings. You still post *low quality tutorials* here and mask them as "in-depth" articles. You continue to spam. **Banned**
I remember when Grails was pushed as the next step for Java... It was Java without all the hair... Sponsored and pushed by Pivotal, my company decided to get all the 'front end' work hosted by grails. .... And now, Grails has fallen out of favour... and now "Kotlin is going to be big" 
Compare the linked video 'Make the magic even more Magical' https://www.youtube.com/watch?v=BiwzAnjrS9o With this "Live-Coding No-Ceremony Microservices" https://www.youtube.com/watch?v=qQtF-Ks0c5U Really...watch both.., and make your mind up.
The great thing about Gradle is it allows imperative coding style within the build script, allowing total flexibility in the build. The shitty thing about Gradle is it allows imperative coding style within the build script, allowing total flexibility in the build.
I am not too keen on Grails as well, but I think Spring Boot will be better analogy to Grails. Kotlin is just a language that you can use without all the magic!
Absolute trash
Marketing tip: - not so interesting info: you, first (remove from future title) - much more interesting info: what does it do, how does it add value (add to future title)
You might laugh but if all you want to do is write your code a bit easier and not have to relearn a new language Groovy might be for you. Looks just like Java and has a lot of the big features that Kotlin has if you want to use them. It’s still actively developed along with Grails. 
I would probably just use contains if I’m being honest. 
So what would even be the use for something like this?
A website preventing right-clicks or text selection? Have not seen that in a while.
Unfortunately, that's not quite so true any more as it once was. They diverged from Java 6 or 7, so now modern Java isn't as easily converted to Groovy. In particular they have different syntaxes for lambdas (mostly because Groovy has had closures for a lot longer). 
True. They don’t have try with resources for example but the differences between the two is summarized on a single page whereas Kotlin is completely different. I guess it depends where you work but I haven’t worked somewhere where the code is already filled with streams. 
Spring is changing for the better but I am not coming back to it. Dropwizard and Java Spark are the future.
I never ever had the impression that Grails was "the next step for Java". It always seemed pretty clear that Grails was "Ruby on Rails on the JVM" for people who might want that for some reason.
Solved by annotating the dependency with @Lazy
Yes, I know. Welcome to Enterpriseland, where we pay out the butt to use old versions.
Nope. JUnit doesn't hold a gun to your head with respect to any subsequent technology decisions. Mockito is a nice way to make mocks, but JUnit is all about providing a nice easy way to declare tests, and define pass/fail conditions. What you test and how you test it is entirely up to you.
I think the next release(s) are working to rectify that a bit.
Maybe I'm getting old, but I think that 6 month cadence is too much if we should test out applications even on non-LTS releases (IMHO 1 year would be better). I'm worried that they will break stuff faster than we'll be able to fix it (to be frank I'm sure that we would be able to quickly fix our codebase, but 3rd party libraries are another story).
Even if you can do this, why would you ever want to?
What do those hints suggest?
Would it not be confusing to have two different syntaxes for lambdas? I realise that closures are not quite the same as lambdas, because they're instances of `Closure` rather than an anonymous inner class with one method. 
http://www.jnode.org/ (Java New Operating System Design Effort)
Consider an existing class class Cell&lt;T&gt; { T value; Cell(T val) { value = val; } boolean contains(T that) { (this == that) || (this.value.equals(that)); } } Now assume that `Cell` is specialized in `T`. - How does the implementation of `contains` look like? - How do the semantics change?
The two things are related. Mostly, you want to include the added value in the title, and since titles are supposed to be short, there's not much more room left for your own story. You can still add it to the linked page if you want, but not the title. In some cases, your story is the actually interesting bit, as in "How I implemented my first Java OSS library within a week, and what I've learned about it". In that case, the added value is not the library itself, but your journey. But that's not the case in your linked page, so simply skip your personal info and get right to the added value.
Well this is interesting 
Why is Oracle releasing new features for a language version that they'll be deprecating in a few months? Is the goal to make the first release of Java 11 less distinct from Java 10, so that commercial developers have an easier time switching to version 11 quickly (i.e. before support for versions 8 and 10 is removed)?
Yeah, the session / entity manager really adds needless complexity to most apps. That's where I think Hibernate originally went off the rails--but it took a year or two struggling with it to recognize the source of the pain.
Why would they not introduce new features in new versions?
This is so useful on a page with code snippets.
..*distinguished* click-bait.
You know the features introduced in Java 10 aren't going to go away in Java 11, right? Why wouldn't they release what they can now? They get more feedback, faster, and we get features sooner. 
Its goal is not to measure code coverage, which I agree with you is a poor metric. Have you seen the video? I think it makes a good job in explaining what an ordinary development session can be with tools like that.
Flavor of the month
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Right. So, back to my original question: is it possible that Oracle is trying to cram more updates into Java 10 so that it's easier for people to switch to Java 11, or is it just part of the usual update cycle?
&gt; What's there to be fed up about? This is how it has always been. &gt; &gt; Do you know JSP tag templating can be used for component MVC in JSP? or that @named objects can be used in JSP, or that you can @inject into servlets? or that @resources can be used to inject resources into vanilla tomcat? Because these are technologies that are provided by default... now.. with no frameworks. Or did you ignore them and go for the shiny? 
New features are released when they are ready, and it does not matter if the next release will be an LTS release or not. Thats is the core idea behind the new fixed release schedule.
Aaahh, that makes sense. In that case, my original comment is neither valid nor relevant.
Ok, that makes sense. To be honest, my theory was quite tenuous to begin with, but I was just curious.
&gt; Do you know JSP tag templating can be used for component MVC in JSP? Not really. That's why Facelets exists. And why pretty much any component oriented framework does its own templating. JSP directly renders HTML, which serves action MVC well since the controller already executed. This is insufficient for component MVC, which have complex lifecycles. &gt; Because these are technologies that are provided by default Yes, I know all those exist, but they are insufficient. Frameworks do a whole lot more. For example, type conversion (from request to beans), handling content negotiation (HTML might not be yoiur only target), handling output types, security, etc., etc. You can use frameworks for this or you can assemble libraries, but the core platform doesn't provide nearly enough. &gt; Or did you ignore them and go for the shiny? I don't make fire by rubbing sticks together, either.
Any error to show us? And why are you setting password in header?
Does it work if you use aGFzaGlrOjEyMw== as the value for encoding?
Not really related but Postman can generate code snippets for a request using various libraries. It might not be what you need but maybe it gives you some insight. Also: [Preemptive Basic Auth with HttpUrlConnection?](https://stackoverflow.com/questions/7019997/preemptive-basic-auth-with-httpurlconnection)
Yea, saw the console if it is generating something extra arguments to make it work, but it's the same I think, but I'll update a snippet you can see.
upvote because of the name
Did you just assume its version?
Did you change your WildFly home? (JBOSS_HOME?)
Try [r/javahelp](http://www.reddit.com/r/javahelp)
So the first question to ask is are you certain you are using the correct password? In the code you show above you are doing String encoding = Base64Encoder.encode(username + ":" + password); This is using a variable 'password' to provide the password and a viable 'username' to provide the username. However in your payload you have the values hard coded: connection.setRequestProperty("password", "123"); payload = "{\"username\":\"hashik\",\"password\":\"123\"}";//JSON One debug suggestion I would make is utilize the variables from the encoding call when you are referencing the password and user name to ensure what you encoded is what you thought you encoded. 
Yea, I should have used them I am soo tired from trying to find this from morning, at this point IDk what I am doing...
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Stack overflow is a totally shit community today
You can also use int or long, and use cents or hundredths of cents or thousandths of cents as your monetary unit (whatever granularity your application requires). * I have no experience with extremely-low-latency financial applications...
I never worked in the finance industry, but I google a little bit and found this. https://stackoverflow.com/questions/3413448/double-vs-bigdecimal Another site that talks about why http://java-performance.info/bigdecimal-vs-double-in-financial-calculations/ I hope that helps! 
&gt; long, and use cents or hundredths of cents What if I want to store more than $92,233,720,368,547,758.07 in my account?
It depends on your financial and trading application. If your numbers are bound and you always round them before displaying then the precision of a double might be enough. Of course your calculations in your code also must account for the fact only doubles are used. Also depending on your definition of "low latency" BigDecimals might be fast enough. Of course if you want to save every microsecond/nanosecond possible, then you are limited in what you can do.
Pro trip: Split that money across 368,934,881,474 bank accounts so that you're fully FDIC-insured!
[What Every Computer Scientist Should Know About Floating-Point Arithmetic](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html) Its a trade off between speed and accuracy. If you are working with money you typically want accuracy. Its usually regulated and has strict rules on rounding accumulated error. For high frequency trading, where you are just looking for a number to trigger off of, you might use doubles. But you would be using C++ anyhow.
Risky. Yes it can be done, but it often leads to errors because we don't generally think in those terms.
With everything passing through JSON these days, which only supports doubles, I'm starting to wonder how important those rounding errors really are.
You would serialize a BigDecimal value into a [string](https://docs.oracle.com/javase/9/docs/api/java/math/BigDecimal.html#BigDecimal-java.lang.String-), won't you?
the answer is yes to all of that. it depends on what’s being calculated. BigDecimal and Azul’s Zing is a good combination where accuracy is paramount. If one is computing a theoretical value sometimes a double is appropriate in the calculation pipeline. When sending orders or dealing with order book prices it can be appropriate to use a long and call it pennies or hundredths of pennies, but extra discipline is needed to know that’s what is stored. 
A good rule of thumb is: if you need absolute exact math without any gotchas, you must use BigDecimal \(or equivalent on other platforms\) and performance will likely be dominated by database and IO so it doesn't really matter. On the other hand, if you need performance above all else, you're probably ok with a little quirky math. In an ideal world, you wouldn't need to make such a choice but life is made of compromises 
Which is why in most cases you should just use BigDecimal. But if you're in one of the cases where BigDecimal is too slow or uses too much memory then you have to be willing to make sacrifices to meet your performance requirements. Either your development speed will be slower because you'll spend more time doing testing activities or your bug rate will be higher because your code is less intuitive. Up to you which you choose.
If you need more performance use long and represent the amounts in cents. Never ever use double. That being said realize that using long means that any tables etc will require rendering of the amount so there is a performance hit, but overall it tends to be better then big decimal if performance is a big concern. And yes it also means you have caps on the amounts and have to have checks but for most people long will be more than enough. 
Recently contributed to an open source crypto and the unit was defined this way. For a moment I thought I had a lot more money in my wallet than I really did until I realized I was two decimal places off. Other devs eventually enlightened me.
I work with financial and insurance systems in the UK and we *always* use BigDecimal. We're often converting between different currencies and calculating broker percentage shares, so it's not uncommon for us to need very high precision. Personally, if meant to represent the 'true' value of a currency amount, then I think I'd always use BigDecimal rather that find inaccurate financial values further down the line.
Use int and use cents instead of dollars if you are that worried about performance. I feel like you must be pre-optimizing unless you are working on some high frequency trading application.
I think it's a good community, but, those guys are self righteous pricks, I mean it wouldn't hurt to help people \-\_\- 
As i can see, your csrf token is invalid. Check your authentication method in backend or try to disable it (just for testing purposes)
Many like Stripe do int as cents
No one will ever need more than 21,474,836.47 dollars.
It's really up to the serializer and deserializer. The JSON specification gives the syntax for numbers but not how their machine representation or operations. https://tools.ietf.org/html/rfc7159#section-6
No one will ever need more than 21,474,836.47 dollars.
It's really amazing how graal created a 'java native' compilation mode almost as a side effect. I hope we could eventually integrate it with maven and have a 'executable-x86' packaging mode
BigInteger?
Yeah this is incredibly irritating
I really wish I didn't suck at yourkit
Open jshell and type: ``` 0.1 + 0.2 ``` Now tell if it's OK to use double for storing money values.
I had loads of rounding issues using doubles, I was working with percentages. So In the end of you doing simple finances then double may get you through but if your calculations get complicated then big decimal all the way man. 
Maybe we don't necessarily need new languages, but having a new and shiny language to challenge Java is a good thing imho. A big problem with Groovy and Scala has been adoption. Kotlin is a supported language for Android which helps a lot and from my own experience, transferring from Java is not that painful. Java and Kotlin can perfectly coexist in the same project even.
JSON != Javascript
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Lacking such a standard, you have to consider the lowest common denominator. Which means you have to assume that it will be stored as a double at some point. And depending on how the JSON is compressed and transmitted, it may occur in unexpected places.
How is that different than how any program parses a text format? If you specify `BigDecimal` as the data type, a JSON number will be parsed as a fixed precision number. If a program in the middle of your pipeline is written by someone who doesn't design their program with the proper types, what can you do? 
That's my point. With JavaScript being used in so many places, It's getting more and more difficult to ensure data isn't being treated as a decimal in unexpected places.
JSON != Javascript Javascript is only relevant if one of the intermediate services is implemented in Javascript. If that service is not a web application, you have my condolences.
If the RIAA finds that you pirated one CD worth of songs, you'll need more than that.
I keep seeing people saying using long but haven't come across actual examples of this. Wouldn't you have the same situation if you try to multiply/divide? 
Floating point is inexact. It is an approximation. Nice for representing the approximate number of inches from here to Pluto. Or nice for knowing how many inches per second is an attoparsec per microfortnight. But not so nice if your paycheck is not accurate to the exact penny. Integers are exact values. You were paid a certain integer number of cents (eg, dollars, and cents). You do care if you were paid correctly. Never use floating point for financial calculations. I've used BigDecimal for years and it's simply not a performance problem. Even the capacity of a 64-bit signed long is more than adequate. See my post here about representing the US National Debt in hundredths of Argentine Pesos and still easily fitting into a 64-bit int.
Not sure how you missed that I was obviously joking about wanting to represent a rediculous amount of money AND you quoted the wrong limit \(off by one\) when my post you were replying to had the correct value.
No. With double your errors will be unforeseeable and hard to test for: floating point round-off crops up in unexpected situations. With int and long, multiplying and dividing will have more expected and foreseeable results. Your likely errors with long will be overflow and integer division: both very easy to account for.
Sure it is if you're analyzing price data rather than executing transactions.
This is not true. native-image has always been part of the Community Edition release.
I've worked on many multi-language projects. It's not worth the effort. "Language" is only one small part of a project. There is tooling, libraries, etc. etc. No matter what anyone says, Kotlin is not merely a dialect of Java (lombok _is_ that). Introducing a new language vastly increases the "surface area" of needed knowledge to comprehend and manage a project. It's simply not worth it.
&gt; we always use BigDecimal Ditto for the customs and duties systems I've worked on.
Look around. More and more companies are using Node as a proxy layer in front of Java/.NET.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Please read the sidebar.
Please, follow the *plenty hints* on the page and ask *programming help* questions in the appropriate subreddit **/r/javahelp**. **Removed**: Programming help
Fun reference for all languages: https://0.30000000000000004.com
You could even use thousandsth of a cent to make certain operations (low interest, division) easier
Nonetheless it is infecting every aspect of computing and I don't think we're properly dealing with it in this regard.
You might want to take a look at JavaMoney https://github.com/JavaMoney/jsr354-ri Though I am not sure it could be a dead project. 
I downvoted you simply because you made an edit about being downvoted. 
When precise rounding matters, I'd assume that people would use fixed-point arithmetic (such as an integer number of cents as others have mentioned), or better yet, a dedicated currency type that can be configured to use the exact precision and rounding modes found in industry/local accounting (and might just be a wrapper for a `long` or `long[]`, or implemented in native code to use the full set of instructions and data types available on the target platform, if the JVM cannot be convinced to produce sufficiently optimal machine code). When speed matters more than precision, I'd expect to see more use of doubles (or even floats), or fixed-point values depending on what performs the fastest in testing while keeping error acceptably low. When programming speed matters more than absolute processing speed or accuracy, I'd expect everyone would just reach immediately for double.
As an idiot that understands nothing, can you explain it to me?
Use unsigned __int64 and go twice as large.
Mortgage bank engineer here, we more or less completely forbid the use of double / float. I think maybe we have them somewhere in the code base, but definitely not at all in the DB layer.
I was going to abstain, but you helped push me over the edge. I too down voted because of the edit!
Oh my god no. Scaled integer values. Always. You've seen "Office Space" or "Superman 3", surely. There's a reason those things exist: people use floating-point numbers for financial values. Floating point isn't associative. Are you explain in a financial audit what exactly controlled the order or grouping of addition operations in your system? No, that will be a bad day for you and the company. Don't do it. 
In Ad Tech, microdollars aren't fine enough. You need to go to nanodollars. But wholehearted support on "Do not use doubles." 
He was trying to say that if what you do is analyzing, exploring or just plotting data, minimal errors won’t matter *that much*. If you are executing orders/transactions and the likes you need absolutely correct numbers though. 
HFT: "I don't care about every iota, as long as you boost yield!" Accounting: "This has to be exact, reproducible, and auditable." Pick your domain and run with it. OP is not stating which they're in. 
There are a lot of HFT firms that use Java. It's not as slow as people think.
Have you ever purchased gas in the US? The penny is the smallest unit you can pay \- but it's not the smallest unit when used in calculations. If you're storing as long you'll have to keep track of potentially different levels of precision in the numbers that you're using and ensure that you convert to the most precise and back again when doing calcs. 
No reason to downvote this. If you don't need exact values double is, indeed, fine.
Great point! I forgot about that. The general idea is the same though, just with different scales 
The JVM has a feature called HotSwap, a feature of the debugger API which allows limited updates to classes loaded in the JVM, allowing Eclipse to upload new class definitions. See [here](https://zeroturnaround.com/rebellabs/reloading_java_classes_401_hotswap_jrebel/).
Java runs in a virtual machine, a layer between the metal and the program, which makes it pretty straightforward to do things like this. C/C++ compile to native code, so there's a lot less room for tricks like this. However Java's hot swap capabilities pale in comparison to SmallTalk and Lisp.
Well, I guess it depends. When I think Java app, I think Java enterprise app with frameworks and libraries galore, because that's the real strength of Java. There's no way you're going to coerce all that stack to run that lean.
I was always under the impression that you were supposed to use an integer to store the number of cents. Is this not correct?
The next big release allows you to use the exact same syntax I believe. 
I upvoted cause this guy downvoted
If it is financial in nature, precision is required, period. Back before C++11 was a thing I was doing financial programming in Java with big num math, but it was so slow, so I wrote my own fixed precision library that allowed for a direct drop in for bigdec. I got a 4x speedup across the system while maintaining accuracy. The one area C++ shines in over Java is operator overloading, where you can write your own fixed precision library that looks and feels and acts like a native type. This reason alone moved my financial programming from the java world to the C++11 world.
Only if they are in different banks. (Technically it's a bit more involved, but $250k i in deposits per institution is a good time of thumb).
RabbitMQ ( an alternative to ActiveMQ ) has a great tutorial on AMQP concepts, which might help explain how queues work and how you could use them: https://www.rabbitmq.com/tutorials/amqp-concepts.html
That was quite entertaining
A more interesting question is why does it work so smoothly in the powerful, free Eclipse IDE yet in the free IntelliJ; it's clunky and almost unusable to debug in.
Interesting. Thank you!
Aren't you violating gdpr by posting my bank balance?
Because you loose precision if you are limited to cents. The calculation of a simple invoice with two positions can result in different values for the position sums, taxes and the total sums and taxes. The resolution to cents simply isn't good enough there. The same is true for *binary* floating point types anyway (like float or double). Just use a *decimal* based floating point type and your fine. (besides the differences you simply can't avoid even with decimal based floating point numbers) 
If you had 100 meaning 1 dollar I don't see what the issue would be. From what I understand Stripe charges a certain percentage on each charge rather than the total for the month so they would just round up or down (not sure which way they do it) on each transaction rather than needing to deal with fractions of cents. I understand doing this for banks where fractions of cents matter for interest and what not there could be issues, but I doubt Stripe would actually have any issues doing it this way. I don't think most companies need to deal with fractions of cents so its probably not an issue.
It looks like in your [submission](https://www.reddit.com/r/java/comments/8lgtmf/the_best_gui_framework/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I don't know what you are doing wrong, but it works smooth in IntelliJ, too.
Not true in the systems we build at my employer. We constantly perform tons of parallel risk calculations that each has tons of floating point operations. Using BigDecimal everywhere would most certainly have a very noticeable performance impact and is also unnecessary given the error on many of the calculation inputs.
For a very good alternative to JRebel that you don't have to pay for, there is also [DCEVM](https://github.com/dcevm/dcevm)
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Same. Never have I have issues on IntelliJ
There might be circumstances where this is ok. But for most problems with money, you will run into trouble soon (and I mean trouble like violation of *laws*!) To make it clear to you, imagine the following constraints for an invoice: amount position net tax gross 1 foo ? 19% 100 3 bar ? 19% 300 ------------------------------------------- totals gross: 400 tax: ? net: ? You want for the totals: tax + net = total and for the position net amounts: net1 + net2 = net_total So of course you have to round - but you need intermediate values in order to round the right value in the right place. So try to fill out the question marks based upon your solution 😉 - as you only have cent precision to store those intermediate results. (Hint: This is impossible with integer values with cent precision!)
If this bot literally interprets question marks as asking for javahelp it's a really, really, really, really bad bot.
Fair enough.
Did you actually measure the possible impact? 
If you're solving things like * find the average price of items satisfyting criteria X and Y on Amazon * look at the order book of a stock exchange (which chages every millisecond) and execute a trade when Stock X has buy orders for Y units at a price above Z. Then it really does not matter if your price data is off by 0.000000000001 cents - these numbers don't need to "add up" and change constantly anyway.
&gt; C/C++ compile to native code, so there's a lot less room for tricks like this. It's not a build-in feature of the C/C++ runtime, but absolutely possible. With C/C++ you have direct access to memory, including executable memory regions. JIT compilers do this all the time. Another example is the Unreal engine, which supports hot-reloading of DLLs and hot-swapping code (e.g. materials and compiled scripts) in development mode.
You better off asking this on /r/openshift. Oh wait, [you already did](https://www.reddit.com/r/openshift/comments/8krf48/how_does_resource_hibernation_work_for_the_free/)... :P 
Total account balance can be positive or negative.
I've worked on multiple banking back-ends. Some used longs (so amounts in cents), others used BigDecimals. It doesn't really matter; in most situations you hit other bottlenecks much sooner and if somehow a BigDecimal becomes a bottleneck integer calculations with longs are as fast as your CPU can get. 
You're working on some really bad systems then. API's I worked with just serialised them to/from strings. 
You can't compare "Groovy on Rails" to an alternative language though. Grails itself works perfectly fine (if you feel like using dynamically typed languages), it's just that the Rails approach of doing stuff went out of favour in favour of REST API's. 
&gt;However Java's hot swap capabilities pale in comparison to SmallTalk and Lisp. True; I was redefining the current object \(or changing its class? was 22 years ago...\) in SmallTalk.
Username doesn't check out 
That seems to be a pattern in Groovy. The same thing happens with == and .equals(). You can use either. I find myself writing it like Java so the lambda syntax is a very welcome addition. Java potentially has two ways of declaring anonymous classes now though so I feel like you could make the same argument. Same with variable declaration. 
Never had a problem with it in IntelliJ personally.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Event driven microservices pal. 
16 Gigs ram, it's more like to the author's point. In Eclipse, debugging seems to be far better integrated. I only wish Maven support worked as smoothly in Eclipse as in IntelliJ.
I've not seen hot replace work in the Community Edition, or integrated Tomcat, you only get that if you pay $$$ for Ultimate, come to think of it, I use Ultimate more now at work and can't recall seeing hot replace work in it either.
When you say risk calculations is this involving dollars and cents represented by floating points or just other things that involve fractions?
I am just hearing about it. Site says "Your project resources sleep after 30 minutes of inactivity, and must sleep 18 hours in a 72 hour period" So maybe you can schedule your inactivity? eg call System.sleep(100) at 3am. Too bad the price goes from zero to $50/month - quite a BIG jump.
Yes, that makes more sense. For the first case, my IDE spits a warning "unboxing might produce NPE", but in this case the compiler could really error out. The second case is especially weird for the outsider, since it relies on the constant pool's range, so, depending on how that's initialized, the example could or could not work. 
I looked at my old downloads and it appears you are correct, my apologies. I'm trying to remember what the difference was that prompted me to download the Enterprise edition to try something out...
I also used openshift's free hosting for my site back when I didn't care about server downtime, but the $0-$50 jump was too steep. I'm now with gandi.net, pay a bit over $10/mth, have much better hardware, and haven't looked back. The "must sleep 18 of 72 hours" requirement is new. Seems they're making sure you can't run anything seriously without paying for it.
Yeah, the price difference is pretty big - but for my purposes the restrictions on the free plan aren't a big deal for me. I'm planning on hosting a Discord Bot written in Java on a friend's private server so I could shut the bot down at night anyways (e.g. midnight - 6am)
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Ctrl+F, type some text, Shift+Arrows to select more text, menu bar -&gt; Edit -&gt; Copy ;)
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I don't know if heroku has support for java. but Heroku is good and the paid plan is cheap 
why wait? Spring already has a lot of websocket support...
This API is quite different from the one that Spring provides. This one is more low-level API.
User guide is here https://micronaut-projects.github.io/micronaut-core/snapshot/guide/index.html
Providing a WebSocket server is out of scope of JEP 321. Even though having a WebSocket server in the JDK some time later is not something impossible, I haven't heard of any plans on that. I'm personally not sure about the value it would have.
Not sure a websocket server in the JDK makes a lot of sense. There are a few libraries that can get you a server application up and going that supports websocket connections, I have used Netty for this in the past. 
You may want to have something inside the subclasses which is private to the class. Maybe the dog subclass has an element "tricks". There are many things that are similar between dogs and cows, like they might both have a "diet" element, and an "owner" element, but you can't teach a cow tricks, so it doesn't make sense for an instance of Animal::Cow to even have a null instance of the "tricks" element. Think of it as a "all squares are rectangles but not all rectangles are squares". We wouldn't say "why do we have squares, they're just special rectangles". There's all sorts of shrotcuts and tricks which you can use with squares that aren't true for rectangles \- similarly for subclasses of classes.
Use a contract account and flags for reporting.
&gt; but you can't teach a cow tricks hmmm, *opens youtube*. 
It's called [Composition over Inheritance](https://en.wikipedia.org/wiki/Composition_over_inheritance). Composition is indeed favored in many situations. Inheritance is a very strong coupling of superclass to sublasses (an *is-a* relationship). With inheritance the subclasses are also of the supertype. So you could do the following: List&lt;Animal&gt; animals = List.of(new Dog(), new Cow()); animals.forEach(Animal::makeSound); The compiler knows that every subclass of Animal has the method makeSound. Though this example would be much cleaner with an interface. 
In that example, why would you **want** to create an instance of Animal in Dog ? Normally Animal would be declared abstract and could only serve to be overridden by classes, and you could not make an instance of it. abstract class Animal { abstract public void makeSound(); } 
&gt; In **Java**, initializing a list requires a lot of ceremony Not anymore. See [`List.of()`](https://docs.oracle.com/javase/10/docs/api/java/util/List.html#of(E...)), [`Map.of()`](https://docs.oracle.com/javase/10/docs/api/java/util/Map.html#of(K,V)) etc.
Any benefit that these boutique languages (Scala, Kotlin et al) have come to Java eventually - and usually in a better form.
&gt; You can get very far by just syncing on a single relational database... In my experience it always ends up being a bad idea. Not only many people end up designing bad the queue and after it works correctly they start to add "just" one simple feature, then another simple feature, then another one until they end up with a shitty message queue that's giving a lot of problems. With a well-proven message broker you can start simple and go up from there.
I can tell you first hand that it's kind of annoying... You can't have custom Authorization headers besides Basic, see here as an example: https://clevertap.com/blog/java-9-httpclient-does-not-allow-custom-authorization-headers/ And even with this hack, you'll have mixed success (I couldn't get Bearer to work). The Executor for the builder is not flexible at all. An Executor which uses the current thread or only 1 thread stalls or errors completely. I didn't advance much after trying to figure out why things just weren't working. Who knows what else is wrong with it.
Continuing with this, if you have a list of animals and some of the animals implement the interface BarnAnimal while some do not, you can use the instanceof method to select a certain group of animals that are BarnAnimals, which do different things than normal animals. It just gives a good way of knowing what kind of thing an object is. Composition does not give you the ability to check if a class contains another one without searching its parameters, so you would have to know how to check for class instances like BarnAnimal within Dog. While inheritance may seem better in this sense, some more complex hierarchies may be difficult to keep track of, which is where composition comes into play, allowing you to better customize your objects. 
They gave up instead of reading documentation and finding the Kotlin way to get what they wanted, and "Java is better because it's trying to catch up." I see your sneaky Elvis on line 3. 
It usually represents potential profit and loss, so yeah, it's money.
Yes. Not in every single case, but we've experimented with both BigDecimals and doubles and it's simple to extrapolate. In any case, given that BigDecimals aren't necessary, it would just be wasteful to build new implementations that use them.
"Better" is very subjective. Had I written Java for 10 years - maybe. But since I used non-Java languages longer than Java, I would not be able to get back. I guess it's a matter of "taste": things you got used to, things you accept/cannot stand, habits, preferred patterns, etc.
groovy closures, one eye Elvis, two eye Elvis. Things I wish I had in java...
It's pretty common in the functional world, which is what a lot of the newer languages nowadays get inspiration from. We've gone full circle again. 
"Kotlin could be better" != "Java is better than Kotlin" Because Java could be a lot better too. The one thing Java will never be able to catch up with \(because it was fucked up from the beginning\) is reified generics. And the nitpicking about nullable types... Just because it didn't solve every problem doesn't mean it didn't solve a lot of problems.
I don't know Kotlin, but I could see some of the complaints the author had they would also have with Scala. Like reverse type declaration. `val x: Int`
This article is misguided at almost every turn. Point\-by\-point: * Name shadowing: Kotlin is not unusual in this regard. Lots of widely\-used languages \(e.g. JavaScript\) use the same scoping rules and nobody seems to have a problem understanding the difference between a variable declaration and an assignment statement. * Type inference: "Java does the same thing" is not an argument in favor of Java. * Compile time null\-safety: The author is horrified to discover that the null\-safety of Kotlin's type system only applies to code written in Kotlin, and suggest Kotlin should handle Java APIs in a way that would make it incredibly tedious to call legacy Java code from Kotlin. * Class literals: Passing a class literal to a legacy API requires an extra five characters. Boo hoo! He neglects to mention that native Kotlin APIs don't even need class literals in most cases where they're needed in Java, thanks to reified type variables. * Reversed type declaration: The author is displeased because Kotlin is different from Java. The whole section is just him trying to come up with objective\-sounding ways to justify an aesthetic preference. * Companion object: Once again, the entirety of the critique is that Kotlin is different from Java. If the author had started his career as a Kotlin developer, he'd be equally convinced that the idea of static members is ridiculous and counterintuitive. * Collection literals: Apparently the author never uses any collection types besides ArrayList and HashMap, because he wants a special syntax for those two types. He's disappointed that Kotlin's `to` method is a method rather than a language feature with special syntax. * Maybe? Nope: On one hand, yes, it would be nice if Kotlin treated nullable types as monads. OTOH, Kotlin has a much richer set of features for gracefully dealing with possibly\-null values than Java does. While it is possible to construct examples where Java code using Optional reads better than Kotlin code using null, it's equally possible to construct examples where Kotlin comes out ahead. Furthermore, it's not an apples\-to\-apples comparison, since Optional is only intended to be used for method return values. It says so right in the Javadoc! * Data classes: The author bemoans the limitations of data classes even as he acknowledges the necessity of those limitations. He also completely overlooks the way data classes enable destructuring declarations. * Open classes: Oh no, another thing Kotlin does differently than Java! * Steep learning curve: I guess this is true if your idea of a steep learning curve means you have to actually learn the language instead of pretending it's a language you're already familiar with. I have used languages with a steep learning curve \(e.g. Haskell\), and Kotlin is not one of them.
And that's in the JVM, not Java. So, Kotlin and Scala suffer from it too.
The new languages don't have their costs. I just spent 2 years in Scala. Never again.
You cannot build a WebSocket without a HttpClient instance. Therefore, I am assuming the problems still carry over (for instance, initially commencing the handshake will lead you to the Authorization header problems and the socket will cripple if not using specific, undefined, Executor semantics).
The functional world represents and will always represent only a tiny fraction of the world's programmers.
Id like to highlight this comment from the OP. **But if you are writing small or mid-size microservice with rather simple domain, some trivial REST and DB code, then Kotlin might not pay off.** This is a valid point, especially if using spring boot for example. You won't be able to use many kotlin features to make it feel like you are using a different language so it gives you the feeling of "may as well just stick with java". 
It's an interesting read, but I disagree with most of the points this article tries to make. The author appears to misunderstand Kotlins nullable types. He calls the get-or-else dereference an Elvis "fix", probably because he isn't comfortable with it's short syntax, yet at other places where things are slightly more verbose (companion object) he goes on to call it boilerplate. I think the Elvis syntax is perfectly expressive and exactly what one should do if the empty string is ok to be replaced with null. Later in, the article is complaining that there is no Maybe/Optional monad in Kotlin, probably not realizing that Kotlins nullable types are practically a really elegant implementation of exactly that with a big nice candy on top.
I spent pretty much every 20 minute run of our test suite reading through the docs for Micronaut today. I really hope it lives up to the claims they are making. As a huge user of Spring in pre-existing projects and projects I wrote from scratch I am in awe and thanks at what it has done for me, but man would I love something faster and with a whole lot less reflection.
Thanks.
Let's check: - Factory methods: in Scala `Foo.apply(x)` can be sugared to `Foo(x)`, in Java we must agree on the convention `Foo.of(x)` - Lambdas: in Scala, can be expressed in various ways, including multiline; in Java lambda bodies must be only a single expression - Pattern matching: hasn't come to Java at all - Type inference: coming to Java any day now - Data classes, value classes: coming to Java any day now These are just off the top of my head. All features that have been in Scala for a long time.
&gt;in Java lambda bodies must be only a single expression You may be thinking of Python here. Java lambdas can be multi\-line as long as you wrap it in curly brackets and use the return keyword.
Not sure why you're being downvoted. Pattern matching and type inference are two of my favorite Scala features.
If you're writing one microservice then you're probably going to be writing another. I don't have experience with Kotlin, but I can have a trivial REST API written in Scala using Finagle in around 30 minutes.
Reification will be coming to Java in some form when generics ] work with primitive and value types. See [JEP 218](http://openjdk.java.net/jeps/218).
Kotlin is not a functional language.
[Pattern matching](http://openjdk.java.net/jeps/305) will be coming in the future.
because it’s what’s used in math (both in high school , and by professional mathematicians for several hundred years — except “an element of“ perhaps replaced with a colon): n : Int f : R -&gt; R 
I didn't say it was. Just that it took some inspiration from functional languages, like a lot of newer languages have. 
why never again?
Once again, the majority of literally all code bases works the way I described, it's what the majority of literally all programmers are accustomed to; just not the vocal few FPers.
It's becoming more and more common. Golang does it. Kotlin, Scala, and typescript do it. I believe swift does it as well.
In other words the flip from C-style syntax to the Haskel style was purely a change for the sake of change (aka chasing fads) with no underlying philosophy.
Saying that "the majority" is accustomed to it isn't a good argument. I bet that a good proportion of that majority isn't thrown back by learning to do things in a different way... 
scala is hell if you don't know how to use it properly. try learning haskell and then come back to scala better equipped to utilize its many development patterns in the right situations
* Really bad tools (sbt) - sbt is incomprehensible to me - uses a really weird syntax - sad build tool * Mediocre IDE support - IntelliJ has gotten better - slow slow slow slow slow - sometimes it takes minutes for IntelliJ's code analyzer to finish analyze and few character change * Excruciatingly slow builds, system resource usage - 5 minute builds are not uncommon - My MBP can become unusable during builds * Spaghetti code - Even after 9 months of reading it, I find Scala terse and hard to follow - Implicits are a nice idea but overused in our code base. - Pimp-my-library is just a bad idea. Mortgaging short-term benefits for long term maintainability. * Very difficult to understand existing code base - Not only have to learn Scala - but learn spray, akka, etc. - This is not Java++ - everything is different * Somewhat difficult to find idiomatic way to write code or what plusses/minuses of different types of code are - I never know if I'm writing efficient code or not * Uncertainty of future of Scala - What's the deal with Dotty? - What's the deal with Typesafe becoming Lightbend * Really awkward, untested or non-performant libraries - Why did Scala folks have to rewrite EVERYTHING!?!? - Netty's pretty damn good library - well tested, tons of projects - Jersey is a very good REST library - well tested, tons of projects - Dropwizard 
Stability vs Chaos. Guess which most companies go for?
That seems to be a flaw in the language design itself then. Whatever one might call Java, it is extremely uniform in its design. 
Pattern matching, Generics for primitives, and Value Types are definitely needed. Especially the Generics bit - maybe my handrolled Pair types will finally get a performance boost! :D
That sounds like a very convenient choice–if those were actually the only two options.
Who gives a damn? I'm not going to avoid visiting Thailand because, say, I'm not used to squat toilets.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
So, evontech is spamming again, eh? And still linking through other sites to disguise the website. [Last time](https://www.reddit.com/r/java/comments/8jjig0/top_10_programming_languages_strictly_based_on/) it was "getpocket", [the other time](https://www.reddit.com/r/java/comments/8ilvsz/8_useful_toolsframeworks_for_java_testing/) a direct link. I have to say though, my favorite is when you're using *instagram* for this, like [here](https://www.reddit.com/r/Python/comments/8dd5hn/introducing_top_7_python_libraries_beginner/).
Fair point. By the way, the article you mentioned refers to the `jdk.incubator.httpclient` incubator module. It means pre JDK 11. Have you tried the new (early access) binaries? If the behaviour is still unsatisfactory, you can always send your observations on [net-dev](http://mail.openjdk.java.net/mailman/listinfo/net-dev) mailing list. 
Thanks for the suggestion, but I am not the owner of the project. :-) Maybe open an issue at github?
1. Subjective, the syntax has recently been somewhat more unified in the SBT 1.x series. Alternatively it is viable to use Gradle or Maven. New build tools on the way Fury and Mill, so if none of the others suit you, you'll soon more more choices. 2. IntelliJ is pretty much the only good IDE choice. Ensime is good, but will not give you the same package you're used to, when coming from Java/C#. There is currently a few VS Code plugins out there, but watch out for the upcoming [Metals](https://metals.rocks). Bloop is another productivity tool that will change this area, with the upcoming BSP protocol integration into IntelliJ, it changes the Apache Spark import/indexing in IntelliJ from 4-5 minutes to 9 seconds. 3. Compiler improvements are coming, I just heard they allocated a full time resource to compiler performance for a whole year. Again Bloop can help here, also compiling on Graal will also help. Upcoming projects like Tripleqoute's Hydra, which aims to parallelize compiling on multiple cores, will also give improvements. Overall this is an area that hasn't gotten much love over the years, but the efforts are coming, I'm very excited to see where we are in a year on this. 4. Very subjective, not going to bother with this one. 5. Again very subjective. Scala is definitely not Java++, and I wish people would stop touting it as so. Scala is very much its own language, and therefore needs its own ecosystem. 6. Scala can be somewhat complex, also depending on style, idiomatic might differ, even though most people will say full functional is idiomatic. 7. Uncertainty? There is no uncertainty about Dotty. Dotty is simply the codename for the new Scala, and it has been officially announced that it will become Scala 3, it is no more wild than Java 8 =&gt; Java 10, it is simply the next Scala. TypeSafe changes their name, I don't see anything else different, don't buy rumours or speculation, they are still the same. 8. I don't know what libraries you used, but I can only disagree. Most libraries have a large test suite and performance benchmarks. I hope some of my points can offer a different insight. 
I'm fairly new to Java, but does the method sleep() exist in the System class? Or do you mean Thread.sleep? One more question, does the container sleep start when I put all my threads (or system?) to sleep? Does it recognize that change?
These are the irritations of 2 years of use. `sbt` is a POS, I don't care what anyone says. The rest I stand by. I never want to see Scala again.
Hopefully in 2020 when Scala 3 should be released, most of these irritations will be resolved, and I will welcome you back into the fold. ( ͡° ͜ʖ ͡°)
That Java has now type inference too, is no argument against Kotlin (and the author admits that Kotlin is better in this regard). Kotlins null-safety isn't perfect, but to conclude that no null-safety at all would be better is a bit strange. The author states at the beginning that Kotlin had made them _less_ productive, and then he comes up with this example, that should show an advantage of Java Java: Gson gson = new GsonBuilder().registerTypeAdapter(LocalDate.class, new LocalDateAdapter()).create(); Kotlin: val gson = GsonBuilder().registerTypeAdapter(LocalDate::class.java, LocalDateAdapter()).create() Crazy productivity drop! &gt; In the C-family of programming languages, we have the standard way of declaring types of things. Shortly, first goes a type, then goes a typed thing (variable, fields, method, and so on). Shortly: `int i` vs. `i: Int`. There are many good reasons to use `name: Type`. It is better suited for type inference (even Brian Goetz would use this syntax today) and the more important part (the name) comes first. Nearly all modern, statically typed languages are using this syntax, by the way. Mentioning this syntax detail in the context of productivity is just using personal taste for blaming a technology. &gt; Sometimes, you have to use static. Old good public static void main() is still the only way to launch a Java app. And then he comes up with this example: class AppRunner { companion object { @JvmStatic fun main(args: Array&lt;String&gt;) { SpringApplication.run(AppRunner::class.java, *args) } } } That would have been enough: fun main(args: Array&lt;String&gt;) { SpringApplication.run(*args) } You can verify this by [generating a fresh Spring Boot Kotlin project](http://start.spring.io/). The the author blames the `to` method to create maps. He forgets that Java has nothing similar. How can this feature make someone _less_ productive? Kotlins null-safety is compared with Monad-like types. Personally I like the monad style a bit more, too, but it is just another compromise (at least as long the JVM doesn't have value types). There is no clear "better" here and no one prevents you from using Java `Optional` in Kotlin! &gt; But remember, Data classes come with the serious limitation — they are final. You cannot extend a Data class or make it abstract. How is this a drawback compared to Java? There are other classes than data classes in Kotlin as well. **Final thoughts** This article is so poorly written! It is mainly about personal taste and barely explains why Java should make you more productive. If you would make a fair comparision, you would find much more awkward things in Java than in Kotlin, but the team of the author is used to Java and that is all about. They don't know Kotlin well, they don't like it for some reason and now they let know the world. 
What do you want to reconsider after reading this flawed article?
The whole article is ridiculous.
&gt; Any benefit that these boutique languages (Scala, Kotlin et al) have come to Java eventually - and usually in a better form. I'd say "sufficient form" is more accurate.
You're repeating some of his own statements here. Just the first one, you say: \&gt; Name shadowing: Kotlin is not unusual in this regard. Lots of widely\-used languages \(e.g. JavaScript\) use the same scoping rules... He said: \&gt; Name shadowing wasn’t invented by Kotlin. It’s common in programming languages. And finishes with: \&gt; I can’t imagine a valid use case for shadowing a method argument. Me neither actually, Can you?
One thing I don't like about Kotlin is the wtf-able variable initialization. Its so awkward to predefine everything and no, I don't want to use that '?'. I just want to declare an integer array as clear as possible like plain old Java's int[] x = new int[SIZE]. Ah, maybe I should just stop looking for a 'better Java' and treat both as separate language with their own good and bad habits instead.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Predefining variables makes things less implicit. If you declare a String. Should the default value be "" or null? It's pretty annoying to have to think about that. You mentioned in arrays. Arrays are just lists, they are ordered collections of elements. Look at any other modern programming language and they all converge on the concept of a list. So why worry about arrays when you could abstract away all those details and use a list. You can do anything you want with arrays using lists in kotlin and be more elegant with it (https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html) You say you don't want to use optionals(`?`). The problem is that every object in Java is optional. Every object can possibly be null and you have to consider the possibility that an object is in fact null *everywhere*. In java, you have to be paranoid about NullPointerException. It's the most common cause of crashes in my experience. Explicit optionals(?) help.
&gt; Why did Scala folks have to rewrite EVERYTHING!?!? Because for people cherishing type-safety codebase stained by nulls, exception-driven error handling or runtime reflection is just awful. They want just JVM not Java itself and Java libs are treated as fallback if there is no more "better" (Scala) solution. I kind of got used to "if it compiles it most likely works". Usually when it breaks it is a Java lib returning null or throwing exception.
The underlying philosophy is functional programming. Who said that the change was purely for the sake of change?
in Rust i'll do: fn func(arg: Option&lt;Arg&gt;) { let arg = arg.unwrap_or_default(); } or things like that, but usually only is small functions.
oops you're right, its Thread.sleep(). I imagine if a non-zero number of threads are awake then your app is called active.
Ok thanks, I'll try that then 😀👍
Of course it is a bit loaded, but I hope you get the drift. There is so much dependency on Java from different companies that it cannot but move slowly. In fact, the new release model they have is quite revolutionary in Java-world - things have never moved as fast as they are doing now. Hopefully it's for the best (from a business perspective), and it definitely is a good move (from the developer's point of view).
In my opinion the "null safety" in kotlin is overrated. Suppose you use x?.doSomething() because it's a nullable type or platform type (T!) The function doesn't get called if the value is null, this can lead to some very hard to find bugs. I'm not saying that Java's NPE is better, but at least you know something went on. If using an if-statement to check for null you have no real benefit. Using if(x != null) x.doSometing() is not so tedious, and I find it easier to understand.
Do you live in Venezuela?
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Screw the downvoters. I'm glad someone understands how enterprise languages work in the long term.
I wish I could follow this rule :\(
From Java to Kotlin And every disco I get in My heart is pumping for love
Maybe you were less productive because you were not as experienced with Kotlin as you were with Java?
&gt; the idea of static members is ridiculous and counterintuitive. Why ? Having a class member (ie not link to a specific instance), as defined by the OOP theory from the beginning, is natural. It is a nice concept. 
&gt; There are many good reasons to use name: Type. It is better suited for type inference (even Brian Goetz would use this syntax today) and the more important part (the name) comes first. It is your point of view because you would like to have not typed language like in the 60s. You can use Lisp. A lot of people still use it. Languages are a matter of taste mainly, type inference has some advantage and some drawbacks 
It's a side effect of Kotlin's smart-casting fun doSomething(x: Number) { when(x) { is Int -&gt; { /* x is nameshadowed by x of type Int */ } else -&gt; {} } }
Huh, that's a good reason.
As far as I know there is support for this in Visual C++ as well as LLVM but I've tried neither of them so I can't say if they work equally well as Java for HotSwapping code. But this is definately dependent of the implementation of the runtime.
Hey, mweisshaupt, just a quick heads-up: **definately** is actually spelled **definitely**. You can remember it by **-ite- not –ate-**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Good bot
We *do* need new languages! that's where java borrows ideas from!
I'd like to see that. I guess it depends on the definition of trivial REST API. If it's just one model with a get, list, post, and delete then 5 minutes is reasonable.
Type inference has nothing to do with not having types. And I definitely don't want to use untyped languages like in the 60s. It is more about having a better signal/noise ratio (but it is still possible to specify the type, if it helps understanding the code).
So the comment I was replying to claimed that Java has had type inference for ‘a long time’.
Thank god I didn’t start Kotlin. I am happy with Java. 
Regarding companion objects, I think he actually has a valid point here. Companion object members are, effectively, exactly the same as static members. I can't think of a conceivable benefit of them apart from strict adherence to the OOP paradigm. Practically speaking, they just amount to extra code (which is IMO less clear than just bare static members).
Best effort nullability sucks. But yeah, given that you have to interact with a lot of java code, I can see the argument. Anyway. Not my tree, not my monkeys. :)
When different is better, that's great. When different is just different, it isn't.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Unreadable on mobile
 return(s1.length() - s2.length()); `return` is not a function. Go away. **10 Tips to Become a Better Java Developer** &gt;8. Learn Kotlin &gt; &gt; also the official language for Android development Quite unrelated these two. And it is not **the** official language, but it is **an** official language for Android. A little bit of difference there.
I wish my team could switch to Kotlin. I was certain they would quickly see the advantages and it would be awesome. But this reminds me that probably most developers like to stay stuck in what they know regardless of any improvements that could come from learning something new.
&gt; Become a Better Java Developer &gt; Learn Microservices What??
Java 8 looks like nothing I've ever seen. (Mind you, I haven't touched Java in years...)
 &gt; These values are extracted directly from the underlying host instead of Docker container, because the max heap size is 512M (2G / 4) instead of the limit set on the container. I'd argue that a container should not tell a process how much "real" memory there is in the first place. For what would I need a container if it does not contain the process and instead it can directly go to the underlying system?
to be fair in Java8 there was already [Arrays.asList(...)](https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T...-) Which is now the same as `List.of()`. 
&gt; Arrays are just lists, they are ordered collections of elements. Look at any other modern programming language and they all converge on the concept of a list. So why worry about arrays when you could abstract away all those details and use a list. You can do anything you want with arrays using lists in kotlin and be more elegant with it (https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html) Really strange comment. Do you have any idea about the complexity of algorithms? It seems not. Array provide you with a random access (i.e; O(1)) and not a list. List priovides you with an O(1) deletion, not an array. So the abstraction is not possible at all or is dangerous &gt; You say you don't want to use optionals(?). The problem is that every object in Java is optional. Every object can possibly be null and you have to consider the possibility that an object is in fact null everywhere. In java, you have to be paranoid about NullPointerException. It's the most common cause of crashes in my experience. Explicit optionals(?) help. Very strange comment again. How many times a member is NOT initialized within a constructor with a non null value? Being paranoid with NullPointerException often means that you have a conceptual problems. NullPointerException is a very rare error for an experimented programmer. 
Good tips as for 2012.
They are not effectively static members. Companion objects are fundamentally different in the bytecode unless you add a special meta annotation. By putting members on an actual instance (of the Companion class), your "static" methods can adhere to an interface contract. They didn't just add more syntax and overhead for no reason. 
I guess its good that trivial is that exact definition.
It has, just not the type you/the article was talking about (local variable type inference).
No blame, just IMHO notes: 1. The article is pretty general and can be applied to all prog languages. I prefer recommendations that offer me a way. 2. I am voting for the JVM point, yes, maybe knowledge of JVM is critical just for 5% issues(an average value for industry), but sometimes it saves your time (especially knowledge of class loading). 3. I’d like to find a point about debugging and heap management using programs like as VisualVM. Totally useful for looking for memory leaks.
No artifacts have been released yet, it was only just opensourced. You can install it from source by following the instructions in the github repo \- [https://github.com/micronaut\-projects/micronaut\-core#building\-from\-source](https://github.com/micronaut-projects/micronaut-core#building-from-source) It will be available as binary from once the first milestone is published on sdkman [http://sdkman.io/](http://sdkman.io/)
What if you need an ordered map?
The overloads are invisible to users however. They are there for efficiency. I don't know about Kotlin but, for example, Scala doesn't use invokevirtual for lambdas (or they don't in the version of Scala I was using). This makes lambdas in Java much better than in Scala. Further, the Java streams lib is view based which is better than Scala's approach (see Paul Phillips' various rants on this).
You've spammed enough. **Banned**
you can just make a maven archetype of any jvm language &amp; framewrk. add a script that supplies the arguments and you can have an api for anything in the type it takes to type "makeapi mycoolapi" or whatever you name it.
Avoiding a few object allocations in exchange for making the method signature so much noisier and only able to go up to 10 or whatever key-value pairs isn't a worthy tradeoff IMO. I've never seen perf issues come from hardcoded map literal instantiation. And if it's that big of an issue, a compiler intrinsic could take care of it. Kotlin doesn't use invokedynamic at the moment, but it's on the road map. For me, this is offset by the fact that the vast majority of my lambdas are inlined and thus have literally zero overhead. And IMO, invokedynamic isn't a feature Kotlin did that Java then did better. It's a JVM feature that was added and Kotlin will soon take advantage of it, but there are more important things to work on at the moment. Obviously, features that require direct JVM changes will come to Java first (like value types). Kotlin has Sequence which is analogous to Stream in that transforms are lazily evaluated upon a terminal operation. You can convert a collection to a sequence and vice versa in one method. 
&gt;See my edits below but please do continue to down vote okay! :D &gt;it shows how open minded \(...\) *or*... it shows how your weirdly hostile, poorly considered, shallow posts don't contribute all that much. you can post whatever you want, but a little self\-awareness can go a long way! :D
I think you are underestimating the aesthetics cons. While they are not technical reasons to not move to a new language, they may be roadblocks to its adoption. In the context of a single programmer or a team being formed anew, it may not be an issue, but when you're dealing with an existing team with pre\-existing java knowledge and biases, they are reasonable non\-technical motives to keep writing java.
Oracle controls the JVM and makes changes to it that are inline with planned languages changes. This is why sticking with Java is a nice option. Value objects are coming, pattern matching is coming, etc. Boutique/third-party languages have to live within the limits of the JVM. 
We are in the initial phase of rolling it out to prod. So far so good. Our DB guy complained that the queries were 10 to, in a few cases, 100 times slower than a single node postgresql instance. But we're talking going from single digit millisecond queries to double digit, and hundred millisecond for complex joins. And it's distributed and maintains those times when a node goes down. Screw you postgresql fan boy for presenting only half the facts! /s
Great job! I love these microframeworks. Would be good to see Micronaut vs Javalin vs Java Spark compared somewhere.
You speak like an inexperienxed programmer yourself. Yes, arrays have some properties when it comes to performance of certain operations. To a college kid, this matters a lot. In practice, it rarely matters. Have you ever seen the crash logs for a major project? NullPointerExceptions are a pretty common cause of crashes, arguably the most common.
39
What kind of computer do you have ? Spring Boot starts in less than 2s on my MBP from July 2015.
Hate me all you want, but you can then just as well hate the community who reported your post as "programming help" sufficient times to be removed. The rules are *perfectly clear* and in so many places on the page that they are really difficult to miss, unless you are on mobile. A 4 year redditor should still be able to find and follow subreddit rules.
"Follow the rules your whole life and you will live a life of mediocrity" -Unknown
MBP 2016. No SSD
Wow. I'm really impressed. The project looks very professional. * Proper documentation * Frequent commits in the repo * Training courses * Commercial support I just wonder why you guys developed this project. I mean all luck to you and competition is always great, but it seems like a huge investment. I'll probably stay in the Spring world for now though. Maybe I'll try it for a hobby project.
If it's a platform type, you can just write `x.doSomething()`. That's why platform types exist. If you're using a platform type, you should understand that it's your responsibility to ensure `x` can't be null. Yes, this breaks null safety when you're using platform types, but it's the price you pay for being able to make cross-language calls so easily. Consider the simplicity of calling Java code from Kotlin compared to the complexity of calling C code from Java. If it's a nullable type and you always want to call `doSomething()`, then using `x?.doSomething()` is just wrong. Don't do that! Either write the code to deal with `x` being null, or use `x!!.doSomething()` if you know for a fact that `x` can never be null. NPEs in Kotlin are roughly like ClassCastExceptions in Java. The type system doesn't eliminate them entirely, but it guarantees that _most_ code won't throw exceptions, and the places that can throw exceptions are fairly obvious. It also tends to make the exceptions easier to debug by moving the error checks closer to the source of the problem.
If you need to declare a member variable in Kotlin without initializing it, you can declare it `lateinit`. Local variables follow the same rules as Java: the compiler must be able to prove the variable is assigned a value before it's used, and for final variables, it has to be assigned a value exactly once.
OMG thanks! This is what I've been looking for.
Building a product around it now after doing a large DB review. It hits the sweet spot for my requirements. I haven't proven exactly how performant it can be, but my approach has Hazelcast as a layer allowing me flexability between redesigning schema and in memory caching. 
Similar syntax, but they're not the same. The list returned by `List.of()` is completely unmodifiable. The list returned by `Arrays.asList()` is modifiable but it has a fixed size.
&gt; I seems pay only on the SPEC website - which is very surprising There is nothing surprising about SPEC wanting your money!
Looks like fun! I'll try to give it a go when I have some time and let you know how it goes!
Cool thanks :)
Type inference is a broad term that is used in many places. Pattern matching is pretty specific I think.
You would be surprised. In any language with a reasonable pattern-matching implementation, the following is a pattern match: let x = 1 This pattern-matches the value `1` and binds it to the name `x`. Because of this and switch statements, we can claim Java has had pattern matching for a long time in exactly the same we that we can say it's had type inference. Both claims are nonsensical, of course.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
When I last used Spark I used the following: * Java 10 * Maven * Manual dependency injection * JSONObject for JSON binding * I used a small [side project](https://github.com/oyvindBjerke/jdbc-middleware) I built myself for SQL * React/Redux for frontend Worked pretty well to be honest, I love how Spark gets out of your way and doesn't try to do everything, unlike most frameworks in Java.
The problem is that in a few months another JVM language will come out (in a preview version, but still), that's much cooler than Kotlin. So everyone who just switched to Kotlin has to switch to that. For these people it's quite hard to ever get productive in anything, since they keep switching.
&gt; Really strange comment. Do you have any idea about the complexity of algorithms? It seems not. Array provide you with a random access (i.e; O(1)) and not a list. List priovides you with an O(1) deletion, not an array. No. List does not give any constraints about time complexity as its an interface. Concrete implementations do. Time complexity you stated are for LinkedList implementation. ArrayList has same time complexity as array.
Lists and Arrays are computer science data structures, this what I consider here. ArrayList or Linkedist are completely different things and are just implementations. I do not speak about that 
Oh wow, that's a really unfortunate name for a Java framework considering how popular Apache Spark already is. I was really confused when you were talking about a web server when Spark is a cluster computing framework.
Been playing with immutables this morning, and it's great so far! Gonna show this to the guys at work, we've been looking for a good library like this. Thanks! 
Out of interest, are all of your nodes in a single data center, or are they spread across multiple DCs? We're currently doing a POC with nodes distributed across 3 DCs.
I google for "spark java" when I want to find it.
Do you work with me? 😏 We are doing 4 DC across the US. One on prem, and the rest cloud; AWS and GCP.
ActiveMQ is useful if you want to send messages (~emails) from one piece of software to another. Sending/receiving messages is transactional. By default messages are persistent. Messages are queued on the ActiveMQ server if the consumer is down or slower than producer. ActiveMQ natively implements JMS (https://en.wikipedia.org/wiki/Java_Message_Service), but also does AMQP (https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol). You can have many producers/consumers on the same queue for parallel processing. https://blog.cdemi.io/design-patterns-competing-consumer-pattern/ You can use ActiveMQ as core for Staged Event Driven Architecture (https://en.wikipedia.org/wiki/Staged_event-driven_architecture). I really like SEDA approach, as you can tune each step individually and achieve really great throughput for your processing pipeline.
**Java Message Service** The Java Message Service (JMS) API is a Java Message Oriented Middleware (MOM) API for sending messages between two or more clients. It is an implementation to handle the Producer-consumer problem. JMS is a part of the Java Platform, Enterprise Edition, and is defined by a specification developed under the Java Community Process as JSR 914. It is a messaging standard that allows application components based on the Java Enterprise Edition (Java EE) to create, send, receive, and read messages. *** **Advanced Message Queuing Protocol** The Advanced Message Queuing Protocol (AMQP) is an open standard application layer protocol for message-oriented middleware. The defining features of AMQP are message orientation, queuing, routing (including point-to-point and publish-and-subscribe), reliability and security. AMQP mandates the behavior of the messaging provider and client to the extent that implementations from different vendors are interoperable, in the same way as SMTP, HTTP, FTP, etc. have created interoperable systems. *** **Staged event-driven architecture** The staged event-driven architecture (SEDA) refers to an approach to software architecture that decomposes a complex, event-driven application into a set of stages connected by queues. It avoids the high overhead associated with thread-based concurrency models (i.e. locking, unlocking, and polling for locks), and decouples event and thread scheduling from application logic. By performing admission control on each event queue, the service can be well-conditioned to load, preventing resources from being overcommitted when demand exceeds service capacity. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Is it easy to setup ? Never actually used it in intellij. 
Not arguing; of course that `&lt;type&gt; &lt;id&gt;` is the most common in existing culture. I was just pointing out that almost all K-12 students see `&lt;id&gt; : &lt;type&gt;` earlier, often before being exposed to programming at all. When the country is pushing for getting more people interested in programming, incl. at the junior-high level, it's helpful to strengthen the connections between programming and things they've already been taught. And certainly, the syntax for declaring identifiers sunders fewer connections than having `=` not meaning equality and having `0.1+0.2` not resulting in `0.3`, in my experience. Smart students will figure it out anyway. But I've seen many students who want to learn programming, but after hitting 20 stumbling blocks in a row will give up. If half of those stumbling blocks are needless, we can definitely improve CS Education by removing them. So, I'm not gonna fault a language for *leveraging* existing K-12 practices rather than ignoring them. (Your original comment is how Kotlin is screwy *for existing programmers*; I'm of course focusing concern on those you aren't-yet programmers. And as an existing programmer, I've picked up enough languages after knowing a couple, that I'm not particularly bothered by variations in basic syntax. That leaves 'programmers learning their second or third language' as the group most likely to stumble on the "non-Algol way" of declaring identifiers.
Hah, no. Our DCs are across the world (only one in the US), so our results will probably be a bit worse than yours.
*swoons* The biggest problem I'm having so far isn't with JOOQ itself necessarily, but with Maven integration for the code generation. None of the examples I've come across work :( Any thoughts? I'm using IntelliJ if that's relevant. Thanks! 
Well, all of the examples I've written work ;) So, feel free to drop a message on the user group with some details: https://groups.google.com/d/forum/jooq-user
&gt; Recommendations for binding JSON data to POJOs? GSON? Is it feasible to have all POST bodies be bound without explicitly doing some in each handler? No, you can't really do anything about that. &gt; Thoughts on a good websocket library to go with it? Why do you need a separate WebSocket library? Spark has WebSocket support. If you mean a client library, then OkHttp has one.
It should get easier for them as they and the libraries and application servers the use adapt to the increased release cadence. Time will tell. Some will refuse or be unable to adapt and ultimately die.
&gt; I was just pointing out that almost all K-12 students actually see &lt;id&gt; : &lt;type&gt; earlier, often before being exposed to programming at all. I graduated HS as the PC Revolution was only taking flight, if kids are taught the way you're describing and it's sufficiently ubiquitous throughout the world; then the point that there needs to be languages to support the concept is probably valid. I'd rather see schools teaching for reality and the reality is, the way it's done in C/C++/Java/C#, etc. really is the better, easier for the mind to comprehend, way and schools are teaching it wrong. 
I didn't look into the library in detail, so I might aswell be wrong: As an improvement, you could add a forEach method that allows you to pass your own concurrent implementation, so that it doesn't use a ForkJoinPool. Benefits: * Control thread count: The default ForkJoinPools ([usually](https://stackoverflow.com/a/22269778/3409441)) operate with `Runtime.availableProcessors()` threads. * Thread execution: Threads in a ForkJoinPools are idle when done * Async CompletableFutures
It's a very interesting finding, which I've stumbled upon as well in the past. It would be interesting too, to have a fourth benchmark: Foo[] empty; @Setup public void setup() { empty = new Foo[0]; } @Benchmark public Foo[] zero() { return coll.toArray(empty); } ... to see if it there is any difference to the ad-hoc allocation of the empty array
Yes, you r totally right. Originally I've discovered that article following a link on that page [https://github.com/h2database/h2database/issues/311](https://github.com/h2database/h2database/issues/311) The author is benchmarking static empty array to avoid creating a garbage array.