Try and catch Instantiate And lately started on Embedded
I think you understand my reasoning. Of course, a conversation model (request / response) with email would be different to HTTP and you would need to provide the glue code to this model. In a perfect REST framework you should be able to plug you own request / response model in. So an application could support HTTP and a proprietary scheme. I don't say that it is pragmatic or useful to the majority of users, but it would force us to think about the framework's fundamental design in relation to the principles of REST as an architectural style. I imagine code like this: @Entity @Transport(type = Http.class, uri = „/user/{id}“) // path mapping @Transport(type = Email.class, uri = „user-{id}“) // maps to the email address’ local part @HtmlComponent(„user“) // If requested as text/html, this view will be used @XmlType @Representations({„text/html“, „application/ld+json“, „application/json“, „text/xml“}) public class UserEntity { private User user; @Inject private UserStore userStore; @UriParam(„id“) private String userId; @PostConstruct public void load() { user = userStore.findById(userId).orElseThrow(() -&gt; new NotFoundException()); } @Update @Consumes(„application/x-www-form-urlencoded“) public void onUpdate(final UserForm form) { // save the user } @Expose @JsonProperty(„userName“) @XmlAttribute public String getName() { return user.getName(); } @Expose @JsonProperty(„links“) @XmlAttribute public List&lt;Relation&gt; getRelations() { // returns relations to other entities. The framework could use this to build a graph of entities, either by providing links or by loading and including the entity data itself. } } Maybe this is overly complex. But in this approach, I have one entity with a described lifecycle and properties that are exposed for different representation.
Yeah, I've done too my good share of "catch(Exception e) { //ignore }"
&gt; What I'm talking about has nothing to do with dependency injection. So what are you talking about? I said I need to inject some dependencies in objects as I deserialize them, and you said the deserializer can do that by reflection by looking up objects in a Map. That's the description of dependency injection autowiring container. &gt; On that note: a lot of programmers consider DI valuable and save themselves time and energy by using it. What is your alternative for them? We need to make the distinction between autowiring, and DI. I have nothing against DI. And autowiring saving time is a code smell. It means the project lacks structure, and is just a soup of hundreds of flat objects, instead of being organized in a proper tree of modules, as any bigger project should be. If you need autowiring to save time, it means look at your project structure (or rather lack thereof) and fix it. You can also save time by using static singletons. But is this a reason to use them? No. &gt; But your idea that reflection is only for side concerns like testing/debugging is personal to you and has nothing to do with the Java language, platform or ecosystem at large. Reflection is intended for metaprogramming. Don't like it? Then don't use it. It's personal to me and to Oracle (former Sun), apparently: http://docs.oracle.com/javase/tutorial/reflect/index.html Now let's see the relevant warning labels: &gt; This is a **relatively advanced feature** and should be used **only by developers who have a strong grasp of the fundamentals of the language**. &gt; Reflection is powerful, but **should not be used indiscriminately**. If it is possible to perform an operation without using reflection, then it is preferable to avoid using it. &gt; Reflective operations have slower performance than their non-reflective counterparts, and should be avoided in sections of code which are called frequently in performance-sensitive applications. &gt; Since **reflection allows code to perform operations that would be illegal in non-reflective code**, such as accessing private fields and methods, the **use of reflection can result in unexpected side-effects, which may render code dysfunctional and may destroy portability. Reflective code breaks abstractions** and therefore may change behavior with upgrades of the platform. Notice the use cases they list for reflection: &gt; Extensibility Features: An application may make use of external, user-defined classes by creating instances of extensibility objects using their fully-qualified names. &gt; Class Browsers and Visual Development Environments: A class browser needs to be able to enumerate the members of classes. Visual development environments can benefit from making use of type information available in reflection to aid the developer in writing correct code. &gt; Debuggers and Test Tools: Debuggers need to be able to examine private members on classes. Test harnesses can make use of reflection to systematically call a discoverable set APIs defined on a class, to insure a high level of code coverage in a test suite. So developer tooling, debuggers and test tools. Only the first example is not one of these, but also it doesn't concern inspecting the internals of classes, but merely creating instances of them by name. I have no issue with dynamically creating objects, that doesn't mess with encapsulation by itself. &gt; It's in that package because arrays have reified type info that you need to pass in if you're creating them dynamically. That's just a dynamic feature, like the one I mentioned above. It doesn't break encapsulation. &gt; You don't need to access SharedSecrets to do what EnumMap is doing. You can getEnumConstants using the public reflection API. So reflection allows external libraries to provide things like EnumMap. What is your alternative? Use EnumMap? It's already provided. 
[Hibernate 5.2 seems to be almost compatible already](https://stackoverflow.com/a/35427268/1025118) since it supports: - Java 1.8 stream() - Java 1.8 Date/Time types - @Repeatable annotation
Springify all the things! (But seriously: enterprise and to lesser degree mobile)
Nice! :D
&gt; and using hibernate/JPA for this slows things down considerably. Why and how much?
Please don't use Date in your applications anymore. Use something more sensible from the time package. Yeah you need to use converters sometimes but there are so many problems with Date that java.time has solved.
If that's what you think. And the answer is no. Working on a scholarship based website in my home country with a focus on people who know technology and I am trying to analyze how many people will qualify for a candidacy of a scholarship based on this survey. Its basically to make the person choosing the candidate for the scholarship easier. The test is going to be an initial screening so need to know whats the general scenario. If you want proof inbox me and I'll show you the beta website.
It seemed strange that it had to be at 9. Is there a reason why you need it in Eclipse and not another IDE?
Just use `JpaRepository` instead of `CrudRepository`. Its `findAll` method already returns a `List&lt;T&gt;`, no awkward conversion required.
Thanks for the feedback!
All well and good except it's missing ssl encryption. It'd be easy to sniff the outgoing address and mitm the password email to phish credentials.
Thanks for the feedback. I run everything through Apache reverse proxy but neglected to mention that. 
Integration between existing enterprise systems. I do a lot of Camel, JMS, JPA, etc.
Java EE too. (Unrelated: check out this [topic on fatjars](https://dzone.com/articles/building-packaging-and-distributing-java-ee-apps-in-2017-part-2))
You probably want Graphics2D, yeah? Google search turned up: https://cs.fit.edu/~mmahoney/cis5200/TicTacToe.java No idea if it works but looks reasonable at first glance as a class exercise.
*piggyback-piggyback-piggyback...* How do you do websocket load-balancing? What do you use for that? How do you stick websocket session to backend? By remote IP?
Apart from being able to brag about it endlessly, you know. [Stuff like this](https://blog.jetbrains.com/idea/2016/04/java-champions-get-intellij-idea-ultimate-for-free/)
If you are trying to represent something like "January 1st 2017" use LocalDate. If you are trying to represent something like "January 1st 2017 at 12 PM" use LocalDateTime. If you need to represent something like "January 1st 2017 at 12PM in EST" use OffsetDateTime. This article goes in a little more in depth: http://www.javaworld.com/article/2078757/java-se/java-se-java-101-the-next-generation-it-s-time-for-a-change.html I haven't read it all but at a glance I think that will explain when to use new java.time classes and why they are necessary.
I agree that embedding versions in the URL isn't the best. One way to solve this is to use headers to request the version of the endpoint/entity you want. This keeps your urls as simple identifiers of resources.
Parallel processing. Task Parallel: http://www.coopsoft.com/ar/ForkJoinArticle.html Data Parallel: http://www.coopsoft.com/ar/ConquerArticle.html
Do not attempt to seek a technological solution to a legal problem. Just get a lawyer to draw up the requisite legal notices that your customers must agree to when they purchase your software or services. Find them cheating? Sue them. And if you do decide to go the DRM route, don't be vindictive. That can land *you* in legal hot water.
I don't know what to tell you, then. None of us are going to help you write malware.
You can leave you're Raspberry PI on all the time. You'll want to reboot you're PC a lot compared to you "server". His suggestion is a very good one, just not explained thoroughly. You want to use API's because they have contracts, they wont change very often and if they do they should be backwards compatible. If you do this JSoup / Web Crawler thing you are opening up your self for a whole world of hurt. Any change to their website can break your bot/scrapper. What if this bot accesses a page where they recently decided to make an SPA. Is your crawler going to load all the JS and generate a page to then get those dynamically generated html tags so you can navigate the page? 
Here is the answer you probably wanted. &gt; You can leave you're Raspberry PI on all the time. You'll want to reboot you're PC a lot compared to you "server". 
Use constructor injection, makes it lightyears easier to unit test. Plus, you can have nice conventions like making those fields final, etc.
As I just commented else where I know a lot of sites have an API, but the point is to learn how to do it without the API and whatever restrictions that come with them. For example here is a bot done in Python that works for Instagram with out using the API. https://github.com/instabot-py/instabot.py and most bots you can buy don't use the API for sites like Instagram/Twitter. So it can be done without the API, but I don't know how hard it will be to maintain the application with any changes they make or if there is away to do it where it won't rely on needing to map out and have the html/js stay 100% the same.
I `try`ed so hard and `catch`ed so much. But `finally` it didn't even matter
No, final milestone is referring to this (4.7) version, meaning it's getting close to a release.
your complex relationships demo is really interesting i'm developing a non-sql relational database (db4j) and currently most of my testing is using business logic from another project that i populate with fake data i need to move away from that and have been looking for a database test with a complex and evolving schema that auto-generates queries and checks correctness of the results. i figured i'd find lots of stuff in this space for sql and port it over ... but :crickets: your HrSchema is headed in that direction 
indeed :)
Singletons and (static) utility classes. Some consider them anti-pattern.
What's wrong with utility classes? Don't you like: - `java.util.Arrays` - `java.util.Collections` - `java.util.stream.Collectors` - ... Where would you rather put the logic inside of them?
Overuse of ThreadLocal to hide flow of information, such as session state or db connections or request metadata.
Who? I'd be curious to hear the reasoning
Telling co-workers why their code is shit.
Well, [Yegor](http://www.yegor256.com/2014/05/05/oop-alternative-to-utility-classes.html), for instance ;)
Everyone has an opinion, but I don't see any validity to that one.
In general, on my humble dual core with 8 GB, HDD, Eclipse performs much faster and uses less RAM. But my favorite IDE used to be Netbeans, not sure what will happen to it.
It's not Java, but it shows some things that cannot be done (yet?) in Java, so I think that might be interesting. If not, sorry...
Builder pattern is way over used.
&gt; Using getClass() instead of instanceof; I tried this, but I'm getting error Class&lt;?&gt; klass = "abc" instanceof Halp (sorry, couldn't resist. I know what you mean)
Probably he needs to maintain applications written in 2004 in frameworks defunct (Struts 1.x) or with EJB 2.0 that are deployed on an unsupported version of IBM WebSpehere, while the whole business logic of the app is written in PL/SQL. Or working on a Java application written in 2001 that passes data to and from a COBOL based system... Or working on an Oracle ADF 10g application that was written in 2005. I've felt like an archaeologist a few times in my career before having the luxury of choosing my jobs...
Interesting perspective on it. Thank you. I used Eclipse for a long time but it always felt clunky and unintuitive. Once I started using IntelliJ, I found that I could get more done because I wasn't fighting the IDE to do what I wanted to do.
I've never had to fight Eclipse. And I've made multiple prolonged attempts at using IntelliJ (mainly due to the propaganda around for it) but I just don't like it. Guess it's like with many other things; different tools for different needs.
Definitely.
If you use for example Math.random() statically, you can't inject a special Random object for your unit tests.
Singletons are an anti-pattern, if they are called statically everywhere, but if you inject a singleton object through a constructor and only use what you got, it's ok, because your class is then still configurable from the outside and does not matter, if the object it got, is a singleton or not.
https://zeroturnaround.com/rebellabs/watch-out-for-these-10-common-pitfalls-of-experienced-java-developers-architects/
Yeah, exporting a file (probably buried 5 menus deep) and importing it on another machine is *so much better*. Or maybe you want a magical eclipse cloud where you can log in on eclipse and all your settings are shared across the thousands of machines you develop on.
If your unit test depends on predictable randomness... ;)
if the dark theme isn't terrible this time around, i may give it a whirl.
I wish there were examples
1. Collections are not utils, they are collections and instanced. Being in a package called "utils" is historical mishap 2. I mentioned Math as utility class that is used correctly and fine. It's a self contained, independant set of mathematical functions. 3. See above.
Did anyone notice line numbers in the Java editor are now rendered in hi-dpi on a Mac? Even though they're just line numbers it's amazing how much more cleaner it now all looks. A few element are still low-dpi like the "more editors" symbol and number, and the WTP icons for start server in debug mode etc.
You saw some using .getClass for class comparisons? Holy shit that's terrible! They missed an entire major keyword! I'd argue there are cases catching a nullpointer over the cumbersome optional is better. Common things I see: Forgetting to close PreparedStatements, Statements, and ResultSet. Querying the db on the main thread Calling .get on CompletableFuture Not caching reflection elements (eg field method constructor) Using synchronize wrong Unnecessary CopyOnWriteArrayLists and ConcurrentHashMaps Not using try with resource Code reuse arising from walling classes, or lack of functional pieces (consumer, predicate, etc) 
Mutability can be very useful when mutable is done correctly. If I wanted to clone my object each time I'd wrap Array
Still trying to learn..so I don't feel too great about any of it.
&gt; Once again - your personal opinion. I don't use Spring or Hibernate but they are widely used frameworks and a lot of programmers rely on them. You know what else is popular? Meth. &gt; Reflection is built into core Java APIs. Sun/Oracle standardize stuff like JavaBeans and JAXB, built around reflection. Whether you like it or not, application use of reflection is part of Java and its ecosystem. I don't know why you have to say this. I never argued that "reflection is not part of the Java ecosystem". I just said it's an overall loss and yes, I don't like it.
I know where you're coming from. I had never worked on anything huge until I got my current job, where I work on a huge project with (I'm guessing) millions of lines of code. There are 4 main reasons that I can think of for using a logger instead of System.out. First, it isn't easy to standardize. Using a logger allows you to standardize the formatting, like putting a date/time on everything, or the name of the class. Second, a logger makes it much easier to capture output to a file, which is essential for debugging if you need to compare the output of several runs. Yes, you can redirect stdout to a file, but then why not just use a logger in the first place? Third, a logger makes it much easier to selectively turn debugging output off. Once you have your program working, just up the logging level and it all goes away. With System.out, you have to comb through your code deleting all the debug output - only to have to put it back in when a new bug manifests. And finally, remember that not all programs have a console. If you're running a webserver, or a daemon of some kind, a logger is really the only way to go.
DI has nothing to do with loose coupling. You can write really shitty tightly coupled code that uses DI and you can write very loosely couple static functions. The only valid argument I have seen against using static for singletons is that it is harder to test which is true. However you can restructure the code a little bit and make it almost fully testable without DI.
Correct. A lot of thought will have to go into the implementation. I, at least, am patient.
If loose coupling is about replacing functionality, so how can you replace functionality from the outside, i. e. without touching the inside of the class, when you can not inject functionality, because the functionality is used directly inside the class? Maybe you even do not have the source code of the class, in which you want to replace functionality. Another way would be using the strategy pattern and implementing another strategy in another subclass. That would be loose coupling through inheritence instead of loose coupling through delegation to an injected object. Of course you do not need to use any library or container to inject something. If a dependency is given via a parameter or set through a property, it is injected.
Non-Mobile link: https://en.wikipedia.org/wiki/Cohesion_(computer_science) *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^71790
&gt; I want the war not to work or better shut their systems down or **lock hard drive** if used in an unauthorized way. Aside from completely unethical (shame on you) this is also illegal in most developed countries. Like others said; your problem isn't a technical one, it's a legal one. 
Are these really equivalent? //Java if(text != null){ int length = text.length(); } //Kotlin val length = text?.length If `text` is `null`, the Java code won't even define `length`, whereas the Kotlin code will define a "final" `length` with `null` value, which is not the same. Even if we declare `int length` outside the conditional, it would still be 0, not `null`.
Yes, that may be the case, but I've seen many real world examples of useless services, and that's why I felt the need to comment it.
I've never understood this, neither in Scala nor in Kotlin or any other language: val text = """ |First Line |Second Line |Third Line """.trimMargin() If you need a stupid margin (that you're removing at runtime, instead of at compile time!) in order to get indentation right both inside the string and in the "host language", you're losing most of the benefits of multi line strings. [Xtend got this right](https://eclipse.org/xtend/documentation/203_xtend_expressions.html#templates) Sidenote: I've learned there's a better way: https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/trim-indent.html. Still done at runtime (and probably with an even larger overhead), but at least not with this stupid `|` character messing everything up.
That's certainly a good question. I know that Java's planned implementation would allow you to do so.
Intermediate representation, optimizations, backends... I guess it's not that different from implementing compilers in other languages. When it's both *with* and *for* Java, there's maybe some more specific elements, such as the focus on profile-based and speculative optimisations.
Depends on what you're using it for and at what scale. But AWS pricing is very competitive, if not better, with their rivals in just about all ways
Anything that interfaces with SQL
TL;DR: In fact, not TL
Yes. Replace this: //define a type type Person struct { firstName string lastName string birthDate date } !empty(firstName) !empty(lastName) end //define some values let customer Person = { 'Gillian', 'Smith', '1965-12-31' } let people list&lt;Person&gt; = [ { 'Simone', 'Tremblay', '1965-12-31' }, { 'Jason', 'Ackerman', '1991-01-15' } ] by this: CREATE TABLE person ( id BIGINT PRIMARY KEY, first_name TEXT NOT NULL, last_name TEXT NOT NULL, birth_date DATE ); INSERT INTO person VALUES (1, 'Gillian', 'Smith', DATE '1965-12-31'), (2, 'Simone', 'Tremblay', DATE '1965-12-31'), (3, 'Jason', 'Ackerman', DATE '1991-01-15'); CREATE VIEW customer AS SELECT * FROM person WHERE id = 1; CREATE VIEW people AS SELECT * FROM person WHERE id IN (2, 3); No need for DNAL.
Spring Boot team members gave a talk that explains *a lot* about this: https://www.youtube.com/watch?v=uof5h-j0IeE
what do you do if you want to put constraints on the data class in kotlin? say age must be between 18 and 99 or something.
It does the job. Do you think that there is no reason?
What does "supposed" mean? According to whom?
Procrastination
It is mostly a personal achievement. I don't think it makes much difference in the day to day life of the champions. Most employers have probably never even heard the term "Java Champion", if they put that in their resume, employers may think it's a made up term.
Wow. I didn't realize that Kotlin does not distinguish between regular strings and interpolatable strings. That means ALL strings get evaluated for expressions when used. Man, that's going to kill performance. C# does distinguish by using $"" instead of "". I guess at some point the Kotlin designers will realize this and break language compatibility to fix that at some point. 
I wanted a Java point of view. My aim is to find something modern for a Java programmer.
 private static final MySomething instance = new MySomethingImpl1(dependencies); public static MySomething instance() { return instance; } vs module.bind(MySomething.class).to(MySomethingImpl1.class).in(Singleton.class); ... @Inject MySomething mySomething; They both do the exact same thing and both are easily replaceable. I'm not saying all the code has to be static but the instances and wiring can be why not? Even entire classes can be fully static and still be fairly easy to replace functionality if written correctly. I actually use far less interfaces than most Java projects I see. If you don't have at least 3 implementations making an interface can hinder you (not always).
In kotlin yes: data class Developer(var name: String) { val age: Int get() = name.length // just an example of a derived property var roleName: String get() = "DEVELOPER_$name" set(newName) { this.name = newName.removePrefix("DEVELOPER_") } } Note here that since `age` is a `val`, you only need to define a setter. For both `age` and `roleName` kotlin will not generate a backing field. You can go even further with this - since these become just getters and setters in the bytecode, you can have abstract properties in interfaces and override properties in subclasses.
I think some people use it just because they like to name their constructor arguments.
People typing the full names of classes everywhere: `java.util.List&lt;String&gt; myList = new java.util.ArrayList&lt;String&gt;();`
Thanks
Check out the darkest dark theme, it's a plugin in the market place. really well done, but it's a shame that it isn't open source (it's free (as in beer) though). 
What about writing your own `HandlerMethodArgumentResolver`. It wouldn't be too difficult to reflect over the bean you're handling, look for annotations on the fields and extract out request parameters to populate them with. You could even do something really ~~nasty~~clever and actually just build a Map from the entire set of request parameters and then use Jackson to populate the bean for you, meaning you get full access to the processing that Jackson already does. That would only work when the properties are one level deep though - you couldn't support requests like `a.0.b=foo&amp;a.0.c=bar&amp;a.1.b=baz`
The teachers supply extraordinary classes to the learners where they can make inquiries and address their questions from the educators expressly amid center java preparing in Kolkata. Next to hypothetical courses, they moreover supply down to earth courses and workshops. Subsequent to finishing the course they set up a scholarly examination and a constant venture.
String interpolation is a compile-time feature
Not "too long", or just "DR" :P Well, they only had 4 years for this, don't forget that. It's a shorter time than you may think.
Does it work in Kotlin as well? for (i in 10..0 step -2) {} 
There are.
you can MySQL connector software. download jar file from internet, this is used only database connectivity ...
There's this annoying type of developer that so many of us know who only wants to refactor code and "get rid of warnings" when he joins a project. Everyone hates that guy.
With JavaScript disabled I get * Faster page loads * No ads * No tracking * No annoying popups * Less battery usage * Less bandwidth (on mobile) JavaScript is useful for web applications where you need a lot of interaction. For content-based pages it is just stupid to make it a requirement. 
Every so often you encounter them: programmers left in the stone age, who swear by their tablets. Not the digital ones, but the actual clay ones. This one used VI and claimed he could program faster and better than everybody else. Long there was nobody else. Then I came along and management was confused. Who is this person claiming using an IDE is better? And why is Maven better than Ant? You still get working software in the end, right? Checking entire JARs into version control doesn't seem like such a bad idea... It's probably just his opinion, and we still need our caveman. Then more and more "opinions" flowed in, eventually the caveman left of his own volition, looking for the next cave. Now everybody uses IntelliJ, Maven and GIT and the dark days are over, but we still have to work through his legacy code...
Can I hook some basic validation into data classes? Like making sure age is &gt;= 0?
You could `/s/Kotlin/Scala` and the comparison would still be 95% valid, which is to say, virtually all of Kotlin's syntactic appeal comes directly from Scala.
Yeah. I hate myself every time I see those warnings in my IDE too. 
I tried IntelliJ community in the past but the tomcat support was limited.
The first 3/5 changes are absolute no-brainers. 4 and 5 seem rather esoteric. So, no. That time certainly wasn't *that* short ;) But I understand this was done in a broader, much more difficult context of Java EE 8, right? So let's see what JPA 2.3 or 3.0 will bring.
Interesting, thanks for sharing.
Nice! I was not familiar with `HandleMethodArgumentResolver`. This is very similar to the `HttpMessageConverter` approach outlined in this gist: https://gist.github.com/dogeared/0db806ad56258711de0ffdfa5317ee42. I like the `HandleMethodArgumentResolver` approach because it's higher up in the chain. That is, you don't have to deal with reading bytes out of the `HttpInputMethod` and parsing a query string. You have the `NativeWebRequest` object and can call `.getParameter` methods. I created a gist for this approach as well: https://gist.github.com/dogeared/3ebb46b9d948c023e702ccb9ecfdf35e. On balance, I think my favorite of the 3 approaches is the `HttpMessageConverter` approach. It seems to be more aligned with idiomatic Spring Boot in that it allows for the `@RequestBody` annotation, which implies that there's an `HttpMessageConverter` in the mix. Both the `HandleMethodArgumentResolver` and the `HttpMessageConverter` approaches lend themselves to auto-materialization using introspection. In fact, I updated the original gist for the `HttpMessageConverter` approach to use the jackson mapper. Thanks for the suggestion! https://gist.github.com/dogeared/0db806ad56258711de0ffdfa5317ee42#file-slackslashcommandconverter-java
If you're concerned about the performance of `trimIndent` you can always cache the result (assuming the string is constant). If the string is not constant, intrinsics wouldn't help anyway.
Lombok @Data can turn the Java example into this.. @Data public class Developer { private String name; private int age; } I wish this was built in instead of an add on Library. 
Kotlin's appeal over Scala is more about what they left out. Scala and most of it's frameworks make a lot of assumptions about what you want in your project. 
[This is a comprehensive tutorial] (http://appwarp.shephertz.com/game-development-center/java-multiplayer-libgdx-tutorial/?utm_source=reddit&amp;utm_medium=reddit&amp;utm_campaign=reddit&amp;utm_term=reddit245&amp;utm_content=reddit) in JAVA that uses libGDX demo Superjumper and converts it into a multiplayer real-time game using AppWarp cloud features. Replicating this can help you with extend any single player game into multiplayer in libGDX.
&gt; And why is Maven better than Ant? I would actually like an answer to this :-) My existing projects use Ant+Ivy (so don't need jars in version control) and for new projects I have been using Gradle. I haven't yet been able to come up with one thing that make me say "This is why I use Gradle now instead of Ant+Ivy!". My experience with Maven has been the same, I see no reason it is better (or worse) than Ant+Ivy. 
* Value types that can be initialised in an invalid state * Ubiquitous mutation * Nulls everywhere, and null checks everywhere The first of these (bean class with empty default constructor) guarantees the propagation of the other two, since they mean that every (non-value-type) property of every bean class is nullable and has a setter method.
Common today to do Java REST backend (JAX-RS or Spring) and HTML5 frontend using a Javascript framework. Struts is pretty old. JSF 2 is all in one and makes it relatively easy to add AJAX actions without actually writing Javascript. A lot of people here will say JSF is dead but it isn't. 
Choose C#. It is something that Java will become in 10 years. In optimistic scenario.
&gt; return name != null ? name.equals(developer.name) : developer.name == null; This is Java 6 example - everyone sane will use Objects.equals(name, developer.name) ;)
Spring Boot, it can be easily containerized for cloud environments.
I have no experience myself, but heard some good things about JHipster: https://jhipster.github.io/
&gt; Early on programmers coming from C/C++ used to do this a lot because having overly broad "include"s could impact the performance of your C/C++ program [...] This makes no sense. Please explain.
If I'm concerned about performance (I am), I would simply not care about trimming / indenting. After all, most of the time, I'd be using this for some embedded XML and/or SQL, and who cares if the string sent to some other system is well formatted. Or, I'd avoid indentation in the host language (Kotlin) and just have a locally ugly formatted piece of Kotlin code without indentation.
Kotlin differentiates types by whether they are nullable or not, so if you say: var length = text?.length ?: 0 it would compile to: int length; if(text != null) { length = text.length(); } else { length = 0 } since length cannot be null in your Kotlin snippet. However, in the original, it can be null, so val length = text?.length is actually equivalent to Integer length; if(text != null) { length = text.length(); } else { length = null; }
This statement bothers me in regards to Spring Boot: &gt; "A common size was 100+ megabytes for real-world projects, 200+ or even 500+ megabytes for extreme ones made by incompetent people." * I've never seen a Spring Boot fatjar over 60mb * Why are they worried about HD space * Incompetent people is no fault of the framework, train them to be competent and stop blaming the framework to push an agenda.
I've been doing java for almost 8 years now, and I've literally never heard of this... 
If you look at Java8, it has a Clock class that can be used to get instants and times. It takes like 10 seconds of effort to create a mock implementation, then you can deterministically manipulate time. 
Now you have.
long time play developer, never used scala, at all. ever. 
Thanks for the recommendation. I'm thinking about using it for my next project since it seems about the closest java has to django. 
After looking into it more, it wasn't a runtime performance problem but a compile time problem. In C/C++ an #include basically tells the compiler to replace that line with the entire contents of the referenced file. #included files can #include files of their own which can lead to files getting pulled in multiple times or even circular dependencies. [Include Guards](https://en.wikipedia.org/wiki/Include_guard) were a technique used to prevent problems with #include.
Documentation: https://www.playframework.com/documentation/2.5.x/JavaHome Project: https://github.com/playframework/play-java-starter-example
It isn't knowledge padawans should have. 
Had they made the language 10 years ago (and put the marketing behind it that they do now), it would have been quite appealing. As it stands, it's more of a "meh, whatever". 
I wrote some tutorials on spring boot and thymeleaf, and spring security on my blog at - https://www.javabullets.com/auto-generating-spring-security-tutorial-memory-realms/ The project is at - https://github.com/farrelmr/parkrunpbreboot
I'm writing small web application not huge enterprise app
normal java? yeah i suppose Oracle JDK is pretty normal :) we're actually in the process of upgrading our platform to the latest version of Java (8, we are currently using 7) but yeah in play, it's all just POJOs all the way down. And using MongoDB/Morphia which gives us a nice JPA-like interface for our models (which are just POJOs) -- no special magic. our team loves play, and it typically takes less than 4 hours for a new developer to come on board to our team, get our code and start making meaningful contributions. 
paintComponent is a method that is part of the Component class already. It is called by the component every time it wants to refresh it's on-screen graphics.(this can be activated any time by calling the repaint(); method). The Component automatically creates the Graphics object, and calls the paintComponent method with it. Here is an example of the paintComponent method in action: public class TestPaint extends JFrame{ // ... Other methods @Override public void paintComponent(Graphics go){ Graphics2D g = (Graphics2D)go; g.setColor(Color.RED); g.drawRect(0,0,100,100); } }
&gt; Java8 &gt; Android What the hell is a Java8?? Lambdas?
&gt; Barf.build()
It was not so straight to replicate what you did. It would be very good if you can show with which dependencies you created the spring boot project. Another good thing would be to publish the project in github. And for reducing code boilerplate use project Lombok.
Hey, I love SQL - its relational model is one of the best things in computing. 40 years and still going. But it's not for everything. You wouldn't validate an HTTP form submission by creating custom tables and attempting an INSERT. For natural keys, check out section 8.5 at https://dnal-lang.org/dnal-syntax/ Here is a sample of assigning a currency to a price using the 'via' keyword: let prices list&lt;Price&gt; = [ { 105.99, via Currency.code 'USD'}, { 49.13, via Currency.code 'EUR'}, //etc. ] The via keyword supports both single and multiple values. "via" can be used to populate a list (0 or more items). &gt; The object extensions of the SQL standard support inheritance. Yes and Postgres says "As these extensions violate relational data model, think about what you are giving up and use them sparingly!". It sounds like trying to mix things that don't belong together in the same level. Schema-level check constraints are indeed cool. I need to investigate further. &gt; Like JSON, DNAL can have structs of structs, and lists of lists, lists of structs, etc &gt; Again, ORDBMS support this (like inheritance). Besides, most SQL databases support XML and JSON. XML, JSON, (and DNAL) represent nested data naturally. SQL doesn't; there's just no getting around that. Each is good for its own uses. By the way, JOOQ rocks! 
or just a compilestatic groovy? @CompileStatic class Developer { String name int age }
Spring boot is the the trend these days, and it's very easy to deploy
Seems like a perfect library to ruin GC times. They literally allocate an object to lower-case a string.
I don't agree that the blog authors viewpoint increases cohesion in a helpful way. It would be better if the methods were on the original object itself. If not, I don't think there's an increase in meaningful cohesion (or anything positive) by replacing static method calls with new object who's only purpose in to replicate the static method calls. It terms of my own opinion it's worse. I'd rather have to remember one static class name, then look through the method names. Then to have separate classname for each action instead.
It's strange but little things like that make a difference 
That's what I thought too. Icons kinda cool but overall it didn't feel "natively" dark. Still way more of an afterthought than IntelliJ. Still prefer eclipse though!
Data rest is great... but it should be used in combination with proper security and (more importantly) good frontend design. Making 100 async calls because your api exposes everything is bad frontend. If you use projections, quality service domain, etc you can do something much more expressive and correct. I use it to replace crud when it makes sense, and try to use domain driven design when possible. It's a tough medium to strike but it can be done. Data rest is another great tool in the spring ecosystem, but is not a free way to build a backend.
It's a little bit extreme and puritanical. I understand what the creator wants to achieve, but I don't think this is really the answer. Basically I think he tries to solve a problem that doesn't exists.
Funny enough i am completly unrelated from this project. But it was a fun time working with it with my team. Jokes on end :D
"abc" instanceof I think you need to add a dot there
&gt; You wouldn't validate an HTTP form submission by creating custom tables and attempting an INSERT. Hey, why not? I've worked with 2-tier apps where all validation was made using triggers. It was really simple and neat and had its uses. Why not use an in-memory DB to perform HTTP form validation? Sure, it would be a bit extreme, but creating a new language seems more extreme to me. Btw: What's your take on XSD? Why didn't that fit for your hierarchical needs? &gt; Here is a sample of assigning a currency to a price using the 'via' keyword I don't know if I understand. Your schema / DDL specifies that a `Person` contains an `Address`, so the relationship is hard wired. And your `via` keyword is just a nested select in SQL, i.e. this: let prices list&lt;Price&gt; = [ { 105.99, via Currency.code 'USD'}, { 49.13, via Currency.code 'EUR'}, //etc. ] Is the same as this: CREATE VIEW prices AS VALUES (105.99, (SELECT currency FROM currency WHERE code = 'USD')), (49.13, (SELECT currency FROM currency WHERE code = 'EUR')) (note, I'm using a PostgreSQL syntax feature to nest the currency record in the price record by referencing the table in the SELECT clause instead of individual column expressions. I'm not 100% certain of the SQL standard syntax for nesting records here). If you wanted multiple nested values, you'd be using MULTISET in the SQL standard / Oracle, or ARRAY in PostgreSQL. &gt; Yes and Postgres says "As these extensions violate relational data model, think about what you are giving up and use them sparingly!". It sounds like trying to mix things that don't belong together in the same level. There are many reasons why this is being said. Most of all, historically, people do not always agree that nesting tuples is still OK with the relational model *especially* when storing the data. Tons of storage implementation details will leak into the DDL (and sometimes DML) and that's certainly not a good thing. There's substantial risk of denormalisation, which is usually not a good thing either. Nesting tuples is quite useful for transient data, however (e.g. in views, data processing, sending data to clients). Have you ever worked with XML in SQL? It's really awesome to construct hierarchical node structures directly from SQL queries. Now, if you allow for the original relational model to be adapted, then here are some interesting links: - https://en.wikipedia.org/wiki/The_Third_Manifesto - https://en.wikipedia.org/wiki/D_(data_language_specification) In fact, the latter is more close to what you intend to do. Perhaps you should simply implement D instead of rolling your own! &gt; It sounds like trying to mix things that don't belong together in the same level. But you're doing the same in your language, don't you? Just because you embrace "hierarchical first" doesn't mean you don't want relations and referential integrity. You mention that on the link you've shared: *"However if several people share the same address (such as members of a family), it’s better to use a relation."* Ultimately, someone will finally merge the relational, hierarchical, and networked models and they will make tons of money because everyone *does want* the best of all three worlds. (Especially merging the networked and relational models will be interesting, much more than the more boring hierarchical model) &gt; XML, JSON, (and DNAL) represent nested data naturally. SQL doesn't; there's just no getting around that. Each is good for its own uses. Yes, they do. And so does SQL :) If you allow it to. Other SQL languages that embrace nesting are SQL++ / N1QL. Interesting links here: - http://forward.ucsd.edu/sqlpp.html - https://www.couchbase.com/n1ql There's a [jOOQ Tuesdays](https://www.jooq.org/tuesdays) interview coming up on the subject. Yes, SQL is historically slow in adopting new things. But I promise you, the "next big thing" in data structuring will also be SQL based. There's just too much good stuff in SQL to ignore it when doing something hierarchical. Having said so, your work *does* look interesting. I just think you should embrace the status quo a bit more than starting completely from scratch. I personally also liked XSLT / XPath, but that never really took off as it deserved to. &gt; By the way, JOOQ rocks! Thanks ;)
Wow. *"Since the inception of Java, big features or a handful of big features have driven major releases every two to three years. This was reasonable in the 1990’s and 2000’s. Going forward, Java needs to move at a faster pace in order to remain competitive. "* That's exciting!
you're missing the controller and pom.xml.
I don't know Django nor python at all. But if you have any question about Jhipster, feel free to ask 
a
Can you provide an example of the second? I've only ever seen a separate builder class (which can be a nested class, but it's still another class). The whole point of the builder is to build a complete and ready to use instance of a certain class. I mean I guess it's completely possible to write a class that way but it's breaking the fundamental point of the builder which is to end up with an instance of the class being built that's ready to use. It kind of breaks the contract if you're using the class itself with a whole bunch of intermediate methods returning this before it's actually fully constructed. Edit: clarified "separate"
A: but you could also use MessageFormat or String.format.
What is a better alternative?
The comparison is done between TestNG and JUnit 4
In the second example of thinks of lines like these `Picasso.with(context).load("http://i.imgur.com/DvpvklR.png").into(imageView);`
Say what you like about Oracle, they do seem committed to evolving the language and platform. It's hard to believe that *8 years* elapsed between Java 6 and 8, during which time the language barely changed. Still somewhat anxious as to how they intend to monetise their investment...
Because if you fully qualify the class name in Java you don't have to import it. They were assuming import in Java did the same thing as #include in C/C++.
&gt; Personally never liked XSD. Too complex (19 primitive types!), and the syntax is too painful. A simple data schema should be simple to declare. That's in the eye of the beholder. I have never had any issues with XSD, except perhaps, verbosity. But that's not a real argument in my opinion. &gt; There is data at rest and data in flight. I think we'll just disagree about SQL being primarily about data at rest, then... I'm not sure if there's really a distinction between the two. In the end, relations and tuples are extremely good abstractions for all sorts of data. "at rest" or "in flight". &gt; Web APIs don't communicate in SQL statements for just these reasons. Well, they invented their own CRUD language, which essentially does the same thing as simple SQL, though. &gt; But sometimes it does. I wish you luck! :)
&gt; Picasso &gt;Use with(android.content.Context) for the global singleton instance or construct your own instance with Picasso.Builder. [They're still using a separate Builder class](https://github.com/square/picasso/blob/master/picasso/src/main/java/com/squareup/picasso/Picasso.java#L684), they just have a singleton static global instance with "sensible defaults": https://github.com/square/picasso/blob/master/picasso/src/main/java/com/squareup/picasso/Picasso.java#L659 I think it's just a side effect of them wanting to make a really "fluent" API.
That would only make sense if they were going on the other direction. Unlike packages in Java, in C++ includes and namespaces are orthogonal, so there's no reason for C++ devs to assume that fully qualifying classes would be required in Java. Speaking as someone who made this exact transition.
I have found Grails to be one of the best documented open source projects I have ever worked with. I am not sure I have ever run into a problem where the answer wasn't available in the User Guide. There is also a Grails Slack channel.
Why is this a bad thing? 
Still less that what took to get C++11 out of the door.
Thanks for all the great comments and feedback. I've made a blog post to put it all together: https://afitnerd.com/2017/05/24/what-if-spring-boot-handled-forms-like-json/
Super cool, thanks! 
Maybe I'm just missing a common pattern, but why build the Java application inside the docker image at all? Wouldn't it be easier to build outside using standard tools, and then just include the binary in the final(and only) docker image?
I think it's important to know when to use interfaces and when not to. A lot of people tend to be a bit over the top with it honestly. I think this article summarizes my views quite good: http://blog.hovland.xyz/2017-04-22-stop-overusing-interfaces/
I think what you mean to say is: "It might be a better idea to start with version 2 because its not backwards compatible."
Not everything in that article follows proper design. In my opinion, services should still be interfaces because you can't solve every problem with mocking whereas it makes migrating to a different service much harder if you require a concrete class (unless you're willing to simply throw out the old version of the code).
I don't really like the term "design your system using interfaces" because it doesn't tell you *why*. It's a generic idea without any context. It is better to start with a principle, like [Dependency Inversion](https://en.wikipedia.org/wiki/Dependency_inversion_principle). Dependency Inversion says you should separate your code from its external dependencies. This is good, because it keeps your code isolated and not dependent on the particular details of things like storage. Does your application use MySql? Does it use MongoDB? *It doesn't matter*. In your interface, you can specify query methods for objects from a data store, and a method to save objects to your data store. Then implement the interface specifically for the data store. Your interface could be called `FooRepository` and the implementation `MySqlFooRepository` or `MongoFooRepository`. I dislike interfaces called `FooRepositoryImpl`. This strongly suggests an interface isn't necessary. Interfaces are contracts that help you preserve your design and to explain what you need out of external dependencies. Interfaces are good, but so are classes. Don't overuse interfaces, because indirection isn't always necessary or good. It can make your code impossible to follow and understand. Start by learning principles like [SOLID](https://en.wikipedia.org/wiki/SOLID_\(object-oriented_design\)), which will help you understand where usage of interfaces makes sense. [Agile Patterns, Principles and Practices](https://www.amazon.com/Agile-Principles-Patterns-Practices-C/dp/0131857258) is the best book I've read about this. Another book which does a great job of explaining how to properly use interfaces is [Growing Object Oriented Software Guided By Tests](https://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627).
&gt; So you only view static web pages? ... and web apps that I approve of.
true ...learning client side technology is more harder
&gt; Can you elaborate? Well, instead of creating a mock every time you can create a stub class that does in-depth inspection of the input arguments. You can probably do this with mocks too but it seems like it would be simpler to just make a specialized class. &gt; so I say not creating an interface in the first place doesn't make it harder to migrate I have the opposite view; there's no overhead to making an interface first so you don't have to create one afterwards. Again, I also feel like it's easier to use an interface in testing rather than use mocking everywhere.
That also depends on what kind of application you want to write: "stay awhile applications" or "drive by applications". A "stay awhile application" is like GMail. The user will probably keep the page open for awhile and is likely to interact with the site quite a bit. In which case you want to optimize for incremental updates. You might sacrifice a bit of initial load time, but you can get your JS, CSS and HTML templates loaded first, and then subsequent network traffic can be small JSON messages. Parsing JSON is substantially faster than parsing HTML, so you get a performance win there too. Be careful with your front end tools though... Also, if you serve up the JS, CSS and HTML correctly, you can even eliminate the initial page load on subsequent visits, since the content will be cached by the browser. This works because the HTML is a static template populated by the client, not dynamic content generated by the server. On the other hand, a "drive by application" would be something like a news site, where the user will click the link, read the content, and leave. In which case, you want to optimize for initial page load time and minimize the number of server requests, so that the user gets their content faster. 
They tell me I can be pretty condescending. That means I talk down to people.
Building inside a docker image gives some of the consistency benefits of a CI tool locally on your own machine. BUT the idea of using a different image every time seems a few steps too far.
Thanks for the feedback - Ive linked to my github repo - https://github.com/farrelmr/introtospringdatarest And updated the post with your advice
&gt; Going forward, Java needs to move at a faster pace i feel like this has been said before... not sure if things will really change.
You might be thinking about this backwards. What are your performance requirements and concerns? Where will you hit bottlenecks? Are you writing to a database eventually? These are more important questions that will drive your architecture requirements. That being said, the advantage of containerized services is that you can scale different portions of your service separately. A distributed queue like Kafka then simplifies communication between services at different scales. 
Yeah - we will be writing to a database for various operations, and we will likely have the mongo db running in a separate container, too. That way we can do stuff like replication. Those last two sentences, having the distributed queue, and the ability to spin up instances of my components, is exactly what I want. But everything I can find so far on the topic is written like a radio manual from the 1940's - I'd like something a bit more digestable! :)
Instead of mixing stuff inside a Docker build, why not just use a jdk container with shared volumes to generate the java artifact on the host and then build a the image with the artifact. Even better, use drone.io to execute build pipelines fully based on docker.
I have often found maven needlessly complicated. I prefer ant and ivy primarily because ant, I feel, is more or less like a shell script, just written in xml. I feel like I have to spend less time googling around when dealing with ant than maven.
Maven gets enough right that it commands the lion's share of the market. It doesn't mean that Alternative X is better or worse, just that everybody has different needs for a build system. If you fall into the large number of software projects that easily use Maven's conventions, great. If you don't, you have alternatives. One-upmanship is a waste of time.
Containers are good for scaling stateless application layers, so be careful of using containers for running databases. 
Ok, so maybe for the DB - I should just have a couple of instances, which act as replication instances, then containerize the API itself, which calls the db? Then use kafka to communicate? Have you seen any good writing on this topic? 
Thank you very much! The answer is really good. I guess one can understand this concept by learning from experience. I hope these two mentioned book will give me some experience!
Hmm. I've not heard of Buck before....
We're switching all of our currently developed projects over to gradle. While it definitely has its quirks, we've been very happy with it. 
..it's almost like people are now too lazy to install/setup stuff and would just rather pull down an image instead..
Returning this from your setters.
I am open to Rabbit, too - but have zero experience with that too. This is new territory for me. I am a very experienced java developer, but am very new to the "Architecture" stuff.
It seems to me, you have problem with choice which is okay. Because Maven gives you choices, you choose to criticisize the ones that makes things easier/quicker &gt; a pom.xml can only list a single source folder. The model is to use a multi module project, not multiple source folders. &gt; which now even has a build cache Maven does have a build cache: ~/.m2 Amd there are plugins to allow parallel access supporting the same build cache shared among multiple runs. You can deploy a build cache locally if you don't want to share the drive or worry about parallel runs. &gt;most other build tools suffer from the same issues (Ant, SCons, etc.) Buck is a notable exception here, but is probably not alone. While not ideal, you can use the ant plugin to solve this problem. How does buck solve this? &gt; Everything’s so much easier if you treat compilation as an atomic (non-incremental) task, the way Buck does. Or you could have a choice: mvn -am -pl mymodule clean install vs mvn -am -pl mymodule install &gt;to make sure the snapshots you just installed Don't use snapshots? &gt; mvn test won’t package anything, downstream modules will use the target/classes from the modules they depend on. Move your tests to a different package and depend on the earlier package &gt;Finally, linked to the above two issues, is one with the command line: back to the second use case above (the first one could be used too, but it’s not much about the build). drama here.... Just do a mvn -pl C if you know for a fact that all your dependencies are already published versions If any of the dependencies needs to recompiled then you will have to run with the *-am* parameter, &gt;Most IDEs will show you 2 folders The major IDEs support package views &gt;It’s becoming even worse if you have a laptop: you’ll have to switch your settings.xml mvn -P home install Alias mvn so that figures it out based on IP address I'll keep using maven until Gradle gets * The wealth of plugins * Archetype functionality * Inheritance * Declarative builds BUCK, Pants, Bazel all have the problem of not makign it easy to make controlled dependency updates unless you treat them like 3rd party plugins but the risk is high of messing that up.
Yep - I just basically want to be able to spin up extra instances of my API, and have them act as a pool of workers :)
Wait until you have to use NuGet.
No reason to switch from Maven. I have had zero of the issues described in this article. Sure you have to follow a couple basic conventions like using one top level source folder. But then you can just add a couple lines of extremely clear XML configuration which were the top result of a google search. I don't any issues after renaming a file. I don't have any issues with dependencies constantly trying to download. 
Article is 4 years old...
The best part about maven is that it "teaches" developers a structure to stick to in order to have an "organized" project. I can't tell you how many monstrosities I've run into with Ant. I've used excellently coded Ant builds too, so it's not that Ant is bad, it just lets you be bad easier. Back when I was still green, I found myself captivated my the structure of Maven. Now, when someone joins our team, they can instantly look at our Maven build and understand 90% of what it does if they've used Maven before. They don't have to understand or learn how we decided to implement an Ant build regardless of how good it is.
Automating a process, like building a build environment, isn't for laziness. It's for consistency. Everyone using the same docker image gets the exact same tool versions, java versions, etc. No chance of inconsistencies. 
Thank you! 
Hmm... &lt;rubs chin&gt;. I wonder if I could get our teamcity build agents to use images. 1 of them has a different JVM to the other 4.
Here is a much more detailed article of mine (which is also for Mockito 2) https://semaphoreci.com/community/tutorials/stubbing-and-mocking-with-mockito-2-and-junit
&gt; With the recent craze of microservices where everybody splits the monolith to smaller projects most of Maven problems simply go away How would it go away? If anything, this will put more pressure on multi module maven builds. As the article points out, those are far from perfect. 
&gt; I don't have any issues with dependencies constantly trying to download Thats what I used to say, and then I tried gradle. It does a lot of unecessary dl-ing
There is a big difference between "still managable" and easy to maintain... 
Number of repos is irrelevant. You could have a single git repo with 20 top level Maven projects inside if you prefer that (i.e. 20 self-contained pom files and not one multi-module project). The case is about micro-services, not git repo organization (the two are independent)
&gt; It does a lot of unecessary dl-ing The gradle or the maven?
While being slower at it.
Gradle is much simpler and nicer to use. I spent ten years with maven. Won't go back.
It's not like I haven't used Maven. Or Gradle. Ant might not be terse, but it's straightforward. And since it's procedural instead of declarative, it's easy to handle the edge cases. Ivy takes care of all the dependencies. I like it.
If I understand you use-case correctly, you don't need kafka, and can instead live with something like [nginx-proxy](https://github.com/jwilder/nginx-proxy). Essentially you want something like this, where everything except the internet can live in docker images: Internet -&gt; nginx-proxy -&gt; application(s) -&gt; database If your application only has external state (that is, state is in the database, in message queues, in external memory caches), then you can just spin up a new application container - and nginx-proxy should be able to detect the container starting up and directing traffic to it too. This is on the HTTP level, no message bus necessary. You can even set it up with heartbeats so that you can remove an application container without interrupting any ongoing requests. If you want to have a database with failover, it's going to be a bit tricky - I would suggest separating the database instances into a R/W master that takes all write requests, one or more hot-standby replicated R/W slaves that don't take any traffic until the master fails and one of them gets promoted to master (this needs a lot of testing!), and multiple R/O slave replicas that take most of the read load (assumes that your read load is higher than your write load). I think you can even plonk something like pgbouncer in front to take care of transactions. Remember: you will need something like a log aggregation and analysis service, otherwise you will need to persist and grep the logs from all applications yourself... 
Everything in nature is broken by design. Just look at trees, plants, animals. They all age and die eventually. Heck even atoms all [decay to Iron-56](https://en.wikipedia.org/wiki/Future_of_an_expanding_universe#Matter_decays_into_iron) Broken! BY DESIGN!
We build outside and add in the artifacts 
&gt;Its a hell of a lot better than ant. Can you please explain this? Ant gives complete control of what you want to do, has full dependency management via Ivy and doesn't get in your way. You setup your build file following a standard model and you can reuse it from project to project. But if you need to do something slightly different it doesn't fight you. And it is very simple to utilize external "plugins". For example, it only takes a few lines to add commands to your Ant script to hook in Tomcat's Ant tasks giving your build script the ability to start/stop/deploy/undeploy to a Tomcat engine. 
Your posts don't add value when you simply cheerleader or make cryptic unsubstantiated claims.
 There are two areas of consistency to solve: 1) The build itself and making sure everyone has the same tools and environment in which to build the software to avoid problems. 2) The runtime environment consistency so that when a developer runs the software its similar to when run in testing and production. If you do these with seperate images then: - No dev stuff appears in production, better for security. - The dev image gets to contain stuff that wouldn't be allowed in production. - But it is a pain to develop with because its not as easy or fast to build and run and iterating becomes a lot slower. If you do a combined image then: - It is going to contain a JDK instead of the JRE plus other dev tools and be worse for security. - Developers will have to limit what is installed into it. - But the iteration of the application can be faster. I don't know which way most people are going these days. More than one organisation I have seen just building outside of docker and that docker takes over for the deployments only. I think that is missing a trick but coding inside of a docker image isn't a fantastic experience for me at least. You pay in drawbacks for the ease of getting updates, works better for other components but for your own software its a bit sticky.
I like you.
/r/javahelp it's in the sidebar
There are some structural problems with Java that make FP quite tedious: + Mutable collections + Streams for some reason can only be used once (while not visible in the api, it throws a runtime exception, I guess we're back in the 90's) + Streams for some reason don't have the foldl operation. Which is annoying whenever you need to collect stuff, often ending up needing to map it to something which is monoidal and then reduce it. If you really want to do fp, use Scala, it solves all these problems to an extend (but still has other problems, although they're much more rare). Note that scala integrates seamlessly with Java. Not that you'd want to after reading the article since it never states *why* anyone would do fp. He does ask the questions: &gt; Are there really any benefits of this new paradigm? In which situations can you leverage the new features? But never answers either of them. I guess the point of the article is to explore these questions. You could've asked google too: https://stackoverflow.com/questions/36504/why-functional-languages &gt; the new notation is rather obscure - I prefer the good old imperative style, which is more verbose I agree... Scala has type inference. &gt; are streams in any way more efficient? Probably not than raw iteration, but they are when you return a stream instead of a collection from an operation and let the user call collect. User code can then add even more operation and iteration only happens once. Also par streams are a a potential thing to look into. &gt; how is it possible to write a program that does not modify its state? (I'm assuming he means how is it possible to write a program that does computation without side effects in a loop, otherwise the question is dumb): I've been told its monad transformers. Haskell uses the IO monad to do things (presumably with a monad transformer)... I've not dived that deep yet into the rabid hole.
I think bi-annual would be too fast. It would be frustrating I imagine for library developers, to constantly have to keep up with supporting new features and changes in the language. u/olivergierke would love to hear you input on this. Annual seems to be more doable. Or alternatively something like Intel's "tick-tock" cycle would be good. Where "ticks" are/can be major architecture changes and tocks are restricted to enhancement changes only. I still think annual would be the best cadence, though I suppose bi-annual would be more doable in such a scenario.
&gt; The beginning symptoms of FP hype train disease: Map&lt;String, List&lt;String&gt;&gt;. What is wrong with multimaps? Though I guess Guava's `Multimap&lt;String, String&gt;` is a better alternative than rolling your own using the default java.util.Map. &gt; Next steps is `Function&lt;UUID, Map&lt;String, BiFunction&lt;Integer, Double, String&gt;&gt;&gt; which then turns into "Java needs type inference and alias!". Pssh, just wait until you see `Kleisli[IO, String, Response]` or `EitherT[Option, A, B]`. :p Though I do admit that a function that produces a map of Strings to functions is a little weird. Where did you see that, and what was it being used for?
It depends on the level of backwards compatibility that can be maintained at that pace. If the status quo is doable with two releases a year, then why not?
&gt; Streams for some reason don't have the foldl operation. Wait, really? Can we just rely on a sequential Stream's reduce operation implementation details, or is it actually truly random how it chooses elements to combine? &gt; User code can then add even more operation and iteration only happens once. Or call a short-circuiting operation like `findFirst` or `anyMatch`, with huge increases in best and average case runtimes. Though I'd say that the key advantage of Streams is declarative syntax rather than iteration performance, which isn't really needed for your average Java CRUD app.
make your own class that extends Thread or implements Runnable, and have public void run() { long start = System.currentTimeMillis(); ... this.runtime = System.currentTimeMillis() - start; } 
I was talking about the size of the Ant file that builds 500kLOC of Java code, not the Java code itself.
Have you seen the free books available on Maven? http://books.sonatype.com/mvnex-book/reference/simple-project.html
I have not, thanks! I am currently looking at: https://spring.io/guides/gs/maven/ But not sure if doing that will add another layer?(spring)
i am a php engineer, trying to learn and master java. I decided to create a small java project to practice.. Do you have any feedback ? Project structure, dependency manager, patterns, tips etc Cheers
My personal opinion is that one of the major good things about maven is that it fights you when you try to do something slightly different. This makes sure that most projects that use maven have roughly the same structure, and when I come in as new in a project, I can hit the ground running and doesn't need to parse someones home build build and deployment system.
Of course I did that but it's not the right way it seems. :( Please see my code here. https://imgur.com/6Ou6cqW
Throwing Exception isn't helpful. Either find a subclass of Exception or RuntimeException that makes sense or create your own exceptions. For example, [this](https://github.com/0x13a/tinder-api/blob/master/src/main/java/com/djm/tinder/auth/AuthRs.java#L22) would be more useful if you threw an AuthenticationException or something like that. [This](https://github.com/0x13a/tinder-api/blob/master/src/main/java/com/djm/tinder/profile/ProfileRs.java#L27) is very confusing. Date already has a [constructor](https://docs.oracle.com/javase/8/docs/api/java/util/Date.html#Date-long-) that takes a long so there's no reason to pull java.sql.Timestamp into the mix. Otherwise it looks fine. There are some areas where you could leverage newer Java 8 features like java.time APIs instead of the old and clunky java.util.Date and friends. I'm also not a big fan of json-simple because it's API leaves a bit to be desired; that's just a personal choice though.
Using interfaces for public constants ... I always prefer using a concrete class with a private constructor to avoid any instantiation.
What are you talking about?
&gt; Every shop that I've seen will have at least 1 shared library between some micro services. I only see your solution working if you forego code reuse between micro services. Not sure what you're suggesting, One of Maven's core features is dependency management. You just need to have a module with the shared code.
That's exactly what I do. But the article clearly explains how maven's multi module support is lacking. My experience with them supports this.
Just an extension on what u/Northeastpaw said, avoid throwing checked exceptions. Unless you want to require code that calls the method that throws a checked exception to do something about it, all you are doing is making your code harder to use.
Nested generics like that are generally bad. Especially if collections contain collections. As if afraid of creating new classes / objects.
This is a strong, positive signal from the IBM camp. It certainly reads like an endorsement for the re-submission of the JPMS proposal for the Public Review Ballot.
In my experience Kafka isn't a good "job queue" because it's hard to balance work among the "workers". The problem I had was that it's the producer who decides how to split "jobs" among the partitions, but the produces has no idea at what rate the partitions are consumed. If some consumers are slower (e.g. because they are running on a machine which is also used by some other process) then their partition might not be processed fast enough even though others are. You can't add more consumers to single partition so you need to add partitions. Basically in my case there was some small number of "jobs" (e.g. 10k) to process ASAP and the imbalance was causing most of the consumers to be idle by 50%+ of the time, while the last 1-2 were catching up. Switching to a queue where workers poll the queue for more job fixed the problem (it was based on Redis, but Rabbit would work too). What I'm trying to say - the workload pattern matters. If your workers execute small number of expensive "jobs" then Kafka might not work well. Adding workers won't also be that simple because you might need to adjust number of partitions (and as far as i know you can only add those, not remove). But if you want to process large numbers of messages with guaranteed ordering and ability to reply them in the future then it might be a perfect fit. see https://stackoverflow.com/questions/40549483/how-kafka-balances-partitions-load 
Once again: please read the sidebar.
&gt; Ideally, you should only have as many threads as you have cores in your CPU. You mean for parallel processing. There are other reasons to use threads other than parallel processing (like UI events).
No, this looks like a good guide to get your feet wet. Spring is not being used in it.
&gt; or is it actually truly random how it chooses elements to combine? As far as I know it isn't random (adding randomness will be extra work). But the api assumes its random for par streams. I would've liked 2 different api's, the smaller one for parstream and the bigger one for 'sequential' streams. &gt; Or call a short-circuiting operation like `findFirst` or `anyMatch` Yeah I used those a lot too, I haven't even considered that. &gt; Though I'd say that the key advantage of Streams is declarative syntax rather than iteration performance *if* people have seen it before than yes, however seeing stuff such as `flatmap` or the `fold` operations for the first time can be a little overwhelming. Although once you realize how much work it is to write these operations in an imperative style you quickly realize how much gain you can have from fp.
apache https://commons.apache.org/proper/commons-email/
I think it's just confusion, because java has keyword Interface. But when we speak about design it do not relate to any language, so term 'interface' is a Contract your class or module or component provide for their consumers. Also it do not relate to Dependency Injection or Inversion. But yeah in Java we have some limitations using classes vs interfaces. Couple days ago my colleague introduced 5 interfaces for 5 classes. And when I've asked him "what's the purpose of thous interfaces? You have just one implementation for each." He answered: "Oh, I dont know, I was thinking it's a good practice".
JMH is for micro benchmarks and as such does things like run the timed code many times. OP is basically attempting to measure the time of a relatively slow IO operation so I don't think JMH fits well
Yeah op is waiting on an IO operation it makes sense to have many more threads than cpu cores
You are joining on each thread right after starting it so only a single thread is ever running at a time basically defeating the entire purpose of creating threads in this instance. You should create and start all of the threads in one loop. Save them in a collection. Then join on them in a second loop. Even better you should look into using an ExecutorService and awaitTermination
Yeah I'm trying to use ExecutorService also. Will do more of that and see how it's working. 
IMO this is the best free online mooc you can find : http://mooc.fi/courses/2013/programming-part-1/
&gt; Note that scala integrates seamlessly with Java. That's stretching it a bit... Ever used scala from java code?
I know about that. It's annoying that it's necessary. Maven should detect the change and do it for me.
https://www.reddit.com/r/java/comments/6dmapz/sending_email_using_struts_2_and_javamail_api/ Spring mail isn't a replacement for Oracle's mail jar, it's a layer on top of it. 
&gt;I can hit the ground running and doesn't need to parse someones home build build and deployment system This is one of the arguments folks like to use often but it doesn't make sense. Once a build system is up and running why do you need to "parse it"? A new developer on a team should simply be using it. The only time I've seen anyone need to understand a build system is when they did need it to do something different for one reason or another, and in those instances Maven actually made it more difficult. 
Checked exceptions have their purpose. Sometimes an error is likely to happen and you want the user to be forced to deal with it. 
Yes, but only for big enterprise legacy projects. Regardless the tutorial is still useful for people who get assigned to work in those kind of project and have to implement something like the that.
Udemy cources could be useful, but only by 10$
I'm proficient in both, but prefer Java's API design and memory management. The political/business history of the two platforms' development still grates on me, and admittedly colours my perception.
Perhaps so. But as for me, I really cannot tell the difference, because I only use the basic features (i.e., search and add libraries, and update them). In fact, in my experience, the Nuget GUI of Visual Studio was better than the Maven GUI of IntelliJ (Android Studio). In Visual Studio, if I search for some Nuget packages, the libraries have icons and short descriptions including web links. In IntelliJ, the search result is just a textual list, which includes only the package name and version.
Last time I programmed C# a lot of the C# source code (examples, open source programs etc) available on the internet required DLLs available on Windows only. Maybe it has changed.
I am paid to write Java. C# is definitely on par with Java, language design and feature wise it definitely has the potential to be more comprehensible and expressive. It's just so easy to get a paying gig as an enterprise Java dev, though
Having moved from years of C# to Java, I really miss linq and free getters and setters. Spring boot Java annihilates C# on things like ease of getting running and environment configuration. Also lamdas feel better in C# than Java. Other than that, pretty equivalent to me. *edit* I really miss var. God I miss var a lot. How did I forget about you var? I'm sorry. 
But... Why?
https://i.ytimg.com/vi/LlOSdRMSG_k/maxresdefault.jpg
methods end with parens(), members have camelCase, and classes use PascalCase. it's for differentiation at a glance. 
Like part-wise in English or German: Nouns being upper case and verbs lower case. Nouns relate to classes, verbs to methods. It reads more fluently.
Looks ugly with operators, but works well enough. With drools I had one way integration which is much more troublesome.
The only reason to have more threads than you have cores is if you have a blocking API -- that is, the code either does a busy wait or the thread is blocked on IO. Other than that, there's no technical reason you need more threads for UI events, and if you do that's a consequence of the UI framework using threads for asynchronous operation. Akka does just fine with an actor model using messages and a CPU bound fork-join thread pool.
What? All the benchmarks show streams are only as performant as iterating on collections at best, but significantly (5x) slower if you use them naively and don't apply a bunch of optimizations.
Kotlin was inspired by C# and is Java compatible ;)
It's just what I leaned, and is the Java convention. Using PascalCase for both can be confusing.
Wow so quick to judge with out knowing the actual business problem! 
I prefer Java, but i love visual studio
Project Coin looked into adding properties to Java. Everyone agreed that they wanted properties, but no one could agree on a specific implementation.
C# is hopelessly tainted by Windows which will always and forever be a steaming pile of crap. I don't want to have anything to do with that ecosystem. I have spent a good portion of my 30+ year career trying to avoid working in DOS/Windows though have inevitably had some exposure for cross-platform work. If the CLR environment was more competitive with the JVM and could be divorced from any association with Windows, both for runtime and tooling, then I might be more likely to consider C#.
I was never a big fan of Visual Studio. That's what we used in high school for C++ and VB. I use IntelliJ and CLion now.
The real question: Spaces or tabs?
Yeah... Why does it matter for some people how you start a method name? It's stupid, there's no difference, only getting used to it.
Interesting, I'm using C# now for the first time (past 2 months) after 10 years of Java. I desperately miss my collections from Java. C# Collections seem really less coherent to me.
I'm a Java developer because I wear glasses and don't c#
Lombok is a bit unusual in how it works. It's a source code generator so it needs an IDE plugin, so that the IDE can be told what is being generated. However unless your project uses any unusual building process it shouldn't be a problem, and even then Lombok provides an Ant task that can be used to create a "lombok-free" version of your source. Also it doesn't make your project any larger, since it's a pure compile time library. No additional JAR is needed at run time. Regarding LINQ: You may want to have a look at Javaslang (recently renamed to "vavr"). It's not quite the same thing, but there is a lot of overlap.
Ohhh lucky you. My uni forced us to use the maven plugin for eclipse... 
I've never heard of anything meaningful being written in C#, it's more of a meme language than python and python allows you to do some incredibly nonsensical things.
A legitimate use case is if you happen to need to import two classes with the same name - Java doesn't support import aliasing like some other languages. So to make use of both java.util.Logger and com.example.myapp.Logger in the same class you're going to have to fully qualify one of them.
Well the stdlib has a convention and if you don't follow it then it gets annoying as you're being inconsistent.
The only thing I never really liked about C# as a Java developer was the fact that you were locked into the Microsoft platform. Yes technically there were open source implementations of the .net platform, but those aren't ever quite on par to the original implementation​. With Microsoft opening .net in recently, I think C# is a pretty decent option now.
&gt;A build cache is a cache that caches the outputs of any task, not just jars. Maven itself has no such thing. It caches outputs, not transient data. And that sounds like a better strategy to me. &gt;The Takari project repairs a lot of Maven, but it basically replaces so much of Maven that it is not Maven anymore. The same plugins work, the build is specified in the same way, what is the "it's not maven anymore" reference to? By this logic, a lot of maven plugins make it not maven. &gt; The burden on the developer to know at each time exactly which state all his module builds are in is not a virtue or a solution to anything. The burden to know plenty of command line parameters that cannot even be put into the pom.xml is also not a sl´olution to anything. You can get used to that and feel like a Maven-Jedi all you like, it is still shit to everyone else. If you just want it to take care of it for you use SNAPSHOTs. That's what we do in development, and the build server sets explicit versions. Some of think that having a change in a core module change all the downstream modules causing a massive testing effort across a bunch of modules that might have not needed it is a pretty shitty experience. &gt; For dependency control, maven makes it near impossible to globally exclude transitive dependencies from the compile classpath, as an example. It is very painful to define dependencies in a correct way. This is a (fairly infrequent) problem and there is an active feature request to add the functionality. For now, if this is a big deal to you, it's probably because you don't share a parent pom and use the dependencyManagement section. 
Did you ever try to debug a Stream? It's a nightmare. Of course it's intended because Streams are lazy / declaritive and not imperative. But wow is that annoying.
&gt; LINQ I really, really miss that in Java. Working with tables just feels so cumbersome compared to how it's done using LINQ.
Try out https://mvnrepository.com
Thank you very much! What blew my mind when I first saw LINQ in action in C++ was its fluency. It feels almost natural to read, if that makes sense. Unlike the C language itself... At first glance, JOOQ looks like a much nicer alternative to Hibernate in desktop applications.
This would be nicer if it wasn't a 4 page thing. I get you need the ad revenue though 
💩
Your builder implementations are wrong. Why have a builder if you have setters off of the object itself? You're missing documentation on your methods, particularly on the arguments. What is this Rq Rs stuff? You can use full names in java, and it is preferred to some acronym that only you know. 
Even though it looks that way at first glace, it is not true. I would advise you to spend some time reading the Gradle documentation and you will see that it is much more different than Ant. And I am saying this as somebody who is using Maven.
Serious question (hopefully not too off-topic): Is there any good tutorials/docs out there for getting going with writing build files and using msbuild outside of VS? I was trying to use the MSDN docs but they weren't as comprehensive as I was hoping. I want to be able to write full C# projects without relying on an IDE doing work for me.
&gt;Of course, Java can run on more platforms, but it is not exactly due to the Java language per se, but rather due to historical/political reasons. &gt;I mean not things like "I hate Microsoft" or something, but purely of the C# language itself. To me this kind of thing matters more than the design of the language itself, especially if the languages are very similar in design and function.
Most of the problems mentioned in the article (incremental compilation, reactor builds, dependency issues) are evident only in big monoliths with a large multi-module structure. Smaller projects with a simpler structure (i.e. micro-services) work just fine with Maven.
There is also Pants :-) http://www.pantsbuild.org/
H2 is a good database if you have not many uses and limited concurrency.... I built a few websites using it. The one that became popular, H2 couldn't cope. I replaced with Postgresql, and far far faster. Though, admittedly, for single user H2 is much quicker and easer to get going with.
The Android UI is thread based.
TIL
Isn't that artifactory? That's what we use but maybe that's not the same thing.
I think it's worth touching on certain key books as well, which are really well suited to beginners: I know there's a lot of threads already about recommended reading, but I believe this list would complement the steps you mention: 1. Head First Java 2. Head First Design Patterns 3. Clean Code 4. Effective Java I see all of these as fundamental texts, which will ensure that any developer knows how to structure their code, and which core libraries to work with from the getgo. 
Microsoft is working on cross-platform C#, but the Linux and Mac versions[1] only have been available for a handful of years. [1] official versions, disregarding Mono. It's complicated.
I have very limited C# experience, but from the little I've seen, C# is a better language, purely in terms of syntax and semantics. Java is better in most other respects. The java ecosystem, naming conventions, actually being a proper cross platform language, "standards", etc, are all better in general. Given the choice, I'll pick Java. I can work around more rigid syntax and the verbosity is actually a good thing when reading unfamiliar code. I also like the wide choice of tooling, and the fact that despite all the crap Oracle does, java still "just works" as a write once, run anywhere language. 
Really depends on what you want to do with your application. Games/time critical stuff - sure, Java's probably not a great choice. Typical business backend - works pretty well and gives you tons of options to customize it.
Tabs..as spaces
Why would you want to remove the use of the new keyword? What's wrong with that? The way the builder should be (at least from my experience, is like this): public class Cat { private Cat(){} private String name; public static class Builder { private Cat impl; private Builder() { impl = new Cat(); } public static Builder create() { return new Builder(); } } That way people call with: Cat kitty = Cat.Builder.create().name("SomeCat").build();
the only thing it changes is that you have an extra class Builder, the approach is still the same. isn't it?
Im still not sure what to make of lombok. I spent abt two hours trying to determine if i could use it and still didnt come to a conclusion. Many people saw it as a hack and raised many maintenance and compatiility issues. The fact that there is a delombok tool scares me. 
Not really. It was influenced by Java, Scala, Groovy, C#, Gosu, JavaScript.
Artifactory is a repository for Artifacts.. definitely not a GUI for Maven
well, if done correctly, the Cat object becomes immutable. Yours still has the setters on there, so your Builder() isn't an object, it's just a static method called Builder that is returning an object, which I can still call setters on. The use of the builder is to return an immutable object. So Cat would only have getters (no setters).
I really like it. I don't like the formatting at all though. Bugs the shit out of me. If you only have to worry about Windows, it's a great language. 
Technically it's not Java, but if you want these features, I'd choose Kotlin over Lombok any day. Kotlin is just fantastic and scratches every itch I have about Java, while still maintaining 100% interop.
I wish my job used C# instead of Java. I also wish that, at the same time, Maven and Nuget could magically switch places.
This is really my only complaint about F#, debugging functional code just is not as supported in modern tooling. Which seems like it should be the other way around.
Delombock scared you? I think that a project that is providing a tool to scan your codebase and remove all of its hooks is a really nice thought, and not usual for people to offer to help remove dependencies on their own project.
Agree with everything except date. Java 8 Date has (finally) resolved that legacy rubbish.
Partly opening.
Maybe he wants to keep his sanity.
You can tweak JVM to your heart's content.
Spring added support for Kotlin recently, give it time.
They also bought RoboVM and shut it down.
I don't know if I was clear. I mean that I think C# is the better language but that maven is the better build tool compared to NuGet.
Yeah but the operating system you is quite closed one, isn't it ? ;)
With questionable licensing ;)
I like the language a lot, but I feel Java has better tooling and 3rd party libraries.
From a pure technical standpoint. Reality is that you will write better code with streams which it self makes it more performant that a crappy implementation that you would do with a for loop.
I personally like C# and find it considerably better language than Java. However language itself is maybe 20% of what matters in software engineering. Ecosystem and tooling are more important and Java is superior in this regard. Perceiving C# and .Net as Windows only stuff clearly does not help. I hope that .Net Core will change this and make it adopted outside of Windows world.
Actually Java outperforms C# in games/time critical stuff category too. C# has some low level additions. But that has consequences: the virtual machine cannot make optimizations on its own, since the programmer already decided about the lower level usage. Syntactically C# is less readable because of the additions. Some added low level features to Java (like the sun.misc.Unsafe) increase Java's performance greatly, but those same features prevent the JVM from making optimizations. A good example for problems with C# memory management would be Unity3D. There is a limit for what is possible to achieve performance/memory wise in Unity3D because of the C# memory management. The same would not happen in C++ or even in Java, if done properly. The problem with Java coding is that most people don't know that you have to restrain yourself. You can create objects, and the garbage collector will take care of it. But you have to restrain yourself in creating those objects. And if you work with really big datasets, you have to handle those data in bulk. There are best practices and libraries for that, but most people just use some naive approach, and then they complain about the performance.
I felt the same way for years, but recently started using it as my current team adopted it for a lot of our services. It's actually really nice. Sure you can live without it but it saves a lot of time. IDE and environment setup is easy and it's not hard to get used to the annotations. They're all very explicit and straight forward. The only one that's borderline too vague for me is @Data. Even people who are familiar with lombok often don't remember exactly which annotations it wraps. But when you see a class with @Getter @Builder you know exactly what you're getting, etc.
Only proper nouns have upper case in English. All nouns are capitalised in German.
The point they were making is that `java.util.Date` still exists and isn't deprecated .
It really helps having different GCs available, with different goals, so you can pick the one that fits your need and then tweak it from there.
There probably easier and better ways to do whatever it is you are trying to do. Akka is great if you need stateful high performance actors and don't mind reading tons of cryptic, mind boggling documentation. You probably don't need that though. Vert.x is not great. If you can explain what you are actually trying to do you will get better suggestions.
Akka is a well test system and you should look also at Quasar. Moreover Akka works well with Scala other languages may have problems. Finally I tested Vert.x using Kotlin coroutine, writing some few lines makes easy to avoid callback hell.
Right. So basically what I'm trying to do is ingest data, build models and use a restful interface (external) that will consume the output of my model. What I'm thinking of is to have separate services for ingestion, prediction, and output. Why separate services? I plan on modifying and evolving them independently. My source for ingestion is MsSQL right now. Will change to hadoop in less than a couple of months. My models are naive, although they perform well. I want to test better models. Additionally, I need excellent monitoring, so need hooks throughout the pipeline. I want to build a dashboard where I get the true values plotted against the prediction values, etc. Also, I wanted that the prediction system itself can be wrapped as a RESTful API that is independent of the ingestion(pre-prediction) or consumption(post-prediction)
&gt; What kind of applications are those? Mostly various intranet applications that cover various business areas and processes. &gt; Database sizes? Most of them are under 200 GB, half of them ~10GB and only 2 of them are ~250GB now. &gt; No of concurrent users? On the application level (not DB Level) we have usually ~500 concurrent user sessions (i.e. Tomcat users sessions) We use the Tomcat connection pool, and HickaryCP for some. &gt; Query complexity? We use ORMs as much as possible. Only few reports are complex. We avoid making the DB Model too complicated just for the sake of normalization :). 
Exactly, I don't consider Kotlin j++. I'd say it's more akin to J--, it removes and simplifies a lot of stuff from java that we didn't know we didn't want back then. Scala would be J++++
Why? I used LINQ for the 1st few months then switched over to functional style which has more features. Now I see LINQ as cruft in the language that they can never remove.
Well, to be honest I spend a fair bit of time at work handling our build and deployment systems. I often solve those kind of problems for people, I'm not a pure Java programmer that only write application logic in Java.
Who can afford to live for free? ;)
Why vert.x not great?
There are a lot of underlying questions that makes this hard to answer. Data volumes, real-time needs etc. Maybe it suffices to rebuild models periodically? Then you could set up a deployment pipeline, where a new model triggers the deployment of the frontend. Do you use AWS? Then there are lots of services that you can leverage to avoid the IPC that I'm guessing you want Akka or vertx for (such as SQS + S3, lambda). In short, there are lots of unknown variables, but I'm uncertain whether *either* vertx or Akka would be a good fit. My recommendation is this: build the simplest thing you can get running. Maybe it needs a lot of manual steps? Then automate the manual steps. Maybe it requires more machines than one? Then set up some sort of worker queueing system using a message broker. Don't plan too much for the future, instead become good at changing what you have when you hit a hard limit.
If you are using MSSQL for ingestion, I'd suppose your data is not streaming. If it's not streaming, then I'm not sure I'd throw in reactivity just to separate the phases and get monitoring hooks. As efficient as reactive systems can be, they are still slower than other distributed processing setups. Also, there's still a great deal of additional complexity in them that you'll have to spend time tuning (for starters, they are a lot harder to debug). If you want to evolve the layers independently, you can apply good interface-driven principles, no matter what your implementation is based on.
I used Date as an example of legacy that remains in the API. So the old Date is still around causing confusion. The new date is LocalDate.
You also have to know how Hibernate works, what is Persistence Context and how it manages your entities. 
Exactly, the LINQ lambda syntax looks like idiomatic C#. &gt; Extension methods Is probably the one feature I miss the most at the moment. Just for `org.apache.commons.lang` and `io`. 
^Did ^you ^try ^the ^alumni ^address ^of ^your ^university?
Eclipse also as such a plugin, and it even deserves a little bit more the name of GUI since it helps you update your pom.xml in a GUI with plenty forms. I personally dislike this feature, but to each his own.
I hope the inspiration from JavaScript was only the marketing bits.
Still, it doesn't matter whether it's camelCase, PascalCase or snake_case. The only thing that matters is consistency.
A lot of Java/Kotlin developers are gonna be mad they didn't think of the name first.
Ease up there, brother. I was asked for my opinion, I offered it. If you're happy with C#, be happy with it.
If you can, start with Gradle. Or Buck, pants, bazel. They're the future.
From the website: &gt;Javalin started as a fork of the Spark framework but quickly turned into a ground-up rewrite influenced by express.js. Both of these web frameworks are inspired by the modern micro web framework grandfather: Sinatra, so if you’re coming from Ruby then Javalin shouldn’t feel too unfamiliar. 
Don't click from mobile people, you will be drowned in pop-ups.
The comment I replied to got deleted, so posting this on the top level: Yes, it's very similar to Spark. Here is a very short (and not very thorough) comparison I wrote for the post on hackernews: * Javalin has no static API, and no concept of "Routes and Filters". In Spark Routes have a return value, in Javalin you just have "Handlers" which operate on the request and response. Javalin can do automatic object-mapping to and from json, and has lifecycle events. * Javalin has a built in mechanism for auth (AccessManager) * Javalin has no WebSocket support, and doesn't do static file handling (it leaves this to the embedded server). * Javalin runs before-handlers before static files, Spark does not. * Javalin has a fluent api. * Javalin is implemented as a servlet, not a filter. * After-handlers are run after everything (even in case of exceptions), (Spark has after-after filters). There are many more small differences. I'm one of the maintainers of Spark. Javalin is the result of using Spark daily for the past two years, fixing minor annoyances and including new concepts I would find myself implementing over and over again.
I disagree, and thanks to the author, te article is very very interesting
Some probably do, I don't :)
I had problems with H2 when using it with lobs. After few days of extensive deleting, inserting lobs my db was always corrupted. I switched to mysql and everything works fine ever since.
If you can hack something together with Akka fairly quickly then that is your answer right there. Pick whatever tech stack that allows you to iterate quickly. That's the most important part. Just be prepared to rewrite it once you've learned more. Good luck!
We use .net core for our new stuff which is both open source and cross platform.
Often no. But it's important to know how to sql works so you understand what the orm is doing. 
Where I work, the legacy monolith is a hibernate monster. The database is a disaster. All new services use manual SQL, usually using Spring JDBC template. We have two DBAs to tune things if ever necessary. I'm not that good with SQL, but I think it's worth it to use directly. ORMs fit the definition of technical debt perfectly.
It's all ball bearings now a days.
I'm not a db guy, but what's most obvious to me is the table design. The way you hold your data in memory is not automatically the best way to hold it in a database. This idea becomes even more pronounced if you use something non-relational like Cassandra. But back to relational, creating dozens of classes with many relations is essentially free inside Java. However, if you let Hibernate do all the magic for you, you can end up with a huge amount of tables where you have to do a ridiculous amount of joins every query, often pulling in a lot more data than you may need. I've also heard that it is really difficult to tune.
Check out MyBatis (3.x).
http://www.smbc-comics.com/?id=3454#comic
But if your naming conventions don't match the stdlib and don't match the other libs you use it looks out of place.
And the first iPhone UI was single threaded.
Sure, I meant there's no point in comparing the choice of case of different languages' conventions. My comment was meant to back up /u/rehemiau's one, I don't get why he got downvoted while he was obviously replying to /u/armornick's dislike of PascalCase for methods.
Wtf this guy copied toptal's article: https://www.toptal.com/back-end/server-side-io-performance-node-php-java-go Edit: my bad, didn't about that share service still the ads sucks
Anytime you're working with a rdbms you need to know SQL. ORMs are great for straightforward cases, but for anything complex you revert to querying. Even if you're using hql or some such instead of SQL it is substantially the same.
Good point. I never go to level 3, and I figured that it would really be up to your application logic to implement it. I'd be happy to provide functionality to make it easier though, as long as Javalin stays un-opinionated. Anything in particular you think is essential to include?
Hopefully this isn't unwelcome here since you're asking if programmers (generically) use SQL regularly -- but Python has a [whole officially-endorsed API](https://www.python.org/dev/peps/pep-0249/) for database interaction which many of the major SQL non-ORM drivers conform to. DBAPIv2 encourages the use of raw SQL in your Python code, which usually means you have supporting SQL files to bootstrap your database -- which in turn means you write SQL left and right.
How do you define *"better"*?
&gt; Do programmers still write SQL themselves? This is the important part of your question. You make it look as writing SQL is something like a burden. But you don't seem to see the full picture. Yes, it is a burden when you're talking about simple CRUD. Or worse, complex object graph persistence. In these cases, SQL is not a very good tool, because, well, you're not really querying the database, you're implementing state transfer between the persistent storage (DB) and your "cache" (application). That's where ORMs shine. (let's say, the help making a really hard problem "tacklable", it's still hard) But when it comes to querying (even relatively simple queries) or bulk data processing (e.g. ETL) or reporting, ORMs don't (and probably never will) beat SQL, because in order to beat SQL, they'd have to - wait for it - expose SQL to the client. In particular, JPA tried to do that through JPQL (and to some extent through the even less useful criteria API or fetch graphs features). If you do a fair comparison between JPQL and SQL, you'll quickly see that the latter is by far more advanced and useful. So yes. Use ORMs where they shine (object-graph persistence) and SQL where it shines (querying, bulk processing, reporting). [I've wrapped up these thoughts in a blog post, comparing Hibernate (ORM) with jOOQ (SQL)](https://blog.jooq.org/2015/03/24/jooq-vs-hibernate-when-to-choose-which/) [Also, my thoughts on the object-relational impedance mismatch](https://blog.jooq.org/2015/08/26/there-is-no-such-thing-as-object-relational-impedance-mismatch/) And yes. I write and manually tune tons of SQL and only SQL.
Yeah, I don't mind writing accessors and mutators. Most IDEs can do that for you anyway.
I use IntelliJ's Community Edition, but I also use CLion, which I am glad I don't have to pay for, currently being a poor college student.
Spring JdbcTemplate. Nuff said.
With spring-data-* you can do simple querying sans SQL.
I write a small amount in code, and some to generate reports from metrics tables.
Where I work SQL is still a big deal. We not only do we use it to add things to our database, but within our Java we write custom queries if we are ever trying to access certain data objects from another place. It's really good to know and I don't see it going anywhere anytime soon.
And since /u/lukaseder is here, we should mention jOOQ! MUCH better than Hibernate or JPA IMHO.
&gt; maintaining raw sql is tricky What's tricky about it?
I use an ORM in my apps and MySQL workbench for a lot of DBA type task work. I still use SQL for when the ORM performs slowly and also to make sure to spot check the work of my automated tools. Understanding the primary way to interface with the database and some of the underlying workings has been helpful for me.
Yeah, you'll be using some mini-querying language encoded into method names that breaks at the next little query complexity. I'm curious, having never worked with Spring Data (but being well aware of what it is). What's the main motivation to use it for querying?
I'm taking bets. Less than 30 days until Oracle legal calls to stop infringing their trademarks. Who's betting?
Replied to someone else. See there for answer.
btw. you still get my upvote. Open sourcing something, promoting it and standing behind it deserves gratitude. Only this way we can reflect and have discussions about architecture and good software.
Because you never know what the query looks like at the other end and it's likely garbage if you're doing anything more complicated than standard crud.
ORM is a square peg in a round hole. Maybe there is a problem to where it is the ideal solution, but in over a decade in the profession, my colleagues and I have always found it non-performant, overly complex, and a maintenance nightmare. We just write straight SQL for everything.
So... did you test in staging first?
&gt; We have two DBAs The world of programming needs to remove ORM's and hire/train more DBA's and DBE's.
sql2o is also decent
&gt; Wow, these answers are scary! Wanna see something really scary? &gt; I wrote a small language to generate all my SQL for me 
I freely admit that ORMs have made my SQL skills very rusty. I do still have to do a little bit here and there for my company's legacy code, but only small adjustments. And since we're porting it, we no longer care about finding the fastest possible solution. That said, we have our own ORM, so *some* knowledge is required to develop and maintain it.
&gt; It does exceed what I would've thought H2 to be capable of doing. We were constantly surprised of what can H2 do. I don't think the H2 authors get enough credit for their work. It's quite sad that they don't really want to use a standard build tool like Gradle, some standard test frameworks so that more happy users are able to contribute back. &gt; how do you manage the concurrency on the database level when you have It varies from app to app. The newer ones use the new MVVC features, for older ones what worked better during the loading tests. We tried however to minimize the DB hits, roundtrips, runtime overhead, and crashes with various tricks like: - duplicating data for smaller DBs. - constant backups for smaller DBs. - having a more "append only" strategy. - audit and history to a separate DBs for many of the sub 10GB DBs to avoid them growing too big. We also have a few apps with Grails (Hibernate) that seem to work out of the box without any problem or tweaking, just using HickaryCP in Tomcat (given they are only ~2GB in size) 
Thanks for this information, will read your posts to get more familiar with it. Can you please share what are the recommended best practices from your point of view for tuning query performance written over JOOQ (as this is one of the largest pains mentioned here by many people with ORMs like Hibernate)?
All the time. Not everyone uses all that component soup. The less between me and that data the better. The DBMS is fine. I don't need an ORM developer assuming he understands what abstractions are proper for my application. 
I agree that using an ORM is more maintainable. It will be easier for the next programmer to read the code and understand what it does. Usually, it will be easier to find a Java programmer instead of a Java programmer who is also good at SQL. However, I disagree that it is more scalable in terms of performance. Sometimes the ORM isn't going to generate the most performant SQL. You may wish to add a HINT to your query in order for the query planner to generate the best plan. The ORM is an abstraction and there is always a cost to using an abstraction.
When you need to maintain some state for an entity in memory and you want access to that state to be threadsafe. For example imagine making a poker app. For performance reasons you don't want to continuously serialize and deserialize the state of a poker table. You also want any mutations of state happening on that table to happen sequentially but you don't want to do locking. This is a use case that works well with actors. Events from players at the table are added to the actors mailbox and processed sequentially in the order they are received. 
&gt;Today's world is full of ORMs and database related frameworks. From your experience and point of view, is SQL still relevant today? Yes absolutely. Even if you were to make the decision to ENTIRELY rely upon ORM's in all you application work you should still understand SQL for two major reasons; 1. You still need to understand exactly how your ORM is actually implementing its behavior. It's possible the ORM is doing something wrong in which case you might need to make a configuration change or switch to a different version that resolves the issue (likely newer, but possibly older if a bug was incidentally introduced). Either way you'd need to have an understanding of SQL in order to diagnosis such an issue. 2. You will still need to understand your databases structure to make sure it is properly optimized for your business needs. Relationships that make sense in and/or are efficient in the OO world may not make sense or are efficient in a RDBMS. There are of course plenty of different perspectives on efficiency; from speed, to storage, to memory. &gt;Do programmers still write SQL themselves? Do programmers still tune SQL queries and handle performance issues as in the past? Even if you want to put the onus of doing this primarily on DBAs you would still want to have an understanding on this to ensure when your application is having performance issues you are able to diagnosis an issue correctly and communicate with your DBA effectively. If you are running into locking issues it's just as possible the problem is in the application as it is in the database. Final note, while the surface area of learning to become an effective developer is very large it means weighing where you will put your time, I would caution against being opposed to learning about an area. Particularly one as important as data. I say this as someone who need to devote more time to understanding SQL and databases. 
Speaking of databases as in "persistent storage", IMHO every developer should know SQL or the specific language like N1QL (or whatever you are using). ORMs and similar frameworks are great and needed, but being able to query your data manually is a huge bonus, whether for debugging, verifying something, some reporting, or even a script to fix something screwed up. 
Now I'm wondering what the actual pronunciation is for SQL. That google search says it is pronounced like an abbreviation, yet others say it is like "sequel".
&gt; Don't call your framework a REST framework when its just way to match URIs - an "HTTP router". "REST" is misused for so many reasons. Its just sad. Provide a way to map media types. And provide a way to create URIs pointing to routes within the same reactor or to external locations. After that, you can call it a building block for creating REST systems. I get your point, but I know very few developers who do level 3 REST. In a lot of cases a "http router" is what people need to create an API that most people would call a REST API. I will have a look at how I can improve it though! Reverse routing and media types are easy enough to implement. 
You tune jOOQ queries exactly as you tune SQL queries because jOOQ=SQL (almost). So the question boils down to how to write fast SQL. And I generally recommend these things: - Understand the relational model and normalisation: This is a forgotten art, unfortunately, among Java devs. If you get your model wrong, your queries will be even worse. - Side-note: Don't let JPA generate your tables. Write your tables manually and learn how to do it properly, then generate your entities. In the long run, that's usually the better choice for applications that last. - Understand indexing (that's 90% of the tuning for developers). I generally recommend reading http://sql-performance-explained.com. Only 10€ for the PDF version and can be read in 1 day, covering everything most people need to know. - Understand joins and when each join algorithm is desireable, and how to influence that (incredibly, few people know the difference between hash, merge, and nested loop joins) - Not SQL specific: [Avoid needless, mandatory work](https://blog.jooq.org/2017/03/08/many-sql-performance-problems-stem-from-unnecessary-mandatory-work/) - Learn how to read execution plans - [Measure!](https://blog.jooq.org/2017/03/29/how-to-benchmark-alternative-sql-queries-to-find-the-fastest-query/) - Learn the language. A lot of people don't really know even basic SQL constructs, and when to use them. [Here's a popular example of people using `COUNT(*)` when they should use `EXISTS()`](https://blog.jooq.org/2016/09/14/avoid-using-count-in-sql-when-you-could-use-exists/) More advanced stuff: - Understand when to deviate from normalisation. - Drop unneeded indexes (this can be tricky but really speeds up writes) - Learn how to reduce I/O - Learn how to reduce CPU-bound activity - [Avoid offset / learn how to paginate](http://use-the-index-luke.com/no-offset) - [Optimise for statement caching](https://blog.jooq.org/2017/03/30/sql-in-predicate-with-in-list-or-with-array-which-is-faster/) - [Optimise through natural keys](https://blog.jooq.org/2017/03/16/faster-sql-through-occasionally-choosing-natural-keys-over-surrogate-keys/) - [Optimise for statistics](https://blog.jooq.org/2016/10/05/why-you-should-design-your-database-to-optimise-for-statistics/) - Many more. This bullet list is endless, of course, and gets more and more into niche cases. If you're using an ORM on top of SQL, you will still need to know a lot of the above as well *plus* how to tune the ORM.
&gt; btw. you still get my upvote. Open sourcing something, promoting it and standing behind it deserves gratitude. Only this way we can reflect and have discussions about architecture and good software. ..thanks! The project is still only a few days old, hopefully people will join in and help improve it.
Either pronunciation is acceptable. I prefer "sequel" because the very first SQL, by Chamberlain and Boyce (the Boyce Codd normal form guy), was literally called SEQUEL (Structured English QUEry Language." But either way is fine.
SQL never lost its power. ORM'ing everything is just silly. I'll just paste a relevant excerpt from a [comment from Gavin King, the creator of Hibernate](https://www.reddit.com/r/programming/comments/2cnw8x/what_orms_have_taught_me_just_learn_sql/cjheyec/): &gt; Moreover, ORM is for OLTP applications. It's not usually appropriate for: &gt; * batch processing, or * analysis. 
&gt; It's funny, though, there's no hot debate about this and both pronounciations are accepted Just because we don't do it these days doesn't mean it never happened ;)
We use this at my job, and I absolutely love it. Writing the maps can be a bit tedious, but it makes it SO much easier to optimize. You actually know which queries are being run, which is insanely helpful when something in production starts to go slow and you actually have an opportunity to find the exact query and optimize it. 
It obviates a fair bit of boilerplate code. Write a method signature, done. As mentioned previously, works great for simple cases, revert to writing queries for anything complex.
YES! Or teach your developers some basic SQL skills so they don't kill your database. 
+1 for MyBatis
FTFY &gt; more complicated than standard ~~crud~~ demo. It's becoming a thing: [demo driven development](http://devdriven.by/demo/)
&gt; What made you choose H2 over its alternatives: &gt; Derby Too buggy for the use cases we tested. When Sun included it as JavaDB we had big hopes, but simply does not cut it. &gt; HSQLDB We found no real advantage of this over H2. &gt; SQLite We are using this too, but for the non-java projects. &gt; Oracle The DB costs more than many projects themselves, so it's a win-loose-loose situation (oracle-customers-us) :) &gt; SQL Server Only recently seems to run on Linux too. &gt; DB2 On non-IBM hardware, performance tests were quite bad. &gt; MySQL, PostgreSQL All our apps are quite compatible with MySQL or PostgreSQL too, so it would be easy to switch - we did for those that really grew to a few TB. However the overhead of a PostreSQL DB (simply the TCO) is much higher than that of H2, so we try to keep H2 for as long as possible. 
Or jdbi.
Yes, they do
Thank you Sir! This makes sense. I think I'll go forward with Spring for now
Spring Data is as amazing as it is useful. Put simply, it is one of the best tool to have in the Spring Framework.
Every day of my life.
Hibernate and such are fine 90% of the time, but the remaining 10% is often where the added value of your app lies.
Couldn't live without writing a simple SQL statement. Really easy to learn. 
In the space I work in, yes. 
In my case: reduction of boilerplate. 
I only ever end up writing SQL for reports, whether it's raw SQL, SSRS, Crystal Reports, Power BI, Tableau, etc. I enjoy writing SQL for reports. For most programming projects I'm fine using an ORM, but as soon as I realize I need more granularity I'll switch to plain SQL. My favorite part about C# (though I don't write much C#) is LINQ.
Any love for Masturbatis?
The project has slowed down from 2015 onwards.
Not free.
So?
It looks pretty nice. I'm in the process of making a pretty simple flash card app. I'll give this a go for the backend.
As far as i'm aware the output UI components *are* embedded terminals in IDEs with a fixed working directory(project folder in Netbeans IDE). If you want to actually get a terminal your probably just going to have to run the jar.
For complex stuff you can map those methods to JQL or SQL queries via @Query.
Some things are worth spending money on, jOOQ is definitely one of them.
And do most programmers either know how to do that or have enough permissions to get it directly from the database log? I have my doubts.
The names of the query methods can get out of control pretty quickly, which ends up being comical. &gt; public void findTop5ByStatusAndUserOrderByStartDateDesc() I'd love if they'd add a way to alias that one to make it more readable. Things like: &gt; public void findByUser() Are great though!
Not until performance matters.
"Javlin" sounds better.
See Vert.x Sync to avoid callbacks.
I write SQL almost every day since MyBatis is our ORM of choice and it uses pure SQL in the mapping files. I work on a small team, so the tuning and performance of SQL are also my job.
That's kind of cool but unfortunately I have been using Vertx since version 1 so I already have a mountain of horrendous code to deal with. I don't think quasar even existed then. I am more likely to start transitioning to the scala api.
What wouldn't you be writing in SQL?
Sequel is how it is pronounced at my shop, and all the shops I ever worked in for the last 21 years. Including college. 
Any program can be written in Postgresql's plpgsql. If your program is largely set manipulation, it's one of the best choices.
It depends, in my experience orms are great in the enterprise. I have some Co workers who still do custom sql but most of us have moved on. I have heard the orm sql debate for a while and I really have to say I disagree with the notion that the use of orms is worse than custom sql. Maybe it's the orm I use, entity framework code first, or perhaps it's the domain driven design that encapsulates our orm perfectly or perhaps it's being able to wrap our linq queries in unit tests and integration tests. But whatever it is, contrary to the dominant opinion here, our solution works great for us. I am curious though why many have not had the success with it that we have. I want to ask, do you guys work on a great number of applications that communicate with each other or do you guys have one really massive system for which you find sql queries are the preferred method? Edit: grammar
"ess cue ell"
I'd use it with native queries, just less code I have to manage, sql mapped directly to my own custom type. The method name stuff didn't really appeal.
I did (a long time ago) a terminal application in java (had to read text, passwords whatnot from the user). There was no way to get the application to open up a real terminal (as the IDE one was shitty when dealing with more complicated things). The only way was to run it from a real terminal.
&gt; * Pseudo actors Can you expand upon this as I'm not sure what you mean. &gt; * Callback hell (this might have gotten a little better with scala support in 3.4) We use Java and yeah, if you're just using straight Vert.x methods that can be a problem. But most people tend to use something like RxJava observables or a Promise based package instead of callbacks. We use Promises, for example. &gt; * Encourages the use of untyped json everywhere Whether this is a bad thing or not is a matter of discussion. But it certainly doesn't force you down this route. &gt; * DI unfriendly Not at all. You just replace the verticle factory with a DI friendly verticle factory of choice. We use HK2, for example: https://github.com/ef-labs/vertx-hk2 &gt; * Error handling unfriendly How so? If you're using straight Vert.x classes, then pretty much everything allows an exception handler to be registered. Like I mentioned above, we use a promises framework, so exceptions fall through into that to be handled. &gt; * Event bus lacks advanced routing so senders have to have knowledge of receivers (tight coupling) We don't use the Event Bus, but as I recall the senders don't need to have any knowledge of the receivers. The sender either publishes or sends to an address, with that address being an arbitrary string. Something may or may not be listening. What knowledge of the potential receiver(s) does the publisher need? &gt; * Buggy (redis) and crappy drivers (jdbc) that make you work in async/callback style without actually being non blocking I can't speak for these drivers, as we don't use redis or anything that needs jdbc. We do use Cassandra and Kafka and both of those have excellent support for non-blocking code. But if you do need to interface with something that doesn't have non-blocking APIs, it's really simple to just use the blocking code API that Vert.x provides, so you can just talk to whatever it is without having to mess around.
I don't live there, but I recommend looking into the Boulder Java Users Group: https://www.meetup.com/BoulderJavaUsersGroup/
And here I am still messing around with EARs...
I don't directly use SQL but we use some SQL servers at work, even though the program using the SQL database is single threaded.
That's exactly why. First candidates are my JPA entities.
I scrolled through the auto-generated log file and found a section called [Java Frames](http://imgur.com/vS86SJx) and googled the first string "sun.java2d.d3d.D3DGraphicsDevice.getDeviceCapsNative(I)I+0" It led me to the openjdk bug section and detailed my exact bug. [link](https://bugs.openjdk.java.net/browse/JDK-8178537) As It turns out, RivaTuner, the library MSI Afterburner uses was causing the issue. I uninstalled both, and now my code runs. I have no idea how the Windows update triggered the problem. 
&gt; findTop5ByStatusAndUserOrderByStartDateDesc If only there was a language that can handle this kind of query in a more structured way...
Moving from php to java was one of best decision in my life. Projects are bigger, tools are better and writing good software is easier. You should learn java very fast.
Yep. Very much so. ORM is great for manipulating data as object, but when you want to do something like a complicated report that borrows from 5-8 tables with complex joins... Yeah, difference in performance between ORM and a well-written query is staggering. Also prototyping. It's often easier to prototype and iterate on raw SQL than on an object model.
I sure do Sometimes straight into java strings
I'm pretty sure this was built only to be able to use that name.
&gt; The DBA is more of a SysAdmin, and when they see a bad query, they can't know all the context associated with that particular query. You're describing a very unfavourable status quo of many projects. Ideally, there's at least one "devops" person on the team who understands operations needs *and* developer / business needs. Strictly separating roles leads to Conway's Law in my opinion.
&gt; I agree that using an ORM is more maintainable. Having worked on legacy banking systems that used both ORMs and "plain" SQL I must say I strongly disagree. Nothing really can beat a declarative language in readability. When you see an SQL query you know what it does. With an ORM most of it has to be deduced from the structure of the model classes and the defined relationships. It's even worse if a lot of this configuration is in XML. 
&gt; I don't really gain anything by using two different Docker layers, if the last one is 150MBs You do actually. Docker caches images so if you create a new image with a new war based on (for example) a Tomcat image that did not change it won't have to redownload the base image. 
If you don't need interactive stdin then you can set output file in Run configurations-&gt;[pick your configuration]-&gt;Common. Then open terminal window and observe output file using "tail --follow=name /path/to/out/file". Other possiblity is to use External tool configuration https://stackoverflow.com/questions/908488/eclipse-running-programs-not-in-the-native-eclipse-console
Sorry for that. You might know that with the web profile, you can have EJB JARs in WARs. Could ease your pain somewhat.
Yeah, that would be terrific. We could design it to work out of the box, even!
Well between the two of us you're the smartest one. Chop chop! Get to it ;)
These should only be used for very basic stuff. You can use @Query to map a simple method name to a more complex query.
&gt; Was the database designed up front (and then entities generated) or vice versa? I actually wonder what you would recommend. Maybe database first, all things considered. I put both first... I design the entities as they should be, and I design the database as it should be, and they meet in the mapper.
I think that's generally the point, Spring Data and any ORMs like Hibernate have evolved to cater to microservices that follow software patterns that result in individual services not needing much more than simple crud operations. Having spent most of my career dealing with many of the challenges listed in these replies; needing to optimize complex queries, multi table joins and inserts, etc... I certainly prefer the microservices pattern I now have in my current company. As a developer, you often have little control over the bigger picture architectural choices that could solve this, but if you find yourself dealing with one query that spans so many tables in a complex join with crazy where clauses that it causes problems and needs to be hand tuned because the DBMS optimizer can't figure it out, that's probably a good indicator that your application scope is too broad and it needs to be deconstructed and factored apart.
Yeah, but I think that is a trap a lot of developers fall into with ORMs and relational databases in the first place: if you have 20 different entities and they're all modeled in one database, why not join them all together and do one ridiculous query to get a specific set of information? That kind of thinking leads to the problems everyone is talking about in these replies. Instead of monster queries, break it apart. Don't join a dozen tables together (how many different data domains is that crossing, and which software components should really own each domain?), instead construct a few smaller queries and use the results of one to inform the next. Query for your user data, then query for that users order ids, then query for the shipping status of those order ids, etc. Your queries will be so much simpler a the software will be much easier to maintain.
&gt; Side-note: Don't let JPA generate your tables. Write your tables manually and learn how to do it properly, then generate your entities. In the long run, that's usually the better choice for applications that last. Heathen! ;) Create an abstract entity model at the level of NIAM/ORM (Object Role Modeling) (or ER if you must) and project that to tables. Only then your tables have a logical meaning in your domain and you also know they're at least at 3rd normal form. Funny thing is, that abstract entity model can also be used to be projected to classes, so the entity classes represent the same entity from your abstract entity model as the tables do (they're all projection results anyway). (See the work of Nijssen and Halpin) If you're doing this by 'hand', you're doing the same thing btw: projecting abstract entities to constructs in either an RDBMS or code. Now for the real kicker: because you can project the abstract entity model to tables and classes, you already know the mappings between then and you can generate these automatically. So create 1 model, project them to 2 sides + mappings and you're done: changes made to the abstract entity model ripple through to both sides (in different forms, that's OK). Hand-writing these things is like writing bytecode by hand: you're doing projection work a machine can do for you. Cheers! FB
It's a very interesting question indeed. In my point of view, the database model is the one that transcends any application built on top of it. It is likely to last decades, whereas an application might be replaced by something entirely different in years (think of hypes like Node.js). In fact, since no state is really stored in the application, it will be much simpler to migrate the application when requirements change. It will not be so simple to migrate any database model. In addition to this, I've worked with database models that were accessed by many different applications (and technologies), so it was obvious that the database needed to be designed independently. In my opinion, JPA entities should reflect the database model as closely as possible. I personally don't see the value of an entity model that has unique features that are not truly reflected in the database. Sure, the mapping can translate between the worlds to some extent, but I think it will just be much easier if most of the more fancy entity features are not used and the entity model just reflects the pre-designed database model. Imagine if Java had type providers like more sophisticated languages ([e.g. F#](https://docs.microsoft.com/en-us/dotnet/fsharp/tutorials/type-providers/)). In that case, we probably wouldn't have this discussion and would just code against the database directly (through provided entity types). But that's my opinion. It only replies to the original claim: &gt; The database is a disaster With the approach I described, the database will not be a disaster (or at least not for these reasons). Don't get me wrong. If you have a complex domain model (DDD style), that is an entirely different story. It has nothing to do with JPA entities.
I've heard that it's a good practice not to follow good practices :D Joking aside, there's a lot of benefit of having Devs knowing what Ops have to deal with, as well as having Ops understanding why Devs make certain design choices. 
&gt; Not from thin air or a fantasy, they project something abstract to the definition they're writing. Of course, I didn't disagree with that. My concerns were merely technical and implementation based, not theoretical. &gt; As an illustration: what about entity inheritance? Inheritance is just a technical tool. It is not something that is inherently important to modelling. In fact, in recent years, it has been shown that it is not a good tool at all for practical purposes. Inheritance was over-hyped in the 90s. &gt; What about a m:n relationship? Again, a modelling tool. I'm aware of the fact that SQL can't model it except by indirection. But that's good enough, no? Ultimately, you cannot really model m:n with Java either (although, you can with JPA annotations). But the fact that I always have to remember to update both sides manually with JPA and think about how the state transition is serialised efficiently shows that the *implementation* of this concept just plain simply sucks. So why bother and not go back to the more simple SQL model, which can still model an m:n relationship decently, if not perfectly. (Side note: Not sure how .NET APIs handle this, e.g. EF. Is it better than JPA?) &gt; What about a type in the entity which results in a different type or multiple fields even in the table? Sure, another limitation of most SQL implementations (at least the non-ORDBMS. PostgreSQL and Oracle have solutions for this). &gt; Entity definitions and DDL definitions aren't the same thing, if you mean by that: table X == entity X. I said they're the same thing *in theory*. But ultimately, we're building things on real systems. *in theory* we can fly to Mars easily. We've figured it all out. But now, we have to do that with real world constraints. So, you're looking at things from an academic perspective, and that's important in the long run, because we want our tools to be able to cover your needs. But right now, we're not there and we need to know how our current tools work. &gt; The DDL SQL of the tables is a projection of the entity model and should represent the same thing Yes, we agree. Although again, you overlooked my disclaimer about *theory* and *practice* :) &gt; Though I'd argue that making performance improving changes to a model should happen after a model has been completed OK, we have two different perceptions of performance here. Indeed, some things can be discovered only much after the initial design. But some performance characteristics are best solved a priori. You simply don't want to migrate a billion-row-strong table several times a day. If you know you're going to be dealing with large data sets in an area of your application, then up-front performance-sensitive design is of the essence. Or you won't even survive going live :)
that's normal, website using the share service. 
I'm not trying to convince devs whose main language is Kotlin to use Javalin, it's made more for Java devs and Java devs who are looking to switch to Kotlin. It should help ease the transition.
also jdbi, never tried but looked decent. the version 3, looks a lot more open too.
I personally find MyBatis not very compelling anymore. The mapping it's not on par from a perf perspective the last time I checked, only slower than BeanPropertyRowMapper that is not meant for production use - yes, BeanPropertyRowMapper is the slowest mapper in the world. And the xml, and annotation heavy is quite dated... 
I thought interoperability was easier to achieve the other way. I would love to rewrite it to Kotlin if it would work well with Java, but I don't trust my Kotlin skills enough to do it yet. 
Nah we had our eclipse checked if we had the plugin set up correctly... 
You're looking for /r/javahelp. 
Docker won't just not re-download the base image, it won't copy it at all. Both containers will access the same base image in their file system.
Any time I have to deal with multiple data sources its a pain. I hate arbitrarily marking one as @primary
That's why you have integration tests.
Seems like a bad tradeoff, especially when other languages already have standards like a leading underscore for private members. That seems way better than wrecking the at a glance readability. 
Yep. Looks like a known issue: https://www.maroonmed.com/rivatuner-statistics-server-causes-gui-java-programs-to-crash-on-windows-10-1703-creators-update/
apparently some website editor thought so. Hey - Spring REST tutorial writers - I'd appreciate an actual walk through and discussion of real world problems involving protecting my REST API endpoints with real world security situations. I have literally never needed to export "/users" or "/book/2" without protecting these calls with some security layer. 
SQL - a 4th gen language, where the developer gets to say what information he wants, and the database chooses the best access to get it. Hibernate - a 3rd gen language where the developer models the way data is pulled from persistence. To hide a rich, 4th gen language behind a 3rd gen facade, isnt just bad, its immoral. 
That's exactly one of the dangers of an ORM. Caching speeds things but: just imagine two apps with caching enabled on the same db, updating it. Hell happens, either cache sync or living with inaccurate data. The funny thing is that any decent DB will cache that data for you...
The problem is very likely with your web browser. Newer versions of the major web browsers have disabled NPAPI support, so Java applets won't work. They're not going to fix this. The technology is deprecated, and no longer supported. For now, you can download the LTS version of Firefox. You may have to re-install Java after installing the LTS browser. The best solution is for your school to stop using deprecated technology, but we all know how that goes.
I thought java applets were outdated and that nobody used them any longer. Unfortunately I don't know what to recommend you.
You guys should call it Words That Form a Query Language!
Firefox ESR 45 didn't work, but Microsoft Edge did. Thanks for the help anyways!
As a project member, thanks for the shout out. I'm curious what _you_ mean when you say "more open?"
Yep great point. 
There is always the offline applet viewer. http://docs.oracle.com/javase/8/docs/technotes/tools/windows/appletviewer.html 
&gt; I'd love if they'd add a way to alias that one to make it more readable I'm okay with ugly names in my repositories, I hide those behind a cleaner interface in my services: ``` List&lt;User&gt; findTopWidgets(Status s, User u, LocalDate d) ```
Yep. Been a fan of SQL mappers for a long time. 
Spring Security has a lot of potential but has very little documentation or tutorials. I would watch the crap out of a good security tutorial for rest end points rather than http configuration. 
I don't like PascalCase.. was a huge turn off. Reading methods at a glance give a weird bad feeling. C# seems like only working on Windows. I don't trust Microsoft ecosystem. I will forever hate them for killing RoboVM. And I know many other people feel the same way for all the good products Microsoft bought and killed in the past.
take a look at [my fork of kilim](https://github.com/nqzero/kilim) - it's a simple coroutine based actor system that scales and includes a web server. just add gson and you've got a high performance rest endpoint
BeyondCompare
Yes, that's why I said ideally. 
DI unfriendly? I use spring with vertx seamlessly. There's no callback hell with completable futures. Some of these gripes make me think you never used it. 
*I don't know what a Spring "ApplicationContext" is...* -- [Tim Fox](https://groups.google.com/forum/#!topic/vertx/Ovaf8CxZEDo) I use Spring with Vertx too but I wouldn't call it seamless or friendly. In fact the reason you can use Spring with Vertx now is partially because of my incessant bitching on the Vertx mailing list 4 years ago. Before that Vertx used multiple classloaders which made it close to impossible to share a single ApplicationContext across many verticles. As for callback hell the vertx scala API is the first version of vertx I have seen that doesn't look completely irritating to work with. But it's new in version 3.4 and it only got released in the last two months. &gt;Some of these gripes make me think you never used it. Trust me.. I wish I had never used it.
Usually with an app like that you're looking at probably an OAuth2 provider and the implicit grant type. Spring has an OAuth2 provider with support for the whole spec, so that should be fairly reasonable. Though their official tutorials are mostly for en embedded angular app vs a token based approach, if I remember correctly.
Yes I know that. I am saying that saving 20MBs is not a big incentive to make me switch my whole architecture from single Jar (self-contained) to application server + WAR file. It is not worth the effort (for the gains)
BeanPropertyRowMapper is the spring RowMapper sorry for the confusion. here is the benchmark I had in mind https://github.com/arnaudroger/SimpleFlatMapper/wiki/Jdbc-Performance-Local-Mysql map a simple object from a query. 
I was trying to see for example if I could integrate my own ResultSet mapper, like sql2o, jdbi and jOOQ allows but did not seem possible. Also those frameworks allow you to get out of the framework and fall back into jdbc land when you want. If you want to work on the ResultSet yourself for example you can. Are use jooq to genereate the sql statement and manage the prepared statement yourself you can. Did not find a way to do that with MyBatis. it's seems that it captures the full query lifecycle and you can't escape it. PS: I know it might sound weird but I like ny query to be inlined, not aliased or in annotation. so I understand that it goes against the design of mybatis.
I guess it depend on how you set up your application I glue my components together with spring and run the group of those components that make up whatever service I'm trying to creat as one verticle. All I do is implement a verticle factory that's spring aware and it retrieves my component on deployment. It's fairly straightforward. I've been using spring boot and vert.x flawlessly 
OAuth2 can be hard to grasp at first but the benefits are worth it. Rather than tell you all about it, I'll point you to some documentation and suggest youtubing it. Some docs: http://projects.spring.io/spring-security-oauth/ Also here's a working example using OAuth2, JWT, and Spring data rest to help get you started: https://github.com/john-miller/spring-data-rest-jwt-oauth2 Good Luck!
A gentle introduction to Sets in Java. Perhaps this is the most underrated ds.
How to use EditPlus &amp; Sublime Text for Java development? Netbeans is great, but lightweight IDEs and editors are cool as well.
Agree 100%. I hired 2 exceptional contributors who didn't have any clue about all this when they were hired. They are star performers in my startup now. But the logic of hiring somebody who knows all this is equally compelling. It minimizes the risk employer has to take. Not all smart people have the inclination to learn and update themselves.
Tiobe is a rubbish index. It's utterly useless. It's purely based on the amount of hits on "X programming" which heavily favours languages with short names and languages that have simply existed for a long time. The long tail of "java programming" (and this applies to any language, but ones with shorter names are more affected) will contain mostly rubbish results. "Java" will match on articles about the island. C will match on articles about Arthur C Clarke. At the end of the tail it will be matching accidentally matched documents that just contain pure gibberish. Good search engines like Google hide this very well. "C programming" on google nets me "About 16,200,000 results (0.51 seconds)". So that's 1.6 million pages. Google will however only show me the first 200 or so results. Why? Because those search results become less and less relevant. Tiobe does not take this into account. It's just a dumb weighted counter of the number of hits in a few search engines. It doesn't know how many of those hits are relevant. It doesn't know how many of the hits on "C" are articles on .Net or on 2001 A Space Odyssey. The most damning evidence are the [graphs they publish themselves](http://imgur.com/a/KipOZ). So you're telling me that in a little over one year the C language dropped from 17% to 10%? That between April 2004 and Aug 2005 Java went from 24% down to 14% and then back to 22%? Of course not. Established languages don't show huge shifts like these. What changed was simply how a few search engines like Google reported hits. The 'decline' of C is simply sites like google getting better at differentiating between C, C++, C# and Arthur C Clarke. So why does Tiobe exist? Simple: &gt; Q: I would like to have the complete data set of the TIOBE index. Is this possible? &gt; A: We spent a lot of effort to obtain all the data and keep the TIOBE index up to date. In order to compensate a bit for this, we ask a fee of **5,000 US$** for the complete data set. The data set runs from June 2001 till today. It started with 25 languages back in 2001, and now measures more than 150 languages once a month.
Not necessarily. Works both ways. After joining if you realize you have made a mistake, you may end up studying more aggressively. In short, there can be no sweeping generalizations.
It's best to compare with redmonk which uses different matrices. http://redmonk.com/sogrady/2017/03/17/language-rankings-1-17/ 
If the point is to stress test the end points then you can also do such tests using tools such as JMeter or Soap UI. These offer similar services and further stats, and in particular will be quicker for certain varied tests such as form handling etc. But if you wish to do it for personal learning then ignore this...
Everyone knows these things. So, your task will be: - Find a better way to measure "popularity" (and other things) - Publish it I'd love to see an alternative index.
All indices have limitations. Redmonk, Google's, Tiobe's. However, Tiobe has one important advantage, which is years and years of records. So you can go to 2001 and see how the language has fared over time. For example, you can watch the arrival and growth of new languages and decline of others. If you follow Tiobe and use it properly, you'll understand that the spikes have to be normalized. So at any single given point in time, they're not accurate, but over time they definitely spot the trend correctly. I don't see why you think that charging for their data is a strike against them. 
Yeah, SQL is still the backbone of the database world. Need to write some flavor of it for most Relational Database Models. Just because there is a boilerplate solution for almost anything programming now doesn't mean we throw away the foundation of that stack. (Not saying you're implying that, just in this world of rapidly advancing technology. It's almost expected to throw away what's old in favor of new). As for the fine tuning that's only really required on two extreme ends of the performance spectrum. 1. You have an extremely large user base and the powerful 32 core server accommodating that base is just a few degrees away from a fire. 2. You have a small (but growing) user base and a single core VPS that must minimize database impact for user experience. So as long as you're in the middle of that spectrum, i.e the hardware isn't stressed and the users are having a good experience then fine tuning SQL isn't really a must. That will come with bigger budgets. SQL VS ORM IMO, boycott the ORM. With SQL less is more, keep your queries short and sweet. Write specific functions for SQL that are directly related to your program needs and let the DBAs handle any ridiculously huge requests that involve administrative tasks. If you need ORM, create a few POJO's and map them yourself. It takes two minutes. Much less than retraining for hibernate, which is more hassle than it's worth. 
&gt; Unfortunately not. People keep mentioning Tiobe in discussions on Reddit, Twitter and LinkedIn. So? It's one way to measure (the only popular measurement, unfortunately) &gt; there is a much better way to measure popularity which is simply to use existing sources like SO and Github: http://redmonk.com/sogrady/2017/03/17/language-rankings-1-17/ Indeed, that's another way to measure, and it is also flawed, especially GitHub. E.g. a lot of Java stuff is simply hidden in some enterprise, and so is COBOL, Delphi, FORTRAN, etc. etc. That doesn't mean these languages aren't popular (by means of how many people work with it). And I wouldn't be surprised if SO is strongly biased towards younger programmers, so COBOL isn't given enough weight on there. &gt; TL;DR: there are already metrics that are more useful than Tiobe. It's not hard to be more useful than useless. Fine. Help them become more popular, then :)
Go ahead and learn as may technologies as you want. The more tech you know the better you can evaluate and create solutions that fit you client needs. You won't feel constrained to stick to one platform when deciding what to use in future projects. I worked primarily in Java but I've also delved in PHP, Angular JS projects for my smaller projects. Sometime it good to learn other programming languages since you'll start to get some appreciation on the pros and cons of the these programming languages as compared to others.
Ya I also found out it was generous enough to remove my activated version of Office. I guess they're really trying to push Office 365.
Is this really necessary? You can easily follow the oracle tutorials to find out more about this core part of java including how to make a "hello world" as well. What's next? How to use System.out.println()? I fail to see this post's value.
I would say so, they even got GoDaddy pushing Office365 as their only Email solution for domains now. The kicker for me was that I had to uninstall Candy Crush Saga three fucking times. At that point I just used some program to rip out windows 10's sneaky services. If you're interested it's here: http://www.majorgeeks.com/files/details/destroy_windows_10_spying.html
Spring has some tutorials on it: https://spring.io/guides/tutorials/spring-boot-oauth2/ That one goes through creating your own provider (you issuing your own tokens) and being a client (using something like Google or Github for authentication). It also expects that the client is served from the Spring server - but for your mobile app you should be okay to just create a new client using the `Implicit` grant type (this is a grant type for applications that cannot be trusted with a _secret_, such as mobile apps or client side apps).
On github
I saw those, I'm looking for community open source proyects.
Hopefully you wrote this praneet... seems that your bot is just posting articles only written by this person and links to your quotes website for clicks...
Agreed, and should be in /r/javahelp
Indeed. And that presenting conclusions that they actually know are wrong is unscientific and in my personal opinion unethical. They're not selling a weighted average of search engine hits. They're selling a conclusion. A conclusion that is flat out wrong. 
I am sorry, I couldn't help myself
Create an account on [BigQuery](https://bigquery.cloud.google.com). Then, run the following query (which will give you a list of 7255 projects using Spring Boot). SELECT cont.sample_repo_name, count(*) FoundFiles, t.Total FROM [fh-bigquery:github_extracts.contents_java] as cont JOIN (SELECT sample_repo_name, count(*) Total FROM [fh-bigquery:github_extracts.contents_java] GROUP BY sample_repo_name ) as t ON cont.sample_repo_name = t.sample_repo_name WHERE (cont.content CONTAINS '.springframework.boot.' ) GROUP BY cont.sample_repo_name, t.Total ORDER BY cont.sample_repo_name EDIT: it was BigQuery, not BigData...
You could annotate commits in pull requests to make it easier to review. For instance, a ui could tell the reviewer, these changes are just renaming a method, these ones are moving a method, etc. That would let the reviewer focus on the logic changes.
Maven totally works now and isn't going away before these other tools you mention also get replaced.
That would be awesome indeed! Didnt think about that 
Html+css are a markup language and a style sheet, hardly comparable to JavaFX. But hey, if HTML and css are so much better, how come countless institutions create or buy installable desktop applications? Why does Microsoft continue to create office if there is a web version which is "infinitely better"?
It's getting there. It's good enough that I decided to stick with it. It still has issues, when highlighting or not in Java, but it's a big step up from 6 months ago.
Hey guys, if you could give me some feedback (the reason why downvote), to help me improve my posts, it will be valuable =D Thanks
But think about the *ad revenue*
I second MapDB. It's the easiest persistent data struct lib for Java. Quite fast, too.
Thank you for the explanation. We will check the rules =) Sorry about that.
Writing "still" in the title suggests expectation of change.
Dropwizard, battle tested by us in production for over 5 years: http://dropwizard.io/ I like Spark Java too, but it's not as complete when it comes to monitoring, metrics, custom admin port, etc...which is important for operations: http://sparkjava.com/
I think VB will start seeing a slow comeback, not to any top spots, but with scripting languages becoming more popular VB.NET is a pretty easy way to get working with .NET. It has some weird quirks and is not the language I would choose but it is really easy to use.
VB.NET is just the current version of VB made to run on Microsofts CLR (Comon Language Runtime). Simplifying it down, all languages on the .NET framework get converted to the CLR before being ran , this helps keep it consistent and allows for multiple languages to use the .Net framework, so when you call a class or method in a .Net library, whether your doing it in VB or C#, your calling the same class (in theory at least). If you know anything about java and the jvm its a similar approach to Java byte code though done in a different way. Edited: u/ladywanking pointed out I switched the L and R around in CLR
I write a lot of SQL and use Hibernate's transformers (which is great). This is mostly with our REST API in which our underlying structure is very old and our understanding on what to deliver is drastically different than our datamodel. Thankfully, we're exploring rewriting our entire application so this might change in the next year.
Alas, when communities game the search rankings so that they will appear higher ([1](http://delphi.org/2008/10/the-many-faces-of-delphi/), [2](http://delphi.org/2008/10/delphi-keeps-climbing/), [3](http://delphi.org/2008/10/delphi-language-of-the-year-2008/)) with the ability to influence the ranking, the veracity of the results overall is called into question. As to an alternative? The [IEEE language rankings](http://spectrum.ieee.org/computing/software/the-2016-top-programming-languages) ([interactive version](http://spectrum.ieee.org/static/interactive-the-top-programming-languages-2016) because comparing R and PHP doesn't make a whole lot of sense).
1) I've built literally hundreds of api's across 10's of apps for various large to very large organizations 2) I have not built more than a couple in an experimental proof of concepts setting in go. 3) In java i've used Spring, EE, Struts, boot and grails, Grails 4) Ultimately I decided that GO was not developed well enough yet for major business line development it's got some great ideas but the wealth of libraries and sheer support on the java side is staggering 5) Java hands down 6) Java runs on everything, it has every add on imaginable, it's got a million different support vectors, most problems you'll encounter are well solved. 7) If you're not using Grails or another more modern JVM language like scala or something you've got a lot of boiler plate and boring code to write... 8) there is currently no case for server side rest api development where i would even consider go over Java, go's simply not mature enough in that area, maybe in another 5 years but not now.
New frameworks come out all the time but that's not to say that the skills and know-how are not transferable. There's a reason why we are paid top dollars in the industry, so start acting like it.
Well, Hibernate is a love hate relationship for me. I'm so used to it that it almost seems like it's required for Java development (it's not!) One day Hibernate will save me many minutes of work. Another day it will cause me many minutes of headaches. SQL has its own set of issues.
one who wants things done efficiently? Maybe stateful? Maybe threaded? Maybe wants easy access to computer resources? Or just the insane amount of libraries the community has built for java? Or the security? Or maybe it's the longevity? HTML5 is a dream of bringing desktop applications on any platform. Guess what else did the same thing 20 years earlier? Right, Java! It had its failures and wins but it evolved, of course, and in time it has been proven that one needs a specialized GUI for whichever deployment environment you are in. There's a reason for why Facebook recommends you to use the Facebook android/iOS application instead of the mobile version. Also HTML + CSS is not much different from FXML + CSS which is used by JavaFX. Not to say JavaFX is perfect for anything GUI. If your team is decent at CSS, JS, HTML (and most people are) there's no reason to make them learn an enterprisey language such as java. Or if you simply don't care about the any of those things i enumerated in the first paragraph and just want to hack something really fast. Etc. 
We all hate you. Stop it. All you do is take the easy shit and fuck up everyone else's merges because you are touching 25% of the source files.
&gt; And you know, since you're arguing statistics, the value of the statistics presented cannot be zero. It must be some fraction above zero. Maybe you should measure it more accurately. Cheers ;) If you conduct a poll of everyone here and ask them what their favorite color is, and then from that statistic publish a report of what kind of car everyone drives... you have provided a statistic that is worse than useless. It's a misleading lie. 
If it's so easy, why isn't every one doing it as they commit? Why isn't the build set to _fail_ when any of it slips through? If it's unimportant shit, why isn't the compiler told to shut up forever about it in its flags? Warnings should be there for a reason, my IDE isn't a goddamn christmas tree, if something's wrong with my code I want to see it immediately, not lose it among a million other warnings nobody cared to fix because they were fucking lazy, while blaming it on having backlog issues to fulfill to make the clueless TPM stop breathing down their necks. 
What is it they call this in politics, "virtue signalling" I think? I'll keep that in mind the next time my boss acts like a hyperactive 3rd grader off his meds and tells me to implement the new pages in angular in 2 days (which we've never worked with before) and I end up having to quit a job of 8 years (along with half the department over the next 3 months). But you know, angular-angular-angular-angular-angular-angular-angular-angular.
"Building RESTful APIs" is pretty much what I do for my job. Most of them, by far, I've been doing in Spring Boot lately but I've been doing this stuff since SOA was the hottest stuff ever so I've used most flavors in between as well (SOAP APIs using Axis2, raw servlets, Java EE, Spring, Spring Boot, Vert.x). We have frequent workshops and hackathons at our company where we check out 'new stuff'. We've worked with Kotlin, a ton of Java microservice frameworks and also Go. Since Go has a lot of buzz surrounding it we did experiments with it building 'actual' real production API's. Basically what I (and most of my colleagues) concluded is that we really don't get the point of Go when it comes to actually building complex stuff with it. Just like with the hype that Node.js went through a while ago most people who are huge fans seem to only be building really simple stuff with it. But when you actually have to build real applications all the stuff that 'isn't there' is going to set you back a lot. So what isn't there? Go doesn't have exceptions; it relies on passing back multiple return values. So instead of being able to have an exception bubble up X layers you have to check and pass on error values in every layer in between. No generics. I really don't get this at all. It makes it a lot harder to write code that's reusable. No inheritance. People like shitting on OOP because it's cool to shit on AbstractBuilderFactoryImpls but that trope is old as hack. OOP is still a very efficient way to model software that quite easily lets you reduce complexity through code reuse. Last but not least; the ecosystem is not comparable at all to that of Java. It's decades behind and is never going to catch up. It doesn't matter how obscure your use case is; it's likely that there are multiple libraries doing it for you in maven central. So what is Go good for? Procedural stuff. Small utility binaries. I'm moving more and more of my shell scripts to Go. Go is a simple language. Simple languages work well for simple scripts. Not so simple for complex software. 
Which is exactly the point: optimisations like these have a huge impact. 
Inheritance is getting less important nowadays since you can achieve the same with interfaces using delegation and are more efficient doing so. Thats why there is no inheritance in go.
&gt; heritance is getting less important nowadays Source? Because it doesn't make any sense. You can't share behaviour through interfaces. &gt; Thats why there is no inheritance in go. But go doesn't have proper interfaces either. Also the reason Go doesn't have stuff like exceptions, inheritance and generics is because they wanted to keep the language extremely simple. They kept it so simple that it's really only suitable for simple tasks. Not for modelling complex software. 
sure you can share behaviour through interfaces nowadays. (Have a look at Java8 functional interfaces). What you can't do however is have any state in the interface which you can have in abstract classes which is exactly what makes them more expensive. If you access a variable of a super class in a subclass this is a rather expensive lookup while methods of superclasses are accessible as fast as the methods in the subclass. Therefore not having any state in superclasses is more efficient. I don't know much about Go but I'm pretty sure they provide a similar functionality.
It takes you 10 min. to create a deployable web application in Spring Boot. Want persistence? Add Spring Data. Want security? Add Spring Security. Want to monitor you application? Throw Spring Boot Actuator into the classpath. Java 8 may not be the best language around but it's good enough. Generics, Optionals, Lambdas and Streams make for some pretty concise and expressive code (in comparison to Java &lt; 8). Because of Dependency Injection, you basically get testable code for free (take this with a grain of salt ;)). Just my 2 cents. Disadvantages: * Java (but you can use a more modern language like Kotlin if you want) * huge artifact sizes * Spring's exceptions can give you some headaches, especially as a beginner
Wow, thanks.
I used SparkJava last year for an in-production application with RESTful interop to an AngularJS UI. The build time was 30 seconds including WebDriver tests, and it was in UAT after two weeks, for a company that was previously used to 18mo start to first launch times. I've just shipped a Jooby application (also Java8) with Vue.js and would use it again (35 sec build time, incl. WebDriver) I'd love to know Go better.
I assume it's all for embedded devices, but I'm amazed at how high Assembly rates on the list.
In Java I can't see how that would be true. I'd want to see a source before thinking it was significantly slower.
[I've asked this exact same question in the Golang subreddit](https://www.reddit.com/r/golang/comments/6ec82g/redditors_whove_built_secure_restful_apis_in_both/) and got only one response with the question itself getting a lot of downvotes. I wonder why?
I didn't know the IEEE ranking, thanks for the hint. At a first glance, it seems to produce quite a similar ranking as TIOBE, though, with the exception of a surprisingly high ranked R language.
You've just described Gartner.
nice article, nice implementation of showAllEndpoints 
&gt; Inheritance is getting less important nowadays What he means is, it is getting less popular. Interfaces/delegation/composition have all been available as long as inheritance has, people are just more into it nowadays. In 15 years, young programmers will rediscover inheritance and it will be cool again.
I strongly dislike the current trend where people just follow and/or quote others they perceive as "industry leaders" without critical thought. Just because Uncle Bob or Martin Fowler said something 10 years ago doesn't make it true in 100% of today's cases. Just because abusing inheritance just to reuse code is bad doesn't mean you should never ever use inheritance. The difference between inheritance is simply the difference between a "is a" and "has a" relationship. Fashion doesn't change this.
Is the Linux kernel complex enough for you? I think it makes perfect sense to build high performance close-to-metal stuff in a more 'low level' language. Both Docker and Kube have very different requirements than for example a REST application. And I think Go as a "better C" makes sense. 
The libraries and the echosystem is what makes jvm programming great. Java is an ok language. For a better experience use Kotlin or Scala and gain access to that great echosystem. Running on the jvm also gives you the advantage of a lot of Runtime debugging and profiling not available in the go Runtime embedded in to the go binary that you are running. 
I have one Go REST API in production and several Java REST APIs. Go was blast to work with but Spring gave me so much out of the box it really is hard to justify not using it for RESTFUL APIs. Java frameworks of choice: 1) Spring Boot 2) Spring Security 3) Spring Data 4) Spring Acutator 
If you use NetBeans it just works out of the box. NetBeans IDE has the philosophy of giving you a complete IDE without having to search around and install a bunch of plugins. Same for Maven support or anything else I have wanted to use.
Can't agree more.
If you plan on doing IOS programming I would learn Swift and not Objective C.
Well, since you mentioned iOS, why not give Swift a go? (Provided you own a Mac). They released a book series to teach you (https://www.reddit.com/r/apple/comments/6e99i3/apple_has_released_a_free_beginnerlevel_900page/). The WWDC sessions are always very informative and if you want tutorials, check out Ray Wenderlich (https://www.raywenderlich.com/) or Brian Advent (https://www.youtube.com/channel/UCysEngjfeIYapEER9K8aikw). Also Kotlin (https://kotlinlang.org/) might interest you, since you have a Java background. It has really nice language features IMO.
I code in the 3 Cs. Our data analysts are using R. iOS is a waste of time for mobile development. Look at the market penetration studies. They are fader below Android and just barely above Windows. Android development would be more profitable.
Both languages are supported but Swift is the future of iOS. Objective C will still be around for a while but people are slowly moving off of it. Since you don't know either Swift would be a better language to learn since that is the future.
Just because there are more Android devices it doesn't necessarily mean more money. A lot of Android users won't pay for apps. My iOS app sold 10:1 Apple/Android. Really depends on the app and your revenue model.
I will never understand people that work for free. Even prostitutes dont work for free. But to each their own. 
Interfaces in Java still can't contain state so "don't really have to use sub classes" is simply not true.
&gt; I have been coding in Java for about 4 years now and have a pretty solid grasp of the entire ecosystem I know it might seem like that, but I promise you have so much left to learn. Picking up another language in addition to Java is a great idea (I would push for C++, or Swift if you're really serious about getting into iOS dev) but don't stop learning Java because I promise that the amount of "ecosystem" out there is truly staggering.
Good point
More knowledge than me haha thanks! I'll definitely look into it. 
Obviously we would be aiming to make money, just makes it better that we enjoy doing it and can gain pretty valuable experience while doing it! 
Check out spring boot
wtf is vcs
Version control systems (VCS) https://en.wikipedia.org/wiki/Version_control
I want to learn more inspecting the code in medium to large proyects, or even small.
&gt; Even Lmao, of course they're working as prostitutes because they like to sleep with random strangers, and not because of shitty lives without any money.
That's actually a very good answer! It doesn't sound like anything that would simplify the code however, that's why I'm offering $1000 to anyone who could refactor that code and prove me wrong. How about the configuration classes? A lot of the configuration is shared in order to keep the API consistent, with a few specialized options for each individual parser. Basically one class extends the other to add more options. Composition here makes zero sense.
&gt; The difference between inheritance is simply the difference between &gt; a "is a" and "has a" relationship It's better to have something than to be something. You can change what you have, you can even mix and match and combine what you have. It is a lot more difficult to change what you are.
If you haven't used flask before it won't be any easier. 
it's fixed
&gt; How about the configuration classes? Same thing. Break up configuration into shared configuration and specialized configuration for each additional type. Pass common configuration to the parser class and common and specialized configuration to the implementations. new Parser(parserConfig, new CsvParserStrategy(parserConfig, csvConfig)) I don't see the benefit to inheritance for configuration. For example, Spring Boot [reads from a single configuration](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-typesafe-configuration-properties) file, but you specify multiple strategies for consuming the configuration for each module.
The Java solution would use Java Server Faces. 
That's a very bad and cluttered API, don't you think? In my case, a `CsvParserSettings` IS-A `ParserSettngs` which in turn IS-A `CommonParserSettings` and IS-A `CommonSettings`. There are 4 levels of inheritance here. That would not be a pain to refactor but a pain for users to use as they would have to provide one instance of each. All I care is that users of my API see that they need to provide a `CsvParserSettings` to a `CsvParser` and get on with their task. Using composition for this just for the sake of "purity" is not improving anything and making everyone's life harder.
Very nice elaborated comment! 👍
I would consider an abstract base class to be an abstraction and therefore the key point is not the reuse of methods through inheritance, but the implementation of varying little behaviours. So if you just implement the missing abstract methods and probably override ones to exchange the default behaviour, then everything is imho fine. If you start to use the *subtype* with an extended API as some sort of public API to client code, then the mess is starting to arise... With pure behaviour sharing through interfaces you simply cannot get into that trouble - but imho there is nothing wrong with abstract classes as well.
All test cases involved are testing functionality. Changing a library that is downloaded a million times a month for god-knows-who to break functionality used by others is not exactly the point of the exercise. I want to be proved wrong but for that I need to know that the basic functionality is still there and no corners are being cut.
As others already said - this index is a complete BS. VB is at the same level of popularity as c#? Microsoft folks say that in fact it's order of magnitude lower than C#. There are more examples like this. Also, fluctuations are just too big to be taken seriously. Redmonk and Pypl Index are more credible imho. At least they do not contain that many very suspicious figures.
I do not get the "cough scraps cough" thing. It is supposed to be an insult or something? That is a very surprising result and not at all reflective of what I have experianced. I think it important to note that the people who visit the website you found this on may not represent Java developers as a whole. In fact that warning is giving in the survey. &gt;Please take the findings in this report at face value, and use at your own risk. If we assume that there are around 9M Java developers in the world the sampling error is around 2.2%. But since the sample is not truly random, it can contain some biases. Although you will see that the respondents description seems quite representative of the industry. Still it got me curious since these things can be regional sometimes so I did some searches on a Job sites and Found IntelliJ might be more popular than NetBeans but is far behind Eclipse. Monster.com Eclipse = 245 NetBeans = 24 IntelliJ = 47 Indeed.com Eclipse = 3,594 NetBeans = 312 IntelliJ = 532 
You said IntelliJ was picking up the scraps, was just pointing out how wrong that statement was. You'll find many more polls favouring Eclipse and IntelliJ over Netbeans through google. (and not a single one favouring Netbeans)
Pick up a totally different langauge, like scheme, prolog or haskell. Or if you want to easily integrate it with your existing programs, scala.
&gt; So how does this contradict my comment? It doesn't. I'm all for changing internals to improve code quality or performance.
&gt; That's a very bad and cluttered API, don't you think? Not at all! There are two classes with two Ctor params each. Quite normal I would assume! Of course one should provide some sort of *factories* in order to make the common use cases more pleasent. But that's always a good thing for a public API, isn't it? And one should not have fear of using Ctor *injection*, as there exist strategies and frameworks for assistance. &gt; In my case, a CsvParserSettings IS-A ParserSettngs which in turn IS-A CommonParserSettings and IS-A CommonSettings. There are 4 levels of inheritance here. The question arises, *why* a ``CsvParserSetting`` must be *a* ``CommonSettings``? Obviously the *CSV* part is quite important and **adds** properties to the base class. So of course one could also consider both things as different types, that supplement with each other for achieving goals. If you trade both as complement types, you gain the flexibility to implement different configurations and combine them in a way, you as a library designer hasn't thought of! Further more you just pass what is needed to a specific class (assuming that the core components rely on composition as in /u/K60d56 example API). This is obviously a good thing. But I would agree with the fact, that it is not obviously a no go to use inheritance in this use case 😄 
&gt; high performance close-to-metal stuff The question above was about Docker. Quite the opposite of "high performance close-to-metal stuff"... A bug/lock-fest galore, if you wish. An absurdist piece of idiocy that sadly middle management sees as driver of "cost savings" and therefore mandates to use. Fucking crap-a-thon that is unable to free the space taken up by deleted file. Joke of a shit that happily tells you you have all host resources when in fact you are restricted to treacle of cpu fragment. An uber-disaster on higher cpu-count machines that spends 50% of time managing intra/container/process locks rather than doing any useful work. TL:DR; Docker is a promising technology, but has some maturity issues at the current stage. Not recommended for production use.
Java+Sparkjava is the best combo for something fast. Much less boilerplate than say spring boot. Further, Hibernate makes databasing ezcakes in a way Golang just can't yet. 
make jar not war
&gt; Source? Because it doesn't make any sense. You can't share &gt; behaviour through interfaces. You don't share behavior through interfaces. You *extend* behavior through interfaces. Composition and inheritance are similar in that you have a class with *overridable* behavior. With inheritance, the *overridable* behavior exists with all of the other class methods. With composition, the *overridable* behavior is exported from the class into an interface. The difference is that inheritance shares state between the shared code and the specialization code and ties them together. This have bad consequences for the specialization code, but it sure can be convenient. Composition doesn't share code and specialization code must adhere to a specific interface. This separation can be inconvenient, but it is a lot safer.
Very true. Objective C codebase will definitely be around for a good while.
Lmao
As broken as Docker can be sometimes you are being very innocent proclaiming "not recommended for production use" when it's very well used in production in a large multitude of successful companies. Hate it as much as you want (as I do having to work with its idiocies for the past couple of years, *in production*) but it's here, it's in production and I can say it has helped on a bunch of stuff too.
It works for the use case and keeps it to a single language. For a product I would agree though
Awesome! My end goal in a few years would be to be a full stack programmer, I've made a few websites already (with the help of bootstrap) but i am missing the analytics side! Python looks like it could be fun, good advice! Thanks!
Kind of an unrelated question, but which do you prefer to write in? Being Java or obj-C? 
It uses an annotation processor to effectively modify your java classes before the bye-, code representation is generated, something that they're not supposed to do (they're only supposed to allow the generation of new class files), and which may stop working in the future. I prefer Immutables as an alternative, for that reason and others.
Yay for Kotlin!
Between the two? Java. I really am not missing the opportunity to throw pointers around and corrupt memory, especially when I work with a lot of large systems that are Other People's Code. For the same reason, I'm preferring Swift for my newer iOS work.
I would recommend either Python or JavaScript. Both are going to be around for a long time and will help with finding interesting jobs. Python is only getting more popular with data science and machine learning and JavaScript opens up more frontend jobs and is expanding into everything. Plus, both have a lot of differences from Java which only helps.
[back-end roadMap for php/nodejs/python/ruby](https://camo.githubusercontent.com/a69353cebac96bd2e82b45771d6edd32715ca0c3/68747470733a2f2f692e696d6775722e636f6d2f6d3956385a69562e706e67)
What gives you this impression? IntelliJ seems to be #1, followed by Eclipse and Netbeans.
I explained this in an earlier comment, but I have changed the wording in my post. Hopefully that explanation is more clear.
I'd consider throwing jHipster into the mix as well. Basically angular + Spring Boot 
That's one (of the many) of the dangers of two apps accessing the same database. A REST API over a single database would be a bbetter solution, if possible. (Once I worked on an in-place rewrite of an app while keeping the same database. We sync'd the caches by each app invaliding the cache in the other. This was a temporary solution until the rewrite was complete. It wasn't so bad.)
If you suck at logic and are just looking for a quick buck, programming is not for you.
Others have suggested Spring Boot, which I personally think is awesome, but one thing to keep in mind that Spring Boot apps are deployed as JAR files with Tomcat inside. If you want to deploy to a Tomcat server, you will need to [convert](https://spring.io/guides/gs/convert-jar-to-war/) a Spring Boot app into a WAR file. If you have complex database requirements, including stored procedures, I would go with [JDBCTemplate](http://docs.spring.io/spring-framework/docs/current/spring-framework-reference/html/jdbc.html). Form submissions are [super easy](https://spring.io/guides/gs/handling-form-submission/) with Spring MVC and the Thymeleaf template engine.
I don't know if you're trolling, but JSF isn't the "Java solution", it is the "standard JavaEE solution". And you the beauty of Java is that you don't have to stick to "the standard" just because it is the standard.
I've spent not even a day with Kotlin and run in to loads of issues, particularly around ambiguous methods with libraries. If Kotlin wants to claim you can keep using your current stuff, they need to work out the java/Kotlin Interoperability way better than it is today. And wrapping top level methods in a class with no way (that I can see yet) to actually reference that class is straight absurdity and creates issues with normal patterns writing applications. There's also no way to actually command that class yourself. So a class in your file creates two classes at compile time, which creates more issues with things like manifests and whatever else. At least, this is my experience so far. Still lots of problems that need addressing. 
What do you want to do? I have a Java project that is an interpreter for the language Logo. You could write a music player (I've done that too), a web-server, anything to get practice. I know one guy that wrote an app to interface with a Roku. If you want to see other code, you can see what other people have on Github, fork, and then play with their code. There is no standard process, it's just something you (can) do for fun. If it's not fun, I wouldn't stick with it. I've been in the field for 14 years with a BS/MS. I've seen what happens when people don't enjoy programming. Github is nice because while git is complex, github makes it easier. (Assuming you are open to F/OSS.) It's not too late, but don't expect a magic bullet either. One book and one class does not a programmer make. As with any profession, it takes time.
This looks cool.
Why not? I would much rather write my buildscripts in an actual programming language than in weird, cryptic XML that calls out to totally opaque plugins that I don't understand in any way. With Gradle buildscripts being able to be written in Kotlin now instead of Groovy, it's even better, because Kotlin has great autocomplete + IDE support while Groovy has almost none.
Good tips, a few comments as there are inaccuracies or at least points that can be confusing on Maven's capabilities: &gt; 2. Build Everything from root! You should be doing this in Maven too mvn -am -pl project-to-build install &gt; 4. Name your tasks, give them a group and description! If you have a complex order to build a maven project your doing something wrong, it should be one command &gt; 5. Alias tasks, name them something you will remember! you can do this in maven too &gt;7. Use the Gradle Wrapper Maven has a wrapper too, but you should forget all that for either option and just use a docker image. 
I tried migrating over the weekend on a production project. The results were unit tests that fail for odd reasons like now hibernate having two ehcaches defined, and gradle intermittently failing to calculate dependencies. I might spend some more time trying to ge to the bottom of these issues, but in the mean time, the maven built still works. On the upset, the builds are quicker.
+1 For using Docker but the Wrapper is at least better than nothing.
Because that is widely used in the Java community, right?
This is true. But I've seen patterns emerge in Gradle usage and thus it gets pretty easy to navigate them if you're familiar with them, kinda like Maven. I know I have a much easier time getting around a build.gradle than a pom.xml. Again, having build scripts written in Kotlin so you can actually Cmd+B and Cmd+Option+F7 around in IntelliJ is going to be a huge plus for Gradle readability and clarity.
Give [JHipster](https://jhipster.github.io/) a look. It's a full-stack CRUD app generator based on Angular and Spring Boot.
Just don't, stick on maven. Maven is still better on long run. Everything that sounds good and so marketable in gradle will sound like the worst of nightmare story after a couple of month.
While learning: **to no extent** - you need to write your own programs, otherwise it completely defeats the purpose of **learning** and you're cheating. If you plan to go that route, you might as well drop the course. Later: it depends on the code license. Generally, using others code without in-depth understanding is a complete no-go.
It's better than the Wrapper because it fixes both JDK AND Maven versions whereas the Wrapper only fixes the Maven version.
That's a shitty reason. You don't have to ship the wrapper; it just makes it easier for new developers to build the project without installing Gradle. It's exactly the same with Maven; you have to install the tool before you can build the project.
I suspect the truth is most of us simply haven't used C#. You can find Java programmers who have tried a lot of other languages - Groovy, dynamic languages, javascript, typescript, a whole bunch of stuff. But there's little motivation to learn C# - I don't know which is better or worse, but I definitely think there's no way one is going to be better enough to be worth the cost (in time, learning, etc) to switch. Plus I learned Java in college. 
So they each have warts... but it's all about the plugins for me. Maven has amazing release and deploy plugins. If it's going in a maven repo or heading to a tomcat instance, maven hands down. Moreso if it's straight Java code or uses generated sources. There are so many great maven plugins. Plus the build times! Still faster than Gradle in my experience. Better IDE integration due to XML and the magic of dtd. Overall, a great choice most of the time. And then Gradle has first class wrapper (mvn wrapper is weak, let's be honest)... and tasks. If u have weird, it's probably easier to make a Gradle task running a shell script than using maven exec or something else. Not as cross platform for sure, but u can make a real monster. It also has some fantastic plugins and is Turing complete. If u need or want that, it's not half bad. IDE integration is... well, not great. But u can learn tricks and make it work really well with Intellij. Great plugins like Moowork's node surpass maven's equivalent in some ways. Can be use in polygot projects probably a bit easier than maven. First class copy with power of groovy. Lots of reasons to use it, but it will be a snowflake every time. Check this wonderful Gradle nonsense if ur into that kinda thing: https://github.com/themadweaz/weazbootgradle/blob/master/build.gradle tl;dr- learn both, evaluate strengths and weakness for each, use right tool. 
Definitely A
Don't use anything, you'll learn a lot more if you do everything yourself. When you're an actual programmer you can look for the right library on Github. :)
What's the point of taking the class if you don't want to bother with thinking and understanding on your own? 
Indeed, scrolling this [0] page the JDK/Maven versions could turn to be tricky to handle in some environment. Thank you. [0] https://maven.apache.org/docs/history.html
A bit /r/mildlyinfuriating how the Back-end path for "Java" has no explanation or further evolution whatsoever.
Cause it's not that popular in Web Development
Read up a bit on the reasons for the Gradle wrapper (and why you should use the Maven wrapper), it's really awesome and should definitely not be seen as something negative And even for Gradle, using the wrapper is optional
No, because Google wrote it and that's what the cool kids uses /s
In the DevOps, why is LXC not recommended? We use LXD+LXC and found it more "separated" than docker.
Harsh, but this man speaks the truth.
It might as well be an indication that you're doing something wrong: instead of looking for ways to split/simplify the main project, you're making the build script itself a project.
FYI: Apache pulls in the Oracle stuff still as a dependency, so legal wise, it doesn't change anything. Technically, it's just a wrapper API to make the Sun/Oracle one a little nicer. 
SSRS is not an option because of licensing. Considered BIRT but got lost in the weeds. There is not too much budget to invest in a full fledged tool so looking to build something, if makes sense. 
While the current app I have in mind is simple and can be fine in Flask, I could see it potentially be extended to invoke a legacy Java based application which I don't have the bandwidth to rewrite. So trying to keep the stack consistent. 
Thank you - so this template is used with Spring Boot or is that independent?
[No](https://w3techs.com/technologies/overview/programming_language/all) [Java is even more popular with the top 1000 sites](https://w3techs.com/technologies/topsite/programming_language)
Do you have any evidence to support this claim? There's nothing stopping you from entering a fake email address if that you're that paranoid.
I know a guy who uses NetBeans, a gal who uses IntelliJ and all the rest, dozens and dozens use Eclipse (except for the few doing .Net work in Visual Studio).
Free to ignore!
I will be messaging you on [**2017-06-02 00:05:33 UTC**](http://www.wolframalpha.com/input/?i=2017-06-02 00:05:33 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/java/comments/6el7xg/all_underscores_scala_books_are_free_and_open/dibfhzx) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/java/comments/6el7xg/all_underscores_scala_books_are_free_and_open/dibfhzx]%0A%0ARemindMe! 10 hours) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! dibfigb) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
JdbcTemplate is separate from Spring Boot - a part of the spring-jdbc module of the base Spring Framework. Spring Boot makes it available using the [spring-boot-starter-jdbc starter module](https://spring.io/guides/gs/relational-data-access/). The Spring Boot JDBC starter module makes it easy to [configure your data source](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-sql.html), and Spring Boot will configure JdbcTemplate correctly for your database when it detects the JDBC driver JAR for your database.
Is there a cloud based option somewhere that has pricing that makes sense? Truly, if a business offered me to make a reporting platform for 200 bucks an hour, I'd decline. Looka like pentaho is open source and quite popular. Not sure about licensing though. Looks like there's a version behind build on source forge. 
It's a recruiting device
Interesting list. I've recently written my own manual, scannerless, recursive descent parser for SQL without any tool. I found this to be much more straightforward. Here's some feedback by the two main maintainers of H2 on the subject (which also uses a hand-written recursive descent parsers): https://github.com/h2database/h2database/issues/484#issuecomment-290641025 Interesting link to the C parser, which also favours this approach: http://gcc.gnu.org/wiki/New_C_Parser Not everyone agrees, though: https://twitter.com/1ovthafew/status/735196845899669504
Cool! Thank you!
People who want to better themselves? People interested in challenges. Someone looking for a job at Google. Not you. 
Please read the sidebar.
Why post this here and not in, and I'm taking a wild guess here, /r/scala?
How about answering questions on Stack Overflow for that? People would: - better themselves - get some nifty challenges (especially to beat the masters in speed and quality) - improve their chances to find jobs at all other place than Google, possibly including Google
Thank you so much for posting this. I am very happy to read it as I am dealing with parsing documents at the moment.
It's a plugin, not native, and is not official and has some issues in my experience. Gradlew is built in.
&gt; Do Oracle and IBM etc hire people who just read and write papers like professors? Yes Oracle has Oracle Labs and IBM has IBM Research. Both of them are mainly staffed by people with PhDs who read and write papers and who would otherwise be in academia. They don't just read and write papers though - they also read and write code.
There's even a (hidden) command called "recruitme". It seems to give a permission error for me though. Edit: once you finish a few levels the "recruitme" command will work.
The python version is also set at 2. Both sides need some updating.
We intend to host the books on our own site, but we weren't able to get this ready in time to make an announcement at the conference we're at right now, the major conference in the Scala community. So we just made them free on the site we previously used to handle purchases. There is no way to turn off the email collection or the donation feature AFAIK. You can just enter a fake email if it bothers you, or you can build the books yourself from the Github repos.
**sidebar** -&gt; **/r/learnjava**
Hmm, not sure. Spend a day diving into the guides [here](https://spring.io/guides) - based on your requirements, I'd look at "Serving Web Content with Spring MVC" and "Accessing Data with JPA" in particular. If you can get those going and understand what's going on you'll be well on your way.
I generally like my parsers to output an AST in the form of a POJO-style data model. The closest Antlr equivalent to this is weird to say the least.
Since you're experienced, the best way to learn Java is to start coding in it. Create a simple blog in Java using basic servlet + JSP hosted in Tomcat + JDBC connection to some free database (Postgresql / H2). You will find issues along the way which you can Google around. The best thing about Java is that most questions already answered in StackOverflow. After you've done with it, go and read [Effective Java](https://www.amazon.com/Effective-Java-2nd-Joshua-Bloch/dp/0321356683) then refactor your project to follow the best practice mentioned in the book. After that you can try to learn more libraries / framework eg. create a new reporting system and communicate the blog with the reporting system through JMS. Adding dependency injection using Spring and many more. 
having used both for large projects, maven is much more mature and faster....50% faster in my benchmarks. Same code, same tests.
You should have no trouble picking it up. I recommend using something like JHipster to generate a starter application to review what best practices are around code organization. 
Spring has some really good guides. http://spring.io/guides 
What is logic?
The active runtime is the default: http://imgur.com/a/2EWSM Quick steps would be: 1) Create a new Plugin project 2) Specify RCP 4 3) Then export the project somewhere 4) Now check and you should see a runnable Eclipse binary in that exported folder. http://imgur.com/a/ZtrZl You will get a blank window. You will want to read and learn what you can do to populate what UI plugins you want to be run. Here's a great starter tutorial: http://www.vogella.com/tutorials/EclipseTargetPlatform/article.html PS There's a subreddit for Eclipse called /r/eclipse. 
JHipster is too overwhelming for new java developer 
Complaining sucks
Does that mean project valhalla is also delayed ? .......
But I want my classes to be immutable because it makes many things a lot simpler (safe sharing, better concurrency, simpler logic, etc.), so that is not an option. Builders let me build immutable objects with flexible configuration without the combinatorial explosion of constructors.
use the archive, it has better formatting than the emails, which require some sort of special viewer or something.
Pretty much to no-one's surprise. I hope that they will get to a consensus regarding the new Module system.
Absolutely, grab yourself a book, learn the language and get coding. If you're anything like me you'll find the hardest part is marketing the finished product. Just don't think you'll be good at coding overnight. It doesn't take much to get started but becoming good takes dedication.
Thank you bro! Do you recommend any book?
....I would say yes. However.... I remember when I was 15, and doing well learning the fundamentals, using Amiga Basic. I know for certain, Java is 100x more .....complex is not the word, but...I feel you need to go through the pain of procedural stuff, and build on it, to understand the power of Java, and to use it effectively. You're 15. Do you / have you played Minecraft?.... Getting into java writing pluggins to minecraft is probably the easiest way to get up and running, and feeling productive. 
good :)
&gt; Getting into java writing pluggins to minecraft is probably the easiest way to get up and running. It isn't the easiest way to learn java, but is the easiest way to give yourself ulcers while attempting to learn java. 
It's been a very long time since I learnt Java so I'm probably not the best person to ask. IIRC I originally learnt from "Java: How to Program by Dietel" but that's a very expensive book now. I can give you some pointers though... Avoid any 24 hours type books as they don't generally go into any detail. Any vaguely recent book will give you the basics but I'd try and get one that has been updated for Java 8, you don't want to be behind the technology curve from the outset. You'll probably want to read a bit about abstract data types (lists, maps, sets, etc) and algorithms, these are largely independent of the language you are learning and will give you a good grounding. Until you are comfortable with the language avoid network communication (e.g. the HTTP, web services, etc), it adds a layer of complexity you don't need at this stage. I say this because I guess your app will want to use network communication. Personal opinion time... learn to use and love an IDE (Intellij IDEA, Eclipse, NetBeans) from the start. Every programmer uses one you might as well reap the benefit from the start. Just make sure at some point you learn what's going on under the hood.
Definitely! You don't need a book to start off at first place. There are many good online tutorials out there. My advice to you is to start small and with an end in mind and work upward from there. Best of luck! 
I suppose, they meant `Sprint Boot` with out-of-box tools like `Spring Data`, `Tomcat`, `Spring DI` etc. 
Jigsaw was expected in Java ~~8~~ 7 and it's delayed, Valhalla is unplanned (no release date).
You join the list and receive mail. It's not that complicated.
The expert group talked through all the remaining issues in the past few weeks, as reflected here: http://openjdk.java.net/projects/jigsaw/spec/issues/ Looks like consensus was (mostly) achieved by clarifying the spec, adding one method to ModuleLayer.Controller and by postponing other features to a next release.
Thanks
I'm glad they still aren't allowing full on cyclic dependencies, though runtime cyclic dependencies pisses me off. 
I would have like to see a bit more analysis on the sb.append().append() vs sb.append() sb.append() you only save a n - 1 ALOAD_1 where n is the number of sb.append() the difference might be due to something else kicking in, the only way to check would be to look at the asm generated. There are some optimisation of concatenation that might be triggered in one case and not on the other. is the real reason there the inlining?
&gt; Why the release had to be delayed because they could not get Jigsaw accepted? AFAIK, the platfrom JSR referred to the jigsaw JSR. Since the jigsaw JSR was delayed, the platform JSR can not be pushed through.
Are you serious? You are applying for a job and asking for help on the interview assignment? A simple CRUD app is something a reasonably experienced Java developer should be able to pump out and seems like a pretty reasonable thing to ask for in an interview. I suspect by your reaction you may be in a bit over your head here.
Yeah, the answer can't be so simple. In fact the bytecode for append() has several load instructions. Possibly relevant, testEmailBufferChain() doesn't reference `this` and introduces no locals.
 the response of the author &gt;There was a similar request for .NET but for now we will not be able to expand any further technologies. The graph is already too much convoluted and it is becoming difficult to even read. So let's keep keep it to what we have (PHP, Node, Python and Ruby), till we figure out how to fit in everything. Thank you. 
To do an Android App you really don't need to know a lot of the Java language to build something funtional. Java is used to call the Android API where all the real magic happens. The real work in doing an Android app is figuring out the Android API not Java. That said do know all the Java basics like: basic data structures, objects, loops, if/switch statements, collections and generics. Also knowing the basics of Object Oriented programming will help too. 
[removed]
See my [post here](https://www.reddit.com/r/java/comments/6es3il/java_9_delayed_due_to_modularity_controversy/did9nrq/). I'm not sure that these were talked through with due consideration.
Should be posted in **/r/learnjava** where the **sidebar** has some resources - section **Free Tutorials** - that should get you started directly. In particular, the MOOC [**Object Oriented Programming with Java**](http://mooc.fi/english.html) is an excellent starting point. **Post removed**: Learning Java - for **/r/learnjava**
According to [Wikipedia](https://en.wikipedia.org/wiki/Java_Platform_Module_System), "Project Jigsaw was originally intended for Java 7 (2011)" ;)
JAXB is nice for many things. Generating SVG (or HTML, etc.) is not one of them, IMO. Seriously. What's so bad about generating XML manually? Because every `&lt;x&gt;` has to be paired with `&lt;/x&gt;` and that's duplication?
The guys over at Spring write some good code, especially Oliver Gierke (Spring Data). Play with that. Read some code, step through it in a debugger. Look at some open issues and try to fix them. Get feedback. Fix your fixes
Do you think coding needs a lot of practice to be perfect with the syntax and coming with algorithms ? 
XML is far more complex than just pairing tags - and you know that, right? Lots of trouble like reserved chars (I saw the author wrote a little helper function to escape those - incorrectly!), the right encoding and its info, properly handling of attribute character usage, ``CDATA`` sections and so on... really, I had trouble and pain enough because of somebody thought it was a good idea to craft xml by hand. As your main interest lies in SQL related stuff: Would you recommend the creation of SQL crafted by hand? If one knows how to write SQL he must just inject the dynamic parameters into the string he sends to the server... not a great idea as we know; SQL injection is ready to go... ok, you need an external library no matter how you use SQL, so that's a difference in the analogy. But the overall picture is clear I hope? 
Yep, shame I discovered Xtext after hand-writing most of what it does - model generation &amp; model -&gt; text translation.
Good article! However keep in mind that the application is based on the Docker way of handling secrets (obviously) so hardcoding the "/run/secrets" path in the Java code is not always an optimal solution.
Yep. I worked in 2009/2010 on a prototype plugin for rpm/rpmbuild that was gonna automatically compute java module dependencies between various packages much like what is done for perl or Python. At the time (shortly before Oracle acquisition of Sun) java 7 release date was considered imminent. Jigsaw was in a working state (for the scope that existed then) already, sun folks were finishing up some build tooling, then acquisition happened and all timelines were out the window.
.NET would work, but it's still mostly limited to Windows.
kind've a messy move though, can't find the documentation that was on java.net now, and the readme's still have links pointed at it.
it's git, fork it =/
OK, look. I know you're taking this extremely personal, given your past pains, and I would too. Really. But this is a thing the author wrote in a couple of hours. I know him personally. We discussed this idea years ago and he hacked up something brilliant in no time. In three days to be precise. Check this out: - https://github.com/Chrriis/RRDiagram/commits/master - https://github.com/Chrriis/RRDiagram/graphs/punch-card In three days and it has almost no bugs. Now of course, technically, you're right and you should definitely go create some PRs to make his work perfect (until the next person comes along and ignores all the nice work only to find one thing they really hate). You can add to that list of improvements: - Create a maven project (or Gradle, I don't care) - Change the license to something more reasonable - Don't hard-code colours (*HARD CODE* - geez!!) - OMG make the font configurable. I need Open Sans - Oh yes, and use an XML library. Or better: An SVG library - And abstract over those libraries to support also PNG, JavaFx, and what not. - Add a CoC to the project One more thing: I'm perfectly fine using plain JDBC in a small project if I have to write only 3-4 queries.
That's **incredibly** rude and wrong. OP's english is more than good enough to communicate his/her ideas. Your shit attitude is going to a unbelievably larger blocker to your career advancement than OP's English skills. 
Can you give some more details? How does it break your application? Do you have a stack trace you can share? 
If you are on twitter I would recommend tweeting [@michaelminella](https://twitter.com/michaelminella). I was at a conference with him just earlier this week and he mentioned how updating Java broke his demo project. I believe it was some sort of crypto or security thing, can't remember the specifics, but I think a good chance you both ran into the same issue. 
While I think there's benefit to learning things by hand, [spotify's docker maven plugin](https://github.com/spotify/docker-maven-plugin) makes things incredibly simple.
Oh, nice. I'm glad you found a solution. Is this an application you wrote / are writing? If so, is there any way you can bundle the MySQL jar with the application instead of relying on it being in the correct system directory?
So which site would be better for an intermediate java programmer ? 
You want to make a fat jar, using either Gradle or maven. I've had success with [this](https://github.com/johnrengelman/shadow), and I think there's a similar one for maven called shade or something like that.
I'm using NetBeans because it has a super easy to use swing GUI builder. I just use the clean and build function in NetBeans and get the jar from the dist folder in the project directory 
Maybe search for "netbeans fat jar" or "netbeans export application" then. I'm sure you'll find something. 
What is this concept called? I'd like to understand why debugging ports can be dangerous. 
Hmmm, honestly not really sure. Are you looking for tutorials or just learning new things? Are you programming professionally yet? Do you think you will be soon? Reading would be a good idea: * Effective Java by Joshua Bloch * Clean Code by Robert C. Martin * The Pragmatic Programmer by Andrew Hunt and David Thomas Attending meetup groups in your area and/or conferences if you can afford them. I have increasingly found twitter to be useful for keeping up on programming topics. Start following some people who talk a lot about software development on twitter (search hashtags to find people) add more people as you find them. It really is reading, reading, and more reading. If you start feeling like you have something to talk about, start blogging. If you feel even more confident, start speaking. I'd say those two are really effective as you, or at least I, don't want to look like a fool, so I do an enormous amount of research when ever I write a blog article or whenever I speak. 
Man I miss the original Java podcast with it's catchy theme. It's Java ... Java
Oh, I missed it!
Python sub is full of confused snake fans
My guess is that java is more cooperation driven and thus work related. Python is more used in hobby projects. 
Not as hip as ruby. Ruby is for real programmers.
Stay away from Rails though
The problem is that nothing really gets posted here so there's no reason to come here. We need more content.
Is reddit the "real world"?
There was an interesting article some time back about where certain software language communities tended to go and what looking at those websites might imply. For example, IIRC, if you looked at Reddit, you would think that Haskell was way more popular (at 27k readers, 40% of Java's reader size) than it really is. I believe Stack Overflow is where the JavaScript folks tended to hang out a lot. I'll see if I can dig up that article.
SSStttt... people here don't want to know that Pivotal even has such a thing and even worse... asks... MONEY.. for it! 
ahhh, IC... thx! 
No, the really really real programmers use butterflies!
We are open to suggestions if you have any.
If multi-threaded is "wrongly" implemented it's debatable whether it's still better or not, is it?
If anyone missed it there was a link buried in the article to the [minutes of a recent meeting](http://openjdk.java.net/projects/jigsaw/spec/minutes/2017-05-22) of the expert group which is quite helpful in clarifying some of this.
Yes. In my experience ORMs are great for 90% of stuff (the usual CRUD LoB applications) but for the other 10% you eventually want to do something they can't, or hit a performance issue (even just being able to understand what the ORM is running)
Consolidate the two learning subs into one because they're the same thing and there's no reason to have two.
And don't forget that is reddit used mostly by americans. 
I have an impression that /r/java community is a bunch of students and just-graduated developers. You won't find a lot of interesting articles here, most of them are shared on /r/programming instead. So it's not the python is more popular it is just the community of /r/java is weak.
NO the REAL OG programmers whisper in binary to the computer
'Github &amp; Ruby' as well.
A great deal of Java related things happen behind closed doors, at the types of larger companies that have more restrictive non-disclosure agreements. In contrast, a great deal of Python related things happen at the types of smaller companies that like to share anything and everything they can for more publicity. That's not to say that either Java or Python is better, only that online presence is a pretty bad metric.
&gt; Python is a more versatile language Python is less versatile than Java. Java is a full fledged general programming language. Python is quicker to learn. I think that is also why you see it in many more places and hear about it more on reddit. It is much more accessible to dilettantes. 
Don't you mean "corporation"? At my job we use java and despite the fact that app servers are bloated and sluggish to start, it's been a delight to code. Zero ambiguities, you can easily refactor code, and well, it actually depends on what framework you use. We use a friendly MVC framework here, so no JSF headaches. It's kinda stale, like a monolithic giant that doesn't need to move because it'll always be there. It's comfy.
JavaScript is not java Edit: oops!!! Yeah I fked up.
Well you are making my point more solid for me. Playing around with a scripting language is a lot more accessible to people playing around with programming, so Python is what they are going to play around with, instead of Java. &gt;but Python is a full blown Bash replacement if you want it to be Interesting opinion, someone on the Python subreddit advised me either to use Python 100% or not all instead of using Python to access *nix commands as they felt that was cumbersome. &gt;Java is 100% a object oriented language. You cannot write scripts with it. That is sort like telling someone they can't take their sports car on a bicycle path and claiming that a bicycle is a superior vehicle because of that. It is for bike paths and getting somewhere in a congested city quickly. It isn't for traveling across the state.
Learnjava and javahelp
Python is popular?
Still digging? 
Debugging is used to find defects in software (and hardware). A debugging port allows a debugger to connect to the software under test. A developer then can use the debugger to analyze the running software, pause its execution at certain points and may even issue commands that change the behavior of the software under test. A debugging port is a little bit like [drilling a hole in a living cow](http://wonderfulengineering.com/us-farmers-are-making-these-giant-holes-in-their-cows-the-reason-weird-yet-helpful/) to analyze its digestion [software under test] and to find new medicine for other cows. It's helpful but you have to know what you are doing. Exposing those cows with holes in their stomachs to predators is probably a bad idea. The same thing is true for debugging ports.
I believe it's taught more often in schools now because it's easier for beginners.
I'll point out that while java itself doesn't have a scripting component there are JVM based scripting languages that do everything python can do with the power of java. I'm sorry /u/angellus but there's just no world in which python is "more versatile" than java. That said python does have its uses... though meaningful whitespace is still a deal breaker for me. 
Not too long ago we mods wanted to do exactly that thing, but the communities on both subs were against it. Hence it stays as it is. My personal opinion would also favor joining the two subs, but that's not up to me to decide.
Java programmers have to spend all their time writing code since the language is so verbose, while us Python programmers have time to also post on Reddit all the time due to the time saved with our beautiful, elegant, concise language /s
Coming from the C++ world, I like having separate language general and learning subs. It feels cleaner to have a sub for conference talks and standards development material saparate from elementary learner posts like "how do I use a string?" Personal preference, I guess.
ouch ;)
Not all Java needs to be bloated either. There are plenty of lower level libraries that are simple to use and can be compared to node / python web dev. Unfortunately most people like the bloated frameworks for some reason.
/r/python has about 100,000 more subscribers than /r/java. 
I was *hoping* that Oracle would ram it through.
Why?
Have you *tried* Python?? It's glorious!
At my job (working for a DoD contractor), Reddit is blocked at work while SO is not. So all of my Reddit time is at home, when I'm not thinking about Java as much. Edit: just to clarify, I work at a DoD facility. I believe that things wouldn't be quite as strictly controlled if I worked at an actual company site.
Don't let the door hit you on the way out
The bloated framework gives you all the tools needed to do whatever it is you need to do. All in a similar design, and often their components build on more base components. So, you learn a thing and you pretty much know how to use the entire framework. Combining a lot of smaller libraries can be fine or can be a pain, depending what you need to do. Often, lessons learned from one library are not applicable to another. If you use them wrong, the overall application can be slower than if using the bloated library. Small libraries are fine, sometimes. Bloated frameworks are fine too.
My guess would be that Python developers are more likely to write Python in their spare time (and therefore post about it on Reddit) and Java developers are a lot less likely to write Java in their spare time. 
&gt; the PHP symfony framework is also said to have been inspired by Spring, so it must be really good. Has one major flaw though: PHP
That plugin is deprecated by Spotify. They recommend using [dockerfile-maven](https://github.com/spotify/dockerfile-maven) instead.
To be fair I used to think PHP was complete crap when I used it several years ago but looking at the newer versions it seems much much better than it used to be.
A decent job should let you have some energy left to be social in the evening.
I'd guess it's because Java has a steeper learning curve so is more off-putting for a casual amateur 
Java developers are too busy being employed? =) Seriously though, I'm not really sure.
From my perspective this looks like the main cause, C++ (the language I use) has big conferences and an open committee that produces lots of content for us to discuss. 
Sure, but I think in this particular case, there are other attributes of reddit users that are more relevant to the explanation why reddit doesn't really reflect the "real world" in terms of programming language popularity. E.g. I suspect age contributes significantly to a correlation.
/r/coffee has 157k subscribers!
Yeah, like in real life, and not on Reddit.
Its because while other languages are fighting over which is better, Java just sits back and absorbs any good features the platforms come up with.
Damn that's factual
Oracle can really do a lot of things to bring Java on parity with C#, but for some reason they aren't doing it. Java is really quite stagnating under Oracle (compared to how it was with Sun).
they don't seem to give a shit anymore. java is alive simply because there's too much invested in it, but i wonder for how long if they keep it this way.
[Because everyone and their dog can code Python](https://i.redd.it/8y807fc27h1z.png)
Java developers are usually more laid back and less likely to be given to aspects of loud vocalizations.
Have you tried setting up a proxy machine you can SSH tunnel to somewhere with Squid running on it? (Worked for me at the time...) But probably not the best idea.
Wow... a java library for replacing coverage with covfefe... 
1ST PLACE!!!
Nothing goes over your head, your experience is way too vast!
make a custom sub with those 3 
Why is this downvoted so much? People have no humor...
Traditionally J(2)EE has been the bloated framework, and spring the lightweight alternative that only requires a servlet container.
[Is Java more popular?](https://stackoverflow.com/questions/2560310/heavy-usage-of-python-at-google) How are we measuring popularity? Number of programmers? Number of popular programs? Number of users? Number of running instances? Which market/industry areas are we concerned about? The question you're asking is super vague so it's hard to really figure out if the answer we come up with actually addresses what you're really interested in. People are much more likely to create a Django, Zope, Flask, or Plesk website than one based on Java. Java is obviously more than just the web but in terms of getting more programmers in the mix, more people are going to care about building their own web sites. It's hard to say for sure without doing some sort of research but I'm willing to bet that the Java continuum is almost all professional programmers, some sysadmins, and very very few hobbyists. Python, being more accessible and more relevant to the things the average person is going to care about is likely to have a _huge_ "hobbyist" population, _many_ sysadmin, and a fair amount of professional programmers concentrating mainly on web development and/or SaaS-related companies. Given that distribution which one is "more popular" probably depends on exactly what you're interested in knowing. Python probably has more total people interested in learning the language but Java almost certainly employs many more professional programmers (even Google uses a lot of Java).
Is that what you hell out mid-coitus?
No, I yell after I finish. 
Do you have to clean each of the 80 submodules every time? Or just a few of them? And what is in these 80 gradle files that makes their compilation slow? Reading and parsing a small gradle file is not much more slow than doing so for xml. Compiling can be slow, but if your gradle files did not much else than declaring dependencies, that would not take a lot of compiler time either. If you can share any of the details, I could try to include in my benchmark.
&gt; Are Java coders less social? Yes. And employed. Hence, less time on reddit.
Maybe a newbie coder, but for an experienced engineer it is not bad. JHipster is a code generator, not a framework, so it actually spells out everything post-code-generation. I found it very helpful when digging into Spring Boot and AngularJS. 
Did you delete your "meme"? lol
why is this a thing?
But shit like hibernate and lombok is amazing
Nor people who are still trying to figure out the geographical mysteries of "Krakatoa, East of Java", it seems. 
But why would I want to talk to random people about work stuff I can't talk about? 
Are you really advocating that someone working for a **DOD CONTRACTOR** create ssh/squid tunnels intended to subvert their work policies? That sounds like promoting potentially-felonious behavior with national security implications. They shouldn't do that, and you shouldn't promote it. Federal information security provisions are nothing to mess with (as the current administration is starting to realize). 
lol … the impression that Java is a difficult language to learn amazes me. I use it all the time, but it's also been taught in schools as the first language for many years because it is rather accessible. We used C++ before that, and it was easy to learn. We occasionally dabbled with Lisp, and it was also easy to learn. We used C before that, and it was also easy to learn. Where is the difficulty in trying out new languages? 
Was about to say something similar. I assume most of the Java crowd is older and more of the 'dark matter' type, i.e 'get the pay check, do other things with life, keep the coding at work' type.
You don't need a servlet container, it's just legacy baggage. Try Play: https://www.playframework.com/download#starters
It's Machiavellian. The same phenomenon is seen to occur in carpentry, where the master carpenter wants to get the eager apprentice to buzz off, so he gives him a rubber hammer with two claws on each side, and tells him to go bang nails into scrap wood. Everyone gets a hearty laugh seeing it happen. Same with R and Datascience. Get a bunch of dummies to go use a retarded tool, they don't increase their skill to become competition. After everyone becomes proficient in R, Chef and Pig, the languages will be changed to Erlang, Swift, Coffeescript, and JPerython (a mix of java, perl, and python). Hurry up and learn that before I flip you again.
That's fucking awful. 
Hahahahahahahaaa. No. 
I suspect it's timing. Java is slightly older and its communities are entrenched elsewhere, often organized around particular runtime frameworks or tools.
JavacParser is open source.
Ouch! Workin' on the high side!
Me personally, I tried to learn Java but had a hell of a time. I them gave up and tried Python and now have written like 4 it 5 usable programs in a little over a month. 
Same here, I do freelancing and mostly develop flask and django (and even did a few tkinter GUI projects). I'm interested in Java only for the so-called performance benefits is supposed to have, but the back end is so heavily stacked in layers these days that I don't think Java's raw performance benefits would matter much there. If such were the case, FB, Wikipedia and reddit would have chosen Java instead of php/python. The other thing I use Java for is for writing Android apps. This (core Java) is one are where Java really shines and learning is worth it. The other webdev part of java has a too steep learning curve tbh to be much useful (especially when options like flask and django are available).
https://github.com/javaparser/javaparser Not familiar with JavacParser, is this what you meant? Edit: Oh, I see what you mean now.
&gt;The parser maps a token sequence into an abstract syntax tree. It operates by recursive descent, with code derived systematically from an LL(1) grammar. Am I correct in then saying that the Java compiler uses LL(1) to parse Java source code?
The [OpenJDK implementation](http://hg.openjdk.java.net/jdk9/jdk9/langtools/file/16febc896c36/src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java) appears to use a recursive descent parser: /** The parser maps a token sequence into an abstract syntax * tree. It operates by recursive descent, with code derived * systematically from an LL(1) grammar. For efficiency reasons, an * operator precedence scheme is used for parsing binary operation * expressions.
&gt; Java is really quite stagnating under Oracle (compared to how it was with Sun). Yeah, who needs fucking lambdas or stream API that we finally got under Oracle's stewardship. /s
I think this is one of the main reasons. 
It took me a while to fully understood java's generics, reflection, and it's whole gc flow etc 
I think its the enforced OOP. That's a tough concept when just beginning. Starting out with Python doesn't require much beyond learning syntax. I don't know if that's a good thing or not.
Many librairies use native code and off heap memory. And some tools are done for that, like Cassandra for example that will by default use very much more off heap than heap memory.
&gt; the help questions should be combined or even combined all into /r/java. And that's exactly what the communities *don't want*. /r/Java should stay clean of help/learning posts according to the vast majority of the community. 
[It just crossed my mind when I saw it here](https://www.reddit.com/r/shittyprogramming/comments/6f2rut/when_your_teacher_hasnt_taught_you_divisions/)
Especially doors slamming on my ass on the way out!
[The character](https://www.google.fr/search?q=command+key), or [the key itself](https://www.apple.com/shop/product/MLA22LL/A/magic-keyboard-us-english)?
LL(1) is a property of a grammar. This limits what kind of parsing algorithms you can use, because not every parsing algorithm can be used for every kind of grammar, if I recall my compiler class correctly. So it doesn't "use" LL(1), because LL(1) is not an algorithm that can be "used" but I may just have fallen into a semantics trap right now. 
No, it means that he Java Grammar falls into the class of LL(1) grammars and that any algorithm that works for such grammars might be used. LL(1) is a sub-type is context-free grammars. Its means you need only one token lookahead to make a decision, since its unambiguos and not left-recursive.
Take a look at [this](https://gallery.technet.microsoft.com/scriptcenter/Use-Powershell-to-cleanup-fc80c443) Basically just copy-paste it to your powershell
The current edition of Effective Java is 9 years old...how relevant is it today?
Are you aware that some of our knowledge of digestion occurred because this hole in the side happened to a human, [Alexis St. Martin](https://en.wikipedia.org/wiki/Alexis_St._Martin)?
Hi /u/Cilph, sorry about the necromancy. I followed your advice and re-wrote everything to Kotlin, but I'm having a lot of trouble with @FunctionalInterfaces * Tried to convert them to typealias, but that requires a return value (Unit) when called from Java, rendering them useless * Tried to keep them as java-interfaces. Works well in Java, but type-information is lost when trying to call them from Kotlin, rendering them useless. Currently I've managed to port everything except the main class and the functional interfaces:https://github.com/tipsy/javalin/pull/11 Any tips?
There are definitely some issues between Java and Kotlin when it comes to @FunctionalInterfaces (SAM, Single Abstract Method). I haven't touched this with the new 1.1 yet. What I used to do was take the small syntactic penalty of explicitly converting a lambda to an object. I think by putting an invoke operator in a companion object. I think this still leaves you with a FunctionalInterface from the Java side. Maybe you could even overload methods to support both typealias or functionalinterface? &gt; Tried to keep them as java-interfaces. Works well in Java, but type-information is lost when trying to call them from Kotlin, rendering them useless. What do you mean by this?
&gt; What I used to do was take the small syntactic penalty of explicitly converting a lambda to an object. I think by putting an invoke operator in a companion object. Any examples of this anywhere? &gt; Maybe you could even overload methods to support both typealias or functionalinterface? That would lead to a more confusing library for the people trying to use it (as opposed to just keeping it as Java) &gt; What do you mean by this? If I declare my function as: fun get(path: String, handler: Handler): Javalin { ... } where Handler is a Java @FunctionalInterface, I get: Type mismatch. Required: Handler Found: (???, ???) → [ERROR : ] Cannot infer a type for this parameter. Please specify it explicit when trying to call it from Kotlin
 package test interface HttpHandler { companion object { operator fun invoke(handler: (req: HttpRequest) -&gt; Unit): HttpHandler { return object : HttpHandler { override fun handle(req: HttpRequest) = handler(req) } } } fun handle(req: HttpRequest): Unit } gives a SAM in Java public class MainJava { public static void main(String[] args) { Server.INSTANCE.registerHandler((req) -&gt; System.out.println("Test")); } } and in Kotlin it gets slightly uglier. fun main(args: Array&lt;String&gt;) { Server.registerHandler(HttpHandler { System.out.println("Test") }) } I'm investigating your Type mismatch issue though. I thought Kotlin handled SAMs well in that direction, as long as handler is a Java class.
Yeah I have no idea why SAM isn't working when defined in Java and used in Kotlin. Probably has a cause in Kotlin compiling for Java 6. It's a known issue I think, but I'm not sure if they're gonna fix that.
I'll give it some time and see if I can find a solution, but I don't really mind having one class and a few interfaces in Java :)
Yeah letting one hit you like that would be an inexperienced rookie move
I wrote a thing :-) https://developer.lightbend.com/guides/play-rest-api/
Zing
Oracle Certified Associate for Java, its a Java certificate from Oracle.
Oh. Somebody still bothers with certs these days? Astonishing!
&gt; so no JSF headaches Which ones?
You mean May is realising that?
Link requires registration. This must stop at some point...
Yep, that was me... does /r/java auto-ban new commenters or something?
Not sure 
Good to see an overview of jBPM. Did you by any chance look at any of the other Java BPM offerings out there too? We're about to evaluate a number of them, and would be great to hear if you have any feedback. I'm surprised more isn't written about them - given how complex a lot of business processes are, I believe they're a very valuable resource for developers to be across.
TIL, thank you for the tips. 
This is messy by design, because what is JavaEE? A set specifications and their reference implementations. These specs can be (and are) implemented by different parties, under different license etc. Documentation is in JSRs, and there is this official JavaEE tutorial on the web.
Eclipse is a fine IDE, but I recommend IntelliJ. The same company also make a fantastic Python IDE called PyCharm.
Not sure why people are downvoting you, it was helpful. Anyway I sent a message to the moderators but haven't heard anything back.
Well you're definitely not shadow banned, your comment probably got removed from auto moderator or something 
Congratulations, you snuck in at the last minute but you just won the Asshole of the Week award.
It looks like if you purchase it through the Docker store, you are acquiring a license to use Oracle JRE. I don't know what the limitations on the license are, like if it is unlimited use, or just one per virtual machine? There is nothing wrong with just using OpenJDK unless you need more advanced encryption, more control over JVM optimizations, or tools like Flight Controller or Advanced Management Console.
Maybe, but they sure don't matter for their Western customers. 
Was there ever a problem with Docker and Java? Most organizations would create Docker images internally and use them to run their own systems. So I don't see why there is a problem for that.
What made you go for Activiti? Did you consider Flowable or jBPM too? As it stands we're probably going to be performing a brief evaluation of all three.
why so?
Yes there was, because we're not just talking about using images internally. We're talking about *redistributing* them. 
Is there actually a reason not to use the official OpenJDK distribution?
SQL is the 4th language I learned to use, a good 20 years ago, and I feel quite comfortable with it. I see no reason to use proxies.
Nice! That's cool that you work for Lightbend. I just glanced over it, and it looks good. I'll have to wait till after work tonight to take an in depth look. Are you interested in feedback as I go?
I'd like to hear what you think about my attempt to fix vulnerable dependencies when updating them is not feasible. I grew a bit tired of all those blogs telling me to simply update my dependencies as a result to OWASP Dependency Check saying that they are vulnerable. In larger projects, updating dependencies is a lot of work and newer versions may also have new vulnerabilities due to the fact that many libraries don't separate updates from upgrades. Because of this (and also because i wanted to try bytecode manipulation), I've created a toolset to integrate fixes into external dependencies. Please tell me what you think about that approach. I am not sure about some aspects, such as: - code readabilty (this is my first OSS project and people generally don't care much about my code at my company) - is this a proper tool to fix vulnerabilities, or does it open up new problems - what about modifying dependencies that have restricting licenses 
Thanks, friend!
Perhaps now you can enjoy your camping trip.
Heh. Definitely is a Monday.
Ur username
Got it. thanks
I do get your point. This approach shouldn't be used when there are better approaches. However, i don't think that forking the vulnerable library is somehow better because: - you still have to inject your forked library - when updating, you have to check whether your fix is still relevant. If that is the case, you'd have to create another fork - It's easier to lose track of your changes With this approach: - The injection is applied automatically - Updating the library should be no problem - Every change is documented 
You aren't asking for help. You're asking for someone to do the work for you
Frankly you deserve to fail for posting this. Go speak to your teacher and explain the situation if there are actual mitigating circumstances, otherwise fail, chalk up the experience, and move on.
Do something worthwhile and **learn**: MOOC [Object Oriented Programming with Java](http://mooc.fi/english.html). We're not going to support you in your self inflicted misery. **Post removed:** do my work, programming help
Good article. One point I'd add is to avoid string concatenation, especially outside of a "isXXXEnabled()" check. Many people naively do the following: log.debug("Unable to retrieve user for id " + userId); Most logging packages offer a substitution syntax, e.g. for logback it's: log.debug("Unable to retrieve user for id {}", userId); This avoids unnecessary string concatenation which can be resource-intensive at scale.
i've been re-reading this guide every few months and enjoy it a lot. def. recommend.
As this is not an official statement from Oracle, it has no value. If you bring this article during a licence audit, they'll just laugh !
If you want pointers for actually looking into the javac source code PM me, I'm familiar with it throughout and wouldn't mind sharing what I know to help get you started
Look into the Java Debug Interface, afaik it's how most debuggers work https://docs.oracle.com/javase/7/docs/jdk/api/jpda/jdi/
I'm not sure I agree. I've seen this take down prod servers, though, as I mentioned it was at significant volume (approx 600 log operations per second at warn)
What app server? I know part of the daily dev routine was to start up your server and go for bootup break when on Websphere. Wildfly and JBoss start up in around 5 seconds on my decade old laptop though. But yeah, I've been playing with all the rest and the spring boot and this and that and the monolithic ones are just so much nicer to me. Maybe I just need better deploy set up. 
Inherited code base. Was great to work with. Like I said the only downside was at the time no workflow GUI for Intellij, but a quick google search finds some promising results, but I have not tried them myself.
hey just in case you haven't gotten the message yet that comment was a reference to your username, hope that helps
It definitely depends on what you are building. When building a cloud web-app style project designed to scale to multiple users or even adopted for clients, CTO's should be jumping into the micro-services architecture model bandwagon, where there are numerous and distinct smaller API's instead of one monolithic codebase. There are no frameworks to support this kind of model, but you can include frameworks in any or all parts of it, depending on where their use is appropriate.
IMO it still lacks some things. It's really useful, but source code dependencies (like in-project module-to-module dependencies) sometimes can be glitchy. Just speaking from personal experience though. IJ and the plugin doesn't leave much room to complain for the most part though
No problem, good luck this week! Make sure you read the last chapter about the interview process itself, it will hopefully remove some nervousness that a lot of people get.
meat jello
AOP can be useful for decoupling cross cutting concerns such as transaction management and logging from your business logic (within reason) but this feels like using AOP for monkey patching when there are other better alternatives.
I will definitely read this one, but I am feeling like this is some kind of cheating. Nevertheless thanks for your effort. BTW: the logo is eyecatching, I like it. 
Well this isn't too surprising, until now almost every Java image on Docker Hub was built from OpenJDK. With Docker going mainstream that's a train Oracle couldn't avoid boarding...
I wouldn't consider it cheating to prepare for an interview, its more like being well prepared for an exam. One thing I stress in the book is that memorizing answers isn't going to win anyone over, its far more valuable to be able to explain things in your own words because it proves you understand the concepts. 
My pleasure
You're welcome! I am also Italian haha
But the concatenation happens happens before the logger is involved so async can't help anything even if it could.
What issue are you having with that approach?
Why are you posting this in a **Java** subreddit?
Questions like these are more suitable for /r/javahelp as mentioned in the sidebar however even there no one is going to do your homework for you. You not being able to do this and postponing this until it's due in only a day is your own fault. The only correct course of action is to discuss this with your teacher. If we're going to just give you the solution you will only fall behind even farther. In general teachers respect people who fess up and want to work hard to catch up. P.s. writing in call caps = shouting = rude. 
I Was thinking more like primitiveish (int, float, char, double, String is a class) members/fields*/instance variables (variables declared inside the class but not in a method) for their Card class. (paraphrase info for all readers benefit) *forgot fields, any more names for that? 
Since this is help with Java **programming**, it should be, as the *plenty hints* on the page indicate, posted in **/r/javahelp**. Please be sure to **read** and **follow** the [**Posting Guidelines**](https://redd.it/48eykt) there. My hint would be to make a `Card` class that stores the color and values as fields and then a `Deck` (which uses an `ArrayList`) to store all cards in the Uno deck. Last, you will need a `Hand` class (that again uses an `ArrayList`) for each `Player` (another class) that stores the cards on hand. You will also need the `DiscardPile` (probably a `Stack` would be suitable here) where the cards are disposed. Since this is due tomorrow you won't stand much of a chance of finishing the task. **Post removed**: Programming help
&gt; This is not as resource-intensive as you probably expect. A typical service creates a LOT of logs and this also creates a lot of objects that then need to be garbage collected. So you definitely want to avoid concatenations on logs that might be disabled (info and lower). 
This guy fucks!
JSF also works pretty much same i.e. https://www.primefaces.org/showcase/ui/ajax/event.xhtml 
&gt; You just click somewhere sometimes on the diagram and that changes something invisible in the underlying xml. Happens to me all the time, and messes all connections (arrows). Infuriating. &gt; Database stores everything as string if I remember correctly. Actually the column type depends on the Java type of the variable. The real problem is that each variable in each process instance has its own row. It's search-friendly, but obviously doesn't scale wrt number of active instances and declared variables. In other engines the whole process context is stored as blob, and only a subset of vars can be marked as available for search to be stored outside of the blob. &gt; Forget about​ unit tests. Or at least we couldn't find anything more than ways to make integration tests. I'd say the opposite, the ease of writing tests might probably be the only benefit of embeddable engines, b/c each step in the workflow is a Java class with a well-defined interface.
Why not use a Javascript framework for the front end (like angular or something), and then use JSP / AJAX calls to pull in the data? 
I've worked with both technologies, both are right. but since you say you don't know anything about JSF, if I were you I would go for Typescript/React. On the other hand, if you don't mind to learn a new thing, go for JSF with Primefaces (for example). JSF is not bad for this kind of applications like CRUD ones.
In REST, you usually have an endpoint that accepts a payload (usually JSON, but XML is also common) - request parameters are uncommon. jQuery can [serialize](https://api.jquery.com/serialize/) an HTML form to a JSON object. So you can build an HTML form as you normally would, then send and receive data via XHR. In MVC, your controller takes that payload, fills a model (after applying some business logic) and returns the view (in this case, an HTML snippet but not the whole site). This snippet can contain the above HTML form (if you want) too. So for example if you have a functionality where you add new items to a list, your controller can return the previous list and one more empty item upon, upon adding - keeping ALL the logic server side. Whatever response the client gets, it will be an HTML snippet, so a simple $(element).replace(response) will be enough in your AJAX callback.
[removed]
For me the choice comes down to the amount of "single page" functionality that is required by the app. This probably also depends on how you want to structure your app. Simplified example: Imagine a table of users with an Edit button. 1. Does the edit button expand the chosen cell with editable fields using a PUT ajax request with rest api? 2. Does the edit button direct you to a "User edit view" using post-back style? I have often found that the requirements often go towards more "single page" functionality where using a front-end framework with a rest-api is better suited than for example JSF and post-back.
If you are using ELK, you will find JSON is easier to consume and search.
In my experience, JSF can get too complicated at times, and the learning curve is a drag. Using a REST approach, even with plain JQuery is much simpler. EDIT: and you can control every part of the logic for any modifications. JSF tends to take control of everything with its component based approach, and doing apparently simple things requires you to jump through hoops at times. It's not your grandpa's MVC, and you need to relearn a lot of concepts because action based MVC and component based MVC are entirely different beasts. Other alternatives are using Spring MVC, it's a delight to work with, and you might be able to reuse some of the JSPs as the views. OR mix Spring MVC with thymeleaf templates, which is an approach that many people use and recommend. 
So you admit that the criticisms are warranted then?
And if I use text then support won't need ELK or other software to read the logs. Any text editor like notepad would do. Right? We can't tell clients they need to install additional software on their servers just to be able to read log files.
SQL mixed with JSPs? Ouch! That's a big no-no in my book. Separating data access from business logic should be, IMHO, your first and most important goal. If you have a lot of SQL, I've used Spring's JDBC lib, you could move all your SQL, untouched, to data access beans to clean up the back end. With Spring MVC, you can move the complicated logic to the controllers, while the models will deal with the data handling. As an advantage, you won't need to rewrite all the SQLs, you can leave that part for later. One thing's sure: You need to rewrite the back end, and the model tends to remain the same no matter what frontend technology you use. As a Spring fan, I say you could try remaking ONE module of your app to Spring MVC, moving all the SQL from the JSPs to one model or data access class, whose methods you can invoke from the controller. With the controller you'd just need to write the get and post part, leaving the JSPs as mere views. From then, rewrite all other modules incrementally until you've finished rewriting the back end. 
&gt; leaves no room for less experienced frontend engineers LOL I've made several complicated webapps using JSF and I know basically zero actual javascript. The power of JSF and Primefaces with all the AJAX is great.
Depend what you want to achieve with this rewrite. If you want to make your application more modern and prepare it for future use outside of organization (say some parts of it would be used by your partners or even a public API), then the obvious way to go is RESTful API with React/Angular/Vue frontend. What you might want to consider is the fact that you're not locked into React or Angular 1.x, you can pick something simpler, like Vue.js - if it suits you. However you should know that adding features to REST API + SPA type of app is actually exactly double the work compared to JSF or whatever and at times its a huge pita. If this application will stay internal, I'd rewrite it in anything that would yield results fast. And from business perspective, its actually easier to maintain JSF-based app because you don't need dedicated frontend developers for it. TL;DR: Writing REST API + SPA is not easier, its an investment into architecture of your application, also its not easier to do features for it. 
You might be better off using the browser's dev tools to look it up as needed.
Yes, it's essentially an internal application. We are currently starting a new project to extend the application and will be using the new tech only for that part. For now, we don't plan on rewriting any existing JSPs with this new technology Thanks for your perspective on REST + SPA being double the work. I would hope that I can abstract away a lot of the CRUD stuff into some declarative-style DSL or something, and "just" invest time into the custom parts.
&gt; SQL mixed with JSPs? Ouch! That's a big no-no in my book. Separating data access from business logic should be, IMHO, your first and most important goal. &gt; Tell me about it... Unfortunately, we currently don't have the capacity to rewrite the backend. We are extending our existing existing application with new modules, which is where we want to use proper separation of data access and business logic. As for Spring JDBC, I'm assuming you're talking about this here: http://docs.spring.io/spring-framework/docs/current/spring-framework-reference/html/jdbc.html According to the table, Spring opens the connection, which might be a problem: The core of the system expects that a specific connection for the current transaction is being passed around and is used for many things throughout the system, this is used for ID generation for example.
Java is far from the 'best' language out there. But it's ecosystem is hard to beat. I would not mind at all if the company I'm contracted out to would let us build services in Kotlin though. 
I have frontend experience, the rest of the team not so much. As for JSF with Primefaces: I have only experiment with plain JSF so far, but will give Primefaces a go. My worry with JSF is that there's more magic involved and I don't know when I will hit the constraints that the JSF components impose and how I would extend/adapt to that.
log4j2 also supports using a lambda to log in cases where you need to concatenate (or use the result of a method call). At the very least this means the logging framework checks the log level first and THEN executes the lambda (which handles the concatenation or method call). +1 for the substitution/format version though. If you're not dependent on a method call this is simplest.
How does that negate what I am saying? You're a backend engineer. You have enough experience to handle JSF fairly easily. But someone who primarily works in frontend and who suddenly has to work with JSF won't have such an easy time.
Well, to mention FB, they were originally using PHP, but they got a lot of daily traffic, then noticed that they were unable to scale like they needed, so if I'm correct, they built a special tool to convert over to C/C++, so that they could add in the functionality to scale when needed... But that's what I like about Java, it runs on app servers that are built to scale your application... Though, I've never really enjoyed data source connection pools...
Well, I know every time I install the jdk on a new computer, it constantly reminds me that Java is everywhere! It brags about being on over a billion devices. But that's the upside I wanted to capture. Java is more popular than a lot of people imagine, due to it's portability. But it's community is mostly older programmers who came from main frame or other areas. Still, I've worked with more Java than anything else (besides C in *nix)... It does everything I need, and I can't complain. That, and Python pisses me off with its indentations... Especially if you mix tabs with spaces...
So, you think Spring wouldn't work in that case or we'd have to adapt our existing system heavily? 
Hmm, I haven't given Angular any thought yet. I don't know why, but I've heard about it of course. How boilerplate heavy is angular (4)?
I've read through it - never read all of it, but I can definitely say it's far from being complete or comprehensive. It's fine as a basic reference, but once you get into it more seriously you find that many details are missing or are misrepresented. 
What makes picocli better than: * http://jcommander.org/ * http://commons.apache.org/proper/commons-cli/ * ... the many others already out there? Not being critical, I'm actually curious! 
The JavaFX SceneBuilder has a little-known feature for analyzing CSS. I find that many times it's easier, or at least faster, to use it as a sort of "reference". Use View-&gt;Show CSS Analyzer to bring it up, then select the component to view its stylable path, style classes etc. (similar to the Chrome developer console element-selection). 
JavaFX isn't a "web" technology - it doesn't run inside a browser (barring WebStart/JNLP, but that just runs a JVM from the browser). 
There are some people saying that JSF is not a good fit for doing "singe page" apps but I know that is not true. JSF, especially when used with something like PrimeFaces, makes it very easy to build SPAs without having to deal with a separate front-end scripting language. The ability to to partial page updates and submits is very easy. I've only done a little bit of work with Angular before but my general impression is that working with JSF is at a higher level. So initially you can build a page that does a full postback and then later on add partial updates and dialogs etc to make your page closer to an SPA in bits and pieces.
That's how we do it also. JavaFX documentation is pretty non existant, the Oracle CSS guide is a good reference but far from comprehensive. You have to roll up your sleeves and get dirty. Use 3rd party tools like scene builder and check the source code of the JavaFX controls to understand how to use and tweak them. You will often see in the source code that the CSS property you try to use will never work as it should because something is hard coded in the control and not documented (some components minimum size for example). Edit:typo
I suggest you read Effective Java to learn why immutable objects are desirable.
It all depends on how exactly you manage the connections. I think the Spring DataSource class allows you to set connections, maybe you can configure it to use whatever connection your application is using, instead of creating a new one from scratch. Yeah, you know? That might just work! DataSource DOES have a setConnection(javax.sql.connection) method, so on initialization, you just set the connection object, and voila! And if you handle the transactions using your application's routines, just don't add any transactional annotations and you'll do fine. In any case, if it turns out that Spring happens to be incompatible with how your app handles the SQL connections (which I sincerely doubt; maybe it'll take some tweaking, but I don't think it'll be impossible), you can still use them the old way without using Spring's jdbc classes altogether, but with the advantage of having Spring's dependency injection facilities. Anyway. The thing is, Spring or not, you do need to move the SQL to separate classes, that's the Crux of the matter. Trust me on this, it'll make your life much easier. Edit: So here's my plan: 1) Add the spring dependencies to your project. 2) create one or more spring "repository" classes and move your sql stuff there. Oh, before that, learn how to do spring injection. I recommend using annotations. You'll need to set up an application context xml, it might seem a bit scary, but it's a one-time task. 3) make an MVC controller class and learn to use it. 4) rewrite one existing module using spring MVC (easier said than done, but you'll get the hang of it ;-) ). 5) Rinse, repeat. Edit: stuff.
Agree and it would be quicker writing again from scratch than to refactor into some new REST API + consumer app.
I will thank you so much again :)
Oh! I didn't see the "FX" part of that. I was assuming you were using Java to build web components. My bad.
There is some learning to do but I run two fairly large JSF application and have never run into an constraints with components I could not handle. Worst case you can just revert back to html and javaScript but I have not had to do so. I would also point out PrimeFaces has several component libraries using different frameworks so if JSF is not your thing you could look at those. The front end will not be as clean or easy to work with but it will still save a lot of time over rolling all your own stuff.
I'm mainly do java back-end work but I've also done a couple of SPA projects (JQuery and Angular) and that approach is by far my favourite. In my opinion it makes it easier to properly separate front-end view logic from your back-end business logic. And properly set up SPA projects using a web component approach are easy to maintain too. In addition to this; users really like it. Because you're not doing full page refreshes anymore the application feels a lot faster and closer to native to users. 
The rules for the CSS system are in there, certainly. But it is really lacking in examples on how to modify or customize the built-in controls. These controls are are just compositions of the more basic nodes, each of which may or may not have their own style classes which are not fully documented by that page.
What's your target audience - internal users where you have a degree of control over browsers used and can guarantee that javascript will be enabled, or external facing where neither of those can be assumed? If it's the latter it may force your hand (or at least rule out some options) unless your management are willing to accept that some users won't be able (or willing in the case of noscript) to use all the features on the site, without increasing the amount of work involved. Also, is there any automated testing in place for the current system? If so the again how easily can it be adjusted to cope with any changes you're introducing to the page?
I developed a lot of JSF2 Apps in the past. If you want to go that way you HAVE to use PrimeFaces. But i agree with thw guy above that it has a steep learning curve and if I where you I would prefer a "state of the art" single-page-app with Javascript frontend and a REST backend. I would go for Angular2+ in that case. It has a steep learning curve too, because there are many parts you need to understand, like the actual frontend, http-services, routing, guards, state and so on. But truth is: in a real world application you need to understand all that anyway. What you gain in "template-simplicity" with React or Vue you pay for in other parts like those mentiones aboth, or the hardest part of all: getting everything to work together and have an actual working build. You need to understand webpack for that. You got that one pretty much "for free" with Angular-CLI, as long as you stay with (perfectly reasonable) conventions. If your unsure try their "Tour of Heroes" Tutorial, as well as some tutorials for React and Vue. Taking 2 days to evaluate can pay off big time later
Yes that is my point actually. In any organization it is best if you create your own Docker images from scratch and do not trust the public ones (not just for Java but for everything) So the fact that Java is distributable or not in a Docker image, is irrelevant if you are creating your Docker images within your organization (and don't distribute them).
Love it. Put it on GitHub and I will help you if you want to make it available for maven and Gradle by uploading it to jcenter. (Message me if you need help).
Making a true SPA would be a lot of work with JSF, but JSF makes it very easy to add AJAX sprinkles all over the place to do partial page updates so you don't actually "reload" the page but the text/layout can change as a result of user action. IE, the browser does a XHR post in the background and updates the DOM but no actual navigation happens.
You're not thinking about the actual use-case that triggers this licensing issue though. If your business model for an application is not just hosting a server, but based on distributing copies of software for others to use, then this issue will apply to you. I think we can all agree that this is not an issue if you use such images in your organization, and do not redistribute them. But that is not what is being discussed. That's why in the title, I specifically say "redistributions". 