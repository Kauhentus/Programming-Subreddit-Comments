I was thinking the same thing but definitely not coming from JS land, or as little as possible. Great question!
&gt; The downsides are simple. GWT, Vaadin, Flex, OpenLazlo, etc are dead. I would agree on all but Vaadin, it seems like their team has done a superb job from what I can tell so far, of keeping up with modern ideals and standards for web design. &gt; and debugging is a nightmare Anything web related is a nightmare to debug. &gt; Almost all of them are dead or dying because many of them leveraged browser plugins like Flash/SilverLight/Javafx/AdobeAi Now you're just making things up. 
&gt; React/Vue/ES201 Until next month, or the one after when xyz comes out.
http://examples.jsweet.org/jsweet-examples-threejs/webapp/webgl_interactive_cubes.html
Use electron
It's true that GWT is now an opensourced project, but Google absolutely still contributes to it. It's definitely not dead. It's admittedly not fashionable, if that's important to you. It originally solved a different problem when it first came out - it gave you a widget/UI API which abstracted away the vast differences between IE6 &amp; FF &amp; Chrome. And it let you write your code in Java, not Javascript. So GWT had two main aspects: a set of UI widgets (and an API to use them), and the "transpiler" (write your code in Java, GWT turns it into Javascript). These days, IE and Edge are reasonably standards compilant. So the UI/widgets part of GWT is not useful anymore and will eventually be dropped completely. The future of GWT appears to lie in making easy interop with Javascript libraries that excel at making nice UIs (Angular, Polymer, Vue), while still being able to write Single Page Apps (esp. "large" apps) in the Java language, as many believe Java offers key advantages over Javascript (again esp. for large apps). Check out [Vue GWT](https://github.com/Axellience/vue-gwt) as an example of this. I don't think Electron solves the OP's problem. OP wants to create a web application, and code it in the Java language. Electron lets you code an application in Javascript, using web technology (a browser DOM), but then Electron converts it into a desktop app (so like, instead of going to your app in a webpage via URL, you just run an executable file on your PC). Electron is kinda like PhoneGap, except that you can target desktop OS's, not just mobile phone OS's. For what it does, I think Electron is really cool. But GWT is a close match to what the OP is asking for. There are other intriguing technologies to facilitate writing Java-language SPA's in browsers too; see [JSweet](http://www.jsweet.org/) [Dragome](http://www.dragome.com/) [TeaVM](http://teavm.org/) 
Vaadin couples the business logic with presentation much more than I would like. It's also much slower to compile and deploy.
Personally I think Vaadin is great. It really streamlined our development by keeping everything in one language. Not only that but you get all the Java IDE benefits. Although a lot of people like to talk negatively about Java I will tell you that the ability of it's IDE to refactor is worth a LOT!! The key with Vaadin is to realize that you do need to maintain your best practices in terms of managing your code. That is you need to be careful not to mix your business logic with presentation logic, it's very easy to do. Another catcha is that you do need to pay attention to your code because it can be rather chatty if you're not paying attention. It's very easy to have expensive event listeners if you're not being careful. Or to load a ton of data that's not needed. But that's pretty normal of any language anyways. For those who have built desktop applications you'll be right at home, Vaadin development is very similar to desktop application development. Overall I really like it personally, it allows me to very productive. I have no problems recommending it and in fact I'm the one who chose to use it for my company. 
https://insights.stackoverflow.com/survey/2017
StackOverflow 2017 survey had 64,000 respondents.
It is not diverse enough if we don't know the context of the work environment respondents work at. The survey treats everything as "average" answer. It is not as simple as running an election survey.
I am aware of this. This is a generic survey about all kinds of developers and not just Java developers. It is great for high level stuff like salary/education and geo information. But if I ask questions like: * "what is the hottest Java framework now?", * "Is Maven still relevant or should I learn Gradle?", * "Is Kotlin displacing Java or Scala?" only the ZT survey has some indications for this..
 &gt;Now you're just making things up. Flex was a framework that competed with GWT at the same time which basically endeavored to make your pages a giant flash app. 
Jmonkey engine is an option for java game development, if you drop java you could look into using unity, but either isn't something you'll learn over night, 
Would not recommend. Go for a modern client-side framework and a heavy UI library. I'd go for react starting with create-react-app and react-bootstrap that has a ton of canned UI components.
react is from 2013, vue is from 2014. (either way, the fecundity of js is actually a pretty cool thing.)
Sounds like you're already well versed in JS. If you want to learn Java for the back end stay away from vaadin at all costs. Vaadin on your resume won't open many doors for you. 
OP wants a desktop app. See title.
API gateways such as Kong or Tyk?
React, Vue, and Angular have move away from two-way data binding.
Is this needed? By anybody?
This comment validates my other comment. Tutorials are for general learning, but this is not a tutorial in the usual sense, this exists because people expect upgrades to just work. Which is clearly not the case here, so we need all the help we can get.
So you want to go from basic to expert in a few months? I suggest focusing on this project from a slightly different perspective. 1) learn the essentials I don't know where to go from there, but focus on 'filling in the cracks' of the work they do. maybe focus on testing their code or making unit tests. edit: actually, now that I think about it... beyond learning the basics, focusing on the varieties of code testing and quality assurance methods (as well as traditional unit tests) is an excellent way to strengthen some very important skills that even some 'professional' developers don't have. If you work with these guys by double-checking their code, you do a few things: - if you don't know a section of code they used or why they did, you now know some important java you now need to learn more about! - you need to learn how to read others' code. It's a critical skill, and you will need it as a professional. - learn about coding best-practices. If you notice your friends make a crucial best-practice mistake, mention it to them. If they disagree, then either you've learned an exception to the situation, or you're now exposed to one of the many scenarios when even 'experts' violate coding best-practices. This is an excellent opportunity, but only if you leverage it in the right way.
+1 to Vue2 + REST 
Just use Spring Boot, Spark, or Jersey to build a REST API, then build the frontend like you normally would. 
The scope of this library is quite limited, and I hope to see all these types included in Hibernate ORM core one day.
**Sidebar** -&gt; **NO learning Java related questions!** **/r/learnjava** is for such questions
[removed]
OP said: &gt; I want to do kind of like a desktop application, but on web. Yeah, I know it sounds stupid, but I want that "desktop" feel on web. He wants a webapp that feels like a desktop app. Not literally a desktop app.
I have the feeling that it was a design mistake to place the compilation of jsp files at runtime in the web server instead of compiling them to class files when the war is built. That compilation infrastructure is used in a large number of remote code executions, and i don't really see any benefit of not doing it compile time, i have never seen anything that generates jsp files dynamically.
-&gt; /r/javahelp But even there people aren't going to do your homework for you.
So... It should be easy no? You already know a lot! Why don't you put the pieces together and prepare a single CRUD web application with a database, to show them? Use Jersey (with Grizzly web server), JSON and Hibernate... Bam, you automatically cover JavaEE "MicroProfile".
Oh, I wasn't aware of this. That makes sense, then, of course.
Yeah. And API specs like MORBA - Microservices Object Request Broker Architecture
Since this is help with *Java programming*, it should be, as the *plenty hints* on the page indicate, posted in **/r/javahelp**. Please, read and follow the [**Posting Guidelines**](https://redd.it/48eykt) there before posting. Since you don't display even the slightest effort to solve the problem on your own, and don't even give enough information this post would not be acceptable there either. Neither of the learning related/help subreddits will accept "do my homework" type questions. **Post removed**
Coroutines in Java? Sweet!
JEE has made tremendous improvements, but IMHO of working on different enterprise systems using different technology stacks, it is still lagging behind the competition (Spring, Dropwizard, etc.). If you are already using JEE, then it makes a lot of sense to upgrade to JEE 8. And refactoring to something else would likely be too expensive to pay off. But for a new project or new microservice? Maybe time to look at the competition... I might start to think better of JEE when I can run tests easily (like in Spring, Dropwizard, etc) instead of having to deal with configuring external containers, building WAR first, etc. Yes, yes, there is Arquillian and Payara has some interesting features to ease such pain, but still not as good as competition
Or, sidestep the whole problem of bolting on additions to jUnit and TestNG to cover their deficiencies and use a test framework like Spock instead
An alternative solution is to use the Checker Framework https://checkerframework.org/ A compiler plugin which makes use of @Nullable and @NonNull annotations.
Don't compare StackOverflow with Zeroturnaround. * This survey is limited to Java world * I guess most responses are from LJC (6k members) and vJUG members My response was pointed out that if more people who criticise survey here would spend its own time to fill it, then results would be less "biased"
If you read my other comments in this thread you would see I defend this report as I personally know the guy who is behind it. I just don't understand why you share some resource with others if you think it is not representative, not correct, biased... call it whatever you want. If I would think that way about something, I wouldn't think it is worth to share.
Again, I think it is biased *to some extent*. It is representative of the community that ZT can reach. It is correct in the way that they drew reasonable conclusions from their data (I'm assuming, since the ZT surveys are executed quite well). It is biased just like every other survey. And as such, it will be cited mostly by the "winners" of the survey (just like winners write history). I'm not sure why that should keep me from posting it. My point being, it might be as good a survey for our ecosystem as we have right now. I'm not going to restrict myself to 100% accurate, perfect, extremely well researched, scientific things, because nothing is ever 100% *"call it whatever you want"*. And I also personally know the guy who is behind it.
&gt; Please seek help with Java programming in /r/Javahelp! 
Since this is help with *Java programming*, it should be, as the *plenty hints* on the page indicate, posted in **/r/javahelp**. Please, read and follow the [**Posting Guidelines**](https://redd.it/48eykt) there before posting. **Post removed**
&gt; If your code doesn't explicitely require use of a security manager, there is nothing that the developer can do to prevent "well-intentioned" users from running the application without the policy. And by default, java lets everyone execute everything once i That's OK, the one using the program should be responsible anyway. 
&gt; Next challenge: a java security manager can keep the policies of only 1 policy file at a time. Read another, and previous policies are forgotten. And unless your application specifically determones which policy file to read, it will read the default that is distributed with the java SDK or JRE: the same one that every other application on in the same environment will use. Disagree. There are semantics of invocation where policy passed in at runtime aggregates the default policy. For example, -Djava.security.policy=, replaces the default with new and -Djava.security.policy== combines the two. Of course the security manager can be overridden with a new policy impl that uses a database or some other storage medium for the policies.
Interesting. Please elaborate?
Wouldn't be surpised to see pattern matching and/or data classes land during Java 9 release cycle (since they're trying to scrap the fixed 3 year major release train with 6 month feature releases). Value types may come in Java 10, that would be fantastic for all languages running on the JVM.
Yes or no, would having a security manager in place prevent using the Struts vulnerability to perform remote code execution?
check Moodle.com rather then developing it from Scratch. 
Not only is this about *programming* (which then should go in /r/javahelp), but it is also Java**Script** and thus in the completely wrong subreddit. **Java** and Java**Script** are completely different, unrelated languages. If anywhere, this should be posted in /r/javascript 
I didn't know that about Vue... can you point me to docs on this?
Cool thanks 
Currently the only Java EE 8 implementation available is the reference implementation GlassFish 5.0. Tomcat 9 is in milestone releases so should be out soon (it implements the servlet, jsp, EL, WebSocket, and JASPIC parts of JavaEE 8). However, Java EE has been steadily improving and made great strides in Java EE 6 and improved even more in 7. I have done my last couple RESTful api's with just Java EE 7. I use tomcat so have to add Jersey as a dependency but if you use a full app server like Glasshfish, Jersey is available with no additional dependency (jersey implements JAX-RS which is a Java EE spec). With the improvements in Java EE I don't see much of a need for 3rd party frameworks. The real question is what do the 3rd party frameworks offer that Java EE doesn't? Remember that most frameworks are just a wrapper on top of Java EE (e.g. Spring MVC uses a dispatcher servlet, Spring Boot just bootstraps Spring MVC, Grails is Spring, etc). You have to ask yourself if the overhead of wrapping Java EE with another framework offers any value.
Nice!
[removed]
32 bits download are down
Fast ? Spend all of your available time on learning it. Get a big mug of coffee, and start playing with it. If it's any sort of larger application you will need to have some sort of plan of how to code it. Consult with your team, you could work on coding the easier components of the game just to get your wits about you. 
You, sir/madam/other... have just saved my bacon. Thank you very kindly. EDIT: The eclipselink dependency can be replaced with the JAXB reference implementation for most use cases. Saves over 10MB on the resultant build.
I don't see a question here.
Cause it's SEO spam. 
In these modern times I think the best way to approach JavaEE is to use the "lightweight" approach and use selected pieces of it in common libraries. Stuff like Application servers is interesting in its own, but I think it has limited audience now, all the shops that I have been working with are more focused on using containers, fat JARs and microservices (mostly, "wanna-be" microservices). What I mean is, if you start working on a *modern* backend application in Java, you probably end up using libraries like Jersey, Hibernate, Guice. These guys are providing perfect implementations of JavaEE standards. So if you learn to use annotations like @Inject, @GET, @Id, you will basically have learnt also how to do business logic with JavaEE, without even turning an application server on. Once you learn thinking of JavaEE as just a reference, you can navigate better in the sea of frameworks and libraries out there: there are frameworks which glue JavaEE-compliant libraries together (Dropwizard, Ninja) or provider more opinionated abstractions (Spring) or simply decide not to use JavaEE references at all (Vert.x, Play, Ratpack) 
Good, though late as always. We'll see it in maybe in a couple of years or later, meanwhile Kotlin already got em.
See [Default Policy File Locations](https://docs.oracle.com/javase/9/security/permissions-java-development-kit.htm#GUID-BFF84712-05CF-4C1E-926F-411FDF83AE32). There is the `=` and `==` command-line syntax as mentioned by /u/shawnmckinney. There is also the *security properties* file (distinct from system properties) that allows specification of multiple security policy files. Though it didn't come up in the discussion, I'll further mention that a policy file can grant different permissions to different code bases (e.g., jar files) allowing different code in the same JVM to run with different permissions. (Multi-tenancy isn't supported though.)
thanks for the advice.
Yes, this has happened to us a few times too, and it's always been `ulimit -u`. It's a bit subtle because the resource is named `NPROCS` but on Linux each *thread* counts against this limit. On a big multicore machine it's possible for a single JVM to have hundreds of threads, so it's easy to run into the default limit of 1024 when just a few JVMs are running.
It says "*preserve the same programming model of ordinary Java threads*", so does that mean these coroutines will be preemptive? That would be amazing. Alternatively, cooperative coroutines can already be implemented without changing the bytecode like Kotlin does, but do require compiler support.
In WebSphere-land, JSP's were available in 3.5.x long before WARs came along in 4.x. IBM had a utility to precompile JSPs, which you usually always wanted to do for performance reasons, but it required root to run and wasn't terribly easy to get going. (Actually WAS 3.5.x had a lot of trouble running as non-root, because that group was mostly Windows weenies. Used to work in the WebSphere Applications Group (not WAS itself, we were clients to it) and I was almost the only person in Bldg 500 in RTP to use Linux full-time as my desktop.) 
My secondary hard drive was getting real slow, so I was migrating as much as I could off it, and I couldn't get those downloads off; I hope someone else saved them (I did find some re-ups by Googling filenames).
Java can have couroutine support if you use Quasar.
Probably an unpopular opinion here but you can make a very rich SPA that has a desktop feel using JSF/PrimeFaces without having to write any Javascript. Take a look at PrimeFaces' premium themes for examples.
well they changed the releases policy actually, so there will be the chance to have some new lang features in few months (next Java release has been planned for March 😉 and the next one again has been planned for September) 
So you want us to do your homework for you?
I was kind of confused when microservice replaced SOA as the new buzzword. I saw no meaningful difference between microservice and SOA architecture. The only kind of difference was a microservice is supposed to only do one thing and do it well. However, I saw plenty of services that did that when SOA was the buzzword.
So in your view the difference between SOA and microservice is that SOA has to use an ESB? And if you aren't using an ESB you aren't doing SOA? This is an interesting take on it, not sure I agree. I know vendors were trying their best to sell ESB's when SOA was the new buzzword, but you can certainly do SOA without an ESB. I sat through many ESB sales presentations (BEA LiquidBase, some IBM hardware ESB, WSO2 ESB, etc). I never saw much need for one, seemed to add complexity where none was needed, unless you were really needing to aggregate multiple services into one request, and the services were using multiple protocols. An appropriate use case for an ESB has to be quite rare.
Nice timing. You just saved me a lot of trouble. Thank you for sharing :)
1. This is help with *Java programming* and as such should, as the *plenty hints* on the page indicate, be posted in **/r/javahelp**. 2. Neither this subreddit, nor any of our sister subreddits will do your homework for you. It is *your* homework and *you* have to learn how to do it. Even your approach of downloading something from somewhere is simply *cheating*. We do not support this behavior. So, trying to post in any of our sister subreddits will be in vain. Your post will be removed there as well. **Post removed** Programming help and "do my homework"
Please stop giving people ideas! :-)
Why is it superior? Genuinely asking as I am wondering which one to choose..
It depends on how it gets deployed and under which app server, etc. But the theoretical answer is yes. Assuming the codebase where the deviant script executed doesn't have this: grant codeBase "file:${user.home}/MyStrutsApp.war" { permission java.security.AllPermission; Worst case scenario is you find the library that is responsible for the exploit is running as privileged code, i.e. has all permission. At that point you can work with vendor, code producer to find a way to run it as unprivileged, &amp;/or remove the offending code.
Sounds like the old 'green threads' model that was implemented years ago in older versions of the JVM? It's funny the proposal doesn't mention this having been implemented previously. In fact, initially the JVM didn't even support native threads! 
I was thinking this exact same thing, it's not trivial but at least there may be a foundation to work against.
A good point. Not positive of the rationale, probably that each container is free to use its own jsp compiler and thus may have different implementations using servlets or otherwise.
Yes, Java EE is certainly worth it. Now with Payara rising and Liberty just gone open source the future looks bright indeed!
&gt; Currently the only Java EE 8 implementation available is the reference implementation GlassFish 5.0. Payara 5 is available too, although in an alpha release. 
Finally! Maybe this will put an end to this whole reactive development by callback where you can never block bullshit...
Coroutines where around long before kotlin existed.
Why was that ever abandoned? From my point of view, green threads are way better than the heavyweight system threads we use now, but I could be missing something.
Huh? all reactive stuff in Java happens on threads, are you thinking of Javascript?
The How to Program with Java podcast talks about full stack web ievelopment with the Swift Framework. It's old though so no guarantee it's still the best option.
If you consider Java EE as a full stack framework, which you'll always control yourself it doesn't matter whether you'll consider it as an "application server" or not. The only problem with the AS concept is that an overzealous ops team may take control of it. But if you supply a fat jar or a docker image, this never has to be a risk, whether you call it AS, framework, or library.
1. No more Oracle and some other minor details
This is great to see! Make sure to test out the OpenJ9 binaries at https://adoptopenjdk.net/releases.html?variant=openjdk9-openj9
Uhm whoever wrote this basically missed most of Java 9. Let me give a better summary: Module system (jigsaw) Breaking all kinds of private shit and basically breaking reflection Very minor improvements to CompletableFuture A start and stop function for streams that takes a predicate (the only thing I give a shit about tbh) Private interface methods...kind of a big deal The entire reactive API...which this article put under "minor updates" Uh...maybe I need to start writing articles and posting them here. 
Thank you! I'll go check it out.
This is for EE 8, not SE 9.
Wow I didn't notice that my bad. Why the fuck is this even posted here? This should be completely removed imo.
Why? It is named "Java EE" for a reason.
Good heavens, a bit grumpy aren't we then?
It's not bs at all. When you learn to use completablefuture it all gets pretty easy. And enabling coroutines wont save your code from blocking programmer errors anyway.
Yeah! Stop posting Java related articles to the Java subreddit! 
I believe the early green thread implementation in Java was N:1 threading, which means that all "user space threads" must share a single OS thread. Moving to 1:1 threading gave a huge boost in performance because OS threads can actually execute concurrently. Fibers, as described, are M:N threading which both allows true concurrency and benefits from not deferring to the OS when rescheduling the thread abstraction.
I believe originally you *only* had green threads. As in only one real system thread. So no actual parallelism.
Ah, well. That does sound pretty bad. Still, is there a reason they switched to system threads instead of adding them alongside green threads?
Fuck Java
This proposal is from the same author of Quasar - /u/pron98
I heard they use Java EE at Oracle .
As in most engineering operations it was no doubt a trade-off between complexity and performance. Certainly a system that supports either green threads or system threads instead of an M:N model that supports both is going to be simpler than the latter. I'm not totally convinced even today that fibers are necessary in Java. I see people complain that Threads are expensive and perhaps in some limited cases they are but for the majority of programs written in Java native Threads are not a performance bottleneck. On modern systems you can easily create over 10,000 threads on a single JVM. Sure, there are context switching costs but with fibers you have the tradeoff that these processes are operating cooperatively so can potentially block forever. So they're not a panacea either.
I'm glad you found it useful.
Oracle at work. We need webstart. For all other purposes I prefer (especially on Raspberry Pies) Azul Zulu. It's just great. 
Do they? I mean, really, do they?
&gt; On modern systems you can easily create over 10,000 threads on a single JVM. But over 1M sockets... We want people to be able to create 1M threads or more, so the programming model is simple. &gt; but with fibers you have the tradeoff that these processes are operating cooperatively Not necessarily. First, Loom (and Quasar) fibers are preemptive in the sense that they yield on IO and synchronization. Cooperative scheduling usually refers to the Windows 3/Node.JS model where tasks need to yield explicitly. Second, time-slice based *forced* preemption is actually very easy to add, and we may certainly have Loom fibers do that. But we had that in Quasar, too, and then took out that feature as it was of no help at all, for the reasons listed in the proposal. Almost all preemption on modern machines is of the first kind.
Problem was: by passing a specially crafted Content-type header, the attacker was able to *(1)* execute arbitrary Java code. The attacker then used his ability to execute arbitrary Java code to *(2)* write a shell script and launch a process executing that script. I grant that the security manager would have prevented no (2), but would it have prevented no (1)? I dont think so.
Just because you can doesn't mean you should 
What's wrong with using VS code for Java development?
I've been working on Java in VS Code because I wanted something with linting and build scripts, but with less footprint than Eclipse. And also to get me to use Powershell more. It's going *okay*. I know there are other choices, but I'm a "new hotness" sort of guy.
I write code on Java using eclispe for living and honestly, I can't think on anything against not havin 1.3gb of RAM usage for development. Maybe support for maven/ant scripts/specific frameworks is lacking, but still, I'm tired of waiting over 15 minutes to have everything updated and in a "working state" on the morning.
Well , AS do lazy loading , that means at bootstrap time they boot only it's core.And later on if you need a specific API it gets loaded.So IMO because of that it makes Java EE lightweight. Also if you don't want to use AS there are alternatives like Payara Micro and Wildfly Swarm.
Why use eclipse or visual studio code in a world where intellij exists?
Agreed. Without a doubt using intellij smartly made me a much more productive engineer. Not saying I don't write code in VScode. But if I am doing something that will take some serious effort intellij is where that happens. Eclipse and netbeans done even hold a candle to intellij when it comes to Java IDEs. 
Just use GraalVM for now
I suspect intellij people is going to have several similar problematic choices with kotlin. They manage to introduce certain features: lambda expressions, coroutines, pattern matching, etc without (before) JVM support. Once JVM supports them, let's say JVM 11, they need to choose between not using the new JVM features and get a performance hit and maybe damage Java interoperability, using them and loss support for Android and older JVM versions, or keeping several different compilation targets, a lot of work. At the same time, Java the language is gaining features, so kotlin becomes less attractive because it's only a marginally better Java. Honestly I'm not sure if it has a future, and that's a sad thing, because competition drives everyone forward. 
I used Vaadin in one of my previous jobs. Very nice framework if you want to deploy something quick. Downside - like most frameworks, when you want to make something unusual you may have to get your hands dirty. Sometimes you may want to integrate a js library to your project and it might get complicated. Generally it's solid and quite active. Perfect choice for intranet apps but I wouldn't choose it for a world facing app because of the overhead. 
I would recommend you to watch our using inner classes as they make the code a bit complex sometimes. I know there are programs like checkamrx that might help detecting those but it can also be a big problem sometimes. Good luck.
Seriously, the intellij whoreship here has to stop. Intellij and VS code aren't even directly comparable. 
* Better performance * 64 bit for free * Cross platform * Better threading model * Better separation of concerns * CSS support (HUGE ONE) 
EDIT: Hey, thanks for the downvote for giving an opinion. What the fuck, reddit. My first bet is that pricing (Specially given there are free and open source alterantives) is the main problem when even thinking on try Intellij. I mean, you have ToolA (which is good) and ToolB (which is great), but ToolA costs 0 and tool B costs 400$. I see the company thinking that going from good to great is not worth these 400$, and for personal use, ~~400$~~ 150$ for something I'm not really going to use at full capacity is out of the question.
Intellij has a community edition which is free. Anecdotally, I use it every day and never have been in a situation where I needed the enterprise version.
That's ambitious and cool. Anyone see some demos?
The free version has a ton of features. Ultimate offers some extra Java EE and Database stuff and access to other programming languages but nothing that would be otherwise deal breaking.
I believe any kind of web framework able to build that without much difference. so my suggestion is to pick stack that your team most familiar with. Although one thing I'm not yet firm: Where to host the video? would it be better to use third party (Vimeo?) or host your own?
Aren't payara and wildfly AS as well?
Well, at my company I sue the tools I'm provided (This is, eclipse and, sadly, Netbeans for a different company), and at home I don't use to work in Java, so... 
Payara and wildfly are the full thing , Java EE implementation. Swarm and Micro are more like Spring Boot.You choose which part of Java EE apis to include in your final uber jar file.
He was talking about Eclipse though...
Personal use doesn't cost $400. It starts at $150 and gets down to $89 on the 3rd year and that's only if you require the Enterprise/Ultimate edition. 
&gt;Why use eclipse or **visual studio code** in a world where intellij exists? Yes, and VS Code as well. (I have no opinion on all this, I just think you missed a bit of context) 
Yes but you are missing (3), the shell script itself must be granted permission to execute. grant codeBase "file:${user.home}/MyContainer/webapps/my-struts-app.war" { **permission java.io.FilePermission "my-heinous-shell-script.sh", "execute";** 
Several demos are available at https://leaningtech.com/cheerpj/demos/
yes, you are right.
Thanks! I will go with JavaFX then. Do you use Scenebuilder or do you code the FXML yourself?
Oh, I looked over the webpage quickly when writing the prices. I've changed it. (Although the point stands, specially having free options).
Yeah it's up to your preference! Personally I feel like IntelliJ makes me a lot more productive and I really love the features. I would gladly pay for personal if I needed it. 
The permission allowing arbitrary code to execute: **permission java.lang.reflect.ReflectPermission "suppressAccessChecks";** As mentioned in the [README](https://github.com/shawnmckinney/serial-exploit-sample/blob/master/README.md) referenced by the article, this permission must be granted to codebases using standard libs like xerces or commons. Here's the most important point: Reflection alone isn't enough for a remote code execution exploit to occur. It also requires privilege to invoke system commands, which are preventable via JSM. Reflection without file execution permission and the attack fails.
&gt; Swarm and Micro are more like Spring Boot.You choose which part of Java EE apis to include in your final uber jar file. What benefit does Swarm and Micro offer then? You can do that on your own. For example, if you are deploying to Tomcat, but want to use Jersey you can include jersey as a dependency. If you want injection in an app being deployed to Tomcat you can add Weld to your project. Is it a matter of Swarm and Micro just making it more convenient? 
Yeah, I would imagine all the web containers have alpha or beta versions of their Java EE 8 support.
&gt; But if you supply a fat jar or a docker image In which case you are still using an AS (or at least servlet container) it is just embedded in your application. 
Well, Javascript based IDEs are not memory-efficient either. I use mostly Eclipse and it's usually 10 seconds until I can start typing code. Vim is faster, sure, but I just prefer to wait the 9 extra seconds. Maybe you should upgrade your Pentium III someday ;-)
VSCode is more of a text editor than a full fledged IDE.
lol, I learned to code in a Pentium 3 back in the day, and using eclipse (And it was faster than the I5 I use nowadays). About startup times, I don't know, honestly. It seems the bottleneck is just a clumsy configuration. I would kill for a command API so I can just order Eclipse start (Start, svn update, maven update, launch local server) when arriving to save time...
We also don't yet discuss where to host video. I personally think handling video on my own would be new kind of work since I haven't work with this technology. BTW thanks for the reply.
I hand code in either Java directly or FXML. SceneBuilder is fine though.
Idk, but I figured I could turn everyone further against it if I said that
Thanks. I wrote that during a bit of insomnia and didn't see the home page. Any Java projects come to mind that should be "ported"? The UI seems like the hard part unless you're already using swing (not JavaFX or SWT) 
First flex version was released sooner than GWT, you're just making things up. Java applets were dead already and they thought there's a market gap (my opinion). And vaadin is definitelly not dead. Recently they released a new version and it's used in intranet apps all over the world. Same holds with primefaces. Yes, hand tuned javascript apps can provide better performance and more eye candy, but no one is willing to pay for it. It's like coding in assembler. I just want to display those damn CRUD forms, that's all.
Thanks. I hate using the mouse too much so I will hand code too, I just find the documentation on FXML lacking. 
This is just the Mockito homepage.
Not answering the question. Java EE 8 is not significantly better than Java EE 7 or 6 regarding the points you mention. Also Guice is not a CDI implementation, and thus has little to do with JavaEE. It supports the 2 same annotation, yeah, but that's all.
Spring Boot is not a way to choose parts of APIs into a jar file. Spring boot is a way to create spring application prototypes while being able to leave out most manual configurations, thus saving time.
Real men use VIM and Linux
Try /r/cscareerquestions/
thanks!
Congrats to Spring Community and special big up to Spring team
Java guys? I have seem most java developer use Eclipse/intellij.
Java EE is all about two things: programming against standard APIs and libraries and running your application from inside an application server (containing implementations of those APIs). Make sure you understand this concept. How to actually use these APIs is easy to learn later.
Thanks for adding more technical details on preemption of the fibers. Once you add time-slice based forced preemption you've partially re-invented a kernel. Why take on that complexity in the JVM? It's justifiable if many projects require it, but what percentage of systems in the world have to worry about 1M sockets? There are already other established ways of dealing with that number of sockets using NIO and libraries built on top of that provide fairly straightforward programming models. 
1. The complexity isn't that high, and it doesn't take anywhere near a whole kernel just to implement threads (at least not anywhere near a large kernel; OTOH, a microkernel is about 10KLOC). Much of the complexity is in the scheduler, and Java already has a state-of-the-art scheduler. All that's left is maintaining a stack. While this project will require some non-trivial effort, compared to everything else the JVM is doing it's not going to significantly increase its complexity. 2. Not only applications that handle so many connections will benefit. Others will experience a reduction in computing resources they require. In the cloud, this means more applications you can cram into a machine. 3. I disagree that asynchronous programming is "fairly straightforward". 4. Fibers enable some other, very interesting and very useful programming styles: actors, dataflow, synchronous programming and probably others. We need to think about the future.
&gt; Has anyone else encountered issues with Java 9? Had you bothered reading a few pages of posts (sorted by *new*), you would already have found quite a few threads about problems with Java 9. You're not telling any news here. Always *read* the subreddit before posting.
I think Tomcat and Payara are the only ones right now. Liberty has issues open for and is working on it. TomEE did like 2 commits in August for Java EE 8 and then stopped again. As far as I know Tomcat and Payara are thus the only ones who have actually released something. The Java EE 8 samples project does its CI testing on Payara btw.
So then why does it matter that you use the term AS for it? As far as your application is concerned it’s just a library. All the downsides of the AS like a dumb sysop taking control of it and refusing to upgrade just to be a nuisance are gone then.
Payara Micro is like a web profile++ wrt the APIs it supports, almost everything from EE except the really legacy bits.
Thanks for the reply. Moodle is mostly written in PHP. But we want to build on Java stack. 
Spring has made tremendous improvements, but IMHO of working on different enterprise systems using different technology stacks, it is still lagging behind the competition (Java EE, Payara, Liberty, WildFly, etc). If you are already using Spring, then it makes a lot of sense to upgrade to Spring 5. Refactoring to something else would likely be too expensive to pay off then. But for a new project or new microservice? Maybe time to look at the competition... I might start to think better of Spring when I can run tests easily (like in Java EE, Payara, WildFly etc) instead of having to deal with configuring things internally, not being able to be building a WAR first, etc. Yes, yes, there is SpringBoot and Spring Configuration has some interesting features to ease such pain, but still not as good as Arquillian.and the transparent internal configuration (@DataSourceDefintion etc) that can be swapped for external configuration (asadmin, cli, admin console, etc)
Is Spring copying MicroProfile Metrics here??? https://github.com/eclipse/microprofile-metrics
&gt; Please copy our code, as the license allows us to, but please also respect our work and leave me alone. You seem bitter that open source is in fact, open source... 
What!! Of course NO. Spring boot actuator was way before Microprofile metrics (https://github.com/spring-projects/spring-boot/tree/master/spring-boot-actuator). I think it's a similar project ;)
Considering the time and work that went into your collection, is it that difficult to write a proper post title? * `[` and `]` should be `(` and `)` * inconsistent capitalization * spelling mistake (embarrassing to no end) Thanks for sharing.
well, I see you did not like my post about JEE 8, as you quote it by replacing "JEE 8" with "Spring". Fair enough. Btw, I am not affiliated with Spring, nor Dropwizard. I have no horse in this race. I was just sharing my (possibly limited?) experience of using those different frameworks. However, I am curious about when you write "when I can run tests easily (like in Java EE"... has there any improvement about it in JEE 8? Are you talking about experience of using those different frameworks? I like EJB and CDI, but I always found writing tests in JEE really cumbersome (eg all the manual steps to download and configure external containers, fighting with ShrinkWrap, etc). Maybe I am doing it just wrong, and I am missing something. Would be interesting if you have any nice links that show how easy it is to write tests for JEE applications, so I can learn and possible not spread BS around? thx
I felt your opinion really interesting (not joking). I feel the exact opposite when it comes to spring vs java ee. All the issues you pointed out were strong points for spring in my experience (testing, beating the competition, keeping up with more modern ways to do things, etc...). I guess that shows how much we can look at those technologies with different perspectives. I work with both java ee applications and spring applications. In java ee it feels like I'm stuck years behind in terms of improvements that could be made. I'll start looking at java ee with different eyes from now on, trying to find its strengths.
&gt;replacing "JEE 8" with "Spring" To really balance it out it should perhaps have been SPRR, but oh well. &gt; Would be interesting if you have any nice links that show how easy it is to write tests for JEE applications This is one of the official Java EE specs. It has a number of small applications that are tested via Arquillian. The nice thing is that nothing is mocked or faked, everything is real and runs in the actual context in which those applications would normally run: https://github.com/javaee/security-soteria/tree/master/test If you look at the test setup closely you'll see there's barely any interaction with Shrinkwrap. The output from the Maven build is used. An external project, but showing a similar approach, now with Shrinkwrap: https://github.com/javaee-samples/javaee8-samples and https://github.com/javaee-samples/javaee7-samples Even though the above uses shrinkwrap, it's not super complicated at all for small applications or micro services. 
&gt; In java ee it feels like I'm stuck years behind in terms of improvements that could be made. Which improvements would that be exactly? I personally found CDI for instance much more capable and modern than the Spring core bean container.
The complexity inherent in Spring is getting to me, as are the many things that are wrapped and presented as a Spring project, then be abandoned again. This round I'll try my luck with Java EE 8 instead of Spring. Sorry, but thanks for all the fish :P
That might be because classloading in Java 9 has been fundamentally changed.
Is anyone use Spring still? Is bit old, not? With terrible big XML file!? Is, please, why we need move everything to xml? Is Spring say, is confit not code!? Is no dependable on Spring? Really!? Really!?? So I remove giant spring ball of mud xml file and my app still run 🏃??? Don’t think so!
xml hasn't been around for years. see spring boot. 
Were talking about flex 3 here, the one that was free, promoted heavily as a RIA/RAD, came out a year after GWT, not the one that previously cost thousands to use. 
You should check it out again. Spring has come a long way since the xml days. It is still being used extensively in enterprise level Java applications. It's has a solid code base and a good community built around it. 
There is nothing that excites millions of developers around the world than the word Eclipse. I am sure that this new name would help usher in many new developers to the platform. /sarcasm
You shouldn't have. No really. 
I would suggest you read a few books. Effective Java, and Java Concurrency in Practice. Both excellent books that cover common patterns and classes and how to best utilize them with the Java language. &gt; I know Java for mostly application development. I'm confused. Do you mean GUI (desktop/console) applications? If so, you should already be familiar with everything you listed. My confusion aside, here are a few of the most common things you'll want to read up on from the categories you listed: &gt; Java Collections Look over these interfaces: List, Map, and Set. The most common implementations are ArrayList, HashMap, and HashSet. &gt; Sorting algorthims No point in dealing with algorithms directly. Read up on Comparable and Comparator. They are often used in sorting. &gt; Threading Read up on the ExecutorService, and Thread class to start. This is a big topic, but these two are used a ton. If you are going to be doing web applications, multi-threading isn't all that common. At least, it's not as common as say, GUI applications where handling threads is shoved in your face. :) &gt; Look into how Java interfaces with Databases. he said they use Hibernate. JDBC is the standard. There are a billion frameworks and libraries that sit on top of that. If you're using Hibernate, you probably won't have to deal with JDBC directly but you should be familiar with it since you still have to configure Hibernate to deal with the JDBC drivers at least.
I'm not clear if you're serious or trolling?
what is the point of spending time redacting and posting on something you dislike.
!?
I'm hoping to upgrade my projects in the next few months. Spring boot 2.0, gradle junit 5 support, upgraded spring security and integration all kinda need to be there first though. Wish this rolled out with all that other stuff, but I don't mind waiting.
Naming is hard.
I can't say this enough. If you're building rest services try Dropwizard instead!
Idk about coding but I certainly I threw random lines of who knows what at a compiler and hoped something sticked for 30 hours a day. Then things started clicking bit by bit.
I am posting this because it is important news in the Java ecosystem. Just because I posted it doesn't mean I have to be pleased with it. In the real world, platforms that rise to prominence aren't always the best from a technical point of view. It takes more than just pure tech to succeed in the marketplace. The ability for a platform to effectively market itself to business owners and architects makes a strong impact on adoption. One case study that I love referring to is how Microsoft Silverlight was originally going to be named WPF/E. It is strongly agreed upon by many developers that Silverlight as a name allowed it to have better adoption due to being simple, inviting, and memorable. Unfortunately, the new name has two core problems in my opinion. One is that it refers to Eclipse. Most individuals equate Eclipse to an IDE. Unfortunately, that IDE has a complex history that leads to a strong dislike by many developers. Second, the name itself is long, complex, and overtly technical. It isn’t simple, inviting or memorable. Overall, naming products is a very difficult task. However, in this case, it was named strictly for technical reasons and not in a way that would make it effective in marketing. Therefore, in my opinion, it damages its future potential.
No, I said everywhere it's good AS LONG AS YOU RESPECT THE LICENSE. Jeddict, for some time, was copy/pasting our code and removing our license headers, and not copying our LICENSE file - this is not respecting the licence, and this was not cool. This isn't what they do today, as we discussed this privately, so there is no issue at all with that. Please refer to the original question here: I just said that JHipster and Jeddict projects would look the same because they use our templates, and that they had the right to do so - what 's wrong with you?
1. Depends on the school / programme 2. Try /r/javahelp
I'm currently on my second year of school and I'm in Java 2. The first year we did the basics of coding. Such as declaring variables. Throwing exceptions. Etc. In the second year everything we do is Object oriented and creating seperate classes.
I agree with your comment and after reading only the title of the post I was thinking the same things. However, the article states that they want to abbreviate it to EE4J which is a bit better, I believe. The link to Eclipse isn't obvious in the acronym and it's a nice throwback to J2EE while the inversion (J&lt;-&gt;EE) still hints at something new. We'll see how the public perceives it though...
Spring 5 is a full reactive stack. Java EE 8 is not, maybe Java EE 9 will be full reactive. For beginners, setting up a Java EE project will be much easier. Spring Maven dependencies are always tricky.
Asynchronous methods. Java EE is not fully reactive.
Worst. Name. Ever. Seriously, i have nothing against Eclipse but this will turn down so many people. If they couldn't stick with the original name JavaEE ( probably because of oracle's TM policies?), why not choose something different and evocative like it is usually done for umbrella projects, like "project jakharta"? 
thanks for the links &gt; https://github.com/javaee/security-soteria/tree/master/test cloned that repository. Checked the first example, "app-custom". Opened it with IntelliJ. Right-clicked on AppCustomIT, tried to execute "Run AppCustomIT", get greeted with "Error: Arquillian container configuration not specified". Checked in the pom file, and I see a plugin to download JEE containers. I know how to configure it, but, just for a moment, think about someone that has never used JEE before. Now s/he has to Google around to see what to do to just run a simple test, whereas in Spring/Dropwizard a single right-click would had been enough. Tried to run from Maven, using "mvn clean install -Ptomee,bundled", as per instructions. Getting a "Failed to execute goal org.apache.maven.plugins:maven-failsafe-plugin:2.19.1:verify (default) on project app-securitycontext: There are test failures.". Besides the configurations in the pom file (eg to download and unzip JEE containers), in the test I need to have @RunWith(Arquillian.class) // fine @Deployment(testable = false) public static Archive&lt;?&gt; createDeployment() // fine create(ZipImporter.class, getProperty("finalName") + ".war") .importFrom(new File("target/" + getProperty("finalName") + ".war")) .as(WebArchive.class); this latter can be put in an abstract test class. so, not a big deal once you know about it. Still, though, because it refers on a WAR file on disk, every single time you do a change in one of your classes (eg, for a unit test), then you need to rebuild the whole WAR to test it. All these things are doable, once you know them. But all other frameworks out there do not need all these steps and constraints :( 
it was a reference to [this](https://www.reddit.com/r/java/comments/72qke0/java_ee_8_does_it_worth_it/dnkl5qu/). I am serious. I find JEE a nice, but with a shortcoming regarding being quite cumbersome when it comes to run tests and debugging. /thesystemx claimed that it is instead very easy. Now, I did not know if /thesystemx was just trolling or serious, and it is me that has been doing JEE wrong all this time. So I just asked him/her to provide some links to check out. 
opsss sorry, page layout tricked me in thinking you were replying to my comment... d'oh! :)
Plot twist: Eclipse wants Java EE to die and for regular Java to succeed it, and this name is part of that plan.
Will package names still be javax.*?
Ditto. I’ll be looking at the Microprofile stuff and seeing what I can do there. With that and Vert.x, I think I’ll manage just fin without Spring. 
How can you deploy an application into WildFly or Tomcat via IntelliJ Community?
Well, you can do that! But I've monitoring my logs using ELK stack, so it makes more sense for me to have one dashboard to visualize health. If I used influxDB you'll have to use grafana (or similar) to visualize your metrics
&gt; Spring Maven dependencies are always tricky This has been greatly simplified with spring boot by: * starter project * BOM's(Bill Of Materials) Most of the projects have a BOM artifact to import like spring-data, cloud, inter alia
The thing i found about spring is that it is very flexible. Most other frameworks ive tried worked really well until you had to stray off the beaten path. Take messaging for example, changing serializers and backends can be done independently and easy. So you can do soap,json,protobuff over http,jms,twitter with relative ease and without changung any business code. Another thing is security most framework only implement this at the edges wheras in spring you can add checks anywhere and using a nice dsl. So in short spring can be complex, but if you make something that isnt both simple and easy it can be very helpful.
&gt; Spring has made tremendous improvements, but IMHO of working on different enterprise systems using different technology stacks, it is still lagging behind the competition (Java EE, Payara, Liberty, WildFly, etc). In what area is Spring lagging behind? Actually the opposite is true. Spring 5 is fully reactive. Spring integrates with way more technologies. Spring is easier to test (yes, I am aware of Arquillian). Spring can be used with Gradle without hazzles (compared to Wildfly Swarm, which stopped Gradle support). Spring has a lot of Kotlin APIs and so on. 
So, will the "Eclipse IDE for Java EE Developers" now be called "Eclipse IDE for Eclipse Enterprise for Java"?
Eclipse just brands every project with "Eclipse", so this is no exception. This does cause it to be buried alongside other mundane projects when it is in fact way way more important. I think it would have been better if they had chosen a more neutral name.
Different performance characteristics of systems at the time? Context switching is expensive because memory is slow right? Used to be waaay faster compared to processor speed, so it sounds like it was probably for the same reason that they designed the language without value types and are now rethinking that.
Easy to remember: EE4J = reverse(2 * J2EE);
Rolls off the tongue
Not a twist, definitely a clear confirmation.
&gt; There are only two hard things in Computer Science: cache invalidation and naming things.
&gt; "Eclipse IDE for Eclipse Enterprise for Java" "Eclipse IDE for Eclipse Enterprise for Java Developers", of course...
It's "clever", but clever names too often are cheesy names as well. Love the whole transfer and everything, but the name.. I dunno...
&gt; Jeddict, for some time, was copy/pasting our code and removing our license headers We never removed license header, in fact jHipster front-end templates had no license headers previously and I guess from last 5-6 month , you applied header license on all templates, so we applied too. &gt; not copying our LICENSE file We already discussed about it over personal mail that it was my mistake and I was not aware about complete licensing term and thought Jeddict also have Apache license. Now followed all Apache license term for front-end templates as per you suggestion. But still you are counting it as We don't respect.
i, too am anxiously waiting for the new spring boot 
&gt; Spring 5 is fully reactive. But is that a fad, or something we'll all be doing? Pure reactive has downsides too, is not easier to understand, and surely doesn't necessarily mean better performance. It doesn't block, sure, until you do block, and then the system needs to do "something else", which takes you back to Windows 3.1 co-operative scheduling. &gt;Spring integrates with way more technologies. You mean like NoSQL right? Which was the big hype of a few years ago. Didn't went to well, did it? Spring may be fast (compared to EE) to jump on hypes, but hypes die out all the time. Java EE takes a somewhat more careful approach and only adopts things when they're really it's something to stay. &gt;Spring has a lot of Kotlin APIs and so on. Which like 1% of devs are using at most for an experiment now, and nobody yet knows if its there to stay. How's the Groovy support these days? How much does Spring actually contribute to Groovy again?
Java EE has plenty of Asynchronous methods. The @Aynsynchrous, managed executors and thread pools, asynchronous events, asynchronous HTTP, elaborate push support via HTTP/2, WebSockets, SSE... &gt; Java EE is not fully reactive. The question is really whether it should be, at this point in time surely.
&gt; But is that a fad, or something we'll all be doing? Pure reactive has downsides too, is not easier to understand, and surely doesn't necessarily mean better performance. That's true, but you don't have to use a reactive programming model with Spring -- but you can. It can be reactive from the database to your http handler method. To the integration: yes, NoSQL is such a thing where Spring offers integration. Maybe the hype is over, but NoSQL DBs are actually used in diverse contexts. I'll have to connect to a MongoDB in the near future and I'm happy that Spring supports this out of the box. You can, of course, use Spring in the same conservative way as Java EE. 
I don't use either of those, so I haven't had to deal with that. I have written a few Play apps in intellij though and just deploy it from the terminal. I guess if that was something I did every day I would probably get the Ultimate Edition.
I think it'd be best to just call it EE4J, that sounds like a decent thing, whereas Eclipse Enterprise is like calling something Slow Clunky.
Yes and yes. We discussed this several times! For some time, you were not respecting the Apache license, and as I told you several times already: - I'm sure you meant no harm on this - Everything is done to help you to use our templates That's why I spent so much time discussing this with you, so it's correctly done, and so everyone is happy. Here I was just answering to "thesystemx" who said I wasn't happy that Open Source is Open Source, and I was giving an example. Nothing against you. I'm happy when people respect the license, as this what OSS is all about. And, to go back to the main subject, once again: as you use the JHipster templates, the end result will look a lot like a JHipster project, that was all I was trying to say in my first post, answering someone who had that very question.
&gt;Checked the first example, "app-custom". Opened it with IntelliJ. Right-clicked on AppCustomIT, tried to execute "Run AppCustomIT", get greeted with "Error: Arquillian container configuration not specified". I also think that Arquillian could do better there, something like a default container would go a long way. &gt;Tried to run from Maven, using "mvn clean install -Ptomee,bundled", as per instructions. Getting a "Failed to execute goal org.apache.maven.plugins:maven-failsafe-plugin:2.19.1:verify (default) on project app-securitycontext: There are test failures.". But that's correct, isn't it? You perhaps forgot to mention that all other tests do run, and that for other targets (e.g. Payara) all tests do run. In that case the test is supposed to fail it seems since TomEE has a long standing bug/omission where it indexes the security constraints in the EJB module, but doesn't do the same for the web module's security constraints. That one test happens to test that. I agree with you that Arquillian itself could do with some better defaults, but I really like the ease with which I can test against different targets. "mvn clean install -Ppayara,bundled", "mvn clean install -Pliberty,bundled", "mvn clean install -Ppayara,provided", etc That makes testing against different environments quite easy, really. 
Yeah, there's actually an [official JSON parsing API](http://www.oracle.com/technetwork/articles/java/json-1973242.html) (AFAIK), but you can basically use whatever you want.
Did you use time machine to get into 2017 from 2005? Otherwise, you just don't give a sh#% what spring framework is. 
And off by one errors, that's the second one
It's called EE4J, and the next version might be EE4J 18.3. (or EE4J Oxygen?) 🙄
&gt; Java EE Stop calling it that. It's called EE4J nowadays
I know. We should let people get used with the new name for some time. However, I would prefer EE4J 1.0
Yeah but not that hard, they’ve named it after the single biggest java project in existence. It’s retarded.
Why did you just do it?
What’s clever about it? 
I think it needs another Eclipse somewhere in there
Classloading has not changed in Java 9. Per Mark Reinhold [here](https://youtu.be/fxB9cVNcyZo?t=26m20s)
Oh god, no.
No thanks. I like the old name better.
Real men use Emacs.
If you are starting from scratch and lets join hands. I have worked on nodejs and java stack. 
Best think is to use AKAMAI. It can do all the transformations on the video and provide locking functionality too. I worked with AZURE video hosting in the past (its a kind of mess with so many API's to invoke for particular work). 
"Eclipse IDE for Eclipse Enterprise for Eclipse Enterprise Java Developers"
The following two look promising https://github.com/alkarn/sslengine.example https://github.com/jesperdj/sslclient You can likely find more by googling "site:github.com SSLEngine"
[removed]
For me personally, one of my teachers used java to graph integrals as they were being solved. pretty neat to see it all play out visually. 
`org.eclipse.ee4j.javax.*` /s
Uninstall it
No worries. :-)
Maybe the "Eclipse IDE" will be renamed to IDE EE.
I feel like this joke is *eclipsing* the point of the article. Eh? amirite? You guys get it, right?
So now we have “IntelliJ IDEA Ultimate” to be the best IDE for developing” Eclipse Enterprise for Java” apps. And Apache Tomcat the Eclipse Enterprise for Java app server. Yay! Eclipse is truly everywhere!
I'm not smart enough to give any views on it.... Waiting for someone else 
Tomcat != Java EE app server. It implements like... 4? 5? of the JSRs in the profile. It's mostly a servlet container. ...or was, if I'm not losing it. TomEE, OTOH, is.
Well I tried with TomEE and the best I could come up with was Apache Tom Eclipse Enterprise app server... Better?
FizzBuzz Enterprise Edition
good thing they dont care
yes, a very IntelliJent joke
The Spring Framework is awesome! 
Bravo!
ohh great, more pedantic assholes can start getting mad at me when I say JEE instead of EEJ.
Minecraft. 
Run the backbone of the world financial system. High frequency trading. Google. Amazon. Aircraft control and monitoring systems. Java runs many of the most important, largest and complicated software systems in the world.
IntelliJ, which GUI is completely made with Swing!
That’s just incredible to me. Such a complex and nice looking UI. I love Swing, but I can’t imagine doing something that large and advanced with it. Fantastic work by JetBrains.
Happy Cake Day!! Edit: umm ok? cool
My comment was full of sarcasm :) Yes, if the name brings confusion then it's a bad name. There were plenty of good options and they decided for a bad option. Even "Java Enterprise Framework" would do better. Ok, if they insist about "Eclipse" in the name, let it be "Eclipse Enterprise Framework". But playing with acronyms like this - EE4J - is just ridiculous. Just one character away from EE2J - let's make all the community laugh at Java by flipping the old name. Hence, naming is hard.
&gt; Groovy support Are you implying a specific shortcoming? Groovy and Spring work very well together, in my experience.
Hmm, I guess. I was more thinking of the memory overhead of each new system thread - 1MB of stack space on an untuned JVM, and still a lot even if you trim that down to the bone. That sort of scalability concern might be a niche usecase though, especially back then. Still, you'd think that a webserver with thousands of requests per second was still something people would write in Java.
They should have called it "Sun", now that name is available.
r/2007scape
Nice
I mean, take your pick really. Java powers a ton of very impressive and/or huge projects.
Rewrite bytecode with JVMTI
&gt; GUI is completely made with Swing! Woah really? That's quite the feat.
Every year I go to a testing event with a lot of different implementations of some standard. It's really noticeable how much more trouble .NET developers have compared to those using Java, not even mentioning the odd ones using Objective C and PHP. Once I asked a .NET party for their WSDL endpoint and they were like what the heck are you talking about?
Also check out [Terasology](https://github.com/MovingBlocks/Terasology) (open source)
Get laid
I've raised a family. Pretty cool for me.
Once you grow older you will see that you don't think in languages but in programming patterns and paradigms. The syntax of the language will be your least concern, but you will still need to enter a certain mindset when you will learn something new. That being said, Java will be here for a long time, especially in the server side world. So Java EE and/or Spring will be viable career choices for the next 10 years. It's hard to predict what happens next. 
I realize that.But i feel like that will help me learn a lot of the patterns i will need to learn.I feel like i have too much general knowledge and not enough specialization on something a high salary position would require. For example , software engineer position might say "familiar with these X,Y,Z languanges/frameworks" . I can't just apply and say i know the concepts but not all the requirements. My plan is to be familiar with JavaEE and spring , then learn .Net and c# and maybe python in the future.Already know decent PHP ,core JS and C , some Azure deployment basics etc.That should cover most job positions i would be interested in.
Story time
WHO WOULD DOWN VOTE THIS WHOLESOME COMMENT
Build a never-ending high-performance cross-platform 3D game and sell it for $2.5 billion to a company that despises cross-platform software.
Am i the only one who found it humorous :D
This deserves to be higher. 
I think the career path is learn trendy web framework, develop opinions on best practices, get an Enterprise job, forced to use Java EE, switch to dotnet core because it is trendy but feels safer than JS, still maintain and integrate with legacy Java app, everything is a microservice running on a different framework on a container, no idea why it works, constantly scared and horrified for the rest of your life
Probably!
Sounds great thanks! *cries*
Eclipse Clojure jEdit 
Don't be too scared. Just learn whatever interests you the most. You'll pick up the differences on the job and in my experience, a lot of Enterprises are scrambling to modernize. They will likely be interested in you for having experience outside the Java EE world. The other poster is definitely correct though, there will be Java EE jobs for the foreseeable future so if you do learn it, it won't be for nothing.
That's the thing , i don't know what interests me the most , i love programming in general.I know what i hate and dont want to see ever again. 1.Javascript.No. 2.CSS.No.Moving boxes around feels like wasting my time.Who the hell cares.I wouldn't care if the web was black and white. 3.PHP.Seen too many idiots abuse this languange's ugly "anything will work" system that produces unreadable code So , due to the above ,and the fact that i have spent a load of time reading more advanced topics for college than the webdev camp guys , i want to utilize them to leave anything related to the front end and be a high end backend/anything else developer.I mean,whats the point of 4 years of study if i end up doing work that a hipster that read about PHP and So the logic behind my choice of JEE was -"Boring" (enterprisey) .So not a million hipsters will start learning it like JS = high demand. -Quite more complex , concept knowledge requiring , and professional than just spamming "echo" -Used by big companies = higher salary Just a guess.Am i wrong on these? Should i look into anything else? 
OP please don't disappoint. 
&gt; to a company that despises cross-platform software I guess you've been sleeping for several years then. The "company that despises cross-platform software" now runs Linux on Azure and released probably the best open-source cross-platform editor (Visual Studio Code). Also Windows 10 now runs bash on Ubuntu natively (well, it uses Hyper-V under the hood, but you don't really notice a performance difference)
Our *three* weapons are fear, surprise, and ruthless efficiency...and an almost fanatical devotion to the Pope...Oooooooooh!
Also RuneScape, back in the day. It’s native now, but it was truly amazing back in 2004-2007.
It has been a few years since the purchase.
CSS is part of every website regardless of framework. It's not a programming language. You should be comfortable with it if you want to do web dev but there's tools. JavaScript, as big of a pain in the ass as it is, will always be useful even if you're using old stuff unless you're working strictly back end but the line is getting blurrier all the time. Dotnet Core might be a good compromise for you. C# is close enough to Java and the framework is nice to work with. Maybe use it to make a web app then use JS/Angular (or any other front end framework) to make it pretty.
oracle is in a great position to do primary research *cough*
JPA &amp; servlet is definitely worth learning - that's about all that's relevant anymore, sadly
Clojure
you can bomb about any interface that doesn't check/enforce size requirements.
Tbh i dont want to stay in webdev.It feels very insignificant , no offense , just my preference , i realize it can have very complex concepts but i dont enjoy spending time on visual adjustments.I prefer developing infrastracture , if i ever find such a job.Maybe a.i or smth. Thanks for your info
If you don't want to be in web dev, why waste your time with Java EE?
does it use hyperv under the hood? As far as I was aware they just abstracted linux syscalls to nt syscalls
Kafka/confluent is pretty awesome 
Groovy and Java EE work well together as well, as do Groovy and Play. It's because of the JVM. What did Spring do recently to explicitly support Groovy?
And we all know that its part of the strategy to embrace and extinguish. 
Make someone code-gay
Yeah. The right name was "Winter" to compete with "Spring".
There is a lot of FUD surrounding Swing. It is actually a quite nice GUI toolkit. I have no idea how it ever got a bad reputation.
Ship the Ask Toolbar to 3 billion devices™
Because you can write the backend but not have to deal with the front-end i.e. use Jersey (jax-rs implementation, part of Java EE) to build the API, then front-end developers consume your API.
That's usual, Microsoft developers live in their own ecosystem. IIS does have WSDL but they're probably steered to use some similar Microsoft protocol which their tools hook up to nicely, it wouldn't be noticed unless they have to interact with the outside world.
Need to add Jersey to that list.
&gt; high-performance i think this is the first time i've heard someone say that of minecraft
You should most definitely learn Java EE. Almost all the java frameworks out there are just a wrapper on top of JavaEE (e.g. Spring MVC, Grails, Spark, DropWizard, etc) If you don't understand what is happening under the covers then you will have a huge problem troubleshooting any issues. Also, if you start taking a look at Java EE 7 (and now 8) you might find yourself questioning why you even need a different framework. JavaEE is quite modern now and if you have experience bootstrapping a new project you can have a REST api application up and going in about 10 minutes (maybe less).
they're just a regular shitposter. it might be funny if it subverted expectations, like if james gosling said it.
Not to mention [.NET Core](https://www.microsoft.com/net/core#linuxredhat)
Really bad name, it sounds as if Java is just some sort of side job for a new Eclipse Enterprise product.
I couldn't agree with this statement more 
My understanding matches yours: Windows Subsystem for Linux does syscall translation. However, in double-checking this, I did notice that the tech is a little more complicated, and there is the possibility of shared technology: a WSL blog says that the "pico processes" used by WSL was derived from "project drawbridge" research project studying virtualization technologies. * [Windows Subsystem for Linux Overview](https://blogs.msdn.microsoft.com/wsl/2016/04/22/windows-subsystem-for-linux-overview/) * [WSL System Calls](https://blogs.msdn.microsoft.com/wsl/2016/06/08/wsl-system-calls/) * [Project Drawbridge](https://www.microsoft.com/en-us/research/project/drawbridge/) I wouldn't personally say that it uses Hyper-V, but I'd be interested in listening if a Hyper-V expert wanted to argue their view.
Is there some context to go with this? Have I been out of the loop on something?
It's all web development, whether you're in the front or the back
Might I just comment, that coming from the PHP community, it's really nice to see that the majority of these responses are really nice and supportive? So far the coolest thing I've seen in Java, is that being completely new to the java ecosystem, I could pick up [Spark](http://sparkjava.com) and [Kotlin](https://kotlinlang.org) at work on Monday (of my own volition and research, no one told me to use this stuff), and have already written a solid mission critical floating restful service to replace a failing implementation of the same API written in a completely different tech. And Kotlin let me do it all in less than half of the amount of lines and a microfraction of files as the previous implementation. That's really cool to me 
Umm, no it's not. web development = html/css/javascript
&gt; High frequency trading Is Java really used there? Isn't it too slow? (I don't mean that in the sense of the old "harr harr java apps/vm is slow".)
&gt; Once I asked a .NET party for their WSDL endpoint and they were like what the heck are you talking about? You sure they weren't talking about the WSDL part? :P
Make sure to read the _entire_ Java 9 migration guide: https://docs.oracle.com/javase/9/migrate/toc.htm#JSMIG-GUID-7744EF96-5899-4FB2-B34E-86D49B2E89B6 The only problem I ran into was not being able to add the java.xml.bind module to an application started with Java Web Start. --add-modules is not a VM parameter supported by the java-vm-arg attribute of the java tag in a JNLP. I fixed it by just including a JAXB implementation in my app (like you had to do pre java 1.6). 
Go without an IDE for the very simple examples at the start. Part of the lesson is learning what the javac command is and how to run an app with the java command. Once you get beyond simple, single file classes move to an IDE. Learn the basics of your chosen IDE and make a note of how it does compilation compared to doing it on your own. Once you're comfortable with an IDE, start looking into build tools like [Maven](https://maven.apache.org/) or [Gradle](https://gradle.org/). Eventually you want your code to be decoupled from your IDE; following the conventions of your chosen build tool lets other people compile and run your projects without having to fire up an IDE. This is a must in the professional world.
Spring and Dropwizard are all just a wrapper on top of JavaEE.
nothing that I'm aware of. I've been writing Spring apps in groovy for a couple of years. It all compiles to byte code. What do you think *doesn't* work in Spring?
Server side is still considered web development where I'm at, I don't know what you're basing that on.
I can make a good solid guess that 95+% of bank software is Cobol, Java, or c#. There might be some outside cases, but even the last trading shop I worked at used java to communicate with the markets.
Because there was/is too much damned assembly required. 
I'd suggest you go straight to Eclipse. It doesn't make much sense to me to learn Java in Notepad without learning the "tools" surrounding it. Also 80% of this sub will tell you to use IntelliJ instead of Eclipse.
I hope I will come back here. 
Oddly, there was a build, and I have a copy, but it's no longer where I got it from.
Because many devs never bothered to read books like "Filthy Rich Clients", never used nice UI component libraries, switching to native L&amp;F, always implemented everything in the UI thread.
That is obvious, but if I use library XYZ to just read the size of the image is it attempting to pull in the whole file or just a portion.
The performance difference between Java and C++ has been closing for years. We're easily at the point where algorithmic performance outstrips language choice in performance impact.
_Filthy Rich Clients_ by Chet Haase and Romain Guy and _Swing Hacks Tips and Tools for building Killer GUIs_ by Joshua Marinacci and Chris Adamson are two books every Swing developer should have. 
throw new FizzBuzzBuilderFactoryException();
Yes, package names of existing spec are not going to change.
can confirm it's used for HFT. Java is amazingly fast these days.
Ever try memory-mapped I/O in Java? Smart use of I/O and careful management of memory brings Java into the same performance field as native languages.
It needs Hyper-V to run, I guess there is a reason behind it.
It gave the computer lab admins at my middle school so much grief.
The only thing they seem to extinguish while doing that is the image of Apple as a company providing the best tools for web developers. And Apple lately isn't doing anything to make MS work harder.
More importantly, multiple threads and multi-cored machines and VM's.
Best reply. 
java's changing to a 6 month release schedule and timed releases. so the next version of java will be 18.3, indicating the year and month the release was made. 
because i really dont know what job i could go for that utilizes my cs and leads to high salaries.I saw in most charts that java is the most paid ,then i saw that almost all.java is either android or enterprise.And i dont like android/mobile phone dev in general so..enterprise
!Remindme 24 hours 
You should just apply to every Junior Developer job you see. Even better if you're not tied to a specific location.
Thanks.I am definitely a fan of learning how things work underneath.I also like to do it the stable/official way instead of hip experimental frameworks
It's the other way around, why is Spring so ahead of the curve because they support other JVM languages like Kotlin and Groovy, while it all compiles to byte code anyway. Why do you think those would not work with EE? Why is Spring supposedly ahead there?
True, that. Fit all those techniques together, and you can make a machine *sing* with Java. That being said, these are also the areas where the real differences across JVM implementations become apparent.
You mean developers actually need to write code? Say it isn't so!
Great.Thanks for your help.Junior developer positions here are all php wordpress garbage ,ill try to find things as far away from css as possible.Ill look into making good resumes and spam everywhere
doesn't GC cause you issues? what pause times do you manage to achieve, and how?
What does the docs (or source) for library XYZ say?!? edit: I don't know why an image library would be expected to sanitize input from the web for that matter.
&gt; Once I asked a .NET party for their WSDL endpoint and they were like what the heck are you talking about? This doesn't seem like a bad thing to me. I feel SOAP is better off being forgotten. Surely you aren't still hoping someone provides you a WSDL these days are you? I can't imagine anyone is doing any new projects with SOAP. 
The thing you have to consider is the hardware budget of a high dollar trading firm. We trade so fast and upgrade so quickly the SEC can never keep up. Every server these days has close to 12 physical cores with up to 64BG of RAM. SSDs reduce a lot of GC latencies.
I'm wondering why Reactor doesn't follow semantic versioning. This release should have been 4.0. 
Probably square space 
Of course you can add tags to the HttpBeat conf file and filter based on them :)
you won't have to wait long, targeted for springone timeframe
How can I make something that looks like that with Swing?
SWT
in what way do you think it lags behind the competition, exactly? Please substantiate that bold claim.
The graphics aren't detailed, but there's quite a lot of blocks in a scene, and it's all dynamic and illuminated. Before MCPE's [cave culling](https://tomcc.github.io/2014/08/31/visibility-1.html) algorithm they had to draw all those hidden caves too. Partly it reminded me of a C voxel project of mine that ran much slower doing a lot less (albeit on old hardware, ~14 years ago). I had to combine adjacent blocks into long rectangular strips to get playable performance, with a much simpler scene, and you can't do much of that when every block has different lighting and textures.
hm... that's super misleading. Spring has had reactive style methods for some time. But having asych style API built on a blocking / synchronous runtime isn't even close to being reactive. Spring has rebuilt over a period of 2+ years atop a natively reactive stack, so it's fully reactive from the ground up.
Can you expand on how an SSD impacts GC latencies? Unless you're swapping - I am not sure how that would have an impact. (Legitimately curious!)
how, exactly? Curious to see you offer evidence.
This is JVM, not Java, but still: https://aphyr.com/posts/341-hexing-the-technical-interview
But do your children run Java? JavaCE (Child edition). Parenting via interface implementation. Aaaaand it got super creepy and I'm gonna stop :') 
There is a difference between writing code and writing boilerplate. Java in general but swing in particular is VERY good at making you write boilerplate. (yes I know you can generate a lot of things but that's not the point here) 
it's not you, Java EE has always been very difficult to test. that's a big part of why Spring became popular circa 2004, the ease of testing / DI container. Since Java EE hasn't changed at all regarding testing in the decade following, it's still true....
I don't think much about Java EE's support for Kotlin is widely known. Why don't you tell us about it, and someone can respond intelligently?
I don't understand why this was downvoted 
aquillian is nice, but it's not part of Java EE / EE4J
I’ve personally automated warehouses with JavaEE. It was hot, sweaty work, but I’ll be damned if watching it hit prod and actually work wasn’t incredibly satisfying. Yes, that’s automating multiple warehouses with one single software solution. It even played with SAP. 
reactive isn't for everyone or all use cases. No one Spring is saying that. Quite the opposite, in fact. But for the people that need it it's going to be quite important. 
Sounds like relocating is a good idea. I'm on the East coast and Junior Dev is usually Java or C#.
&gt; Chet Haase and Romain Guy Huh, I know those names. Pretty cool that they're still working together on something different at a different company after all this time. (For those who don't know, they're key Android engineers now)
I'm not sure if this is still common practice, but at one point, you'd work around GC issues by "object pooling"; basically, `new` up all of the objects you need at VM startup, and then never call `new` again.
re:imageIO the max pixels, for bufferedImage anyway, appear to be MaxInt, so spark.png won't run it out of memory, but still 2gig is a big chunk, multiply by color depth. But the IHDR is easy to parse in a png if you want to do some checking before handing it off (i.e. it passed the filesize limit, but now you want to enforce memory usage limits). If you run the code snippet here on spark.png (which treats it as a stream, still using imageIO) it returns in about 70ms with: 225000 225000. It returns that fast on a tiny png as well. https://stackoverflow.com/questions/1559253/java-imageio-getting-image-dimensions-without-reading-the-entire-file other formats may have tags though, so parsers might choke, but png is just blocks.
Is that what terminating child processes really means? :S
I’m all for writing code. Boilerplate is another thing entirely. 
big bang releases that take years to surface are anti-pattern in modern open source, particularly for bigger ecosystems / projects. Java SE is already moving to a faster release cadence. 
Notch coding a old school dungeon crawler for Ludum Dare https://www.youtube.com/watch?v=rhN35bGvM8c (Prelude of the Chambered) I can't locate part 2 anywhere anymore...
Yeah I expect that to be a problem for scala as well. As java adds features, they won't match up 1:1 with the equivalent features in the "better javas". So, these languages have to either break their own features to re-align them with java or watch their "seamless" compatibility story slowly degrade.
Nice
Spring will build on Servlet and JPA until there are better options, those are the only specs that remains relevant these days, unless you are using an EE server, which then makes CDI and JAX-RS relevant. Full Profile gives way to Web Profile, and community members are working on a "microprofile" which is basically 3 specs: JAX-RS + CDI + JSON-P, which appears to ignore data access / JPA. The rest of it has become irrelevant. Spring builds on those remaining relevant APIs like JPA/Servlet and addresses entire workloads that Java EE does not and likely never will: microservices, reactive, big data, noSQL... so yeah, if you aspire to doing any modern Java development, that "wrapper" provides a lot of value
Spring builds on Servlet primarily. But that's kinda like saying Java EE is a wrapper around java.lang.object
It's vapid.
Yeah, I suppose that's true. I wouldn't mind if it was my cake day and someone said something, and it's not really hurting anyone else to see it. But I suppose I understand 
I think "Fall" would be fitting (in more than one way).
How about renaming to TomBstone? Would be fitting in the Eclipse graveyard.
Not sure if I understand the question. The entire point was there's no specific support needed, since by virtue of the JVM it "Just Runs" anyway. The poster above basically said that about Groovy. So I'm not sure what special support Spring offers for Kotlin anyway, and why that is needed. Nobody here has explained that to me yet. Maybe there's a good reason that Kotlin needs special support, but I haven't heard yet what that support exactly is. But that does bring me to my second point. Kotlin is quite new, it's cool, sure, but will it catch on? How many languages have we seen in the past that were quite cool but never captured more than a tiny niche, if they captured that at all and not just vanished. So Spring now jumped on Kotlin, perhaps since it's a bit "En Vogue", but will you keep supporting it 5 years from now? Will it even make sense to have Kotlin support 5 years from now? And what about 10 years? How many of your users are actually using Spring with Kotlin? According to the recent JRebel survey, which historically has always showed a small bias towards Spring (not saying they are biased, but many respondents happen to be using Spring), the interest in Kotlin (and other alternative JVM languages) is low. Really low. 
Yeah No. That's C++ on realtime operating systems. And since these systems have a really heavy technical baggage, it's not going to switch to Java anytime soon. From what I know, it's still really hard to achieve determinism under a JVM.
RemindMe! 1 day 
I will be messaging you on [**2017-09-30 22:04:42 UTC**](http://www.wolframalpha.com/input/?i=2017-09-30 22:04:42 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/java/comments/737sst/what_is_the_coolest_thing_you_seen_someone_do/dnoyz3e) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/java/comments/737sst/what_is_the_coolest_thing_you_seen_someone_do/dnoyz3e]%0A%0ARemindMe! 1 day ) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! dnoyzb2) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
Up to, or waaaaay beyond 64gb.
&gt; hm... that's super misleading. Why? The GP said "Asynchronous methods", as a response to being asked "Which improvements in Java EE are the ones that made the GP feels like he of she is stuck years behind in terms of improvements that could be made [in Java EE]" So apparently for "Asynchronous methods" Java EE is years behind, to which I responded it's not. It has plenty of asynchronous and parellel executing constructs (I didn't even mention all of them). Then my *next* reply was about the claim "Java EE is not fully reactive", to which I didn't reply at all that async APIs are close to being reactive. I just asked if Java EE should even BE reactive. Reactive has been around for some time. Heck, even .NET's Rx library which was advocated for Windows Phone 7 and Silverlight(!) wasn't particular new, so the pattern clearly has some staying power. But point 1; Spring isn't that innovative or modern here either. It follows what other frameworks have been doing for a long time. So criticising Java EE for being "years behind" is a bit of a pot and kettle story, since Spring is then "years behind" just as well. Point 2 however is that Reactive is not quite the silver bullet. It's not the universally better way to do things. State is often spread throughout the program and can be hard to track or access even. If you update from an older stage to a new stage, the state embedded within the entire reactive system can be lost. This can be problematic, really. Global limits can be hard to enforce as well. Blocking (timed) calls are actually a damn and easy cutoff point; if the blocking call times out, drop the action. This makes graceful degradation quite a bit more straightforward. For signal processing, reactive may be a good idea. For hard core processing or even transaction processing where transactions may be dropped if needed (to maintain system integrity), I'd rather not use reactive. Purely natively reactive, is also a bit of an unclear term. Is it focussing on time varying data? Or is it event streaming? (p.s. when I was young, which is -cough- a looong time ago, I did my thesis on dataflow languages, which is actually a pre-cursor or at least a related field to reactive, which dates way back)
You forget CDI, Java EE Security, Bean Validation, Interceptors, Expression Language and of course JAX-R, among others. All of these are HIGHLY relevant in modern applications.
I tried a bunch of different UI libraries for Java, the original JavaFX being the only one to really impress me, but I always found myself coming back to Swing. It just worked and had everything I needed. Cumbersome, but effective.
At JavaOne years ago, the cart of an inverted pendulum. I think it was the Sun guys. 
Java Extended
Some of those dating sites have got to be running on the JVM.
I believe a lot of them use [Azul’s Zing JVM](https://www.azul.com/products/zing/pgc/) and techniques that minimize garbage creation. Check out [LMAX disruptor](https://martinfowler.com/articles/lmax.html) for example. 
Genuinely RuneScape, specifically RS2. I can't imagine developing an MMO back in the early 2000s with such a small team and of such popularity and in-game size. Seriously impressive feat, I feel like as developers today we get it incredibly easy compared to those that came before us. I'd really like to know all the ins and outs of their codebase.
I personally do love all game engines from LibGDX and LWJGL to jMonkeyEngine
Android
ThinMatrix on YouTube is developing a game (Equillinox) in Java and LWJGL. Pretty cool concept, and an extremely beautiful low poly game.
wow this thing is still alive? been a while since 2012-13
yes, java moving to a timed release system is definitely yay. might help with some of the feature delays we've been seeing with the likes of java 9, and might help stuff like tail recursion finally get added
Noobie question here: what do you mean when you say "it's native"? I've seen people use that term when referring to tech but never bothered to look it up. Do you mean like "easy to create now but impressive/difficult back then"?
Software in general is too slow for latency sensitive trading anymore. Anything that cares about latency is a hybrid hardware/software system. Java is plenty fast to handle the software side of those systems and you get the typical Java advantages to boot.
It's a windows client now. Native typically means bare metal compilation to machine code. This is distinct from bytecode which is a halfway point interpreted to native code by the JVM, CLR, etc. 
I'll just use JavaFX thanks
OS X and iOS uses swift / objective-c for its "native" language. Windows uses C# as its "native" language. *nix systems use C as it's native language. If you want to write an app that works on all OS's then you would have to write 3 separate apps in each separate native language. This is suuuuper time and money consuming. Java came into play by bridging all OS's with the JVM, that way you can write one non-native app in java and it will work on all OS's. EDIT : My definition of "Native" was that it was the primary language of development paired with OS. Top Google definition of "Native" is the following. &gt; Native code is computer programming (code) that is compiled to run with a particular processor (such as an Intel x86-class processor) and its set of instructions. Turns out my definition sucked thus I now understand the downvotes.
Java compiles to bytecode (sort of like machine code) but because that bytecode isn't x86 (or whatever architecture your CPU is), Java needs a virtual machine, the JVM, to run. Because it needs that virtual machine, Java does not run "natively" (ie. on its own). This is also the case for many other languages such as Python which requires the user (not just the developer) to install Python on their computer. On the other hand, languages like C, C++, and Rust all compile to actual machine code for your computer's CPU which is probably x86. Because that machine code is the one directly supported by your processor, the program needs no virtual machine to run. When this is the case, the problem is said to run "natively". There are advantages to both options which is why some languages are native, some use a virtual machine/interpreter/JIT, and a few support both. 
Nice
Uninstall it
Reporting in
Why is this being downvoted? Isn't this true?
GMail web app - JAVA backend with JS front 
Kotlin probably will a harder problem than Scala, because they need to keep Android compatibility while running in modern JVM 's. Scala never really invested in Android, while for kotlin is a major selling point. I wonder if Google will help intellij, since they have officially adopted Android.
That was fun to learn in college. Really made me think differently about programming while using the functional paradigm. 
C# is not "native"...
You got downvoted but you are not wrong. Except for the realtime os part which I've never seen in finance. There is a lot of financial software in Java, but the key HFT components are either C/C++ or they are in FPGAs. 
¯\\_(ツ)_/¯ Didn't even notice the downvotes till you noticed! I'm betting it's because I named the technologies that must not be named.
Is it sad that this has helped me grock spring better than spring tutorials I’ve found online? I mean, it’s not the easiest to follow, but it works better for me at times.
Kotlin
first, javaee is a spec, not really a thing to 'wrap'. spring uses a servlet impl in it's classic mvc setup (as a 'front controller'). there's some jpa stuff, but really jpa is hibernate-as-a-spec (or was). it's a bit silly to turn that into 'spring is just a wrapper on javaee'. the new webflux based on reactor can use optionally servlet 3.1 async or something else like netty or undertow (xnio).
It's being down-voted because it's not correct.
What's not correct about it?
not sure, i think you maybe are misreading 'biased'. bias in statistics and surveys isn't a personal thing, it's a characteristic of data or process. it's not a personal attack and not something to get defensive over.
https://duckduckgo.com/?q=native+vs+managed+code&amp;ia=qa Edit: Sorry to dump a link on you, but there's a ton of resources that already explain it. If you're genuinely curious, a few of the top links in that search results will explain.
The definition provided centers around the OS vendor choosing what is "native" to the platform. That is simply not true. "Native" code refers to something that compiles to your CPUs instruction set and, generally, isn't GC'd. C/C++ is native on OSX/Win/GNU+Linux. C# compiles to bytecode and is run on the CLR (thought IIRC there is a native compilation option, maybe?).
&gt; "Native" code refers to something that compiles to your CPUs instruction set and, generally, isn't GC'd. I would leave out the part about garbage collection. There are lots of GC'd languages out there that compile native binaries: Go, Ocaml, Haskell, various LISPs...
I would say beyond even 128GB. Some back bone stuff really loooves to chew the memory. 
I'm very well aware of that fact, but for some people ASM is only one part of the definition. This is why I opted to use the word "generally," but maybe I should have chose "sometimes" or "in some circles."
No, G1 gc in java 8+ has almost no pause and can handle huge amount of objects, we run it in production under super high volume and it's so much better than CMS gc. It's so good, it's the default gc in java 9.
This is highly inefficient, the GC technology has come a long way in the last 20+ years.
It's scary that the biggest innovator in the Java database space has such poor understanding of random processes and independent samples that he doesn't realize this survey is garbage
While blind “object pooling” may be inefficient, where you just have an arbitrary pool of objects that you are acquiring and releasing somewhat randomly as though it were a connection pool, re-use of preallocated objects in the right context is plenty efficient. For example, if you have a bunch of worker threads that all operate on a single “message” type whose data comes off the network, rather than “new-ing” that object for every new message you could simply read the data from a ByteBuffer into an already allocated object for that thread. This kind of thing is very plenty efficient, and used in high performance situations; [LMAX Disruptor](https://lmax-exchange.github.io/disruptor/) for instance, allows the objects in its ring buffer to be preallocated. 
Yeah, this is the part that Java HFT evangelists (of which I am one) tend to ignore. Java is used in very high speed trading environments, but the true HFTs that are pure speed plays are barely doing anything in software, even C++ might not be sufficient. 
Maybe they are, since they have access to the largest Twitter followership of Java developers. @java.:-)
No it's because it's just plain wrong. C# isn't native for one. C would be native on all OS's. C# and Java run on a virtual machine, with managed memory.
Don't store things on the heap. Check out chronicle for an example.
Hi, any similar books about JavaFX? Also, is JavaFX any good compared to Swing?
And they still don't allow dual booting in Windows License. And they still give "discounts" to OEMs that don't sell Linux preinstalled. And they still have SecureBoot, where Microsoft has to sign Linux kernel for it to boot, or SecureBoot must be disabled. Maybe they just hate Linux/*BSD, not cross-platform software?
&gt; No it's because it's just plain wrong. I proudly stand corrected for my definition was far off from true. &gt; C would be native on all OS's. No argument to that :thumbs:. But to be pedantic, it is native on unix (and the like) systems. &gt; C# and Java run on a virtual machine, with managed memory. Idk, if memory management (bidirectionally) implies native though. From what I read, a language that compiles to opcode is Native. Im no compiler or language implementation expert, but I feel as though memory management can be a compilation feature. 
What? I know C is native on Unix, it's native on all OS's with a compiler available. Java/c# are definitely not native. One of their distinguishing features is no need to manually manage memory. 
Build Spotify, GrubHub, Netflix, etc.
Yes, I run it in prod under heavy load, but still run an average of 30ms with occasional spikes to 3 figures. Getting to this took some work. This amount of GC pausing seems too much for HFT, so was wondering what in particular people are doing 
&gt; what the heck are you talking about? My sentiments exactly. REST all the way in modern times.
The purpose is for libraries only, you still need to use java command, giving the .so as input., via -XX:AOTLibrary. http://openjdk.java.net/jeps/295 Java 10 improves this, and project Metropolis with SubstrateVM offers actuall AOT without requiring the java driver command. If you really want pure binaries, you still need a commercial JDK like ExcelsiorJET. 
Fewer files is not necessarily better...
Tell that to my ElasticSearch cluster. =(
Minecraft
It also has a Linux and Mac client now. Please stop this paid shilling of Windows here.
No, those are shaders, not Java.
I didn't know that because I don't own a map and would never game on Linux. Your first conclusion is paid shill? Have fun being crazy dude
**Sidebar** -&gt; # Do not post tutorials here! First warning!
All of that is just means to satisfy companies running their software on Linux and developers needing real tools for their work. Microsoft is just desperately trying to stay relevant. Other than that, there is not much that they are contributing to open source software. You could consider them more like a cancer. They just like to leech from others till they die.
Now that I believe that JavaEE was losing its bad reputation, it will all be back to the same, many people just associate Eclipse with the ide, (I'm one of them, I know there is more stuff there) and Eclipse has its own fame of slow and bad too. Is there any way we can pressure or show our concern about this bad naming decision? Why not keeping JavaEE? 
I like Spark a lot, it's really fast to prototype applications. Cool to see that you don't miss Laravel &amp; Co. 
I think Hazelcast is pretty awesome.
[removed]
So you are openly saying that the only relevant platform in your opinion is Windows ? Cannot get more crazy than that really.
It appears our AutoModerator decided this post is "code help". I don't quite agree, but still think this topic would be better suited to /r/learnjava or /r/javahelp. Are you OK with reposting it there?
Senior Dev spotted ^^^ 
I know you're just joking but I'm not even tangentially related to tech, I'm a pharmaceutical dude.
That's cool. What brings you to a Java sub?
Used to mess with computers as a hobby. I suppose it's still related because programs like marvinJS are written in Java, it's useful for a lot of physiochemical calculations, but that's probably still best left to compsci people who have been handed physiochemical mathematics. It's crazy the kinds of calculations we can make about organic molecules thanks to computers, it's pretty much the entire basis for modern drug development.
Whoa damn that's awesome I never knew that. That's really cool thanks for teaching me something new!
I know gay.com was waaaaaaaaay back in early 2000s.
Yes, it's in active development.
still exist .. but slowly fading
plus mature ORM like Hibernate
Are you sure? The name marvinJS implies that it's written in JavaScript, not Java?
Shrinking from about 89 non vendor source files to 1 400 line source file and a couple thin classes, all while accomplishing the same exact i/o is a massive improvement in the developer experience for the person who has to take it over from me Indeed muxing together source files into one does not an improvement make by itself, but rather in how hat merge is being utilized that does 
I'm a huge fan of the Sinatra pattern that Spark uses Speaking of the php side, I don't need to miss them as I still use them every day, and happily so. Though I'm not a Laravel user, I'm a Symfony aficionado ;) 
&gt;c++ They're called *ELF* binaries. It has nothing to do with the language they were compiled from.
The original version is Java. Maybe they use GWT?
.NET Native, IL2CPP, CoreRT, Bartok, System C#. Some learning material for you.
There are Java and C# native compilers without need for VM. On UWP and Xamarin iOS, C# is always compiled to native code.
Go, D, Haskell, OCaml and Dart 2.0 are native and have a GC. C# is only available in native code for iOS and UWP. There are plenty of AOT native compilers for Java, even OpenJDK has added some support for it. Long term plan is to replace C++ with AOT Java on the OpenJDK, known as Project Metropolis.
&gt; If you really want pure binaries, you still need a commercial JDK like ExcelsiorJET. Clarification: Excelsior JET Standard Edition is free even for commercial use. Authors of _public_ non-commercial projects can apply for free Professional/Enterprise licenses. https://www.excelsiorjet.com/free Disclaimer: I work for Excelsior.
This is correct, my apologies, MarvinJS is their barely useful web version :D
I have never worked on a Java EE project where it wasn't expected everyone to be skilful at all levels.
Control real life process with [Ignition](https://www.inductiveautomation.com/)
&gt; you don't think in languages but in programming patterns and paradigms True, but sadly people hiring you will think of specific languages, frameworks, libraries and tools.
AFAIK at least for OSRS they still use Java for the backend and RuneScript their proprietary scripting language for the content? I think the client also has CS2 (another proprietary scriting language) for scripting, like interfaces.
He may be crazy, but you know what isn't crazy? Gaming on Linux. I actually end up gaming more on Linux than Windows because it makes me appreciate that games run because of my games that don't run. I've been playing a ton of Day of Infamy, Insurgency, Saints Row 2, 3, 4, Gat out of Hell, CSGO, TF2, etc. Hell, Wine even allows for games like League of Legends, Call of Duty (at least the first 5 or 6 of them), Grand Theft Autos before IV, and many more games to run fine. Linux gaming is actually a lot better than it used to be although I've had few issues running games on Linux since I first tried in 2014. In fact, a lot of bugs that are present in Windows games are actually present in Linux too - it's quite funny to see. I loved Windows and I have extensively used both Linux and Windows as a sysadmin before, but Windows 10 large spying, forced service packs and more have pushed me over the edge to Linux. Still, that guy is dumb as hell for thinking that anyone who likes Windows is a shill. lmao
Holy shit, that actually looks awesome. How does it compare to mine-test feature-wise and maturity-wise?
I wouldn't go so far as to say gaming on Linux is crazy. It's more that it seems a lot more convenient on windows. I'm fully aware of it's ability to do so but like...dude wine is a pain in the ass. I've enjoyed Win7 since it came out, and will continue to use it until it's fully EOL. Then I might...go to only linux instead of dual boot. As far as the same bugs being present it used to be waaay funnier. Windows used to have the authenticity check for software, and it totally used to pass it. Using IE. In Wine. Most of the games I play are blizz games (working with the blizzard-agent in wine is a fucking nightmare I remember that distinctly) or AAA modern titles. So real talk: have the wireless nic drivers gotten better? It's the reason debian isn't on my laptop right now. The drivers like a year ago were absolutely awful for 2 different internal high-end cards. Basically had to put the laptops next to the router to get a connection.
Wine actually isn't that bad. With Lutris, it's literally all graphical interfaces with zero command line interaction required. Steam is dead simple as well and 32% of my Steam library works on Linux - that's not a lot, but I am someone who was pretty much an only-Windows gamer and I have a decent number of games so I am left with quite a lot of games that work fantastic, and some games even run better on Linux than Windows. I do understand Linux is not for everyone but it's honestly pretty good for gaming these days.
Well I'm somewhere between a software engineer and infosec monkey. So Linux is for me just you know...on a box in a dc..and headless haha
Weird. That shit is weird. I withdraw my claim. One is a transpiler technically though isn't it? So you know a lot about this it seems. Does the C# AOT toolchain just run the last step on the CLR beforehand? Like does it still compile through the same route just....beforehand
&gt; Other than that, there is not much that they are contributing to open source software. More than 99.9% of loudmouths, I'd say I guess some people just need someone to hate. Be it Jews, Blacks, Russians, Chinese. Or just Microsoft, since it's 100% politically correct, especially in geek circles. They are just a company, and guess what - they are on the market for 30 years and still trying to stay relevant. How dare they... Can't they just die? We all would live so happily thereafter. edit: I find it absolutely ironic that people with this attitude even exist in a community devoted to a language which is practically owned by the worst example of caricature "Greedy Corp." named Oracle. One would think Java developers, unlike Python hippies, have more practical mindset. OTOH, I'm not sure if most people commenting here and downvoting me actually make a living by writing software.
Yeah, OSRS is the original code base. I think the client just bundles a JVM, like Minecraft does. The whole engine is Java, with a scripting interface exposed to make content development easier, iirc.
Ah, I see. Linux can look quite nice as a desktop: https://i.imgur.com/yDvk5fl.png I also have some home and cloud/VPS Linux servers, of course. :)
&gt; And they still give "discounts" to OEMs that don't sell Linux preinstalled. Oh. How could they. "Please, customers, don't walk away from us, we gonna give you a discount!". Only Satan himself could come up with something like that! &gt; or SecureBoot must be disabled That's right. You can, uh, disable it. Or use it, in case you want to be sure that your system, including boot loader, loads only signed code on startup - you can even use DKMS to compile signed modules, and add your own certificate to MB CMOS (I can do this on my MB at least). Now you have a choice - whenever to use all of these (plus TPM as LUKS key storage) or not. Ain't it terrible having more choices?
Watching my favourite French man create and maintain the fastest csv parser SimpleFlatMapper :)
Compiling to C++ is just a shortcut, a way to avoid writing a compiler backend. There is some info regarding .NET Native. https://channel9.msdn.com/Shows/Going+Deep/Inside-NET-Native https://docs.microsoft.com/en-us/dotnet/framework/net-native/net-native-and-compilation Also .NET could always bet AOT compiled to native code via NGEN, but apparently many fail to learn how to use it.
Yes, I'm fine with that. I tried to last night, however I kept getting an error. But I'm going to try again now. 
&gt; One would think Java developers, unlike Python hippies, have more practical mindset. Most Java developers don't really like Oracle too. Which is kinda different to the .NET and Swift / Objective-C people, that often have an overly positive image of the "host" company. I think thats why the Java ecosystem has faned out in JVM implementations, JVM languages, toooling, 3rd party libraries / frameworks and openource. `Not Oracle if possible`.
Which has been backseated by the new Minecraft. Minecraft is dead, long live Minecraft.
Thank you! I had uninstalled Minecraft recently after learning it is on the road to be extinguished. This may become my new Minecraft. Thank you so much. :-)
That was some grotesque offspring of functional and assembly. I'm unsure if I should be impressed or repulsed.
Rising World is cool. Hoping it becomes the new generation style Minecraft. https://www.rising-world.net/
Sounds like a Kotlin Ad, no thanks.
More SPAM from the JetBrains crowd.
Rising World FTW. jMonkeyEngine put to great use.
This is just as meaningful and productive as carpenters building religious cults or hate clubs around axe and saw manufacturers. If not for Oracle - 90% of Java developers would lose their jobs. Oracle is *the* reason why Java is so popular in enterprise after 20 years. What you or someone else feels about this is completely irrelevant to the facts.
Theres a new Minecraft? 
or *PE*, or *Mach-O*
This thread took a dark turn...
I have much the similar problem, not knowing what technologies and languages I should focus on. Personally hate front end development as well, but since I live in a fairly low tech area without much options as far as relocating, I feel forced into it. Everyone needs a website after all!
How long does approval for free licenses take? Also, does it support kotlin?
I want to ask the very fundamental question of getting started with a Java RESTful API project structure. &amp;nbsp; My development background is in .NET. Let me start with describing how .NET projects are structured. In .NET projects (called Visual Studio Solutions), there usually are at least TWO types of sub-projects in my application. * “Services” (i.e., Data Repository &amp; Business Logic classes, etc) — depending on my needs, I may have a lightweight ORM (or) full-blown ORM like Hibernate. Data Transfer Objects (DTOs) are declared in this project or in another project as POCOs (equivalent to POJOs). I guess you could say it is similar to an EJB project. * Web App — configure Dependency Injection and Component Lifecycles (i.e., Instance per Request, Singleton, etc) in my Web App project from a bootstrap class. This also has my RESTful API controllers, and the service classes get injected via the DI Container of my choice. &amp;nbsp; **The question I have** is how can I setup a barebone Java RESTful API project structure using Maven with basic CRUD for a single table (say `Customer` Table). &amp;nbsp; The biggest problem that I am having is unfamiliarity with a Java project structure and Java frameworks. I have some basic understanding of Maven, EJBs, packaging types (ear, war, jar), Java Specs (like how Jersey is reference implementation of JAX-RS). &amp;nbsp; I have looked for a very simple project structure, and I could not find one on the Internet. The projects generated by Maven are not helpful either. What I want is multimodule project that uses a simple light weight ORM to deserialize JDBC result set into POJO. I don’t want to use a heavy ORM framework like Hibernate. &amp;nbsp; Can someone help me please so I can learn the rest on my own?
Learn Spring. I’ve been building enterprise-scale systems based on Java EE since the early 2000’s. At one point, I was an advocate for EE6. But the reality is that Spring has emerged as leading enterprise framework. Some parts of Java EE are available with Spring, e.g. JPA. Other parts have analogous concepts. For example CDI in EE is shares similar concepts with Spring’s core dependency injection. As a technical leader, when I’m looking to hire someone, I’m looking for critical thinking, passion, the ability to solve problems, and fundamental grasp software concepts. Knowing the particular frameworks or even language my company uses is just a bonus. The best thing you can do to prepare yourself for job is to show you are capable of being an engineer... not just a hack. Go solve a problem, build a game, contribute to something open source. Learn to communicate clearly. 
&gt; The entire point was there's no specific support needed, since by virtue of the JVM it "Just Runs" anyway. this is a red herring. when talking about spring support for kotlin, spring has for example added apis, annotations to improve experience with kotlin null-safety, added extension functions and other items to use spring in kotlin an idiomatic way, etc. there's some info here, if you're actually curious: https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0 https://spring.io/blog/2017/08/01/spring-framework-5-kotlin-apis-the-functional-way 
Eh? I mean maybe a bit of context? The previous implementation was made with PHP 7.1 on top of ReactPHP (a non blocking I/o lib for php). ReactPHP essentially lets you run scripts like you would Python (wsgi) or NodeJS. Indeed this was done because we are s php team that have decided to do the whole microservice thing. Turns out, php ain't amazing on its own for that kind of thing, as you'd have to throw a server technology like Apache or Nginx in front to manage the traffic threads and initial routing, adding overhead. We'd settled on Python with Falcon for our APIs for a while but the tech just never really clicked. No one liked using Python and we were getting slowly disappointed with the awkwardly designed and poor performing official libraries and modules. Eventually some members of my team started looking into Node and Go. But the thing about those languages is that they suffer the problem of lib and vendor immaturity for critical requirements ReactPHP was my attempt to write a php microservice without server overhead, making it compatible with our workflow using a language we're all familiar with (and indeed, like). But I had to write a micro framework around it, as using react for a restful API wasn't the easiest thing to do in a traditionally blocking and stateless language. This is the reason for the bunch of files. It wasn't until I'd already pushed the project to prod to power a critical service for a high traffic site that I noticed some fine print: ReactPHP was not intended for production, at this time. It is a toy library. Nonetheless it held up to the traffic which was impressive. The problem was that if anything was less than ideal, react would fall over and die. Even when using kubernetes to auto manage, scale, and restart multiple containers of it, if for example our DB (Couchbase) took a tad too long to respond, react would timeout and fall over. This is when I discovered exactly how non configurable the react stuff was. The thing with Spark is I love the Sinatra microframework pattern for restful API's and indeed is that frameworks primary purpose. What I like about the Java ecosystem is the mature and battle tested libraries of mission critical tech we use (and indeed some of those, like Couchbase and Elasticsearch, are natively supported with Java SDK's, where PHP, Node, Python, and especially Go had "officially supported" third party libraries, or in Couchbase case: officially created but awful versions of its SDK) The thing I love about Kotlin is that it looks to me, is that syntax that lets me inline a whole lot of Java in one clean easy to read line. `Gson().toJson(mapOf("status" to "ok", "posts" to posts))` and `class Response(var status:String? = null)` for example reduces a bunch of lines, and in many ways reminds me of php in the way of how much syntax sugar is capable of reducing lines and unnecessary verbosity `json_encode(["status" =&gt; "ok", "posts" =&gt; $posts]);` No ad for anything, just still riding the high of wrapping that up on Friday and only having started earlier this week with a bunch of stuff I was 100% unfamiliar with using. It was all so dead simple easy, and everything went ridiculously smooth. 
That's why I don't use IntelliJ.
&gt; @Aynsynchrous not to be confused with @Randsynchrous
Both parties keep it alive. Oracle driving major standards (in Java SE and until a while ago Java EE) and parts of the community that feel like "we could do better" and create competitive frameworks and integrate new techologies faster. Looking at e.g. the .NET platform, many things are dominated by things built by Microsoft like ASP, WPF, EF etc.
&gt; How long does approval for free licenses take? 30 days max if you apply for the Standard Edition. This is meant to encourage you to download an evaluation copy and try all features. 1-2 business days for a solid non-commercial project (we are in GMT+7). &gt; Also, does it support kotlin? Excelsior JET takes bytecode as input, so it should support any language that compiles to valid Java bytecode and comes with a JVM-agnostic runtime. Kotlin and Scala are two such languages, so kotlinc is part of our test suite, and our 2nd gen AOT compiler is written in Scala and of course bootstrapped. Edit: typo.
Your accusation of misleading is actually misleading 😮
&gt; Since Java EE hasn't changed at all in the decade following Java EE hasn’t changed???? What’s that for nonsense? 
So if Kotlin doesn’t become as popular as Spring seems to gamble on, will those APIs disappear in the big spring bin of abandoned APIs? 
But it’s available and may become part of EE later. That’s how it often happens in EE.
requests to dox are a violation of reddit policy - please delete this comment https://reddit.zendesk.com/hc/en-us/articles/205183175-Is-posting-someone-s-private-or-personal-information-okay-
Excuse me? Perhaps you should first provide some evidence for your statements that everything in Java EE except Servlet and JPA is irrelevant.
&gt; Please substantiate that bold claim. Perhaps you should first substantiate your bold claim that everything in Java EE except Servlet and JPA is irrelevant? 
I'm serious. Okay, the wording was a bit in a jest, but the message is serious.
They have to migrate 130 repositories. There is a lot of work to do.
&gt; I'm sure you meant no harm on this That's a good point to take away. It's easy to make small mistakes. My previous company made a similar mistake. We forked an OSS project, thought we adhered to the license, but made a mistake. Author contacted us, and we corrected it. Everyone happy ;) 
How long did it take you to learn everything before you were able to do that? Am looking for some encouragement in a very painful learning journey.
A lot of work indeed, and probably even more than 130 since there are still a few repos not migrated to the javaee org (like JSF and Jersey).
**Learn Java EE.** I’ve been building enterprise-scale systems based on Spring since the early 2000’s. At one point, I was an advocate for Spring 3. But the reality is that Java EE has emerged as leading enterprise framework. Some parts of Spring are available with Java EE, e.g. JBatch. Other parts have analogous concepts. For example Spring’s core dependency injection shares similar concepts with CDI in EE. As a technical leader, when I’m looking to hire someone, I’m looking for critical thinking, passion, the ability to solve problems, and fundamental grasp software concepts. Knowing the particular frameworks or even language my company uses is just a bonus. The best thing you can do to prepare yourself for job is to show you are capable of being an engineer... not just a hack. Go solve a problem, build a game, contribute to something open source. Learn to communicate clearly.
&gt; JPA &amp; servlet is definitely worth learning - that's about all that's relevant anymore, sadly Please substantiate that bold claim. 
Let’s see. I wrote Hello World in Java sometime in 2007 as a part of my CS degree. I (re-)wrote that application (it was version 2) in 2012, maintaining it as my job from 2011 to 2015. So 5 years to the point where I was able to re-do it. 
👍
 ~~Since on the official mailing list there is radio silence,~~ please let us know if we can help and how.
Remember that you can also create Java EE/EE4J microservices with: * WildFly Swarm, * Payara Micro, * WebSphere Liberty Micro. EDIT: made it more easy to read.
So the latter one is Microsoft's fault, not the general lack of interest from developers? And yeah, both parties keep it alive. But if it weren't for Oracle and someone else (let's say, Google) would have bought Sun at the point of the bankruptcy, would we know Java today as it is? Judging by what Google does to everything else, Java today would not even look like Sun's Java, it would not compile old code (take a look at what they did with Angular framework). Google would probably use it in some of their project, and then throw it away, like they used to, while moving on to Go or something else. But, or course, those awesome language features would have been greatly appreciated by remaining Java developers - I mean, by both of them. It would be now just a niche language to use for Android development, and even then - not the only one, with Javascript/CSS frameworks moving in to replace it. OTOH would Java be alive without Scala/Closure/etc, without OpenJDK and gcc-java? Absolutely. It wouldn't be as "cool" as it is now, but it would certainly be still around and widely used - even while being more of a "modern COBOL" than it is already.
Oh yes - we also had the issue in JHipster when someone copy/pasted some other company code into our templates... He didn't mean any harm, but that's easy to have this kind of issues. Anyway, I really, really have no problem with having our templates reused, that's totally part of the license, and in the end we all benefit from it - Jeddict can make some good advertisement to JHipster in the Java EE world, and maybe their users will find issues or contribute to our code.
That's the spirit ;) Good luck to both projects! :)
So the warehouses are running ‘hello world’ now?
Please, do not learn the Spring!
!!
Oh, this is good! 😡 You say time machine, but to say Java EE is all about EJB 2 you up vote no?!! I know you kind! And is true, I not give 💩 about Spring!
why is that?
thank you , learning about a technical leaders perspective on this is invaluable.I do think i posess the things you mention.I always chose to do optional projects (although small) which included designing some IT systems for a theoretical e-gov service , some network related ones like a socket group chat , made some websites and woocommerce heavy modifications etc , took part in google's code jam and made it to 1st round after qualification rounds then i fell asleep on the PC lol.I have even designed some maps with cryengine when i was 15. But tbh i feel like everything here works with relations.Everyone just hires people they know , people who even cheated on every test and paid for every project , and they become managers while im doomed to start a serious job in my 30s.
&gt; So the latter one is Microsoft's fault, not the general lack of interest from developers? No, its not Microsoft's fault. The .NET developers are just too "Microsoft compliant", so the innovation largly doesn't come from them. &gt; It would be now just a niche language to use for Android development, and even then - not the only one, with Javascript/CSS frameworks moving in to replace it. Currently these are moving in today, because Java is perceived as not moving forward. It has an image of being old, slow and verbose. &gt; It wouldn't be as "cool" as it is now. Java is not perceived as "cool" nowadays &gt; even while being more of a "modern COBOL" than it is already. Which is bad. Also Java will likely not be kept around as long as COBOL. COBOL drives huge closed of monolithic mainframes. Java can easily be understood and then replaced / gradually phased out. More so with the current trend of splitting into smaller pieces / services.
damn thats a lot of names in one sentence lol.Will definitely be looking into these
`jaotc` only emits ELF binaries currently.
Well, if you manage to figure out how to call the shell I put in for the purposes of debugging the serial port stuff in there, sure.
You are right. I edited it. It should be more readable now.
what problem does loom solve that quasar (or kilim) doesn't currently solve ? have you thought at all about what the bare minimum code change required to support this would be (it seems like it would be pretty minimal - really just a secure way to expose the stack) or is the goal really just to move quasar from the PU namespace into java.util and obviate the weaver ? 
Thanks.If im not mistaken microservices are part of cloud infrastracture right? Is there any sector that mostly has to do with deploying/making apps for cloud or is it general software engineering?
The software engineering concept behind microservices is [component-based software engineering](https://en.wikipedia.org/wiki/Component-based_software_engineering). Microservices are the most modern way to achieve component-based software engineering in the cloud. Many people think that a microservice architecture is a service-oriented architecture (SOA) done right.
**Component-based software engineering** Component-based software engineering (CBSE), also called as component-based development (CBD), is a branch of software engineering that emphasizes the separation of concerns with respect to the wide-ranging functionality available throughout a given software system. It is a reuse-based approach to defining, implementing and composing loosely coupled independent components into systems. This practice aims to bring about an equally wide-ranging degree of benefits in both the short-term and the long-term for the software itself and for organizations that sponsor such software. Software engineering practitioners regard components as part of the starting platform for service-orientation. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
They can just leave JSF...
&gt; No, its not Microsoft's fault. The .NET developers are just too "Microsoft compliant". As in "being sheep"? :) I don't think so. The main reason, IMO, is that Microsoft developed their .Net platform while watching Java, learning from mistakes. They made it "good enough". Open-source .Net-based frameworks [do exist](http://springframework.net), and [there are more](https://www.dotvvm.com), it's just most Java developers don't bother checking. As most people participating in this thread apparently still don't realize that .Net is open-sourced (under MIT license - Oracle, hello?), just as they aren't aware of the fact that Microsoft has arguably the biggest repository on Github, listing 1400+ OSS projects, which is 1.5 more then the one of Google and certainly more than the one of Apple which is listing... something like 30+ projects. "All right, but apart from the sanitation, the medicine, education, wine, public order, irrigation, roads, a fresh water system, and public health, what have the Romans ever done for us?" &gt; Java is not perceived as "cool" nowadays Well, cool enough for me to use it by choice in many projects. I just perceive people who are bothered with its strict typing and checked exceptions as crappy programmers :-p It's not the only language being used, but as soon as you need to write something reliable and easily tested - it's Java. And I certainly wouldn't want it to become a platform aimed at attracting NodeJS "cool boys" and "software artisans" - otherwise the *least common denominator* factor is about to kick in. But that's just my opinion. &gt; Java can easily be understood and then replaced / gradually phased out. More so with the current trend of splitting into smaller pieces / services. Look, I've been in software development for 25 years already. I'm always eager to learn something new, I've studied Go recently to use it in a project, and I learn Haskell now. But I've seen all kinds of *magic pills* coming and going. Microservices isn't the answer to everything - their primary goal (compared to EJB and likes running on JVM, who had "microservices" and event buses for many years) is enabling companies to develop scalable architectures using cheap JS/PHP programmers. While understanding code is possible, replacing it completely (especially considering the huge codebase Java has) is another thing. It's not just a matter of a language/tools used, but much more a matter of people and their expertise. 
It will be more efficient and more robust. But it's not intended (at this point) to cover anywhere near all of Quasar. Just fibers and continuations. Quasar will likely then be reestablished on top of Loom.
Have you seen [PrimeFaces](https://primefaces.org/showcase/ui/ajax/basic.xhtml), [ICEFaces](http://icefaces-showcase.icesoft.org/showcase.jsf?grp=ace:ajax) or [OmniFaces](http://showcase.omnifaces.org/utils/Ajax)?
Yes, they can just leave JSF...
After all the effort done to integrate it with CDI? I don't think so. Leave it for what? What do you suggest them to use instead?
Without a doubt, testing adds to development time so you have to balance quality with timeliness.
I agree. In my experience the additional time spent testing during development saves a lot more time in the future. Without tests in place fixing problems becomes a headache and costs more time to fix.
I have a strong dislike for "component" based web frameworks. Give me a good request/response based framework like Spring MVC or even a REST API with a JS frontend anyday over JSF.
possibly, if there isn't much interest.
JavaScript is a language designed in 10 days. It has many design mistakes and they were kept, release after release, after release. If you don't like JSF it's OK. JavaScript is not better at all. There are, however, much better options, like Elm and PureScript. There is no reason to drop a widely adopted specification like JSF.
I have found, throughout my years of treading these waters, that the people that claim "writing tests slow down development" are people with only a few years experience. Good test (unit, functional, integration, etc) have a minor up front cost that pays YUge dividends later. 
If you're computer science you'll be doing 50/50 CS theory and CS application, as soon as your core classes from the uni are out of the way. This sometimes takes two years, so in the meantime you can practice personal projects. Make a github and share your source code, build a resume, work for fun places (doesn't even have to be programming. Be a barista if you want, these experiences can be life changing!) 
I have some team members who definitely don't have anything to do with intelligence.
Heh! I love it and have been saying for years that the "JavaEE" brand has GOT TO GO! Too much baggage and negative associations. EE4J is something that DOESN'T have that negative baggage (yet). Let's home that they can do something useful with it!
Gradle tasks. Or Maven if you happen to use it.
That's not via IntelliJ.
You can define a run config which does that. Well worth not spending 400 dollars for me.
I have yet to be on a single project where the budget and timeline allotted for proper testing outside of very limited functionality. 
You're doomed as soon as your company starts thinking of software development as a "project". You're bringing about a new living thing which you will now share a future with. Sure you can complete the "adopt a cat" project for less money if you cut out the cat litter from the budget. But a couple days after your launch party the smell of success will be drowned out by the smell of something else. 
A lot of companies think of it this way unfortunately. I'm just a body in a chair getting paid to get rid of the Mt. Everest of technical debt with shoe string budgets. Bidding my time, earning experience and learning new things on my own time.
For people interested in testing software you should check /r/tdd :)
Some of the best developers I've worked with do some variety of "test adjacent programming" (as one of them called it), one screen has main code being written, other screen has the tests open on it, and they write them in almost parallel. Their code is the stuff that rarely causes people to be paged.
The heading here is incorrect. EE4J is not the new name for Java EE. It's the name of the Eclipse project where Java EE will be housed. See the Eclipse Foundation's [own post](https://mmilinkov.wordpress.com/2017/09/30/on-naming/) on this
The "test everything" comic might give the wrong impression to some people. Here is an article with more details on what to test and what not to test. (I am its author) https://zeroturnaround.com/rebellabs/dont-test-blindly-the-right-methods-for-unit-testing-your-java-apps/
We do test. Or shall i say, the customers test ;) Biggest reason is time and project constraints. Of course everything is tested, just not tested to find all the corner-cases that probably should be tested.
Absolutely. On one extreme, there are those types of people who want to sling incomplete and buggy features at the customer just to get them out there, and on the other extreme are the types of people who, if left to their own devices, would never actually deliver a feature in their lifetime because it was never quite complete and thoroughly tested enough. I find that when either of these types of people get too much power at a company (or on a team), death of the product is inevitable, and they always think it’s someone else’s fault.
Are we sure this article isn't a parody...? &gt; It’s useful to at least know the difference between them all: &gt; - Acceptance testing &gt; - Alpha testing &gt; - Beta testing &gt; - Black box testing &gt; - Comparison testing &gt; - Compatibility testing &gt; - End-to-end testing &gt; - Functional testing &gt; - Incremental integration testing &gt; - Install/uninstall testing &gt; - Integration testing &gt; - Load testing &gt; - Performance testing &gt; - Recovery testing &gt; - Regression testing &gt; - Sanity testing &gt; - Security testing &gt; - Stress testing &gt; - System testing &gt; - Unit testing &gt; - Usability testing &gt; - White box testing First, that's quite an apples-and-oranges list. You're gonna put "beta testing" in the same list where you put "unit testing", seriously? Also, no, it's not that useful to know a semi-random assortment of 22 words to add before "testing". It's neither exhaustive, nor required, nor providing that much insight as to your testing needs. I've seen nothing good come out of people bike-shedding about whether a specific test is "unit testing" or "integration testing". When I was young and naive, I thought that learning lots of words, definitions, categorizations and so on is "knowledge". I thought smart people know lots of words, categories and terms. 20+ years of experience later, turns out words are merely a communication tool, which is highly overloaded, contextual and best learned on a need-by-need basis, depending on the specific practices and needs of you team and project. Turns out also words are entirely not reflective of your skills or the extent to which you correctly apply the practices behind the words.
Sounds to me like you probably got fired because you have a shit attitude.
I wonder greatly how much your “dislike” is fuelled by HN and hipsters. Maybe when web components start being all the rage you suddenly like components.
And add OmniFaces to that ;)
To be honest that only happens on windows
[removed]
No, don't do this, just make sure that whenever you give off an estimation, it includes the time to test, document, think about it, etc...
This acronym is not bad but I think that they should use a new one word name which should be simple and easy to remember. Most of the meaning of the name Eclipse in other languages is long and complex, In my opinion they can use one word name like Kasuf which is arabic name for Eclipse. 
&gt;but to say Java EE is all about EJB 2 you up vote no?!! No. You just came here to say your bullshit about things you have no idea. All the spring projects I worked last years (a dozen of projects) have... 0 xml related to spring. &gt; I know you kind! No you don't. And same about spring. 
Don't worry about it, Java isn't a hard one to learn. There amny aspects you can learn about it and it might take time and practice but it is a recommended one to learn. The only problem with it is that sometimes it get a bit complex, an this complexity can lead your code to suffer from bugs and errors that are really hard to be detected. There are programs that might help, like checkmarx, but it is recommended to avoid those as much as possible. Good luck.
**Sidebar** -&gt; #Do not post tutorials here
If anywhere this question should be posted in /r/eclipse. This has nothing to do with Java.
In my work I've found that the Don Quichot fighting the good fight singlehandedly approach rarely works; if you go against the grain you have to lobby to get everyone behind you otherwise they get nervous, jealous and feel embarrassed and bad things happen.
Android
&gt; Don Quichot You're Dutch, aren't you? :)
I am, I think the English spelling has an X somewhere, but I'm not quite sure.
Good for you. That company doesn't deserve you and your work wasn't valued there. Any time you spent there would have been an absolute waste. Why don't you find a job where they would appreciate your work more? Many companies are always hiring highly competent engineers such as yourself. 
Java 18.3 is the next major version of Java under the new versioning scheme (18.3 indicates it is targeted for March 2018) . Previously it would have been referred to as Java 10. OpenJ9 is a JVM implementation developed by IBM/Eclipse. The above link is to a GitHub issue for OpenJ9 to add early support for Java 18.3. The title shown above is a complete mystery.
Seems like there's some classic bike shedding going on here too. No comments on the actual project charter, but everyone's got a comment on the top level project's name. Hopefully this gets everyone back on track.
Quixote in English; Don Quijote in Spanish. No idea why they used a Spanish x (as in Mexico, not taxi) to represent the h sound in English. But then pronunciation was never English's forte. **Edit:** https://en.wikipedia.org/wiki/Don_Quixote#Spelling_and_pronunciation apparently explains that it was originally more like a sh sound in old Castilian, like a Portuguese x.
For big enterprise project that need to be maintained for years like an erp, web components like jsf is really good choice better than angular or react that need too mush effort to maintain your app. 
&gt; words are merely a communication tool, which is highly overloaded Can't tell how many times that my "end-to-end" was misinterpreted as a complete system "end-to-end".
A common reason I've heard while working for a consultancy that often teaches organizations TDD is "our code can't be tested". Many people seem to think their domain is exceptionally complicated and testing is only viable for people solving "simple" problems. This hasn't ever proven true of course.
I did better by working for myself. Then when I get mad the only one I can blame is myself. You have a lot more upside and downside that way. Then I figure out why these people lie in the first place, a good honest day's work gets irritating after a while and you start looking for free money that drops out of a dispenser given no effort.
I would suggest that testing decreases development time. Up to a point. Good unit tests save me from repeatedly firing up the application and manually testing things. A couple good integration tests and maybe an end to end let me quickly know if the whole thing works without manually testing and give me a good indicator of when a feature is done. Once the feature is done and merged those tests then help other developers know if their changes have broken things, saving them tons of time manually testing, and serve as a reminder of AC that would otherwise be forgotten. Its a bit of time spent up front for automation that saves tons of manual effort in the long run. On the other hand as you add more tests around a feature the more the value of each new test diminishes. Testing can be taken too far. You have try to find the sweet spot where the tests you're writing are providing enough value that they're still making thing faster.
They seem to be a slow follower to Spring regarding features and they are desperately clinging to the fat server. If I have a choice, it’s Spring boot stack hands down. 
&gt;They seem to be a slow follower to Spring regarding features Which features would that be? &gt;and they are desperately clinging to the fat server. They are not. See Liberty, Payara Micro and WildFly Swarm. Besides that a full featured runtime has advantages too. Why else would Spring have a Tc Server? &gt;If I have a choice, it’s Spring boot stack hands down. If I have a choice, it's Java EE hands down! :P
It's still trying to solve a problem that doesn't really exist anymore, if it ever did in the first place. 
Ok, this is not a troll comment, I am a long time spring user, haven't touched Java EE since made version 6.... So i'm way out of the loop. Can someone tell me reasonably succinctly what V7 and V8 really have to offer someone who's been into spring for a while?
Any good books to start learning java ee 7?
What problem do you mean? Java EE handles persistence, provides restful end services, provides a means to validate incoming values, allows you to secure those end points, etc All seems like a very real and current problem to solve, doesn’t it?
Added! :)
All of those can be achieved without Java EE. What's the unique problem that it's trying to solve?
No, my dislike comes from over 12 years of web programming and preferring to have visibility into the request/response cycle than a component framework hide it from me. Most other successful frameworks are request based, Rails, Grails, Play, Spring MVC, Django, Phoenix, and the list goes on. Hell, even .NET developers seem to be migrating away from the classic ASP.NET framework to ASP.NET MVC which is a more request based framework. 
How would you achieve all of those things in Java without Java EE?
Because of all the reasons that have been regurgitated on this subreddit that I don’t need to rehash. Not going to shave that yak again. https://www.reddit.com/r/java/comments/67945a/whats_the_main_reason_people_using_the_spring/
JSF hides far less than the urban myth is trying to make you believe it does. A post back riddled, navigation rules heavy and component only JSF 1.x application might have made you think that (and with good reason), but this approach was largely abandoned in JSF 2, where JSF became more like a hybrid framework. Modern attempts at the request based pattern (like MVC 1.0) often tend to move JSF as well, with the automatic handling of locales and the ID automation tools on the view. ASP.NET web forms were neglected for a long time and are essentially JSF 1.x. For MS it made more sense to start over.
Jersey and Hibernate can handle all of those issues. Edit. I guess technically Jersey is a Jax RS implementation and there are some implementation portions of Hibernate that are EE spec compliant. Logically I’ve always separated the spec and the implementations. Even Spring implements the specs when they finally come out (Cache API is a great example). So I guess it’s a bit of a admittedly murky retort. 
CDI gives you dependency injection, like in Spring. For microservices you can use WildFly Swarm, Payara Micro or Liberty. Now you have standard security API and much better JSON processing. Many things can be done asynchronously. In Spring, you have to import a lot of Gradle/Maven dependencies and there is only one implementation. In Java EE / EE4J you have only one Gradle/Maven dependency and you can choose the implementation that you prefer. Sometimes, parts of Spring are abandoned quickly and without explanation. That doesn't happend with Java EE / EE4J specifications.
Jersey and Hibernate, nice ;) Jersey is the JAX-RS RI, and Hibernate is the most used JPA implementation. The JPA API was largely designed by Gavin King (the creator of Hibernate) who saw it as the next gen Hibernate API. Hibernate and Jersey still depend on other specs like JTA, Servlet, Bean Validation, and the Java EE security machinery. Many people make Jersey endpoint CDI beans. So by mentioning Jersey and Hibernate you actually explained the value of Java EE ;)
&gt; Without a doubt, testing adds to development time Does it though? Clearly there's an initial investment, but overall it seems to make maintaining so much easier and faster. It's more of a ROI situation.
Great example as well for my original post. All of these “features” were implemented and used outside of the Java EE world and only slowly adopted later. “Prior to the introduction of EJB 3.0 specification, many enterprise Java developers used lightweight persistent objects, provided by either persistence frameworks (for example Hibernate) or data access objects instead of entity beans. This is because entity beans, in previous EJB specifications, called for too much complicated code and heavy resource footprint, and they could be used only in Java EE application servers because of interconnections and dependencies in the source code between beans and DAO objects or persistence framework. Thus, many of the features originally presented in third-party persistence frameworks were incorporated into the Java Persistence API, and, as of 2006, projects like Hibernate (version 3.2) and TopLink Essentials have become themselves implementations of the Java Persistence API specification.” The JPA API was adopted later and blessed but not invented by Java EE, but rather by someone outside of Java’s official spec because of deficiencies in whatever the Java spec was at the time. What you are espousing would be for me to create a new spec called Fairway EE and include all of the best existing open source apis from the ecosystem and then claim my spec is the best. 
Ohhh, you think i dont know you kind!??? You think i craxy!? Please, think again! Is you pretend Java EE is not changed?? Huh? Is still EJB 2 and is JSF still only post! But then someone does same to Spring and you feel many offence!??? You knot see hypocrisy there!???? 
Lol 😂 Is you explain Java EE, and is how works! What is problem!??? Is 💯 project out there, yes? Then Java EE take look 👀 and what is most work best and is base tech come in Java EE. And yes, EJB entity bean, is big mistake from beginning, but please, you never make single mistake!? I dare you! So mistake is corrected and was corrected in 2006, is 11 year ago!!! But you still hold this mistake in our face!??? Is what are you!? Is you men (women) or mice 🐁? Now, please, is the Hibernate very good, but you think Hibernate invented pattern!??? Hahaha, if you think is you very wrong! Is **toplink** invented, then Hibernate copy! Yes, you google that and you see is correct!!! Now, we say Hibernate is solving problem that is not there!? You really think? No! You don’t! So why is Java EE not solving problem!? Is you logic false, I proved this! 🤓
That IBM JVM had AOT for years. There's also one cool project - avian which I like, but it seems abandoned.
im just reading the entire javaee tutorial.Its like 200 pages
&gt; … you can choose the implementation that you prefer s/you prefer/your server ships &gt; Sometimes, parts of Spring are abandoned quickly and without explanation. That doesn't happend with Java EE / EE4J specifications. You mean like they dropped half the content of JavaEE 8 last year, in some cases (MVC) without even notifying the EG members upfront? *scnr* ;) Care to elaborate on the parts of Spring that have been abandoned the way you describe? Sometimes, statements are made quickly and without proper explanations… I guess.
Do Spotify use java? From what I recall the GUI is written in C I guess some of their backend stuff and data engineering stuff probably uses the JVM somewhere in the stack though 
It's just one possible solution to a problem. You can pick spring or create your own toolkit from some libraries or just pick some EE server. In case of EE server everything in it should be tuned to work together. A nice feature of EE servers is that they are able to host multiple apps (microservices anyone?) or you can just swap to distributed transactions, or do clustering or other kind of magic (ideally) without a code change. Also what I really like is, that compared to spring, you deploy just a small jar (can be like 100kb). But to be precise, it's trying to be a vendor independent standard of writing a business software. So you can hire Java Joe, an EE developer and he doesn't need to be specialized in your super cool (and expensive) EE server.
&gt; You mean like they dropped half the content of JavaEE 8 last year, in some cases (MVC) without even notifying the EG members upfront? They never have been officially included into Java EE / EE4J &gt; Care to elaborate on the parts of Spring that have been abandoned the way you describe? Spring Roo, for example. I guess we will never have spring Roo 2.0. 
Check my history and quit your BS. I said nothing about JEE/EJB, but you came here with meaningless statements about spring. You said nothing technical, but turns out you know evrthng about me personally . So just prove your point about spring, otherwise it looks like promitive troll that I won't follow. 
&gt; They never have been officially included into Java EE / EE4J Which is a tautology but completely missing the point: stuff that was officially scheduled to be included was removed without even notifying people working on it. &gt; Spring Roo, for example. I guess we will never have spring Roo 2.0. Well, there have been two release candidates already.
Shave that yak, or peel the banana? At any length, weak dude. I think you just can't backup your claims. You've been conditioned to hate on EE, but probably don't know the first thing about it.
&gt; s/you prefer/your server ships And you're implying that as an average dev you can choose the framework freely (in other words Spring), but can't choose the framework that is also called a "server" (in other words Java EE)? &gt;Sometimes, statements are made quickly and without proper explanations… I guess. I value your work and know you're a balanced engineer, but that is quite often what Spring fans do, unfortunately. They're quick to make statements like Java EE is behind, is slow, can't be updated, and what have you, but I rarely if ever get a real answer when I ask for details.
I hope this doesn’t turn out to just be a fad, but I’d really like to see Java EE embrace the non-blocking, reactive streams APIs that even Spring has embraced. Being able to use EE effectively in both IoT and cloud environments alike could be a killer feature.
&gt; Which is a tautology but completely missing the point: stuff that was officially scheduled to be included was removed without even notifying people working on it. It's well understood that the way Oracle treated Java EE 8 was quite bad. From the rumours I've heard it's only thanks to a number of the Java EE engineers that we even got the small release that we got. Two specs, JSF and Java EE Security were largely or almost completely developed by the community, two other specs, CDI and Bean Validation, by Red Hat. Oracle dropped MVC, JMS (even though Nigel et al worked on it), and didn't even start with adding JCache to Java EE. Java EE Configuration was dropped before it even started. JPA was rushed (as EG member you know this, of course), and JAX-RS and Servlet only got relatively minor updates too. Servlet work actually didn't start until e.g. JSF was already done. But this hasn't been the norm really for Java EE, and everyone except Oracle was quite willing to make it a success. Now that Oracle does all the work to transfer Java EE to Eclipse I feel they do put in a lot of effort again to make that happen, and I'm sure that under the new org Java EE will do better than ever. 
Well, I'm not claiming Java EE is fully reactive, but JAX-RS does have reactive features. See: https://blogs.oracle.com/pavelbucek/jax-rs-21-reactive-client-api
Java EE does try to create specifications around functionality that is already widely used a lot of the time. It does provide some good. When all the guys out there in the open source world come up with stuff you are going to start out with a lot of different versions of the same idea and different APIs for interacting with each one. Once Java EE creates a spec for that functionality it becomes the de facto standard and most everyone provides a Java EE compatible interface for users to interact with. It helps steer the ship and get everyone working in the same direction. 
Looked through your comments... they are mostly 'use jee, X is shit', 'Y is slow' etc. W/o any tech arguments. Unlikely I get tech reasons this time from you. If I was mod here, I'd ban you for few days, dude.
Thanks for re-iterating on this, but I guess these days everyone is aware of all this. I just wanted to point out that the original claim of short-notice abandonment was bogus, general deprecations are a usual thing and JavaEE has not been free of such surprises in the recent past. Which basically renders the "argument" invalid.
&gt; And you're implying that as an average dev you can choose the framework freely (in other words Spring), but can't choose the framework that is also called a "server" (in other words Java EE)? I am implying that there is an implementation selection process that is more direct in the Spring world (by defining project dependencies) and more indirect in pure JavaEE as the idea is to stick with what the server suggest and potentially augment. That's different approaches with both pros and cons on either side. It's just that the proclaimed "dependency you like" is actually the more Spring-ish model than it is the JavaEE one. Which made the argument bogus. Oh and yes, we see a lot of traditional companies in which the choice of server is made by operations and cannot be influenced by the developers whereas what goes into the war is accounted by the development teams. I guess in that case, the Spring approach gives developers more options but at the same time also more responsibility &gt; I value your work and know you're a balanced engineer, but that is quite often what Spring fans do, unfortunately. Being a balanced engineer? ;) I don't speak for Spring fans and I don't care what others do. If I argue, I don't resort on "but JavaEE fans say…". That's the weakest argument you can make as it's not even an argument really. That's why I'm not going to argue things that allegedly others say. None of this was my point. I just pointed out inaccuracies or at least misguiding statements.
&gt; So criticising Java EE for being "years behind" is a bit of a pot and kettle story, since Spring is then "years behind" just as well. save the pesky little detail that we actually are shipping a fully reactive implementation now. Nothing new about reactive, granted, but doesn't change much about what's GA and what isn't, and how long it will take for EE do anything about it. No one said reactive was a silver bullet - quite the opposite. Spring team is being extra careful to advise people against flocking to it for no reason. The reason why EE even has to ask themselves the question of "whether to do it or not" is because they don't have real customers pushing the boundaries of the synchronous microservice stack, and finding they have edge cases that require reactive throughput levels.
I should say that JAX-RS is also relevant, it enjoys usage beyond just EE user base and is supported by a decent amount of vendors. re: your question: I'm not sure what more compelling evidence exists than the JCP itself pruning irrelevant APIs: Full Profile Web Profile microprofile * Microprofile, which granted, was never blessed by JCP/Oracle, was advanced by the last people in the market to get away from the full blown EE programming model e.g. IBM/RHAT. IIRC it the "microprofile" consists of JAX-RS + CDI + JSON-P, which appears to ignore data access / JPA. To business leaders (less developers) Gartner group has declared it irrelevant, but they missed the point that Servlet / JPA and arguably JAX-RS is alive and well. https://adtmag.com/blogs/watersworks/2017/02/java-obsolete-report.aspx So you were saying something about evidence of Spring lagging behind in the market? Or maybe you were just going to go find another thread to troll. 
mildly curious, what makes you say it may become available later? 
ignoring you countering a question with a question, sure, see above, evidence is readily available to anyone with a browser. Or does Redhat still standardize on IE6? You were about to offer some evidence, or maybe you were just going to go find another thread to troll? 
Can you inject into the constructors of servlets or filters or listeners yet? Or into the constructors of tags?
&gt; And you're implying that as an average dev you can choose the framework freely (in other words Spring), but can't choose the framework that is also called a "server" (in other words Java EE)? Application servers we can choose are determined by the support contracts the company gets. Since we are a smaller project in the larger picture we have no say about it. 
fair point, JAX-RS is relevant if you are a Java EE user, arguably beyond that as well - fairly well supported by vendors. thanks!
&gt; the *unique* problem goalposts. stop moving them.
wat
no, I didn't forget. I left them out since the APIs you name are EE centric (for the most part) - e.g. they relevant to EE users only. 
Pardon, I missed JAX-RS, which is also relevant, as it enjoys usage beyond just EE user base and is supported by a decent amount of vendors. re: your question: I'm not sure what more compelling evidence exists than the JCP itself pruning irrelevant APIs: Full Profile Web Profile microprofile * * Microprofile, which granted, was never blessed by JCP/Oracle, but was advanced by the last people in the market to get away from the EE programming model e.g. IBM/RHAT. IIRC it the "microprofile" consists of JAX-RS + CDI + JSON-P, which appears to ignore data access / JPA. To business leaders (less developers) Gartner group has declared it irrelevant, but they missed the point that Servlet / JPA and arguably JAX-RS is alive and well. https://adtmag.com/blogs/watersworks/2017/02/java-obsolete-report.aspx 
i meant with regard to testing. I've updated my comment so it's not open ended.
Because 1) this has been discussed before, so there’s a wish by various EE people to do this, and 2) these things have been done before, like PrimeFaces’ search expressions being added to JSF, and OmniFaces’ WebSocket among others. So there’s both a will and a way, plus that the CDI and BV TCK’s are Arquillian based already, and new TCKs for the OSS specs and MP have expressed interest to be Arquillian based as well.
Nah. Just remembered arguing with people on the internet is a waste of time. 
I like your subtle attempt to hint at JAX-RS being only relevant because it’s used outside EE. Nice! /s MicroProfile has started with a minimal runtime and as a 1.0 wanted to release something quickly. It has absolutely made no statement of any of the other EE APIs being irrelevant. In fact, all of the MP contributors (Payara, TomEE, Red Hat, IBM) fully support and keep innovating on the implementation side of these APIs.
That makes the statement slightly less bold, but still not true. The main thing that changed is the widespread availability and usage of Arquillian and Arquillian connectors.
That makes no sense, why would you need a support contract for Java EE, but then magical don’t need one for Spring?
Specs can not get a new revision and new specs can not be finalised, but the existing spec implementations keep being supported. Dropping MVC is not dropping an existing and used spec, but starting to design and prototype something and then deciding not to complete it. This is something completely different than dropping something that is actively used and I think you know this. Actually pruning something from Java EE is a multi major release process, meaning it’s practically speaking announced at least 6 years in advance. 
What’s the constructor of a tag? Constructors of new HttpAuthenticationMechanism are injectable I think. Servlets are not yet CDI beans. Java EE 8 should have made a big push to make everything CDI, but we all known how that went.
Making bold claims and then not backing them up is a waste of time for everyone. If you think discussing is a waste of time, then could you please not make those claims to begin with?
LOL bro. Formal methods or GTFO.
We have support contracts for Tomcat as well, but not for the libraries we deploy on it (hence we can freely choose what we deploy).
Picking a leaner subset of APIs IS quite a statement, as it's a clear indication of what the producer deems "most critical for an MVP". Sorry, but I am allergic to trolling from competitors who try to throw shade on news that isn't their own. 
I was providing an opinion. If you don’t like it, downvote it. It’s Reddit. :)
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/u_addamsson] [Zircon, a text GUI library | Version 2017.2.0 released!](https://np.reddit.com/r/u_addamsson/comments/73p393/zircon_a_text_gui_library_version_201720_released/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
I have been writing code professionally since 1989, so that's 28 years of experience. I'm not saying that it's not worthwhile to test during development. I'm saying that it undoubtedly increases development time -- so a conscious trade-off has to be made between quality and timeliness. The perfect is the enemy of the good. You know the old expression: good, fast and cheap... pick any two.
The thing that increases development time isn't testing, it is required quality. There is a scale: doesn't work &lt; appears to work &lt; sometimes works &lt; often works &lt; usually works &lt; reliably works &lt; assuredly works &lt; always works For any point on that scale, testing during development will get you there faster than any other technique (with the possible exception of formal proofs at the far end of the scale). But what it probably wont do is get you to that point faster than less testing, or even no testing, would get you to a lower point. Sometimes that lower point is actually good enough. And, if you are feeling mercenary, some other times it isn't, but you get paid anyway. 
Oh man this looks awesome. Nice work! I will definitely noodle around with it.
That sounds fishy. So you have a support contract for a tiny part of the stack, but then no contract for the bulk of the stack where much more could potentially fail due to bugs or security issues?
Yes, it's a bit silly - the requirements only affect the ops side of things. Nevertheless I know it looks the same in at least a few other companies. We do have internal security guys who do check if our libraries are not related to CVEs or if we don't have inadequate security measures in applications themselves, but they are much more flexible and adaptive than long-term support contracts.
In this case it’s not, since it’s what was chosen for a specific profile with a specific purpose to function as a base. MP is not a replacement for EE, but a different profile mainly. Just as web is a different profile again. There was even talk on the MP list to only have a bare core (like Liberty) and don’t include any spec. &gt;Sorry, but I am allergic to trolling from competitors who try to throw shade on news that isn't their own. Then you must really dislike working for Spring I assume? Since exactly that is what Spring has been dowing since day one. Just look at the old server side posts and look here on Reddit too. Almost every Java EE post is swamped with “Spring fans” claiming EE is obsolete and that they prefer Spring (of course). 
Thanks! Feel free to ask if you have any questions or suggestions!
Fair enough ;)
I see those companies too so I can feel your pain. On the other hand, more and more companies do deployments via Docker, so them Java EE or Tomcat + Spring doesn’t matter at all.
No this only runs on Swing currently. This is why I used "text GUI" and not "terminal emulator" to try avoiding the confusion. The concept is based on Lanterna though so you can write an implementation for the `Terminal` interface and use **all** of the features mentioned above but this library is geared towards game developers and real terminals lack features like transparency and also they have some extra "features" like private mode which you would need to handle in your implementation. It is possible though if you want. Check the docs!
This looks really neat. I haven't done anything with Java GUIs in a long time, but when I did this I used swing. I am under the impression swing is effectively deprecated at this point and JavaFX was the way to go. I am wondering why you make this using swing though rather than JavaFX? Is it a matter of compatibility or something else I am missing here?
&gt; In Java EE / EE4J you have only one Gradle/Maven dependency and you can choose the implementation that you prefer. LOL this is one of the biggest farces ever.... especially the "program to the interface" yea except when behaviors underneath leak out and cause runtime issues you never had before.. 
If we can get to our required quality level with no testing, then we should do no testing because it is a wasted effort and time. As soon as we start testing, we add development time even if, as you accurately point out, we are testing in order to reach some specified quality level. 
Very well documented!
One clarification is hardly moving the goalposts. Java EE is a pretty unique solution. I just don't understand the problem it's trying to solve. edit: When I say "understand", I mean I don't think that the reasons I've been given are a problem that needs solving. 
Neat. At some point I wanted/needes to do something similar. I will surely take a look.
Huh, this might be pretty interesting to make a roguelike or something like that. Will definitely be keeping an eye on this.
you said "solve a problem", then examples of things it does were given. then you said "unique problem", which is a different (if somewhat vague) question. but of course you're being oblique and trolly, so it's not totally clear what the you're even talking about. people have to guess.
I think Oracle still owns that name.
I'm on the official reddit app (android). How can I save this post? I can save this comment. That will have to do lol.
There is a subreddit you might want to check: `/r/roguelikedev`
The save icon is hidden because its color is same as the back ground image (white). You can just tap where the save icon should be.
IMO machine learning in Java have already become common because of the rise of big data. R or Python can do ML things very easily, but not at scale. To deal with big data many people use Hadoop and its ecosystem such as Mahout and Spark. Well, Spark supports Python though.
It would be nice to have the ML prototyping tooling you get in python in java too though
As the Spartans said to Philip of Macedon, ‘if’.
You are right, Swing is kind of obsolete. I used Swing for the first version because this started as a port of Lanterna and it had Swing support from the get go. Currently we are working on libGDX support which is more useful for game devs but JavaFX is definitely an option to implement. Another thing is that you don't really interact with Swing when you use Zircon, only with the API which is GUI-agnostic.
&gt; Java EE 8 should have made a big push to make everything CDI, but we all known how that went. JavaEE would be much much cleaner and unambiguous if designed on the top of CDI from the beginning. Adding CDI to JavaEE6 was too late. Now half of frameworks' classes are managed by CDI and half are not. Half of the things can be injected with @Inject, half can not. CDI is viral, it forces all classes to be managed by container. Today I'm not sure if I wouldn't like too see JavaEE without CDI , the mess it introduced is bigger than advantages. Platform should be polished but there is no one to do it. 
Nice!
Weka
JSF 2.3 took steps. MVC and Security are CDI from the get go. MP APIs (possibly merging with EE, for some JSRs have been created already) are CDI from the start too.
Can you elaborate?
Se use spark and python bindings at work
Cool.
Yes, I have the b181 build from development EA builds...which is why it is so jarring to not see a Solaris x64 build for FCS.
Spring vs JavaEE etc blah blah blah. Please, just look outside the box, at other ecosystems. Imagine if there was no JavaEE, no JCP. that Java was just another PHP / python /etc. No servlet. No (fat) servers.... just compile everything together and ship it as a fat binary... Can you imagine Java becoming as big as it is? 'Fat' servers, and thin wars are a huge advantage.
&gt; Everyone just hires people they know You're absolutely right about that. They way to fix that is to know people. Here's what I did. I joined local users groups and developer groups. I gave presentations at my local Linux users group for a while and one time a person in attendance happened to be someone from Pratt and Whitney and was looking for help on something his company needed to do. He approached me after my presentation. That was my first "real" job and I haven't stopped since. You just need that first opportunity, for someone to take a chance or notice you. You sound very passionate about this which is really good. That helps a lot. I think just being around other developers will help you. I really suggest seeing if there are local groups in your area that pertain to your development interests. It can't hurt to at least attend a few events and see how it goes.
GUI written in C?! 
&gt; Well, Spark supports Python though. There is also SparkR for R
Change the theme to night/dark mode 😌 Who uses light mode anyways :P Edit: misspelled mode as nude :V
i already have a job buts its a small startup that only does wordpress trash.Im also paid the minimum wage.But they are planning some big projects and since we are only 2 devs i will be part of the entire process.So im torn between staying a year or 2 for the upcoming experience , or quit and try to find a better job with my current experience
JavaFX is the replacement for Swing and any new desktop Java application should probably be done with JavaFX instead of Swing. 
Is it just me or do these recent EE initiatives seem a bit uncoordinated?
Whoa, this is cool as hell. I actually used Lanterna years ago and I was just recently thinking about it for some reason. How serendipitous for this to show up on Reddit. I might give this a shot for the next Ludum Dare.
There are many [to choose from](https://github.com/akullpp/awesome-java#machine-learning). Just not as known as the Python libs.
Who's readily going to use a library written in another language in Java?
right, fans. Not employees. I've had a strict no troll policy since 2012, with (1) exception post that was made on the spring website. Whatever you see is the community responding, we're usually quite busy writing software. Anyway, reading your comment history, you don't appear to be a troll, my comment wasn't directed to you. Posts are fair game, but if the trolls on this post continue throw shade on the hard work the team has contributed to the community for free, I'll have to revisit that policy... and rest assured I'm tracking them now. Anyway, it just occured to me that microprofile has a much brighter potential future now that Eclipse foundation is running EE4J, and we look forward to collaborating around those remaining APIs that remain relevant. I think we can all agree that not having useful APIs like JPA, Servlet languish in non-responsiveness and neglect is good for all of us. 
Java will probably never stop being relevant for the simple reason that a lot of enterprise code uses it. That said, it's always recommended to learn more programming languages to learn more paradigms and expand your knowledge. I'd say every programmer should learn at least one of the following: an OO language, a functional language, and a dynamic language. (NOTE: by dynamic language I mean something like JavaScript, Lua, Perl, etc.)
&gt; Should I learn another programming language probably a good idea regardless of anything else. Learning more languages open mind your mind to other ways of thinking and other ways of solving problems. &gt; Java dies or stops being popular this I'm not sure I will be alive to see, so I wouldn't sweat it. Also, if you're really proficient in any field, you'll probably be fine either way &gt; Or are people who say Java will stop being relevant wrong? this is tricky. Java may be getting less popular, but the jvm may not. In the corporate world, a lot of work is still being done in Java (sometimes for the wrong reasons, but still). In small-ish startups, some work is being done in java but (at least regionally where I live) the bulk of the work is being done in ruby/python/javascript and the like. 
So you are saying I can't build a microservice with just Jersey? Embedding tomcat into an app takes a few minutes to write a single class. You don't need spring to write a microservice. 
Thanks! I don't know how Ludum Dare works. Can you use external libraries when you do it?
Since Kotlin compiles to Java bytecode there is no difference in practice whether this lib is written in Java or Kotlin. If you look at the code examples you can see that they are written in Java (and throughout the documentation all examples are also written in Java). The developers of Kotlin have gone to great lengths to make interoperability absolutely seamless.
While for small business and startups they will mostly use Python, Ruby or JS the Java is the language of the enterprise. At some point you will reach so big threshold that from existing languages Java will be the best choice to switch to. You should learn other languages tho, your approach to programming will benefit 
It's the same as e.g. Apache Spark. There's a nice Java API with documentation, but it's not idiomatic and when you want to or have to look at internals (lets say debug or analyse traces) you have to navigate around another language.
No, of course not. you could write a microservice with Jersey, and it's a good API. I wasn't saying you need spring to write a microservice, it's an architecture and design that could be implemented with anything. But there is just a lot remaining to address besides the rest API itself - Circuit breakers, service discovery, dynamic configuration, leader election, caching and many other things that are non-trivial. Distributed programming is hard so tools and best practices, drawn from proven code (netflixoss and others) is helpful. 
Arquillian is quite decent from what I've heard, but it's not part of java ee / ee4j. I'm happy to update my comment if I've misunderstood something. 
Kotlin improves on Java's strong points and also compiles to JS (though I haven't tried it) and they're working on some native stuff. So it's very ambitious but it seems like it's becoming popular pretty fast.
Interesting, I'll keep an eye out for progress. Good luck! 
I'd be very curious for your perspective on how they compare, I have a lot to learn about Vert.x If you want to blog about it we can get it into this week in spring and @springcentral
Literally anything.
Quality post! And the answer is, as always: it depends.
Write a number base converter.
we used to employ the the committers, so I think we've contributed quite a lot, thanks for pointing that out. How much has RedHat contributed to Groovy? Or is it the usual imitate and give nothing back strategy?
we support it for spring boot apps on initalizr at start.spring.io. And unlike Swarm, Spring fully supports gradle. In fact, we just overhauled the whole system https://spring.io/blog/2017/04/05/spring-boot-s-new-gradle-plugin
Get relay for reddit. It's much better... 
well, the question was pretty straightforward, sorry you're having trouble. Kotlin is a bet, to be sure. Time will tell. But our bets have a pretty good track record.. In the meantime, this might help answer your question about what specifically we do for Kotlin. https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0 I haven't seen you actually answer a single one of my questions in this thread, why is that? You were going to say something about Java EE's Kotlin support, I think, right?
I'd argue with that. Zircon has an idiomatic api. It was designed **specifically** to be idiomatic for Java devs. Of course if you don't like it you don't have to use it. Another thing is that Kotlin is not that different from Java if you compare it to Scala. One of the main selling points to Kotlin is that it is easy to read for Java developers. Of course this is subjective but I checked it with devs who don't know kotlin and they were able to tell what is going on. Scala on the other hand has so much baroque syntax that if you don't know the language you can't read the code.
BaconReader fan here, can do all you want and more. Not the sexiest client, but very stable and functional.
good question. investigating.
apologies, they are release trains that bundle compatible spring data projects.
also, see http://platform.spring.io/platform/ distribution
I know webgl is really iffy in cross browser support right now, but a lot of desktop applications do just that and avoid os specific widgets. It makes a lot of sense - one ui lib that works everywhere.
Last time I tried jsweet it just crapped out at a simple example, I'll have to give v2 another look.
http://www.thekitchn.com/great-apps-for-coffee-lovers-215191
My guess is that it will become more mainstream once all browsers support canvas and more people realize that modern languages like kotlin already support transpiling to js
oh god, why? It's built in to java. 
Just because something is built into a language does not mean you understand how it works.
I've done a small personal project with it, worked great.
Spark, et al. are trash at machine learning. Scikit-learn on a large box actually scales better. And most production platforms are using something like [Vowpal Wabbit](http://hunch.net/~vw/) or some proprietary re-implementation of it. Source: I work at a digital advertising company.
Yeah, you can use game engines and rendering libraries. You should check it out.
Ugh. As good a job as the mods do, I wish there was a better way of dealing with these spam accounts - I've seen them on other subs, do auto-moderator bots actually help control content?
**Sidebar** -&gt; #Do not post tutorials here Also: **no spamming here** *Second warning* ([first one for reference](https://www.reddit.com/r/java/comments/6tybqw/client_server_communication_in_java/dlrrii4/)) third one is out.
haha control content? you would have never explained it like this lol this is fun
Make an app that can recognize hot dogs
hey, thanks for the time bro :)
What do you mean?
https://www.reddit.com/r/learnprogramming/wiki/faq#wiki_where_can_i_find_practice_exercises_and_project_ideas.3F Also: This subreddit is not about Java programming. Such questions should at best go into **/r/javahelp**.
&gt; Should I learn another programming language (...) Of course! You can't build a house with just a hammer. &gt; (...) in case Java dies or stops being popular? Or are people who say Java will stop being relevant wrong? There are always people who announce the death of language X in industry Y. This happens every few months or so. Strong opinions tend to attract a lot of attention and that's what these people are ultimately looking for. Java (or rather the JVM) will still be around for a loooong time. &gt; And if you had to choose a seocond programming language, which one would it be? This question is difficult to answer because it depends on where you want to be and what you want to do. Having at least a basic understanding of a low-level language like C(++) can provide you with very useful skills for learning pretty much any language.
Ok, are you looking for any feedback? I didn't launch it, but opening the source I immediately saw a lot of subjects that could be improved. 1) Why aren't you importing the classes properly? Doing new javax.swing.JFileChooser() instead of new JFileChooser()? 2) Lose the comments that explain nothing. "// Variables declaration - do not modify" "// End of variables declaration" - completely useless comments, you know what they are by looking at them. (Also those variables declared in a class are called "fields".) 3) You declared fields in the end of class (The ones you called variables). Usually they are declared in the beginning before methods. 4) You have stuffed everything in one class, the same class that contains main() method is extending the JFrame. I remember doing things like this when I started learning Java. How about trying to extract the main method out of this class and launch the JFrame from there? Maybe try to split the logic a little. Instead of one huge class try to split the logic to different classes. One or more that deal with UI, one that deals with saving/loading etc. 
Yes, well, I know the official position. However, is it any good in practice? Windows Vista wasn't better than Windows 7, newer isn't necessary better. OTOH we're not talking about Microsoft here...
I thought that you had to write everything from scratch. This changes things a bit! I'll definitely look into it!
was looking for some materials on this subject. thanks a lot!
I've been playing around with WAS and the only thing this entire experience gave me is some more gray hair. Everything IBM produces is like a pile of half-assed abortions, overcomplicated, bloated and outright stinks like hell. Let alone the ridiculous price tags they put on everything.
bullshit like lambdas will hurt java no end. Lambdas are good... yes. But not for a language like java that aims to bring general purpose programming to the masses. It makes java less easy... There's a good reason why visual basic got so far.
Is there something specific you are curious about? JavaFX is a fully featured GUI toolkit. 
....i think i coughed up a bit of sick/
Even if better than Scala and more readable, it's still different and not going to be a fluent transition from one to the other and back. The context switch of a mixed codebase is killer to productivity and stability. Either all Kotlin or all Java, both ways. Where I work we also got rid of Groovy. It was too much a liability to manage two languages and Groovy is even closer to Java than Kotlin.
Any good developer needs to be capable of learning a new language easy. Java isn't going anywhere in the next several years, probably longer. It's always good to known more than one language. When all you have is a hammer … Learn how languages are built, how syntax and grammar, finite state machines etc. Once you learn how languages work you can worry less about learning the "next big thing"/ 
Well, I have worked with all of the mentioned languages and I think that Kotlin is just a turbo Java while Groovy is something else (and more dynamic). At my current workplace we use Java and Kotlin in tandem (and node.js as well) so I can say that it boosts our productivity instead the other way around. I don't know why it is a productivity killer for you. There are multiple teams where I work (IBM) where they started adopting Kotlin and all of those guys use it in tandem with Java and there was a noticeable productivity boost in all teams. That being said, all of the above is a moot point since when you use a library you don't plan to modify it and your codebase won't be a mixed one. I've been programming for 10+ years and in 95% of the times you don't even need to check the source code of the library you use (nor debug it) if the documentation is good.
guess it depends what industry you work in
And/or the skill of the programmers.
Learn another language anyway. Some tasks are better suited to different languages, and you learn more about coding in general by knowing different languages so you know what in your code is a Java-specific quirk and what’s general to programming. I often code in Python now because it’s quicker to throw together some code for experiments. I don’t really like Python for large applications that need maintaining, but for quick experiments and computations it’s great. It has easy libraries for scientific and numerical calculation, and a lot of things that would take a lot of boilerplate in Java takes a line or two.
Consumer wise though (i.e. just for the average joe), is Java really relevant anymore for stuff like applications?
"[The Eclipse IDE] has a complex history that leads to a strong dislike by many developers" What are you refering to?
You may do some hint at the bullet list in "why zircon" as I skimmed only to the list and thought: the heck? That are drawbacks and was nearly leaving as I thought: that can't be your selling points! Glad I reread!
Nobody cares what you think Java should be. Thank God.
Good point! I'll fix it now.
And even if it's amazing people will need to notice that it exists. Software made for regular folks is a dead market except for two exceptions : either you're filling a hole that has never been filled before or you are making a video game.
AOP is huge in Java development. Here's a common example: @Transactional private void doIt() { // .. DB stuff .. } The `@Transactional` aspect is an example of "around" advice, intercepting the call do `doIt`, and either creates or joins a transaction before executing `doIt`. If `doIt` throws an exception, the aspect catches the exception and rolls back the transaction.
AOP logging is the best, if your app can afford the slight penalty hit. I recently implemented it in a website I made and being able to see all method calls in a request, a general idea of the params and their execution times have made troubleshooting issues way easier
even if you're not using Swing/JavaFX in an everyday basis (and if you're not programming in Java, chances are high you are not), you probably interact with a lot of java code through Html or something. And even if you don't, if you own (and use) an android phone, you're using something that is not java but looks/smells/taste like java so yes java is still relevant consumer wise, even if it's invisible
Was it WAS Liberty? If so that will be the first time I've heard that about it - what did you have difficulty with?
have fun writing your map and reduces using anonymous classes then...
That makes a lot of sense, thank you!
That's really cool, how much traffic does the site get?
In my company and a few other places where I dabbled around the engineering team always choose the Java EE implementation, or in some cases Spring. Frankly, operations solely choosing the Java EE implementation is not a best practice and rarely if ever is there any good that can come from it. In startups it's often devops and then the team together chooses all tech (also build systems, preferred editors etc)
Th entity manager choice largely depends on your infrastructure. I've gotten by with the standard just fine and only faced complications when trying fancy things out. Futures and async are great; again only where necessary. Always measure and prove these feature's worth before complicating your system. That goes for "enterprise" or not.
no, 7.0.07 or something... Maybe I should check out liberty, although am afraid to touch anything ibm after being ... hurt. Kind of made an impression that monkeys with keyboards made the whole thing.
you can out me this time too :)
[removed]
Java has been the most popular programming language in the world for many years consecutively. It takes a few weeks to learn a new language, and a few months to get really proficient with it. You can worry about your Java skills being obsolete maybe when it falls out of the top 5 languages.
Of course, it was a completely hypothetical 'if'. For any reasonably useful program there is no required quality level that programmers can just magically produce to with no testing.
Im looking to move out of state. The most amount of jobs in my search were in this order * Java / Java EE * .Net * Python * Ruby/Rails * C++ I have professional experience in all of them, and use Java/LibGDX for personal projects. I love Java, and I'm actively trying to get a job with Java. Doesn't hurt that it had the most job posting of all languages in the area I looked.
I don't want to steal Jin wangs idea
There is more than enough work around in Java that learning the language and frameworks like Spring and Hibernate will definitely be worthwhile. Often it's the needs of your current project or one that you may be joining that governs which languages you will need to learn. 
Wow, v7 is quite old and I'd certainly say things have significantly improved since then. I'd definitely suggest trying out Liberty, or Open Liberty. We really focused on making things easy, fast, and modular with developers at the heart of our focus. Give it a go, and genuinely let us know what you like or don't like - we take all feedback seriously and want to make sure Liberty is as good as it can be :-)
AOP is critical. Even outside of spring, there are tons of things using it.
We use it for caching, authorization, metrics and transactions. They are good for cross cutting concerns. 
I've used it a lot before for metrics gathering etc. Using aspectj instead of java proxies for the implementation makes the performance hit almost non-existent.
I used netbeans, and the vague comments are how it generates. Also, the weird declarations are just me failing to be consistent with the generated code. Subject 1-3 are things i can't really fix. 4 i could work on fixing, but it'd be a hassle. 
I know that Goetz said Local-Variable Type Inference ([JEP 286](http://openjdk.java.net/jeps/286)) will be ready for the March production release.
What libraries are implementing it? AspectJ only? 
We had in house custom libraries prior to implementing spring
&gt; If thundering sales calls and formal attire aren’t enough to make your engineering team happy campers, being available as an on-demand IT resource will surely engage them. Shitty day at work, no?
Jersey 2.26 implements JAX-RS 2.1 https://jersey.github.io/download.html 
I use Jersey via annotations in some of my projects. aopalliance is the library used pulled in via transitive dependency.
1. Not Java related 2. No spamming
It's now delayed to december :(
Well good luck adding new features and syntax highlighting to this then. Perhaps try to untie the project from Netbeans as a first thing, so it would not depend on it. Swing does not require Netbeans to run. You will be quickly running against the wall trying to extend something like that in complexity. Also, since it's open source you limit the code to very small fraction of people by tying the project with Netbeans generated code. What about IntelliJ and Eclipse users? Wasn't your intent to write something that people wanted to use? Currently any other text editor which isn't tied to Netbeans already has a huge advantage over you from the development point of view. Think about it.
Joshua Bloch recommends this book as well
I've been wrighting code since 1983..... so a few more years. Let me say, I dont believe you. You must test, otherwise how do you know your code works or not? do you just release it if it compiles without running it? Or do you do as I did for many years. Write a bit, run a bit. write a bit, run a bit.... gradually building up the application knowing what you've built on is solid..... This is not writing unit tests.... but rather just manual testing as you go. I have even wrote some code in complete isolation, and messed around with it until it worked, then copied / pasted it into my mainline. I've done this from the very beginning, and I can't imagine programming without doing it. Writing formal automated unit tests makes this process QUICKER! honestly... because instead of you fireing up the application each time, you just click the test button on your ide. and all your tests run, and you have instant feedback where you need to fix your app. You no longer need to run up the entire app, and navigate through it to find the bit of code your working on. You just write the test that shoves data into that code, run it, and see what the result is. 
I was at JavaOne. AMA
Yup, Jersey is the reference implementation for JAX-RS. So, it is always the most current. And unlike many reference implementations, it's surprisingly suitable for production use as well.
Bits and pieces of Panama, Valhalla, Amber, loom 
**JPA Security:** use some way of prepared statements; please do not use String concatenation to _generate_ your query strings **JPA Performance:** do not use it for bulk processes which are time constrained. It adds a bit of overhead which can be too much for your requirements. But as always: measure to prove it **Future:** Imo use `CompletableFuture` for async since it offers a better API. Eg. you can chain calls.
It's about picking the right tool for the job. Java is great at running big fucking applications at amazing speeds, but it does require a lot of disk space for the JVM, memory and a time consuming compilation step. In my oppinion this can be a real disadvantage for small microservice style applications where you want to deploy and test often and compilation really slows down your workflow. There is almost no way around Node JS in almost any field, especially if you're doing frontend work, so that I would say is worth a look. Python, Ruby, Perl or PHP I would only look at if I have to, their future is not any more sure than Java's. But it depends on what you're doing. Java projects are often a pain to get running (not if done well though) while with node it's just npm install &amp;&amp; npm run dev, this makes Node also better for containerized applications.
18.3?
What did they say about EE4J? What people at JavaOne think will happend?
It's the new release schedule (and versioning if they changed that already), they're aiming for two releases per year, one in March 2018 (hence '18-3) and one in September (18.9) with the September version being the Long Term Support one. https://mreinhold.org/blog/forward-faster They want to be able to add new features faster. With Java 9 some minor improvements were held back by the fact they had to wait for Jigsaw.
I was there too. The general sense I got was that attendees loved the move by Oracle, but disliked the EE4J name.
 &gt;They want to be able to add new features faster. With Java 9 some minor improvements were held back by the fact they had to wait for Jigsaw. This doesn't really change anything though, one feature can still block others in that release. If they actually wanted to deliver things quickly they could've easily been released in an intermediate version like 8.5 or whatnot. Or if that one feature clearly is not getting ready on time, move it to the next release. Just making the release cycle faster doesn't necessarily help against such delay issues anyhow.
Ubuntu has a similar versioning scheme
They're making more releases, but also working with the train idea. Every 6 months, a train leaves the station and whatever's on the train will be shipped. So when a feature is not ready, it will have to wait 6 months.
They really have to discipline themselves for this train idea instead of delaying everything multiple times for trying to get the last feature in, which turns into a rushed mess.
The EE Guardians, this EE-Central thing, the EE4J rebranding (or not rebranding, just a new implementation? I dunno), the fact that EE moves off the JCP from what I've heard (or not? Might've just been a rumour), the fact that many things were announced before being properly announced at JavaOne... What *is* this thing? Official, non official? Who's behind it and why?
I wrote a [blog post](https://niels.nu/blog/2017/spring-boot-aop.html) about it a while ago. It also goes into details of why it's useful. Spring itself uses it extensively.
Of course non official. But it's good that there are unofficilal initiatives about JavaEE/EE4J. It means that there is a big community using it. The EE Guardians achieved a lot of results. I don't get the problem with that.
&gt; It makes java less easy... Anything 'new' has a learning curve. It's just something you need to get over. After that code is easier to read just because there's less of it. People had the exact same argument when they added the for-each loop in Java 5. 
Is this a new site (the domain was created in 2016)? Because it still has the old naming (Java EE as opposed to Eclipse Enterprise 4 Java) and also links to a lot of "Java EE" stuff on the Oracle site that's probably not going to be there much longer. Are Arun Gupta and Arjan Tijms aware that they are 'contributors' to ee-central.io? 
I have no numbers on their achievements, sure there may have been some. I'm just saying that things related to "J2EE4J" currently seem a bit uncoordinated, so I personally don't think this "initiative" is helping right now. Gah, sometimes I really wish the Java ecosystem was a tad more like Microsoft / .NET: Less community driven, more vendor driven. But that's just my opinion. Yours obviously differs.
Seeing that Microsoft is trying to involve the community, it seems strange to read your opinion. .NET has been mainly ignored by developers for a reason. Can you even imagine EE4J without Hibernate/JPA and Weld/CDI?
Yes, we will have to wait and see how it goes. Even though the delay would only be 6 months, it would be natural for teams to try and finish their feature before the train leaves, leading to a rush just before the deadline passes. It all depends on whether they have the right gatekeepers to coordinate this.
You're simplifying things. The reason why .NET has been less popular than Java are much more complex than just them having been ignored by developers "for a reason". Sure, developers do influence decisions, but they don't make all decisions. I'm not sure how JPA/CDI is related to this discussion.
Can you explain, please?
I'm assuming you mean the first. In return, can you explain your JPA/CDI comment, please? My explanation is simple. Let's look at an analogy. There are quite a few PL/SQL developers out there. Do you think developers would pick PL/SQL "for whatever reason"? Probably not, it's a reasonable choice for logic in the database *if using the Oracle database has already been decided upon*. And that, I'm certain you will agree, is probably not a developer's decision. Likewise, the fact that stuff runs on .NET or Java or whatever is often decided by a customer, not by a vendor. Trying to connect popularity to some fuzzy notion of "developer community" is simply not going to work on a larger scale. All I'm saying is that Java is popular for many many many reasons far beyond the fact that it is more community driven than .NET (but probably much less than e.g. Python, PHP, Ruby, and others).
I understand your PL/SQL example, but in the Java EE world, standards were ignored many times and new standards emerged from community contributions. For example, Entity Beans were created by the vendor, but they were ignored by developers, who used Hibernate instead and then JPA was added by the vendor.
whatever's ready when 18.3 rolls around is what goes in if i understand correctly. it's a timed release, not a feature release
I can't read Fn as anything other than "Effin' ". The effin' project has been released by oracle. They made an effin' development kit. Hopefully no one starts talking about Fn as a service......
Context switches are always negative to some degree (except in JavaScript)
What's the rationale for not having that for fields? Seems counterintuitive. Thanks for the link though.
Huh. So, they're already abandoning the version number scheme introduced with Java 9 (Verona)?
&gt; Hopefully no one starts talking about Fn as a service...... that is called a brothel...
&gt; Subject 1-3 are things i can't really fix. Sure you can. Don't blame your IDE for stuff in your source file. The stuff that is generated is just based on templates that are trying to 'help': you can disable it or remove them. As far as stuffing everything into a single class, one of the most used pattern for GUI applications is the [MVC](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller) pattern. I'd strongly recommend adopting it; your one main source file is quite a mess and will be very hard to extend. Also what are you trying to accomplish? /u/deadlock_jones gave you valuable feedback but you seem rather defensive about it. P.s. asking for donations is a tad premature too ;)
Why even give a third chance with people like this?
It’s not a farce. You can port your app within a very reasonable time between EE servers.
Yes, it looks like it: http://www.oracle.com/technetwork/java/javase/overview/eol-135779.html JEP-223 only says: Use semver, such as $major.$minor.$security; it doesn't specify how. Project Verona implemented it in the way of "9.Y.Z", but another project could implement it as "YY.M.z". However, "YY.M.z" is not really semantic, because the $major doesn't change because of a major change, rather because of new year's day. Maybe they will use both an internal and external version numbering scheme, such as the external 18.3 corresponding to 9.2.0 internally, kind of like how Windows 8 is internally Windows 6.2.
The key idea to realize is type inference does NOT mean weaker typing. You can very much have a strong typing system while having a lot of inferences. Take languages like Kotlin or Scala, `var number = 5` can very much be inferred as an `int` type and every time you want to use `number` it will always be of the type `int` by the compiler. This works fine for local variables, but it loses grip at the field and parameter level. `void doSomething(var numbers)`, how would the compiler know that `numbers` is supposed to be an `int`? Or maybe you wanted it to be a `List&lt;Integer&gt;`, a `Set&lt;Integer&gt;`? See, at this level the type cannot be inferred anymore and you'd be doing guesswork (dynamic typing), which is bad for Java. This same logic applies for fields. `var numbers` cannot be inferred until it is initialized, so the only way for this to work is if you force developers to initialize the variable before it's used anywhere. So either it'll have to be initialized directly (generally bad practice for Java fields), or in the constructor, treat it similarly (but not quite exactly) like a `final` and force initialization before usage so the compiler can get a type. Really though, that is just quite a lot of work to get it right, so it's just best to leave it completely explicit so we can maintain strong typing in this case.
And with Java (if done correctly) it's just git clone &amp;&amp; ./gradlew bootRun (or whatever your framework tells you to do) Both Spring, Play and JRebel has hot code redeploys for development scenarios, and for production you are using an automated build system, right? Not saying you are not correct when saying to learn NodeJS (for frontend at least) but your other issues are not really issues if done correctly.
Yup, we use it in prod and it works great.
Stephen Colebourne wrote a post asking to reconsider: http://mail.openjdk.java.net/pipermail/discuss/2017-September/004352.html Later in the thread, Mark Reinhold mentions that SC makes good points, and that they can talk in person (at Java One?).
Ugh. Just as soon as Java finally gets a sane versioning scheme, it gets scrapped in favor of more insanity.
Learn another language now not out of fear that Java will evaporate overnight leaving you unemployable, but because it'll help make you a better programmer today. Pick one that's different from Java in some significant way. If you want to stick with the JVM ecosystem, I'd recommend Clojure. It has runtime compatibility with Java but is a LISP variant and will introduce you to some new ways of thinking about breaking problems down using metaprogramming. If you don't care about the JVM ecosystem, Haskell is a reasonable choice; its type system will be a revelation if Java is the only language you know so far. Both of those languages, if you learn to think in their idioms, will cause you to write your Java code differently. And don't really worry about this too much. I've picked up at least a half-dozen new languages on the job over the years as the need arose (in addition to others I've learned in my spare time out of personal interest). It's just not a big deal in my experience. 90% of being good at programming is about problem analysis, high-level design, and good collaboration on a team; the actual letters you type on the keyboard are necessary but not the most valuable thing you're bringing to the table.
it is definitely a farce.. i can't even move my app between different major versions of the same EE server... and i'm not even talking about api changes i'm talking just about underlying behavior being different causing things to break.. the whole point is i should not have to "port" my app
I noticed that recently too. Kinda sad but at least it gives me some time to finish part 2 of the Helsinki MOOC.
Yeah you have a point. Not everybody has their company pay for JRebel though and hot code reloading with the Oracle JVM works only in very limited cases. Out of interest, how long does your Spring+Play application take to compile+boot though. Our JVM applications are still on top of tomcat &amp; glassfish and it takes about 1-2 minutes to build (without all of the dependencies) and then another 1-2 minute to boot+deploy our wars. Which is a bit painful. Incremental builds/deploys during development are of course a bit faster, but still annoying... Sure we have jenkins running, but it happens that you have to wait for it too.
This is very thorough, thanks!
General optimism about the future. Although, I noticed the question asked "Why the Eclipse foundation? Why not Apache?" was never really answered. I asked an Oracle employee and got corporate-speak response. 
&gt; Let me say, I dont believe you. You must test, otherwise how do you know your code works or not? do you just release it if it compiles without running it? You're being pedantic. Everyone tests their code to that extent. When professional developers talk about 'testing', they are referring to systematic frameworks for repeatable tests (see the 20 types of testing listed in the article) and/or incorporating rigorous testing into the development process (TDD). These things, while generally effective at improving software quality, add overhead to the development cycle. You can develop and deliver code without all of that ceremony with greater risk. &gt; and all your tests run, and you have instant feedback where you need to fix your app. Not all software is conducive to this type of testing. 
What's more interesting is that footnote: Users of Java 9 (currently only having ~5 months to transition) should update to 18.3 immediately. So once you're on the 18.3 train (especially the 18.9 LTS train) you should be safe for the coming years.
Yes, but Ubuntu is a distribution of different software that has semantic versioning.
Yesterday's key note at javaone mentioned that it's only for local variables. 
I think they also mentioned a major release every 3 years. 
Wow, this sounds like such a pain in the pass for someone in your place. I was going to come in here and recommend Jsoup but you need to build one from scratch so maybe check out this Stack Overflow question/answers: https://stackoverflow.com/questions/238547/how-do-you-programmatically-download-a-webpage-in-java Also something like this should be posted in /r/javahelp in the future.
My personal opinion on why they chose Eclipse over Apache was the history with Apache, Harmony and TCKs. Also, Oracle has used Eclipse in the past for TopLink/EclipseLink.
thatsthejoke.jpg
[thatsthejoke.jpg](http://i.imgur.com/tEjeMu8.jpg) --- ^(*Feedback welcome at /r/image_linker_bot* | )[^(Disable)](https://www.reddit.com/message/compose/?to=image_linker_bot&amp;subject=Ignore%20request&amp;message=ignore%20me)^( with "ignore me" via reply or PM) 
I know right, tell me about it! But okay thanks, I'll give that a scan and see if I can find anything I can utilise…. Also thanks, I'll post there too. Cheers for your help, I appreciate it :)
Honestly I'm more of the thought that Java is so powerful because of all the libraries available, they should be teaching you how to find and utilize the right libraries for the job instead of rebuilding non-trivial things from scratch. Having working knowledge on how Jsoup API works is more important than having built a parser yourself, IMO.
Not much at all, it's a small site for my wife to track her dog walking business. I got the idea to do this from my old job, ,and their traffic is about a couple thousand hits a week. Not too busy either, but much more than the one I made. 
Also MicroProfile is already under Eclipse, it makes sense to keep it and EE/EE4J together.
&gt; unlike many reference implementations, it's surprisingly suitable for production Not on topic, but Weld, Eclipse Link, JAX-WS, JAXB at least are ref. impls. that are suitable for production. Why is it surprising that the ref. impls. are suitable for production?
Thanks, I was wondering if I can use it in Wildfly since it already uses RESTEasy and I won't get conflicts.
HTMLUnit is a good headless browser. I use it to scrape sites at work Am in the process of changing to WebDriver using Headless Chrome though
Make sure to grab OpenJ9 binaries from https://adoptopenjdk.net/releases.html?variant=openjdk9-openj9
&gt; Helsinki MOOC What's that book good for? I'm gonna use the time to finish Java Precisely, Joshua Bloch recommended to read it before his book during an oracle interview
Go to /javahelp and ask there. But I'm wondering that java web apps are still function. Thought they are deprecated. 
There's not really sufficient information to help troubleshoot here, unless this was some kind of widely known bug. What is the webapp running on? Tomcat, Tomee, a standalone module like Spring Boot, etc... When you say "add the same path," are we talking to the Windows environment variables? To User Variables in the top, or System variables at the bottom? Is JAVA_HOME set? Is a full JDK installed? If the webapp needs to compile JSP files or something similar, if it's just a JRE there's no compiler.
OMG, why?!
Yes, you'll need to use a jboss-deployment-structure.xml file to exclude the built-in javax.ws.rs whatever in your deployment. You can always write directly against CXF, Jersey, or RESTeasy - you just lose the portability that you get by writing against JavaEE namespaces - you know, if you just wanted to try something out. *Additional: It looks like RESTeasy implemented JSR-270 a couple months ago (https://github.com/resteasy/Resteasy) - see if that version is included in Wildfly 11 (currently release candidate 1 is available, so it should be pretty stable, and they could always use more people trying things, in case you find some other error) - this would let you avoid messing with deployment structure XML files, too, if it's included. If it's not, you could always just pull down whatever they have and build it, then use that with Wildfly 10/11 (assuming no other dependencies) with a jboss-deployment-structure.xml file to exclude the other version. See https://docs.jboss.org/author/display/WFLY10/Developer+Guide#DeveloperGuide-ClassloadinginWildFly for info on classloading in Wildfly 10 and a start on how to exclude things. Ask if you have questions, I can try to help if it's not too crazy (and if I can respond I'll say if I can't help).
&gt; And unlike many reference implementations, it's surprisingly suitable for production use as well This is a bizarre statement, can you give me an example of a reference implementation that _is not_ suitable for production? 
The simplest method is just to use make straight http requests, following some sort of graph traversal algorithm for links (try to avoid loops and make set some sort of max depth per site), and strip out html tags (you may want to ditch the stuff between tags. Depending on what you're trying to capture some sort of html parsing and/or DOM library may be useful.
Payara 5 alpha and snapshots are available for Payara Server and Payara Micro. For Docker: * `docker run -it payara/micro:5-SNAPSHOT` * `docker run -it payara/server-full:5-SNAPSHOT` Direct download links: * [Payara Server 5 snapshot](https://oss.sonatype.org/service/local/artifact/maven/redirect?r=snapshots&amp;g=fish.payara.distributions&amp;a=payara&amp;v=5.0.0.174-SNAPSHOT&amp;p=zip) * [Payara Micro 5 snapshot](https://oss.sonatype.org/service/local/artifact/maven/redirect?r=snapshots&amp;g=fish.payara.extras&amp;a=payara-micro&amp;v=5.0.0.174-SNAPSHOT&amp;p=jar) I think there should be a beta coming soon and the target release is Q1 next year (so version `5.181`)
Just include Jersey 2.26 as a dependency in your application and you can deploy to most any container (e.g. Tomcat 8.5.x). If you include it as a dependency you don't have to deploy to a Java EE 8 container (which only Glassfish 5 is available now, couple others in alpha/beta).
Might be an environmental variable thing. Check your PATH and JAVA_HOME variables.
Yeah I was thinking like: * Flying Car SPI * NIO for IPP (Inter-Planetary Protocol) * Martian language support * -XX:UseQuantumMathLib 
Are you using IntelliJ?
very insightful. you get a star!
That was one of the first things I checked. Everything checks out okay there.
When you say web-based app, are you referring to an Applet-based app? Or something more traditional like SpringMVC or a JEE Servlet app?
Under Java Runtime Environment Settings in the Java Control Panel where it lists Platform,Product,Location,Path,Runtime Parameters,Enabled,and Architecture. If I click "add" and navigate to the same path as the one that's already listed in the first slot, "C:\Program Files\Java\jre1.8.0_144\bin\javaw.exe" As to windows Environment variables, I've checked those, JAVA_HOME is set and everything else there looks to be right.
The joys of working with outdated Government systems.
Ah shit but I don't have any idea why it is doing this. Maybe you can download an older version of java 
We still need to know what you're running this on, and how. 1.) Is this on a server where the app is deployed, or your dev workstation? 2.) What server or servlet container are you using, and are you using it standalone or in an IDE? 3.) What exactly is JAVA_HOME set to, and is it set in the USER or SYSTEM section of the environment variables (or both?) C:\Program Files\Java\jre... is definitely a standalone JRE, and NOT a full JDK with a compiler. If your web app uses JSP files, you NEED a full JDK.
It's not a farce, I have moved several apps from Weblogic that only used servlet/jsp to Tomcat without issue and with no changes needed. 
certainly, if you don't use a variable declared with var, you have no way to know what it is. you can generally infer what something is from it's usage, though there are a few things that make this a risky proposition in a language like java. but what about for fields that are initialized at declaration? class Course { private var students = List.&lt;Student&gt;of(); public List&lt;Student&gt; students() { return this.students; } } edit: just noticed: &gt; So either it'll have to be initialized directly (generally bad practice for Java fields) why do you say "generally bad practice"? something to do with preferring lazy initialization?
&gt; (and expensive) EE server Glassfish and JBoss are free if you want a full app server. Tomcat and jetty are free if you just want a servlet container. Actually the only app servers that I can think of that cost money off the top of my head are Weblogic and Websphere. Java EE is a standard and the app servers implement it. There is no reason a developer needs to be specialized in any particular server. 
Why? Because javascript is bad enough in itself? :D
&gt; desperately clinging to the fat server. You understand that Spring Boot is a opinionated configuration mechanism for Spring MVC right? And when you use spring boot to build a fat jar it embeds Tomcat right? How is Spring boot getting you away from a fat server? Even if it was, why is that a desirable thing?
I use JPA in an enterprise server codebase. There are a ton of nuances in how to use it properly, and if you mis-step with it, it can make your world kind of a living nightmare of deadlocks and data corruption. 1) Yes, you need to use entity managers to perform queries and find objects by their identifiers. You don't need to manually manage transactions. JPA will commit the transaction when the request completes. If you use @TransactionAttribute to create a new sub-transaction, it will commit when that method invocation completes, but ONLY if you invoke it from an injected @EJB proxy. Invoking anything from "this" ignores any and all Java EE annotations. 2) Any new sub-transactions you create via @TransactionAttribute can NOT mix entities from the parent transaction passed in via parameters or you will corrupt the cache. By the same token, do NOT return an entity across that boundary and expect to modify it in the parent transaction. All entities should ONLY be modified within the transaction from which you retrieved it. 3) Yes, @Asynchronous is very useful for parallelizing multiple operations. However, keep in mind the caveat from #1 above that, just like all other Java EE annotations, the method will only actually be executed asynchronously if you invoke it via an injected @EJB proxy. It will NOT be executed asynchronously if you invoke it locally from the "this" reference. I recommend reading up on the javax.enterprise.concurrent.ManagedExecutorService if you plan to return values from the Future. Also keep in mind that even if the @Asynchronous does NOT return a value, your current transaction and hence the current request (if it's a web service, for example) will NOT complete until all @Asynchronous invocations complete, whether you are waiting on a return value from them or not. Edit: Not sure what your questions about security are. That's all setup as a part of the JDBC connection configured in the app container, so the EAR or WAR will never have any knowledge of the database password. If you have a specific security question, just let me know. Also, I would give a thorough read through the [JPA spec](http://download.oracle.com/otndocs/jcp/persistence-2_1-fr-eval-spec/index.html) (that link is assuming you're on Java EE7).
Github link is here https://github.com/fnproject/fn Looks quite interesting, you still need to setup infrastructure to run it though. AWS lambda does that part for you. 
Composable repositories look nice! One question, though. Why are the implementation beans for fragments looked up by name, and not by type? That would seem more obvious to me.
One additional note. Entities are either in an attached (aka "managed") state or in a detached state. Do not mix attached and detached entities or, again, you will corrupt the cache. When you create a new entity, it is initially detached, which is basically just a POJO. Call EntityManager.merge(), and it will hand you back an attached entity, which you can then use to assign relationships to other attached entities.
the fuck does GA mean even?
It's not a book, rather it's an online introduction to Java that is split into two parts. It's a highly recommend resource for Java beginners on /r/learnprogramming. Part 1 can be found below: http://mooc.fi/courses/general/programming/how-to-get-started.html
1. Stop calling these things "standards" :) That's an insult to *actual* standards, e.g. the ones governed by ANSI or the ISO, etc. 2. Entity beans (EJB 2.0) were widely adopted and they were a "standard" too (by your definition). It's just that EJB 2.0 entity beans were crap and bloat, which is one of the main reasons for Hibernate's success. Anyway, we're digressing...
&gt; you still need to setup infrastructure Thus defeating the point of ‘serverless’. The whole point is that it’s someone else’s kit and you don’t have to think about it. The value of this will be if some enterprising entity picks it up and runs it as a managed service, ala AWS Lambda. But then, you’ve already got OpenWhisk and a bunch of other players on that space already. Good luck, Oracle.
Thanks, I looked at 11 CR1. It seems to implement RESTEasy 3.0.24.Final where the latest is 3.1.4.Final (though their release date is the same). Honestly I didn't see SSE implemented in any of them and their [web page](http://resteasy.jboss.org) still mentions only JAX-RS 2.0. Can you have a look please? &gt; JSR-270 370 :)
No need to curse. https://stackoverflow.com/questions/2107484/what-is-the-difference-between-springs-ga-rc-and-m2-releases
Especially as we’re now looking for implementations of all interfaces implemented, a by-type lookup would significantly increase the likelihood of finding multiple potentially available implementations. We could investigate moving there or at least allowing to opt-in to that, however. Feel free to file a ticket.
Exactly, anything is better ;)
At least we agree on something. :)
This gets into subjective territory, so the only objective thing I can say is about usage numbers. Not many people use Glassfish in production. That applies to the included technologies too, like EclipseLink or their JAX-WS implementation. Some exceptions are JAX-RS and JAXB. What I've run into is situations where the RI strictly follow the spec, but do little else. So, for example, I'd lose several Hibernate-only entity annotations if I went with EclipseLink, with no suitable replacements.
It occurs to me that I'm in this deeper than I realized. Unfortunately I only have access to work on the computer periodically when the issue arises (when it's being used in a courtroom setting), and I haven't had an opportunity to fully explore the issue at length. I did check that both the System and User paths were set correctly, though of the top of my head, I don't remember what "correctly" is. I guess I was just hoping this was one of those "oh yeah, that's a thing. Just do this to fix it" kind of deals... 
Spring Boot usually starts in around 40 seconds for a mature application from Intellij, hot code reloads takes a couple of seconds. 
Thanks Ollie. I don't feel strongly about it, I just wondered why it is the way it is. 
That's exactly what it's for. People who can't or don't want to run on Amazon, people who want more control and people who want to prevent lock-in to Amazon. If you use Lambda, you're stuck on Amazon for a long time. 
&gt; I think Glassfish 5 was released with it so can I use a Jersey dependency? Yes. All you should add to pom.xml is something like &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;8.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; and that's all
I guess the advantage to running something like this is you get a bit more control over things, provide more CPU/memory options etc 
Anyone know if this affects other downstream components which share libraries w/Tomcat?
I hear what you are saying, so I found a netbeans independent method using eclipse. I had a problem eith the main.form file anyways. Now, i can use a gui designer and follow conventions properly. I will also be able to make my project use multiple classes for different things. Thanks for all your help. I really appreciate it. I will keep what you said in mind. 
I agree with you, Lambdas are just annoying when shoehorned into Java which isn't really meant to have them. It mentally jolts you out of the mindset you have for writing the rest of java code, and is just one more different way to do what you can already do.
&gt; I have found, throughout my years of treading these waters, that the people that claim "writing tests slow down development" are people with only a few years experience. Good test (unit, functional, integration, etc) have a minor up front cost that pays YUge dividends later. I've found the people who think automated tests are "magic" are the people with only a few years of experience (in the "knows just enough to be dangerous" zone) or people who don't actually track the results of what they claim (pretty common in the corporate world). 1\. It takes 2-3x longer to write thorough tests. 2\. Devs who do write tests often focus on pendantic testing rather than testing the important stuff. For example, writing a layer to mock out the db and the ui, while completely neglecting testing things from the user perspective - automating the browser to test the actual running app. 3\. Tests quickly fall prey to corporate reality, where writing them ASAP becomes the most important goal. So people write quick meaningless tests so they don't get put on a "performance improvement plan" or whatever that's their boss thinking they're slower. Quick easy pointless tests look the same to the boss, but get done far faster. 4\. Realistically, tests quickly become a big rolling blob that no one maintains. Add new functionality? In dreamworld you update the tests, in practice people just comment out the tests that fail because again they can't afford to look bad productivity wise compared to their coworkers, and updating tests for existing code takes even longer than writing them originally. 5\. Tests add a huge amount of wasted time if your requirements are constantly changing. I've never seen a situation where the boss just says "We're all going to write tests now!" hasn't been a complete waste of time. 
You can certify for SE 7 Programmer II, and then pass upgrade exam to SE 8. I expect that to be easier than upgrading for SE 8 on first level and then passing full-blown SE 8 II exam.
a d v a n c e d s h i t p o s t i n g
It's also possible that I missed something - when you say Java web app, do you mean an applet embedded in a web page? IF so, I'm relatively useless in terms of having a chance of quickly troubleshooting it - my Java experience is all console and web/application servers.
Java devs are furries confirmed
DELETE THIS
Hey there
Did you not understand that this is the joke that he had already made? I can never understand why people repeat people's jokes back to them. It must need a special kind of autism.
Amazing support for reactive ! Nice to leave the decision to the user whether to jump on it or just upgrade from spring 4 without any investment yet on reactive. Not sure why people are trolling with JEE or EE4J in this news, Spring is the most popular framework on the jvm and arguably still features ahead of the spec. That's just normal process, once Spring establishes a usage pattern, it goes into spec, nothing wrong with that! Spring was the first java microservice framework (&lt;3 Boot) and is on track for 1st enterprise reactive framework. Kudos to the team !
In every application I've tried, AOT actually decreases startup performance because of the time it takes to load the shared library. Class Data Sharing (CDS or AppCDS) might be a better choice [1] Graal VM (Future of Java) has a `native-image` tool that generates executable binaries from jars, classes, etc. It can't compile JavaFX or Swing applications yet, but Hello World is ~3mb and takes .004s on my machine. Graal is also interesting as it turns the JVM into a multi-language runtime. The current early-access builds include js, python, R, node, npm, ruby, and java, all running (fast) on the same VM. [1]: See for example, http://mjg123.github.io/2017/10/02/JVM-startup.html
Damn, this is a top-notch shit-post! If it weren't so irrelevant to the sub, I'd give you gold.
Wildfly 11 is still a EE7 server. The are starting EE8 in Wildfly 12
They could have some fun user meets. https://www.effenvodka.com
Thought so, thanks.
Okay, well this is a good question and there is a lot to say about it, but I feel like if you're grouping fields together without recognising the difference between public/private/final/non-final fields you're maybe already a little lost. - Private final fields with static/inline initialisers; yes that would work just about the same as local inferred variables I suppose. - Public final fields with static/inline initialisers; similar story, but the *interface of the type* becomes dependent on the inferred type of the initialiser expression, which you will at some point realise is utterly terrible when e.g. the `new HashSet()` initialiser you want isn't covariant with the prior `new TreeSet()` initialiser a user depended on. *(Edit: this is the same reason method return type inference is often an incredibly stupid idea.)* - Private final fields initialised in the constructor; this starts to get awkward. The ultimate inferred type may be lower-bounded to expressions in *multiple constructors*, and any changes to any of them, or to expressions which refer to that field, may interdepend in unpredictable ways. - Public final fields initialised in the constructor; the worst of both the previous worlds. - Private non-final fields; well at this point you're getting a whole lot of action-at-a-distance. Every expression in the class which references the variable has to add type-bounds to the ultimate inference variable representing the type of the variable. This is a beyond-combinatorial explosion of complexity. If making things intuitive is what you want then don't unravel this thread. - Public non-final fields, haha I hope you already see why this is a horrible shitshow. Can't make changes which are covariant *or* contravariant in type. Where is the type even inferred from? Just all the uses in the same class file? Ew.
Why are you doing these in the first place?
To me this just feels like overcomplicating everything. Just infer the type when the assignment happens right in the declaration. Yes it will become part of the interface but why shouldn't it, for TreeMap/Collections that might be bad, for String it's fine. Business Objects can also very well b defined by class rather than by interface making it fine again. I was expecting type inference to only work at declaration (also for locals) is that not the case? Again: feels overcomplicating for little benefit.
&gt; To me this just feels like overcomplicating everything. I'm not the one overcomplicating anything, I'm just giving the facts. &gt; Just infer the type when the assignment happens right in the declaration Like in my first two bullets? Yeah. Like I said it works in the first of those two cases. I'd be okay with that, even if it does start to feel a little inconsistent. But if you think that the issues raised by the second bullet are insignificant compared to the small convenience of omitting type in those few circumstances ... well I would question your experience and reliability.
I, uh, gotta change some stuff
&gt; Thus defeating the point of ‘serverless’. The whole point is that it’s someone else’s kit and you don’t have to think about it. consider: virtual machines do not ipso facto mean that you're free of managing infrastructure. it just means that it compartmentalizes things and allows for the commodification of infrastructure. similarly, functions as a notional unit of deployment can allow for commodification, but it doesn't necessarily imply that you must or ought offload something. running your own FaaS can potentially save a lot of money, depending on the user. also, if providers *do* pick up these opensource packages for their services, it just means you now have a migration path (should you need it) and can avoid vendor lock-in.