They've been refining a publicly available prototype for a year or so iirc, so I'd say it's a little further on than just discussion. But yes there is no specific JEP for it yet I think, it's just stuff you have to pick up from the mailing list mainly. They seem to be very careful about making minimal changes, i.e. dividing things up into the smallest possible incrementally deliverable units, and data types are just one part of a fairly sizeable plan wrt patterns etc. I suppose the switch preview is the first little step, and JEP 305 looks to be the next in line, in preparation for richer pattern support.
See https://developer.jboss.org/blogs/scott.stark/2017/04/14/critical-deficiencies-in-jigsawjsr-376-java-platform-module-system-ec-member-concerns : Jigsaw simply does not support split packages across modules.
After habing upgraded to IntelliJ, upgrade to Scala and Akka.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You move classes so they're in different packages. It's the only way. You could have: * `com.example.data.*` * `com.example.services.*` * `com.example.ui.*` And then you won't have a problem. It shouldn't be a massive refactoring if you don't use `Class.forName()` or similar, or class names hardcoded in config files.
I've never heard of anyone doing this. Is there something specific you are worried about? 
One thing is to use your frameworks to the fullest extent and not try to reinvent the wheel. Keep them up to date and to migrate to new features when possible if it means throwing away your code. The logic being that they would have had a lot more eyes looking at security issues and best practices. As an example, Spring 5.0 introduced a new `PasswordEncoder` framework which makes it very easy to migrate to new hashing methods. https://info.michael-simons.eu/2018/01/13/spring-security-5-new-password-storage-format/ Similar Spring Security has introduced and improved CSRF Protection over the years. If you use the Spring html form stuff, that protection happens automatically.
The website couldn't even keep newlines in the code samples; I wouldn't try and copy the text from the page and expect it to be exactly as written. If you were writing the examples yourself, you would use literal tab characters in the source code.
We are still on Java 8, and haven’t moved ahead because the module system breaks a lot for us. I’d be curious to hear what 10 and 11 broke for you. Those releases didn’t seem as disruptive. 
The recommendation is to start building your projects with early releases of future Java releases semi-regularly so you can be aware of changes ahead of time. For example, there's a `maven:3.6.0-jdk-12` Docker image you can use to test it quickly. Perhaps run the build weekly on your CI server? And having six month releases should mean fewer, smaller issues than there were with the big three year releases of yore.
Development and testing with Oracle JDK is fine. Production is not, regardless as to whether it's commercial or not. 
Sorry, Ian not sure to understand what you are suggesting. Are you saying that I move the classes in within the libraries? Eh: move the java.persistence package from eclipselink.jar to javax.persistence.jar? 
No, I'm talking about your classes. If Eclipselink have split packages, then you'll need to wait for them to fix their problem. 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Alright. Thanks. Regarding my jars, I did put everything in separate package.
It means I have to maintain my multiple projects more frequently instead of letting them be stable and not be changed for absolutely no reason. There's no other way about it, this is more inconvenient for me because they decided to break things they didn't have to. Backwards compatibility is an afterthought to them, and it's frustrating to see this happen to my favorite language.
There are some immediate benefits to not going to college. You'll have much more free time, more money to spend on things etc etc, especially if you have the benefit of living at home. If you're not in a great position, you'll end up working 8-10 hour days, sleeping for 8-10 hours and your free time will be limited, will that free time be used on your hobby? That's exactly what it is at this point in your life, it's a hobby. You know nothing about computers and unless you have a friend who is messing around with hardware in his garage, college will give you the opportunity learn the real magic. Computer Science generally explores the hardware and software end of computing but more importantly it allows you to become a problem solver. The high end stuff (Java, Python) are all fun and games but unless you truly know what is happening within the computer, you're wasting your time. Anyone who has created/developed popular, $$$ worthy software knows what is happening within the CPU. There is no problem with finding yourself, letting your brain fully develop and returning to school in a few years but most people don't get the opportunity to return. It truly is easier to do it now. "It's just a piece of paper" one may argue and while I do have that mindset sometimes myself, it represents much more. It represents this decision that you're facing right now. Do you find the discipline/focus and courage to bring your all to your education or do you make the decision to mess around? That's why the piece of paper matters, I want to hire people who have made that sacrifice. Not necessarily the kids who had it handed to them and had full scholarships etc. I want the kid who was in a tough spot, loss but yet found the perseverance to grow intellectually. I was once in your shoes, programming since age 12ish. Go to school or find a way in the near future to commit. It's not easy, it may be painful, it will require long nights, but in the end it will be worth your pursuit. 
We use the Sonar+OWASP plugins in Jenkins as part of the build pipeline to verify dependencies against CVEs and spot common bugs/security issues.
I would add to this that a senior is expected to show good example to other developers, to be able to help them and to be able to guide juniors to develop further. All in all, senior is supposed to take more responsibility than just those things he has been working on. 
Look at --patch-module. It will effectively move the package contents from one module to another so that the module system sees the entire package as served from the one module.
First, if you like to take part in the discussions and influence the decisions then, as Mark Reinhold says, [you have to show up](https://youtu.be/HpbchS5kmio?t=1029). The easiest thing is to follow the mailing lists and submit your input. Second, what have 10 and 11 broken that isn't fixed by changing the command line (including adding dependencies)? Has there been actual code that required changing? Java 9, the last major release was different. The changes there simply had to be made in order to guarantee the future maintenance sustainability of OpenJDK.
I agree with you about the free time, it gives me more to focus on my priorities. I intend on working a Monday - Friday from 8 - pm. The free time will be into coding and other activities. There's 168 hours in a week, if I'm working 40 hours a week, it leaves me with 128. If I'm sleeping 8 hrs on average a night, that leaves me with 72 hours. That leaves me loads of time for my hobbies. I do actually have a vast knowledge of computers. I've built computers, I've coded dog trackers, I've coded apps and I've already done two college courses on IT. So you could say I have some knowledge between me. I have a different perspective about college then you. Would you be telling this to the likes of Steve Jobs, Oprah Winfrey? I've talked to many people about them not going to College and their high up in companies, having people working for them. You could say this mightn't happen to me, it could also not happen to me if I have a college degree. We could both be sitting in a 9 - 5 job. I could be the guy beside you who's doing this job but has other ambitions e.g a business on the side, I could have crypto's at my dispense? or I could I be the college graduate just working this job because that's what he studied for. Who knows everyone path is different, but I don't see myself getting a piece of paper to say I pasted 'x' course. If I'm ambitious I could be learning the same thing as a college student, what's stopping me? &amp;#x200B;
&gt; because they decided to break things they didn't have to But we really had to. How to break as few things as possible has been discussed at length, and designed, for almost a full decade. &gt; Backwards compatibility is an afterthought to them Backwards compatibility is one of the most important core values of OpenJDK, now as it was before. If you're wondering why projects such as Valhalla take so long, that's because most of the work is about backward compatibility. But some things had to be made to ensure Java is not just compatible with the past, but also with the future. We're trying to reduce the disruption to a minimum, but if you have concrete suggestions you should weigh in on the mailing lists.
This looks like https://bugs.eclipse.org/bugs/show_bug.cgi?id=525457 which should be fixed in eclipselink 3.0.0. Split packages has been a source for many subtle and hard to debug bugs for years - not the least in OSGi deployments where split packages has been shunned for well over a decade (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=243265 for example) - so taking a step further and not allowing them at all in Java modules was a deliberate design choice. 
&gt; I have a full-time job, I shouldn't have to frequently update and change all of my projects that survived Java versions 6 to 8 just fine without any problems. For f* sake - we know you have full-time-job, you don't have to copy-paste it in each message.... As for your issue - just stick to JDK11/LTS and you will be just fine and you will be in the same boat that you are currently - with major release every 3 years (see the video). If they haven't introduced rapid-release cycle but decided to introduce major features every major release something would get broken and the rationale is they want more lean runtime with possibility to introduce new features. You mentioned JavaFX - does it really have to be bundled into main runtime? How many applications use it? Java is (currently) more server side and you can just include JavaFX jar with your project and problem is solved... 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Scan your app with ZAP [https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project](https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project) Lots of other great suggestions in this thread too. Try them all. There’s no magic bullet for security.
It looks like in your [submission](https://www.reddit.com/r/java/comments/9ygyvk/i_dont_get_where_i_am_going_wrong/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I would add to your list: https://www.edx.org/ high quality courses.
1. To migrate to JDK 11 you don't need to modularize your app. A simple solution is to leave everything on the classpath. This is a good first step even if you do want to modularize your app later. 2. Even when you modularize your app, there is no need to put *all* dependencies on the module path as automatic modules. You can leave just the problematic JARs on the classpath. 2. If you do want to move everything to the module path, getting around issues in libraries that have not yet adapted can be done with command line options. [This is a great list](https://blog.codefx.org/java/five-command-line-options-hack-java-module-system/) of options that can help you work around such issues. In particular, take a look at `--patch-module`.
The module system in Java 9 is complicated enough already. I'm glad, they didn't go down the road the author suggested with versions as a first class citizen. To me something like @ProviderType and @ConsumerType would have been totally overkill. But again as the author says “One Man’s Dream … Is Another Man’s Nightmare”.... &amp;#x200B;
Here's the procedure: - Try running things on the module path once - Report all issues to all the libraries - Revert to running things on the class path - Check back in a few years
Lol! Apparently this is what it will lead to. I did submit a bug report to eclipselink. But I fear the time I will have to migraye the hot apps!
You might want to check out [Mario's answer on Quora](https://qr.ae/TUhDSR) to a question similar to this. I can't tell you enough how this gave me the push I needed as fear and insecurity could be crippling. Good luck!
Fear of breaking existing code. (Imagine having a string of "{1}" in a logger, for example) That being said. Raw strings would be the perfect place to wedge this in. The window to do it is while these are still a preview feature.
There are more than enough notations that are currently just invalid code. Some languages use prefixes in front of double quotes like `s"string"` (rather ugly though) or multi-line template strings using triple quotes. 
Thanks for the help. I went the --patch-module route for now. Then I stumble upon jlink not allowing automatic modules. I will try step 2 later today, hopefully this will solve the issue. I can see how jpms is a good idea however I believe the path will be rough for the early adopters.
&gt; Then I stumble upon jlink not allowing automatic modules. Why is that a stumble? Just don't pass those modules to jlink, but do add their JDK module dependencies with `--add-modules`.
NIH = Not Invented Here &amp;#x200B; Many people have probably gone through this exercise at least once. Probably privately. I need a Foobar thingy. I understand what I need. I understand how to build it. It would be fun and challenging to built. An accomplishment. So I build the Foobar thingy that I need. Problem is, there are already three solutions to the Foobar problem already out on them intarweb tubes. One or more of them just \_might\_ be an exact solution to your problem. But that is less fun. (And in some environments: I can write this and there is nobody who will call me out on it being unnecessary.) Sometimes a private NIH project then becomes a public project. Giving us yet one more solution to an already solved problem. Does this configuration language bring something new to the table that is a substantial improvement over existing configuration languages? &amp;#x200B;
Wow, thank you!
I see a lot of people mentioning static code analysis, anyone have dynamic code analysis named into their ci/cd pipeline?
Ignite looks quite powerful.. is anybody using it for the other functions, besides basic caching? Machine Learning and distributed computing look interesting.
It's built on top of the community project AdoptOpenJDK ([https://adoptopenjdk.net/](https://adoptopenjdk.net/)) - AMZ add some patches and AWS-specific stuff. If you don't need Amazon-specific stuff, just use Adopt.
It's a shame the collection operations in `Collections` operate in-phase. Maybe we need a set of new collections utility methods in the JDK.
Why do people bother with blogs like that? It takes about as long to impotent as read.
My first instinct would have been the reverse iterate and simply add to a new list. The view is a very intersting example I wouldn't have thought of. It this a valid answer though? This would only work for `.get()` but not for an iterator or foreach or do they use get internally?
With very few exceptions, everything uses `get()` internally, which allows list implementations that do stuff on `get()` to work.
I have two complaints with this post. First, they carefully describe the difference between the runtime of inserting at the beginning of an ArrayList vs a LinkedList, but completely forget about the performance of `get(index)`, instead just assuming that it's always constant time. What if the input list is a LinkedList? Finally, the "View" solution is a valid solution, but it's cheating in the benchmark. The view is a lazy solution: you don't incur the runtime cost until you actually try to read from the list, so you need to take that into account in the benchmark. If the input is a LinkedList the view would still be incredibly fast to create, but it would be O(n\^2) to iterate over.
My first instinct would have been to implement a view and just iterate backwards internally. There is no reason to allocate memory/copy if it's immutable. 
Thanks for criticism. I also post it here to get some constructive remarks. Regarding the first remark I mentioned in the problem section that accessing a given index is made in a constant time. We can then assume it is not a LinkedList. Yet, do you think it should have been highlighted? Second point, I obviously agree. Maybe I should mention the word lazy to help understanding that is cannot really be compared to other solutions.
It looks like in your [submission](https://www.reddit.com/r/java/comments/9ykhtw/simple_java_program_help/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Everything is in the two first sentences of the post. I described that it was an interview question and that a large part of the candidates did not find the problems and solutions. This is why I wrote this post. If that's too long for you or if you knew this answer, you can simply avoid it ;)
You're right, however I think there are other variables one has to consider, such as how often reverse iteration will be necessary. If one intends to do so frequently (and over a large set), it would make more sense to make a copy, however if not, utilizing a view makes more sense. I think if anything, these type of blog posts help jog or show other approaches and in no way are a replacement for critical thinking in real world situations. 
Ah, I admit I missed that part. Perhaps I am nitpicking but I prefer sample code in blog posts to follow best practices as much as possible and so I would prefer the type signature of `reverse` not take a generic List if you only allow random access lists. There's the marker interface RandomAccess that you can add an instanceof check to make that clear. You could alternately change the type signature to take an ArrayList. It would also be nice to recommend the "standard library" solution as a postscript since one shouldn't, if following best practices, re-invent the wheel when there's a pre-built solution. ArrayList&lt;T&gt; copy = new ArrayList&lt;&gt;(copy); Collections.reverse(copy); return copy; If you look at the implementation of reverse, you'll see that it checks the RandomAccess market interface.
Yeah, I'm not saying that the View is worse in all cases - merely that the benchmark in the post was misleading. The View isn't 100,000x faster, it's just lazy.
This was a rather interesting read. Having spent a lot of time writing with heavily used collections (and written a few for specific use cases), I would have initially written with a view based design. The funny part about this question is that if someone were to have read the java docs and implementations of [immutable collections in guava](https://github.com/google/guava/wiki/ImmutableCollectionsExplained), one would find that[ImmutableList has a reverse list implementation that precisely relies on using a view](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L589) backed by the original (already immutable) list. &amp;#x200B; It's a good question to ask to see what techniques someone may be familiar with, but by no means would I consider the question to warrant passing over provided the interviewee having simply not been exposed to said techniques.
If preparing and interview question involves running benchmarks, you're doing it wrong. If you, as the interviewer, can't tell a good answer from a bad one just by looking, how can you possibly expect the candidate you're interviewing to come up with an ideal solution on the spot?
I don't agree that the view solution is cheating the benchmark. The question was about the performance of the reverse method. It's true that there is a small overhead when iterating over the reversed list (which is mentioned in the blog), but the time complexity of iterating over the concrete list type of the parameter is not relevant as i see it. It will be the same complexity to iterate over the returned list as it was too iterate over the original. And that is why I think the view solution is superior to the others in terms of performance. It leaves implementation decisions up to the caller and does not alter the complexity of the list. 
I don't get your point. The post contains benchmarks to illustrate the solutions. I don't expect the candidates to run benchmarks or anything, what do you mean... Moreover, I don't expect candidates to come up with an ideal solution. Yet, I'm trying to check if the candidates understand some core concepts like time &amp; space complexity, the main differences between ArrayList and LinkedList etc. I don't understand your point.
why is upgrading to intelliJ so important? I personally use it by myself, but I used to use eclipse for several years and it was also a very good IDE. I was never really a fan of netbeans tbh. Not sure why. 
&gt;Semantically that’s what it means to be a major release. This isn't the versioning semantics that Java uses.
This is better suited for r/learnjava. There are tons of resources online as well as books.
Alright thanks.
You could say it's more an issue of the framing of the article. It's interesting to compare different solutions using benchmarks, but whatever you learn that way is irrelevant in the context of an interview. If the candidate can justify their solution in terms of concepts like asymptotic complexity or memory locality, it doesn't matter how well their solution performs on a benchmark. A good candidate might mention that they'd like to run benchmarks on different solutions to see which one performs best in practice, but unless you allow the candidate to actually run benchmarks during the interview, you wouldn't want to judge the candidate's solution based on knowledge you got from running benchmarks.
Yeah, the article is fine for the most part. I just disagree with framing it in terms of an interview question.
I never judged a candidate on something I learned myself from a benchmark. That would be stupid. Your comment is irrelevant.
It's cheating the benchmark because it doesn't accurately measure the cost of the reversal. You could write a similar view which lazily does "BogoReverse" - it randomly shuffles the list until it finds one that is reversed, then uses that list. It's wildly inefficient but it will perform the same on this benchmark because it's lazy - doesn't do anything until you call `get()`.
Presumably they meant "in-place"
Testing your own tests. I liked that talk. The dude was likeable. Interesting topic, nice tool, simply explained, a bit of history, problems, alternatives, when to use, when not.. Something I missed was **the example**. All example mutants / equivalent mutants seemed like.. well. Nothing majorly interesting. Just something: yeah.. maybe or may not be fixed. Although it was maybe because it was a live demo and a quite well tested framework. Otherwise it's so on time it's a bit funny. Rereading pragmatic programmer "testing the tests!! It's important" and katsching, there's this video telling me; hey, try that. Now, it's good.
It means I didn't check what my phone was writing. Yes, I meant in-place. Sorry.
It was a joke. I think intellij is better, but each to their own.
Use Guava. Lists.reverse solves this problem perfectly (a lazy view, with exactly the same performance characteristics as the List it wraps), and there are many other invaluable Collection tools.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
 list.stream().forEach(e -&gt; reversedList.add(0, e)); The stream isn't necessary, you can just do `list.forEach(e -&gt; reversedList.add(0, e));`. Both `Iterable` and `Stream` have a `forEach` method. 
A view is always best for performance. Otherwise I'd do this: private static &lt;T&gt; List&lt;T&gt; reverse(List&lt;T&gt; immutable, T[] dest) { final int size = immutable.size(); if(dest.length != size) { throw new IllegalArgumentException("invalid dest length. expected=" + size + ", actual=" + dest.length); } int i = size - 1; for(T x : immutable) { dest[i--] = x; } return Arrays.asList(dest); }
I also dropped out of college. I learned Java mostly by spending many hours doing personal projects (a text-based RPG, a chatbot, an encryption program). Compiler errors about static vs non-static contexts broke my brain for days until I finally got it. Stackoverflow was less than a year old so I forget if I used it. If you know what questions to ask you can just use a search engine I consider IntelliJ IDEA to be one of the greatest pieces of software in history.
Javafx
If there was a Software Development major, then maybe. But my university only had Computer Science, which is basically an academic track at this point
Engineering is about making intelligent trade-offs. Cost-benefit. So why do you make out that universities have a monopoly on education and that a degree is worth any amount of money? I spent 0% of my coursework using an IDE in four years of computer science. Because differential, integral, vector calc (and beyond) were much, much more important to them.
Personnel is policy
 return Collections.reverse( new ArrayList&lt;&gt;(immutable) ); Too many lines... ;)
Best way to bake security into your dev process is to build it into your design. Your processes should have as few privileges and capabilities as possible. DJB has a good essay available at https://cr.yp.to/qmail/qmailsec-20071101.pdf talking about structuring systems to have minimal exposure. Think about authorization as the base model, and authentication that pops out from that. Do you need access to a CRUD repository if you're only reading from it? If you only need to read from it, you should only have a read view. If you are querying a particular user, you should be handed a query component that only lets you make queries as that user. You shouldn't be allowed to change your password unless you specifically requested the ability to change your password, and that ability should be granted only for five minutes, etc. 
Note that Nashorn was deprecated in Java 11: [https://openjdk.java.net/jeps/335](https://openjdk.java.net/jeps/335) &amp;#x200B; It's going to be removed in a future Java version.
Except `Collections.reverse` returns `void`
I know the question is about performance but I cannot ignore the fact that while input is immutable and output in examples is often totally mutable. And keeping immutability would leave us with the answer with custom view. 
And there will be no successor?
I see charts, but can it make graphs?
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Idk why you're getting downvoted. These people are like getting mad at you for something you're explicitly saying you don't do lol. Thanks for this article. I'm used to only seeing interview questions involving primitives, so it's cool to see some of the different ways of working with Java lists. 
Yeah, I don't really understand, anyway... Thanks for the comment ;)
Definitely look into stuff like FindBugs, Snyk, CVE scanners etc. in your build process / CI/CD pipeline. And also make sure you don't only scan on build but also periodically scan 'inactive' projects. Other than that; the best way to make sure you're doing a good job is having frequent penetration testers try to poke holes in the stuff you made. 
Don't migrate yet. We (the ecosystem) just aren't ready. I tried modularising jOOQ. It was impossible. IDEs are not ready. Maven wasn't ready (at the time). Some test dependencies weren't ready. Most optional dependencies weren't ready. The only thing that seemed really ready was the JDK itself.
In the FAQ ([https://aws.amazon.com/corretto/faqs/](https://aws.amazon.com/corretto/faqs/)) the question: **Q: How can I use Corretto outside of AWS?** mentions Amazon Linux 2 as the only supported Linux option. Amazon Linux (ideally on AWS) is what they're targeting, but the binary might well work on another flavour of Linux. It won't be supported though. I hear on the grapevine that Ubuntu support is planned for late Q1 2019. 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
May I ask where are you now, if you also dropped out of college?
Your given me some valid points. I don't want this to be a back and fourth about this topic. Put yourself in my shoes. I'm 20, I'm at a crossroads in my life, I'm stuck. I turned to Reddit for some guidance which I do really because a person can only give you 'advice' but will that be beneficial for in the long term? Did I make the right choice in dropping out? I don't know, I will have to see in the next 1/2 years where am I in life. Am I on the road to success which I originally planned to be or am I just stuck in a 9 - 5 job &amp; a miserable c\*\*\*. 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
For now they are, because they are positioning themselves to focus more on the language and VM. If you are using package management, most breaks are easily fixed with a new dependency or updating old ones. I suspect that things will break far less in future releases, 12 already looks minimally breaking.
I mean, if they really didn't care about backwards compatibility then serialization would be gone yesterday.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt;"piece of paper" represents much more than what "I passed x course". It represents your determination, sacrifice and desire to be in the field that you choose Should I tattoo "Java" on my face or carve it into my chest too? That would be an even bigger statement than merely torpedoing 4+ years of my youth. Some people actively enjoy homework. Not me. YouTube and Stackoverflow were just getting started 10 years ago but they're huge now. And they're free. Sure, you effectively shut yourself out from academia forever by learning skills on your own, but academia is a sad place
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
There is a subreddit for Eclipse. https://www.reddit.com/r/eclipse/
&gt;Some people actively enjoy homework. Not me. YouTube and Stackoverflow were just getting started 10 years ago but they're huge now. I almost stopped reading at this statement. What exactly do you think sharing knowledge on stackoverflow or youtube are? It's a form of homework. Work done in your home whether it's paid work by an employer, classwork or work done on your own terms. We'll since you're not interested in homework... there is no reason to discuss youtube or stackoverflow any further ;) Don't get me confused, I am not promoting "classroom only" as it's obvious that everyone should continue to push their knowledge. However, there are benefits having students learn multiple subjects in parallel and we should compare it parallel processing since we're in this subreddit. You won't understand mips if you don't know how to build your own cpu which requires knowledge of logic gates and binary. If you're dedicated you can skim past it quite easily but you're not doing anything useful. It's much more than "here follow these steps ok you did it great!" Same with calculus, 1 comes before 2 and 2 comes before 3. You don't want to create a human who knows calc 3 but speaks like a 4th grader. That's why you allow the brain to download in parallel. 
I'm not talking about homework in the abstract. I'm talking about the dogshit busywork assigned by humans with no financial incentive to see students succeed (if anything the opposite; too many As and Bs is brings suspicion). At least a hard-ass boss has stock options. &gt;You don't want to create a human who knows calc 3 but speaks like a 4th grader Ludicrous example. What the hell is wrong with six weeks of math then six weeks of English????? I want to know.
One difference between a senior and a junior is that a senior can be told a set of requirements, and then be expected to translate that into working code, while a junior needs to be told what to do. As a senior, I expect you to understand your part in a project, gather the information you need, set up your own meetings, basically get stuff done, but also understanding the role of architecture in a project. As a junior I only expect you to do as you are told, and not mess it up too much... The transition is kinda sliding, and comes with experience. Btw, writing good unit tests is hard, and doing TDD forces you to think about how you build your software. So learn to write tests... 
Huh? You must have some built up hatred inside because you like to spew random nonsense. I'm starting to believe you were a dropout yourself :D
When I was trying to learn inheritance I made a Pokédex with each individual Pokémon inheriting from its type like fire etc, which inherited from Pokémon etc. You could definitely use some interfaces in there as well like canFly() etc
Ooooh thats GOOD. Although, I am a heathen and dont play Pokemon. I do play Magic though. Thanks!
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
It's the responsibility of the developer to not abuse language features. For myself, I'm not a big fan of `var`, but I can see some useful use-cases. (First that comes to mind is declaring iterator variable in a for loop.)
These arguments were discredited years ago in the C# community. And decades ago in the languages that had local type inference before C#. *** Of particular annoyance to me is this ridiculous argument: &gt; `MyInterface&lt;Integer&gt; interface = API.getMyInterfaceImpl();` &gt; So that we always know what the type is. There is no confusion about what API.getMyInterfaceImpl() returns or what type of generic is used by the implementation. It’s all explicitly declared. Clearly we don't know what the type is. We know the object implements `MyInterface&lt;Integer&gt;`, but that's all. It's actual type, the information we really need when debugging problems, is already hidden behind layers of indirection. In many cases it is impossible to figure out what they real type except at runtime. 
I'm not a big fan of var. I would prefer to see the actual type than the word var. There is exactly one use that I see for var. Use var for an anonymous class with additional members. That customized anonymous class does have a type, although that type does not have a name. The var can still reference it by the unnamed internal name of the class. `var a = new Object() { int x; int y; };` `a.x = 5;` &amp;#x200B; &amp;#x200B; &amp;#x200B;
&gt;We know the object implements MyInterface&lt;Integer&gt;, but that's all Right, this is what I was talking about. API.getMyInterfaceImpl could just return the whole implementing object or it just could return the conforming interface parts. Why would it return the whole object? Who knows. But with explicit types we can guarantee that what we are working with is an implementation of MyInterface&lt;Integer&gt;.
If anything it'll force people to provide better names for their variables and methods. I'm currently working on an old codebase that seems to think terseness is a virtue when it comes to names. 
It always returns the "whole object". You can't return a reference to part of an object. That's not how it works. That's not how any of this works. 
By *"abusing"* I've meant to write code that is unreadable due to the use of the keyword var. When writing var x = obj.doStuff(); You might not be sure of the type of x, which makes the code slower to read. The developer can prevent this by explicitly writing out the type instead of using var.
The type is not really useful information to the reader of your code. As code is a lot harder to read than to write, we should strive to make code more readable. Hiding type information makes the code more expressive and less technical.
Yea, but that's not an "abuse" of var. 
Maybe `var` wouldn't be so difficult for you if all your examples didn't use shitty variable names like `x` and `interface`...
Ahhh, bikeshedding...
&gt; To remove the entity reference duplicates, we need to use the DISTINCT JPQL keyword I've always found that curious. I mean, when writing `LEFT JOIN FETCH`, I would have expected a nested collection semantics, such as when writing the child query in a `MULTISET()` operator in Oracle. What may be the reason JPQL hasn't been designed this way? &gt; When executing the JPQL query above, Hibernate will now generate the following output .. `SELECT DISTINCT ...` That's unfortunate. The fact that we're projecting both `id` columns should be sufficient for the ORM to prove that `DISTINCT` is not needed here in the SQL query (the deduplication will still happen in the client, of course). As shown thereafter, the PostgreSQL optimiser is also not smart enough to eliminate the unnecessary `DISTINCT` keyword (there's a sort operation). So we have quite some inefficient SQL in case the result set grows to be larger than a few rows.
Dammit it was just an example. You don't have to tear it apart. But here you go, here's a more refined one: var users = server.getUsers(); Now what is the type of users? A List? Maybe. A Collection? Maybe. A Set? Probably. A Map? That migh happen. A custom class? Possible. Or might it be just an int? **Don't know.** Of course this can be prevented by a good API design, but if you're using a library, that you cannot reliably modify, then this *can* become an issue. And here comes in the responsibility of the developer, to **not** use var in these cases, but write out the full type of the method call so the **next** developer who **reads** the code can understand it quickly. And of course you can name the variable *usersList* or something, but that is just a shitty way of writing out the type instead of *var*.
Ok, lets fix that. int x = obj.doStuff(); Now do we know what's going on? No. The variables are named `x` and `obj` tell me nothing about their purpose. How about we keep `var` and fix the names. var affectedRows = orderDAL.markSentOrdersAsComplete(); Now we know what the code is actually doing. Whether `affectedRows` is an int or long isn't really interesting at this point because I'm going to treat it the same either way.
True enough, much more sensible example :)
&gt;Basically, you don't have to declare a new type for a trivial anonymous class. AKA saving [a few lines](https://gist.github.com/BlueGoliath/3a4ae60c4fde749e5763d510323d09dd) of typing... (For JavaFX anyway) 
Of course, we can fix stuff. We can always write readable code even with *var*. But the problem is that it *can* be abused. And if it can, then it probably will. Or if it won't be abused, then this is one more thing that a developer needs to be aware of when using *var*. To make it readable for the future developer. And we all know what happens when you give more stuff to do to a developer. They get lazy. And they will choose the lazy way. (Of course, exceptions apply) *Var* has its use cases, I'm not saying that it doesn't. I'm saying that it shouldn't be overused.
Things you got wrong. 1. Exposing more information to the caller doesn't actually hurt the caller in any way. If they only want to use a subset of what the object exposes, they are free to without limitations. 2. If the caller does care, some simple reflection code reveals the real type and all its methods. No information is hidden at run time. 3. The point of returning an interface is that you are in a situation where in you need to return multiple possible implementations at runtime and those implementations do not share a common base class. It is not about information hiding; it is about the limitations of the type system. 4. You know who is directly providing the implementation because you are calling a method on it. 5. You don't necessarily know what the caller needs. You are just assuming that they can get by with just the subset exposed by the interface when in fact they may need more. See 2 above. 
Clearly example naming. Regardless, in order to properly convery the type in the variable you're going to have to give up saving those precious keystrokes. Either you explicitly declare the variable or you give it an explicit variable name, otherwise you end up with what might as well be just x or interface to someone who isn't you.
&gt; A List? Maybe. A Collection? Maybe. A Set? Probably. A Map? T Don't know, don't care. From the name I see that I can treat it like a collection, so I'm going to unless the compiler says a method I'm trying to use doesn't exist. We already do this anyways when we disguise the real type behind an interface such as `List` (or `IEnumerable` for you C# fans). Again, we've been doing this for years in C# and the problems you are concerned about don't really happen. 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I'm still looking for that example of "overuse". Because I literally use it everywhere it is possible and I still haven't seen a problem.
Pet management software. Have a little database for a pet store that sells different kinds of pets or animals. Gives you a nice little is-a hierarchy alongside some interfaces that describe common traits of all animals (like having a name in your pet store)
1. Yes it does. If the whole object of the returned interface changes. Suddenly a method that isn't part of the interface is gone and things break if you use it. If an object is solely an implementation and contains no other method then it's probably fine. Program to the interface, not to the object when given the choice. 2. reflection should always be avoided. No, there isn't anything stopping you from accessing API details you shouldn't have to but API details can change between versions so you cannot take advantage of such things(or shouldn't anyway. God knows people still do but it's their fault if things break.). 3. You're contradicting yourself. 4. It could be a static method that returns an implementation. You might have a hub class that returns various objects that implement an interface. 5. Then they either need to do a feature request, find something else, or get dirty with reflection and test each version for breakage. 6. It does because var will use the whole object if that is what is returned. See the list examples in the presentation. Granted, it's the APIs fault for returning the whole object and not just the interface but there may be reasons for that and you may want to guarantee that you only are using the interface. Now you're using var in some places and not others. Might as well just use explicit types and stay consistent. 
&gt; If the whole object of the returned implementation changes. Suddenly a method that isn't part of the interface is gone and things break if you use it. What if instead of changing the method to different a type you change its name but return the same type? Optimizing for the incredibly unlikely scenario that someone is going to make a very specific breaking change is stupid.
Funny that the way you named your blog post is actually what Brian Goetz almost quotes in his latest talk at [Devoxx](https://youtu.be/4r2Wg-TY7gU?t=752). His main argument is to provide information with a variable name instead, because it is the main source of information anyway. 
I can tell you're invested in type declarations and var bothers you. May I suggest you fix the problem at the IDE level. When I ctrl-shift-f in Eclipse, the formatter can give me tabs or spaces, because I can configure that. All you need is an IDE which will change var declarations to explicit type declarations and vice versa. Then everyone can decide for themselves. Like tabs and spaces. Tabs are the best BTW. People who use spaces are nuts. ;)
Great talk. Maybe some small improvements of Valhala are actually coming sooner than we think! 
&gt;What if instead of changing the method to different a type you change its &gt;name but return the same type? &gt; &gt;Optimizing for the incredibly unlikely scenario that someone is going to make &gt;very specific breaking change is stupid. The thing is, it's a seamless optimization. You don't need to do any real extra coding to do it and as a result, as an API developer, you can swap implementations depending on the requirements. Interfaces are more rigid and can be more safely relied upon(A "contract"). For a real life use case, I made [GoliathENVIOUS](https://github.com/BlueGoliath/GoliathENVIOUS) which is an API that allows for overclocking your Nvidia GPU in Linux using Java and JavaFX as a way to learn how to make a basic API. When you overclock your GPU on Pascal and newer cards, Nvidia provides a way to overclock by ALL performance levels(states, same thing) but not on older cards even though they run on the same driver. So, instead of creating two methods I can just swap the implementation depending on the family of GPU that is the primary GPU. Can, not do anyway. There isn't any benefit in GoliathENVIOUS's case as your GPU hits the most performant performance level anyway when gaming.
&gt;\&gt; Something I missed was **the example**. This tool is real easy to [get started](http://pitest.org/quickstart/) with — so if you have a project at hand that doesn't have a brilliant test coverage, just configure the tool, run it and explore the results! I found Pitest quite useful when developing (complex/business-critical) features to determine how good the tests are.
When using inheritance don't forget that you shouldn't break the Liskov Substitution Principle, in order to have more robust code.
Right, the article is a response to the presentation that Brian references. It's a horrible defense. If they really want to make such an argument then either you do: Person p = new Person(); OR var person = new Person(); explicit type or explicit variable name. Not that you can't have both of course.
Implement a board game. I did so for my junior software engineering project with Chess. Each piece type had its own class that determined where it could move, how it could attack, etc. The "Board" also had its own interface and behavior. In the end, it was very satisfying for it to all come together.
I wish blog authors would learn how to use apostrophes. They're smart enough to code, but can't do simple syntax?
Also, the API vendor can change the implementation details without changing the type's name. That's why we encapsulate private fields and methods.
One way or the other, this particular ship has sailed. People who want to influence features in OpenJDK should participate in the open discussions *prior* to the feature's inclusion. 
Yep! Time will tell! Have you tried out the [early access builds](https://jdk.java.net/valhalla/)?
The module system separates concerns. It is meant to provide the minimal amount of functionality and guarantees that would benefit most from being in the JVM, as well as to give the JVM the necessary amount of guarantees for its own benefit. Versioning could and should be handled by the build tool. A reasonable question to ask at this point is, if the build system is responsible for configuration, what do we need the module system for? Well, for one, in addition to reliable configuration, the module system provides strong encapsulation. But even on the configuration front, the VM benefits from modules because it makes class loading faster, and versioning would not have helped here. So, the build tool handles versioning, and the module system only does whatever checks must be done in the VM, best be done in the VM, or are useful for the VM. Would it be useful to add *more* checks to the module systems to enforce versioning? Perhaps, but only when we know the best way to do that, and only once the ecosystem has had time to digest the module system as it is.
It doesn't really matter. In the case of jPackager in JavaFX I've brought up all the breakage that happens as a result of its removal and the insane rate at which things are being deprecated and thrown out: projects in Netbeans that don't use jLink literally can't compile. Even templates that come with the IDE no longer work. Their response? *crickets* It's such a waste of time it's not even funny. Maybe If I was some uber important partner or OpenJDK distributor then I'd get more of a response...
It does matter, even if the decision doesn't go your way. For example, [see](http://mail.openjdk.java.net/pipermail/java-se-8-spec-observers/2012-August/000005.html) how public posts about the module system were noted. All good-faith feedback is taken very seriously and discussed at length (even if sometimes in private among OpenJDK developers). We monitor social media feedback, although well thought-out mailing list posts may be given more serious consideration.
&gt; is an `int` or `long` isn't really interesting at this point because I'm going to treat it the same either way You know you gonna treat it the same way because you know it's either `int` or `long`. Someone else might not know right away or he would treat it differently anyway. E.g. using `Math.toIntExact()` In this particular example you lost visual information but gained next to nothing (1 character in case of long).
It does matter, even if the decision doesn't go your way. For example, [see](http://mail.openjdk.java.net/pipermail/java-se-8-spec-observers/2012-August/000005.html) how public posts about the module system were noted (including Reddit discussions). All good-faith feedback is taken very seriously and discussed at length (even if in private among OpenJDK developers). OpenJDK project members often monitor social media feedback, although thoughtful mailing list posts may be given more serious consideration. Even if sometimes no response is given (it is hard to respond to every piece of feedback with such a large community) and even if the rationale for the decision is given at a high level rather than addressing each particular objection, feedback is still taken seriously. So don't stop giving it, preferably at the right time and in the right channels. &gt; Maybe If I was some uber important partner or OpenJDK distributor then I'd get more of a response... [The level of influence depends on the level participation; but at the very least, you have to show up](https://youtu.be/HpbchS5kmio?t=1029).
It doesn't force anything. Actually I'm already seeing variable names like `peopleList` or `providerBiFunction`.
Thanks for the suggestion, that's what I wanted to do anyways. But I guess I should understand how to test good, first. :/
It'll take us some time to learn best practices, and those definitely are far from ideal. But how many times have you seen names that forego vowels for no particular reason or are a single letter or have no bearing on their contents or context?
Calling a variable `p` is a crime against readability with or without `var`. So Person person = new Person(); or var person = new Person(); 
I’m bit confused at the few downvotes for this comment. I mean, it’s terse, but its still well-meaning advice. Remember folks, when you don’t know what something means, make sure to Google it and look it up! Fortunately the Liskov Substition Principle is very googleable, as are the other software principles of SOLID as well. Go down some Wikipedia/blog post rabbit holes and have fun!
No? Anonymous classes existed way before var. And you can use lambda expression for saving even more lines in your example.
Monopoly.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Single letter or foregone vowls are rather rare in the code base I'm working on. I'm mostly concerned about the rampant lack of consistency. Someone's using `mandantID`, someone `mandantNumber`, another `mandator`, then `idClient` or `clientID`, just `id` or `identifier`. Synonyms for the same... :( Anyway, I think people that are not getting the variable names well now, will not not do better when they use var. In those cases its a loss. Additionally the best practices and guidelines need to sink in, so situations and discussions can be avoided. See Optional, it took quite a while until everyone in the team got the message "Optional is a no go for parameters or fields".
But people did eventually get the `Optional` message. Mostly.
But you also need to know when to break the Liskov Substitution Principle. 
&gt; Now what is the type of users? if the person who made the ```Server``` class doesn't have brainworms, one of the collection types. An int doesn't make sense cause then the method name should be ```getUserCount``` or ```getNumUsers```. the arguments against var frequently come down to needing extra type information to make sense of badly named and written code elsewhere. 
i was about to start using javafx for gui but now idk if i can? This licence stuff is not clear at least for me 
You don't need a CS degree to write code.
Cheers for the insight man! At the moment I’m trying to get into a software company but it’s hard because where I am located right now, ‘interships’ aren’t really a thing! *Currently in Malta but from Ireland*. I plan on getting into a company and working on my skills. Maybe 2/3 years down the line move to the states, always wanted to move as I’ve family in San Diego. Might get lucky and get into an American based company here :). I’ll reply to this thread in months to come. 
Bull. The only reason I would call `Math.toIntExact(long)` is if I got a compiler error saying my value was a long. I'm not just going to write that code on a whim. 
My kingdom for raw string literals 😍
Was there in the room during this talk. Very interesting!
Usefull info.Thank a lot.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
har har var har.
That's why we created high level languages...
Neither did what you said.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
No. Unfortunately not yet. Still reading and learning module system. 
At this point I would be embarrassed to say I had a bachelor's degree
I disagree with this. Actually, I would say that we're both partially right. Your criticism is that the view solution is lazy, and that is true. But the implication of your statement is that if you actually use the list reversed-by-view then the true cost will be comparable to the other best solution. But that isn't the case, the reality is that the other solutions are doing a large amount of unnecessary work. The article does mention the fact that there is a small runtime cost to using the view, and simply calls it insignificant. I was curious as to how true that actually was, so I wrote a benchmark (using jmh) as follows: &amp;#x200B; `package list;` `import org.openjdk.jmh.annotations.Benchmark;` `import org.openjdk.jmh.annotations.Scope;` `import org.openjdk.jmh.annotations.State;` `import java.util.AbstractList;` `import java.util.ArrayList;` `import java.util.Arrays;` `import java.util.List;` `@State(value= Scope.Benchmark)` `public class MyBenchmark` `{` `private static final int LIST_LENGTH = 1000000;` `private List&lt;Integer&gt; testList = new ArrayList&lt;&gt;(LIST_LENGTH);` `public MyBenchmark()` `{` `for (int i = 0; i &lt; LIST_LENGTH; i++) {` `testList.add(i);` `}` `}` `private List&lt;Integer&gt; reverseByArrayCopy(List&lt;Integer&gt; theList)` `{` `final int size = theList.size();` `final Integer[] array = theList.toArray(new Integer[0]);` `for (int i = 0; i &lt; size / 2; i++) {` `int temp = array[i];` `array[i] = array[array.length - 1 - i];` `array[array.length - 1 - i] = temp;` `}` `return Arrays.asList(array);` `}` `private List&lt;Integer&gt; reverseByView(final List&lt;Integer&gt; theList)` `{` `return new AbstractList&lt;Integer&gt;()` `{` `public int size() {` `return theList.size();` `}` `public Integer get(int index) {` `return theList.get(theList.size() - index - 1);` `}` `};` `}` `@Benchmark` `public int testArrayCopy()` `{` `List&lt;Integer&gt; reversedList = reverseByArrayCopy(testList);` `int sum = 0;` `for (int i = 0; i &lt; reversedList.size(); i++)` `{` `sum += reversedList.get(i);` `}` `return sum;` `}` `@Benchmark` `public int testView()` `{` `List&lt;Integer&gt; reversedList = reverseByView(testList);` `int sum = 0;` `for (int i = 0; i &lt; reversedList.size(); i++)` `{` `sum += reversedList.get(i);` `}` `return sum;` `}` `@Benchmark` `public int testUnreversed()` `{` `List&lt;Integer&gt; unreversedList = testList;` `int sum = 0;` `for(int i = 0; i &lt; unreversedList.size(); i++)` `{` `sum += unreversedList.get(i);` `}` `return sum;` `}` `}` &amp;#x200B; I picked the array-copy reverse to test against since this was the best other option in the article, and the test involves reversing an ArrayList with a million Integers inside, and then iterating once over the reversed list and summing the integers. I also threw in an iteration over the unreversed list to get a baseline of how much time was being lost. The results were as follows: &amp;#x200B; Benchmark Throughput testArrayCopy 172.092 +- 1.363 ops/s testView 604.974 +- 37.351 ops/s testUnreversed 746.071 +- 5.697 ops/s &amp;#x200B; So there is a small cost to using the view, but it is still many times faster than using the next best implementation mentioned in the article. Obviously the performance improvement will become smaller the more times you iterate over the reversed list, and I imagine at some point the array-copy method will become preferable. I don't know how many times you'd have to iterate over the reversed list to reach that point though. &amp;#x200B; As for the 'BogoReverse', you're right. You could put unnecessary operations into the view implementation and change its performance. But that's irrelevant because I could equally put unnecessary operations into the array-copy method and claim that array-copying has worse performance than it actually has. The article was definitely a little lazy in not assessing the performance of a realistic use case (i.e actually using the list that was provided), but it wasn't wrong in claiming the view implementation had the best performance (at least in a common use-case of a single iteration over the reversed list). &amp;#x200B; Obviously using a view will not always be that much more performant than other methods. It just happens that in the case of reversing an immutable list the delayed cost is tiny and the other methods are doing unnecessary work. 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
If you are at an event with other Java developers and you don't know what to talk about just throw in a "What do you guys think is better Eclipse or IntelliJ?" and you will have stuff to discuss for hours...
I generally agree but would also like to add that sometimes it's not always that simple. You may generally be considered a senior but in your current task you would love to "get stuff done" but you don't have enough information about the domain to continue and the people that could give you that information are holding it back, maybe not even on purpose but just because they never have time for you. In this case you might quickly slide into the view of a "junior" and can feel kinda dumb because your project does not progress as you wish or as you are used to. I used to work in such an environment where the team (aka long year employees) was not very helpful with sharing their domain knowledge and I constantly needed to ask them questions about anything - But the main person that could answer the questions (also questions about the requirements) never had time. That was very annoying and I totally felt like a junior or just someone whose participation is not valued. 
Dull
AsciiDoc toolchain sounds amazing, def saving this 
There is this course for Java EE: [https://www.edx.org/course/fundamentals-java-ee-development-red-hat-jb083x](https://www.edx.org/course/fundamentals-java-ee-development-red-hat-jb083x) I would recommend you to learn spring instead if you don't really need Java EE.
Rubbish. Languages like C#, Scala and Kotlin already prove that this argument is nonsense. The major flaw with the implementation is that they haven't also included 'val' which would make it easier to default to immutability. 
[Prezto](https://github.com/sorin-ionescu/prezto) is also good, goes with zsh. Link: 
[API-Mock-Maker](https://github.com/authorjapps/api-mock-maker) seems a good tool to create mock APIs (REST/SOAP etc) locally, as well as in cloud. Just click-click and go - built on top of [WireMock](https://github.com/tomakehurst/wiremock) and [Zerocode](https://github.com/authorjapps/zerocode)
Vim and coffee
Just a thought! When this is an interview question, where exactly this can be practically applied?
I learned a lot by making a text-based RPG. I had various general superclasses like Potion, Weapon, Apparel, Unit and many more specific classes like Health Potion, Sword, Armor, Enemy.
I was quite worried when Jetbrains launched their new subscription model, but they keep on pumping out features. Best IDE by far!
Yeah, looks like variable declaration (not by accident, as in the video).
They do in place upgrades for patch versions. However, not for major versions. This seems normal.
They have "toolbox" app that can install/launch any of their IDEs. Downside is that it's another app running in tray. https://www.jetbrains.com/toolbox/
in an attempt to make this post vaguely related to java, is anyone using a toolchain that converts some sort of markdown to javadoc ? 
They've been adding features around the same rate as before and after the licensing change. 
And you post this in /r/Java because?
Toolbox makes following EAP much easier :)
Is anyone else getting an "invalid version" on the Kotlin plugin? 
lol. this is embarrassing (to put it mildly). 
they can make 100 toolbox apps, but they need to handle this in the ide itself. for crying out loud it's not rocket science. it's a solved problem. they do it for minor updates... 
Wow, seems like feedback is really important to them. Does reddit counts? ;-)
&gt; but they need to handle this in the ide itself You seem to be the only person here who has this much of an issue...the toolbox really makes this a non-issue 
I love [Sourcetrail](https://www.sourcetrail.com/), although so far I use it for C++, not Java. (also NetBeans)
well, yes, apparently im the only person on this planet to think that not handling that in the app itself like a normal application is a bit embarrassing for a company that prides itself with the developers it has and their skills. why is that? because all 5 of you that read my comment and bothered to answer are morons. quite simple answer really. it would be understandable if it was never done before, would be an unheard of request or such an outlandish thing that new decades of R&amp;D would have to be poured into it, but given the simplicity &amp; straightforwardness of such a thing for a desktop application ... it's not really forgiveable. 
? do you have any problems with my breathing?
No, we just think you're a jerk and an idiot
Thinking about MTG, you could easily think of a card requiring its implementation to specify a mana cost. That cost could be some abstract collection of mana quantities.
The toolbox app is really nice, and there's a lot of advantages to using it. If you don't like the toolbox app, just script the update process like I have. [Link](https://gist.github.com/Pear0/8a9caba496f1b70e1351a11c94e89fc2) 
Yeah. Go ahead and use visual studio and enjoy not being able to uninstall it without windows format.
im a jerk allright. and an idiot if you want, for not sucking up to jetbrains regardless of what they do and how they do it. you're just a moronic fanboi. if they'll tell you to jump off a bridge you'll most likely do it and thank them for the opportunity.
[Yes](http://mail.openjdk.java.net/pipermail/java-se-8-spec-observers/2012-August/000005.html) but very little. A thoughtful post (or, [better yet, many posts and active participation](https://youtu.be/HpbchS5kmio?t=1029), like trying out early access builds) to the mailing lists counts more.
Well that’s not much better. Qt is quite the bloat compared to GTK
I think that "abusing" should not just mean code that is difficult to read, but code that is outright MISLEADING to read -- possibly because the difficulty of reading obfuscates it.
As far as I know (and everybody else on this subreddit): **Clojure is not Java**. This is a **Java only** subreddit, not a **JVM languages** one. **Removed**
I could be more a fan of `let` than of `var`. But I would still prefer `final` with a real type name. I would happily use `let` instead of `var` for the one use case I described. But that is the only use case where I think I will ever make use of `var`, or a hypothetical `let`.
Anonymous classes and lambdas are useful. A concise way to do what otherwise requires a separate class declaration for, even an inner class. Do you also think inner classes are evil?
You mean language should adapt to the IDE?
Thank you for this. You are not the first person to recommend Spring to me. May I ask why Spring over Java EE?
The new Kubernetes/Go templating plugins are on point. Makes making Helm configs a breeze.
Holy shit, multiline TODO is game breaker for me! Updating tommorow
What NPM package?
Will there be a new bike shed every six months? /s
I would have preferred if they had skipped the variable declaration and just made obj implicitly have the tested type in the following block, so for exampe if (obj instanceof Foo) { obj.someFooMethod(); } 
Have you programmed in GTK and Qt? Qt is big (sure, bloated, whatever you wanna call it) but compared with the clusterfuck GTK programming is, really, how can you even say this? This proves you have absolutely no idea wtf you're talking about.
https://www.npmjs.com/package/retire
For me it works great
lol. go check yourself , there are screws missing in your head. GTK is on the same level as the EFL libraries. Only a crazy mind would design it, and an even crazier would use it. 
Yet they're still removing more and more with each and every version, Java 12 will likely be the first version to have Nashorn removed when it was only introduced in Java 8. 
&gt; Backwards compatibility is one of the most important core values of OpenJDK, now as ever I do find that hard to believe when each and every Java release is just removing more and more thigns. I finished upgrading two of my applications to Java 11 after a few hours just to find out that apparently Nashorn is likely going to be removed in Java 12. It's literally an endless battle.
There's still plenty of time to influence the design. Follow the JEPs and pay attention to jdk-dev mailing list.
Actually, yes. I just spent several hours upgrading two of my applications from Java 8 to Java 11. There were code changes required as well as having to literally remove certain code. One of my applications makes heavy use of Nashorn which means I'm going to have to re-write a ton of code after Java 12.
I wouldn't want it. Too often I'll upgrade and find it that some third party plugin isn't supported on the new version yet and I have to go back to the old version for a week or two.
Now if there would some way to allow the user to revert to the last version ... hmm.. dunno. Too complicated, yes. Too complicated.
This is a bit weird, yea, especially since they have it for minor versions. I tend to have a bunch of Intellij installations floating around my home folder after a while. As to why it's not automatic, I think that ties into the purchase scheme. You get perpetual licenses for major versions, so you keep the installation around. Also any migrations to config/indexes seem to happen between major versions. It probably saves them a modicum of effort as compared to a migrate in place. Those don't seem like good reasons though. It definitely makes me drag my feet on upgrades that don't have any features I need, because I'll have to download 600 MB, unzip it myself, update my quicklaunch bar and commandline launcher and etc, and wait a while for reindexing.
I used it a bit back when it was called GridGain. Back then it was mostly the distributed computing thing (basically map reduce, like Hadoop without the disturbed file system). Then it went closed source for a bit before before rearing it's head again as Ignite. However it was pretty crashy at the time. I was mostly running huge monte carlo simulations on it and sometimes I'd set it running over night and get back into the office the next day to find it had failed after an hour or two. Might be better now though, it's been a couple of years. 
what licensing change?
What you are asking here violates the **Reddit Terms of Service** that generally prohibit posting personal information. **Removed**
&gt; would have preferred if they had skipped the variable declaration and just made obj implicitly That's what kotlin does. Brian already touched upon that topic here - https://www.youtube.com/watch?v=4r2Wg-TY7gU&amp;feature=youtu.be&amp;t=1760 . This will work nicely with short circuiting. public boolean equals(Object o) { return (o instanceof ThisClass t) &amp;&amp; ( this.size == t.size) &amp;&amp; Objects.equals(this.name, t.name); }
Cool, this is useful.
I find it the best way to keep the app up to date on Linux
It looks like in your [submission](https://www.reddit.com/r/java/comments/9z88gp/dijkstras_algorithm_priority_queue/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
good grace... instead of "i heard" and spreading misinformation do some basic research. They deprecated it in java11 without any information when it will be removed, they suggest graalJS as replacement (sounds reasonable) and most likely they will remove nashorn when grallJS is fully ready...
I found out through the graalvm GitHub that Java isn't going to be coming with grallJS, it's going to be a module like JavaFX is. I'm really not a fan of Oracle removing and breaking compatibility with so many things. People said the breaking changes would stop after Java 11, it seems like it's getting worse. It may not be in 12, but if it's in 13, 14, or anything later it's still not ideal for me. I keep having to change my applications, soon it's going to be every 6 months I'm going to need to keep changing my applications. It gets frustrating after a while, especially when the everyones response is basically "lol suck it up too bad for you".
I use the Intellij snap on Ubuntu. I got the email today that the new version was released, closed Intellij, reopened Intellij, and I was on the new version. Took zero effort on my part. 
Game changer?
It looks like in your [submission](https://www.reddit.com/r/java/comments/9z90hn/need_help_with_my_project/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Plugin for what? IntelliJ or...?
It's a custom application.
https://github.com/pf4j/pf4jm problem solved
I was about to say: OSGi, which has been around for ages. But then you said you wanted no restarts. 
Worth every cent.
If there isn’t a new one, there are always plenty of old ones in need of repainting.
 Bunches of great stuff in there!!
You heard the man!
I had to manually go into preferences &gt; plugins and update Lombok. Worked like a charm after that. 
Indeed!
&gt;“Hello world” written in Spring Boot now produces a 15MB JAR file! Well, that's because the default configuration isn't meant to just print a single line of text to the console. It bundles an instance of tomcat and wants to listen to connections. With just a few lines of extra work, you can whittle it down to under a megabyte. This is still a perfectly valid spring boot implementation, autoconfigured and all: @SpringBootApplication public class SmallApplication implements CommandLineRunner { public static void main(String[] args) { new SpringApplicationBuilder(SmallApplication.class) .web(WebApplicationType.NONE).run(args).close(); } @Override public void run(String... args) { System.out.println("Hello small world"); } } And &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; I'm sure you can take more out to make it even smaller and still really a spring boot application that does nothing but print a line of text, but it's really a bit like complaining that your SUV doesn't fit in a bike shed and you can't lift it on your shoulders. 
I made one for the last company I worked for. I wish I had the source to reference, but it went something like this: 1. Create a set of interfaces that will be consumed by your primary application; Ideally these interfaces have zero dependencies. (Optional: package this up as a separate .jar to be consumed by both the plugins created and the consumer) 2. When you create the interfaces, they should be "callback-y": // ILoginPlugin is the interface your login plugins need to implement, IPlugin is just a marker interface for you to work with -- maybe add basic logging or something as default methods, w/e public interface ILoginPlugin extends IPlugin { boolean beforeLogin(String username, String password); boolean afterAuthentication(IUser authenticatedUserObject); String afterLogin(IUser authenticatedUserObject); } 3. In the above example, I've set up an interface that I'll use during my authentication process. First thing I'll do, before any local authentication, is optionally auth against something else. Maybe I want to always log someone in if they use the username "demo", maybe I want to check against a different authentication database, whatever. The boolean returned could mean whatever you want it to mean. In this example, I'll take it to mean, "go ahead and consider them authenticated instead of checking the local database". It could just as easily be "bail on authentication before checking" -- it's your choice how it works. 4. Write some consumers for your interfaces: public class LoginController { void doLogin(){ // PluginFactory is something you'll write to manage the objects, reloading, etc of the plugins you use. PluginFactory.get looks like this: &lt;T extends IPlugin&gt; get (Class&lt;T&gt; pluginClazz)... ILoginPlugin authPlugin = pluginFactory.get(ILoginPlugin.class); if(authPlugin.beforeLogin(username, password) || localAuthMethod(username, password)) User user = userService.load(username); if(!authPlugin.afterAuthentication(user)){ throw AuthFailedException("Or whatever..."); } doOtherPostLoginStuffLoadingContextsOrWhatever(); String placeToSendUser = authPlugin.afterLogin(user); postLoginRedirect(placeToSendUser == null ? 'loginPage.html' : placeToSendUser); } } } 5. This is the tricky part - you can do this by yourself with stock-standard Java or you can use libraries to help you. IIRC I ended up using Reflections for finding plugins inside of jar files and some library (I'll think of it...) to do the ClassLoader part. You basically create a classloader inside a singleton (Spring Service, w/e) which will you will load classes into. There's a million ways to do this and my way isn't the best - it's just "a way". In my example above this would be part of the PluginFactory. Make a static (or singleton non-static) method which will "Reload" your plugins. You can decide how you want to let your Plugins handle statefulness. I made the choice that plugins get blown away and reloaded when they're reloaded and they can be reloaded at any time. That was the rule. Plugin authors then write their plugins in such a way that they know they can be reloaded at any time (basically, don't store things in memory if you want persistence). Ok, back to this reload method. Have a spot on the filesystem you can scan for .jar files. Pick em up and scan them for IPlugin classes (remember that marker interface?). Instantiate those classes using reflection using the classloader that you decided to use (note: you can't actually refer to these classes by anything other than the interface you cast them to). Now that you have the object, your factory plops them into a Map/List to be consumed by your consumer. The way I did my plugins was a `List&lt;ILoginPlugin&gt;` which I then wrote a meta-plugin Class for every plugin interface to cycle through all plugins that were loaded (or return sane defaults if none were). 6. Extend this to everywhere in your application. Find all the "callback" points you want to interject external custom business logic to. HAVE FUN!
yeah, but then you're using a snap. 
We've been arguing about adding `let` to C# as well for the last couple of years. It's a minor change, but I would certainly use it where possible.
Really? You must be really terrified of the prospect of async/await. If Java implements it like C#, it will be built using the same code as lambdas.
I think `for` in other languages is pretty straight forward, but I agree that they are clumsy in C-based languages like Java.
It appears to have broken/changed javafx support. My previously working project is now refusing to run.
Jesus, there really is no pleasing you. Downloading the tool they use to update and install major updates automatically and access all your projects is too much for you, running a terminal command to update is too much for you.
Thanks for the great explanation. Your structure looks similar to PF4J, by any chance are you the creator of PF4J. 
My computer seems to be crashing often when I ran this latest iteration... anyone else having issues?
What’s wrong with you?
I'm used to them so I personally don't mind.
How does that help celebrate Thanksgiving?
Is it that support provided by a plugin? You may need to update manually or wait for a patch. 
I guess you’re just using the one product. It makes a lot of sense if you have multiple products. I would otherwise have to launch each to update.
Oh what, I need to check that out, is it crosscimpatible to pycharm?
Lombok plugin is my nightmare when new release of Intellij is available. The only plugin with problems at every update.
Here you go: [https://sourceforge.net/projects/platonos/files/](https://sourceforge.net/projects/platonos/files/) &amp;#x200B; This was written a long time ago, but still works fine today. Basically very similar to the old Eclipse engine before they went heavy with OSGi. Concept is super simple.. plugins can define extension points that they implement.. and extensions that they extend from other plugin extension points. Engine dynamically loads plugins as .PAR files (basically zip files with all the classes and dependent libraries for the plugin wrapped up in side). It resolves plugins at runtime as they are loaded, and can be unloaded or reloaded (hot swap) with ease. Very small library, but quite powerful. Originally built a Swing desktop framework that was all plugins. Never quite finished the framework as Swing started to go out of flavor, but it was quite nice for desktop apps back then. &amp;#x200B;
Wait, OSGi works without restarts just fine. You can deploy bundles and configurations and changes are picked up at runtime, no restart needed. Felix Fileinstall, Felix Webconsole, the Gogo Shell work that way, and I'm sure there are plenty more tools like that.
I totally agree. It was sold as a replacement for Class&lt;Map.Entry&lt;Integer, ArrayDeque&lt;HashMap&lt;String, String&gt;&gt;&gt;&gt; but predictably people are using it to replace everything from String to StringBuilder.
var is code golf
No, it's not. It's completely dependent on the context. Do you really name your `IOException` `ioException`? No, you don't
I can strongly recommend using a static site generator. I personally use JBake (because it's Java based). [My first ever post](https://niels.nu/blog/2015/baking-a-blog.html) was about setting it up.
It is impossible to "abuse" the variable naming feature. Any code will behave exactly the same regardless of the variable name. String inaholeinthegroundtherelivedahobbitNotanastydirtywetholefilledwiththeendsofwormsandanoozysmellnoryetadrybaresandyholewithnothinginittositdownonortoeatitwasahobbitholeandthatmeanscomfort = getSentence(); 
guy is hilarious. liked his joke about module hell
I'm cancelling my subscription too! Can't live with that!
&gt; That's how the JPA spec says entity queries should work That doesn't explain *why* the spec says something as silly as that :) It should say "the implementation is vendor specific". In fact, it should *never* specify the exact SQL produced by some JPQL syntax, only the semantics of that JPQL syntax. The SQL spec would also never be as crazy as to specify what kind of algorithm should be produced by any specific SQL syntax. &gt; I agree that applying this hint by default should be the default option for entity queries. The hint should *never* be necessary.
The built-in way is using META-INF/services/* / the [Java Service Provider Interface](https://www.baeldung.com/java-spi).
Kubernetes yes, but go is sold in a separate IDE (Goland) and is not available for PyCharm.
Not really, subscription system came with 3 major releases a year instead of only one major and a minor like before.
Thank you for that. I happen to be working on something where that library would be an ideal fit!
If it’s not about web development then it’ll make it. IntelliJ free edition is focused on java, android and Kotlin development.
If it’s not about web development then it’ll make it. IntelliJ free edition is focused on java, android and Kotlin development.
You can try the « File | Invalidate cache and restart » feature too.
https://www.jetbrains.com/idea/features/editions_comparison_matrix.html
Does it means that we need to mention all of the available implementation inside the META-INF directories. How about a scenario where the plugin is downloaded from market place or done by different team? 
No. The *plugin* JAR lists the services it implements in its META-INF/services/my.Interface and the main program uses the ServiceLoader to find all the plugins in the classpath.
This is interesting! 
You might want to check which Java version your project is using in the Project Structure. Just in case if these update changes it to Java 11 then you need external JavaFX library. Or just use Gradle do some config and the headache is now gone. 
What's the advantages of PF4J compared to built-in Service Provider Interface mentioned in another comment? 
I have a 1 year older license. Will I be able to upgrade to this version(free)?
It's terrible in Java because Java is imperative. It has checked exceptions and it's object-oriented. It's not supposed to function-oriented (or annotation-oriented). You know Java's gone off the rails when guys are now saying a for loop with an if statement in it is spaghetti code and is evil. Java likes to pretend it can be all things to all people. What is Scala for?
You're not wrong; its a bit bothering to me as well. But getting all these stuff for free (using PyCharm and IDEA Community), I don't think I'm in the ground for addressing minor complaint. As for the commercial edition, at least its not overpriced even by developing country standard (I live in Indonesia; somewhere in Asia). When I graduated and got myself a job, I surely would upgrade.
Because I do not think it's possible to unload a plugin via Service Provider easily. Perhaps you could do it via a custom isolated classloader ... but that's probably what pf4j already does.
Awesome. I know OSGi only because of Eclipse, which has to restart after installing ams throwing it off.
"Why Optional Is Little More Than A Fancy Wrapper".
Usefull stuff. I liked it. I hope https://blog.gceasy.io/2018/11/05/memory-efficient-eclipse-or-intellij/ it may help you.
I tried it before reinstalling, but it didn't help.
&gt;BTW: https://openjdk.java.net/jeps/343 Who knows when, if at all that's going to be released or if Netbeans will integrated into it or whether it will be a seamless/backwards compatible integration. I wouldn't think it'd be a priority for Netbeans given it only has basic support for Java 9 modules still. Or, when it gets deprecated. I'll give it two years before there is at least talk about it being deprecated in favor of something worse without a proper replacement. &gt;These formats include msi and exe on Windows, pkg and dmg on macOS, and deb and rpm on Linux. No native executable for Linux. 
jesus, i guess the main reason we invented machines is so that those machines do the work for us. 
I just want to thank everyone for their responses. I’ve been reading over them and I really appreciate the feedback. 
You know if it automatically updated major versions, a plug-in he had installed would break and he'd be losing his shit. 
My company only recently started requiring unit tests, so it’s something I have put to the back burner but have been meaning to get around to.
Thanks for responding! I think it’s tricky when the lines get blurred between where a developer/senior developers work stops and an architects work begins. I’ve been struggling with that lately as trying to balance working on closing out sprints versus doing architectural work. 
Thanks for responding! In a company that has software architects as well as engineers, where do you draw the line in terms of where an engineers work stops and an architects work begins?
The continuous subscription we've had for three years or so?
Thanks for responding. I think “gather the time you need” is something else I lack. When I’m given a project or user story, I think I need to finish it as fast as possible and don’t set aside research time or give myself time I need to do the project. The R&amp;D always happens, I just don’t communicate it as often as I need to. 
Shit! Someone used a multiline TODO in one of my dependencies. Scrap the entire project! This is unusable!
Salt much?
Thanks for responding! Why do you say lambdas and streaming APIs are overrated?
&gt; If you need to change your loop from ++ to +=5 you just have to rewrite the whole thing back to imperative style? Just multiply by 5? IntStream.rangeClosed(0, 20).map(x -&gt; x * 5).forEach(System.out::println); 
Seems like they're good for dealing with large datasets and online algorithms. Other than that they are a handicap. They're niche but proponents want everyone to use them everywhere. My comment history from the past two weeks or so has my detailed thoughts on it
Na, i+=5 will print 0, 5, 10, and 15 And {0-20} * 5 is 0, 5, 10, 15, 20, 25, 30, ... , 90, 95, 100
Okay, let's not pretend that Nashorn is as old as XP was. It was literally released in Java 8, we are barely on Java 11 now and they already deprecated it. It's fine, it's whatever, I literally spent all of yesterday rewriting my application to just use native Java. It is frustrating seeing all the features I am using even newer ones like Nashorn end up getting deprecated. Do you not see how that can be frustrating? 
https://docs.oracle.com/javase/10/docs/api/java/util/stream/IntStream.html#iterate(int,java.util.function.IntPredicate,java.util.function.IntUnaryOperator)
03?
I have never said it's not frustrating. I'm trying to see both sides and weight pros and cons. I'm aware that Nashorn was included in Java8 (which was released 4 years ago already! and before you had Rhino) and it's not removed yet! (it's being deprecated). So with java11LTS you still have 3 years of support (maybe longer, depending on when they actually remove it). IMHO, quite a few things shouldn't have made into core java and be released as libraries (ideally JVM should be modular from the start so you would be able to pick what you need). To get to that point of flexibility they had to break some stuff now. *IMVHO* and what I was trying to say from the start - while removing stuff can be huge PITA, I think benefits out-weights them. Why I commented and downvoted you? Because you were virtually repeating the same complain (copy-paste) over and over again…
`IntStream.iterate(0, i -&gt; i+5).takeWhile(i -&gt; i&lt;20).forEach(System.out::println);`
I started rewriting my parser with iterate and ran into two problems. First, `Variable used in lambda expression should be final or effectively final`. I got around this by making them single-element arrays. A major hack, but it technically works. Secondly, I have to parse recursively, so exiting the iteration early and returning an integer is absolutely necessary. I solved this by using a single-element array *and* explicitly setting `j` to `end` It's not pretty: package com.esaulpaugh.headlong.rlp.util; import com.esaulpaugh.headlong.util.Strings; import java.util.ArrayList; import java.util.List; import java.util.function.IntUnaryOperator; import java.util.stream.IntStream; import static com.esaulpaugh.headlong.util.Strings.HEX; /** * Decodes RLP object notation as defined by the {@link Notation} class. */ public class NotationParser { private static final int OBJECT_ARRAY = 0; private static final int STRING = 1; private static final int OBJECT_ARRAY_PREFIX_LEN = Notation.OBJECT_ARRAY_PREFIX.length(); private static final int OBJECT_ARRAY_SUFFIX_LEN = Notation.OBJECT_ARRAY_SUFFIX.length(); private static final int STRING_PREFIX_LEN = Notation.STRING_PREFIX.length(); private static final int STRING_SUFFIX_LEN = Notation.STRING_SUFFIX.length(); public static List&lt;Object&gt; parse(String notation) { List&lt;Object&gt; top = new ArrayList&lt;&gt;(); int[] pair = new int[2]; parse(notation, 0, notation.length(), top, pair); return top; } private static int parse(String notation, int i, final int end, List&lt;Object&gt; parent, int[] pair) { int[] nextArrayEnd = new int[1]; int[] nextObjectType = new int[1]; int[] nextObjectIndex = new int[1]; final int[] objectStart = new int[1]; int[] objectEnd = new int[1]; Integer[] returnVal = new Integer[1]; IntUnaryOperator iuo = operand -&gt; { if(nextObjectType[0] == -1 &amp;&amp; nextObjectIndex[0] == -1) { returnVal[0] = Integer.MAX_VALUE; return end; } if(nextArrayEnd[0] &lt; nextObjectIndex[0]) { returnVal[0] = nextArrayEnd[0] + OBJECT_ARRAY_SUFFIX_LEN; return end; } final int nextType = nextObjectType[0]; if(nextType == STRING) { objectStart[0] = nextObjectIndex[0] + STRING_PREFIX_LEN; objectEnd[0] = notation.indexOf(Notation.STRING_SUFFIX, objectStart[0]); parent.add(Strings.decode(notation.substring(objectStart[0], objectEnd[0]), HEX)); return objectEnd[0] + STRING_SUFFIX_LEN; } if(nextType == OBJECT_ARRAY) { objectStart[0] = nextObjectIndex[0] + OBJECT_ARRAY_PREFIX_LEN; List&lt;Object&gt; childList_ = new ArrayList&lt;&gt;(); try { return parse(notation, objectStart[0], end, childList_, pair); } finally { parent.add(childList_); } } return operand; }; IntStream.iterate(i, j -&gt; j &lt; end, iuo) .forEach( (j) -&gt; { nextArrayEnd[0] = notation.indexOf(Notation.OBJECT_ARRAY_SUFFIX, i); if(nextArrayEnd[0] == -1) { nextArrayEnd[0] = Integer.MAX_VALUE; } nextObjectStart(notation, j, pair); nextObjectType[0] = pair[0]; nextObjectIndex[0] = pair[1]; } ); Integer rv = returnVal[0]; if(rv != null) { return rv; } return end + OBJECT_ARRAY_SUFFIX_LEN; } private static void nextObjectStart(String notation, int i, int[] pair) { // Pair&lt;Integer, Integer&gt; int o = notation.indexOf(Notation.OBJECT_ARRAY_PREFIX, i); int s = notation.indexOf(Notation.STRING_PREFIX, i); if(s == -1) { if(o == -1) { pair[0] = -1; pair[1] = -1; return; } pair[0] = OBJECT_ARRAY; pair[1] = o; return; } if(o == -1) { pair[0] = STRING; pair[1] = s; return; } if(o &lt; s) { pair[0] = OBJECT_ARRAY; pair[1] = o; return; } pair[0] = STRING; pair[1] = s; // return new Pair&lt;&gt;(STRING, s); } } 
&gt; There were code changes required as well as having to literally remove certain code. Because of Java 9 or Java 10/11? If the latter, what code? &gt; One of my applications makes heavy use of Nashorn which means I'm going to have to re-write a ton of code after Java 12 now. AFAIK, Nashorn has not been scheduled for removal in 12. I assume that when it is removed, it will still be available as a separate artifact. 
Show me one parser written in a functional manner
That is a great question, and difficult to answer. I’ve seen some companies treat architects like tech leads, others like managers, and others with almost no purpose at all. Where I work, an architect is a master of the big picture for a technical project, and their main duty is creating (and continually tweaking) an architecture that satisfies both technical quality attributes (more on the engineering side) and product quality attributes. They spend a lot of time in meetings translating technical solutions to non-tech people. Soft-skills are an absolute must. All of them were ace-engineers at one point, but few of them write code beyond proof-of-concepts now. On the other hand, a senior engineer at my company is still writing (a lot) of code, but is also in close company with the architects and often will contribute to the architecture. Not a lot of their time is spent in meetings, and where an architect would be more concerned with patterns that satisfy a quality attribute, the engineer would be more concerned with the effective execution of said pattern. (Side note: a great architect will often involve the team in their decisions and readily adopt good ideas from even the most jr staff)
Lombok is working great for me, at least 16.6.22 or newer, even on JDK 11.
&gt;Or just use Gradle do some config and the headache is now gone. Replaced with a different type of headache when you try to figure out why Gradle is unable to grab dependencies from the Maven repository on your home PC when it works fine on your work PC, which then results in you ending up replacing automatic loading of dependencies with manually loading locally stored jars.
What about pages build in JavaScript(Anguler, React ...) ?
No, OSGi restarts don't work fine. Google OSGi LinkageError. 
What do you mean by infrastructure? The gogo shell and felix console are just jar files that you deploy to your app.
Too many letters compared to `var`. If we want people to use it by default it can't be longer than the one we want them to only use when `const`/`let` isn't applicable.
Have you googled "OSGi LinkageError"?
Exactly one of the reasons I hate it. 
Headless Chrome is the only sane way of doing this kind of thing nowadays.
Exactly ! I wrote an article about this too : https://ksah.in/introduction-to-chrome-headless/ You don’t have to use headless chrome for everything, if the Angular / React front end is calling simple REST endpoints, you can analyze it with chrome dev tools or Charles proxy and reproduce the http calls in your Java code. It will be faster than headless chrome, but sometimes it’s just easier to use headless chrome ! 
Wait, we're talking about reloading bundles, not about generic classloader issues. Classloader issues are very common in Java applications ... and arguably OSGi takes some of those problems away. In return, it asks for a little discipline in using classloader. In my experience most - if not all - classloading issues stem from libraries alredy doing funky stuff with class loaders.
I never quite understand Gradle when I were using IDEs like IntelliJ as the first stop before, but I took a step back with VSCode (+Java extension) and learn to configure things by hand. Gradle and VSCode is now my go-to for small projects. When the project grows, leave it to IntelliJ. For logging purpose, [this user guide](https://docs.gradle.org/current/userguide/logging.html) show that it is doable. I tried the `-S` parameter and it works. 
The standard is OSGi. You should get started rather fast for basic stuff but there's also a lot to learn about OSGi. Your application server might already support OSGi or something similar. Instead of implementing and integrating it yourself it might be simpler to just switch application servers.
 &gt; Task :test [test] running unit tests &gt; Task :build [build] build completed 3 actionable tasks: 3 executed I already saw all of this stuff in IntelliJ, it said the build had succeeded, but it still wasn't working. I noticed when I started manually loading the libs instead of loading automatically from the repository, that's when it started working. Now it works on my home PC and work PC, so that's good enough for me.
I use selenium I don't think I'll try anything else. 
I'm lost; I hate them all. Java 7 was mostly fine. Best thing since 7 is vectorizedMismatch and the like
Apparently there's an iterate API. But it's not very flexible. IntStream.iterate(0, (x) -&gt; x &lt; 20, operand -&gt; operand + 5) .forEach(System.out::println);
Honestly if you're working in an environment where LinkedList is used and passed around as a List then you have bigger problems. 1. Don't use linked lists 2. If you do use linked lists, don't use LinkedList 3. If you do use LinkedList, don't treat it or use it as a List
I did it for, JAVA\_HOME and JRE\_HOME. Now i added PATH one which was pointing wrong one but still i can't open it because i changed open with option and dont know how to choose right one.
Right click-&gt;open with-&gt;choose-&gt;jre-&gt;set as default-&gt;ok
Dude get a dedi or at least a vps not single purpose hosting. 
Look at the table below the price examples - they are quoting Java with 1GB of memory vs node with 0.125GB of memory - that's why it costs more. &amp;#x200B; If you're going to use serverless stuff (eg AWS Lambda) Java will also have the added cost of a longer start up time compared to Node or Go. Personally I'd forgot hosting and go down the serverless route. There's a cut off point where AWS lambdas become more expensive than a dedicated VM but you need a lot of calls to reach that point. &amp;#x200B; [https://aws.amazon.com/lambda/pricing/](https://aws.amazon.com/lambda/pricing/) &amp;#x200B;
IMO, bad interview question with poor analysis. 1. "Reversible" is a bad interface even for a contrived interview question. Why isn't it generic? Why is it named "Reversible" when it's actually the thing performing reversals? The naming conventions make this look like student code. A method for reversing lists does not warrant its own interface to begin with (should be a static method). 2. In practice the best answer is almost always to use standard library methods and get on with your day. If you're using Guava you can use Lists.reverse to create a reversed view. You can also create a reversed copy of the list by using the ArrayList copy constructor and calling `Collections.reverse`. In Kotlin the call would simply be `list.reversed()`. 3. The benchmarking and "performance" focus of the article is amateurish. The question is not an optimization question, performance and throughput requirements are not provided and no indication is given of how the method is going to be called or how the reversed list is going to be used. High-level time and space complexity are worth broad consideration but using microbenchmarks to judge answers is completely misguided. When I interview candidates I don't ask them infantilizing questions about reversing lists. If I did, I would expect them to use the tools available to them in the standard library.
İt is not working..you have to choose a file. İ tried both javaw and java file in bin folder but no
Can you download with it?
Thanks for the reply. How does OSGi compared to PF4J?
This is what forEach gets you: IntStream.iterate(i, j -&gt; j &lt; end, iuo) .forEach( (j) -&gt; { nextArrayEnd[0] = notation.indexOf(Notation.OBJECT_ARRAY_SUFFIX, i); if(nextArrayEnd[0] == -1) { nextArrayEnd[0] = Integer.MAX_VALUE; } nextObjectStart(notation, j, pair); nextObjectType[0] = pair[0]; nextObjectIndex[0] = pair[1]; } );
Good for you.
Continuing to scroll down: &gt; Java applications are among the largest applications typically running on PWS. The reasons for this are manyfold, but the primary one is that Java applications are deployed with the app server that is bundled during the buildpack deploy process. A typical java app is 1 GB. For the purposes of discussion, let’s look at the cost to run this app for 100 hours: ... &gt; Ruby on Rails (RoR) applications are commonly found and are not as heavyweight as Java applications. A typical RoR app utilizes about 512 MB (or 0.5 GB) to run. The cost to run this RoR application on PWS is: ... &gt; Node.js applications are prized for their speed and small memory footprint. A typical Node.js app utilizes about 128 MB (or 0.125 GB) to run. The cost to run this Node.js application on PWS is: ...
My understand is that this is part of the reason why they did the subscription model. With the single big release, they'd write code for awhile and get some features and then when they needed money, they'd release and have everyone upgrade. The big problem with the big upgrade model is that you can't plan cash flow. What if you release only a few features? What if some people decide not to upgrade? What is the budget for the next year? Going to a subscription means that the changes in funding tend to be minor and you can plan out a year in advance for salaries and the like. More certainty in the future allows for better resource allocation which in turn means an improved rate of being able to incorporate features - and not just features that people see.
Spring has way more market share, so it's better to find a job. * You have things like Spring Boot and Spring Initlizr that makes creating a new project really easy. * You don't need an application server like JBoss/Glassfish, instead you get a embedded tomcat or jetty making easier to deploy things. * It's way ahead Java EE in few aspects like Configuration, MVC, Integration with other tools, and for the stuff that Java EE is better you can use in Spring like JPA or JAX-RS. &amp;#x200B;
I have used selenium as well to automate some browsing tasks. I don't think it's much good if you need to do high volume of things.
OSGi is such a fucky way to do plugins I kind of hate it.
Wow after messing with OSGi and hating the hell out of it I might just use this. 
What jar file is it? You might need some older / newer Java version.
Also worth noting $21 per month for 1gb ram, 2gb storage and no mention of cpu is ridiculously expensive. You can get a 6gb ram, 25gb storage, 2.4ghz cpu for half that price. [https://www.ovh.co.uk/vps/vps-cloud-ram.xml](https://www.ovh.co.uk/vps/vps-cloud-ram.xml)
İt is for all jar files
The value of pivotal is in the tool chain. Being able to deploy with `cf push`... that's worth something. If I want to push an application into the cloud somewhere, and I'm not a sysadmin (and even if I am), I don't want to have to worry about securing the machine, setting up the firewall rules, etc... Being able to just push the code up there and not have to worry about setting up the machine, the clustering, the fail over, the load balancing... That could easily be worth $10/month. The pricing on gb of ram is also a bit awkward as that's for the entire machine rather than just the Java application. There's a fair bit of work in setting up the deployment chain and securing the machine when working on a raw vm.
I haven't used it for any big tasks, last thing I did with it I scraped my school grades. 
Is that a video on how to use an SDK? I am speechless.
All of eclipse's problems are due to not using proper OSGi standards. In their defence they created a lot to f their infrastructure before the proper standards were developed but unfortunately the result is that they've been left behind. They don't, for example, use the proper dependency resolution mechanisms or a repository format with enough metadata to implement the OSGi repository spec.
May be the are using older Java version(&lt;9) which is not very good on container environment regarding memory management.
Yes, I wanted to write "game changer" of course
Looks like a mug shot. 
Hah now I see it too.. :) That's just my living room, I keep mug shot for another video ;)
01:14:45: someone in the audience seems to ask this same question - why is the iterative style code written all on one line, while the lambas are broken out with 1 op/line. He says that he wrote it the way he sees code...but that's unfair because he's looking at average iterative code vs the best lambda code he can come up with. 01:17:50: he answers a question of "is there every a time you should write this all on one line" with only "If you hate everyone you work with. Otherwise don't ever write code like this. Because it's not going to help anybody." 01:18:38: "emphasize that your team should never put 2 dots on the same line". I feel kinda torn because on the one hand, it's like a 2 hour presentation, like the first time I see it I feel bad because I'm nitpicking. But when you see like 10 presentations and they all do these same little tricks it starts to be deliberate - they format iterative code badly, then format lambda code as well as possible, then claim this proves something about lambdas being better - when what they really proved is that better formatted code is easier to read. 
https://aws.amazon.com/blogs/aws/amazon-lightsail-update-more-instance-sizes-and-price-reductions/ I'd go with Lightsail, Linode, Vultr, DigitalOcean, etc. to start.
As a developer, it is absolutely essential that I write secure code. However, it has been a *long* time since I've been a sysadmin. If I wanted to write some code and host it somewhere... say a slack bot or alexa skill, I don't have the hubris to believe that I can properly secure a modern linux machine. In a larger environment were there are more people with more roles, the security of the infrastructure itself is something that another position does. That doesn't alleviate me from writing good code - just that I know that the machine is locked down sufficiently with intrusion detection on it and things like that. I'm being hand wavy there because I really don't know anymore. What I do know is that if I build it in a container and hand that container off to our infrastructure team, they've assured me that the code in the container will run the same as it does on my machine and that if I wrote bad code, a malicious actor won't be able to get out and control the host machine. This is a very different environment for "I want to put a toy application on the web" and "I want to put enterprise grade software somewhere." For that toy application, its something that I wrote in my free time and I'd be ok paying $20/month to host it. I wouldn't want to have it be on an improperly secured VM that becomes part of a bot net or having to pay a sysadmin much more than $20/month (that's only two pizzas (and no beer!) a month to my buddy) to make sure that that VM doesn't get broken into.
this seems hideous.
The new SDK supports fully non-blocking calls, which is nice for highly concurrent workloads. 
Exactly, it's a perfect fit for reactive Spring. 
salt? voicing my opinion about a lack of a must-have feature in 2018 of a desktop app doesn't mean "salt" nor "triggered" nor anything. if anything, the idiots defending jetbrains are salty: "look, if you install this, run the other thing and cycle across the county three times you get the same benefits. what's not to like". and that's idiotic. but hey, to each their own.
It's not the OSGi limitation. It's the limitation of the whole approach: reloading of classes cannot always work reliably. Simple example: you have a running infinite loop which holds a reference to some object in some plugin. Then you reload this plugin with a new version of the class (with an incompatible change). What happens to the old object? Java has no way to unload this object and replace it with a new version.
I wouldn't mind if they added it to the IDE. But it wouldn't save me any time or benefit me in anyway. Therefore, I don't care. The toolbox app really is neat and gives me a single place to install, uninstall and update all their products drom.
are you saying that you've never seen/used/sit in a chair that has a cup holder and a tv remote? no only that, you would say to somebody requesting such a thing that "they're wrong. it wouldn't benefit me in any way"? if yes to any of those questions: 1. That kind of chair is **extremely** comfortable, if a bit expensive 2. wtf is wrong with you? 
I just said I wouldn't mind it existing. But I wouldn't be advocating for it or in need of it. I just find it hilarious how your so upset over something so minor.
Thanks so much for the tip. I'll check it out.
Have you tried using Parser Combinators? 
What about SPA web applications?
Wow, that was one of the worst written pieces on the pitfalls of functional programming I've ever read. No real substance, a lot of claims, and poor examples. Unless this was supposed to be some very bad, dry, tongue-in-cheek "humor", this is just a terrible opinion. Like, what was even with that "spaghetti code" example? How was the original spaghetti? And how does it help to remove a few redundant parens? Formatting isn't what makes code spaghetti, high coupling between modules is what makes code spaghetti. Now, I'm a huge functional programming fan, but that doesn't mean I reach for it all the time in Java. Sometimes it's useful, sometimes it's not. I tend to like FunctionalInterfaces, they help with wrapping up custom methods that can throw exceptions. I tend to like streaming for iterating over deeply nested structures. I also tend to write fairly stateless code, rarely do instance variables change after an object has been instantiated. As an example, I recently had to write a lot of queries (~30-40) using hibernate over a fairly complex set of models. There was a lot of nesting, and in many places required some complicated traversal of the tree of objects to pull out the right info. In several of these queries, if I were to write them imperatively to build the list of results, there would be about 12 layers of for loops and ifs, but with streams using map, filter, and flatMap, it can be written much more cleanly, modified more easily, and with tools like Intellij, we don't have to guess the intermediate types because it's displayed inline automatically. For the simple queries a for loop or two would work just fine, but some of them really would have gotten out of hand written the more traditional way. Even the die hard antifunctional guy on my team had to agree after showing the two alternatives (which, you know, Intellij can switch between automatically anyway).
&gt;Like, what was even with that "spaghetti code" example? How was the original spaghetti? And how does it help to remove a few redundant parens? Formatting isn't what makes code spaghetti, high coupling between modules is what makes code spaghetti. Firstly, it's a generic phrase for messy code. Secondly, the formatting made non-messy code look messy because of the formatting and extra brackets that aren't required. Just like declaring an int inside a for loop body which is another thing I've seen functional programming in java advocates do a few times. From Google: &gt;Spaghetti code is a pejorative phrase for unstructured and difficult to maintain source code &gt;As an example, I recently had to write a lot of queries (~30-40) using hibernate over a fairly complex set of models. There was a lot of nesting, and in many places required some complicated traversal of the tree of objects to pull out the right info. In several of these queries, if I were to write them imperatively to build the list of results, there would be about 12 layers of for loops and ifs, but with streams using map, filter, and flatMap, it can be written much more cleanly, modified more easily, and with tools like Intellij, we don't have to guess the intermediate types because it's displayed inline automatically. For the simple queries a for loop or two would work just fine, but some of them really would have gotten out of hand written the more traditional way. Even the die hard antifunctional guy on my team had to agree after showing the two alternatives (which, you know, Intellij can switch between automatically anyway). I wouldn't mind seeing some example code showing how nested it supposedly is. 
&gt; Firstly, it's a generic phrase for messy code. Secondly, the formatting made non-messy code look messy because of the formatting and extra brackets that aren't required. Just like declaring an int inside a for loop body which is another thing I've seen functional programming in java advocates do a few times. First of all, if a couple of curly braces make your code hard to maintain, r/python is this way (I say this with 8 years of professional python experience). Also, it is my opinion that arguing about formatting is for chumps. Use a code formatting tool that is consistent. I recommend prettier with the java plugin. It'll save you a lot of headache, because you'll stop worrying about whether or not there are curly braces on a single line if, and spend much more of your time worrying about the code itself. Don't argue about tabs vs spaces, how many spaces, curly brace placement, spacing, etc. Just use a tool that has opinions for you, because it ain't worth my time, I have too much shit to get done at work. &gt; The "difficult to maintain" bit is most relevant. New requirement, you must log out the intermediate values of that variable. How many lines of code must you change? &gt; I wouldn't mind seeing some example code showing how nested it supposedly is. Here's an example with the names changed, although it's the third one I looked at, not necessarily the most complicated. To start with, the imperative code: Criteria criteria = session.createCriteria(Foo.class); criteria.createCriteria(...); // Lots of lines excluded here because I can't post proprietary code List&lt;Foo&gt; foos = criteria.list(); List&lt;String&gt; targetThingNames = new ArrayList&lt;&gt;(); for (Foo foo : foos) { for (List&lt;Bar&gt; bars : foo.getBars()) { for (Bar bar : bars) { for (List&lt;Baz&gt; bazs: bar.getBazs()) { for (Baz baz : bazs) { for (List&lt;Qux&gt; quxs : baz.getQuxs) { for (Qux qux : quxs) { for (List&lt;TargetThing&gt; targetThings : quxs.getTargetThings()) { for (TargetThing thing : targetThings) { // Order needs to be preserved, so can't just use a Set if (!targetThingNames.contains(thing.getName())) { targetThingNames.add(thing.getName()); } } } } } } } } } } return targetThingNames; And the streams based code: Criteria criteria = session.createCriteria(Foo.class); criteria.createCriteria(...); // Lots of lines excluded here because I can't post proprietary code List&lt;Foo&gt; foos = criteria.list(); return foos.stream() .flatMap(foo -&gt; foo.getBars().stream()) .flatMap(bar -&gt; bar.getBazs().stream()) .flatMap(baz -&gt; baz.getQuxs().stream()) .flatMap(qux -&gt; qux.getTargetThings().stream()) .map(TargetThing::getName) .distinct() .collect(Collectors.toList()); I'll remind you. This is actual, real world code that I have to work with. I don't have the ability to change the model, it's inherently a complex network of relationships. All I did was change out names. Here I'm working with Foo, Bar, Baz, Qux, and TargetThing classes, each of which contains a list of the next object. That's only 5 objects out of a much larger tree of objects. The criteria sets up what values to query, and is skipping over about 16 lines of setting up a moderately complex query. Now, I know which one I'd rather work with. But wait! What if I needed to log out some intermediate valeus? Well, I'd most likely need to log out individual values, not lists of values, so I can follow the example provided in the [Stream docs](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#peek-java.util.function.Consumer-) Criteria criteria = session.createCriteria(Foo.class); criteria.createCriteria(...); // Lots of lines excluded here because I can't post proprietary code List&lt;Foo&gt; foos = criteria.list(); return foos.stream() .peek(o -&gt; logger.debug(o.toString())) .flatMap(foo -&gt; foo.getBars().stream()) .peek(o -&gt; logger.debug(o.toString())) .flatMap(bar -&gt; bar.getBazs().stream()) .peek(o -&gt; logger.debug(o.toString())) .flatMap(baz -&gt; baz.getQuxs().stream()) .peek(o -&gt; logger.debug(o.toString())) .flatMap(qux -&gt; qux.getTargetThings().stream()) .peek(o -&gt; logger.debug(o.toString())) .map(TargetThing::getName) .distinct() .collect(Collectors.toList()); Now, are there disadvantages to using streams? Of course there are. There are cons to using any pattern in programming, doesn't mean you shouldn't use them. Streams in Java can be slower than loops, they can be harder to debug with a line debugger, in certain cases they can be harder to split up, and you can't really extend the Stream class, so no adding your own custom stream methods so you can more easily resuse code. But, I declared half as many variables with streams, the code is _much_ shorter, easier to add debugging to, easier to remove debugging from, and is very powerful.
Wow, that's a lot. Thank you for your answer. I know that I'm asking a lot but do you know of a very good resource that you can recommend for learning Spring? The best way I learn is when there are exercises so that I can make very small incremental tasks as I learn, like in the Helsinki MOOC for OOP with Java. Also, the best resource I have found so far is [Javabrains.io](http://javabrains.io) but I don't know if the spring tutorial there is out of date (2011) and if it's enough. I'm not asking you to watch his videos, that would be silly, just of the top of your head, if you have some experience with this. Thank you a lot for your time, this means a lot to me. Learning alone is hard. 
This is the reality of adding features to a language while making them backwards compatible. 
Honest question here. Why make a video instead of text? I might be alone in this, but except for entertainment I really hate video. It's much slower than reading and it doesn't really add anything that inline pictures couldn't solve.
Like a stereo salesman with his hand on the volume dial. *The expensive one sounds clearer, doesn't it?* Gee, I wonder why.
I prefer videos. Your question is basically "why prefer apple pie over pumpkin pie?". It's just preferences.
Yeah I guess you're right. What is with video you prefer?
I think it's incredibly obvious this article was written with a purpose; to tell the author that he is perfectly right in resisting the more functional approach many languages are taking. Every single argument in this post was just written with that in mind. I hope that the author, someday, will actually start approaching 'new' stuff with an open mind instead of actively trying to resist change. I'm not saying all change is good, I'm saying that you should not start with the assumption that it's bad. Starting with the assumption its bad is the best way to make sure you come to a conclusion you want to come to. That said; there are some issues I want to point out. First of all going for this: if(e % 2 == 2) result += e * 2; Most linters will warn you against it by default. This is considered a bad practice for a reason; doing this makes it very easy to add a line to an if statement body and make the mistake of missing that there's no braces. Ending up with something like this: if(e % 2 == 2) result += e * 2; result -= 1; It's easy to miss the mistake here. It's silly to be so concerned about the amount of lines of code; opening/closing braces is just a single line of code. Besides, the whole FP argument isn't about lines of code anyway. Seondly; a lot of your arguments are based on that the FP approach is slower. The method call overhead in most situations is extremely tiny; I did a benchmark with a typical work load (such as mapping objects and creating JSON) and you can't tell the difference even in synthetic benchmarks. So if you're in a situation, like when you're dealing with large arrays of primitives; by all means use a for-loop for performance. No one is saying it should be your only tool. And frankly, the statement that *Stop developing software if you actually think any of this is true. Please.* is just ridiculously aggressive. The moment you use language like that no one is going to be influenced by your post. You completely lost the readers. So now it's just a rant and rants are best written on paper and then burned. And frankly you should probably do the same with your post. You have no streams/lambda examples in your post so it's clear that you haven't even given it a shot. Which is a shame. Because the industry in general is moving to a mixed OO/FP approach that Java (and Kotlin, heck, even Rust to some extent) support really well. 
The feature set of serverless has expanded a lot recently. The limitations are often around how you choose to do something rather than what functionality you want to implement. Eg on the aws side you've got lambdas which are good for short lived (up to 5 minutes) processes so they work well for restful APIs, processing messages from queues, short lived scheduled jobs etc For longer running processes you can use Fargate so you can run containers that are longer running. For state you can use Dynamo DB or Aurora Serverless if you want a SQL database (though you're stuck with mysql at the moment)
May I ask what made you hate the hell out of it?
Different people choose different ways of consuming information. Actually the idea is to make videos that are on the edge of learning and entertainment. Short (much shorter than conference talks - that are difficult to watch online because of the length) and informal. I like grabbing pizza in the evening and watching programming videos on YouTube - I believe there are more people like me ;-) But I totally get it if that's not the way you like learn about new stuff.
This is where well-behaved programming comes into play. Running an infinite loop _without any means of interrupting it_ is something I view as risky, whether you're running OSGi or not. So you'd better have an exit condition. They way I see this happening in OSGi is: - Bundle A runs a thread T, uses object from bundle B - Thread T is part of an OSGi component or managed by A's bundle activator - Thread T has a Thread.sleep() condition or checks a 'stop' flag - Bundle B is redeployed - Once Bundle B is stopped, Bundle A is stopped as well - since the imported packages are no longer available - When Bundle A is started, Thread T is stopped as well - Bundle B starts - Bundle A starts, T is started again ------ My point is that OSGi offers a well-designed framework for applications that can be changed at runtime, _given that you follow some simple rules_. Yes, it cannot change the rules of Java. Yes, it cannot do anything if you stick a `for (;;) ; ` in your code. But do you really have to?
I am not familiar with PF4J, but I've used OSGi extensively. What I can say is that PF4J _looks_ like framework for defining extension points, wheres OSGi takes it much further: - definition of jars as (reloadable) modules - service layer ( similar to what Spring, Guice, etc do ) - loads of additional modules - event management - configuration - logging - web console - shell ... I would daresay that if you take a look at the OSGi specs, they cover pretty much all use cases ( [Core](https://osgi.org/specification/osgi.core/7.0.0/), [Compendium](https://osgi.org/specification/osgi.cmpn/7.0.0/introduction.html) ). The things that have turned people away from OSGi historically were: - various libraries not being OSGi-ready ( missing fields from manifest ) - lack of tooling These issues are pretty much gone today, and I'd encourage you to take a look at [OSGi enRoute tutorials](http://enroute.osgi.org/) when you have the time.
I think compatibility is not the only motivation, there is also an important performance trade-off. When we initialise an array, currently the whole chunk of memory is just zeroed. This is fast, and it's simple enough that the JVM can make a lot of convenient assumptions. So when we create an array of values, if we want it to remain fast, it still has to be zeroed. For some value types this is fine, e.g. for complex numbers this just means initialising everything to (0 + 0i), which makes perfect sense as a default value. Or for Optional, the default would just be an empty Optional, which is also sensible. For other value types however, a zeroed instance might not make any sense, it could just be junk data. For example it may be a value which must contain a non-null reference. So what do we do in this case? How do we initialise our array? There are two choices, either we invoke the default constructor on every element in the array, which could be very slow, or we surface the concept of "nullability" to the language so that we can have a sensible interpretation of what a zeroed instance of the value actually means. The latter is faster, and probably a reasonable choice regardless of backwards compatibility.
We'd only need to call the default constructor once and cache that value throughout the lifetime of the JVM. 
You're not alone.
If text is boring you often stop reading. The video will keep going to the end unless you stop it. For some people the fact that you see a person talking to you makes the information easier to absorb. 
Sure, if you restricted the constructor to not include side-effects. Obviously that's a bad idea most of the time, but it is still a possibility. Besides, most such constructors are just going to be basic assignments anyway so caching won't make any real difference, the expensive part is assigning all that memory.
What the heck? That's just bullshit. 
Absolutely. In addition amount of memory, file content, and file sizes are important since different algorithms perform differently given the parameters.
Maybe, maybe not. Like I said it wouldn't make much difference anyway, the assignment is still the expensive part.
Your `tmp` variable in `reverseByArrayCopy` is a lowercase int, so it's autoboxing. Can you turn it into an `Integer` and run it again?
Looks really nice so far. I do hope that your efforts and ADBA will be merged!
Different people are different type of learners. So some are textual learners, some learn better by audiovisual explanation.
Hi! What tools do you use to make the videos? I noticed some transitions and background music, it is stock or genereted? 
Unrelated to the topic, but if you're calling `distinct()` and returning a `Collection` it might be better to just collect using `toSet()`. Distinct is not the most efficient operation in streams. If you're specifically returning a `List` then only optimize it if it's a problem.
Thanks for the tip! In this case, we haven't really seen a huge issue with speed, most of the queries return within a few ms, and that's with the overhead of json conversion. We also had the requirement that order be preserved, and this is a particularly clean and easy way to ensure that. I built in some performance monitoring into this service so we can keep an eye on it, so far I think all endpoints return within about 15ms (most are ~5ms), which is fast enough for our purposes. If it becomes a problem I might figure out a reduce call that would be faster than distinct, then replace with that everywhere. Until it's a problem I won't worry about it, though. 
Hi! I use Screenflow for editing - it's really doing good job for any kind of transitions or elements popping up here and there, it does poor job when it comes to adjusting video colours (for example impossible to change colour temperature). But it's relatively cheap so I cannot complain :-) &amp;#x200B; I search for music either on YouTube or SoundCloud with terms like "no copyright music".
This: if(e % 2 == 2) result += e * 2; Is against any Java Code Convention: [Oracle](https://www.oracle.com/technetwork/java/javase/documentation/codeconventions-142311.html#449) and [Google](https://google.github.io/styleguide/javaguide.html#s4.1-braces) Whoever has written the article has no clue about standard compliant Java programming. 
I also have a bit of a fetish for parsers, I recently wanted to test some immutable binary trees and wrote a fairly simple lisp like language for making tree structures. It looked like this "(((1)&lt;-2-&gt;(3))&lt;-4-&gt;((5)&lt;-6-&gt;(7)))" this would be a tree like this 4 / \ 2 6 / \ / \ 1 3 5 7 I wrote it in Java and while I did have a little bit of mutable state it was effectively functional, it was more like an implicit extra return that was then the implicit argument for the next function so rather than have methods be private Pair&lt;Tree, String&gt; tree(String input) I had private Tree tree() { //using this.input this.input = rest; return resultingTree; } This worked because the grammar was LL(1) so there was no backtracking. I think this is a good balance for Java in terms of embracing functional programming. Make code effectively functional, to allow composition, concurrency, and all the other fun stuff FP provides, while still using some of the imperative tricks of the language where appropriate, but keeping them encapsulated.
It looks like in your [submission](https://www.reddit.com/r/java/comments/9zokhd/writing_j_unit_test/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I agree, different algorithm perform differently. Snappy can be used for faster compression with small compromise on compression size.
I know, right? Why create a new list instance? Everyone traverses reverse lists with this cool funky arrow syntax: for (int i = list.size() - 1; i --&gt; 0;) foo(list.get(i));
If you need the best speed, use native compression programs with standard input and output.
It's new I doubt anyone is running it in production but take a look at Notation and NotationParser at https://github.com/esaulpaugh/headlong/tree/master/src/main/java/com/esaulpaugh/headlong/rlp/util And if you're really adventurous, https://github.com/esaulpaugh/headlong/blob/master/src/main/java/com/esaulpaugh/headlong/abi/SignatureParser.java I've optimized them as much as I'm able
AdoptOpenJDK has both OpenJDK builds and builds of a JDK based on OpenJ9.
It's not just map and reduce. If it requires the memorization of every method in 2000-line java.util.stream.Collectors and God knows how many other files, it's esoteric. Everyone knows what for and + and * do. God knows what `sumWithCompensation` does
Well spotted. That seems like something the Jit could optimise since its obvious that variable is never used as a primitive. I've made the change and am currently running the test. It hasn't finished yet, but the intermediate reports its printing show that performance had taken a big hit. Its dropped down to 135-140 ops/s. When it's done I'll revert the change and see if it goes back to the previous value or whether my pc is just slow today. Its doing nothing else though so I don't think its that. I've also spotted a potential problem in the view based solution. Each time get() is called its calling getSize(). I doubt it can optimise that, so I've pulled it out as a final variable outside the list declaration. 
Well it looks like neither of the changes mentioned above made any difference. All three benchmarks were slow by a comparable amount, so it must be my machine running slower. New results were Array copy: 140 ops/s View: 569 ops/s Unreversed: 714 ops/s
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
" Ok you have 24 hours, move all of your app (including database) to Azure, Rackspace, on premises, HP Cloud, etc. I can do that. Can you? " No, so what? " Vendor independence and extreme flexibility are far more important than extreme scalability. " Just no. Making blanket statements about what's important as if they are some universal truth is ridiculous. Whether you want vendor independence and if you do, to what degree you need it is something that should be part of the input when you consider the architecture for a system. Different people will come to different conclusions based on their priorities and an analysis of the costs and benefits to them. &amp;#x200B;
Author here. graphviz-java can also use [J2V8](https://github.com/eclipsesource/J2V8) (google's V8 javascript engine packaged as jar), and I'm pretty sure nashorn is/will be available as separate jar, just not included in the JDK.
Quite interesting. Especially that for a `nullable value class`, `null` will just correspond to an instance with all the fields set to their default values (`0`, `null`, `false`). Although the fact that constructing such instance through a constructor will result in a `NullPointerException` might be surprising to many.
&gt; the possible range for `% 2` is only `0` and `1` and `-1`
People here seem to love IntelliJ. I'm new to programming, why is it so popular?
&gt;Streaming api is about reducing large datasets. 99% of software is not about that. Your examples in this thread have been consistently parsers. 99% of software isn't about that, either.
Look.. There's spring and java EE... those are the main contenders, if you want something else, you have to be more specific about your atual needs. Maybe java is the prefect fit for your project, maybe it's not.. depends on what you're doing. Overall for low-cost hosting, java is *not* the best option. 
- polymorphism. - how to ask good questions.
* Exceptions and the difference between checked and unchecked and why you'd want either. * Lambdas and streams. * The collections framework. The interfaces and the different concrete implementations and the properties they each have * Modern packages, like `java.nio.files` and `java.time` * The Java Style Guide. The Sun/Oracle guide is the original, but a little out of date now, as is Elements of Java Style. Google's is probably the modern successor. Deviate at your peril. * Build systems, in particular, Maven and Gradle. * Logging, in particular, SLF4J and Log4J2. * Unit testing with JUnit, and the assertion libraries like Assert4J, hamcrest and Truth * Dependency injection and IoC containers like Spring and Guice * What frameworks like Spring and Play * Database access with JDBC and then JPA in that order. And you absolutely, positively must read Effective Java 3rd edition by Joshua Bloch. At least once a year.
* Inheritance vs. composition (and when each should / should not be used). * The collections framework. * How to use stackexchange without being a dumbass. * Roll-your-own generics. * A framework (I suggest spring, but really anything will do.) * ORM (Hibernate or otherwise.) * Functional stuff is really neat, it will make your intentions clearer. &amp;#x200B;
&gt; You can't work with shared data structures carelessly as you can with coroutines. Could you give an example where you'd be able to carelessly work with shared data structures in coroutines? One would think that you would always have such structures behind a lock or they themselves would be thread-safe.
ISA. Don’t inherit unless it IS A duck. If it just looks like a duck, it ain’t a duck. 
Guess I'll just go fuck myself then
These are not concepts but specific technologies. I think you're describing one specific role at your company as a template for every developer. I'm convinced one can be a very experienced senior Java developer &amp; architect without knowing more about Spring, Play and Guice than that they exist. Someone might be an expert in JavaEE or Vert.x, RxJava &amp; Akka, and mainly use non-relational databases. I've seen people like Mark Reinhold use make rather than maven or gradle. java.nio.files is a niche thing, I've never used it in production. 
Everything in Effective Java by Josh Bloch Everything in Java Concurrency in Practice by Brian Goetz Everything in Design Patterns by the GofF Based on my experience, following are key skills to become an expert Java programmer: * Good knowledge of Java collection * Good knowledge of Java Networking API * Good knowledge of Java Concurrency * Good understanding of Object oriented design pattern * Unit testing * Performance tuning, profiling and JVM internals * Object oriented analysis and design skill * UML * Good Coding skill * Good knowledge of frameworks likes Spring and Hibernate * Java 8
articulating ideas and questions to both humans and google is essential and underrated. it feels like it should come naturally or just be common sense (to seek help rather than just go "i'm stuck?"), but some folks just don't have it. 
&gt; ORM (Hibernate or otherwise.) Lol...very strongly disagree.
Yeah, that is big. I think when I hit walls like that, I try to take a step back or up the 'chain' and restate my problem. Or ask myself 'why am I doing X, what is the end state of X', try to list alternate methods, then run those by google. I think people frequently try too large of a problem statement/question as well. Instead of 'how do I display a sql table in a website' they may need to break it down to 'how do I retrieve sql, how do I manipulate the data I received, how do I get this data to the DOM?', and potentially smaller subtasks within those tasks.
lol. that's just bullshit. 
Functional in Java, LOL
Collection Generics Inheritance 
I DON'T LIKE ASSERTS
Why? ORMs are becoming very common in the industry. And even if your projects or team does not use one, it doesn’t hurt to know.
Object Oriented Design and Design patterns. All the absolute basics that I can think of aren’t really Java specific, but can be applied to programming in general
**XY problem** The XY problem is a communication problem encountered in help desk and similar situations in which the real issue ("X") of the person asking for help is obscured, because instead of asking directly about issue X, they ask how to solve a secondary issue ("Y") which they believe will allow them to resolve issue X. However, resolving issue Y often does not resolve issue X, or is a poor way to resolve it, and the obscuring of the real issue and the introduction of the potentially strange secondary issue can lead to the person trying to help having unnecessary difficulties in communication and offering poor solutions. The XY problem is commonly encountered in technical support or customer service environments where the end user has attempted to solve the problem on their own, and misunderstands the real nature of the problem, believing that their real problem X has already been solved, except for some small detail Y in their solution. The inability of the support personnel to resolve their real problem or to understand the nature of their enquiry may cause the end user to become frustrated. The situation can make itself clear if the end user asks about some seemingly inane detail which is disconnected from any useful end goal. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
We already have a bot that copies text from Wikipedia. At least it identifies itself as a bot...
SOLID principles and Test driven development
You don't need everything in the list, but start at the top end and work your way down (although they're in no sense ordered by importance).
`Objects.requireNotNull() is your friend. Use it early and often. Couple it with one of the many null/not null annotations for warnings in your IDE/static checker.
Because lots of people think that ORM means not knowing SQL and/or suffer terrible performance because they haven't turned their set up. There's no problem with using an ORM. 
I know what it’s for, I just haven’t had a use for it in production. It can’t load a resource from a jar, and haven’t had a use case for directly accessing the underlying file system in a long time. 
Have you not needed to read from a file or delete a file?
Yes, that's exactly what it does. And that's why you want to use it. As I said, use it early, so that you detect nulls when you're given them rather than when you try to use them. You can discover problems closer to the source of the issue.
More than a collection of libraries, using a framework boxes parts of the architecture and development process. You gain in productivity and in training costs if the framework is well known. You lose in freedom and put your trust in the ability of the framework to scale to your needs.
Race conditions. What they are and how to avoid them. That's more of a general programming concept, but it's absolutely crucial for even a junior engineer.
Everything in Effective Java, then graduate to Java concurrency in practice. 
It's a vague term but generally a framework would be more than just a library. It might span multiple languages, provide a standard directory structure, and/or provide a suite of tools. It might help with deployment, monitoring, and automated testing. I think people start calling something a framework when it goes beyond a library and changes your development workflow. Sometimes it's just a collection of libraries. It's not a strictly defined concept, it's just something people use when library doesn't seem enough but platform is too much.
&gt; Java passes object references by value.
The most typical examples are web frameworks. Setting up a web server has lots of common parts. Routing, login, uploads... A web framework will work like so: We do the routing and security and body parsing for you. Please provide a thing with this particular interface and we will call with the parsed web request. A usual library is something you can call. In Framework Land, library calls you. 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
How to divide a problem into parts. Basically divide and conquer, but not limited to basic recurvice algorithms as it's usually teached. It starts with modularization of a large project and ends with something like mergesort. 
JNI? It's going to die soon, Graal is on its way.
Agreed. ORMs are overkill for tiny apps where rolling your own SQL -&gt; Pojos is trivial, especially with libs like Commons and Spring JDBC to take care of the most verbose parts. Meanwhile, large apps that bloat up over the years become a nightmare when dealing with all the tricks the ORM engine is doing under the cover. How many times does some junior / offshored dev add some bad code which ends up making n^2 calls instead of a single join, before half your time is trying to grok the convoluted mess you've created at the DB layer. This becomes even more relevant these days as companies move away from huge and expensive vertically scaling Oracle / MS monoliths and instead move to smaller, distributed data stores where ORMs don't even work well. The skills you need are not knowing exactly how to tweak Hibernate or JPA, but instead understanding how to set up read replicas, caches, distributed transactions, etc. The only successful use of ORMs I've ever seen in practice seem to be the exact demos which were created to showcase them - things the size of Pet Store or various Spring Data and Hibernate guides. 
static vs non-static contexts passing references by value access modifiers
What does graal have to do with replacing jni? Did you mean panama?
Streams API
&gt; I've seen people like Mark Reinhold use make rather than maven or gradle. That doesn't mean it's a good idea. Build systems is one of the few universal ecosystem things that *every* java developer should be aware of. 
In what way didn't it work then? I mean, Gradle seems to think it worked at the very least.
So the Eclipse way of fixing things has arrived with IntelliJ. I kid... sometimes I'm a bit dismayed by the many small bugs in IntelliJ and meanwhile I remember being frustrated with having to restart Eclipse because it would act up often, now at least it's just consistently broken and I don't need to restart it till the next EAP.
**Every** Java developer should have **excellent** knowledge of JNI and wireless networks?.. 
Or for checking parameters, if you're not using project Lombok or similar, there's `Validate.notNull(foo, "Foo cannot be null.")`
Yes to Concurrency &amp; synchronization and Class loaders. No to JNI and the network stuff. 
The term 'frameworks' comes from [house frameworks](https://www.shutterstock.com/search/house+framework). A framework is different from a library that you basically build your code within the framework. It helps you develop faster (because the skeleton is already there), but the downside is that you can't just rip out the framework: your code is tightly connected to it. So in Java terms frameworks are libraries where you can't simply swap it out for a different one during development. 
&gt; ORMs are becoming very common in the industry. In my experience 'the industry' is moving away from them. Queries are easily expressed in SQL and then all you need is a light weight object mapper. If you want type safe SQL you should go for something like JOOQ IMHO. 
Don't use assert unless you want to only do the check in dev. Assert statements only run when the `-ea` argument is passed at runtime, so should not be relied upon. Tbh most developers should just never use assert, every time I've wanted to use it I've been correctly talked out of it.
By "copy of value". It's a copy of the reference that is passed. So when you assign the ref , passed to a method, to another object,it doesn't change outside the method
+1. Reading *Head-First Design Patterns* and seeing its lessons applied in libraries like Guava really upped my game in Java.
* Access modifiers. Learn to utilize the package-private visibility or even protected. All classes being unnecessarily public is a code smell imo. * Writing testable code. Utilize dependency injection for easy mocking, avoid modifying state wherever possible, etc. * Knowing Streams, Optionals, Collections and when to use which implementations. * Build tools. Doesnt matter which really, Maven or Gradle are good for sure.
Use jsr223 and JavaScript/python/groovy, easy to load/reload on the fly. Even jexl would work, without jsr223. No need to mess with the classloader/classpath which really is a can of worms. I did this for a game, scripts are reloaded whenever they change on disk using a file listener. Keep state in the plug-in caller and not in the plug-in, it's much easier to reload plugins then. If you use a classloader think of isolation, unloading classes, caching / negative caching, plug-in reuse / pooling and synchronization issues. Also, if your plug-in jars contain resources, they might be cached differently - so if you unload all classes and replace the jar, the cache might still reference the old and now unavailable resources. 
How to ask good question is a really good advice! I had and probably still got issues with that.
Garbage collection and in general memory management stuff. This is critical knowledge for any serious development.
How object references work in Java. It is different for raw types and for Object types. You might get some seemingly strange behavior if you don't have a good grasp on this in Java.
After loops and conditions learn data structures (arrays, lists, dictionaries, etc). Every single comment jumped ahead to advanced shit that “you just have to know”. Keep it simple. 
At a high level, a library is code that your code calls, a framework is something that calls your code. Take something like a web framework - the framework handles receiving the request, and will pass this off to the relevant part of your code to get what it should send as the response.
Returning `Optional` forces the caller to handle the error case. You can't get the value without calling `.orElse()` or `.orElseGet()` or '.orElseThrow()`. (Do not look at the `.get()` behind the curtain; seriously, don't call `.get()`). More interesting, you can chain calls from `Optional`: String username = null; User user = userService.get(id); if (user != null) { user = user.getUsername(); } if (username == null) { username = "(Unknown user)"; } becomes: String username = userService.get(id) .map(User::getUsername) .orElse("(Unknown user)"; 
I would like to add design principles to this list, although a lot can be solved by leveraging polymorphism.
It's not needed; `java.lang.Objects.requireNonNull(T, String)` has been in the JDK since Java 7. There is also `.requireNonNullElse(T, T)` and `.requireNonNullElseGet(T, Supplier&lt;? extends T&gt;). `.requireNonNull()` also returns its parameter so you can use it inline in an assignment. void setName(String name) { this.name = requireNonNull(name); }
Looks like I'm jumping on this thread a little bit late but I actually have one that I would consider fundamental that almost every junior level engineer (college trained or not) just glides right over. Sit down and learn the power of enums. Every time I get dropped into a project containing some juniors with bright ideas (particularly Android based projects), they always miss out on the power of enums and they are not hard at all. I will say most beginner / academic level material glances by them as well but if explained effectively, it can all become clear on one page. Case and point, "Java Precisely" by Sestoft
But importantly, if you call a mutator on a mutable object, the change will be visible outside the method too. This can surprise people that aren't expecting it. This is one of the reasons why immutable objects are generally preferred; functions can't have surprising side-effects on their parameters if you can't modify them. Look at the `java.time` classes. All their mutators return a new objects.
Or, switch to a JVM language that strongly is against using nulls. I.e. Kotlin
Android suffered from premature optimisation, so they didn't use enums in the runtime library, so everything uses magical constants instead. 
You are right about side effects (including mutability). But that's another subject. My point was about a very popular confusion about references 
Is Google still maintaing Guice? I though they focus on Dagger2
As a database developer that came to Java late, ORM is good idea that doesn't work well in practice. ORMs obfuscate everything that data engineers actually care about and spend their time on such as query tuning and explain plan improvement. We spent much of 2016 unraveling our hibernate yarn ball and reimplementing it using NamedParameterJdbcTemplate. It's much more efficient, for one no more double or somtimes triple calls to satisfy a relationship, and all of the SQL is PART of the application (via individual resource files). This has made troubleshooting much easier as the SQL that is getting executed is no longer a guessing game. We also have full control over the Entity lifecycle, which is generally not well understood, so our code is MUCH safer (no more unexpected mutations either in our code or at the DB).
In the way that my project wouldn't compile because it had tons of packages that weren't found.
Right, but you only explained half the story.
Might be better to start from the bottom. At least for the recommended reading
Of course, and so are source control and an IDE (or at least an editor) I just think there isn’t a specific implication that is essential for every java dev to know. 
Who cares if there was only 1 book. It's a damn good book to read.
Yes, that's why I recommended it, but your original comment made no sense in context.
Yeah I've been getting that for a while on some of my projects, I'm too afraid to upgrade my Kotlin plugin and risk breaking my projects.
You haven’t used it because you are doing computer science, not engineering. Frameworks are an engineering tool. You don’t use a framework to solve a research problem, the problem a framework solves is when you solve similar problems in a similar way over and over. A useful framework encapsulates the boiler plate stuff that is the same project after project.
Yes, I've used [api.incidents.org/drunk](https://api.incidents.org/drunk) to query related data. By default it provides you coarse location data, date, type of incident (like "injury", "fight", etc...), and emergency services response time. Make sure to look at the API docs at [incidents.org/dev/help/api](https://incidents.org/help/api) . There is a webhook for accessing push notifications about currently occurring accidents.
Unreadable on mobile. Ads hijacked the article before I was two paragraphs in.
\&gt; Isn't laziness the entire point of IoC? Not really. The main motivation was just increased modularity and decoupling. In my experience, however, the biggest motivation behind IoC, and especially dependency injection, is testability. It makes it much easier to write unit tests, because you can replace dependencies (the injected objects), with stubs/mocks/fakes.
^ You summed up my experience with ORM"s as well. They seem appealling at first but work with them for a while and you realize they're an extra layer that gets in your way.
thanks, was nearly ready to read this post. no way I'm doing that now.
if you write some code that is poorly encapsulated and requires the user to pollute their entire codebase to utilize it, you call it a framework to make those bugs sound like a feature 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
There was recently a thread on /r/cscareerquestions/ where someone was saying "keep in mind that most of the people posting here are college students who don't have real world experience". There was a followup thread that was basically "I graduated from college, got a job, and find that I rarely post here any more because at the end of the day I want to go home and do non-tech stuff". It's saways been a problem with forums that a lot of people posting are basically just marketing whatever new buzzwords they're interested in. I'm not seeing a lot of goid advice here. 50% of the items are "things I've never used on the job at all".
Oh thank you so much for this! You have no idea how much you’ve helped me. 
Actually the links aren’t opening though I have tried on my laptop and my phone. 
I still attempted and was able to read about half before the ads... :/ First half was interesting though
&gt; In my experience, however, the biggest motivation behind IoC, and especially dependency injection, is testability. Please watch https://www.youtube.com/watch?v=NzknrbrV8BY - it will give you a different perspective on unit tests
Do one for hospital-acquired infections
Ah Spring, the new J2EE of the old
Know not everyone agrees with you but thanks for your help in this whole thread.
I would say integration testing is much more valuable.
It's 45 minutes long. What part of the video is relevant here? What part of what I said do you object to?
Gross.
Should still set the Automatic module name
An interesting idea, but thankfully not likely to happen due to the substantial amount of implementation complexity involved. The only concerning thing is that they seem to consider shipping value types without specialized generics – that will cause some pain later on.
I agree. There is a reason why pretty much all other languages didn't do this. Although the "nullable struct, but no nullable class" of C# (remember how this worked out?) seems eerily similar to one aspect of this proposal.
Or, you know, we could require that the user proves that an array element is written to before it is read. (Some JVMs do this already for optimization purposes.) The array init problem is hugely overblown and trying elaborate runtime things to address them is usually not worth the cost.
I read it on mobile with no problem. An ad popped up, I closed it and continued. 
Nice article. One thing I don't understand is the appeal of using annotations over XML. At my job, we've built a whole infrastructure of application components that can be interchanged. They all work in a pipeline structure, similar to chaining Unix commands. It's a great system - I can build an entire new application simply by creating a new XML configuration file. However, if I replaced the XML with annotations, I'd have to recompile everything. To me, having precompiled libraries that I link using Spring was the great thing about Spring; if I had to recompile every time, the advantages would be lost. I have used the @Autowired annotation occasionally when there will clearly only ever be one implementation of an interface. Now, obviously Spring annotations are popular, so there must be use cases I'm missing. To add, we aren't the typical web development shop; we do mainly desktop applications, and we don't use databases much.
Simplified: Libraries can be used by calling them to get the functionality the library offers. In frameworks the developer implements defined "entry hooks" that the framework expects. E.g implement interfaces, extends abstract classes, annotations, dependency injection,... The rest of the application is all managed by the framework. Developers only fills in the "omited" parts. In general you can distinguish it easily by looking where the main-loop lives or what it calls.
Theres an API for everything now 
&gt; Use it early and often. Define boundaries where data can be null - third party libraries, some DTOs and such, and never use nulls elsewhere. If you make exceptions 50% of your code will be handling nulls.
`Optional`, `requireNotNull()` and `@NotNull` have reduced my null handling to practically nothing.
That's true, unfortunately some people skip Optionals or use @NotNulls without requireNotNulls. That's probably the worst place to be because there's a false sense of safety.
The only wrinkle with using null annotations with null check methods is that at least IntelliJ will flag up the check as redundant. Obviously, it's not a big issue, but false warnings make it harder to find other issues. And you can only check the asserts for the annotations when running within IntelliJ, otherwise, they're ignored. There's no annotation processor you can use in your Maven/Gradle builds. I don't know why IntelliJ hasn't provided that option.
What you say re niches is totally true in many (most?) contexts. I can't recall ever using JNI to gain a performance advantage or access kernel libraries. I also don't use JNI often enough but what I have to refresh my knowledge each time. However, I have frequently encountered cases where libraries were available only in C or C++, n or they provided a Java wrapper API for only a very restricted set of functions. I've probably had a need for JNI about once every half-dozen years; and "need" is a strong word, but I've scored points for being able to step up and do a job no one else was able to do. Examples include accessing MS Excel and MS Word functionality only available via a C/C++ API initially, and the very popular FLEX License Manager, which only offers a Java wrapper API for the most basic licensing approach. JNI is required for more flexibility. Agreed re networking; the bulk of today's networking is handled by HTTP, or rather by even higher-level JavaScript constructs. However, despite the volume of applications, HTTP is horribly inefficient for basic operations (which doesn't matter for many applications with today's network performance), but there are many applications outside of "retail" user interfaces and relatively lightweight client-server interactions where HTTP's performance overhead, developer complexity, and testing effort are unacceptable. And, BTW, those jobs tend to pay better, too.
on a desktop with ublock and custom dns level blocking mechanism, it works ok. it was readable for me.
compilation is a non-issue in java. one doesnt build applications just by writing an xml file, you need to write some code to add you custom logic to your app. then, since you are building code anyway, why not use a programming language to do it, instead of XML which is not a programming language (can kinda do xslt transformations, but man, why do you hate yourself?). and since you have a programming language available and ready already (java), well, just use java. i havent used xml for spring configurations since 2008 or so. basically, since i could. now, i would still use XML where it makes sense, but not for glueing apps together. it simply doesn't make any sense.
There is also an ad right in the middle of the content. Too bad ad blockers can't get that shit.
&gt; I have used the @Autowired annotation occasionally when there will clearly only ever be one implementation of an interface. With Spring 4-something you don't even need the @Autowired annotation anymore in most places where you're doing Constructor injection (which you should), just FYI. Regarding XML versus annotations; I have done both and personally just strongly favour annotations. This way the wiring together of 'stuff' is just in the code. 
&gt;It does seem to be a much more efficient algorithm. In practice it usually isn't if you benchmark it. The access to the other array uses more memory throughput than just jumping forward in the searched array and you usually don't get that many substantial partial matches, anyway. 
Knuth dedicates an entire book to searching and sorting. It's a surprisingly complicated subject, with more options than you'd first think.
The article is missing example code that runs correctly. It just says "use this annotation, or a different method to create your proxy", but then in /restofthefuckingowl fashion doesn't demonstrate those approaches.
Well this is frustrating. Everyone is praising the comment, but it's been deleted so us johnny-come-latelies have no idea what they said.
My life
So deep
Hi, I think it will be useful https://jsonresume.org
myLife.toString()
NPE
I added a generated word cloud with terms / frameworks I worked with or am interested in, such as Spring, Docker, Kotlin, etc. Also invest (time and/or money) into making a really good one. Its primary goal is to get you a first interview after which your interviewing skills are more important. 
I'm using a simple and sober, yet quite detailed LibreOffice template [https://extensions.libreoffice.org/templates/curriculum-vitae-1](https://extensions.libreoffice.org/templates/curriculum-vitae-1) It has landed me at least an interview for all the jobs I've applied to since I started using it two years ago.
This has nothing to do with **Java** and therefore is completely off-topic here. At best, this fits in /r/cscareerquestions. Really, it doesn't matter in the slightest what you use as template for your resume as long as it is concise and readable. **Removed**
I use the same template, but in Google Docs. Very good for condensing information while keeping clarity.
I've been following the mailing list. Some GWT devs have been working with J2CL for a while now. They have mostly been waiting for the J2CL release to be made public before making GWT 3.0 available to work with.
&gt;Wiring everything with XML is still programming, except now you're using a language that wasn't designed to be a programming language. At least Java config has type safety included. Good point. &gt;And I can't see creating a new application being such a frequent occurrence for most people that rebuilding the project is a massive chore. In our office, which admittedly is a little niche, I do it literally every week. We have lots of different data "feeds" coming from different sources. Each is typically some sort of stream (TCP, file, etc) that must be decoded into a common format. Then it has to be logged and routed to another destination (i.e., another TCP stream), often after being encoded into a 3rd format. So I'm all the time throwing an app together that can do all of this, quite often using only XML. I already have TCP listener components, decoder and encoder components, and router and filter components, all of which I merely have to "wire together" with XML. It's a bit of a grey area whether you want to call this process "creating a new application" or "reconfigurating an existing application", but the key point here is that I rarely have to touch the compiler, unlike there's some new message format that I'm going to have to decode or something. 
It looks like in your [submission](https://www.reddit.com/r/java/comments/a097og/reverse_immutable_list_in_java_8/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Is OOP really considered beyond basics? I guess he did ask absolute basics...
I guess I should’ve used the title of the post: Three Developer Tools I'm Thankful For
In my projects I have one GUI call another GUI and then close itself. It may be annoying to have them open up and close all the time, so lately I have been thinking of ways to switch panes inside the GUI. So you know, many panes will make scene builder lag. I hear there is a way to allocate more resources/ram into the program to help with the lag. 
It was a link to https://www.incidents.org, something like api.incidents.org/drunk IIRC. But the link redirected to the homepage, and anyways, seems like a very dodgy site to me, and not a real source of statistical data at all.
ty for the reply. i was hoping for a way to switch panes inside the gui. since this will lag and they way to allocate resources is way to advance for me jet. i will switch to web application. ty anyway.
maybe using oop effectively, then?
Programming help should go in /r/javahelp. **Removed**
My answer probably caused them to have flashbacks about the similar questions they made on StackOverflow lol.
My instinct would be to check for first letter then last letter. If both match then as efficiently as possible eliminate the possibility of the middle containing the middle letter (or a prefix of the substring being searched for)
Hmm do you know any other sources the one I’ve found is super long and complicated to parse. 
i'm not sure i'm qualified. i'm just worried this will strip away a potentially good feature of value classes: non-nullability.
Wish more people understood this. Unit testing with mocks often just leads to enforcing a certain implementation, passing when things are actually broken and failing when things are actually working but not in the way the tests enforce. They're worse than useless- they're actively harmful.
It seems like you have to explicitly ask for nullability, but if you don't want to ask on the mailing list, you can wait for the next *Ask the Architects* session (they have them at most Java conferences) and ask then (they often take questions on Twitter). My point is that it is not hard to get "official" answers about planned features (it is true that there is some self-imposed selection via a "seriousness barrier", but it mostly ensures that the people who receive the answers are those who actually care enough to get them).
I believe What you are looking for I believe is the fx:include statement. It loads a fxml view from another fxml. https://docs.oracle.com/javafx/2/api/javafx/fxml/doc-files/introduction_to_fxml.html#include_elements Other approaches would be, - loading the fxml from java - defining a custom view using the fx:root 
[God forgive me for I have sinned.](https://gist.github.com/Caellian/a755d453e6376623f7ea355efa9a61f3) It's still in incubation, I'm currently making a program that uses it in order to find probable bugs. So far the testing GUI is quite responsive and takes very little time to load. It's obviously inspired by JavaFX but it uses YAML instead of xml. Also, widget level controllers are a thing. Still learning how to do stuff, but doing this first has thought me a lot about Eclipse RCP. 
&gt;Most linters will warn you against it by default. This is considered a bad practice for a reason; doing this makes it very easy to add a line to an if statement body and make the mistake of missing that there's no braces. You should tell whoever made the CompleteableFuture class that. They do one line if statements throughout the class. &gt;It's easy to miss the mistake here. No it really isn't. &gt;It's silly to be so concerned about the amount of lines of code; opening/closing braces is just a single line of code. Funny, functional programmers seem oddly obsessed with it. &gt;Besides, the whole FP argument isn't about lines of code anyway. What is it about then? It isn't code reusability, readability and/or performance... &gt;You have no streams/lambda examples in your post so it's clear that you haven't even given it a shot. You really don't need to, do you? You see other people do lengthy presentations and give stupid reasons as to why it's the better approach when in reality they aren't.
&gt; NIO will still do things faster, but fibers will be pretty close to as fast. Why would NIO be faster than the JVM switching over to a different executing thread/fiber in case of IO?
Oh well, I tried. I'm sure I'm not going to even slightly change your point of view. If your colleagues are happy with you in a team by all means go continue the way of working you're used to :) 
The best performance tip for JPA is don’t use JPA
why?
To me at least writing a performant SQL vs writing a performant JPA model is way easier. If you have simple CRUD ok JPA is less work but if you have CRUD + 10 or more projection queries I would say go with something else. Yeah you could do projection queries in JPA but the mapping code is not that hard to write and you can do many things while you map. 
Dont be confused about performance of queries. because its the first time need. if you think about data cache is implemented by persistence providers (JPA) in order to improve performance by reducing accesses to the database data. Just think about When millions of users pretend to access the same row of a table they usually went to open a connection to the database and then the data was retrieved from the table, in this sense the database became a bottleneck for many applications; that is why data caching is of primary importance for new Web applications; in this sense, the Java Persistence API offers many possibilities to increase performance by means of using many distributed cache frameworks. So if cache implemented then this query you are running wont take that much time on second request. (Though Off topic)On the other hand JPA relieves the programmer from manual handling of persistent data in CRUD operations, hence reducing the development time and maintenance cost, it is enough to provide the data base schema to generate automatically the most of the CRUD operations needed to develop the system.
They are trying to be edgy. There's a group who believe everyone should hand craft SQL for every single query, then hand craft the mapping code (or use bullshit object\[\]s with no type safety to pull back your data). This has become a popular response to every post on any ORM. Of courese there's an element of truth to it (as with most things, it can be nuanced), and there are certainly benefits to using hand tuned SQL at times (that doesn't actually preclued the use of an ORM of course), however just like any tool, when used properly, ORMs are just as good as hand crafted queries (I'd trust an ORM to generate better SQL than most of my co-workers in most cases). &amp;#x200B;
First of all, I agree, but: &gt; Streaming is usually slower in Java, because lots of reasons. I dislike statements like these even though you mentioned the solution I normally go for: &gt; I would ask for performance benchmarks. Compared to 'just' iterating over an array there is a pretty big overhead when 'streaming' over a collection. But in relation to all the other stuff you do in most cases it's not noticeable. Method invocations are very very *very* fast. Generally the difference isn't even measurable if you're doing stuff like JSON parsing from and to memory, let alone in real life scenario's where you're pulling stuff over a network and send it out over a network again. It's like worrying about taking a helicopter or a car for a 8 mile drive when your goal is to fly to mars on a rocket. 
It's been 6 years since I used an ORM so things might have changed now. But at least the last time I used it, I can't think of any situation where I'd recommend ORM over just writing the sql. It's one of those ideas that looks extremely attractive on paper but is horrible in practice. 
You are working in an OO language. Your data is relational. You map them together. Everything is ORM. 
Of course ORMs are fine if you want to cripple yourself and your database by not using elementary features such as SERIAL. 🤔
&gt; The only reason developers choose an in-memory database for running integration tests is the associated speed of avoiding disk access. That's not the only reasons for using an in-memory database. The main reason I use hsqldb during tests is because it reduces the complexity of setting up and configuring a clean database for testing purposes. Yes, there could be behavioural differences between hsqldb and the live database engine, but that's why you have a test environment and the ability to switch to using a real database server if there's an issue. 
If you're just looking for code to copy &amp; paste here it is: [https://github.com/spring-academy/spring-boot2-junit5-sample/](https://github.com/spring-academy/spring-boot2-junit5-sample/)
If you're just looking for code to copy &amp; paste here it is: [https://github.com/spring-academy/spring-boot2-junit5-sample/](https://github.com/spring-academy/spring-boot2-junit5-sample/)
I'm guessing you just read the headings and didn't read why they suggest not using the `SERIAL` type? 
If you have any concern about JPA or Hibernate performance, you can raise the problem on the [Hibernate forum](https://discourse.hibernate.org/), and I'll make sure I will give you an answer to address your concerns with a proper solution. After all, Hibernate is very customizable, and it can be adjusted to the vast majority of OLTP application requirements.
There's so much truth in this. If you don't use an ORM framework, you are going to either write your own ORM library or use a different data access framework, which is not advertised as ORM, but practically solves the JDBC `ResultSet` to Java Object trees/graphs transformation problem. 
Honestly this ORM bashing in every post which is remotely talking about orm/hibernate is getting annoying. Personally i prefer readability, type safety / strong typing, IDE support, debugability, security (sql injection anyone?) over any hand crafted sql. In software development there are much bigger issues than performance. Writing plain sql in in any OOP application for me is code smell. &amp;#x200B; I guess it is much easier (and cheaper) to deploy a postreSQL cluster with WAL than to handcraft every sql query.
This but unironically
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt; when used properly, ORMs are just as good as hand crafted queries (I'd trust an ORM to generate better SQL than most of my co-workers in most cases). You obviously have no idea what you're talking about. An ORM doesn't magically generate efficient queries. You need to have at least some basic understanding of SQL and RDBMS to use an ORM in a way that will generate efficient queries. If your co-workers can't even write proper plain sql queries then there's no way their ORM equivalent is going to be any better. In fact, there's a good chance it might be immensely worse.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Thank god our college opted to teach us Java. 
It looks like in your [submission](https://www.reddit.com/r/java/comments/a0irzj/learn_java_from_best_java_training_institute_in/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
If you're just looking for code to copy &amp; paste here it is: [https://github.com/spring-academy/spring-boot2-junit5-sample/](https://github.com/spring-academy/spring-boot2-junit5-sample/)
It seems like if your application consists of nothing more than configuration of existing components it wouldn't be all that time consuming to "recompile everything" since the java equivalent is a single @Configuration class. We use a lot of Spring Integration at my place of work and I find the DSL for configuring integration flows to be so much nicer to work with than the XML equivalent.
&gt; Otherwise, would you have an `EntityManager.createNativeQuery` if not to use it? Yes, as a fallback if the intended use fails/falls short.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
It doesn't have context switching or scheduling costs and it can handle multiple simultaneous requests/responses.
Please, **spam** somewhere else.
so can you for sql with QueryDSL or jOOQ. So I don't really think it's a + of JPA over SQL. does anybody really use the criteria api? 
Criteria API is useful if you need an entity query that varies based on user input (e.g. the user can select the filtering criteria). So, instead of using String concatenation for JPQL and risking SQL injection attacks, it's much better to use Criteria API. However, if you need dynamic native SQL queries, you should use a framework like jOOQ.
Machine learning is basically Python.
When I really get stuck I hope to have the time to apply the old fashioned "walk away and come back" principle. Even an hour away from the problem sometimes can give me a fresh perspective coming back to it.
A server-side web framework that provides type-safe DSLs for HTML, CSS and elegant Java DOM API, for pure Java Web development.
are you afraid you would understand the code? you can sigh all you want, debugging "hand crafted performance" sql code inside a java method is not fun.
Money / currency, they had a JEP for it, but the proposal was awful and impractical, see https://github.com/JavaMoney/jsr354-api/issues/64
Yes, I agree. That's why I said you need to have at least some understanding of SQL / RDBMS when you're using an ORM.
&gt;If you don't use an ORM framework, you are going to either write your own ORM library or use a different data access framework While I very much agree with this, it does open up the question whether SQL is the right tool for the job anyway. After all the definition of ORM is: &gt;... a programming technique for converting data between incompatible type systems using object-oriented programming languages. I just mean to say that if we are using ORM frameworks to work with SQL then that could be a signal that we are actually not using the right mix of technologies. And I say this as someone that does use ORM frameworks. 
Still more error prone than using an in-memory database. We have to wait for PostgreSQL to start up on one of our builds that requires us to use a real database. And we can only do that by polling. 
Java has a huge problem, and it is a version problem. If you run a JAR 1.8 but your JVM is 1.6, it’s a mess. Go’s binaries, on the contrary, are ready to run right away. It simplifies things a lot.
If you use type safe queries, you don't need all of that and you can understand your code years later... but hey if you are happy with plain SQL, so use it and be happy....
We use this approach for Hibernate IRM tests on MySQL and MariaDB. After Docket starts, tests begin to run and the DB is already available.
I use the criteria API
What do type safe JPA queries have to do with code readability? Actually, looking at your comment history I think I see a pattern: &gt;If your DB is not performing well, you can also throw money at the problem (It is 2018, even my desktop has a 6-core cpu). You could use a DB cluster. The performance increase is incredible (see postgresql + wal). &gt;Code generation is amazing, it produces reproducible code. You only need to debug it once and it can be incorporated in your DevOps efforts. It saves time and nerves. I really don't understand whats not to like about it..... Now I understand where the whole "ORMs are amazing" is coming from....
&gt; (I'd trust an ORM to generate better SQL than most of my co-workers in most cases). You must be one of those people that don't watch what queries hibernate is sending to the database. That is the only explanation, because if you did watch the queries hibernate generates on its own you would realize how laughable your comment is. Even when using Hibernate you write HQL for your read-only queries. Otherwise performance is non-existent. 
And if you build something in Go that uses libraries how versioning is handled there? As for binaries - they run just fine even on Ubuntu 6.06 LTS? Because you know - you want to run binary form 2014 on JVM from 2006... Funny thing - you can set target JVM version but this will limit what you can use.
 so? whats your point? and yes, ORMs are amazing :-D
My point is that as someone who clearly lacks basic understanding of the architecture of modern RDBMS you probably shouldn't be trying to lecture people on ORM hate. 
maybe you want to revisit some CS lectures then before you show off your ignorance?
This. Java 1.8 has quite a few features that aren't available in 1.6 (off the top of my head: lambda expressions, multicatch blocks, default and/or static methods in interfaces, try with resources...). You can't expect to write code targetting a 1.8 JVM and expecting it to run on a 1.6 one. WTF.
no good java library for using RTMP. [https://en.wikipedia.org/wiki/Real-Time\_Messaging\_Protocol](https://en.wikipedia.org/wiki/Real-Time_Messaging_Protocol) &amp;#x200B; I was looking to write some software that would stream to Twitch, but couldn't find a good way to do it.
**Real-Time Messaging Protocol** Real-Time Messaging Protocol (RTMP) was initially a proprietary protocol developed by Macromedia for streaming audio, video and data over the Internet, between a Flash player and a server. Macromedia is now owned by Adobe, which has released an incomplete version of the specification of the protocol for public use. The RTMP protocol has multiple variations: The "plain" protocol which works on top of and uses TCP port number 1935 by default. RTMPS, which is RTMP over a TLS/SSL connection. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
:) . Yes I'm very ignorant. Let's take a part some of your mindless drivel though, shall we: &gt;If your DB is not performing well, you can also throw money at the problem (It is 2018, even my desktop has a 6-core cpu). You could use a DB cluster. The performance increase is incredible (see postgresql + wal). All righty. First of all mentioning CPUs in the context of RDBMS (like Postgres) is idiotic. Anyone with even a shred of experience knows that the traditional bottleneck of relational database systems, nay most database systems, is I/O. If you have money to throw at your database you don't buy more CPUs, you buy a faster disk. Second of all, clusters are horizontal scaling and as any competent DBA could tell you, RDBMS just don't scale horizontally. Yeah, there are all those fancy shmancy products like Oracle RAC, etc, but sharding on an ACID-compliant system just doesn't work well at all in practice, not to mention the crazy tricks it does to transaction isolation levels. However, third of all, and most important point is: if your DB is not performing well and your first knee-jerk reaction is to scale hardware - woe be to any development shop that dares to hire your ignorant ass. 
&gt; readability, type safety / strong typing, IDE support, debugability Don't data access objects provide all of those benefits? &gt; security (sql injection anyone?) Prepared statements have solved the sql injection problem since decades. Even spring's JdbcTemplate uses prepared statements internally.
What's wrong with https://github.com/JodaOrg/joda-money?
I've been a professional software engineer for about 20 years. Around 15 of those in Java. Do tell which CS knowledge I lack. Wait, why do you keep referring to all of this as CS? Are you a student? :)
yeah whatever, 20 years of experience and not able to discuss a problem in a proper way...... enjoy your sql &amp;#x200B;
Yes, that was not a problem for jOOQ, which already has them for a while. But if you're maintaining a library that has split packages, are you really going to break backwards compatibility lightheartedly in order to be able to specify automatic module names?
&gt; When using PostgreSQL, it’s tempting to use a SERIAL or BIGSERIAL column type to auto-increment Primary Keys, when using JPA and Hibernate, this is not recommended. I've seen the rationale behind this in the past, and I understand the reasoning, but as a database person, I find this advice rather funky. I would like to design a schema that works *for all clients*, not optimise the schema *for a specific client*, and within that client, *for a specific library / framework*...
I'm not bashing, but... &gt; readability Use jOOQ &gt; type safety / strong typing Use jOOQ! &gt; IDE support jOOQ again &gt; debugability [sic] jOOQ, I guess (how is Hibernate debuggable, specifically?) &gt; security (sql injection anyone?) Oh yes, jOOQ! &gt; In software development there are much bigger issues than performance Nope. They're usually just as big. I mean, if you think security is something noteworthy, you should at least mention performance on the same level. But then again, performance/slowness and ORMs/SQL are two orthogonal discussions. &gt; I guess it is much easier (and cheaper) to deploy a postreSQL cluster with WAL than to handcraft every sql query. Are you talking about CRUD or actual business logic, analytics, etl, reporting, etc?
[This is a post](https://ren.zone/articles/safe-money) for `safe-money` in Haskell, but I still learned a lot about how to manage money with programming.
Vaadin ?
&gt;A good example is the Spring Framework. Spring (through configuration) imports a number of external libraries (including some of its own). Through Maven’s inheritance and dependency mechanisms, your application depends on the Spring framework which has pre-imported and pre-configured those libraries and given you an easy way to configure not only itself (Spring), but those other external libraries. I think this is closer to the original definition of framework as it was presented to me. The point it highlights is that, since the **framework calls your code**, there's a lot of dependency on the code you write with the framework, and it's hard for you to have a "mix" of frameworks, since your runtime \*is\* the framework (think Java servlets, they are the code that opens a socket, receives the bytes, etc. Additionally, you can't generally mix another runtime that does similar things to servlets even if you need some functionality that servlets may not have - you need another process running the separate runtime. These two factors have caused (heavyweight, traditional) frameworks to become marginally less popular in recent years. &amp;#x200B; &amp;#x200B;
This is because Lombok is just one giant dirty hack. It is lucky to work at all (or unlucky depending on your views on lombok). 
of course you can use jooq which is great, but that was not the topic, the topic was plain sql! Reading skills are not offered by your consultancy then? 
Did you try to invalidate your caches and restart? Do you have IntelliJ delegating build tasks to Gradle?
What a weird way to compare IDE's.
i really hate to be that guy, but... Kotlin has a great [DSL](https://github.com/Kotlin/kotlinx.html) for exactly this. But yep, I haven't found a pure Java version that fits this niche.
That's what Java needs... A transpiler. Write code in 11 and transpile it back to 1.6... /s
Yes, yes.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Waiting for a container with the correct database to start really isn't _more_ error prone than testing against a _different_ database, it's just differently error prone. The "abstract database" is one of the great lies of this century.
I didn't see your /s at first and you had me... worried.
The main problem with what you call "plain SQL" is string concatenation. Once we have raw types (Java 12 onwards), the occasional "plain SQL" statement embedded in Java. Again, views are also "plain SQL", and stored procedures allow for using "plain SQL", so your distinction is more fuzzy than what you may have wished for. Your snark was obviously uncalled for, but you knew that when you wrote it. Because otherwise, you would not have entangled yourself in a contradiction like this: &gt; I guess it is much easier (and cheaper) to deploy a postreSQL cluster with WAL than to *handcraft every sql query*. [...] but that was not the topic, the topic was *plain sql*!
All of these are either easily avoidable or customizable. There are many legitimate issues with Hibernate (as with any software), but this is just mindless complaining.
Back when Hibernate was new I do not think it had joins(I am talkig about HQL which later mostly became JPQL). And original promise of hibernate was work with objects like they are in memory which faild really badly. Average developer is not capable of writing performant JPA/Hibernate model and he is not capable of writing a performant SQL code. But one big plus with writing SQL is your DBA can help you optimize it. In JPQL it is hard to write little optimization tricks. But if you drop down to to native every time why use ORM at all mapping code is written verry fast and easy to write. 
Guilty as charged. I was in the mood of complaining. I know a lot of stuff I mentioned can be fixed, or are just bugs that you can cause yourself, but I'm personally just impressed by how horrific results you can get from just a few simple mistakes. Let's just say that I fundamentally disagree with the entire approach that Hibernate has taken with ORM, and I will never rely on technology that does that much and tries to be that smart. I guess the critical thing is the surprise factor. I prefer my technology to be as dumb as possible, but not dumber. Like, for instance, Hibernate having a strategy of saving objects using java serialization if they implement Serializable. Which probably totally seems to work OK to the point that code can even end up in production with that mistake, until at some later time when you realize the ginormous fuckup that you have done.
Some CRUD queries, or queries that fetch 10 entities by a filtering criteria are easy to optimize. For projections, you can use plain SQL instead. It's as simple as that.
Try again. Gradle 4.10 introduced cleaning up caches. Probably 90 seconds of Gradle 5.0 was cleaning up 6Gbs of old stuff that accumulated. &amp;#x200B; If for some reason this is consistent, then you should contact us, because that is unacceptably slow and not at all what our performance tests show.
&gt; You shouldn't use hbm2ddl in production. We wrote that in the User Guide. You should use FlywayDB or Liquibase instead. Here's a loaded gun, courtesy of Hibernate. Please use responsibly. In case you do end up shooting yourself with it, know that we did not advice using any guns we give you in our comprehensive user documentation. I think you should work on making it work well enough that production can be run with it, because many people will do. I think the statement like above is just a cop-out. I know versioning issues are a little bit difficult because schema must occasionally be migrated from one version to another. It's also tantalizingly close to reach: most of it boils down to creating new tables, adding new columns and dropping unnecessary old columns, all which can be done automatically. On a rare occasion you have to identify the version of schema running and write some kind of migration procedure to convert, though. Still, it's a short init routine that you do before you let Hibernate or some other automatic tool touch the schema. &gt; In the User Guide, you will see that we advise devs to use @ManyToOne(fetch = FetchType.LAZY) by default. Maybe you do. Perhaps the issue is that I do use Hibernate through JPA, which probably cripples it somewhat in terms of available API and convenience. Part of my problems are probably just results of dealing with JPA in addition to Hibernate. &gt; That will be changed in Hibernate ORM 6.0, so stay tuned! Glad to hear it. &gt; You'd be surprised by the amount of effort we put into rewriting the User Guide! I see no way in your user guide to turn off Java object serialization. I just consider it another loaded gun, handed to me either by the JPA specification or Hibernate itself. Honestly, what self-respecting database schema would have a column where your actual intention is to write programming language specific binary object data? Documenting that this happens is fine, I guess, but how about all the folks that go "why would I *ever* want this, and how do I turn that misfeature off?" &gt; The version you used 10 years ago is way different than what Hibernate 5.4 is now. You misunderstand. I do have Hibernate versions up to 5.3.7 running on production. I still have some dozen applications or so using it, and they will probably never be migrated away. I consider the most critical things to have to do with hbm2ddl, because they kind of make Hibernate-derived schemas ugly to look at. But I guess I'm at fault of using it in the first place, right?
If your app is 80% CRUD ok it could be usefull but most apps I work on are 80% other. Queries of 20 lines and more are normal. Data that is part of 1 entity that spans multiple rows, PK with 5 or more columns, SQL with 3 or more levels of nesting, tables with 100 or more columns that never get fetched all at the same time,multiple CLOB columns. This database i worked with had more than 5000 tables with almost 100 materialized views and many normal views. Most entities were a combination of multiple tables some of them were lookup tables some not. &amp;#x200B; When you have data model that complex JPA just gets in your way.
&gt; You are working in an OO language. Your data is relational. You map them together. Everything is ORM. Objects don't really map to relational data. I.e. you can't build a set of database tables to represent something like inheritance that are first &amp; second normal form compliant. Every type of ORM sells you a compromise of sorts, and compromises are never a good thing. 
Would you rather write the implementation details of that compromise yourself or import a package dedicated to just doing that?
I've tried many times. It seems related to the network because when I use the `--offline` the build time drops to 0 seconds. I'll investigate more.
Definitely myself. At least I have full control over it and can keep implementation details of both my relational data and my Objects separate. Whereas going with ORM imposes certain choices arbitrary software makes that are often the wrong ones. Hibernate, in particular, has a number of deeply flawed features that I've run into over the years that are so poorly designed as to be considered broken by almost everyone except for Hibernate creators. 
Of course but what I mean is you don't need a framework. Instead of wrestling with a framework to force it to work for your use case efficiently, writing your own classes is almost always better for any non trivial project. 
Why does the extension matter? What's even wrong with it?
Just my OCD. I would like the main build script to have the simplest possible name. `build.gradle.kts` looks too much. The same reason I dislike `CMakeLists.txt`. Yeah, some stupid complain. But it could be great if the language can be inferred from `build.gradle` alone.
Any idea of intellij supports that already?
IntelliJ already supported the Kotlin DSL with Gradle 4.10.
Ok thanks
You need Tomcat/Jetty/JBoss etc if you're listening to HTTP requests. They're not "application servers", but "web application servers". They're Servlet containers. If you aren't serving HTTP requests you don't need Tomcat. I probably question what you were doing if you did.
I wonder why does it take longer using `list.forEach` than using `list.stream().forEach()`. This actually makes no sense. Possible causes: 1. Larger error margin in case of `list.forEach`. 2. Stream uses enhanced for-each under the hood, that's why it is comparable to that result as well. 3. The `list.forEach` is not reimplemented in the List implementation to be more efficient. I'd say that this benchmark is incomplete. I'm very much interested in what kind of list was used, and look into some possible causes for the larger error margin. In theory, with the best JIT optimization possible, the `list.forEach()` version should be the fastest, as the List implementation itself can optimize out some sanity checks and unnecessary virtual calls. And for one more thing to mention, `list.forEach` has an advantage of no iterator `hasNext` calls, which can be costly if you're dealing with concurrent collections, or handling online resources.
If your application consists of reading data via SQL, and you barely modify any table, than JPA and Hibernate are not a good fit.
I kept the margin error in the table so that everyone can see how the test went on my computer. The list is an ArrayList. Of course the choice of the collection has an impact. However, my goal was to see what could be the impact of the code form. So, of course, every test uses the same collection implementation. Here is the code: [https://github.com/qwazr/java-benchmarks/blob/master/src/test/java/com/qwazr/benchmarks/ForLoopBenchmark.java](https://github.com/qwazr/java-benchmarks/blob/master/src/test/java/com/qwazr/benchmarks/ForLoopBenchmark.java)
&gt; I think the statement like above is just a cop-out. I'm the person who rewrote around 80% of the new User Guide. I wrote [this statement in the User Guide](http://docs.jboss.org/hibernate/orm/5.3/userguide/html_single/Hibernate_User_Guide.html#schema-generation): &gt; Although the automatic schema generation is very useful for testing and prototyping purposes, in a production environment, it’s much more flexible to manage the schema using incremental migration scripts. &gt; I see no way in your user guide to turn off Java object serialization. I just consider it another loaded gun, handed to me either by the JPA specification or Hibernate itself. Honestly, what self-respecting database schema would have a column where your actual intention is to write programming language specific binary object data? Documenting that this happens is fine, I guess, but how about all the folks that go "why would I ever want this, and how do I turn that misfeature off?" Well, if you manage the schema with Flyway and the column in VARCHAR and Hibernate tries to persist it as `byte[]`, the Integration Tests will fail, and you do have Integration Tests in your application, right? So, this issue is improbable. &gt; I consider the most critical things to have to do with hbm2ddl, because they kind of make Hibernate-derived schemas ugly to look at. But I guess I'm at fault of using it in the first place, right? The goal of hbm2ddl is to allows the tests in the hibernate-core to generate the schema from the test entity classes that are confined to the test class. That's why it was added. Now, why did you assume that it was a good idea to use it on a production system? 
The list is an ArrayList. It is visible in the source code. Of course the choice of the collection has an impact. But the purpose of this was not to compare collections implementations.
you don't need them. you can have the entire web server part in your application if you want. but if you need to run multiple web applications on one server, on the same port, then the only way to do that is via an application server, which it is then the server and can forward requests to the appropriate application. of course, tomcat/jboss/etc. do a lot more than just act as web servers, provide services like messaging, or database conectivity, etc. which means that applications do not need to be burdened with maintaining and providing those libraries which in turn saves space and RAM and time.
Any performance comparison is heavily affected by the implementation you use. For example, a loop with a `LinkedList` that used `get(int)` is going to perform absolutely terribly compared to a loop that used an `Iterator`. Your timings are meaningless for comparing looping a `List`, only for looping an `ArrayList`. 
`Collection.forEach()` can be specialised for an individual collection implementation, where as `Stream.forEach()` can not. Plus, `Stream`s have a surprisingly large amount of infrastructure behind them.
Don't give a shit. It's a build system that thinks it's a development environment. Did we learn nothing from make and friends ? 
Would you mind elaborating the deeply flawed features and the poorly designed features as well? 
I hate the way i like you 
&gt; Would you mind elaborating the deeply flawed features and the poorly designed features as well? Sure. It's been a few years but the following two from war stories jump to mind: - Optimistic locking. It is simply broken in Hibernate. I could probably write a whole article on all the ways it fails in the real world apps. Just don't use it and implement optimistic locking manually. - Pagination. By default when you have appropriate dialect it selects appropriate pagination strategy and paginates your results for you without having to worry about any ROWNUMs or what have you, right? Except Hibernate will never prevent you from pagination even if you don't have an ORDER BY clause which basically results in pagination results being potentially completely random. 
You only need an application server if your code depends on one. If you just have a main class, there is no need for an application server. You don't even need an application server for a Java web application - if you write all the http handling code yourself. It's much easier to leverage all of the code provided by the application server if your application handles http. 
&gt;Tomcat/Jetty/JBoss Tomcat/Jetty/Undertow
The problem is text editors need an extension for syntax highlighting.
I think what he's trying to say is that there is no de-facto machine learning libraries in Java, whereas in Python you have extremely active projects in this area. Most obvious Python project that I know of which does not really have a Java equivalent is [scikit-learn](https://github.com/scikit-learn/scikit-learn).
Everything related to video and audio. And ui toolkits that are not swing and javafx. 
&gt; Adding to this, for instance Spring Boot has its own servlet container embedded With Spring WebFlux it's just Netty so you don't even have a Servlet container anymore. And there's a lot more microservice frameworks that don't support servlets. 
You are right. Of course, by nature, a LinkedList would probably perform perfectly using an iterator, and badly using indexed access. But again, the goal was not to compare the performance of the list it self. The goal was to see how the compiled byte code would perform by using the large options Java provide. And as some code required the use of the get and size methods, I choose the implementation who is suppose to provide the faster implementation on indexed access. At the end, once can reuse this project and use any other list implementation. And this exactly meet the educational role of this little piece of code. &amp;#x200B;
Amen brother. Although, where's Maven 4.0?
There's nothing wrong with the Hibernate optimistic locking mechanism. The default implementation prevents lost updates. The force increment lock modes allow you to materialise conflicts across multi levels if associations. I wrote over [30 articles about concurrency control on my blog](https://vladmihalcea.com/tutorials/hibernate/). Feel free to point out the flawness of the optimistic locking mechanism. As for pagination, the SQL standard defines the construct independently of the IRDER BY which is defined in a different section. Does that make the SQL standard flawed too? Anyway, not using Order By with pagination denotes a lock of SQL knowledge, which leads to manu other issues even if you don't use JPA of Hibernate. 
&gt;There's nothing wrong with the Hibernate optimistic locking mechanism. There is. You aren't allowed to set the value of the field that is used for versioning which severely limits its actual usefulness in the real world applications. 
A performant, open-source, JavaFX/Swing PDF-viewer. I'd be content with a non-Android JNI wrapper around Chromium.
That would be a terrible mistake because the version is required to be increased monotonically, not to be set freely by the user based on a random value. What you think it's a bug, it's actually a feature. All logical clocks work this way in Concurrency Control. The purpose of the version is to give a happens-before consistency model, hence this requirement. The only time you can actually pass the version is firing merge, which is required since you want to reattach an old snapshot while optimistically assuming it has not changed.
And Maven isn't? I've never met a non complex build system other than a hand crafted one for a simple project.
Terminal ftw
While at it you could add a while-loop. Also maybe this "clojure-trick" is faster? private long usingStreamForEachMethod(final List&lt;Integer&gt; list) { final int[] total = new int[0]; list.stream().forEach(value -&gt; total[0] += value); return total[]; }
This use case is treated in [this blog post](https://vladmihalcea.com/preventing-lost-updates-in-long-conversations/). What you need is to retain the load-time entity snapshot, either on the server or the client and use that when you call merge. The load-time version will be used in this case. This is how it's supposed to be used, and the load-time snapshot is used for dirty checking too as the flush figures out whether an UPDATE is even necessary.
Then use an ORM framework when it suits you and drop it when it doesn't, rather than wrestling with it. I have never used JPA/Hibernate, but I have had good experience with lighter frameworks like mybatis and jooq.
I would rather definitely not myself in the same way I don't want to implement my own collections, sorting algorithms, etc.
You don't NEED an application server. But ask yourself WHY do they exist and are so widely used? The server provides services which make it easier for you to write your application. Certainly you can build an HTTP server into your application. Along with dispatching to the right handlers for various URL paths. But why should every web application re-invent that wheel instead of focusing on what the application does? I get paid to build an accounting application not a web server. Your entire build process can produce a single artifact: the WAR file. FoobarApp.war. You can plug FoobarApp.war into any Java application server (Tomcat, Jetty, Wildfly, . . . others). Those servers provide various standardized services that your application can use. Session tracking with cookies. Named resources -- where the values of those resource names can be changed in the server without altering the application. Multiple applications hosted on a single server. A single control panel (such as Tomcat's control panel) that lets you install, remove, start, stop individual applications. I'm not trying to 'sell' you on an application server. I'm merely pointing out that they provide a lot of services that you don't have to write yourself. You mention building HTTP into your application. What about HTTPS? All of the sophisticated crypto algorithms and machinery. Tomcat, and others, already do all of this and more. You can tell tomcat how many spare threads it should have listening for incoming requests -- without altering your application. Tomcat gives your choices of which "connectors" you might want to use -- configured in the server.xml file, outside of your application. Your application doesn't care how the plumbing works. Another brand of server might implement it very differently -- but the interfaces are all the same and your compiled application file just plugs in. Hope that helps you to evaluate the alternatives.
&gt; What you need is to retain the load-time entity snapshot, either on the server or the client You can't retain a load time entity snapshot on the client, because, umm welp it's HTML/JavaScript. You can't retain a load-time entity snapshot on the server in an environment with micro-services (that actually handle your web calls) because that would introduce sessions, persistence, storage, etc. That is how majority of apps are written these days. This is my point. When Hibernate was written it was mostly seen as a replacement for EJBs which ran on these gigantic application servers as big monolithic apps and if all of your entities are floating in one big VM, Hibernate concepts (like hanging on to an entity snapshot inside VM) sorta make sense. In 2018 it simply doesn't work anymore. 
&gt;&gt; ...it's just that building all that stuff yourself is generally a waste of time so we use abstractions over this. So we need them?
If you want to be a Commercial User, then buy a commercial Java from someone, such as Oracle, or Red Hat or others. If you don't want to use a Commercial version of Java, then use the open source Open JDK. The commercial versions of Java are based on Open JDK. Here are some places where you can get compiled binary builds of Open JDK. (Or you can built it from source yourself.) [https://aws.amazon.com/fr/corretto/](https://aws.amazon.com/fr/corretto/) [https://github.com/corretto](https://github.com/corretto) &amp;#x200B; [https://adoptopenjdk.net/](https://adoptopenjdk.net/) [https://github.com/AdoptOpenJDK](https://github.com/AdoptOpenJDK) &amp;#x200B; [https://github.com/ojdkbuild/ojdkbuild](https://github.com/ojdkbuild/ojdkbuild) &amp;#x200B; [http://www.azul.com/downloads/zulu/](http://www.azul.com/downloads/zulu/) &amp;#x200B; [https://jdk.java.net/11/](https://jdk.java.net/11/) &amp;#x200B; [https://developers.redhat.com/products/openjdk/download/](https://developers.redhat.com/products/openjdk/download/) &amp;#x200B; [https://github.com/SAP/SapMachine](https://github.com/SAP/SapMachine) &amp;#x200B; [https://bell-sw.com/java.html](https://bell-sw.com/java.html) &amp;#x200B; I would also say a similar thing about Linux. If you want a commercially supported Linux, then buy one! Or download a precompiled open source Linux and use it without the assurance of anyone to call at 3 AM if something breaks. But many (maybe most?) people do that. There's nothing wrong with that. &amp;#x200B;
I'm not saying not to write SQL when you need to. In my experience, most of the stuff I have had to write is pretty simple CRUD. In those cases, I can write very little code that glues together a web server with my data and get a full featured REST, gRPC, or graphql API into my data. Most endpoints make one simple read query selecting a single row of data and maybe doing one or more joins, and if it has to write anything, it's a single insert or update. Why wouldn't I lean on some full featured packages which can give me this basically for free or at least make it very, very easy? Then for complex batch jobs, reports, etc, feel completely free to bypass the ORM and do whatever you need.
Of course you can. The entity can be passed as JSON to the client and reconstructed back as a detached entity from it's JSON representation. Easy peasy. Hibernate is used with Java EE application servers, with Spring, for EIP tasks like Apache Camel or Spring Integration, etc. You'd be surprised how many projects use it and choose it in 2018. In fact, most Spring Boot applications use Hibernate too. There are millions of Java developers using it every day.
One of the easiest ways to get started is to create a JAR file. A tutorial on how to do so can be found [here](https://docs.oracle.com/javase/tutorial/deployment/jar/build.html). Information on advanced techniques, such as packaging the JRE with the application, can be found [here](https://docs.oracle.com/javase/tutorial/deployment/selfContainedApps/index.html). Java 9 added a linker, which can optimize your build by only including necessary modules and dependencies. It is named jlink, and you can read about it [here](https://docs.oracle.com/javase/9/tools/jlink.htm#JSWOR-GUID-CECAC52B-CFEE-46CB-8166-F17A8E9280E9).
&gt; Of course you can. The entity can be passed as JSON to the client and reconstructed back as a detached entity from it's JSON representation. Easy peasy. When you attach a detached entity, you still cannot set the versioning field yourself. I mean, you can, but Hibernate will simply ignore it. Am I missing something here? 
&gt; Why wouldn't I lean on some full featured packages which can give me this basically for free or at least make it very, very easy? Because ORMs are pretty heavy engines for doing that. You can easily use something like a SQL mapper and achieve the same results with just as much ease. However, if your CRUD is really that simple and you aren't planning on growing it into a full-featured system I suppose it's fine to use whatever you are comfortable with (and gets the task accomplished faster) 
You are simply missing my previous explanation about how merge works and the version is passed along.
"Java is still Free" is THE document answering to a lot of questions: [https://docs.google.com/document/d/1nFGazvrCvHMZJgFstlbzoHjpAVwv5DEdnaBr\_5pKuHo/preview](https://docs.google.com/document/d/1nFGazvrCvHMZJgFstlbzoHjpAVwv5DEdnaBr_5pKuHo/preview)
Such a shame they didn't name it build.kradle
Java means many things. One of them is the 'OracleVM'; this is a binary compilation with associated tech support (both applying security fixes and redistributing, telling you about it, and supporting your use of it) released by oracle. It will be for-pay only starting with JDK11. There are many other binary disttibutions of the same source code; that source code (java, the hg-based source code) is open source. I suggest you look at adoptopenjdk.org or amazon corretto.
We NEED the JVM to run java server applications. We don't need Tomcat. It makes everything easier (and should be used whenever possible) but it isn't a hard requirement.
With proprietary stuff, IIRC --profile (ran locally) should also detect high dependency resolution times.
I understand how merge works and how version is passed along. My point is that your solution requires for a detached entity to be persisted somewhere, be it HttpSession or HazelCast or whatever. That is NOT always an option in modern web apps. 
You doesn't need application server, it's relict of the past. Just give a try to Spring Boot which has embedded application server into "main". It's much easier to debug, as your whole application is in one jar instead of war that is depending on external linked libraries. https://docs.spring.io/spring-boot/docs/current/reference/html/deployment-install.html
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Prepared statements are life
In the product I work on we do both. Some applications are plugged into tomcat. Some just constantly run on the back end and manage their own connections and lifecycle and others yet are called by other processes and take commands as input and die when they are done. Do what makes sense.
But you can do anything. Sounds like you might enjoy maven. 
I think the word in question is "need". You can do it yourself, it's not that hard. But, it takes time to get it right, so it's easier with a web application server. Tomcat is not my first choice, but it's relatively lightweight and not bad. 
This is so naive and innocent I actually feel bad for laughing.
Or, the browser. Most front-end applications use JSON to bind data to the UI. So, you just retain the same JSON entity representation you have used to render the UI when saving changes. It works like a charm.
How difficult was it for you to land your first Java position with only having PHP and front-end experience? I'm looking to do the same. I've been working with JavaScript the past 3+ years and want to move over to Java.
You cannot go from JSON -&gt; detached Hibernate entity with an intact version field inside of it :) 
I use the Criteria API for every single query. The extra time spent writing is saved 10x over the life of the application during refactoring.
Well, I was promoted into being a PHP/LAMP stack developer from being a warehouse supervisor making VBA Excel apps within my company. Then after two years, I was promoted in to being a Java developer within the same company. I’ve never actually landed a software developer job through interviews and such. This is my only company as a software dev. I’d say that I’m proficient in core Java, but I can tell you that based on my personal experience with PHP and JavaScript, the transition to Java was freaking difficult. There are things that Java enforces that JavaScript and PHP do not, and that will take some getting used to. Biggest of all, Java is a compiled language whereas PHP is interpreted and doesn’t need to be compiled. JS runs right in your browser. I wasn’t using any dependency management or package management tools with my JS/PHP projects, so it was a bit of a shock and a steep learning curve jumping into that stuff with Java (Maven and Gradle). If you have experience with Node or NPM, then I suppose it will make the transition easier because of all of the moving components that can come with a project. Still, Java is a powerful object oriented programming language (C derived I believe), so while the syntax coming from JavaScript won’t be completely alien, there are still a lot of things that are different. Java is also a statically typed language while JS is a dynamically typed language, assuming you aren’t using TypeScript. This also seems redundant and repetitive when you first come from a dynamically typed language until you get used to it (I still occasionally write JS but would feel really “uncomfortable” writing PHP again being that it’s dynamically typed and I’ve been on Java so long). These are some of the many things you’ll have to adjust to when making this transition. The IDE is also something that takes some getting used to. It can be overwhelming in the beginning trying to keep track of how to compile, where to compile (terminal vs IDE), debugging and stepping through code, and all of the intricacies that come with an IDE and a programming language. I haven’t used Netbeans really for Java, but Eclipse is free but has been hell to learn. I just started using IntelliJ, and it’s pretty good but the full version costs money. I think maybe $10-$15 a month? Not sure, but it’s probably worth it if it will lessen the difficulty. That being said, if you read this far down then you should know that switching to Java was probably the best career choice I’ve ever made. It took me out of my comfort zone (I was probably the best PHP developer on my team and was staring to get into C to write PHP packages) and forced me to step my game up, seriously. Unless I needed to learn a functional programming language, or C/C++, Java has toughened me up enough to not be intimidated to learn any new language, framework or concept. I don’t know any Python or Ruby but my wife dabbles in them, and whenever I have to help her it’s usually really easy for me because all I’ve been through with Java. If you have any other questions feel free to ask here or message me if this thread fades away. I’d love to help someone along their path and save someone time and energy.
Thanks for taking the time to respond! I'm currently a junior at ASU pursuing a degree in software engineering, so I have a little Java experience. I'm becoming more comfortable with the statically typed nature of Java, but yes it has been a difficult transition thus far. I'm becoming bored with JavaScript though and feel like, as you mentioned, it would push me to learn more about programming in general. I just feel like the projects I'm building for my classes wouldn't be enough exposure to get me a Java position. I would like at least a mid-tier position. Definitely wouldn't like to start over as a junior developer. I believe some things I already know could be useful (node/npm, mysql, mongo, git, webpack/grunt/gulp, etc.) I also use IntelliJ daily. I've written JUnit tests and learned about Gradle this semester. I'm just looking to expand my knowledge professionally, not just personally.
Why not? 
There are a few partial transpilers, if I'm not mistaken Retrolambda :)
&gt; You can do it yourself, it's not that hard. But, it takes time to get it right, so it's easier with a web application server. So you need it? 
Most applications today are based on input/output over http, so it is a bit strange that you need something like Tomcat. Imagine if you would need third party libraries to work with the keyboard or to read/write to standard out. Shouldn't this capability be built into the platform? Not a full-fledge application server, but something for basic input/output. You can create your own server socket and handle requests, but that's like setting up interrupt handlers for the keyboard. Today you start an application in the main method. Maybe there should also be a way to launch an application that waits for input/output over http. JDK\_HOME/bin/javahttp [MyApp.java](https://MyAppl.java) public class MyApp { public void hello(Request rq, Response rs) { rs.println("Hello World!"); } } The result could been seen on http://localhost/hello It could be a plugin architecture, so if you have an application server on the module path, it could take over and handle more complex use cases.
Java is not so widely used for desktop apps, but heavily used in backend parts of enterprise systems. For enterprises it's usually packed into \*.war\\jar and deployed to the web servers(tomcat\\jetty\\wildfly) as a separate containers with micro-services or as a solid applications on a huge greedy VM's. At this moment Java role usually is to expose web API, process business logic and data validation layers and work as an entry point to database. So if someone opening account with your company, data will be collected through the JavaScript based view, passed to the Java program, be validated, transformed and saved into the database. For desktop applications code coming packaged to \*.jar with appropriate launcher - shell or bash scripts, exe file for win, which actually launch java from cmd with required parameters in the user friendly manner. More complex apps may have on-site database, some external modules, so program may come as a folder with jar, few subfolders with database(sqlite for example as a small local DB), libraries(win specific DLL's) and let's say config files in separate folder. In root folder you'll find main \*.jar with logic and \*.exe(\*.sh) file which will do something like "java -Xmx=1024Mb -jar program.jar -Ddatabase.location=db.api", but way more complicated, which will actually run your program specifying how much RAM it can consume and where is your database located, hiding all these technical details from the user.
Nice.
Gonna go out on a limb and say python or matlab as scientists can't be arsed to learn real languages
or R :) &amp;#x200B;
Vaadin is an excellent framework, if you are a desktop application developer and like to develop a web application with that skillset. It is basically like writing a Swing application. I can not follow the comments below that claim Vaadin does not scale. In my experience it is super fast. However as it is a monolithic deployed web app, it obviously can not scale via micro services deployed in a cloud. Angular or ReactJS are browser based. That means you have to code the interaction with the server yourself, you need to know how a DOM looks like and basically address "your widgets" via id or name tags. Comments below that claim, you have no control over the look and feel of your Vaadin app, or are restricted in layout options: are simply wrong. Vaadin emits standard HTML where every widget has its own name and tag. Everything is rendered using CSS.
I'm not sure how popular R is in the scientific community so I can't speak to this
What's the advantage of using Netty over Tomcat for Microservices? We're currently shifting to a Microservices architectureand I saw some post recommending Jetty or Undertow
&gt; You don't need application server, it's relict of the past. Just give a try to Spring Boot (rolls eyes) You know what spring boot uses to run your application? Tomcat.
If that's all you took from my comment; sure. 
TL;DR: Before: JButton button = new JButton("Button"); button.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { foo(e); } }); After: var button = new JButton("Button"); button.addActionListener(e -&gt; foo(e)); - Me: See ma, it's functional? - Ma: Meh.
You actually don't need it. Just open a standard [`java.net.Socket`](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/Socket.html) from the `java.base` module, and implement the HTTP protocol yourself, should be rather straightforward.
I think Clojurians would like to have a word with that author.
okay (:. just hoping some bioinformatics folks follow java reddit also
Is Concurrency in Practice still relevant today? It seems a bit old Java 6? I’ve not read it, but interested in doing so. Working my way through Modern Java in Action and Effective Java. Was debating either Concurrency in Practice / Head First Design Patterns / Grokking Algorithms next. 
it is
Documentation is still piss poor. You can only learn gradle from stack overflow. Now with kotlin DSL things are even worse. Still betterbetterthan maven though, although that's a pretty low bar.
No need for an application server, just stick nginx (or another web server) in front as a reverse proxy.
Sure, I was merely pointing out that "existing != preferred" which you seemed to imply. BTW, how does JPQL hold up performance-wise? It looks close enough to SQL to assume it should be transferrable easily enough in many cases.
Activated posterior 
Correct. Your comment was completely pedantic and added nothing valuable.
lambda is syntactic sugar
For JPQL and Criteria API, you really need to pay attention to: - the underlying SQL statement that gets executed - the plan cache size as the default 2048 might not be enough. Check out [this article for more details](https://vladmihalcea.com/hibernate-query-plan-cache/). Assuming, you provisioned the plan cache to hold your entity queries, and that you validated the JPQL and Criteria API queries and they look exactly like the ones you'd generate yourself, then there shouldn't be any difference between running an entity query and a native SQL one. 
The best points of this article seem to be: &gt; Make good use of Generic Types. Generics in Java can trace their orgins to Generic Java created by Philip Wadler (Haskell legend), Martin Odersky (creator of Scala), Gilad Bracha, Dave Stoutamire. Don’t ignore type parameters, declare them and enforce them everywhere. Minimize casting and if instanceOfing. Where you do use them (it is still Java after all — they are likely impossible to fully eliminate), centralize each type of cast within a resuable method, use proper type parameters on the inputs and outputs and write good tests! &gt; Make illegal states unrepresentable in our code. The Haskell and Idris compilers will enforce this for you, just pretend Javac is as strict. Avoid nulls, don’t throw Exceptions, avoid locking and synchronization and you will take giant leaps towards this. &gt; Make our own data classes immutable and final where possible, use immutable collections (proper ones). Avoid instanceof checks where possible, and where you use them make sure the types are not extensible. &gt; Use libraries that avoid runtime magic and reflection where pragmatically possible. All of these suggestions are excellent in my opinion, and make your program a lot more robust.
I'd rather have the type information in the declaration than in the initialization (as it is the case with the shortened-generics). I'm not looking forward to: var item = someFunction(); But on the other hand, that's more of a problem in the project than the language.
For the unlikely case that you haven't heard this in one of your discussions before: You are part of the problem. Gradle is EXACTLY what we learned from other tools. It's not perfect - but not accepting that an advanced build tool has to support complex builds rather than denying those builds exist doesn't help us.
This is all fine and good when you are developing yourself and even if you work somewhere where standards are set and actually followed.. but sadly that is not the case in many, maaaaany workplaces. I'm having to deal with awful, awful code right now, and if I didn't have strong typing then it would make it take even more time to get through this horrendous code. I feel like that's what people have an issue with. It's not that they can't themselves write the code in a readable way with or without var, but more that we know idiots will write bad code that we will have to read later and clean up. 
&gt; Correct. Your comment was completely pedantic and added nothing valuable. It's next to impossible for a normal programmer to develop their own http server over TCP. I did that in my first year of CS. HTTP is an extremely simple Text protocol. If that is "next to impossible" for you to implement I don't want to know how bad you are at everything else. And I don't know why you are trying to point out that it was a pedantic comment; I point that out myself. I just wanted to clarify / add to his comment for any beginners that might read it the wrong way. It's quite interesting that you're complaining that I am adding nothing to the discussion when you in your comment basically just repeated what I already said 15 hours ago.
Well, while I am quite mindful about the nulls, locking and Exception parts, all those *avoids* and *don'ts* basically sound like just *don't use Java*.
Understandable, but with modern Java you can code from the ground up and avoid most of the problems. I doubt we'll ever escape null, but hopefully the language will evolve help make it a rarity, if it hasn't already.
That wasn't the intent. Deciding to just not use Java would be a bad decision for most teams (and companies). It's much harder to hire (at least at scale) for niche languages. Java is a critically important language, and for most of us it's not going anywhere. We can learn from other languages though (hopefully without also adopting their problems!).
I believe you’re conflating type inference with strong/weak typing.
&gt;I did that in my first year of CS. HTTP is an extremely simple Text protocol. Precisely my point. You think writing something is just implementing the silly little things in the protocol. What about high availability, integration with other third party tools, all the hardening you have to do to get it ready for production? You think open source projects have an issues list for the first of it? Guess what, I wrote my own SQL interpreting database in college. That didn't mean it was ready for prime time or that I'd be stupid enough to try. &gt;If that is "next to impossible" for you to implement I don't want to know how bad you are at everything else. I'll leave this where it belongs. Says a lot about you and the level of exposure you have to the real world. &gt;And I don't know why you are trying to point out that it was a pedantic comment; I point that out myself. I just wanted to clarify / add to his comment for any beginners that might read it the wrong way. Similar to "I'm not such and such but...". Most times you end up being "such and such." Just making sure you were aware. And if you truly cared about beginners, you would have actually left it alone so you don't confuse them. You essentially were trying to humble brag.
https://en.wikipedia.org/wiki/No_true_Scotsman
**No true Scotsman** No true Scotsman or appeal to purity is an informal fallacy in which one attempts to protect a universal generalization from counterexamples by changing the definition in an ad hoc fashion to exclude the counterexample. Rather than denying the counterexample or rejecting the original claim, this fallacy modifies the subject of the assertion to exclude the specific case or others like it by rhetoric, without reference to any specific objective rule ("no true Scotsman would do such a thing"; i.e., those who perform that action are not part of our group and thus criticism of that action is not criticism of the group). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Sadly we don't have the possibility to switch language easily. I work for a very large organization and we're slow on new technologies (for "security" reasons). We just moved to JDK8... As for your question, I would say the objective is to host various endpoints related to a single domain entity. Ex. A user account details microservice, a schedule microservice (for a scheduling app), a employee microservice, etc...
I may be - and probably am. It's early and sometimes these terms get confused in my head. I hope people can still get what I'm trying to say, though. 
The venerable master Qc Na was walking with his student, Anton. Hoping to prompt the master into a discussion, Anton said "Master, I have heard that objects are a very good thing - is this true?" Qc Na looked pityingly at his student and replied, "Foolish pupil - objects are merely a poor man's closures." Chastised, Anton took his leave from his master and returned to his cell, intent on studying closures. He carefully read the entire "Lambda: The Ultimate..." series of papers and its cousins, and implemented a small Scheme interpreter with a closure-based object system. He learned much, and looked forward to informing his master of his progress. On his next walk with Qc Na, Anton attempted to impress his master by saying "Master, I have diligently studied the matter, and now understand that objects are truly a poor man's closures." Qc Na responded by hitting Anton with his stick, saying "When will you learn? Closures are a poor man's object." At that moment, Anton became enlightened.
At that point, why not just `;`
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Monads are always at fault.
Hm...
This is functional, because it has no side effects. Right?
Be careful with those sync collections. Here's the implementation of some interesting methods: public ListIterator&lt;E&gt; listIterator() { return list.listIterator(); // Must be manually synched by user } public ListIterator&lt;E&gt; listIterator(int index) { return list.listIterator(index); // Must be manually synched by user } And the Javadoc: List list = Collections.synchronizedList(new ArrayList()); ... synchronized (list) { Iterator i = list.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); }
&gt; where as Stream.forEach() can not Of course it can! But the implementation is much more subtle, hidden in the various specialised `Spliterator` implementations.
Yeah it happens a lot discussions of the var keyword I think, sorry I didn’t give any explanation, also early here. But basically the type inference that var provides doesn’t weaken the type system as far as I understand, it’s mostly just syntactic sugar. You can’t go assigning a variable declared with var to value with a different type, right? Your point stands that the type is less explicit, which in your case sucks because the codebase sucks, but I mostly work in Go these days, which also has type inference, and find it’s joy in a codebase that doesn’t suck. Totally unsolicited bit of advice, I don’t know anything about your situation, but if you aren’t being specifically paid to fix a shitty codebase, and the codebase is actually shit, it probably means the devs you work with are also not the best, and it might be time to move on to somewhere were you can learn from better devs. I recently moved to a place where I’m constantly the worst dev in the room and while it’s scary, I’ve grown more in five months here than the previous three years resting on my laurels as a top performer at my last gig. 
Go away, payara spammer.
Guess it would be functional if the button didn't hold a reference to all it's event listeners. I'm bad at FP and I'm trying to wrap my head around how would one do this in a functional manner (i.e. adding event listeners, without overly-complicating the code - event bus or whatnot)
I'm curious, example?
Perl is the mainstream in bioinformatics. R is used as well as other languages but perl is a king there.
I appreciate the advice, and I have definitely thought about it. The project I'm maintaining is dying and desperately needs a complete rewrite. We just got a new VP of r&amp;d who is moving things in the right direction, though, otherwise I would've been gone already. I'm hoping that with his guidance we can pull this thing out of the grave. 
Yes, it's still relevant. The core concepts of multi-threading are still the same e.g. Yvisibility, ordering, thread-safety, immutability, parallelism, etc. It also explains the common mistakes made by Java programmers which result in multi-threading issues like race conditions, deadlock, livelock, etc.. 
The ref.newInstance is a mechanism called reflection, you can search about reflection in Java, because other languages can be reflected too. It allows you manipulate the code dynamically at runtime. The regular way of dealing with instance creation is new SomeClass() but notice how in your example the class name, Demo, is a string parameter, imagine you don't hardcode "Demo" as the parameter but you calculate it dinamically like: Class.forName(aVariable + "Service").newInstance(). It will return an object and you don't actually now the class for it. Reflection is heavily used in frameworks and libraries such as Jackson for json parsing it spring boot for web applications. 
Why is a Lambda in Java less functional than an Lambda in Clojure?
You will likely have better luck asking on r/learnjava. Have you tried doing any searches online?
You can ask your course tutor or teaching rep if you have one.
Knowing that it's a collection provides little to no value. Is it a Set? Is it a List? An array? Is it mutable?
I was just kidding, hinting at the fact that `addActionListener()` returns `void` and thus your statement has no effect on the code that calls it.
https://youtrack.jetbrains.com/issue/IDEA-188689
was quite interested when suddenly right in the center an extra layer of functionality is necessary with no warning in the title or whatever to register for another service. Thanks, but no.
Found it funny that I immediately got deprecation warnings for Gradle 6.0 😁
Thanks for the feedback. As an educational purpose I definitely have to provide a code who follow the standard. Nice catch ! I will update the code. 
Depenencies are also a Monad, if you think about it
As others have said this is reflection. The "Demo" does not have to be hardcoded. eg `Class ref = Class.forName(mycls); Object obj = ref.newInstance();` 
There actually *is* a point in the example from the OP - `Demo` is in the default package, so if this code is elsewhere, it would not be able to reference `Demo` without reflection.
How would you suggest we improve the docs?
I hope Spring-Cloud-Netflix-Zuul is updated soon to work with 2.1. It’s the only thing holding me back.
Most of the time new is just fine and preferred— as the program won’t compile if you’re missing a class. The exception, as others have pointed out is if you have some classes you want swapped out for various environments— or if you anticipate swapping them later. Example is dev vs production classes. The other common use for reflection is loading serialized classes— for instance json to class. 
&gt; No-one in Java-land is doing functional programming, and that is a good thing. So no one is writing pure math libraries? I someone doubt that to be true.
Write them yourself with the assistance of an IDE.
But he's referencing Demo by casting the result and assigning it to obj which is of type Demo.
Ran the testStaleStateExceptionMergeJsonTransform and it does indeed generate OptimisticLockException as described I will bookmark this whole thing for future use. Thank you!
Rainer: As several already stated before me that you don't need one. I want to point on to the topic that there are reasons to pick one and reasons not to pick one. You probably do not want to write the code for the protocol yourself, but you don't need a application server for this. It was mentioned that the application server can let multiple applications run on one Host. Of course you can also put any reverse proxy in front of the applications, so if you only have one machine and want to have multiple applications running, this might be the easiest solution. It was mentioned that the application provides you with messaging. If you need a simple solution, that could be a good choice. Some people like the idea of having the environment configure the configuration, using an application server can be the solution. Others would rather not be depending on the environment or decide for a bigger solution like vault or and should not rely on any external configuration/dependency provided by something like a spring configuration server. It depends on your needs. You should choose what fits you best.
OK.. so just like how I would (will...) do it with golang. Question then, how will you break away from the usual way of embedding services in another service via annotations and just using the service.methods.. when your domain services are broken up and running in separate JVMs? Will you be using JEE/RMI/etc? Or look to use messaging via JMS? I am looking to use Solace message bus with MQTT messaging between golang services. There is a bit of figuring out how you have, say a single API endpoint that may need to use 2 or more services.. especially given the async nature of messaging. My dilemma is.. do I hold up the API request connection while aggregating message responses before sending the final response back... e.g. if say I had a users service and an address service (because we may re-use addresses.. so dont want it to be tied specifically to the users service). The API request comes in to get a user with their addresses (assume they may have more than 1). The API code would send a message out to the user service to find the user.. upon that response.. it would then find addresses for that user via its user id perhaps... upon that response, it would build the JSON response and send it back. I believe in a highly scalable architecture, this sort of thing would happen very fast... but there is still a longer delay in using the pub/sub async inter-service messaging approach I just described, vs the way we have done it in Java, where a single service makes calls to other in-jvm services. I dont know how much faster the jvm approach is.. but I know its not nearly as scalable. So while the per user process time may be a little slower, the ability to scale to an unlimited number of users is what I am more worried about and want to handle.. hence why the micro-services approach is more fitting in my mind as opposed to the "soa" monolithic all API/code per JVM approach that spring boot/jee/etc have taken until recently. Not that you couldnt actually break services apart in java for many years.. as some have done that.. but most apps are all apis/logic/etc in one JVM, and then just scale that as needed. Very heavy on resources to scale it. Anyway, I have also considered maybe async APIs.. e.g. consumer provides a callback URL where upon completion of any request, would send the response to that callback. The down side is mobile.. not entirely sure how to allow a mobile browser/web app to provide a callback... it is not running a server. Could look to use SMS but that is not an ideal approach I dont think. Could implement polling as well.. but that defeats the benefit of async API. Long polling/web sockets maybe? But then.. do I build 2 APIs..one async, one sync.. for those that cant provide callback urls? So much to figure out! 
Not only that I wrote that test, but you are going to publish a new article about it and explain it in more details so that it's clear to anyone using JPA, Hibernate or any other data access framework.
Sorry, you want me to publish an article somewhere? I'm confused :)
The problem I have always had with Hibernate is it tries to be an SQL generator and a ORM. They are not one and the same but Hibernate rolled them into one from the very beginning. Also, the learning curve for Hibernate is way too high. Yes, of course you can make Hibernate performant; however, the amount of knowledge needed to make it performant is far above the knowledge you need to make raw SQL performant. The amount of time you save in initial development (if any) is lost many times over trying to get Hibernate to perform well. I will give credit where is credit is due and say it does mostly solve cross-database support if your application needs that (and if you write software intended to be used on-prem by an enterprise client you almost certainly do). I haven't seen a non-hibernate solution to this issue. Hibernate has been bloatware from the very beginning and is an over-engineered monstrosity that needs to be abandoned. It boggles my mind why it is still used.
jOOQ is not free. 
Oh yea, you're right. I missed that.
No. I'll publish it on my blog next to the [other 200 articles](https://vladmihalcea.com/tutorials/hibernate/) about SQL, RDBMS, JPA or HIbernate,
I'm glad you found my articles useful. As you already found out by now, my blog is not about JPA or Hibernate only. It's about getting the most out of your data access technologies. For the next year, I'll prepare a series of articles about SQL, so stay tuned for more awesome resources.
Yeah you're right, it's not required, I didn't mean to make that assumption. Though the reality is that a lot of file type detection uses only file name/ext.
For what it's worth, don't use Class cls = Class.forName("com.example.Demo"); Demo obj = (Demo) cls.newInstance(). There's several problems with this code. Firstly, `Class` is a generified class. You can avoid the cast if you use the generic parameter and call `asSubclass(Class&lt;T&gt;)` Class&lt;? extends Demo&gt; demoClass = Class.forName("com.example.DemoImpl").asSubclass(Demo.class); Demo demo = demoClass.newInstance(); But more importantly, don't use `Class.newInstance()`, because it hides several exceptions. It's been deprecated since Java 9. You should call `Class.getDeclaredConstructor().newInstance()`. You now have to handle three more exceptions. try { Class&lt;? extends Demo&gt; demoClass = Class.forName("com.example.DemoImpl").asSubclass(Demo.class); Demo demo = demoClass.getDeclaredConstructor().newInstance(); } catch (IllegalArgumentException | NoSuchMethodException, and InvocationTargetException | InstantiationException | ClassNotFoundException e) { throw new CustomException("Couldn't construct new object", e); } 
&gt; Please show me which one of those were open 10 years ago, are fundamental to any application, and they were never fixed. It took 14 years for adhoc queries to be added. So I guess we can't say it was "never fixed", but 14 yrs, come on! (can't find the jira right now). &gt; I are supposed to read the User Guide prior to using a framework, in which case this silly situation would be prevented. Exported as a PDF it is 553 pages long! Even if you could read the entire thing front to back without gouging out your eyes there is no way someone could remember every little thing in 553 pages. &gt; That will be changed in Hibernate ORM 6.0, so stay tuned! Here is a forum post from 2005 requesting this, 13 yrs! https://forum.hibernate.org/viewtopic.php?f=1&amp;t=944272 That forum post also demonstrates another plagued Hibernate in the beginning (don't know if it still does). However, when I was learning Hibernate in the 2005ish timeframe the developers, to put it bluntly, were total dicks. That community post demonstrates that (it is a tame version). The developers were totally dismissive of that posters suggestion and really rude (and now 13 yrs later sounds like it is finally being changed). That is how the forums were back then, the developers answer to every question was to read the entire 500 page user guide and get back to them when you had. And they were rude about it. Couldn't even be bothered to point out where in the user guide the information might be. They created a toxic environment in the forums. That put me off on Hibernate from the beginning. 
&gt; Let's just say that I fundamentally disagree with the entire approach that Hibernate has taken with ORM, and I will never rely on technology that does that much and tries to be that smart. I guess the critical thing is the surprise factor. This perfectly sums up my opinion of Hibernate 👍 
Well the difference in Java is that anonymous classes are an extension of (or implementation of) some other type, so the declaration can be of that type. In C++ that isn't always the case so there is sometimes nothing you can declare (other than using auto, the equivalent of var). &amp;#x200B;
Cool thanks - wasn't sure if the shift to functional style programming and reactive programming maybe changed best practices for doing some things. Lots to learn, not enough hours in the day, will get there eventually :) 
I was not aware of this myself, in fact. :) I don't remember when I last used `Collection.synchronizedList()`, as it seems quite useless. Just wanted to check the sources to see why there was no difference in performance when you use the `Iterator`, yet there was a huge difference when you use `size()` and `get()`
The Hibernate ORM team has 5 developers which need to: - develop new features - fix bugs - maintain multiple branches: 6.0, 5.4, 5.3, 5.2, 5.1 - update documentation - answer question on the forum and StackOverflow - go to conferences and give talks - etc So, some features will take longer because of lack of resources. In the end, this is an open-source project, so anyone can contribute if they need a feature that did not get the resources to be fixed. As for the forum, I think the [new forum](https://discourse.hibernate.org/) is a very useful resource, and the questions are answered in a professional manner. Take a look on it and convince yourself.
Thanks for the reply! Currently on my mobile, but will read this once I'm back home.
That performs worse in some cases.
Actually, yes. What even is JButton? A Swing [button](https://docs.oracle.com/javase/7/docs/api/javax/swing/JButton.html)? A JavaFX [button](https://docs.oracle.com/javase/8/javafx/api/javafx/scene/control/Button.html)? A CLI GUI button? A shirt button? What does the J stand for? Java? JavaFX? Is the class seemlessly interchangeable between Swing/JavaFX? If it's a Swing button, why isn't the class named "SwingButton"? Too much typing? If it's a JavaFX button then why not "JavaFXButton"? It would make the code much more readable and understandable. Did the person accidentally hit the J key when typing? /u/s888marks why the terrible class naming?
Can DM me too if you prefer to take it off of thread.
The difference is those events can be queued up and they can be for multiple connections. One thread can go through all the events for multiple NIO connections. That ends up having only the single scheduling penalty for waking up the thread vs 100's or thousands of those penalties. It is why a tomcat connector of BIO handling 100 connections is at the boarder of reason whereas tomcat with 10,000 connections under NIO hardly breaks a sweat.
I would tell this story to my junior developers if I knew how to pronounce Qc Na.
For those who speak English there is the **sidebar** (old reddit): + **Do not post tutorials here!** These should go in **/r/learnjava**. But save yourself the posting there as it won't be well received there either. The subreddits are **English only**. **Removed**
https://benjiweber.co.uk/blog/2018/03/03/representing-the-impractical-and-impossible-with-jdk-10-var/ Check out the Impossible Types section
I was hoping to find such a reply, thanks a lot for the detailed answer.
Thanks a lot for the methods and references.
Thank you.
Thank you.
Go away, Spring hired shill account
&gt; constructor API Is there any good read on this? My google fu is apparently weak.
seriously, groovy?? why :S at least kotlin would be my first choice.
Reflection is nice and all but please avoid it whenever possible. It's a performance hit for your application and any program be written without it. I'm not even going to mention all the smelly code that can be written with it... 
What do you think of this paper then: http://static.usenix.org/events/hotos03/tech/full_papers/vonbehren/vonbehren_html/ They claim that a well written lightweight thread library has the same (or more) performance than a NIO implementation.
Check out the javadoc for `Class.newInstance()` or my comment on this post.
I do hope so. I'm rewriting a large project these days and my main goal is no nulls and less exception throwing. I gotta say it's coming up nicely, but I do feel the language's fighting me now and then.
Although I am not currently using an application server, I am personally interested in information about Wildfly, Payara and Open Liberty.
I definitely could be wrong. What I would say is that the NIO route for performance is definitely easier to get wrong. Light weight threads do the right thing for you right out of the box. That being said, https://www.techempower.com/benchmarks/ Generally, Java makes a really strong showing for performance without light weight threads. Go, on the other hand, barely shows up (though it does take the number 3 slot, but then next comes in at 23). This may be due to Java optimizing better than the go compiler, it also might be due to other language constraints. Heck it could be due to a lack of interest in Go compared to java. Still, you'd expect maybe a little more competition. (For example, rust shows up quite a bit).
Nope I'm just a hobbyist I'm afraid! 
It is possible as they are eluded to. Buy what I love about the book is that it introduces you to concepts slowly bit by bit and I'd feel out of my depth trying to work it out for a few hours. 
Yes, you should make sure that the code fulfills the requirements. Why would you not do this? I mean, you can just eyeball it, you don't have to write tests. But if you see a case that's not handled, or the results don't seem to match the requirements, you should say something. The developer missing or misunderstanding the requirements is just as much an error as an error in the written code. The point of code review is to catch errors.
Yeah but I mean there are cases where you have like a medium sized feature. You cannot just "eyeball" it. You have to spend precious time on it, even to understand the feature itself and then check the code.
I don't see code review as the primary mechanism to ensure functionality. That comes the tests and demos. I use code reviews more as a critique of implementation. But any code review should always contain both the product code and the test code so I eyeball the tests to make sure they look complete. &amp;#x200B; If you ask me to review code without any test code, I'll probably reject it and ask you to write your tests.
That depends entirely on the nature of your team and what you hope to achieve by the code review. If you won't if you're doing it right unless you know what problem you're trying to solve. &amp;#x200B; For example you one team might want to focus on quality of unit tests whilst for another team need to focus on issues around multithreading. And what you look at is likely to change over time as you solve some issues and new issues arise. 
If that's a concern I'd think about addressing that through testing rather than code reviews, at least for happy-paths. For new features, we're experimenting with mobbing together to write the high level tests before we start coding so by the time we get to code reviews we've got confidence that the code works. So our code reviews don't focus on that. Our main focus is on doing we have a good set of lower level testing to test exception conditions, can we refactor without breaking test (eg is there too much mocking) and can I understand what a particular piece of code is doing. We've also got lint rules and formatting rules defined so that one less thing to review and argue about.
I typically review in several passes. 1) does it do what's required? 2) is it structurally sound, with sensible abstractions and bearing Single Responsibility in mind? 3) Is it clean and readable, making good use of available libraries and/or language constructs? 4) Is it accompanied by automated tests that can verify its continued operation as additional changes are piled on the system? 5) Is it efficient? Yes, you'll have to spend time on it. If someone submits a change set spread across two dozen files then it's going to be difficult to reason about, so encourage small reviews. For larger reviews, schedule a huddle or screen-share where the author can describe the scope and purpose of the changes, and then leave it to the reviewers to it. The important part here is communication. Reviews are not a substitute for picking up a phone or asking for some of the author's time to explain something, or a fellow reviewer's opinion on something that you think might be dubious. Don't feel that once a review appears in your inbox that you have to tackle it in isolation. Talk to people!
I'm not really sure what the guy is on about really. A brief look at his history makes it appear he's not a developer at all, although I only looked back a couple of pages.
TIL...
You can, but not in Java. Write a program for the ti-84 plus and deploy it to the calculator. You can find on google how to do this
TIL good class naming doesn't matter and JButton is a completely acceptable descriptive class name.
"If I see the words new Thread in your code again I'm gonna get mad"
You're asking is the git-flow model of code review. Formal code review is the coder preparing for review. The constraints are that the code should be small enough to go over in 1 hour (eyes tend to roll back in the head too much longer) and the reviewer(s) and the coder has to present the code so that the reviewers can "understand" what they are reviewing. The value of actual code review is that the reviewee, in preparing for the review and actually giving the explanations, finds all the mistakes and misunderstandings. You can actually do this with a rubber duck, the reviewer doesn't really matter, as long as you actually do prepare to do it and do it.
Not *quite* nothing. There's some stuff in static blocks in Container, but if you're depending on a line like that to do some necessary library loading, you better leave a comment. And an apology.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
When reviewing peers, I just see wether they adhere to clean code principles and our coding guideline. For juniors and... "special" colleagues, I tend to cross-check the requirements with the implementation.
Nope. You would first have to port the JRE to the Z-80, which is a tall order given that the processor doesn't support memory protection or threading.
As said by u/rarewonder, java is not compatible with TI calcualtors. Programming directly on the calculator in [TI basic](http://tibasicdev.wikidot.com/starter-kit) will be your best bet for just about any program you'd wish to create. &amp;#x200B;
You are reviewing for maintainability and correctness. So reviewing the functionality is surely part of reviewing for correctness. That is what most people will tell you anyway. In practice I have found code reviews to be nearly worthless. Just becomes a place to have your code nitpicked apart by someone who does something different than yourself but the code itself is still maintainable and correct. I am not sure I have ever had a bona fide bug found in my code during a code review. On the other hand I have been asked to rename things, replace enums with magic strings, replace caching with n+1 selects, etc. Let the downvotes rain down!
If it's in source-code repository I could suggest using 'number of commits' to identify build (given lack of changes in the source the binary should be exactly the same)
I don't think those features would be at all difficult compared to implementing the rest of the JVM - just interleave the threads like normal context switches and mark the memory pages appropriately with a read-only flag or with an owner? It goes without saying that this is obviously too much work to do, so the answer is no (or find a transpiler?) but my point is just academic.
I upvoted your message and have serious question - don't you want to change your job? For static code analysis (magic strings, n+1, etc) you have Sonar. For rename requests - there's either reason for it or you should reject such a request if it makes no sense. I personally found bugs multiple times, my colleagues found bugs in my code as well. Most of the times reviews let us share the knowledge, and ensure quality. 2 years ago my PRs used to have about 80 comments (98 is my personal record). I was new to tools I use at work. My colleagues did comment each incorrect change, explained it, suggested improvements. Now from time to time I have 2 approves in the same size PR wothout comment. Team has changed, people has changed, I have improved. Now other people seek my code reviews more than they used to. Code review is a great concept. It is meant to help team deliver and maintain codebase, exchange knowledge, discuss problems, spot things that are visible when are implemented. If code review doesn't work, I would blame team, not the concept.
Java is not efficient enough in terms of memory management. I would suggest looking into different languages which are also used in academics. There are some new kids on the block like Julia
Fair enough. That said, I challenge The Internet (tm) to write a TI calculator JVM bytecode interpreter.
I like to check test coverage, code quality, overall architecture and for obvious bugs. I tend not to harp on things that are too stylistic. But I will if it makes the code hard for me to read. Another big thing is security. It's not a big issue on our app in general. But if you have some customer facing webpage it matters more. Even I found a PR with a hardcoded username/database password in the properties file -_-. I rejected it and told him to change his password xD Things like protected queries and make sure script tags don't execute in your text fields. ;)
The new operator it's the way to create new objects from a class, using its constructor. You can also create a static "create" method or use the factory pattern if the constructor API is not enough. Class.forName is part of the reflection API and it should be avoided unless it's really necessary, because it's not performant and it can break the business model. But it allows you to instance objects at run-time without knowing the class name at compile-time. This functionality has specific use cases such as framework development.
Are static inner classes useless? 
Yeah pretty much
What had you confused?
This is why everyone should use mocking frameworks and do actual unit tests on logic not de facto integration tests. $0.02.
True, study materials are very helpful while taking a test.
Yes, that analogy seems fine. I use static inner classes all the time: enums, builders, generators, multiple concrete implementations of interfaces, etc.
If it hasn’t been done yet, it’s impossible.
Are you using CI/CD to build/deploy your app?
Things I have pointed out in code reviews this week: Hey, the way you did this shows you didn’t know about this language feature and it might have made things easier. This test case doesn’t actually test what you think it does. This isn’t the way we normally do this. You left a bad commit in the commit history. You’ve never seen anything like that? 
Yep, see the test pyramid.
Integration tests? Isn't that what prod is for? /s
You're complaining about not liking the name `JButton`. This has nothing to do with `var` and therefore nothing to do with the conversation.
Well, you're not wrong. Of course, emulating threading and protection in software is somewhat of a daunting task. Also, given that the Z80 only has 16 address lines, you would have to implement bank switching on top of everything else. At this point, it sounds like an assignment that Beelzebub would hand to a programmer upon arrival in the seventh circle of hell.
Are you kidding me? Gradle is heaps better than Maven if you just want convention, and easily customizable if you need to slightly diverge from convention.
The only problem is when gson returns `"null"` on a class defined within a method.
I don't use gson. Have you tried contacting Google, its creator?
I’ve used them to declare internal classes, such as iterator implementations. Just because they aren’t used all the time doesn’t mean they are totally useless.
See that's what I mean. I guess I should have said they have no unique use case. Something like an iterator I will have in the package in its own class, as it will likely be shared by other implementations in the package. My big thing is the downside is...much longer classes for the very dubious benefit of a stronger coupling between two classes. Also it makes it super annoying to reuse that iterator impl in another implementation of whatever collection. An iterator for example has at least 6-7 methods for a simple one. That's quite a bit of additional code if I'm writing an actual implementation into my inner class. 
....what class is a builder an inner class of? Please tell me it's not the class of object the builder is building. 
If other classes need to use a particular class, I agree that it would make sense to declare it in a separate file. There really isn’t anything wrong with declaring the class in a separate file anyway. It just seems to depend on style and situation.
It looks like in your [submission](https://www.reddit.com/r/java/comments/a1291p/java_help/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
There’s a program someone made that lets you upload notes to your ti 84 plus ce. It’s on YouTube if you search for it
The first thing I look for is test cases. Do they match the acceptance criteria for the story. Are they laid out clearly so I can tell the purpose of the code by reading the tests. Next up is a check for clean code. The metric I use is, "could I fix a bug in this code if I was paged at 3am." Luckily my current job doesn't require me to carry a paper, but I still find it to be a good metric to follow. Often I'm reviewing code written by a different team, where they're making changes to the code that I'm a subject matter expert on. I want to check that it's clear from the code that they understand what's going on, and that their code fits the domain model. These will often be junior devs, so I keep my eyes open for things they've missed, or best practises that they're not aware of. When reviewing code written by members of my team I don't have to pay nearly as much attention, since they're all familiar with the domain. Here I tend to focus more on things they may have missed, possible edge cases that weren't caught be tests, etc... We like to hold ourselves to a fairly high standard so will often point out possible different ways to solve problems. Nothing that needs to be fixed as part of the review, but a good way to identify team best practises going forward. Overall I find reviews to be a great learning tool. They're a great way to learn new tools and techniques, and help to disseminate best practices throughout the company.
&gt; For larger reviews, schedule a huddle or screen-share where the author can describe the scope and purpose of the changes, and then leave it to the reviewers to it. IMO these things should be done in writing as a part of the review request. Then a year from now when the code is being maintained by a different set of people and they figure out that a bug slipped by the reviewers and was introduced by the change in question, they don't have to track down the original author and ask for another live presentation on what the change was all about; it'll be right there in the commit message. Having everything in writing is also a huge boon if the team is distributed across time zones. Is it time-consuming? A bit, but not extremely, in my experience. Often it's faster to write up a thorough description than to wait for all the reviewers to be available at the same time. And if a change is huge and complex, there will ideally already be a product spec or design document to describe it at a high level, and the reviewers can familiarize themselves with that before even looking at the code. To be clear, I'm not saying real-time interaction with the author should never happen during code reviews. Obviously that can be far more efficient sometimes. But biasing toward reviewing in writing has some pretty compelling advantages for a long-lived project, at least in my experience.
The very few engineers I know who work in corners of bioinformatics use Java and Scala. I'm sure there is a spectrum between languages people are prototyping in versus using in production. I'm personally most interested in where the existing momentum is, rather than what the best language for the job is.
Years ago I was lead engineer of the automated test tools team at a tech company you've probably heard of. I actively discouraged people from treating high code coverage numbers as a target metric for exactly that reason: I observed that teams that prioritized coverage and rewarded developers for high coverage numbers tended to accumulate large numbers of not-very-useful, brittle tests, and had a higher incidence of tests that verified incorrect behavior because it's what the code did and the code needed to have a set of passing tests with high coverage. Coverage isn't a worthless measurement by any means, but by itself it doesn't tell you much about what value you're getting out of your test suites.
You wouldn't mind writing about that in r/javaTIL, would you?
Nah, your best bet would be to transpire somehow to the ASM language that TI-84 supported. It was possible to sideload applications from a computer. They could also be precompiled. This is how Super Mario World and Phoenix I/II ran so fast.
If by DAO you mean a single god object that does all DB work, no. Recently I wrote a micro service that used raw JDBC for performance reasons. The service pulled basically populated an in-memory cache (GemFire) as fast as possible by pulling all data in a table, and then pulling deltas. I would’ve much rather implemented a Kafka stream but alas, the other team involved thought that was too much work. Anyways. JPA/Hibernate were much too slow for what I needed. I wrote a loop that used a raw cursor to pull data ridiculously fast. This way, I was able to saturate my local network, which was surprising low at 1Gbps.
If you’re really committed, you could give this a try: https://github.com/raydac/j2z80 From the author: “It is a maven plugin developed for academical purposes, the plugin allows to translate compiled JVM byte codes into Z80 instructions. It works as a pattern compiler with minimal optimization. Warning! It is not a JVM interpreter because it generates low-level native code for Z80. It doesn't contain any GC!” Good luck, let me know if you can get it to work 
First pass, read the interface and see if you can understand what each method does without seeing the implementation. If you can, then spot check the unit tests to verify 'functionality'. Then read the implementation, ensure compliance with code standards, look for duplicate code in the class, check variable names, and make sure non-trivial code that takes more than one reading is properly commented.
I didn't use to use DAOs. I just dropped the result of my queries into a resultset, and use that to instantiate domain objects. My applications mostly lack the CRUD architecture one finds with DAOs and JPOs. When I find a need to update anything, it usually is not the data I had my application read, but something related to it. So I either use raw SQL or at best invoke a stored procedure. I studied various existing persistence architectures and frameworks for Java. I found most of them tedious, overly complex, or requiring too much implementation compared to my needs. These days I use half-DAOs: generators that proxy between the data resultset and the read-only domain object. I can do that because most of my applications don't write back to the same data records. Those half-DAOs follow shared behavior via an interface, that is limited to my applications' needs. I'm about to collect them into a reusable library to avoid code duplication. 
Are you sure? Doesn't the Function class make Function instances first-class citizens? They can be created, instanced, passed around as arguments, composed, and yes, even curried (or at least half-applied). Yes, Function instances can be declared outside of classes. They can be declared in interfaces. But that's about the extent of Java's willingness to forego its "everything is an encapsulating object" concept.
I don't understand analogies like that at all. Static inner class is fundamentally just a class with a funny name, e.g. Foo$Bar. You write Foo.Bar but that's just because java recognizes the reference to the inner class and pretends very hard that there is a genuine relationship between them. However, you might just as well have the static inner class in a separate file altogether. Static inner classes are useful for declaring multiple public classes or interfaces in a single file, something that Java normally disallows. This can be useful for declaring things like callback interfaces and enums that are relevant only for that one particular class, so you can keep them all nice and tight together if you care about such a thing.
I think that depends on what you consider your resposibility, or better, what you would like your responsibility to be. Do you want to be able to maintain any subsystem with ease? Perhaps just one subsystem? Do you not care if your time is spent fixing bugs caused by poor design, and low code quality from your team mates? Or do you want to be responsible for the quality of the overall product and be someone who's word means something and gives confidence to your higher ups? Knowing your goals should drive your priorities in code review. They will guide what you focus on, but in general, yes absolutely you should be looking for bugs during code review. My approach is a bit more rigorous and in the weeds than others here would prefer, I imagine, and I also don't get the benefit of making people write unit tests to help me understand their changes, so keep that in mind. I absolutely wish I could just tell people to write tests, but I'm not the boss. :) 1. **Assess whether the change set solves the problem specified in the ticket**. This can involve building and testing empirically. Basically, see if anything got lost in translation. This is absolutely the first thing you should do before diving into the code. 2. **Familiarize yourself with the general layout of the changes.** 3. **Determine any areas that are scary, and try to understand what the author is trying to do**. Unexpected complexity often means the author is accounting for an edge case you hadn't considered. But it can be a number of things. Taking a moment to try to understand what the author is doing before asking them better prepares you to talk to them about their change. Make comments in the PR to confirm your understanding with the author. This is also a great time to ask for specific documentation. At this point, if they passed part 1, you should not have tried to make any meaningful criticisms, yet. Now that you have a 60-80% understanding of the change set compared to the author, there are lots of options available: 1. **Attempt to find bugs based on issues and smells you noticed in the code**. Report the bug, and say what lead you to it. This educates people, and makes them more likely to listen to you when you say something is a smell with no corresponding "bug". 2. **Critique the salient issues**. Filter out all the nitty gritty stuff, and identify issues that are the most problematic. Then discuss them. What is most salient is informed by your priorities. Does the change harm your ability to maintain this system, or integrate some feature? Is something prone to break with future maintenance due to some gotcha? 3. **Comment on something you like and would like to see more of**. This is such a painfully neglected type of feedback. It is very important that when people are doing something right, you don't let them un-train themselves. Letting them know that good work done without fanfare is not unnoticed. That is invaluable. And goes without saying, it generally makes people happier which is an end in itself. Always give generalizable feedback, i.e. don't go off of whims. Never ask someone to change something unless you can tell them why and when they should apply your rule. Often rules, like style rules can either be documented in a wiki or enforced with linters and static code analyzers. Obviously the latter is preferable when possible. Last, **if time permits**, give "clean code" feedback. Stuff that doesn't matter for functionality / performance, but makes the code less intimidating to look at and more respectable.
I'm not his friend, but I can confirm that in C++ this is the only way to store a lambda value auto add_one = [](int a){return a+1;}; print(add_one(5)); //prints 6 yeah, our lambdas aren't as pretty as yours
Is the thin EAR support still missing in Gradle 5.0?
 This is what I check during code review : 1. Does the code align completely with the business functionality ? 2. Can the code cause unintentional side effects (from a business domain point of view) ? 3. Can some parts of the code be replaced by standard libraries like Apache Commons or Google Guava ? 4. Is it possible to minimize the memory footprint ? 5. Is the code readable ? Are the variable names, method names and class names meaningful and indicative of their functionalities? 6. Is the code well equipped to handle concurrency ? Are the Date and Number formatter instances defined in a thread local context ? Is every critical section guarded by a lock ? 7. Are there enough unit tests ? Ideally I'd want every public method to have one corresponding unit test 8. Are there a few integration tests ? 
When I write it myself, it's static. It builds instances of its outer class. The built instances don't have builder instances. When Lombok generates it, it has the option of adding a toBuilder() method to an outer class, which prepopulates a builder instance of its inner builder class. Whether that inner builder class is static or not, I haven't bothered to research. 
spring jdbc template is great, I think its so much better than ORM. Especialyl namedparametertemplate.
I have implemented a class called CRUD that serves as a simplistic ORM. My preferred style for a database hosted domain object is a naked struct, no methods on it whatsoever, just public members that exactly correspond with columns in database class. Here are some API examples, these would literally work assuming a class Foo with fields Long id and Integer xyz: Create object; Foo foo = new Foo(); foo.xyz = 5; CRUD.persist(handle, foo); // does INSERT INTO foo (xyz) values (?), gets the ID, updates foo.id Update object: // does SELECT * FROM foo WHERE id = ? foo = CRUD.select(handle, Foo.class, foo.id); foo.xyz = 6; // does UPDATE foo SET xyz = ? WHERE id = ? CRUD.persist(handle, foo); Delete object: // does DELETE FROM foo WHERE id = ? CRUD.delete(handle, foo); The implementation of CRUD basically uses reflection to scan the object, identifies the ID column from annotation, treats all the rest as regular columns, and finally generates the relevant SQL statements. persist() is has a little bit intelligence in that it determines whether to update or insert based on the contents of the ID field: If the value is null, issue insert, collect value assigned by DB to the ID field. Because the CRUD must read all the fields and write all the fields at once, I use SERIALIZABLE transactions to avoid lost update issues, e.g. the sequence of select-modify-update can race with other transactions attempting the same thing. Commit failures require that any code executing a transaction needs to potentially be attempted multiple times, so the code within transaction should always be side-effect free and as short in duration as possible. My code actually doesn't quite run on top of raw JDBC, but it's fairly close. I use a library called JDBI that provides all the mapping capabilities between ResultSet and my objects. Those mappings, however, wouldn't be too difficult to write yourself, if you want to. JDBI also has an approach for DAOs where you can declare SQL statements into an interface with annotations like @SqlQuery, and JDBI generates usable class at runtime from the definition with support for binding variables to placeholders in the query. That kind of stuff helps avoid mixing raw SQL into your program. Still, I find that reporting-type workloads and some API calls typically have no single canned statement to execute, and then you need to construct the SQL statement text from scratch. For all such statements, you'd use placeholders with a :fooId type syntax to avoid SQL injection.
Frankly, I think it's a matter of figuring out which gates you are really trying to keep, and go from there. I'm not saying don't try to protect all gates, but this is a very good case where it is helpful for individuals to specialize. Implementations often have signals and code smells, but in the workplace there are usually intermediate steps between initial and "good" implementation. On the other hand, if you are trying to focus on business logic then you probably need to spend more effort on implementation correctness and verifying that the tests are a reasonable measure of implementation accuracy--a bad but correct implementation can often still be refactored. 
Then you're lucky. It gives them wet dreams download a driver developed by some professor at Oxford. I've seen some interesting R shiny stuff. In my opinion, what a lot of scientists don't get is SLDC and managing code across developers. Not all but some.
I'm using Spring JDBC Templates. The code structure is pretty much the same as for classic JPA, but you need to implement the repositories by yourself. Next to each repository I've got a RowMapper class. For more complex queries I've created an additional layser of "query"-services that prepare the SQL statements that's then send to the respository-methods.
Mybatis is a neat tool
Recently migrated our applications from Spring JPA to JDBI and loving it so far. The docs are pretty straightforward: http://jdbi.org
Why not re-write it for the ti? Generally programming skills, especially the basic ones are pretty much transferable to anything else, with some exceptions. It shouldn't be hard for you to get your mind around a different language. When I was starting out moving from one thing to the other seemed daunting and scary, but it all just comes down to the right tool for the right job.
That's not the point. Node's gulp.js or Ruby's Rake let you do everything too, but they are not an entangled mess like Gradle.
 The new operator create a new object while we can use newInstance() method to create object if we do not know class name at the beginning and it is available dynamically at runtime .New operator is used to create objects, but if we want to decide type of object to be created at runtime, there is no way we can use new operator. In this case, we have to use newInstance() method. 
just look Wicket is great library for that : https://wicket.apache.org/
If you are not going to use ORMs, please check jOOQ. It is amazing
I would suggest you guys for start to include Sonar in your CI process (maybe you have it already?) and force each dev to use it. This way CR won't be focused on static code analysis, as there is a tool for that. Also it's always ok to ask questions, leave general wonderings etc. I personally multiple times leave up to 5 minor remarks and approved the change. Why? Because not everything has to be my way, not each developer is willing to change his work and not always spotted places to improve have to be in scope of reviewed change. Often when someone moves files, refactors packages, etc. some issues are spotted in code that was moved only. It's fine for me to either fix such a code in current PR, or to cover it in other one, but such an issue can't disapear. It has to either be fixed or logged as separate issue. 
Haha yeah. What language will I be writing in today...
lol &gt;Laziness can be a useful tool for improving performance, but more often than not it reduces performance by adding a constant overhead to everything https://wiki.haskell.org/Performance/Strictness
I really don't get your comment. Kafka streams are between topics, from the way I worked with them, and they are mostly a consumer and producer that are hidden and allow you to manipulate and route the data between the consuming and producing. For database inserts you'd require a connector, most likely a jdbc connector, to be your sink. That is not streams, afaik. It's just a configuration over code way of doing things. Unless I'm missing something. And on a sidenote, using streams and sinks saves so much transactional synchronization between commits on db and on the topic, that for your last statement of 'too much work'. Are they crazy? It works like magic, it is performant and has almost zero implementation.
They are absolutely different. Primary use case for JDBI is to use static SQL queries, literal queries which you can copy and execute in any SQL console, effortlessly. And it does that brilliantly.
I've used jOOQ and can recommend it. Once the code generator is set up, writing SQL queries is a breeze. Even resolving m-to-n joins is easy thanks to the jOOQ API.
I'm referring to Mark's claim that: var x = getSomething(); is bad because x and getSomething are meaningless(not descriptive enough) in his var presentation. If you are going to argue this, then the variable name "button" and the classname "JButton" are also bad as neither are descriptive enough. Again, is JButton a Swing button, JavaFX button, or a shirt button dipped in a cup of Java? We don't know. Of course supposedly bad class naming can be bad regardless of your use of var, however, if the JDK developers themselves can't do good class naming back then with Swing or now with JavaFX then how do they expect anyone else to do it?
I meant as the reviewer. The reviewer doesn’t write new tests to verify functionality. The original developer writes the tests. Though maybe having the reviewer write new tests would have some benefits.
Eh?
Test coverage is by far the most important to me. Then also making sure silly mistakes are not being made that could become a performance bottleneck e.g. bad loops. Also, I make sure there's not too much going on in a function e.g. side effects. Also that functions have a single responsibility that can be easily validated outside the realm of the full program
unless you literally want to copy and paste a query, you can do that with jOOQ too. You can create the query once using jOOQ methods, generate the sql string and use it. The main reason to not use jOOQ is when you have to write object graphs or when you use a privative database
Is it bad that everything you're telling me makes me want to attempt to implement a Z80 emulator?
Being able to change the db is a great feature of jOOQ, but it is not the main one. I don't know any other library that gives you all the power/expresiveness of SQL without losing the typesafe and syntax from your programming language (java, kotlin, scala...). And its creator, u/lukaseder, is always eager to help
Real world experience speaks through you
&gt;I am not sure I have ever had a bona fide bug found in my code during a code review. On the other hand I have been asked to rename things, replace enums with magic strings, replace caching with n+1 selects, etc. Do you find the same when you review other people?
test coverage -&gt; clean readable code -&gt; stupid inefficiency aside from that, they can do as they like
[You know how to call me](https://twitter.com/lukaseder/status/1067716131622924288)
Not OP, but from my experience “too much work” usually means “we have no idea what that even is, let alone how to use it”
I have no idea how its meant to be pronounced, its ancient copy pasta. You could either invent your own pronunciation or just change the name 
No, that's completely normal. Those are called [Intrusive thoughts](https://en.wikipedia.org/wiki/Intrusive\_thought): &gt; Many people experience the type of bad or unwanted thoughts that people with more troubling intrusive thoughts have, but most people can dismiss these thoughts. For most people, intrusive thoughts are a "fleeting annoyance". Psychologist Stanley Rachman presented a questionnaire to healthy college students and found that virtually all said they had these thoughts from time to time, including thoughts of sexual violence, sexual punishment, "unnatural" sex acts, painful sexual practices, blasphemous or obscene images, thoughts of harming elderly people or someone close to them, violence against animals or towards children, implementing JVM emulators for non-standard processor architectures, and impulsive or abusive outbursts or utterances. Such bad thoughts are universal among humans, and have "almost certainly always been a part of the human condition". 
**Intrusive thought** An intrusive thought is an unwelcome involuntary thought, image, or unpleasant idea that may become an obsession, is upsetting or distressing, and can feel difficult to manage or eliminate. When such thoughts are associated with obsessive-compulsive disorder (OCD), depression, body dysmorphic disorder (BDD), and sometimes attention-deficit hyperactivity disorder (ADHD), the thoughts may become paralyzing, anxiety-provoking, or persistent. Intrusive thoughts may also be associated with episodic memory, unwanted worries or memories from OCD, posttraumatic stress disorder, other anxiety disorders, eating disorders, or psychosis. Intrusive thoughts, urges, and images are of inappropriate things at inappropriate times, and generally have aggressive, sexual, or blasphemous themes. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Your commit message and code comments should be enough to understand the why. Relying on your central repository pull request discussion sounds less than ideal. Imagine if you move from github to gitlab.
But you can measure the quality of the tests with mutation testing.
Whatever the variables being passed from the jenkins $(varname) &amp;#x200B; you can use this $(varname) in your ant script
i need a class for about two lines: one to initulize it and one to pass it to json. I could do it in one line.
Oh man mybatis sure can be useful sometimes.
Agreed, and I phrased it poorly in my comment. I favor a system like [Phabricator](https://phabricator.org) for code review; it automatically updates the actual commit message that gets pushed to the central repository to include the summary and test plan from the review request. So you don't get the *discussion* per se in the commit message, but the commit message and the reviewer-approved change description in the review request are one and the same.
The unit test written for the function should be the "fulfilment" test. IMHO, a set of working unit tests are a pre-requisite for code-review.
could you develop that? I've always struggle to see the benefits a mybatis compare to other jdbc wrapper framework. and the sql in xml just freaks me out.
Good to know! I’ve been meaning to look at their implementation. Thanks!
This one has a lot of material: [https://www.amazon.com/Java-Enterprise-1-4-J2EE-Bible/dp/0764539663/](https://www.amazon.com/Java-Enterprise-1-4-J2EE-Bible/dp/0764539663/ref=sr_1_1?ie=UTF8&amp;qid=1543408353&amp;sr=8-1&amp;keywords=j2ee+bible) This one too: [https://www.amazon.com/Enterprise-JavaBeans-Fourth-Richard-Monson-Haefel/dp/059600530X](https://www.amazon.com/Enterprise-JavaBeans-Fourth-Richard-Monson-Haefel/dp/059600530X) &amp;#x200B; &amp;#x200B;
Looks similar to OrmLite and many others
was curious because it's from Brett Wooldridge
Don't blur the lines between reviewing code and doing UAT. I review code mainly. If there is unit testing on the project I'll review test results and coverage and whether the patch runs. The rest is left to QA and integration/regression tests, which are much more efficient than I am at testing functionality.
What’s with the downvotes? 
I use Mybatis (a SQL mapper). It basically allows you to keep your SQL in XML template files and you have to write it yourself, but it takes care of mundane tasks: i.e. mapping results into POJOs, dynamic sql, etc. In the past I used Spring JDBC templates and I was pretty happy with them as well. 
&gt;and the sql in xml just freaks me out. Can you elaborate on why? BTW, the latest Mybatis (as in built in the last 10 years) allows you to write SQL in annotations a la JPA. 
I don't find annotation much better to be honest. when I use jdbc I just inline my sql in the method or close to the point of use, easier to see what's happening. I don't see the benefit of having it outside the code that will use it.
You just interleave your business logic with mysql queries. Did I mention I love my job?
I am too, but the original poster specifically asked "raw" and not ORMs.
Are you asking because of license issues? Otherwise, I really wouldn't recommend anyone use raw anymore. There are just too many potential security issues that you have to code defensively against. It's just easier to fire up gradle and include jOOQ. Now if you're worried about learning the jOOQ DSL ... you should know that you can still use raw SQL and it's still better than rolling your own or writing raw. 
As a side note, [Nest-Based Access Control](https://openjdk.java.net/jeps/181) was added in Java 11. It allows classes in a nest, such as an outer and inner class, to access each other’s `private` fields without bridge methods.
r/learnprogramming please 
I usually go with "In a corporate office building (public class) the inner classes would be individual departments with people in that department who sit at desks in that department with computers owned by that department". &amp;#x200B;
I like to use static inner classes when I’m serializing data over a an api. Like nobody will ever consume the class directly, it’s just being used as a method to shape data for Jackson. I like it because it’s tightly coupled to the controller/resource class as it should be.
Why? Sounds like dogmatic nonsense to me.
...do you really expect to just read a book and know it? Typing it and reading it are completely different. You asked a question, I answered it and now you're trying to put my encouragement down? :D I answered the question, that's encouraging enough. 
Here you go: https://en.wikipedia.org/wiki/Goodhart%27s_law
&gt; The first thing I look for is test cases. Do they match the acceptance criteria for the story There is no way unit tests will match the acceptance criteria. It think you are confusing unit tests with integration tests. 
BeanPropertyRowMapper is very poor from a performance perspective. I would recommend using [https://serkan-ozal.github.io/spring-jdbc-roma/](https://serkan-ozal.github.io/spring-jdbc-roma/) or [https://simpleflatmapper.org/0104-getting-started-springjdbc.html](https://simpleflatmapper.org/0104-getting-started-springjdbc.html) for generic row mappers. and sfm can also map your x-to-many.
I am just talking about our stack at work :) Java, c, python, Perl, bash, ruby, JavaScript, typescript, Pascal, Pascal, html, scss. One truly never knows what langue he will use when he gets to work...
This is just an implementation detail, isn't it? It doesn't affect the language at all.
Oooh, I just remembered, `Map.Entry` :)
Correct. It will help those working with the VM.
Rewrite it on BASIC
Also, perhaps you can try this : [https://github.com/raydac/j2z80](https://github.com/raydac/j2z80)[https://github.com/raydac/j2z80](https://github.com/raydac/j2z80)
Not quite a JVM but there is [this](https://github.com/raydac/j2z80).
And the internet be like: https://github.com/raydac/j2z80
Yeah, unfortunately, Spring Boot CLI only supports Groovy. Here's a Kotlin version: package com.example.demo import org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.boot.runApplication import org.springframework.security.access.prepost.PreAuthorize import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity import org.springframework.web.bind.annotation.GetMapping import org.springframework.web.bind.annotation.RestController import java.security.Principal @SpringBootApplication @EnableGlobalMethodSecurity(prePostEnabled = true) class DemoApplication fun main(args: Array&lt;String&gt;) { runApplication&lt;DemoApplication&gt;(*args) } @RestController class HomeController { @GetMapping("/") fun home(user: Principal): String { println(user) return "Hello ${user.name}" } @GetMapping("/admin") @PreAuthorize("hasAuthority('ROLE_ADMIN')") fun admin(user: Principal): String { return "Hello, ${user.name}. Would you like to play a game?" } }
Hi, (disclaimer: I'm a java noob) I find this very pretty, and would like to see the code behind this, could you post it on github or something ? Thank you.
No, they're useful for encapsulating implementation details. The best example is [`Map.Entry`](http://hg.openjdk.java.net/jdk/jdk/file/19b15ff2576b/src/java.base/share/classes/java/util/Map.java#l406), which is an inner interface in the `Map` interface. `HashMap` returns `Map.EntrySet` for `Map.entrySet()`, and each individual entry is a `HashMap.Node` object. But you don't need to know these implementation details. Nothing outside of `HashMap` needs to know about them, not even other classes in `java.util`.
The benefit is that the SQL becomes config rather than code. Config is easier to change. 
but sql is code. Now, I understand that in some company there is that artificial boundary between config change and code change, and passing sql as config can make one's life easier. 
Friends don't let friends write authentication. :)
Understood. I don't necessarily subscribe to the sentiment, but I definitely understand it. 
Hey, good question! I have somewhat of a different perspective from most people. I really dislike most of the major frameworks b/c they feel big and bloated. However, just using raw JDBC is pretty dirty - just to do a simple DB query you have to catch all kinds of checked exceptions. I created a little wrapper around JDBC which cleans it up. It only contains 3 java files - it is incredibly light-weight and easy to use. [https://github.com/mirraj2/EZDB](https://github.com/mirraj2/EZDB) &amp;#x200B; Then, to organize my code, I have a package called "models" which contains java classes like "User", "Session", etc. I have a package called "db" which contains a matching DB class for each model I want to store in a table. So, "UserDB", "SessionDB", etc. It is up to each of those DB classes to contain the logic which uses the EZDB library to query the database. &amp;#x200B; I can go into more detail if you're interested. I really have loved doing it this way and have found a lot of success using this approach to develop quickly.
Thank you for trying your best to help. I'm afraid you are confused though. 
I usually pull down locally and actually run the tests. Amazing how many simple mistakes that catches. Then I look at the PR, try to find some key pieces of logic and either comment then out or flip it (change = to != or &gt; to &lt; for instance). If some test doesn't fail, I'll reject the PR.
&gt;For this project I'm only planning on using raw JDBC, but JOOQ is a paid library, no? &amp;#x200B; You only have to pay for jooq if you're using a proprietary db (e.g. Oracle). Open-source DB support is free (in both senses).
Why are you posting the same thing all over reddit? Why are you not disclosing (here) that the top link is your website? 
because it's the best ide
This is a good, brief summary for some of the more interesting enhancements. Thanks maciejwalkowiak!
I assume that the code fulfills functionality. If there are edge cases in the functionality that I can think of, I ask about them. Other things that I look for that you didn't mention are code duplication and optimizations. 
Thanks; the "start your free trial" button on their homepage does not imply that using the project for open-source dbs (the majority usecase?) is free.
Can you describe your 'half-DAOs' more? Are you creating classes like &lt;EntityName&gt;DB that map from ResultSet to domain objects? 
Thanks; do you use static or instance methods on these classes? And why not just make static methods on the domain objects themselves?