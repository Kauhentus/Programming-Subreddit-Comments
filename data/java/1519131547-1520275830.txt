I tried using WildFly Swarm recently to try to learn Java EE without having to setup an app server that I'd soon forget about. Whatever manifest file specifies which versions of jars to load from the m2 cache did not match the actual versions in the cache, and thus would not run because it could not find several dependencies. After manually repackaging all of the unmatched dependencies, my code didn't work (not surprisingly since it was my first attempt), and I realized I didn't want to rebuild the jar manually every iteration and just gave up. Maybe it's my fault for using Gradle instead of Maven, which Wildfly Swarm clearly prefers.
&gt; Your 'swapping' requires a build too. No, clearly it doesn't. That's kind of the whole point. &gt; Unless you don't test after a change. All of our components have been thoroughly tested *before*, so of course we don't need to test after the change. The whole point of "dependency injection" was supposed to be to allow you to code to an interface, and then use different implementations of the interface at *runtime*. By moving to annotations, all of that is lost, because in order to switch implementations you have to recompile. All @Autowired really buys you is not having to pass around so many parameters. Which is nice, don't get me wrong, but it isn't really the spirit of DI.
Ok, that's one I didn't know about. I'll look into it.
There's the documentation from oracle for that which is goos
I agree. I have the license version of IntelliJ but Netbeans works faster and is just easier to use.
That's not a case against `var`, it's a case against programming. People who misuse something should not be allowed to use it. People who can't drive cars, don't get a licence. Good peer review is critical, every time someone abuses the language, shout "thou shalt not pass!"
Why not just do this? There is no need for redundancy. Map&lt;Character,String&gt; fullCharNames = new HashMap(); 
You can also do this using an @Configuration class and configurations or using things like Spring Profiles. 
The XML configuration could be loaded from a local directory instead of the class path. 
But we override stuff in our config too, from the application.yml files. That really has nothing to do with whether you use XML or Annotation based DI configuration. Sounds kinda like you're abusing the DI XML for environment configs. 
Right on! Just wanted to add a few more frameworks that someone should "know the names of" if they are a Java developer. Frameworks: Start with Spring Boot, maybe consider Vertx or Dropwizard as well Persistance: Straight JDBC, JooQ, MyBatis, and Hibernate/Spring Data are all great options, each at varying levels of abstraction. Spring also has integrations for each that make it very easy to use. Build System: Gradle or Maven are the most popular by far. Ant is still used in some old projects. Common utility libraries to check out: Apache Commons, Google Guava, Project Lombok, RxJava Common Message Queues used with Java: ActiveMQ, RabbitMQ Unit Testing: JUnit is by far the most popular
Don't start with specific libraries/frameworks, specially not the bloated Spring ****(flavor). Learn to do the basics in Java. Test out eclipse, intellij, netbeans, ... and find out what you like. Read up on java organizing, packaging, and deploying. Try out jdbc before you test out the various data abstract libs. Try to solve problems in java that you frequently solved in .NET. 
Spring Boot is pretty much the future for Spring, not Java. 
That’s a good clarification, thanks! I got distracted with the OP focusing around the Spring side of Java (they appear to be webdev focused and targeting Spring). As a result I missed the root question of the General java ecosystem, which may be useful for others popping in here with a similar question.
I agree, examples you gave are very simple, and knowing that most people name variables with their asses, I can see how it can become difficult to read code where they use `ps` or worse, `personList` which simply embeds type information in the name, if we are lucky!
Yeah. But like I said; with or without List&lt;Person&gt;, a variable name like `ps` is just bad, lazy programming. 
Unless I'm missing something, the site seems to be an advert for buying the PDF, and is devoid of any useful content. Also the formatting is dreadful, not very promising for a site on markup-based UI development...
Sorry about the very long wait, I looked at the articles, and they do not quite cover what I sought; they are more aimed at JVM/compiler writers and experts, and the first of them directly recommends "Java: Concurrency in Practice" for regular developers. But they are still valuable, so thank you either way.
is no one using XMPP? 
&gt;their current framework WPF is painful compared to JavaFX which is the best, most modern UI framework available today. It's cleaner than Android in terms of not being opinionated, I agree, but also slower than Android(for whatever reason). But having not tried WPF, I'm not sure why it is better than it. Care to elaborate?
What's the speedup like relative to the Java 9 G1? Is the full pause time reduced linearly with available cores?
&gt; The whole point of "dependency injection" was supposed to be to allow you to code to an interface, and then use different implementations of the interface at runtime. No, that is the Strategy pattern. Implementing the strategy pattern is most certainly not the whole point of dependency injection. 
This greatly helps to debug a scenario on the fly. I will give it a try :-) Thanks for sharing!
I have specifically approved that post based on OP's inquiry.
Having done quite a bit of typescript recently, the implicit typing works very nicely. Sometimes types aren't clear and you want to add an explicit type it's not an issue.
I couldn't agree more. It's all about finding a way to define what you want to learn in terms that an algorithm will understand, which is almost necessarily narrow. Deep learning algorithms are like a crowd of savants, an auditorium full of Rainman. They each know one or two things really well and fumble the rest. What are the use cases you're considering?
Parsing of formatted government documents. There is a standard people are supposed to follow but people are people and the document store spans a century. There are a bunch of prebound rules and assumptions that can be used as starting points rather than go the route of a completely self-taught system.
Interesting. What are you using? I would imagine something like doc2vec + classifier alongside some rules...
Just starting to look into it this year, we will likely be leveraging frameworks for the rulesets and try to get as close as we can. The learning part comes for when people get creative with data in the documents usually due to advances in technology. I need something that can identify patterns of formatting and make a best guess crack at breaking the data up. Usually there will be multiple documents with different authors using a new data format so there is some learning that can be done in concert with hand guidance and rules.
The only problem is that SLF4J doesn't support lambda logging, such as `LOGGER.trace(() -&gt; expensiveMethod())`
I think a maven is some sort of female fox and in that case it's pronounced may-ven as in haven or shaven.
Task hell? With Maven there's a plugin for most things, for Gradle everything has to be a custom task.
Yeah currently it's a little slower but that should improve over time with the AOT compiler. WPF is a little older and it shows. It's exceedingly verbose and highly coupled with XML. Microsoft missed the memo on favoring composition over inheritance and opted to have UI written in XAML which is compiled with a partial class which acts as a sort-of controller. Yes, the C# compiler compiles XML. Sad but true. This makes things very brittle and hard to maintain. It has no CSS support so just like back in the 90's all the styling is scattered and compiled into the code base. Good luck skinning or rebranding a non-trivial application. It's also not much different architecturally than winforms which is ancient and you'll often be stuck falling back on 32 bit supporting legacy com and activeX junk. 
Never worked on databases, but the "communicator" code sounds like pure boilerplate. "Core" should be easily accessible so that any front end(CLI,GUI) can use it with little boilerplate code.
Go watch Uncle Bob's talk on Clean Architecture. https://www.youtube.com/watch?v=Nsjsiz2A9mg You can skip the 6:00 intro if you like...
Or you could just use a logger :)
it was still fun :))
Non-Mobile link: https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^151280
**Model–view–controller** Model–view–controller (MVC) is an architectural pattern commonly used for developing user interfaces that divides an application into three interconnected parts. This is done to separate internal representations of information from the ways information is presented to and accepted from the user. The MVC design pattern decouples these major components allowing for efficient code reuse and parallel development. Traditionally used for desktop graphical user interfaces (GUIs), this architecture has become popular for designing web applications and even mobile, desktop and other clients. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
That’s true. 
If for whatever reason the broker goes down, 'rabbitTemplate.convertAndSend()' will throw an [AmqpException](https://docs.spring.io/spring-amqp/api/org/springframework/amqp/AmqpException.html). What's the best approach to ensuring that messages aren't lost and can be sent to the queue when the broker is back up? I remember being asked about this scenario during an interview. I said there should be a primary and a secondary broker (two different VMs) for fault tolerance. Also, to cache the message in redis or have the message associated with state in a rdbms which can also have a status. What do you guys think?
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
sounds like they just want to separate the communication, backend, and frontend. If they call it core, it sounds to me, that it is extensible via a plugin API.
My experience is largely with the JVM, but I recently started looking at .NET and to be honest I've been quite impressed. I was able to quickly get a simple MVC app and deploy it on Linux using .NET Core MVC, while developing it on a Windows box on Visual Studio. I did not have to research which web dev framework to use, which package manager to use, etc. It all came straight out of the box and was very straight forward to get set up. According to [this](https://en.wikipedia.org/wiki/Comparison_of_the_Java_and_.NET_platforms): &gt; Both platforms are well used and supported in this market. Of the top 1,000 websites, approximately 24% use ASP.net and also 24% use Java, whereas of all the websites approximately 17% use ASP.net and 3% use Java. I also came across [this link](https://w3techs.com/technologies/overview/programming_language/all) As far as desktop/UI dev goes: https://blog.lextudio.com/the-story-about-net-cross-platform-ui-frameworks-dd4a9433d0ea Just yesterday on /r/programming there was a link to discuss [Avalonia](http://avaloniaui.net) &gt; You can deploy Java very easily as well since you don't need to install it. With AOT, Java Native Packaging and the new module system you can create true "stand alone" applications. This is simply not possible in .net. .NET also has a AOT compiler, and with .NET CLI I was able to cross compile binaries/packages such that they could be deployed on a different OS as I mentioned before. From what I can tell so far, language differences aside, what .NET has going for it now (other than it was open sourced and lots of development has been going on recently) is that it supports value types, unsigned types, async/await, ref/ref-return, and proper generics. There are a couple of these on the JVM roadmap (e.g. [project Loom](http://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html) for continuations and [project Valhalla](http://openjdk.java.net/projects/valhalla/) for value types and generic specialization) but it remains that they will not have fully reified generics, and I don't see anything resembling the remaining properties I mentioned. I think this may played a role in making Unity opt for C# for parts of their engine. On the other hand, there is [project Metropolis](https://jaxenter.com/openjdk-project-metropolis-137318.html) and a couple of new efforts to implement new GC options with projects Shenandoah and the Z Garbage Collector.
Although I'd forgotten about it, there are durability concepts similar to what you described: https://www.rabbitmq.com/reliability.html That references: https://www.rabbitmq.com/tutorials/amqp-concepts.html Perhaps something like a Fanout Exchange. 
that way you have a clean interface between ui and the backend. if you intertwine frontend code and backend long enough you create a legacy system that nobody will want to refactor, like ever.
Why not just babel ES6 into js and fire up nashhorn/V8?
Very Nice! I am saying the same thing since 2010 (!!!) Old presentation: http://codepipes.com/presentations/feature.pdf New presentation: http://codepipes.com/presentations/package-by-feature-2.pdf Other people have been saying the same thing for years as well: http://www.javapractices.com/topic/TopicAction.do?Id=205 But apparently still a lot of developers do not understand why this is important...
There's this but it's never as up-to-date as it could be https://wiki.openjdk.java.net/display/HotSpot/Main.
I personally found it complicated and had a tendency to break in wierd painful to debug ways. In addition, at the time, it was only deployed on to application servers that were painfully slow to respond to changes. I felt like it is an interesting concept to layer a server side framework over the front end but it proved to be leaky. Ultimately, I find it easier and faster to separate my front end and backend concerns and code.
Could a college student grasp everything in Effective Java? Do I need more experience than just doing class assignments?
Because i = i + 1, i++, ++i, i += 1 being different ways to do the same thing make it confusing to learn? Flexibility should not be seen as a weakness in the language, it should be seen as a strength. 
I kinda get why you're excited about this. I code in javascript some, but mostly I'm in Java on a daily basis. I really appreciate having this feature in Java logging, but I don't have much need for it in the rest of my code. When I do, there are Java classes for this. But, if I did a lot of string manipulation, this would probably be nice. You should write some tests for your code. Specifically, your character replacement is going to have a ton of side cases that you're missing. Also, the performance of your code is going to be pretty bad. There are ways of solving both problems at the same time. 
thank you so much for your response! 
It looks like the [RabbitTemplate](https://stackoverflow.com/questions/44300651/spring-amqp-message-resiliency-in-case-broker-connectivity-down) can be configured for to retry when the broker is down. I guess the next step is when the producer goes down. There's also [mirroring queues.](https://www.rabbitmq.com/ha.html) 
It's about to be deprecated in 4 weeks
https://shipilev.net/jvm-anatomy-park/
The only way to fight this is to take a stand. Be a professional, take your craft seriously. Plumbers don't fix pipes with duct tape. And force everyone on your team to read Clean Code. But truthfully, it only works in teams where an open culture and peer reviews are accepted. And if you're not working in a team like that, you're doomed anyway regardless of `var`.
What you are describing is commonly known as *Model View Controller* design pattern and is a very common (actually one of the best) approach to programming. It decouples the processing from the input/output and thus makes changes to either end easy. If you haven't come across this pattern yet, it is more than high time to learn it. Such patterns are key to *Clean Architecture*.
I really hope that we will start seeing a transition to System.Logger (https://docs.oracle.com/javase/9/docs/api/java/lang/System.Logger.html) once Java 9 catches on. It has enough functionality for 95% of anyones needs.
That is, if you're brave enough to move off from the LTS Java 8 release.
http://olivergierke.de/2013/01/whoops-where-did-my-architecture-go/
euxaristo patrida :)
This is the best quality content on this topic by far (I've read most of it). Recommended.
Did you take a look at https://projects.spring.io/spring-session/?
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I tried, but was having a hard time figuring some stuff out. Guess I’ll try and give it a more thorough look then. Thanks
See also discussion on core-libs-dev [here](http://mail.openjdk.java.net/pipermail/core-libs-dev/2018-February/thread.html#51623).
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Yes please.
Good point.
Let me guess - from the U! S! A!?
Nope, Holland actually.
I always use `System.out.println("💩");` for my exception handling code. Straight and to the point.
[removed]
&gt; Well, the answer these days is slf4j+log4j2, or slf4j+logback. Don't use anything else, and convert anything else you come across to slf4j API. Which is fine until you want to try out the new hotness, wildfly-swarm, and realize that it is firmly stuck on jboss-logging. Fun times ensure.
&gt; What makes UTF8 the better charset for java if only ASCII characters are used for coding anyway? If you use only ASCII characters, then UTF-8 string will be bit-identical to ASCII string. In other words, UTF-8 is strict superset of ASCII
&gt; On maxOS
A bit of an improvment on this would be using https://cloud.spring.io/spring-cloud-stream/ . This is an abstraction over various brokers, including rabbit and kafka. With this, you would not use RabbitTemplate, you would use Source (https://docs.spring.io/spring-cloud-stream/docs/Ditmars.SR3/reference/htmlsingle/#__code_source_code_code_sink_code_and_code_processor_code), @RabbitListener would be replace with @StreamListener which can handle json payloads. You can set the content type that you want to use with spring.cloud.stream.default.contentType=application/json If for some reason you wanted to switch from rabbit to kafka, the only thing you would need to change is your dependency in pom from spring-cloud-stream-binder-rabbit to spring-cloud-stream-binder-kafka 
Of course this is not a production feature, because it's highly expensive in performance, but It was really funny and enjoyable to read. Also, I would be a great thing to add to the language.
# YES!!!! The other pain-inducing implicit environment dependency is local timezone, but I think it would be much harder to convince people that the JVM should default to UTC. Worse, it'd likely break many people's apps...
&gt; Right now it depends on your operating system what Charset they use. That can be a problem, for example your app might behave differently when running on linux or windows. Right now you can't even fix that without changing the code. This explanation is not quite right, and whatever merits it has that I might be overlooking, I think people are likely to misunderstand it. Every time the JVM starts up, it examines the arguments it's given and its runtime environment variables to choose a default encoding that it will use in methods like the ones you link. As [this page explains](http://javarevisited.blogspot.com/2012/01/get-set-default-character-encoding.html), you can override the default encoding by: 1. Using the `file.encoding` system property at JVM startup (e.g., `java -Dfile.encoding="UTF-8"`); 2. Using your operating system's locale mechanism (e.g., in Linux, you can do `export LANG="en_US.UTF-8"` to set your language to English, your country to USA, and encoding to UTF-8); 3. In many Java-based tools with custom startup scripts, by adding the `-Dfile.encoding="UTF-8"` toggle to some environment variable specified by the tool. The problem here is how to consistently get the same character encoding across multiple runs of the same code and in different machines. Solutions include: 1. Develop your own set of startup scripts that take care of calling the `java` command with the correct options or environment to enforce a consistent encoding; 2. The "launcher" pattern where your main entrypoint class actually starts a second VM to run your "real" application. 3. Use "Infrastructure as Code" tools to provide environments that do locales consistently. 4. Avoid the Java methods that implicitly use the default encoding, and instead always specify the encoding manually in your codebase. 99% of the time you want UTF-8 anyway. 
&gt;Maybe for stuff that fits into a single line, but as soon as you have to break a string concatenation into multiple lines or have lots of dynamic parts, it gets ugly quite fast. You've got a point there. I may have been biased because so many of my logs are simple one liners.
At last!
Best comment ever! Thank you :) It was too much fun for me to start complaining about double quotes and plus signs and ending up with writing a mini code something helps as much as it can. I'm glad if you enjoyed the article!!
It's not only the language of the application. Imagine your last name has a foreign character (for example, the spanish last name "Muñoz"). That character is available in UTF8 but not in ASCII.
No please. This is going to cause all manner of unnecessary breakage. Better idea: Deprecate methods/constructors that use platform default encoding. Encourage people to always specify the encoding.
But gradle build type and flavors are so nice
Right, thanks for the correction! I edited in inline for better visibility. Regarding `file.encoding` though, the JEP says: &gt; The value of these system properties can be overridden on the command line although doing so has never been supported. So the only supported way right now is your option 2, `export LANG="en_US.UTF-8"` (changing the environment the JVM starts in).
&gt; The value of these system properties can be overridden on the command line although doing so has never been supported. This is a weird statement. I think it means "it works but nobody's ever guaranteed they won't change it." I've certainly used `file.encoding` many times and observed it to work. (On the Sun/Oracle JVM. That's another detail: I don't think third-party VMs are required to support that mechanism.)
ActiveMQ and RabbitMQ have mature communities and support a variety of protocols (including XMPP). JMS or AMQP is what I've seen used in (new) Java applications, primarily. I've also seen a lot of Kafka... but I have very mixed feelings about Kafka. It is certainly not appropriate for applications (though sometimes organizations try to use it for everything). 
I would argue that even with `List&lt;Person&gt;` a variable name of `ps` is still bad lazy programming. What does it matter that it is longer to write `persons` or `peopleOver42`? I can type `pe` and let autocomplete write the rest for me. To me, the benefit is that I can write var people = peopleService.getPeople() and now, in 99% of the cases I'm protected against method signature changes. I don't care if some idiot decides the method should return `Collection&lt;Person&gt;` instead of `ImmutableList&lt;Person&gt;`. So long as I'm not specifically using `ImmutableList` methods, no break occurs. It makes for less annoying code updates because external code motion doesn't affect the users of your APIs as much. (for example, moving Person from `my.stuff` to `my.special.stuff` doesn't cause your code to break on rebuild.) (Not saying that you SHOULD break your API contract, you shouldn't! Just that liberal usage of var can act as a band aide to make those sorts of changes less annoying)
To the max.
Interesting article. I bet there are some younger folks who are thinking "IB Who?" :)
But it's also a rather weak pitch. I'm not going to chose the guys who in the end will sell me an app server that only runs on their OS which only runs on their processor. hyperbole, I know, but we know how IBM likes to play the licensing game when they have locked you in.
Applications that allow arbitrary UTF-8 characters in user data are my favorite. What's your username? "🦑🌋⚗️💯23"
I thought it was a container service? Meaning you would deploy your java jar to it and orchestrate it from there. I don't see how that would "lock you in", unless I misunderstood.
It's not about the charset, it's about encoding for StringS represents in Java, as in all possible StringS that can be used inside Java. 
3edgy5me.
C'mon, really? IBM's flagship Java EE app server is fully free and open source and runs on any OS and on any JDK. Currently running it on OS X with the Oracle JDK, with an other box running Ubuntu and OpenJDK. It does run on IBM's own JDK too (J9), but guess what, that one is open source too. If IBM decides to increase the support costs to an unacceptable anyone can fork the source and just build their own version, or you can switch to an other application server (perhaps doing some porting if you used IBM features). Please, stop spreading FUD!
Gradle &gt; Ant+Ivy &gt; Maven 
Gradle ends in "e" which makes the "a" have its long sound. The "a" in Maven is long as well. Google "define maven" and it will show the a having the long sound and also have a short audio clip of it being pronounced.
Gradle actually has plugins for most things as well. However, you can go the custom route if you prefer. I actually find Gradle to the the perfect mix between Maven and Ant. Gradle gives you a lot of stuff by convention (the maven way); however, if you need to go beyond convention then you can write a custom task (the Ant way). In maven if you needed something custom and a plugin didn't exist you were pretty much screwed.
\*PHP 6
While I'm struggling with finding a junior developer position, what I wonder is if there were particularly more junior developer positions around a decade ago. Or at any point in the past 20 years or so. Perhaps someone out there has actual data on the issue, but this feels like pure anecdote. Even if it agrees with my own struggles in landing a first developer job while finishing grad school.
If you have the choice, there's nothing wrong with upgrading to Java 8 and then straight to 11 (which is the next LTS) when it's out.
The problem with the default timezone is not its value, it's using it.
As if forking were an option for an enterprise.. You need someone to provide support. 
&gt; and now, in 99% of the cases I'm protected against method signature changes. I don't care if some idiot decides the method should return Collection&lt;Person&gt; instead of ImmutableList&lt;Person&gt;. So long as I'm not specifically using ImmutableList methods, no break occurs. This is a very good point as well. Since I use streams or a simple for-each a lot I often really don't care if something returns a Set or a List.
Fixed.
&gt; As if forking were an option for an enterprise.. Probably not, but if the market is lucrative enough any other party can jump at their opportunity, and if that party is serious enough enterprises will follow. Case in point, Oracle/GlassFish which was dropped by Oracle and then supported by Payara.
I don't think this helps me in my works but it's good to know it exists. 
Thank you. Very Good post. I completely agree with you. Without knowing Spring framework we cannot admire the beauty of SpringBoot.
in my last position it was scrum, its hard to get extra overhead time to review junior code and teach someone stuff. ofc everyone expects a junior to be slower but in reality POs dgaf. after 2 years of scrum sprints my last junior was still the same junior. the company im with now only hires seniors, half of the team external senior consultants. it works 
Try this one too http://blog.jamesdbloom.com/JVMInternals.html 
Could have used: System.out.format("%s", var);
I've used the Ant plugin for Maven in the past, but it felt super hacky.
Cool. TIL.
I know I'm late, but who the fuck writes these? 3rd one is stupid, like, what would be the point of having a private field, in fact, so private that even the class that owns it can't access it. It would be pretty much the same as like being insecure about something so much that you yourself can't think about it.
As I said, this is not only a "bad coders" situation, but a "bad shit happens" scenario. It's easy saying "this should go this way", "the manual says this other thing", but in the Real World (©) mistakes are commited (pun intended), and hacks must be assembled from time to time. Or you just have bad luck, land with a shitty developer and suddenly you have 2 years worth of crappy code to deal with. And an actual company relationships are way much complex than just "taking a stand." You can't go telling people to read a book to write good code, unless you are in charge of code policing and later invest time and tools to enforce this. My team is far from "doomed", regardless the shitty stuff we have around here, because there's no single codebase that is free of this kind of mistakes. And hey, I'm a programmer and try to clean the code and write the code as clean as I can, but the human factor is going to still be there, no matter how many books you read, tools you install, or crappy managers your company fire.
The problem is that the methods/constructors that ask you to specify an encoding are nasty to use because they throw the checked UnsupportedEncodingException. Is it possible to define new/additional encodings at runtime or are supported encodings system dependent? If not then provide an enum for all encodings and replace the constructors that accepts an encoding as a String, with ones that accept encoding as an enum. This: UrlEncoder.encode("foo", Encoding.UTF8) Instead of this: try { UrlEncoder.encode("foo", "UTF-8) } catch UnsupportedEncodingException { throw new RuntimeException("Should not be possible if I can type", e) } If supported encodings are system/runtime dependent then at least provide: UrlEncoder.encodeWithUtf8("foo")
Ah okay I see. You've taken the wrong approach then. System has a method called setOut so you can redirect the output to your own stream. Here's an example: class TestStream extends PrintStream { @Override public void println(String s) { String toPrint = s; //do fancy logic to the input super.println(toPrint); } } //somewhere else System.setOut(new TestStream()); No need to reflection or whatever you did.
Didn't know about that, thanks for sharing!
Most of what you learn at university is useless for the average junior dev (especially at a consulting/service company) is useless anyway. You don't need to know complex data structures and algorithms. At most, if you know OOP principles and the difference between a List and a Map in Java, you'll be golden. Then you end up using Spring/Hibernate, so you'll learn that a little, but you won't deep-dive unless it's really necessary. How often do you think in these scenarios people actually have to optimize for performance? Only when a clear bottleneck forces them to. It's good if you have a rudimentary understanding of how memory is affected and what forces your CPU to do tons of work, but what's much more important in junior developers is their ability to work independently as well as in a team (asking questions) and do research when required. They will have to almost learn everything from scratch again, so it's important that they do that well. I've seen some juniors grasp everything very quickly and essentially being their company's cheapest employee despite having more relevant knowledge than *some* of their senior counterparts do at 10+ years in the industry.
If only the ASCII subset are used anyway, then UTF-8 is dramatically better in simplicity and efficiency compared to UTF-16. Just ASCII itself, or 8-bit code page supersets of ASCII, are no longer viable for non-legacy applications, so you already have to pick from UTF-8, UTF-16, or something else with more than 2^8 codepoints. 
&gt; You don't need to know complex data structures and algorithms. Nonsense. 
They help. It's good to know them. But what junior dev will actually have to touch them, especially when probably 3/4 Java web dev jobs are with some company that develops small-ish applications? When was the last time you (or a junior dev you know) had to implement a data structure from scratch and then implement a sorting algorithm (presumably for performance reasons)?
Knowing data structures isn't about implementing them from scratch. It's about knowing which one to use in what situations. That's why they're taught. Your statement about "Most of what you learn at university is useless for the average junior dev" could not be father from the truth. This foundation of knowledge and understanding helps you learn all the other shit you have to deal with in your first job. This is the biggest difference between people with a formal education and those without; the ones with the education typically pick up stuff much faster than the ones without. **That** is the value of your education.
Thanks a lot!!!! Great link!!!
You could always get exactly what you want by using LWJGL. It involves more work, but it's very light weight and you have total control over it.
JOGL 
&gt; But it's also a rather weak pitch I know right? Really it's a bad sign when someone's pitch is "I'm an expert." If you're providing real value, you point to the value you provide. "I'm an expert" is what you say when you don't have anything compelling to point to.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I'm really looking forward to these!
That isn't IBM's fault. What is IBM's fault is their manipulative business practices. They refuse to update their platform. The OS simulates running on magnetic tape for crissakes.
Yes z/Os. I don't have a link. Thats something I picked up on the job. 
Is it some sort of option you configure? I don't understand how the OS "simulates running on magnetic tape". Do you mean it purposefully runs slow?
You know how normally programs would assign their variables to memory as if they were using RAM? This assigns space as if you were using tracks and cylinders, with tracks being a single spool of tape, and cylinders being an entire rack of tapes.
Conservative GC would probably work well enough for the JVM because there are no value types or inline arrays which more easily masquerade as roots, ie. a random sequence of bytes as used in crypto or hashing would yield a lot of false positives. By comparison, the CLR is a much worse fit, because value types and stack/inline/fixed arrays means false positives would be much higher for some applications.
I use Processing 3.x often. It's a OpenGL wrapper. It's good for 3D stuff. You can get started with it pretty quickly with its own IDE, but you can also use it within eclipse. Check out some Processing tutorials: https://processing.org/tutorials/p3d/ https://processing.org/tutorials/pshader/ https://processing.org/tutorials/eclipse/ Check out some instagram posts tagged with #processing to see some of the stuff people make with it. @cacheflowe on instagram does neat 3D stuff with it
If you do Kotlin maybe, Java not any more...
I'm a senior dev. I can count the number of times data structures and algorithms was actually relevant to my work on one hand. It's requirements gathering, domain knowledge, and architecture that have been overwhelmingly the most important skills in my career. I did get a CS degree, and I appreciate it, but the skills and knowledge I learned there often seem entirely unrelated to the actual value I deliver to my business.
We will be getting value types at some point, though :)
&gt; InfoQ: What's on the horizon for your data classes research? &gt; &gt; Goetz: Breaking the features that data classes need into finer-grained features, that might be usable by all classes. For example, even in classes that are clearly not just data carriers, constructors are full of error-prone repetition, which could be replaced by making a higher-level correspondence between constructor parameters and representation. This way, data classes become simpler (just sugar for other language features), and more classes can get the benefit of the feature without trying to shoehorn them into data classes. This sort of thinking is why I'm glad Goetz is one of the primary forces in JVM &amp; Java evolution!
&gt; LWJGL is a Java library that enables cross-platform access to popular native APIs useful in the development of graphics (OpenGL), audio (OpenAL) and parallel computing (OpenCL) applications. This access is direct and high-performance, yet also wrapped in a type-safe and user-friendly layer, appropriate for the Java ecosystem. They don't mention Kotlin anywhere
&gt; I can count the number of times data structures and algorithms was actually relevant to my work on one hand. Then you did not do any work that requires this kind of understanding. Fine. 
LWJGL is a Java library. It may use Kotlin internally, but it works well with most JVM languages.
The description is old. See github [source](https://github.com/LWJGL/lwjgl3).
It's a wrapper over C libraries. It's going to be unidiomatic no matter what JVM language you use.
Description at the source matches /u/duhee's text. Did you mean to link a specific branch?
This is the last piece needed to put most of the boutique JVM languages to bed. I hope it comes sooner rather than later.
&gt; I think this weird cargo culting around data structures and algorithms is kind of unhelpful, since it misleads so many engineers into thinking that knowing the difference between a List and a Set is the primary source of their business value. I never said anything of the sort. You're also focussing way too much on just the DS/alg stuff. All the other theoretical stuff, discrete math, compilers, databases, data modelling, concurrent programming, operating systems, etc. That's all stuff that all together creates an important foundation for your career. If you "don't use" anything of that you probably ended up in some kind of low level web dev company. If that makes you happy; go right ahead. But it's completely wrong to state that all that stuff you learnt is not important. 
Conservative GC was a hack for languages where it is difficult to impossible to know exactly where pointers are within objects. If you have all the information at runtime about which members of an object are actual pointers, why not use that information while scanning an object and have Exact Precise GC?
It's helpful that they can learn from other languages such as Kotlin.
Right, I looked up the project structure. Kotin is used to generate the sources.
The awkward-ness I experienced was from it wrapping the low-level API not Kotlin. Kotin is only used as generator.
The abstract data class is _very_ nice. This is a big improvement over Scala. Being able to create mixin data classes is very useful. 
&gt;I never said anything of the sort. I know. I was describing an attitude which permeates our field, and which I think your reaction to a pretty mild statement neatly encapsulated. &gt;If you "don't use" anything of that you probably ended up in some kind of low level web dev company. There's a difference between not using something, and not having it be a particularly important factor in their work. As an engineer I often have to do work that touches on some of those domains - but it's still not what I'd prize in a junior engineer above all else. I tried to convey that distinction, but I guess I failed. &gt;But it's completely wrong to state that all that stuff you learnt is not important. That is, in fact, something I was very careful to not say. In fact, I think I explicitly stated that I appreciate my formal education.
Yeah! There are some great guys on the The Java Platform Group -- Goetz, Marks, Reinhold, Rose, Buckley, Bateman. I am glad Java is in their hands!
As usual there are no release dates, but the new release cadence will likely bring these features to us sooner than others in the past!
Yeah, it is some exciting stuff!
lwjgl is really good though it might be a little too much if you just want to render the odd mesh here and there
I think you misunderstand, or more likely you understand all too well but just want to make an anal point. The real point is that EE is a standards backed base where other things can be plugged-in. OmniFaces, DeltaSpike, Payara Cloud Connectors are all standalone products that plug-in to EE extension points.
You're right and that information is of course used in a conservative GC. But the thing is, besides objects' fields there are also methods' local variables pointing to those objects and keeping them alive -- these references are to be found on processor's registers and stack and detecting which exactly registers and stack slots are holding alive (yet to be used) pointers is the main difficultly for GC. Example in the second part of the article illustrates it greatly ;)
Shinda, you're going to reply to question asked?
That has nothing to do with JSF or JPA, but with servers in general. You're just following the client hype... 
Well, the question is, why your data is not also constructed by the builder pattern. Also if you mention builder pattern you should mention [Lombok Builder](https://projectlombok.org/features/Builder). Reduces a lot of bugs. I wish a Java native implementation or some alternative would be introduced. 
If the higher level tools don't have what you want... you might not have a choice.
Just because it grabbed it, it does mean it grabbed it all, whether it's using it all or not, the system and the rest of the apps have exactly 200M less to use. I've always found "but it only uses a chunk of it" argument moot. I can borrow $200 from you, but only actually use $50. Does that make you feel like you are only out $50?
WebSphere?
Someone should really rethink the name of this project. I would recommend a quick lookup of its current name in urban dictionary.
How to go from a beginner in rocket science to landing a job at NASA what resources did y’all use? How many hours did y’all do math? And if you were stuck at a problem when should you look at the solution?
I honestly wasn’t playing it was a serious question. Y’all just got to much time in your hands to play with others ain’t it 
What I mean is that the question you asked was ridiculous. It showed that you haven’t put much thought into the question you asked, which is a little ironic given how much research and self-learning is required for this occupation.
The driving force isn't the developers need to use Docker, K8s, etc. to deploy an app, but IT's need to maximize use of computing hardware. With computer systems being more powerful than most applications actually need, it's more cost and energy efficient to use methods that allow that computer system to be divided into several applications running on virtual nodes on a network. More importantly, it is great when share computing resources doesn't require everyone to adapt the same programming language and/or frameworks. 
I’m sorry but some people are not native to English. 
IBM Java Web Application Server? 
I remember when I just coded. Those were good days
It's literally 14 clicks deep just to see how many messages are in a queue, so easy! Want to deploy an application to a web server without their ui? You get to learn a proprietary scripting languages!
&gt; It's literally 14 clicks deep just to see how many messages are in a queue, so easy! Want to deploy an application to a web server without their ui? You get to learn a proprietary scripting languages! I work w/ Websphere daily. Obviously if you're building a new system there doesn't depend on it there is better more modern options but its not nearly as bad as everyone says. I have all sysadmin tasks scripted with Python incl managing clusters, deployments, restarting. Scripting virtually any task it is fairly trivial.
I used to be “just a developer” myself, I wasn’t hired as a DevOps engineer and when I started here our deployment methods were using WebDeploy in Visual Studio to push to IIS - sure we had TFS running builds and tests but it really did no good when the artifacts never went anywhere. I took it on myself to improve things, and I continue to do so daily because I personally remember how much time I wasted on builds and deployments - I deal with that shit now so the devs on my team can bang out instead of frustrate themselves trying to get it live ;)
I thought it was Jython? It’s quite a popular scripting language for enterprise software. 
Someone may have missed the point
I am not DavOps and I don't want to be ;) but I am a developer and I try to help improve the process when I can. If I write a tool or script you better believe it's going into versioncontrol somewhere... I live by the idea that if the code is not better than I found it other than the issue I was addressing then I am not doing my job. Some developers live by the, it's not my job or that's not my code or This story did not call for that change we can just do it later... Keep up the good work ;)
I absolutely love spring-boot, every time I sit in on a call with the other members of my team hammering away at a ASP.Net app I cringe a little (C# is a great language with an incredibly shitty ecosystem). I wish they’d put some more polish into spring-security though, it can be kind of a pain to configure :/
Gotcha. Totally agree with you there. IBM was a pioneer 20 years ago but the complicated nature of WebSphere makes it unsuitable for most businesses.
Overall it's hell to learn and maintain, and there just aren't benefits to using it. Amusingly enough, we have one solution left that still uses it, and we're moving that to docker because of how long it takes to install stuff on it otherwise.
It's ancient first wave of Java enterprise technology stuff. Before JBoss etc. you had an application server called WebSphere that ran on Windows. It's still in use in legacy systems that belong in a museum.
I mean yeah, I'm not saying it's impossible to do those things, the startNode/Server scripts it deploys with make some simple tasks easy. Configuring ssl, deploying mqs, dealing with osgi though? Needlessly more complicated than tomcat or jboss (even with eclipse osgi wrappers added to tomcat). Disabling protocols and key algorithms even worse. Websphere (especially pre-liberty) was an exercise in Stockholm syndrome to use. We use Ansible for almost all of that today (where we can't use docker, which happens), and it's so much easier to not only maintain, but critically to /teach/
Our deployment system on WAS took 2 hours and we overprovisioned by 33% every time. First Tomcat system 30 minutes. Now we are moving to Pivotal Cloud Foundry and it’s taking us less than a minute. Part of that’s our fault for wiring bad tooling but part is WAS
&gt; I have a colleague who doesn't know the difference between a List and a Set too I have a colleague who doesn't know what the % operator is. Guess what? They're female so they get to keep on sucking. Yay diversity...
You wish. The bank I work has a "new" system which is considered the "strategic platform" which is running on Websphere. Managers don't see anything wrong with that... BTW, I'm switching jobs.
It's a dream if they have C# that can run in JVM. Oh wait, we do have Kotlin which is similar.
Working with JavaEE server is like contracting ebola.
/u/henk53 is just a JavaEE trollvangelist. He try to do the Socratic method on every debate nowadays until the other party tired of answering. Pretty childish to me.
I do love Kotlin and I use it all the time, can't force my team to switch though (I'm just glad .Net Core is a thing now so at least we can start moving away from Windows Server). Still, for the things that I absolutely cannot do in .Net (accessing DB2 for i from .net core requires stupid expensive licenses from IBM, on the JVM I can just use JTOpen, for example) it's my first choice.
/r/javahelp
Zing
Eh, WildFly isn't so bad. Or maybe I'm a masochist :/ Compile me, daddy
Perhaps your lightweight application could be delivered as a web app and then you could use WebGL? 
I'm learning Spring Boot right now. The learning curve is a bit rough since I'm new to Spring but man is it nice to have an imbedded Tomcat server that just works. I don't have to mess with running a separate instance of Weblogic and configure everything to test something locally. 
Unfortunately it seems that this project has been on life support for years now. At this point I doubt it will ever be properly maintained again so if people have problems with it they'll be on their own.
With all due respect, it's easy for you and others to say JavaEE by itself is outdated and cumbersome.. I can say the same about say Django (where I know nothing about): "Django by itself is outdated and cumbersome." See what I did there? I ask for why to see if it's just a parrot or someone who actually knows the technology. 80/100 times, people have NO idea what to reply, meaning they're just parroting and don't know Java EE at all. 15/100 times, people used Java EE in 2001, and still think it's exactly like 2001. 5/100 times, people have a valid point, and it's eventually a good discussion.
&gt; Or even JBOSS, Payara or whatever 100mb stupid slow Java EE server. Now, that's not a troll comment then? I'm probably feeding the troll here, but if other people might be reading along. JBoss starts up in about a second, Payara too. They use some 50mb of memory after booting. Payara Micro, Liberty en WildFly Swarm are smaller than 100mb, but even then, things like Spring with all dependencies included (such as Hibernate) is not rarely 100mb+ as well, plus it starts slower than WildFly Swarm and Payara Micro and Liberty. 
Jim Laskey was looking for feedback on Twitter: https://twitter.com/wickund/status/966754263329275904 Unfortunately, posting tweets seems to be filtered on this subreddit, so I posted the survey link directly.
I know what WebSphere is ;) Hated it with a passion, but it's old. Now there's JBoss etc, and from IBM themselves there's Open Liberty, which is fast, small, free and fully open source.
Hahaha - it works well though and I still love it! :)
嗨咯
Could it not also be seen as a way to maximize efficiency when you look at th greater scope of things? For instance, are there no benefits when you run your services in smaller chunks. You could guess that it’s easier to fill whatever capacity you have in a manner that doesn’t waste resources when your pieces are smaller. Say, in the same way as small stones leave bigger gaps than gravel when you put them in a container?
If they open source flight recorder this alone will be worth it. 
There a bunch listed here: http://www.java-gaming.org/index.php?action=resources But LWJGL is well supported last I looked.
I meant efficiency of performing more computation with less energy.
I think you meant AWS ECS
Ecs is a container service. Elastic bean stalk is their paas.
Would you mind also posting this to /r/programming? It should have more reach there.
Sounds good to me!
Hiring Jr devs entails a long term commitment on part of employer. You need to allocate sr devs to help and have a longer term vision and roadmap for your project or product. The projects I work on they want us to hit ground running, ship something and either move on to something new or ship another version. They don’t want to commit to anything longer term. Sometimes the projects iterate for years, sometimes just weeks.
So, openjdk and oraclejdk will be tecnically equal but oracle's is going to have official support. Am I right? 
Ah okay then. Yea, for wrappers, you have two choices: Try to fix the awkwardness of the foreign libraries or keep it as close as possible to the foreign lib, in order to not invalidate all the documentation that already exists. For LWJGL, previous versions tried to hide the uglinesses of for example OpenGL and it failed. It failed, because most of the times this approach is taken, it has to fail for several reasons. Maintainance and abstraction problems are only two of them. So I'm very happy they ditched trying to fix native APIs.
Yeah. Guess the survey results will be posted. I'm surprised this didn't get more traction on /r/java yet! Must've been filtered for a few hours, again...
Hmm, it says so on this subreddit as well: &gt; No surveys, no job offers! Such content will be removed without warning But I guess this is a bit of an exception, because the survey is from the Java language designers, so definitely of interest.
`var excited = true;`
containers require more resources than running the equivalent processes natively, and (in the case of java apps) dramatically more than an equivalent single process. [here's an discussion](https://forums.docker.com/t/docker-resource-usage-overhead/21664) but that overhead is worth it, because it dramatically reduces the complexity - ie the many processes don't need to be aware of each other's details 
&gt; it’s easier to fill whatever capacity you have right. it makes the logistics of sharing resources dramatically easier at the cost of slightly lower efficiency
Welcome to TheReg? Check out an article about Yahoo! ...
Mark Reinhold discusses LTS releases [here](https://youtu.be/H48QEcjP1PU?t=11m1s). He made it appear that Oracle would not charge for LTS.
`bool excited = false;`
Boolean or boolean?
[libgdx](https://libgdx.badlogicgames.com) seems to be popular
You can see the list of features [here](http://openjdk.java.net/projects/jdk/10/). I'm not sure why it isn't added to the release notes.
You seem to be talking about resources as what is reported by the OS, while I'm talking about electricity use measured at the utility meter. You don't need containerization to enforce clean separation of concerns.
Might be not stable enough. JDK releases now work like trains not taxis, if feature is not mature enough, the train leaves and the feature has to wait for another train.
It’s in the early release build. I’ve been messing around with it lately.
&gt; APIs for Creating Unmodifiable Collections I'm still wondering why they didn't create specialized, separate immutable collections from the start? Now they've added (JDK 9 and 10) `List.of(..)` and `List.copyOf` to the mess: `new ArrayList&lt;&gt;(..)`, `Arrays.asList(..)`, `Collections.copy(..)`, `Collections.toUnmodifiableList(..)` All are variations with a slightly different result. I certainly forgot one or the other.
Kotlin certainly handles these much nicer.
Just like rip joda when jdk8 came out
I think the same. This post is not showing up in "new" however, it seems to be hidden. I came here from twitter. I asked the mods about this, but no answer so far.
They could make a decision to make the default list immutable. Java made this decision 20 years ago, when that concept was not so popular. I think the difference is negligible and in the end it's just a preference.
Doing it from the beginning certainly would've been nice but it's far too late for that. They would have to break all of collections code to do it now. 
And RIP guava in every single major java update since its inception apparently.
Out of curiosity, what are you saying should be changed? * `java.util.Date` and `java.util.Calendar` have been deprecated * `java.time.LocalTime` and `java.time.LocalDateTime` are stored without timezones... they're implicitly the computer's time zone, hence the **Local** in their names * `java.time.ZonedDateTime` requires you to specify the timezone * `java.time.Instant` is essentially a 96-bit UNIX time, which is already measured from UTC
Slight problem: There are entire classes that exist solely to do operations on the default character set. For example, `FileReader` and `FileWriter` both do this. What's more, you have to create two objects to replace the single objects above... `FileInputStream` and `InputStreamReader` for the former and `FileOutputStream` and `OutputStreamWriter` for the latter. 
You're making a rather excellent point here. I'm indeed thinking a bit backwards with this—relying on longtime experience that `java.time` has slowly begun to render less relevant going forward. But look for example at the [`ZonedDateTime.now()` method](https://docs.oracle.com/javase/8/docs/api/java/time/ZonedDateTime.html#now--): &gt; public static ZonedDateTime now() &gt; &gt; Obtains the current date-time from the system clock in the default time-zone. This will query the system clock in the default time-zone to obtain the current date-time. The zone and offset will be set based on the time-zone in the clock. &gt; &gt; Using this method will prevent the ability to use an alternate clock for testing because the clock is hard-coded. That method is probably implemented something like `return ZonedDateTime.now(Clock.systemDefaultZone());`, or like `return ZonedDateTime.now(ZoneId.systemDefault());`. Note that other classes in the package also have similar methods; e.g., both `LocalTime` and `LocalDateTime` do. I've just seen too many cases in my time of developers who just routinely go for methods that use the environmentally-dependent default value and just blindly assume it'll return the same results in different environments (or often the same machine at different times). And testing tends not to reveal bugs like these. Heck, I could even consider a solution where we simply picked a different name for the no-argument `now()` methods. Something long and cumbersome like `currentUserLocalWallClockTime` would be better; and it also describes the semantics to jog people's minds a bit that perhaps this isn't the thing they want to do. It's doing a complicated thing that experience has shown can be dangerous in server applications; it should have a name that reflects that.
That's only true for 7-bit ASCII. If you use 8-bit ASCII characters past character 127 (aka "Extended ASCII") you'll get weird results in UTF-8.
I agree with most of this.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Fun exercise to you learn the language but in reality this solution is not particularly fast. Traditional string concatenation (using +) is a lot faster than template strings (printf). Also take a look at the StringBuilder implementation if you're not familiar.
It doesn't really matter whether the JDK is safe to download or not: if you want to write apps in Java, you will need to download it. That said, I didn't know that Unity uses Java at all; I thought it was based around C#.
It primarily uses Java for Android apps, as Android is Java based. 
Yes, Java (and the JDK) is safe. The older Java browser plugin had security issues, but most browsers no longer support plugins like that anymore. The real problem wasn't so much the Java plugin, but the way that the plugin was given access to the browser.
Yeah but ebs is their solution for attachable storage
I don't know any of those things and deploy apps!
I have been working for 2 and a half years now and had 3 jobs. Never worked with someone who has less experience than me.
Java applets that ran in the web browser used to be the issue because it was easy for the user to give great access to their own computer through it. Luckily it is not really used anymore.
Android is a bit of a skill jump. For basic GUI's check out JavaFX (The successor to Swing) 
&gt; Is Java Development Kit safe to download? The JDK itself is safe. However, the official Oracle download site is unencrypted ("http://" only) and prone to MITM attacks ;)
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Yeah I got the feeling. Was sad to find out that there isn't a basic console apk where I can just plug in my class and use it with a keyboard. Thanks for answering so quickly! 
&gt; I found a lot of people saying that Java was unsafe, had security vulnerabilites Who? Wondoze .net fanbois? 
--&gt; **/r/javahelp** As is outlined in *so many places* in this subreddit. If your program is properly written, i.e. follows clean separation of input, output, and processing, you should be able to switch the presentation layer (input output) pretty quickly. See the [Model View Controller](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller) design pattern.
**Model–view–controller** Model–view–controller (MVC) is an architectural pattern commonly used for developing user interfaces that divides an application into three interconnected parts. This is done to separate internal representations of information from the ways information is presented to and accepted from the user. The MVC design pattern decouples these major components allowing for efficient code reuse and parallel development. Traditionally used for desktop graphical user interfaces (GUIs), this architecture has become popular for designing web applications and even mobile, desktop and other clients. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Thanks for the heads up. Also wrote in over there, but I'll be honest I didn't check if asking for help wasn't allowed/isn't encouraged here! I'll check out the model view controller design pattern though, cheers.
Crossposting to /r/javahelp, sorry.
There are a number of terminal emulators for Android. One of the simpler open source terminal emulators is [Android-Terminal-Emulator]( https://play.google.com/store/apps/details?id=jackpal.androidterm ) It is Apache licensed, so as long as your project is also released as open source (which means you have to publish the code, GitHub is the best way to do that), you are granted the right to copy the code into your own project and use it for whatever: https://github.com/jackpal/Android-Terminal-Emulator As for running your own code, the app's configuration defaults to launching `/system/bin/sh`, so instead what you do is configure it launch your own Java app, so `/system/bin/dalvikvm /path/to/your/program.dex`, and you'll probably have to convert your program's `.class` files to `.dex`files using the Android developer kit.
Thanks for this! Will also have a look here! 
I edited my comment above, but I'll just say it again here: The app I linked you to can be easily configured to launch an arbitrary app. The app's configuration defaults to launching `/system/bin/sh`, so instead what you do is configure it launch your own Java app, so `/system/bin/dalvikvm /path/to/your/program.dex`, and you'll probably have to convert your program's `.class` files to `.dex`files using the Android developer kit.
The MVC pattern or a simplified version is key to proper programming. It doesn't need to be anything complicated. The main element is to learn to produce a clean separation between input/output and processing. Processing should only receive and return values and input/output should only be responsible for acquiring and presenting data. This pattern especially in a simplified version is easy to learn and easy to understand. Learning to separate the parts will help in more complex applications.
Maybe things will change as I advance in my career, but as I mentioned I'm a senior dev where I work. I also know people further in their careers who, if anything, seem to care about technical minutiae even less than I do! This isn't to say that data structures and algorithms isn't a perfectly fine domain to specialize in - you've done well for yourself by doing just that. It's just that software engineering is a huge field, and there are many other domains (both strictly technical and more broadly practical) that you can specialize in quite successfully. You just never seem to hear about them, especially when you're a junior.
I'm literally overwhelmed by how helpful you've been. It's close to midnight in my Timezone, but when I wake up I will attack this with a whole new motivation! Seriously thanks for the help! 
You can think about in incremental steps towards that and you could be there in no time!
&gt; var isExcited = true; FTFY
What's stupid or slow about modern Java EE servers? What are you comparing to?
It’s going to be in 10, relax.
Not really the place for this, you should try /r/javahelp. But the fix is... if (myInt !== "") { b = true; } should be if (myInt != "") { b = true; } 
Okay, thanks. I did try that before but got a different error. I'll post future help questions in the sub provided, thank you.
Your Ide is right, correct "not equal to" operrator is "!=", not "!==". (source: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/opsummary.html) By the way, why are you comapring int (myInt) to String ("")? Even if (myInt) is String then Strings should be compared using ".equals()" method. Read more here: https://stackoverflow.com/questions/513832/how-do-i-compare-strings-in-java
For Strings and other objects, you need to use the equals method to check for equality, the behavior of the == operator is not what you would expect. The oposite of the == operator is the !=. This is not assignment. The assignment operator is just =. For a better learning experience, I suggest r/learnjava, which is a subreddit that should help you out. 
I see, thanks. Also that is another misunderstanding on my behalf. I was trying to check if an integer value was entered thinking that "" means nothing for both string an integer.
Okay, thank you. I'll have a look there.
They could have started adding [Vavr](http://www.vavr.io/) like immutable collections in Java 9 instead of adding more methods that produce misleading and error prone collection views. Then they can start depricating those "unmodifiable" variants. Migration should be extremly straight forward. I've done this myself with all the Guava FluentIter(r)ibles. Heck they could do this even now.
If myInt is of type int: if (myInt != null) { b = true; } if myInt is of type String: if (myInt.equals("")) { b = true; }
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I know this isn't what you're asking for but you should really learn to code a GUI instead. I actually know a couple solutions for that but what you're asking for doesn't require you to emulate a terminal, that's just a lazy way of doing stuff and you should learn the proper way instead that is creating a GUI-based version of your program.
Haha I love it, bots are fun
I love this.
You do need the diamond operator there though.
How? They look exactly like their Scala variants. The Java version ```java abstract record Base(int x); record Sub(int x, int y) extends Base(x); ``` is ```scala abstract case class Base(x: Int) case class Sub(x: Int, y: Int) extends Base(x) ```
Probably your best shot is to use a *proper* IDE: + [Eclipse](http://eclipse.org) - free + [IntelliJ](https://www.jetbrains.com/idea/) - Community Edition is free + [Netbeans](http://netbeans.org) - free
/r/javahelp `.jpg` doesn't know any transparency. You will want to use a different painting program (Gimp) and create `.png` files that have full alpha transparency.
Did you experiment with shooting at different angles? I havn't played much desert golf but I wonder if a higher angle would cause it to bounce out of the hole less. Still a great video. Thanks for sharing.
You need to specify the z position manually and add all images with a different z position
So it should land in the next Java LTS? I'm okay with it.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Everything I’ve read says not to use that feature. E.g. https://stackoverflow.com/questions/9367950/scala-abstract-case-class#9368120 - but maybe this is wrong? A huge problem with Scala is finding reliable up to date docs
Surprised Guava's [Preconditions](https://github.com/google/guava/wiki/PreconditionsExplained) wasn't mentioned
It’s in the works — [JEP 305](http://openjdk.java.net/jeps/305).
Yeah that's incorrect and outdated. Abstract case classes have their uses, e.g. when you want to prevent their instantiation (just like a regular abstract class) but want access to the benefits case classes bring by default. An `abstract case class` does not have its `apply` and `copy` methods automatically generated, this is useful if you want to enforce invariants using case classes. https://www.cakesolutions.net/teamblogs/enforcing-invariants-in-scala-datatypes
Well, any recommendation here will start a "holy" war. Commonly, *IntelliJ* is the most recommended. My personal favorite, however (maybe Stockholm Syndrome) is *Eclipse*. My least favorite one is *Netbeans* - never really got to like it. IMO, test all three and stick to the one you like most.
Good point, I’ll definitely try all of them. Thanks again.
Pretty interesting additions to JDK 10. We run dev and test environments in Docker, only need to transition to production.
I wasn't aware of it :-) It's hard to be exhaustive...
With regard to null references: deciding explicitly to use/not use *null* and documenting when it happens and what it means makes more sense in general....
Guava Preconditions has been around forever 
I was confused for a second. I thought you had found some crazy trick to implement named method / constructor arguments. Nevertheless, it is a neat addition. The main use case I can see for this is to cut down on biolerplate for reflection based libraries which use method parameter names for injection sources (for instance, JAX-RS's @QueryParam annotation). It's too bad this is not on by default since having to rely on the source code being compiled with this specific flag could be risky in complex deployment / build environments. Imagine writing code that relies on this functionality and then having it deployed in an environment in which the parameter names are not available. Those could be some fun bugs to hunt down. Is there a way to check at runtime whether this information is available to help avoid this potential problem?
That's cool. In that case what about non-null references like Kotlin's `T?`. Is there any discussion about that for Java?
Are you talking about the Elvis operator? That likely won't appear in the language. Work is being done on value types, though, which are stack based objects. See [JEP 169](http://openjdk.java.net/jeps/169).
Oh and another thing is that the JVM lacks reified types, and I'm not sure there is any work on that. I know there is work for generic specialization, that's a step in the right direction but those are only somewhat related to reified generics.
I did! It was a fun little programming diversion, especially since I haven't used Java in years.
[JEP 218]( http://openjdk.java.net/jeps/218) discusses generics over primitive types, which will be reified. Type erasure is not going way, though.
I believe that video still addresses your question. Using `Optional` will eliminate common uses of `null` in some areas. No plan, that I know of, is currently in place to introduce non-nullable types
Yep, I was referring to type erasure.
The only way I know is not very reliable. If not "named", parameters will have default names such as `arg0`, `arg1`, etc. You could check for such pattern.
Almost everyone is going to recommend IntelliJ. It’s just really good.
Dalvik VM*
What does an extension method do? I haven't looked at Kotlin in much detail.
This article is problematic in a variety of ways. 1) As several other commentators have mentioned, the Google Guava library has had preconditions for years and years. 2) The author's discussion of Objects class is limited to Java 8, which means the expansion of Objects preconditions checks in Java 9 is not mentioned, while his complaint about its limited offering remains. Most of the Guava preconditions now have direct counterparts in Objects. 3) The author's code examples for Objects are not how the classes are generally used. Their design is intended to avoid his if/then/else-style statements in favor of assignments of parameters to directly to private variables and cause exceptions if the precondition is not met. This is the style used in Guava's preconditions and in the Javadoc examples for Objects. 
Cool. Thanks for the response and thanks again for the original content.
Yeah, the additions to Objects in Java 9 are worthy of mention. The class has become quite useful now. 
I always thought that programming by contract (PBC) was mostly about static analysis. It seems that the entire discussion here is about formalizing runtime exceptions based on pre/post-conditions and invariants. Should I change my mind about what PBC is in practice or?
If all the cloud vendors are open compatible; it should be the same on all, right?
It looks like in your [submission](https://www.reddit.com/r/java/comments/80aipb/script_to_identify_top_java_thread_consumers/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
They allow you to "extend" the behavior of an already existing class by writing static methods that can then be called as if they were part of the original class. For instance, you can extend the `Int` class to define a `abs()` function, then when you have the relevant extension method imported into your scope you could call `1.abs()` or `x.abs()` where `x: Int`. The Kotlin standard library makes use of this to extend the behavior of Java's collections to define things like `List&lt;T&gt;.first()`, `List&lt;T&gt;.sum()`, etc.
Also handy are`Validate` from Apache's `commons-lang3` and `@lombok.NonNull`
I think originally it was more oriented towards static analysis, but to the limited extent it's practiced now, it includes static and runtime analysis. By the way, if you're an IntelliJ user, they have a PBC-like annotation that they enforce in the IDE called [@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html)
Given I now work for Microsoft, Azure was my chosen cloud provider by default. But, I decided to implement this app in a way to abstract out the cloud-specific code behind an interface, so you could do precisely this. If someone wanted to do a pull request with an implementation of that interface for Google Cloud, AWS, etc - I would happily support this. With a little extra code to allow for a user to specify their preferred cloud vendor, this would be very cool. 
Only documenting these cases isn't that helpful in my experience. An approach where the documentation happens through annotations that can be checked automatically is much more helpful. Modern IDEs or the [Checker Framework](https://checkerframework.org/) are able to check nullness. Unfortunately there is still no standard annotion to express nullnuess in Java.
Just use bitbucket and learn C#. Visual Studio Community is free, and the scaffolding in ASP.NET Core 2.0 is a nice touch. Plus (correct me if I'm wrong), but you may deploy C# to AWS and GWS also.
Congrats and thank you for the share!
First get a job offer then figure it out.
Lol, get job at first, not an internship. Make your own projects while studying. 
Why can't you study and work at the same time like normal people?
Like doing c# on linode. No thanks.
Looking forward to JUnit 5, and I would love to use it in all projects I work on. Unfortunately, I cannot... because currently Maven (ie, Surefire/Failsafe) does not seem to fully support it :( (and I would love to hear if that is no longer the case with this 5.1.0 version...) I made the mistake to upgrade to JUnit 5 in a project in which I was forced to downgrade the Surefire version (most recent version did not work at all), and lost ability to re-run flaky tests (that was a big problem for that project). How is JUnit 5 supported in Gradle? 
Just switch languages for no real reason.
Does it already work with Arquillian?
Yea, it's hard to recommend that someone "try all of them and see which you like" because of all of the features you have to get used to. I've been using IntelliJ for years, and I still stumble across features I didn't know about. That coupled with the new features each IDE adds for each new iteration makes smoke testing them hard.
Why the down votes? Goetz has made this same statement over and over again (not specifically for Kotlin, but for languages in general). Because of backwards compatibility, they're slower to change and adopt new paradigms because they want to be sure that the features they're adding to the language belong in the language and not some external library.
Agreed.
Let's rewrite our enterprise java app to Rust that is working perfectly, to look edgy and shit /s.
&gt; The methods look blocking but are actually transformed into asynchronous methods that use CompletableFutures to continue the execution as intermediary results arrive. It rewrites the code through bytecode manipulation via a java agent. Totally overengineered piece of crap written for people who I guess struggle to chain CompleteableFutures in a clear, readable and maintainable manner
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Ewwwww... way to shoehorn monadic functions in a imperative way
I figured since it was EA, they would have made a future that stops running unless you buy more more time.
No
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Admirable. More devs need to think along these lines. If the one major barrier to cross-cloud development is addressed by the vendors, bandwidth costs, we might see a lot more cross-cloud development. A developer could choose to spread the architecture across cloud vendors without fear of incurring undue bandwidth costs. The developer could then take advantages of the services they need for the entire architecture. Perhaps they choose Azure for Docker containers for some of their persistent Microservices (can't believe I'm using the term now). Per Then they choose AWS for Lambda for transient Micrososervice "functions". Then they choose GCE for region location for network transit speed, etc. etc. 
Some of the IDEs have tools to make this easy to do. Android Studio has a GUI builder that lets you drag-and-drop components onto a viewport. Eclipse also has a WindowBuilder that lets you do this with Swing. As a beginner, you might try those out and then look at the code they are generating. From there, you might consider getting a book on Android development or Java FX/Swing development and skimming them for more examples. As others have said, while Android does use Java to write programs, it actually isn't running on a Java VM - it is running on an alternative VM called Dalvik VM. This means that Java FX applications (which are designed to run on the Java VM) won't run on Android, so you probably need to pick one and learn the ins and outs of programming frontend apps in the respective environments. Good luck! 
Check this tutorial out using one popular Java framework, Spring Boot, to build very simple full-stack applications from HTML to a Java backend. https://spring.io/guides/gs/handling-form-submission/ You also will see others using backend REST APIs with something like AngularJS or React, but as a beginner you might find a simple HTML application like in this Spring Guide easier to learn about. 
It was written before Java 8 releases?
Any particular resources on data structures you guys would recommend for a junior dev trying to up their game?
I still prefer reactive streams to CompletableFutures; much cleaner and the code is still reasonable to read.
Nice! /r/learnjava is a great place to put this sort of stuff while you're still learning. Want some feedback?
Sure!
The OP is deploying to Azure. If I'm deploying my project to Azure, then I'd use the language that is the best fit.
Looks just like JavaScript promises. I don't understand the problem they are attempting to solve.
reads like `unsigned compare`
afaik they are still working on it
`ucmp` as described in the "Minimal Value Types" proposal? I this is a little outdated, currently they are experimenting with a different model "L-World" which is much simpler in many ways. There is no longer a universal `any` carrier type above Object and value types, rather they are looking at a strategy of treating Object as an "honorary interface" such that it can also be the base type of value types, so no more `ucmp` etc. [This discussion](http://mail.openjdk.java.net/pipermail/valhalla-spec-observers/2017-November/000388.html) is a good place to start, but there has been a lot of work on this since then so there's probably a lot to read through. I think the current state of the exploration has acmp returning false when either of the operands is a value type. I realise this doesn't come very close to actually answering your question but maybe it will help point in the right direction.
This is not new, this was done years ago, not sure it's still relevant to them.
Thank you! I just added a license and some minor changes, now you can use with long or short options: ./lwp_check.sh [--stlen &lt;STACKTRACE_LENGTH&gt; --count &lt;LWP_COUNT] | [--help|-h]
Azure is just like all the other cloud vendors - it isn't language specific and has support for a number of languages, including Java. There is a Java SDK available for most Azure services, so the notion that Java is foreign or wrong on Azure is incorrect.
As I said elsewhere, azure is not language specific, and it caters to a number of languages by offering sdks, and Java is one of those supported platforms. Java is a first class citizen in Azure, just like it is on AWS or Google cloud.
Student. I build weekly homework assignments. I study information security. More than likely I'd test applications. I'd like to work on an Android app.
I am a student and course coordinator. I work on assignments for my courses, as well as create assignments for our introductory course.
Spring Boot Helps you With some starter Projects and free from hassle of setting Up Project.Its Just a simple container .Where as Spring Is Still a Framework With MVC Patter inbuilt supported in Spring MVC . Check this http://frugalisminds.com/spring/spring-mvc-vs-spring-boot/
Is it right that nums[i]/sum is doing integer arithmetic? So that e.g. 4/3=1?
Senior software engineer building and maintaining an enterprise platform for the exchange of medical data between hospitals. We use a mix of Java EE and Spring and hope to move more to Spring.
A tool, or an app that supports the user. There are a lot of BS apps out there. So something that betters the user, possibly privacy oriented. Phone apps are like IoT smart devices: cool, but have little to no practicality/value at the premium price.
Azure won't get many Java projects.
You can download OpenJDK from various sources: Adopt OpenJDK. Pick your version and download. https://adoptopenjdk.net/archive.html?variant=openjdk9 OpenJDK Build. In addition to links on the page you can click "releases". https://github.com/ojdkbuild/ojdkbuild My favorite . . . Zulu from Azul systems. Certified with TCK. https://www.azul.com/downloads/zulu/ 
Today? CTO, although I got here by way of "Director", "Section Head", "Lead Developer", "Junior Developer", and "Hey, you." These days I'm building strategies and architectures professionally, but I like to keep a hand in actual dev work on my own time, too. My favourite stuff to build is tightly-tuned algorithms for doing pattern matching, similarity detection, and the like. My favourite thing to do is taking an algorithm that's technically correct, and putting it into a load-testing harness with a profiler attached. Seeing an implementation's performance jump when I hit thresholds like zero-allocation feels *good.*
Ooops, sorry, I had `vcmp` in mind. I was aware of `acmp` returning false (that's basically strategy 1 of 3 they are trying), but `acmp` returning false won't address the issues around floating point values from what I can see.
Sorry, I had `vcmp` in mind, I corrected the original answer.
Could be, I felt that the `ValueType::identity` stuff was more of a temporary hack...
how is it not on purpose? :) 
Day job: Software engineer. I do back-end DB modeling/processing, and write front-end viewers, CRUD applications, or REST apis. I also do business logic automation like shit to generate reports from that stuff. If it's information related, be elated, imma make it. I work for a couple of companies at the moment. One is a medtech company, and one is a fortune 500 I shouldn't name. I'm a contractor, but a very regular contractor on both. I usually get ~60-80hr a month from each which works out great. I like the flexibility and downtime a great deal. I used to work for Minecraft servers FT, and did basically the same thing, as well as some plugin stuff. I was compensated extremely well, but I would not recommend it. Being the lynchpin of a 24 hr business is a *nightmare*. Add customers that spend 24/7 trying to break it..yeah. I still do Minecraft plugins on the side, but I actually enjoy it again now. 
Callback hell
It wasn't meant in a snobistic way, rather that they can wait for other languagues to discover what works and what doesn't and implement it in their own time in a way that makes sense for Java. The whole ecosystem benefits from cross language innovation.
The problem with this is that this is changing the semantics of things. For instance, changing `ArrayList&lt;Double&gt;` to `ArrayList&lt;double&gt;` will change its behavior incompatibly. Of course there could be some public reeducation campaign of changing all generic code to add some `instanceof` checks for doubles, but that won't scale with value types, where floating point values can be nested arbitrarily deep inside.
That's nice, though I think `CompletableFuture` also has cancellation and backwards propagation of cancel/fail events. It's just that it only handles a single event, instead of a (possible infinite) reactive stream. Its API is kind of a nightmare, though. I've been meaning to write a blog post about that for a while now.
Senior Software Engineer. Day job is a web app with Java backend rest services. Side projects include a Minecraft modpack development utility and a Discord bot for a server I run.
Well spotted. Yeah, the most recent checkin in the actual code is November 2016 ...
So... I used to agree with you on this. Now I don't. CompletableFutures are monads which use closures and method invocations for control flow. In a language *without* imperative control flow like Java, that's fine! You're already using functions. But the thing is, Java's imperative controls are pretty nice and it forces the API to recreate all the functionality *that exists as a language primitive* in the form of `.filter` and `.map()`. Granted, I'd prefer applicatives for Traversable-like stuff, but most languages aren't really there.
The web was designed for a large Angular application running in a browser??? Last time I looked the original web didn't have JavaScript and the servers just returned HTML...
That's good news, but I also know this is a highly educated and competitive area.
I'm sorry I'm not sure I follow. &gt; The problem with this is that this is changing the semantics of things. Is it? At the very least the surely isn't changing the semantics of existing code, even if recompiled. It's both source and bytecode backwards-compatible. Of course if people do update their code, some incompatibilities may be expected, but that said ... &gt; For instance, changing ArrayList&lt;Double&gt; to ArrayList&lt;double&gt; will change its behavior incompatibly. I don't see why this should have to be the case. ArrayList uses `equals` not `==` to compare member equality, so assuming the new `double.equals()` behaves the same as `Double.equals()` the behaviour of `ArrayList` is also identical. The way I see it, the only way the behaviour would change is if the implementer of `ArrayList` opted-in to manually specialise for `double` and decided to use `==` instead of `equals` in the specialised code. And I have no idea if manual specialisation is planned to be exposed as a language feature. Also, I assume `dcmp` will only be used if the two values at either side of an `==` are statically typed as `double` ... e.g. under normal circumstances, any `T == T` in generic code will still use `acmp` if `T` is parametrized with `double` rather than the JVM trying to be clever and specialising to use `dcmp` under the hood. I really can't think of any situation where changes will be incompatible, am I missing something? FWIW I absolutely don't claim to be an expert, I'm just someone who's been following along on the mailing lists, so I'm happy to be corrected.
RIP JEE. Guess I'd better learn Play or something.
That's what I'm thinking about too. I mean Java EE actually had a meaning (Java Enterprise Edition). Enterprise profile has a meaning too. But Jakarta EE? What that 'EE' stands for? Jakarta Enterprise edition? Do we have Jakarta standard edition too? I prefered Enterprise profile.
Thing is, if you need to propagate ThreadLocals, can you do it via CompletableFuture? Limit the number of concurrent threads? Join multiple threads so that's there is a hard limit on how many are running at any one time without starving other uses? Retrying a request pipeline on error? Reactive streams also abstract away starting the process, and all the above is a result of that.
Can't imagine the whole Indonesia didn't campaign the shit out of it. 
Senior Software Developer. Recently recognized for 35 years service. I build a commercial specialized web based accounting application (SaaS). On the side I do several things. I build Java programs on Raspberry Pi to control chained 8x8 LED matrix, where each 8x8 LED block is controlled by a single MAX 7219 chip. I have a Java implementation that can drive these chained modules on a Raspberry Pi 1. Naturally it would work much faster on a Pi 2 or Pi 3. It does use concurrent threads (even on single core Pi 1). One thread empties queues of command messages to 7219 chips, forms a command chain and then rapidly clocks these bits out using SPI. One thread drives a rapidly running snake on a module, with another similar thread with a different length snake and different movement rate (just to prove they are different) on another module. One of these 8x8 LED modules is actually a 7-segment 8 digit display (also with MAX 7219 chip) and another thread rapidly shows milliseconds as fast as can possibly be updated on this display, while another thread spins four segments in the upper part of the leftmost digit of the 8 digit display. The whole thing looks very active while running. But it runs on a Pi 1 without problem. So I was pleased. By snake, I mean a length of lit LEDs that moves, when it bumps into an edge, or sometimes randomly, it changes direction and continues. The other lit LEDs in the snake follow the "head" LED. I also build a big Swing desktop application for a friend. 
The most relevant question for the DC area is probably: Can you get a security clearance. And do you mind working in that environment. If you are unclearable then your options will be much, much more limited in that region.
How so?
waaat ? edit: why not Jizz EE ??
How is `javax` package prefix going to be renamed?
Yeah, that's calculating the percentage (hence the ``*100``)
Depends, Dropwizard is still a thing and it is largely built on JEE.
I wouldn't say "on the contrary" but JEE is modernizing like it pretty much always has. Take a popular implementation of something (Hibernate for instance) and standardize the api for it. They're doing the same thing with a lot of spring stuff. It's important to remember that JEE is just a set of APIs with very little actual implementation logic where spring is a full framework.
&gt; Mhhh, but then you would have this weird thing where == tests for identity on all types, except for floating point values (where you need to use equals); Well, not *just* floating points ... for primitives in general. The `==` operator clearly doesn't test e.g. `int` for identity equality either, since `int` doesn't *have* identity. So yeah, there is still a special case here: for types which are statically determined to be primitives, the `==` operator is overloaded to have a different meaning. For types which are statically determined to be *value types*, `==` may keep the original semantics of identity equality (and therefore most likely be a compile time error/warning since this isn't a useful check). Or it could overload to any number of other behaviours, including bitwise equality or even deferring to `equals()`. &gt; and equals which would test for equality on all types, except for floating point values (where you need to use ==). Well no I don't agree with that at all, `equals()` still tests for "equality" on all types. For some definition of equality that hopefully fulfils the method's contract. (Which `Double.equals` does, and so `double.equals` also will.) With floating points there are just a few different types of equality we can check for. Java chose to use two different approaches in different places, which can be confusing to users in the very rare cases that it comes up. This does NOT change at all with the introduction of value types. &gt; If you had some value class _value class Foo { int i; float f; String s; } both equals and == would return a result based on a mixture of identity and equality comparisons. Okay so I've tried to figure this out and I'm really not sure exactly how you think `==` and `equals()` will behave for `Foo`. Can you please clarify *precisely* what you're picturing? The way I see it the default `equals()` implementation for value types could do any number of different things, there are a few strategies that make sense. It could certainly, by default, do the same thing as `==`. Why not? Or maybe it wouldn't. Why would this be so surprising? `==` and `equals` have never reliably meant the same thing before. Any value type can override its `equals()` method just like any reference type can, so obviously it would be crazy to always expect `==` and `equals()` to *always* do the same thing. In this case it's just a matter of observing that `double` is one of the value types which overrides `equals()`.
As a former resident of Jakarta (part of Java) who still live at Java island I have this urge to sue and get paid for compensation.
But why?
Don't fret, it's just a recursive definition :p
&gt;MicroProfile Fault Tolerance provides circuit breaker Cool. What JavaEE standard does it implement? Where is the JCP that describes its behavior? I feel like I am repeating myself. I am just saying that there are areas that are not covered by the JavaEE specs. Of course there are technical solutions on how to solve them. It is just that these solutions are not part of any spec.
`jakartax`
Junior Software Developer. I work at the Missile Defense Agency in a software lab where we build prototypes for future capabilities.
It looks like in your [submission](https://www.reddit.com/r/java/comments/80iotb/grepping_through_java_enterprise_documentation/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Title: Security Engineer but that because no one has changed it lately... What do I do? I fix thing and implement new things ;) Full stack using: Java, javascript/html/Cass, flash, python, Perl, pascal, bash, raged. There is even a custom parser in there with a homegrown syntax.
Copyright reasons.
That breaks backwards compatibility.
Isn't Jakarta another name for Tomcat?
I live in Southeast Asia, so I don't like that name; because, to me, Jakarta is a not good (or terrible) city. Java is a cool name, because, to me, it is just an island where coffee grows. If I had right, I would choose another place (in Indonesia, Brasil, Vietnam,...) where coffee grows. Jakarta is a terrible choice.
Hobbyist. I specialize in "Hello World!" systems and crappy games (I use the crappy games to both learn and practice new concepts). 
I use [Grails](https://grails.org/) professionally to build web apps. It is built upon Spring, uses the Gradle build system, and Hibernate for ORM. You can use Java, but it's meant for [Groovy](http://groovy-lang.org/), which you may really appreciate coming from the dynamically-typed world. I personally really like Groovy, as you get the power of the JVM without the overly-verbose syntax of Java. Grails is a mature, well documented framework. You can use React with it, and many different database technologies as well. We deploy to Tomcat containers, but you don't have to. Auth is provided by Spring, which is great, and testing in Grails uses [Spock](http://spockframework.org/), which is also nice. Check out their handy [app forge](http://start.grails.org/) to get started, and try some [tutorials](http://guides.grails.org/index.html).
Spring Boot is my Go-To unless I have reason to choose something else. It covers most of the stack really well. It also runs out of the box basically configured unless you're doing something really weird/custom. If you follow SOLID design it works really well though. My last several projects I've spun up through https://start.spring.io/ Name your project. Define it's maven coordinates, select the modules you want included (advanced mode gives you a full list of all the available options), and it gives you a pre-configured pom file you can import into your IDE. I basic REST client can be up and running inside an hour, and it can be built on very easily to build out all the features you need. Regarding your list: * Bundler: I prefer Gradle. Spring appears to favor Maven, but both work. * Testing: JUnit with AssertJ. AssertJ just gives better error reporting, and the asserts are more intuitive. * Authentication: OAuth is nice if it fits your use-case. Most of the headaches can get outsourced to a third party authentication client (Facebook, Google, GitHub, loads more). I used Scribe: https://github.com/scribejava/scribejava * REST: Spring Web or Jersey. I have more experience with Spring Web, but others on my team swear by Jersey. * NoSQL: I've mostly used DynamoDB through AWS. Otherwise I've used MongoDB configured by SpringBoot. I'm not sure which driver it uses, but it works out of the box. * ORM: Java Persistence API. Again I use Spring's JPA module. * Dependency Injection: Spring... you probably saw that one coming. * Network Clients: I don't have a favorite here. I do more really light HTTP work, so Java's HttpClient works in most cases. Jersey's HttpClient is a nice abstraction if you're doing more advanced stuff. If I were to setup a simple REST server to support an application I'd do the following: Use Spring Initializer (https://start.spring.io/) to create a new Spring project with Web, Security, and JPA modules selected along with your favorite DB implementation. Download it as as a Gradle project. That comes pre-loaded with JUnit for testing, but I'd add AssertJ to make my life easier. Finally if needed, I'd include Jersey to get access to the Jersey HTTP client if I need to make additional REST calls from the server. Assuming you're going to be working with JSON requests and responses from your app. I'm a big fan of Gson for JSON parsing, but Jackson is also popular (https://github.com/FasterXML/jackson) 
Hmm… One thing I'll miss about JEE is that the application is decoupled from the socket(s). This can let you do fun tricks like listening on a Unix-domain socket instead of TCP.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Take a look at [light-4j](https://github.com/networknt/light-4j) and related frameworks. They meet all your requirements and more. I am one of the authors. 
Catalina
I looked it up, Tomcat is an ex-Jakarta project.
Are we just going to pronounce it gee now like "gee golly wiz"? Fuck me.
&gt; there is more demand in jobs that use Java than Node in my area That's because you'd be hard pressed to actually build giant business applications using Node. They be slow as frozen molasses. They're two different things.
i wrote a database [db4j](https://github.com/db4j/db4j) that's targeted at this use case and have been working on demos - the schema and queries are just pure java. instead of node-style callbacks, i use [kilim](https://github.com/nqzero/kilim) which uses bytecode weaving to convert imperative code into async for REST i either the builtin server provided by kilim or spring boot (just because it's popular) with deferred results and maven for packaging 
The long version is learn how to build a web application using JavaScript that calls your Java programs through an API. This is how most software is architected now since what you can do in the browser is tends to easily outstrip what you can do in a desktop GUI application in terms of look-and-feel. Back in the day the Java library had the window toolkit AWT, which was then succeeded by Swing, then JavaFX. This allowed you to create GUI applications on the desktop. But they just feel clunky and look old. With the browser method it's more portable so to speak. If you wanted to distribute this program you could just host it on a site and direct people to the site, rather than have them download and run a Swing/JavaFX app bundled in a .jar or other executable.
Trust me I got exactly what I wanted, even from you :) 
Thanks everyone. All your comments were excellent. 
I have recently started using ActiveMQ with STOMP.js (mqtt also supported) for websockets in my React apps. Makes it super easy to push data to react from any language or app.
It depends on complexity. Spring boot has the must support for any java framework and I wouldn't use anything else. I have and regretted it. Use an orm. Not an expert in that. I don't know about NoSQL orm stuff. I also use elasticaeach and solr. I've used orms and rolled custom and always wished I'd have used an orm. Data storage depends on requirements. Nothing wrong with MySQL (mariadb) or postgresql if the domain makes sense for it. I use maven and not gradle but it doeant much matter. Use whatever is easier. Its not going to make much difference so use what's easier for you. The newer junit is good. I've just been using assertj and I've liked that. Having used a bunch of web servers I still use tomcat but it's not really important. You want to spend ur time developing and not deploying. Use whatever ur most comfortable with. My big suggestion is to use restful ajax to react and avoid any server side rendering. Use redux and sagas. The extra complexity upfront is well worth it later. Again it depends on your complexity and desired maintainability.
You can't copyright the name of a thing. Do you mean trademark reasons? 
100% this. Don't want your time trying to reinvent the wheel, Boot has all the pieces and does it well.
Grails is excellent and the Spock testing is fantastic.
I would like to point you to https://strolch.li It is a different framework to the Spring and other similar types, as the model is defined as an abstract model, where you always have the same three types of objects: Resources, Orders and Activities. The fields are mapped as Parameter objects, of which all the primitives are available. The nice part about this framework is, that you can be up and ready in a matter of minutes, and start building your project immediately in that you open your favourite XML editor and start modelling your data. Once your data is defined, you write your business logic in the form of Services, Commands and Queries. There are many predefined services and commands to manipulate the object model, so that you write your own services when you need to enforce special business rules. Through the use of Policy objects, you decouple algorithms from your object model, so that at runtime you can change the behaviour, or easily implement different behaviour depending on your customer. For instance you might have a simple billing service which performs a few preparatory steps, and then calls the configured billing policy to execute the billing depending on the customer, or the warehouse, etc. And of course persistence is as simple as configuring the persistence handler, pointing to your RDBMS and then setting the mode to CACHED. For you as a developer there is no more thinking in terms of SQL etc., as this is completely hidden from the developer. There is even a simple file persistence layer if you are running on IoT. The runtime can be just about anything. Usually it is run inside an Apache Tomcat instance as a webapp, but this is just because a WEB UI was always required. You could just as well use Java SE and start the server using a main class. Calling services in the Strolch container is usually rest, but also this is totally up to you. Strolch is being actively developed, we have quite a few ideas on how to enhance the API. There is a Polymer Inspector component which makes it easy to see and manipulate the actual data. We are redesigning the query API to be much easier to understand, a new SQL style query API is nearly finished which makes it easy to perform queries from a client e.g. the browser. If there are questions, then don't hesitate to ask. Yes, Strolch is very different, but the concept has come out of the planning and execution segment, and has been refined over the years until it has become what it is today.
For hhtp clients, retrofit.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I've said it before: It's a very weak brand name.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
wondering the same... what does EE stands for? can't find where it is stated. and did the people vote for this name without knowing what the acronym stands for? or was it explicitly stated in the poll? 
&gt; why not Jizz EE Because you didn't propose it when names where proposed?
&gt; Take a popular implementation of something (Hibernate for instance) and standardize the api for it. "Take", since it was Having King, the Hibernate father and lead at the time, who designed most of the JPA API. &gt;They're doing the same thing with a lot of spring stuff. What "lot of Spring Stuff"?
Happy cake day
Nice, these guys have really picked up the pace recently.
And if you want a DI framework on top of that stack without going full spring, guice is a good choice.
they needed a name starting with J
What die you mean with no di but ioc style.?
&gt; NoSQL: I've mostly used DynamoDB through AWS. Otherwise I've used MongoDB configured by SpringBoot. I'm not sure which driver it uses, but it works out of the box. You could also consider CosmosDB on Azure (and deploy the apps on Azure). Spring Boot comes with some dependencies for it (search for azure on Spring Initializer dependencies. And [CosmosDB](https://azure.microsoft.com/en-ca/try/cosmosdb/) has flavours for MongoDB-based apps, Cassandra-based, SQL API, and classic key/value style. And it is distributed NoSQL database.
For old stuff it's not - Oracle. said they accepted it would have to stay as is. New stuff will probably be in a different package though.
they be calling you by "Junior Developer" ? That's funny 
CR Analyst - Logging / Reporting systems - Complete stack from frontend to backend to database dev - self made position in the company! - Currently on PHP, but re-writing the birds-nest in Java (and upgrading)
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/indonesia] [Jakarta EE is the new name of Java EE](https://www.reddit.com/r/indonesia/comments/80llcx/jakarta_ee_is_the_new_name_of_java_ee/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Well, most of them don't care about this one. So they won't campaign it.
Haha... we know that Jakarta EE would win. *Disclosure: I'm one of the mods of /r/indonesia and occasional Java programmer.* 
It looks like in your [submission](https://www.reddit.com/r/java/comments/80ltpv/do_i_have_to_always_bind_mysql_results_to_a_class/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I just assumed that grails was not relevant anymore. Why would you use it over an SPA framework with a rest backend
IMHO Spring Boot is the most complete framework. Just look through their tutorials. It;s really easy to start. Just for lightweight rest services SparkJava (sparkjava.com) is really cook and reminds me Node.js. Good luck.
I also recently came to java from ruby world. I used to use sparkjava on projects in the past (i use sinatra in ruby), but the project looks quite inactive. I ended up using javalin (https://javalin.io/) for now. It is similar to sparkjava, but seems better and more finished.
And I sit here and enjoy my lambdas in Java 8
.......then f*ck Java and continue using Node.js? ;)
I hate adding unnecessary libraries.
Honestly, if your goal is junior development I think you're fine. You have a degree, work history, soft skills that many Juniors won't have, and a portfolio. I think you'll be more than competitive. 
Yea, I designed and built a grails app at my last job. I just don't really see what challenges it addresses nowadays
Stealing innovation from Spring and labeled as "standard" without any due respect.
Does not apply to package names...because if it does, we are fucked beyond hope.
It means “I’m confused”
Really useful! Having HTTPS would not hurt though :-)
OK, thx!
It's insanity. Let's start a pool for when it will be abandoned.
The reason 9 had so little in it was because of the long release cycle. A lot was stripped out to try and get jigsaw out the door. Other languages have fast release cycles and you end up hardly noticing them.
Jesus EE.
* Build: maven, but Gradle would be fine * Testing: Junit, Mockito, Hamcrest * Auth: Spring Security * REST: Spring Data REST * Nosql: I use postgres, nosql is for the birds * ORM: Hibernate - I'm familiar with it and hate it always. * DI: Spring * Network clients: Spring has a nice web client, but I usually use the apache clients due to my familiarity with them. 
The number of jobs online is sometimes a result of the difference between a technology's enterprise employee mindshare and (employable) developer mindshare. So the fact that there's lots of jobs online may just mean that very few employable developers are interested in it. 
I wish I had lambdas. :(
People said that about the Firefox release cycle, and it's worked very well in practice. Before the change, each major release would take forever to come out because it was so hard to stablise major tranches of changes all at once - and then get criticised for switching things up without getting feedback. After switching to a six-week release cycle, people barely notice each update, yet they've successfully landed major rendering and architectural changes with barely a ripple. I'm certainly prepared to give it a chance for Java. It's going to take a bit of a change in mindset though.
NoSQL has very particular uses; I'd say don't use it unless you can prove you need it for something traditional SQL databases can't do.
Or ART.
I wish i had fancy auto-closables.
They really do, I didn't expect an RC this early after the 11 release. What a pleasant surprise. ---- Here's a list of the changes for the impatient: ## Quality Risk * [[WFLY-9869](https://issues.jboss.org/browse/WFLY-9869)] - Pure HTTP EJB invocation not working ## Component Upgrade * [[WFLY-9789](https://issues.jboss.org/browse/WFLY-9789)] - Upgrade RESTEasy to 3.5.0.Final * [[WFLY-9836](https://issues.jboss.org/browse/WFLY-9836)] - Upgrade jboss-jsf-api_spec to 2.2.13.SP2 * [[WFLY-9843](https://issues.jboss.org/browse/WFLY-9843)] - EJB HTTP client 1.0.10.Final * [[WFLY-9865](https://issues.jboss.org/browse/WFLY-9865)] - Upgrade jastow to 2.0.3.Final * [[WFLY-9891](https://issues.jboss.org/browse/WFLY-9891)] - Upgrade picketlink to 2.5.5.SP9 * [[WFLY-9912](https://issues.jboss.org/browse/WFLY-9912)] - Upgrade to Artemis 1.5.5.jbossorg-009 ## Enhancement * [[WFLY-8875](https://issues.jboss.org/browse/WFLY-8875)] - Improve exception when injecting EJB Local Interface Proxy loaded from two different classloaders * [[WFLY-9552](https://issues.jboss.org/browse/WFLY-9552)] - Enable JBTM-2955 ## Feature Request * [[WFLY-9825](https://issues.jboss.org/browse/WFLY-9825)] - Microprofile REST client 1.0 support ## Bug * [[WFLY-5459](https://issues.jboss.org/browse/WFLY-5459)] - Rename JGroups-related attributes * [[WFLY-9346](https://issues.jboss.org/browse/WFLY-9346)] - Race condition during ORB startup * [[WFLY-9403](https://issues.jboss.org/browse/WFLY-9403)] - Unable to deploy clustered ejb in a mixed domain. * [[WFLY-9567](https://issues.jboss.org/browse/WFLY-9567)] - Setting 'eclipselink.archive.factory' property should NOT depend on 'eclipselink.target-server' being set * [[WFLY-9635](https://issues.jboss.org/browse/WFLY-9635)] - jdr throws IllegalArgumentException if server is not started * [[WFLY-9706](https://issues.jboss.org/browse/WFLY-9706)] - Newly added InfiniteOrPositiveValidators to messaging attributes should just print warning if negative values are not -1 * [[WFLY-9746](https://issues.jboss.org/browse/WFLY-9746)] - Revert JGroups capability reference to ChannelFactory * [[WFLY-9752](https://issues.jboss.org/browse/WFLY-9752)] - Failure to read deployment resource on some WS deployments * [[WFLY-9821](https://issues.jboss.org/browse/WFLY-9821)] - SingletonProvider may be incorrectly initialized with RegistrySingletonProvider * [[WFLY-9840](https://issues.jboss.org/browse/WFLY-9840)] - batch-jberet subsystem export should exclude the correct path * [[WFLY-9845](https://issues.jboss.org/browse/WFLY-9845)] - @Singleton @Startup classes inheriting from a class containing a @PostConstruct method will not create a transaction * [[WFLY-9848](https://issues.jboss.org/browse/WFLY-9848)] - JMS CDI extension uses old version of addAnnotatedType * [[WFLY-9850](https://issues.jboss.org/browse/WFLY-9850)] - wsprovide fails on HPUX machines * [[WFLY-9857](https://issues.jboss.org/browse/WFLY-9857)] - wildfly-clustering-infinispan-spi brings in unnecessary/duplicated dependencies * [[WFLY-9861](https://issues.jboss.org/browse/WFLY-9861)] - Optional dependency causing failure in WS EJB tests * [[WFLY-9862](https://issues.jboss.org/browse/WFLY-9862)] - SecurityCommandsTestCase uses the wildfly-core test runner instead of Arquillian * [[WFLY-9863](https://issues.jboss.org/browse/WFLY-9863)] - Remove dependency on unused ModuleIndexService * [[WFLY-9870](https://issues.jboss.org/browse/WFLY-9870)] - Intermittent failure in InterDeploymentDependenciesEarTestCase * [[WFLY-9871](https://issues.jboss.org/browse/WFLY-9871)] - Intermittent failures in CompensationScopedTestCase * [[WFLY-9872](https://issues.jboss.org/browse/WFLY-9872)] - JspTagTestCase fails intermittently * [[WFLY-9873](https://issues.jboss.org/browse/WFLY-9873)] - ServerReload should wait before checking process state * [[WFLY-9882](https://issues.jboss.org/browse/WFLY-9882)] - Intermittent failures in syslog audit log test cases * [[WFLY-9883](https://issues.jboss.org/browse/WFLY-9883)] - EAR deployments are creating unnecessary and wrong EJB ModuleDeployment services * [[WFLY-9884](https://issues.jboss.org/browse/WFLY-9884)] - WeldResourceInjectionServices runs into NoSuchElementException when deploying multiple EJBs * [[WFLY-9885](https://issues.jboss.org/browse/WFLY-9885)] - elytron security configuration is ignored in RA connection definition * [[WFLY-9897](https://issues.jboss.org/browse/WFLY-9897)] - getBytes(); calls should be replaced with getBytes(StandardCharsets.UTF_8); * [[WFLY-9898](https://issues.jboss.org/browse/WFLY-9898)] - Fix description of eviction size attribute * [[WFLY-9905](https://issues.jboss.org/browse/WFLY-9905)] - JAX-RS client builder cannot be bundled in deployment * [[WFLY-9906](https://issues.jboss.org/browse/WFLY-9906)] - SessionManagementTestCase fails intermittently ## Task * [[WFLY-9637](https://issues.jboss.org/browse/WFLY-9637)] - Remove uses of "new OperationFailedException(ModelNode)" * [[WFLY-9743](https://issues.jboss.org/browse/WFLY-9743)] - WildScribe: use strike-through for deprecated model attribute/operation/children names * [[WFLY-9841](https://issues.jboss.org/browse/WFLY-9841)] - upgrade org.jboss.spec.javax.enterprise.concurrent:jboss-concurrency-api_1.0_spec to 1.0.2.Final * [[WFLY-9866](https://issues.jboss.org/browse/WFLY-9866)] - (EE8 mode of) module javax.faces.api needs a dependency on javax.websocket.api * [[WFLY-9868](https://issues.jboss.org/browse/WFLY-9868)] - Add Elytron module dependency to wsprovide wsconsume
Not the OP, but I assume he means passing dependencies in via constructors. 
Do DI implies that _something_ is injecting the dependencies. This is often automated with Guice or Spring. But sure, it could be manual. IOC in my mind is more general and implies that objects are not in control of their configuration and dependencies, that they're configured externally.
This release model doesn't slow down features, but it also doesn't magically make them get implemented more quickly. It just means that short-term and mid-term features aren't *held back* by big features, as has frequently happened in the past. *Which means we get stuff more quickly.* This is very important at the moment when there are a lot of different things on the horizon with various different, difficult to predict timescales (panama/metropolis/valhalla/amber/loom/etc.) It would be silly for Oracle to keep boxing themselves into a corner by trying to put a schedule on everything, experience has shown that this always goes wrong. It just means they have to put more and more resources into working on delayed projects which starves everything else.
The only Enterprise edition of any city was [this one](http://www.imdb.com/title/tt0708455/)...
It's the classic waterfall vs agile debate, honestly. Trying to plan everything in some grand plan more often than not results in slipping deadlines and being unable to react to changing requirements and information that comes up during development. The new semi-annual release cycle means we won't have a repeat of Java 8 and Java 9, releases that took FAR too long to get out the door because larger features needed more time to cook preventing us from taking advantage of the smaller ones.
How long did you spend at each of those stages (if you don't mind me asking)?
NoSQL is a really broad term ... it covers a huge range, from document-oriented databases like MongoDB, to key-value stores like Redis, to graph-databases like Neo4j ... and many other styles of data storage as well. For most of your other requirements, it's enough to say "REST" and people can recommend stuff right off the bat. But for NoSQL I really think people need better insight into your requirements (including, for a start, why a RDBMS is no good).
for anyone else wondering, he meant Gavin King
I'm not sure Java 9 is so useless for most developers. At least on my project I'm very keen to upgrade. The only reason we haven't already is that it breaks backwards compatibility in so many ways, that upgrading is surely a large project. But there's actually quite a lot of improvements in 9 that are quite subtle but I know we can benefit from. We will benefit quite significantly from Jigsaw, because we do encounter dependency conflicts in our app (Guava conflict was found just today!), from the better support for fibers (via Quasar), from named classloaders, obviously from better performance and less memory usage, our startup time is poky so we could also benefit from AOT and AppCDS. Just in general there's three years of improvements and although they may not be big changes to the language, we already use Kotlin so language improvements don't matter so much to us anymore. Whereas a better JVM does.
&gt; The double NaN value is already not "identical" to itself. From my understanding it is. `vcmp` is specified as bit-level indetity, including floating points. &gt; In fact foo1 and foo2 will alread have very different identity and equality behaviours because they contain a String. I apologize, I was to lazy to write out `var s = ""`, that's what I intended to convey. &gt; But we probably don't actually have to worry about this, because no, value types do not have identity. According to the spec, they have. I think the nomenclature java people are using is a bit confusing in this regard. When they say "identity-less" they mean that value types have no fixed reference-type hashcode or locking operations. &gt; You imply that you expect == on a value type to do a component-wise == check. I think that is the current state of things. &gt; it is almost certianly not an interpretation shared by the language designers here I think it is, I'll look up the latest slides and link them. 
"This release model doesn't slow down features, but it also doesn't magically make the biggest features get implemented more quickly." I agree and I'm not expecting that to happen. I guess I will be more convinced when I actually see these features materialising. It would be interesting to see in four years time whether we did get some good stuff earlier than we would have with the current release model. In the meantime, we have had to pay a cost for this (support cliffs for LTS) and so I remain sceptical until I see something significant that is worth upgrading to (beyond keeping on a supported version). At the moment, there is nothing in 9 or 10 that makes me want to do that but I do look forward to seeing if there will be something in 11.
Thanks. I suppose I should mention that I have dabbled with Android development. I built a single JAR file that includes Jetty (not using a framework) and provides a mini web interface to control a RelayDuino... http://oceancontrols.com.au/KTA-223.html The RelayDuino is connected by serial port over USB. You launch the JAR and it provides a web server. (No visible UI on the machine you launched it on.) Open browser to the mini server and have full control over the RelayDuino's relays, see it's digital and analog input states. Also a button to keep rapidly updating the state of analog / digital inputs on the web page. Multiple RelayDuinos can be daisy chained together via RS-485 with only the first RelayDuino plugging into computer via USB. This project can control relays or view inputs on all of the daisy chained devices. The single JAR was meant to run on Raspberry Pi, which it does (on a Pi 3). It also happens to work perfectly on Linux desktop or Windows desktop if you plug the USB of the Relayduino into the Linux / Windows PC. I had to do a bit of research to find a cross platform way of using serial ports. I also had to get this JAR to run as a background service on a RasPi when it is booted -- with no user interaction or logging in. In the process I researched and learned how to modify a Pi's linux to run from a Read Only SD card. I don't own this project which provides a mini web server to control RelayDuino, but I wrote it for someone. 
Not everything is, or should be, an SPA.
There was a really interesting stack posted in the Kotlin subreddit (if you're willing to check out another JVM language). http://adavis.info/2018/02/graphql-api-in-kotlin.html
Join us in "Oracle product that is certified only to use JDK 6" land!
I wish I had reified generics.
Can I ask why you're switching back to Java from Node? Just curious.
Spot the redditor who didn't get the meme
I'm indifferent to what it's called. Just, that if I was new to the Java world and I heard someone say Jakarta and then go 'eee' 'eee', I would have a hard time not giggling. It took me a long time to get over 'hadoop'. ; )
Feel free to contribute: https://github.com/Zortax/ZReddit
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
10,000 upvotes. Spring is godawful. ORM is an antipattern. NoSQL is a meme. simplicity trumps all.
Senior Consultant, nowadays I build teams and processes.
Maybe you are looking for refinement types? some way to say public Integer @Positive whatever(Integer @Positive a){ } and get compile type error if a can be negative, or any path in whatever returns a negative value? [Checker Framework](https://checkerframework.org/manual/) may be usefull, if that's what you want
I was referring to the `ucmp` part, not the `vcmp` part of it, haven't heard any news on that. The bit about `acmp` is from my understanding related to how existing code should behave if it receives a value type. The only thing I inferred from it, is that `ucmp` exists, and works the way as I described. &gt; I still think the behaviour this creates is perfectly fine, some classes override equals, and double will be one of them. The problem is that `double` would end up with only one behavior, but if you want to avoid boxing (which is one of the core points of Valhalla) it is necessary to support both identity _and_ equality. Otherwise, it wouldn't be possible to express semantics that existed in an erasure world in the new specialized world.
Are all new JVM features being simultaneously incorporated into Graal?
How exactly does displaying all of the source code for an entire scenario add any value for troubleshooting? It doesn't. Being able to view the data that caused the problem is what is most valuable when assessing a failed scenario.
Principal Architect - I write APIs (spring boot, spring cloud), lead data ingestion with Spark, Spark Data, and Azure into our datalake, and I write anisible/terraform for our pipeline. Learning Kubernetes currently.
most complete for what? :)
I'm reading this and I'm amazed of how much things I need to learn. Currently, after 10 years of C++ embeded , I'm switching to Java. I try to hang in the Java subreddit to get a grasp of what's ahead of me and how to invest my efforts to become employable as a Java programmer, but I have to say this: there are a tremendous amount of frameworks that are used on a regular base and it's frightening. Sorry for any grammar / spelling mistakes. I'm not a native. If I would have known English better, I would have wrote everything correctly.
Cool! Our coworker did something similar years ago, but for [jconsole](https://en.wikipedia.org/wiki/JConsole): https://arnhem.luminis.eu/top-threads-plugin-for-jconsole/. See also https://arnhem.luminis.eu/new_version_topthreads_jconsole_plugin/.
**JConsole** JConsole is a graphical monitoring tool to monitor Java Virtual Machine (JVM) and Java applications both on a local or remote machine. JConsole uses underlying features of Java Virtual Machine to provide information on performance and resource consumption of applications running on the Java platform using Java Management Extensions (JMX) technology. JConsole comes as part of Java Development Kit (JDK) and the graphical console can be started using "jconsole" command. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
[RTFM](https://docs.oracle.com/javase/tutorial/uiswing/concurrency/dispatch.html) /r/javahelp in the future
Thank you!! 
That's good to hear. I'm not looking for anything fancy, but I feel like I do have some skills that should be worth something.
Seriously consider using kotlin.
I mean, spring still uses a lot of ee components. And ee isn't half as bad as it used to be, with the added benefit of not having to use spring.
It would be nice to hear more success stories attributed to jigsaw.
Because I think I might want to land a backend dev job and lots of them use Java.
Considering that I exclaim that out loud when I see a bunch of bullshit code, it'd actually be a pretty good name
not a popular opinion apparently.
I'm a Senior Developer. My boss asked me to remove "Java" from the title because he wanted the flexibility of giving me non-Java related work. So I do mostly Java, and a little .NET. I have design and maintain various web and backend applications.
For frontend dependencies webjars is pretty nice and plugs into spring easily.
What are you talking? Netty has been pretty stable, Spring Framework 5 non-blocking is based on it (WebFlux and WebClient).
Grails sucks compared to just using Spring Boot with Kotlin. It's taking a solid-ish foundation and spreading an extra layer of bugs on top.
i'm indonesian programmer and last project that i know use J2EE is like 9 or 10 years ago. Usually we use spring here.
Just tried out the AOT in Windows. Seems to work. I did, however, have to install Microsoft's link.exe tool to get it to work.
i wonder how you randomly ended up in here to shitpost 
did he say rod johnson? lol
it seems strange and arbitrary to associate a language with a cloud platform.
&gt; I'd use the language that is the best fit how is any language a so-called "best fit"? this seems like a nonsequitur.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Jahova EE?
I wish I had a JIT compiler.
I also wish I had a collections framework.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Netty does not provide binary compatibility across minor versions as a policy.
Add your stuff to GitHub. Work on it a bit now off GitHub and landing a junior position will be quite easy
&gt;Java developers have spoken, and we’ve listened. Probably there too few dot Net shops around in the business world. So Java devs haven't spoken, they just did nothing 😈 So nobody simply used this API. And Microsoft isn't any more in the position to ignore well established tech stacks. Great to see that they are forced to join the Java and open source world more and more! 
"Java" is TM'ed. Sincerely, it is fair. No one can go around and create an "Apache MyLIttleFramework" without Apache Software Foundation giving the right to use their name. Or Eclipse Foundation as well. And Apache is very protective of their brand (and rightfully). But Apache Foundation did a nice thing: they allowed the Eclipse Foundation to use the word "Jakarta" (TM'ed by them), for this particular use. Good stuff.
Great post, not java
It does apply, but it is damn easy to switch. Recursive text replacement with grep+sed and you are good to go
Oracle said it will open source Flight Recorded and all commercial features.
Link to repo: https://github.com/microsoftgraph/msgraph-sdk-java 
I hope it does not (legally), in the same way that APIs are not copyrightable. Because if it does, then it is some fun to have. For example, you have a system and added support for a product. So the support classes are inside a package with the name, that is a trademark violation? Is mentioning the name of the product in your comments then also a trademark violation? How about the documentation? And now comes the kicker, if that is all a trademark violation, that means that we could prefix all function names with the trademark and nobody can use these functions, neither when using the library/application/API nor when building a compatible API...because that would be a trademark violation.
I think I'm not getting hung up on the wording. The issue with this approach, as mentioned, is that it works inconsistently for composite value types.
&gt; It's easy to say a brand name is weak Absolutely. It's hard to create a good brand. In this particular case, it's *very* hard, because the old brand was rather controversial already, given the long-time stalling in progress of the different JSRs, etc. I wonder if someone ever considered actually asking experts in the CI/CD field for this. &gt; in the early days of it's existence By choosing "Jakarta", the brand inherits around 20 years of history both from Java EE and from the Apache Jakarta project, so I'd say the weakness lies precisely in the fact that it is not in its early days of existence. It's a legacy brand from day 1. &gt; through voting and in the open [Apparently](https://mmilinkov.wordpress.com/2018/02/26/and-the-name-is/) (correct me if I'm wrong), there were 2 choices and both were equally bad IMO :)
J++. Oh wait.
I feel that's on the person themselves and not the title. I've worked with a lot of juniors and some of them have a real drive to learn and want you to ask them the questions and they will figure things out with a bit of guidance. These are the guys you want to keep note of. On the other hand you have juniors who just want to be spoon fed and are horrible to have in your team because they stay junior and are bound to stay at that level until they change their mindset. That's why the position dwindles. They need the guidance because they didn't learn how to learn in university.
you learn and grow a lot more while doing a full story on your own, manage and operate something from a-z. if you just work tickets that state everything you got to do there is nothing you can learn, youre just a code monkey.
Largely? How much of JavaEE do you have in Dropwizard? Servlets? :)
I earn my life with Jav^^Jakarta EE, i couldn't miss this awesome news.
I agree with all of that, except Mockito and Hamcrest. I would suggest jmockit and assertj instead.
For every use case that you actually won't need. ;)
Sure... Make me try to piece a timeline together. ;) I've been CTO for 4 years, was Director for 5, there was a year of consulting after my kid was born, two as Section Head, at least three as lead dev, and everything before that was a mishmash.
We seem to be talking passed each other. My point is not that the extensions themselves are a standard, but that lots of libraries provide features that plug into standard extension points that Java EE offers. Like a socket for electricity is standardised, but the appliance you plug into it is just an appliance. (And btw micro profile is a kind of pseudo spec / open api; its implemented by multiple vendors, but that's besides the point here) 
Dropwizard uses JAX-RS which is part of JEE. Specifically it uses Jersey 2.
But then you need serialVersionUIDs. private static final long serialVersionUID = 2014_09_20_001L; Which means you need integers that can have embedded underscores. 
I'm glad I can have a varargs array as the last parameter of a method. That helps a lot in building miniature embedded DSLs that are compile time safe.
Yeah, it's a good idea to show that you understand and use git
Can we call it Jak EE for short?
&gt; Can we call it Jak EE for short? I will for sure
whatever you're comfortable with. I've never used assertj/jmockit - what are the advantages?
Now $550, more expensive than IntelliJ all products pack
Well now I just cant not see it!
One of the greatest Java classes ever made. Glad someone is talking about it.
As someone who loves futures - no. No way. The API is a nightmare: * names that diverge from the standard monadic functions (`thenApply` instead of `map`, `thenCompose` instead of `flatMap`) * multiple overloadings for the same name with dangerously different semantics * inconsistent trampolining * lacks some incredibly basic and helpful methods (`zip`, timeouts before Java 9) * combinator methods that are badly typed to the point of complete uselessness (check out the signatures of `allOf` and `anyOf`) * an inconsistent model as to when you pass in a thread pool that seems to combine the two worst options (on construction and on each method call) * terrible methods that result from failing to separate futures and promises (`obtrude` and everything related to it) * some of the most confusing implementation code I've ever read. And the thing is, I LOVE futures. They make parallelism way easier to write and reason about. But Java really missed the mark here, and it shows.
I mean if I'm being honest I love it because it made staged futures a fuckong cakewalk. Any better recommendations? I have an extension I made with caching, but I assume your concerns are valid.
I can't say much for assertj. It was used in a project that I joined and I liked it. I don't think that it is more capable than Hamcrest. JMockit is just great. * One style for all. There's not a different syntax if you are mocking something static, no other methods to call * sensible defaults for mocking. If for example you have two mocks defined and call a method one one of them which returns an object of the second mock's type, the default return value is the second mock * when verifying calls, you can mix arguments and argument matchers * ... Check it out, it's really cool.
I've not seen it used nor used it anywhere. It looks like a compounding mess.
I like threads. Threads make sense. Threads work without requiring brain gymnastics or debugging parkour.
&gt; names that diverge from the standard monadic functions (thenApply instead of map, thenCompose instead of flatMap) "monadic functions"? That's a weird way to spell "query comprehension". It doesn't even make any sense in this context. The definition of monad is "an indivisible and hence ultimately simple entity, such as an atom or a person." It is only associated with lists because one programming language, just one, uses monads for query comprehension. And if we want to get all academic and pedantic, the formal term is "projection", not "map". **** Now don't get me wrong. There are some serious issues you pointed out. But don't bury your lead with bike shedding. 
Jak EE, is bad name I think... Is EE good when you go short! 👍
[OpenJDK Mailing Lists](http://mail.openjdk.java.net/mailman/listinfo)
**Monad (functional programming)** In functional programming, a monad is a design pattern that defines how functions, actions, inputs, and outputs can be used together to build generic types, with the following organization: Define a data type, and how values of that data type are combined. Create functions that use the data type, and compose them together into actions, following the rules defined in the first step. A monad may encapsulate values of a particular data type, creating a new type associated with a specific additional computation, typically to handle special cases of the type. For example, the simple Maybe monad encapsulates variables which may have a null value, representing an option type, and automatically ensures that null values are not passed as arguments to functions that cannot handle them, serving as an alternative programming technique to throwing and catching exceptions when null values arise. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/java/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Yeah, don't get me wrong, it's a huge improvement over parallel programming by submitting tasks to an ExecutorService. I'm just disappointed in a number of design choices. While I wouldn't say it's perfect, Javaslang's Future is a lot better in a bunch of ways. It's worth checking out. I think Monix's Task is my favorite future abstraction I've seen on the JVM, but it's pretty much Scala only.
Absolutely, and Loom would be great. But while green threads solve the non-blocking IO problem, you still need futures to do any kind of elegant parallel programming. The designer of Loom and Quasar has pretty much openly said that if you want to do any kind of complex parallel programming, threads alone aren't going to cut it. Actually, before long you realize you want backpressure and stream modeling and have to start using reactive streams, but that's another topic altogether. ;)
Aaaack! Time loop!
Well futures do not satisfy monad laws so it's IMO better that they don't adopt monad terminology.
&gt; Technically, it's still JEE :O Technically, [it's never been JEE](https://javaee.github.io/javaee-spec/JEE).
Man, I just don't like Jakarta, I don't even like the way that word looks lol.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
My official title is "Manager of New Product Development". As the title suggests, I run a group of developers building new things. Current projects involve a full-featured reporting system (etl, api, webapps), and a transaction processing application for the desktop (javafx, jni).
More so as a portfolio
if you say it together it sound like a stripper name I like it, **jakee**
Not everybody is interested in applying functional programming abstractions everywhere just for the sake of it. Optional for example was designed with Limited use cases in mind, which should save us from people applying it everywhere.. which is something you might not be interested in, but that's your personal attitude towards things. Same for futures. You have your mindset, probably colored by functional programming vocabulary. Map and flatmap are only intuitive in THEIR speech - for Java guys the current method names are probably more speaking for themselves. So it should be fine to implement it as it's appropriate - regardless if it makes sense from other target audience's Perspektive. Nothing against your other points though.
So true! but hence the ":O" ;)
LOL I love it when people try so hard to make everything sound like it is a monad.
I tried it out a when play 2.x came with it a couple years ago (I think) and I just couldn't find good docs on it. I think I was trying to build a backend to a simple web app, but I couldn't wrap my head around how to return a response to the page. I could obviously create a response but I couldn't 'block' until the process (what the CF was doing) was completed. So it would return no results to the page but the process was completing. I think I was looking for an 'onComplete' type function. I'm probably just dumb. 
Lagom is a microservice framework by Lightbend as well. I don’t know much about it, but I would think it’d be more lightweight than Spring. 
Can I ask what you mean by trampolining?
This name pisses me off before even using it. Awful just awful!!
AFAIK most major GUI Toolkits will only allow you to use a single thread to draw onto the screen. You can setup parts off scene and then run the update on the UI Thread.
Showing inferred @Nonnull/@CheckForNull inline seems like the most valuable new feature to me (but I'm not an Android developer). I wish they would have expanded a bit what *Support for Spring Boot Devtools* entails.
You don't think it's kind of weird to add three monads to the stdlib, have two of them use the generally accepted method names for monadic operations, and then just grab different names for the third ones? Like, I wouldn't even mind if `thenApply` and `thenCompose` were used everywhere. I just want consistency - the language designers should pick an approach and stick with it. Otherwise, it's confusing to understand that `thenApply` is basically `map`.
You are not dumb, its hard. I've also played with it, and its really not easy depending on what you want to do in the future, the code to be called, what to be returned, and what to do with exceptions. But when you can do it, it work well.
The tech/product has a background/history, but the "brand" (Jakarta EE) is new. So again, it is easy to say a new name sucks, especially for when it is applied to something that already exists. Not that you will ever do this, but if you were to rebrand jOOQ for any reason, you would hear from some users that the new brand is weak and/or it sucks. It's just how humans think. Easier to criticize.
ah ah ah nice one :)
Lifelong eclipse developer. Are there any good tutorials on how to migrate/use projects to IntelliJ for us eclipse users? Mostly tomcat spring projects with maven and svn/git integration. I really want to get into IntelliJ but I want to reduce the learning curve. Any help appreciated. 
[This](https://www.jetbrains.com/help/idea/eclipse.html) might be of interest to you.
I'm seconding this. Spring Boot is ok, but in my opinion it is way too bloated and slow. It doesn't scale as well as vert.x because it's not built with being reactive in mind. It also locks you into doing things 'the spring way' which in my opinion is bad for your development long term. Vert.x on the other hand is very light weight, blazingly fast (it beats node.js in speed and scalability), reactive and has everything you need to build distributed systems, be it a simple CRUD web app or an IoT system.
For UI leading JS frameworks are Angular, React and VueJs. React and Vue have become more popular. You can choose among these 3 based on your requirements.
Thanks for the suggestions. I'm planning to build the back end as a series of REST services (served up with Spring). Googling I also found SemanticUI and Django. Are these tools (and the ones you suggest) good options for building a REST-driven UI?
The enhanced pom stuff is interesting. Wonder if this is in response to what spring is doing with their dependency management plugin. And Jupiter support couldn't come fast enough
Yup.. micro services are a good way to build REST APIs.. reg SemanticUI it is only a CSS styling framework.. would suggest you to build UI using one of the JavaScript frameworks mentioned earlier and apply this Semantic UI CSS framework on top of this UI. You can also apply other popular CSS frameworks like Bootstrap, Foundation etc.. Django is only for use with Python.. it will not work with Java/Spring
It is better than what we had but I agree. There is a lot of gotchas around completable futures that are just non-obvious.
&gt; Yup.. micro services are a good way to build REST APIs.. reg SemanticUI it is only a CSS styling framework.. would suggest you to build UI using one of the JavaScript frameworks mentioned earlier and apply this Semantic UI CSS framework on top of this UI. You can also apply other popular CSS frameworks like Bootstrap, Foundation etc.. Django is only for use with Python.. it will not work with Java/Spring 
Yes because we all know we weren't doing that for all those years back when we were doing it and the code was maintainable.
Wouldn't Optional be called Maybe if it was using the generally accepted method names for monadic operations? I’ve always heard/read about the Maybe monad.
Vert.x is great!
That's the name of the equivalent type in Haskell, but both Scala and Rust go with Option instead.
Oh yes, I forgot about that.
it is honestly not hard to migrate. you won't regret it.
I remember the first time I started using it. I was amazed it detected it was maven and just worked, and I got predictive typing on javasript. All without having to install a load of funky plugins. This was the day after eclipse just decided to stop starting, the git plugin was shit or something. Never looked back. Never get frustrated with intellij.
I don't know, but historically updates have required separate download.
Shit I wrote a java based azure backup utility like two years ago and put it on GitHub in 2016 https://github.com/dxk3355/BackupToAzure
IMO the only thing going against IntelliJ is its license cost as Eclipse is free 'for all'. However, JetBrains has free license for Open Source projects and students. Feature wise IntelliJ beats Eclipse every time.
IntelliJ IDEA's youtube channel is full of tutorials on working with the IDE. I suggest you give it a go. https://www.youtube.com/user/intellijideavideo/videos Despite the learning curve, small or not, switching to IntelliJ would be one of the best things you could gift yourself as a developer. I made the switch after 3 years working with Eclipse. It took me 1 month to master the IDE but I never looked back since then. Off course that was 2010 and now the IDE has greatly improved in the learning curve department. 
Try the EAP (Early Access Preview) which os free
On major version change it requires. They advertise [toolbox](https://www.jetbrains.com/toolbox/) as the tool that is able to update tools seamlessly, check it out. Although it might be a bit of an overkill to manage Intellij only with it.
Downloaded Intellij 2 days ago free version (had no idea free version existed :( ) I am really surprised how well and smooth everything is.
Since this is help with *Java programming*, it should be, as the *plenty hints* on the page indicate, posted in **/r/javahelp**. Please **read** and **follow** the [**Posting Guidelines**](https://redd.it/48eykt) there before reposting. **Post removed**: Programming help
Please, don't start the hollywar here. There is a special topic for this.
Intellij IDEA has a fully functional free community edition. It's mostly missing application server and database stuff.
I've never heard of anyone going from IntelliJ to Eclipse, but *everyone* using IntelliJ started out using Eclipse. I think that tells you everything.
Html and js syntax support and many many more features. 
Using IntelliJ for Scala and loving it
I highly recommend not changing the default shortcut mapping. While it may take a bit to switch the default mapping is a lot more consistent. Ctrl-F: Find. Ctrl-Shift-F: Find everywhere. Ctrl-R: Replace. Ctrl-Shift-R: Replace everywhere. Ctrl-N: Search classes. Ctrl-Shift-N: Search files. Etc.
As far as I know, JavaEE / JakartaEE support is missing from community edition.
No, I don't think it's weird. You are permanently talking about monads, but I doubt that the types in Java suffice monad criteria...and even if so: We're talking about specific implementations of things that you seem to only know as monads. That all those implementations have to be consistent regarding an abstraction that is not present in Java, is something that YOU want, because you think of them all as similar/the same abstractions. That's not what everyone else thinks about it. Don't get me wrong, I like the ideas of functional programming and universal abstractions, but that's something not everyone is interested in, which should be totally fine for you. And so, on an Optional, one wouldn't expect "thenApply", because "then" is something that expresses time relation, or a happens-after relation...which is clearly not optimal for Optional, because there is not "happens". For "map" and "flatMap" on Optional, I guess that they didn't find any meaningful alternative, so they sticked to the fp standard. For futures, they found an alternative, and honestly, thenApply and thenCompose are way more speaking in this context then map and flatMap - again, for people not used to/not "infested" by all the fp abstractions.
Most enjoy IntelliJ more, but this question always gets heated.
Fuck ya!! 
Great news
Provided that you are not using partitions, you should be able to scale your streams via the runtime (for example Kubernetes). At least this is the advice that Richard Seroter gives in his excellent pluralsight course: https://app.pluralsight.com/library/courses/java-microservices-spring-cloud-coordinating-services
Well... that was quick
I have had no trouble hosting a few ASP.NET Core 2.0 apps on Linode servers. 
Maybe it's the application that has an error rather than Java? Can you see any stack trace when you run from the command line? Have you tried more than one GUI application? Java won't just be 'being a jerk' for no reason - there will be a technical problem and the logic of the program is probably causing Java to close the window.
 java -jar &lt;foo&gt;.jar from a command prompt...then you'll see the error.
Thanks Cagatay!
Windows is closing the window on you because the jar is either finished running or there was an error.
Can't wait to try it with kotlin
I switched to using Toolbox and it made life easier than playing the "will this EAP release be a patch or a download" game much easier. If you don't use EAPs, it might be different. 
"unable to access file'. Just don't get it.
Good reminder
The nonblocking Webclient is going be super useful compared to blocking resttemplate for our project.
Weird that the article uses MicroProfile 1.2, but ignores all the actual MicroProfile developed specs. Open Liberty also has a single feature to add for MicroProfile, so you don't need to remember what's in it and add individual ones: &lt;featureManager&gt; &lt;feature&gt;microProfile-1.2&lt;/feature&gt; &lt;/featureManager&gt; https://openliberty.io/news/2017/10/26/microprofile-12-open-liberty-17003.html The Open Liberty site has some nice [guides for Config](https://openliberty.io/guides/microprofile-config-intro.html) and the [Circuit Breaker API in the Fault Tolerance](https://openliberty.io/guides/circuit-breaker.html) spec
These guys make the Java world a better place.
Nice work. The intro is a bit misleading: the author claims to implement the algorithm without variables. Yet their code sample clearly defines and uses variables. 
I've looked through feature lists before but never caught the Docker awareness bit. That's huge, though Spring (which I use at my place of employment) isn't even really ready for JDK 9.
They're functionally fantastic classes. But, Doug Lea is not a very good API designer. The method names are horrible and the strange hierarchy of CompletableFuture and CompletionStage is odd and not very useful.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Downvoted by the pansies who can't handle foul language
109 sounds great, but if you really count JEP 286 in the same counter as e.g. the addition of the `java.jar.JarEntry.getRealName()` method, then that would be a bit sensationalist, would it? ;-)
"News, Technical discussions, research papers and assorted things of interest related to the Java programming language" This is the Java language subreddit.
Please remove the article then, it's containing kotlin related informations. /s
Hell yeah! And built-in Reactor support is also amazing!
How does this compare to Dropwizard? I never really messed with Spring Boot much, but it does have a bigger ecosystem. I'm trying to decide whether I should schedule a day to evaluate it 
Give it a go. On Azure, it has grassy support. Visual Studio Code has SB 2.0 plugin already. And one can find Azure extensions also on start.spring.io. 
I think intellij is built on swing, so if anyone knows about big swing apps it's them!
Retrofit FTW.
cmd-shift-a will be your friend. Everyone at my workplace is switching over and we find it useful. It's basically a hotkey that gives you a search box for any other hot key. I've also installed a plugin that shows a hotkey for any action I do with the mouse to encourage the learning of hot keys. 
I recommend to fuck consensus and use what you like. Do you need consensus of friends to decide on your partner or how you name your kids?
I'm not experienced with either, but my perception is that dropwizard is suited for microservices, while spring boot is more suited for bigger and more complex applications. Dropwizard uses some technologies and just works, spring boot supports a lot of different technologies and can be configured a lot (but less required configuration than plain Spring, unless you want to). 
As someone that is using Spring for over a decade -- basically on a daily basis -- I would say without reservation: YES
Jakarta has maybe few problems, but is nice city 🌃 also.
If your work, and therefore your life, is made easier by something. Then fuck yes it's made your world a better place. I'm guessing you've never use IBM Websphere before.
&gt; `var x = new ArrayList&lt;String&gt;();` Is a bad example for type inference. It results in x being an ArrayList instead of List and it saves you only 3 characters compared to `List&lt;String&gt; x = new ArrayList&lt;&gt;();` 
Where’s Java Concurrency in Practice?!
[It's taken right from the JEP.](http://openjdk.java.net/jeps/286)
By that same token Bosh made the world a better place too. Tons of companies have produced tools that made the work of professionals in all kinds of professions easier. Making the world a better place is super common following your logic.
&gt; Java world
And Bosh for the carpenter world. Every company its own sector.
&gt; I'm guessing you've never use IBM Websphere before. I wonder why Spring fans always have to bring up WebSphere, a monstrosity of a server that even IBM ditched years ago in favour of lightweight, free, and open source Open Liberty. And the Java EE ecosystem is not represented by IBM only, it's JBoss, Payara, and TomEE as well, with many other smaller projects around like DeltaSpike, OmniFaces, PrimeFaces, and others. They made the Java world a better place, too.
&gt; Item 52: Use overloading judiciously What does that have to do with the JEP?
Tomcat 8.x has an EOL in June of this year. So why didn't they target the 9.x series?
Corporative world loves IBM
JCreator ftw
Going by the books listed I think the article author meant "recently published books".
Yeah, but I wondered why a Java 8 book was listed.
It's a superb example as there is no need for ``x`` to be anything other than an ``ArrayList`` 😉 YAGNI 
The things you expect to require endless configuration or just don’t even think about in other editors, just work by default in IDEA. It does the “integrated” in IDE so well. VS too for D3D stuff.
Underscores were inserted at a later time with regex. But the integer values like 20140920001 were in use already.
I was down voted for my name, and post history, I'm used to it :) People hate my main domreddit that I post in, so bots and people auto down vote me. My karma can take it though, lol. 
which even has bash included
Spring Boot 2.0 is now Java 9 compatible
Why does that matter? ArrayList implements List, so any method that accepts List, would accept x. var is only local too. Would you mind to elaborate more on why this is bad practice? 
Bingo! My karma can take the hit though, lol. What's funny is I work with the pivotal guys in Los Angeles.
Ctrl + Shift + A lets you search for things like "replace", then it'll let you select it, but also show you the keyboard shortcut. This way you can learn all the shortcuts as you need them. Its still a great idea to learn the commonly used ones
One never knows for sure why she has been downvoted, except if she is told the reason. 
&gt; Item 52: Use overloading judiciously Another edition I guess: http://thefinestartist.com/effective-java/52 
&gt; List&lt;String&gt; x = new ArrayList&lt;&gt;(); And why would I want that? What's so special about the `List` interface that makes it better than the `ArrayList` interface for local variables? 
I have been using Boot since it was brand new. I am a fanboy but not a shill. I honestly can't imagine using anything else. If you want a one-file sinatra/flask type HTTP endpoint, you can write that in about two minutes. And that dumb test application can then grow to full enterprise project with top notch security/orm/redis/oauth/etc. etc. library support (if you want/need it to). You are right in that Spring has a great ecosystem, and I think the boot team has done a fantastic job making that ecosystem accessible and easy to use.
If you are going with angular, you could look at [PrimeNG](https://www.primefaces.org/primeng/#/). It's a set of ready to use UI components. If those are enough for your project you can skip a lot of design effort.
I'll tell you why. There is a rule in programming summarized as "Program to the interface, not the implementation". What this means is that you should only use the public API or Application Programming Interface for whatever library you're using. Don't mess around with the internals using pointers, reflection, etc. because the internals may change over time. Java makes it hard to use reflection (as compared to the public API), so generally speaking Java programmers never got into the habit of violating this rule. As a result, they tend to not understand the rule. But they do understand that they've got this `interface` keyword. So they reinterpreted the rule to mean that they should never use a class's public interface and instead do everything, literally everything, via abstract interfaces. And that includes local variables despite having zero justification for it. *** So there you have it. Some Java programmers in the late 90's misunderstood something and it became an idiomatic way of writing Java code.
Javy McJavaface perhaps?
Programming against an interface gives you more flexibility. You can just switch out the underlying implementation without having to change to code that uses it. Specialized functionality, in this case e.g. `ensureCapacity` or `trimToSize`, is rarely used.
Nono, you got it reversed. `x` needs to be rarely anything other than `List`. It's more robust code and amenable to change without effort.
This is a great rule, but it does not apply to local variables and in-method implementations, which is exactly the scope of *var*.
Everytime someone from the_donald posts outside of the domreddit they are downvoted. People made a tons of tools to detect if someone belongs to the donald. https://absurdlyobfuscated.com/tagger/ If you want proof, scroll my history, anything in a subreddit is downvoted. Is naive to think otherwise. 
I don't think you actually understood what I wrote.
I love the the term concrete. It helps to perpetuate the myth that it's somehow impossible to swap out classes. 
If you are concerned your code might break by using `var x = new ArrayList&lt;&gt;()` and deciding to change later to LinkedList, then you should avoid methods that do a lot of stuff, like... keep the method block size below 20-30 lines of code. Because length of a method body is the only thing that might make you forget the type of `x`.
Oh, you were unaware that the compiler checks to see if your new type has the same methods as the old type. Also, that's a horrible example. If you access a LinkedList as if it were a List you're guaranteed to get horrible performance. 
Not if you care about backwards compatibility. Methods should accept interfaces yes, but they should return the most specific type possible. That way you can add new methods to that type over time and have those methods be available to clients. *** That's the general rule for interfaces. But Java adds a wrinkle in the fact it no longer has abstract interfaces. Now it has abstract base classes with fields and abstract base classes without fields. 
So you want to avoid a useful method in favor of a slower pattern because you might, under some bizarre set of circumstances, need to change the type to something that doesn't have that method? You are micro-optimizing for changing code that is highly unlikely to change. Please try to come up with an example that isn't utterly ridiculous.
Yup, I'm referencing the third edition.
&gt; Also, that's a horrible example. If you access a LinkedList as if it were a List you're guaranteed to get horrible performance. Sigh. How about you realize midway in production that a lot of inserts happen in the middle of the list. The initial ArrayList better be a LinkedList.
I recommend Dropwizard over Spring Boot personally. It just seems much cleaner and easier, unless you specifically need Spring.
Have you actually tried that? It's not as simple as just writing `new LinkedList()`. Because it has to chase pointers from the beginning of the list, your insertion time is still O(N), except N is the number of elements before the location you want to insert instead of the number of elements after the location you want to insert. And since pointer chasing is involved, you can expect a lot of cache misses. To actually see a performance gain when using a `LinkedList`, you need to either: 1. Be inserting at the beginning of the list 2. Keep a reference the linked list node that you want to insert after. This requires changing a lot more than just which object you constructed. You need to actually change your access patterns. Unfortunately the built-in version of LinkedList is so badly designed that it won't help you. It needs methods such as `addAfter( LinkedListNode&lt;T&gt; node, T value)`.
Those charts are not the easiest thing in the world to read. I do think it's funny that one line is captioned "Readability of string literals containing many". I *hate* it when my string literals contain many.
They should have surveyed the readability of their charts
Gradle 4.6 introduced junit 5 support. Was released a few days ago. It's what I waiting for on my projects
We've tried retrofit, their concurrency model is still based on one thread per request. We can't afford this since we need to do fire 5 concurrent request per incoming client (we have around 500 client per second). This translated to around 2500 threads per second minimum if you want to use retrofit. We need async non blocking reactor based client for this kind of scenario. Our implementation now is based on spring boot 1 with vert.x client for making http requests to the other services.
Given that the Java List interface is broken by design, when I use explicit ArrayLists I at least know what I can do with it. Replace that ArrayList with emptyList() (that "List" allows that) and suddenly all your adds crash at runtime.
We've been using retrofit with RxJava for an API gateway that has big fanout (5-100 dependent requests per origin request and on occasion 1000+), and our biggest problem is that we're saturating downstream services and need to throttle, which Rx is very suited for. I've only had minimal exposure to vert.x.
If you realize in production that a lot of inserts happen in the middle of the list, then my friend, the issue is in your test case :-)
Number of people who think the chart is...: 70% Number of people who think the chart is...: 30%
I've had that experience too. Ironically though, I sent an email about the renewal price last fall and no one got back to me. So, I never renewed. 
Is spring cloud supported?
Yes, it is super common. That's why society as an aggregate moves forward slowly but steadily.
I think Spring Cloud Finchley which is based on Spring Boot 2 is scheduled for release March 29th.
Have you tried http://hotswapagent.org/
Not in a few years, worth a revisit?
That... That I can get behind. Carry on.
It was first inspired by Dropwizard and Coda's work, also Ruby
And this has got what to do with Java exactly? Also - Azure kinda sucks. There are much much much better tools/services/offers out there. Unless you are into AD. But buttplugs is each owns choice. 
It should be interestingly enough for STEM students learning (or already coding) Java and that want to play with cloud computing. Regarding the comment on `Azure kinda sucks`, well all I can say is that services keep improving, and new ones being added. And also "Azure" is not one single service. If one sucked, maybe other 30+ services are not that bad. Just saying... 
Inferring types that are too specific doesn't really matter when it only applies to local variables. That's one of the reasons it's restricted in that way rather than applied to e.g. return types. The scope of the effect of any changes e.g. from arraylist to linkedlist is limited to the method which you're already rewriting, so who cares.
If you have 109 changes / features I think everyone can guess they’re not all the same size ;)
If IBM allows students to use their services without the hassle of providing credit card information, then by all means, please share. I am sure there are Java developers interested in learning Cloud Computing. That's all.
Should we all migrate to /r/jvm or similar then? Java can't be discussed without mentioning the whole JVM ecosystem and other JVM languages.
These students will go on a cloud computing sub, not here...
Promises are extremely useful, but CompletableFuture feels horribly over-engineered to me and I find it very hard to remember the method names or what they actually do. I got so frustrated with CompletableFutures API that I have built my own and only implemented features I actually used. It ended up using slightly different semantics for some methods (e.g. my `Promise:then(Consumer)` does not return a new stage, just adds the callback to a list of callbacks) but in return it got a LOT smaller (both API and LOC wise) and easier to reason about. 
Sure. Thanks. 
I haven't use it in a spring boot project, but it works fine in my normal web project.
At some point, all the boring (yet useful) little changes were grouped in something called e.g. "project coin". Anyway, this is just bikeshedding, so let's move on :)
There's something similar to JRebel, specialized on spring applications: [spring-loaded](https://github.com/spring-projects/spring-loaded)
The article should mention that Apache Harmony was "retired" in 2011 - http://harmony.apache.org/ somehow.
The previous use was for a startup (I think) that after some years didn't see the light of day. The *sub* always had postings for Apache's Maven and the previous admin didn't delete them, so the re-purposing feels correct. 
I am removing this post based on it being not about Java as such. The purpose of the subreddit **clearly states**: # News, Technical discussions, research papers and assorted things of interest related to the Java programming language Even though cloud computing *can* be done with Java, the post is still not relevant enough to be considered *on topic*.
I am pretty sure I can find several posts on /r/java that are not related to the Java programming language. Sad that this was removed because two users didn't like the post, while so many posts unrelated to Java are still around (and rightfully). But the double standards applied here is really... confusing. What is the policy after all?
You should be worried indeed. The funny thing is that "everyone" always seems to want the "inferior" IDEs to die. But when they actually do, and their favourite IDE has won, they'll be in world of hurt and IntelliJ will nowhere work as hard as when it has competition. Same goes for operating systems, mobile phones, CPUs, your favourite framework, etc.
&gt; Sad that this was removed because two users didn't like the post, How can you assume that? We got several reports about this post (and about many of your other contributions).
You should have skipped the bold "At-Most-Once and Beyond!" phrase in your post title (which is not present in the actual article). Even `/dev/null` guarantees "at-most-once" processing ;) 
Thanks, those are some good points that I had not considered.
I did something similar: https://github.com/soabase/soabase-stages
Spring loaded seems to be deprecated. However there is Spring DevTools.
“But microservices and containers are bad” - /r/java
FWIW - I wrote a small wrapper library that makes using CompletableFuture a lot simpler. https://github.com/soabase/soabase-stages
Your instinct is correct. Don't pigeonhole yourself. Java is a fine language for many things, but I can guarantee you that you can't build a career on a single language. 
I'm not sure about the future of Java, but Java 8, functional programming and streams really rekindled the fun I had developing in Java. This still gets me going.
Android Development. That means its for personal uses, too. 
&gt; that you can't build a career on a single language. I disagree to a certain extent. You can definitely build a career on a single language, just ask the COBOL programmers making bank right now. The question, however, is whether or not you can build a fulfilling career that you enjoy on a single language. Some people are fine in that camp, and want to become the best x programmer they can be. Others want more variety. Either path is fine - you don't have to chase the next hot thing to be considered an accomplished software engineer. 
Don't be afraid of learning other programming languages.
Thank goodness that we've finally got native JUnit 5 support!
From everything I've read recently, Java seems to be one of, if not the, most in-demand languages. Here's a few sites talking about it: http://www.codingdojo.com/blog/7-most-in-demand-programming-languages-of-2018/ https://www.informationweek.com/devops/programming-languages/10-most-in-demand-programming-languages-of-2018/d/d-id/1330856?page_number=2 https://www.techrepublic.com/article/five-highly-paid-and-in-demand-programming-languages-to-learn-in-2018/ 
The language is not the problem. Java has just moved to a 6 month release schedule and is cutting edge in many ways and lots of activity in the Java microcosm. The language you use is just a tool to translate your ideas to paper that gets gobbled up by the compiler/VM. What's more important is your grasp of the data structures and algorithms for the problem space and secondly your grasp of the tools to get your ideas to production. This includes an IDE, version control, testing frameworks, deployment and integration, OS tools like bash, sed, awk, grep, etc... I will give you an example, my last job I interviewed for they gave me a programming assignment to grab data from a weather site as a csv file and parse the data to answer questions like hottest day this week and day with the largest deviation in temperature, etc.. They give you a couple hours to write it and then they look at it and discuss your code (data structures, algorithms, etc...) Now, this is a company whose flagship product is written in Java but the interview assignment can be written in any language. I chose Perl at the time as that was the code I used most often and most recently at the time. I got the Job and a few years into the job I was asked to help interview the newest job applicant who made it past the interview gauntlet to the final coding problem (same problem.) When it was time to review his solution I saw he wrote it as a Bash shell script! We hired him too. It almost is never predicated on the language you know. It's more predicated on the problem domain and problem solving skills. That and familiarity with production level tools like VC, CI, TF, and working with Teams via Agile methodologies, etc... Build up your portfolio on Github/Gitlab. Show experience with tools like Eclipse, Junit, Maven, Jenkins. Show experience with a production OS like Linux and all it's tools. These all go a long way to making you marketable. The programming language is just another tool in your tool belt. I have several in mine that I have acquired over the years.
For better or worse, Java is going to be around for the long haul. Talented Java devs will find work got at least the next decade. In some ways, it's the new Cobol. It's not completely stagnant though. Spring brings some of the fun back. There's also a dozen other frameworks. It's also an easy transition from Java to c# if you want to give Asp.net Core a shot. It's got a lot less boiler plate and might help you find some joy. FYI, Struts has a serious securities vulnerabilities (see Equifax.) If you haven't moved to Struts 2, it's a good idea.
Often only the production has a feasible amount of real-life data. You're not going to test for all eventualities.
Source?
Why not okhttp
I mentioned `LinkedList` there but you can imagine any implementation as you see fit such as the fastutil or trove ones.
I've come full circle on Java. It was not the first language I learned, but it's the first one I became proficient in. Then left it for PHP, Ruby, JavaScript, and handful of other excursions. Over the last 5 or 6 years Java, JavaScript, and Ruby are what I still code in. Java impresses me more each release. Both in the language and capabilities of the JVM. At the language level generics and lambdas are super powerful, and bring lots of interesting options for new APIs. At the API level each new release does a great job at standardizing best practices from the best libraries into the stdlib, e.g. Java streams, immutable collections, javax.inject, CallableFutures, and executors have all made significant impact on the collective idea of best practices in the language. Upcoming Java 9 support for reactive streams is another great step. Finally with GraalVM and truffle APIs, I'm firmly convinced that the JVM becomes the ubiquitous"write once run anywhere"platform that Java has promised since inception. I mean just look at the language support of the JVM: * http://www.oracle.com/technetwork/oracle-labs/program-languages/overview/index.html * https://en.m.wikipedia.org/wiki/List_of_JVM_languages I for one am super thrilled about the future of Java. If not a bit nervous that I just can't keep up with the pace of innovation. What I personally have zero interest in is JEE and other large Java Enterprise esque features (eg. struts). Jboss, Glass fish, Wildfly, Tomcat, Jetty, etc... IMO are all old hat Java approaches that just aren't necessary. But that's just a matter of my personal taste.
Non-Mobile link: https://en.wikipedia.org/wiki/List_of_JVM_languages *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^155331
No, don't use a cheap excuse like that. If you are going to defend this pattern, you need to at least spend as much effort on an example that actually supports it. Otherwise you are just mindlessly repeating dogma.
Kotlin is really just Java written in a more simple and less verbose way, and is incredibly easy to learn if you already know Java, so if you wanted to do android development, you're fine. My teacher actually recommended that I just learn Java first, as it would give me a better understanding of how programming works than only knowing kotlin would.
Sorry, but this is not true. Java is still much more demanded language and IMO it would not change in the near future. And I have links to prove my point of view: https://www.itjobswatch.co.uk/jobs/uk/groovy.do is sinking https://www.itjobswatch.co.uk/jobs/uk/scala.do almost 10 times smaller than Java https://www.itjobswatch.co.uk/jobs/uk/java.do Champion of all times :) You can see clearly, how much java is bigger than any derivatives of it.
I feel like I've seen a lot of JEPs lately that are just catching up with features that Kotlin already has.
&gt; functional programming That doesn't even ring a bell yet. 
I think Americans in general work with newer, more innovative tech than us Europeans, and German speaking countries are even less cutting edge than the rest of Europe. It's so weird, just crossing the border to the NL is like visiting a different species.
Yeah, that's bullshit.
and kotlin's just catching up to scala. i'm glad java's seeing a lot of new development and improvements and can't wait for things like project panama
His arse
That Java represents an "ever decreasing slice of the job market" is nonsense. It's ridiculously entrenched and the single most in demand programming language. Struts, though... that really is an antique niche. Make sure it's not all you know. 
This is extremely useful. I know it states that they might consider it in the future, but I wish they put in string interpolation as well.
I'd like to see /.../ for regex's like javaScript. Pattern.compile(/hello\s+world/);
I didn’t say it was Java was shrinking. Just happen to see more Groovy and Scalia job postings
&gt; I figured I'd check out Android development, but those guys are all transitioning to Kotlin While it may be Kotlin, it is still a JVM language (which means you will inevitably be using Java libraries) and there's plenty of documentation, examples, available only in Java. So you have to know at least some Java to use it (ideally you should understand how would Java equivalent of your Kotlin code would look). &gt; I can barely read JS, forget about anything C-related. Python is okay. That's ok, you need just more experience with it. If you feel overwhelmed with options, ask yourself what kind of work interests you more: frontend (JS), backend/Android (Java), embedded/systems level (C), data science/machine learning (python). &gt; Do you have any words of encouragement about the future of Java? I am 100% positive Java will be around for a long time. It's one of those languages will a solid ecosystem which can rely on for real-world big projects. As opposed to some "cool" JS frameworks which require you to rewrite your application every 6-12 months.
Why? And why even have Pattern.compile if, like JS, you'd expect that to be implicit?
A mere 18 years after C#? Yay? What's up next, `a ?? b` in 2020?
That's a good point... var mypat = /hello\s+world/;
Not everyone is into it, I do it when I need to so I can say honestly that I'm up on 8 but I dislike the clash between FP and traditional OOP. They threw in FP in 8 trying to make it cool. It isn't needed but it's here and those of us OOP types are stuck with it. It was a terrible idea and Java deserved better than to have been sabotaged with FP. Streams though, are actually cool. I like the total control of traditional processing but with streams you can put together stuff fast and they seem to execute fast for most uses. They can get a little clumsy but not too bad. 
The OP isn't asking about kotlin.
I don’t understand this mentality. Why are you upset about an improvement?
Is there also a JEP for (scala like?) string interpolation? What would have to be done to create it?
I'm fully aware of that, but he did mention kotlin as one of the modern languages he feels he should be learning instead of Java, and I'm simply saying that learning Java will be useful, because it will be a massive aid when it comes to learning kotlin.
More about the lack of them.
https://www.youtube.com/watch?feature=youtu.be&amp;t=50m17s&amp;v=FdkPHShh628
Have you seen what’s in the pipeline? It’s chock full of stuff!
... but people are trying to improve Java and your deriding their efforts. That makes no sense to me.
Still a bad idea to change syntax for a feature like that. That's how you end up with XML literals or other stringly-typed features as part of a language's grammar. The library solution that exists is just fine and not worth a language feature. I'd argue JS got it wrong.
Too little, too late.
👉🏻 /r/kotlin
Fair enough. Just out of curiosity, why do you read /r/Java if you feel that way?
I don't, I was just randomly sent this link and found it a little bit baffling that it took* Java this long to get this feature. *well, it's not even targeted...
I work for a great company and we're dying for good Java programmers. Previous company, same thing. Java isn't going anywhere anytime soon. The JVM is a rock solid platform and if anything it's just getting more popular. Just about every major player is using it: Google, Amazon, LinkedIn, Reddit. Plus, learning a language shouldn't be a lifetime endeavor. The time invested in problem solving, Java or otherwise is well spent and will pay itself back in whatever language you decide to use down the line. 
If you can barely understand JS, code some more JS. You'll need that language just about everywhere
Using anything but &gt;1.8 gives me phantom limb syndrome in my brain.
I think Gorsuch filled the Scalia job posting, so you're out of luck there. (And so is Merrick Garland.)
Yeah but we get hibernate instead of EF and we get spring. Count your blessings. Spring has a module for fucking everything. If spring-coffeemaker doesn't exist by 2020 I'll be shocked.
Give it a go.
Please don't feed the troll. Both henk53 and copperheadblue are troll and JavaEE advertiser. 
&gt; I figured I'd check out Android development, but those guys are all transitioning to Kotlin Where? I mean that from an immensely curious standpoint. I think it's a bit absurd that I'm still generating getters and setters and I'd love to see "java + refinement from things we learned from java" take off. But I searched glassdoor in my area: Java - 1,074 results Kotlin - 0 So I tried searching nationwide: Java - 64,637 Kotlin - 17 Is there something I'm missing? I'd be happy to be proven wrong. 
Worth it for the regex slashes alone.
But do we cheer at every product that every company brings to market to the degree we're yelling it makes the world a better place?
And you are a Spring zealot? Same difference, not? But the circle jerk mentality lets you think it's okay to say Java EE is bad, but it somebody puts Spring into question it's suddenly a troll. Don't you at least see a little bit the hypocrisy in this?
And perhaps that Apache Geronimo was "retired" as well, somehow, although it was never officially announced. One day they just stopped developing.
This is what I struggle with. I started programming just over a year ago, used java at uni (one year masters course) and then got into a grad program, working with C#. I feel like i have decent understanding of data structures and algorithms (I'm usually all right with kata-like tasks) and the basics of language/OOP principles, but I've been struggling so much when it comes to working with a production side codebase and all the tools that I never had to use during my university courses. I'm talking stuff like integrating with APIs, build tools like Gradle, libraries and all that stuff. I know I just need to practise practise practise but I don't have a lot of time on my hands right now, and it's getting increasingly harder to find suitable exercises and explanations for things I want to learn now. It feels like if you're having a problem with inheritance there's tons of books courses and videos that explain that to you but the information dries up when you move on to frameworks, tools and other things that you need to develop at a professional level, but that's beyond what the usual courses offer. Basically if anyone has any tips, I'm all ears.
I agree with you. We have to focus on solving the problem, implementation can be in any language. 
I feel like you are focusing way too much on getting certifications. I would suggest that you better build your data structure and algorithms skills. Anyone can write a program in any language if their concepts and logical thinking is clear. Also you would recognise that all the major languages are 90% similar. So you can learn other languages easily as well.
Not yet. All JEPs are listed [in JEP 0](http://openjdk.java.net/jeps/0), so you can take a look yourself. I believe the correct way to propose an enhancement is through the [Java Community Process](https://www.jcp.org), but I haven't looked into that myself.
I recommend this short video: https://www.youtube.com/watch?v=bFcaO1pXzws I made the switch after many years using Eclipse. I only regret that I haven't done it sooner.
We ha been doing OOP the wrong way for years in Java. At least, let's try to do some functional programming in the right way. For example, we have been told that inheritance was a great thing for years. Only lately, we started to prefer composition over inheritance. I believe that pure functions and immutable values are great patterns that we should use in Java too.
Go ahead, satisfy your wildest longings, run from your existental angst while you can. Let Kotlin be your muse in your Storm and Stress. Then you grow up, get a family and a job in the Enterprise, and end up coding Java (and SQL) like the rest of us.
On many latin keybords on Windows, the backtick is a very hard symbol to produce.
It shows that there is a high probability of a null state and provides methods for handling it. Bit I agree a language integrated feature like in Kotlin would be better.
Java is not going to die. But, if you work on age-old technologies like struts and JSP, then you will not have any scope. Since my 15 years experience in Java, I have worked on various frameworks on Java. Every time when there is any new languages are introduced, there will be a discussion about Java's end. It overcomes all the obstacles and still dominates being one of the popular languages on the planet. I would suggest you focus on the emerging trends in the Java community, Java 8, Lambdas, Spring Framework, etc. which will make you stay updated with latest trends. 
&gt; Based on that data, Realm predicts Kotlin will overtake Java on Android by December 2018. Kotlin may even change how Java is used on the server, the company said: “In short, Android developers without Kotlin skills are at risk of being seen as dinosaurs very soon.” https://www.infoworld.com/article/3230301/mobile-development/kotlin-could-overtake-java-on-android-next-year.html
/r/Java: “JavaScript is bad!!!” “var is good!!!”
Implicit typing is not the same as dynamic typing
And Java can run on bare metal, which I think will be important in the next phase of computing, based on cloud technology and its oceans of available computing nodes. Another thing that he should keep in mind is that Java is complex, which is good, it narrows down the field of competition. There are a lot of people who would like to be Java experts, but do not have the years of necessary experience to be viable.
Kotlin is one I have in mind
Even C# has implicit typing, using the same keyword no less.
Also note it looks like Google is moving towards Dart for mobile. Kotlin might just be short term decision to give current Android devs options.
C++ also has it with auto.
I was actually working on Nuxeo on my previous job (Very similar to Alfresco). And the main issue from all the customers I worked with was it was very complicated to setup and use. My point is to make something simple but yet packed with features.
Get out of your cave and use an ide to work
I do have an IDE I don't want to have to mouseover the method to check return type constantly. It's fucking irritating. For little to no benefit. 
Spring Boot DevTools is not a replacement for JRebel. What DevTools does is that it creates 2 separate class loaders, one for your code, the other for libs. When it detects a change in the "your code" classloader, it will restart the application. However, this restart will be very fast because the lib classloader won't be reloader again. Hence, DevTools is not an alternative to JRebel, as it doesn't provide every feature the later does. However, in specific contexts, it does practically the same - and it's free. (Plus you don't have the ZeroTurnaround sales guy calling you...)
I think I am going to get downvotes for this. &amp;nbsp; C# has had the `var` for a *long long time* now. It is an absolute time saver for typing and reading code. &amp;nbsp; I still see Java developers bitching about this from many blog posts to Reddit comments. I don’t understand these people.
Sure. But then again, the name of the method should at least reveal _something_ about the intended effect of the method. If method and variable names are random garbage and there’s no way to understand from the context what the variables should be, then I guess you should probably consider running far fast away from that codebase. Either that or finally learn and remember what methods return what. Or let your IDE to expand those vars to fully qualified types if this is needed. 
Can you give us more information about your interests and experience level?
Try [the search function](https://www.reddit.com/r/java/search?q=open+source+contribute&amp;sort=new&amp;restrict_sr=on&amp;t=all).
If you're interested in web/html your help would be appreciated at * https://github.com/tipsy/javalin * https://github.com/tipsy/j2html
Rust, too. 
Disagree. I'd choose the latter. Only params and return types (i.e. the types of the contract) benefit from the base collection interface... for local vars it's less important than the redundancy reduction you get. If it were immutable, I'd use List.of of course. 
As others have said here do what you like. Think of something that you use from OSS or something that's interesting to you and find the relevant project. Then just look at the contribution guide and start small. We recommend to our contributors to start with documentation fixes and small things like that just to get the hang of the process. You can then look through the issue tracker and try to find something interesting there that you can implement/fix. FYI this is our project http://github.com/codenameone/CodenameOne/
A serious question: why not pursuing the idea: why var is useful? Why not removing the type? If the var has not yet been defined then the compiler could define it automatically and it has this information. 
&gt; Oh dear, that type description is rather awkward. I'd say that whole Linq statement is an unreadable mess. The type description is the least of my worries… :P
I usually just do something like: &gt; List&lt;String&gt; list = new ArrayList();
I think we're going to need some time to get used to when and where using `var` is appropriate, and I suspect it's going to be a case that we probably shouldn't use it everywhere just because we can. It's also going to require better method and variable naming so we are a bit more obvious about what types an object is (no more calling a list `list`, rather `users` or `elements`, for example). But it's going to make things easier in Java and I'm looking forward to it. 
Additionally, `var` is only usable in limited situations, so it's not going to be a huge problem. Especially with good method and variable names.
&gt; Uhh this actually sounds like a really really good idea. What exactly do you mean by that though? Like a plugin that replaces var with the type only while you're viewing the class? That would be tits. Well, since ‘var’ is not released yet, there’s no IDE that supposed to support such thing for Java but for Ceylon IDE I happen to know for a fact that both Eclipse plugin and IntelliJ plugin have quick fix feature turning ‘value’ keyword (think ‘var’ in Java/C#) to the actual type signature and back to ‘value’ again. Very handy. 
Please don't feed the troll. shinda-sekai-sensen is [a] troll and [a] Spring advertiser.
&gt;Use JavaEE if you are a masochists. Do you see the hypocrisy already in you calling me a troll, while most of your own comments are actually troll comments?
https://github.com/spring-projects/spring-framework/blob/master/CONTRIBUTING.md
That's not exactly true. Most Java devs are "dependent" on an IDE simply because the tooling makes our lives easier and frees us to focus on other details in a professional environment. We *could* edit in vim, and I've certainly done that from time to time depending on the circumstances or hackery, but it's usually not worth the bother because the tooling is *right there*. Like a professional builder uses power saws and drills instead of a hand saw. He could use hand tools but why bother? Most other languages do have IDEs of some sort, Java devs just aren't familiar with them because they're newer and less mature. But they exist for the same reasons Java devs need them. But to your point about readability outside the IDE: that's still important because a lot of us spend time browsing / searching through source in a repository view without having the code checked out. 
&gt; If the var[iable] has not yet been defined then the compiler could define it automatically and it has this information. That's messy and doesn't allow for things like shadowing.
There is always one
How to work with types like CollectionLinq&lt;Tuple&lt;String, CollectionLinq&lt;Tuple&lt;Integer, Group&lt;Integer, Order&gt;&gt;&gt;&gt;&gt; 1. Write String customerOrderGroups = ... 2. Let IDE fix type for you 
Case 1: NO[Tab][Space]n[Tab] (6 keys) Case 2: var[Space]nameOfMyType (16 keys) With `var` the IDE doesn't know the type of the variable until after the right hand side has been written, and therefore cannot suggest a completion for the variable name.
Oh is that wrong? My AP Computer science class taught me to do it that way... then again it was written a long time ago...
 Map&lt;String, List&lt;Customer&gt;&gt; customersByState = new HashMap&lt;&gt;(); becomes var customersByState = new HashMap&lt;String, List&lt;Customer&gt;&gt;(); but I take your point. 
&gt; Anyone know how the goto type definition functionality works in IntelliJ when writing Kotlin or Scala? Almost flawlessly. It occasionally fails on really complicated Scala types, but that's way beyond anything Java's type system can represent anyway. IntelliJ can handle Java `var` in its sleep.
I will say JVM-based development is probably the best space to be in and will be for a while. That's mainly because of the massive ecosystem of great libraries and frameworks for the JVM that allow you to bring value to an enterprise with a lot of efficiency. As far as the language, that means particularly Java but obviously Kotlin is a nice concise dialect, and Scala is fascinating too although more difficult to master. When employers ask for Java they really mean the JVM whether they realize it or not.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt; Going to the definition of the type with a single mouse click is immensely useful and one of my favorite features of real IDEs. Of course it would be possible to implement this with vars too, but I fear that there's a lot of room to screw this up. Hopefully I worry in vain. The spec makes sure that `var` is only allowed in places where the exact type can be inferred easily and without any doubt. Hovering or clicking `var` would show or open the correct type definition. IDEs are already capable of doing this for features like "create local or field 'foo'" after typing `foo = methodCall()`. 
Yep. I work with some developers from time to time who have worked primarily with legacy C#, and some of them are deeply distrustful of 'var' at first. I think people just aren't sure that it really, fundamentally works: that the compiler is able to determine the type from the rvalue.
Same deal happened with auto in C++, it really was an amazing time saver, especially considering that so much magic is done with templates.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I don’t have an exact answer to your issue, but I prefer to use [sdkman](http://sdkman.io) to manage java (and java-related tools) installations. You might try it out and see how it works out for you.
I'm trying to follow exactly what my instructor has advised, I am a complete beginner, and think it would be in my best interests as a n00b to follow the course guidelines and do what everyone else is doing. Im just not sure what is causing this installation error. Ive never encountered it before. 
As Java developer, my biggest concern is less about the code I write and more about having to work with a team (or at least, inheriting the code written by a "team"). While var is convenient and recognizable, the cost is ambiguity at a high level. Assigning values at definition as the result of a function is fairly common. Not forcing the user to explicitly define a type at declaration isn't inherently bad, but the industry is increasingly populated by programmers with limited experience in a codebase (and potentially qestionable aptitude). At some point the cost of convenience features for me is outweighed by the cost of having to deal with them being abused by a larger crowd of coworkers.
I feel like a noob having never had to do anything platform-dependent on the JVM
And you just live with the warning? I couldn't.
I don't get it. If the IDE picks it up, you can be sure the compiler is doing its job. 
That is so strange to say? Why would you use a text editor regardless? 
Woah woah woah. Nobody is talking about removing typing. You get the same static type constraints and compiler support. What are you talking about? 
[removed]
What I actually often end up doing is write the right hand side first, then use Intellij's refactor to variable (default ctrl+alt+v) feature. That way I'm already letting Intellij infer the type, and it will automatically suggest a name based on the type.
We are dependent on IDEs, because we enjoy the programming workflow as the guys at Xerox PARC thought the future of computing would be (Smalltalk, Lisp and Mesa/Cedar workstations), instead of being stuck on a modern version of a teletype. My first IDE was Turbo Basic for MS-DOS.
On the opposite, you should be super happy!
Your problem is not Java related. It’s a DMG issue. Other subreddit may produce better answers. Personally I prefer to use Homebrew to install Java on my Macs, but given the information you provided this may not be an option for you.
Look at the other downvoted comment. The salt is real. ^^^and ^^^tasty
That sort of distrust in your coworkers sounds like it could be very toxic. If problems arise, wouldn’t the proper measure be getting your team together and deciding on a best practice which would cover the corner cases you are talking about? You could extend your linter to enforce them. It’s a relatively small effort if as a result you get to declare without writing explicit types. You save time by not writing obvious types and some useful patterns become easier to implement. At the ene of the day, the truth is that most modern languages have this feature. You can either validate or invalidate your concerns by checking some of them out—you can do it today if you want. For instance Kotlin is a very pragmatic practice oriented language with great tooling support. 
Do you have a code review process in your company? If so, you should not let bad code pass it. Over time you should be able to convince your coworkers that writing good code is better for everyone.
No new reserved keywords, no prototypal inheritance, please. Thank you.
Yes, Another issue with the same topic show the same. Seems many people live in a closed world and immerse in a low level and hate disturbing. Let it be. Run its own course. Anders Hejlsberg wins in these aspects.
Besides being totally different things like /u/isprri mentioned, I would like to say that, yes, `var` is good in Java and bad in JavaScript. In fact, it was so bad in JavaScript they had to introduce `let`.
both are shit
Tell me about it. I had posted about `var` a month back, and while most people were as enthusiastic about it as I am, there were some rather strange grumpy people who attacked it viciously. I mean, of course they are entitled to their own opinion, but the language cannot stay stagnant just for them. The only way forward in this industry is to adapt and improve.
Absolutely agreed.
&gt;Speaking as a frequent Haskell developer, I'm also a bit sceptical about var. How so? Haskell has full-blown type inference. Or are you saying that that is a shortcoming of Haskell? 
I do think type-inference leads to more typing than having to start with the type declaration when dealing with non parametric types. I've explaing why as a response to another comment. However, another redditor suggested starting with the right hand side and then using a refactoring in which case both methods are equally fast and **var** probably is slightly more readable.
\`
a better idea than adding *var*
Cobol never died. Java is the new Cobol.
every project will have to set up githooks to reject any code containing var to prevent contamination of the codebase and preventing prototypical inheritance would be a nightmare
Look at the sample code -- this is prototypical inheritance. There is no place for prototypical inheritance in Java. We have class inheritance. Am I the only one who noticed this? Am I a genius or something? People are actually trying to pass this off as a mere convenience feature.
Why is it messy? Please provide an example Languages without type already exist
C#'s var is not Javascript's var. C#'s var is still statically typed; it's just a shorthand for the type of the rvalue (which the compiler can determine). You're definitely right to worry about readability, but once you're used to it, and provided you're using a good tool (such as Visual Studio), I've found the situations where var hurts readability to be pretty rare.
God help us
I admit I haven't read the spec, but since when is var nameOfMyType even valid in Java? `var` specifically picks up the type from the right side of the expression and said expression **has** no right side.
I am working on some tutorials. What would you like to see? 
 var result = someMethod(); What is the type of result?
My guess is that IntelliJ will make it very easy for me to read what the type is, and that will make the readability problem minimal for me while I'm working with the code. It might impact readability when doing code reviews, as we normally read the code on bitbucket/github for that.
The thing is, you really only need the interface in method signatures and when you. And if you call a method that returns a List&lt;String&gt;, you can just do this anyway: var list = MethodThatReturnsListString();
Wow - that "Impossible Types" example is pretty cool. I didn't realize that was part of the spec. So what happens when you try to return "person"? I guess you cannot declare a type for it so it becomes a kind of sealed definition that's only available in the scope that it's created in.
How it's supposed to work (code is form the last example)? To be precise - I'm thinking about object creation, not casting. interface Mixin { void __noop__(); static void create() {} } (...) var duck = (Quacks &amp; Waddles) Mixin::create;
Not for job security.
FYI -- I installed JDK 10 and played around with it. Calling *getClass()* on the "Impossible" object returns what looks like an anonymous class name. E.g. public class Foo { public Object bar() { var p = new Object() { String name = "foobar"; }; return p; } } System.out.println(new Foo().bar().getClass()); This prints something like *Foo$1*. That class however is not defined. You can't instantiate even from the class object. E.g. new Foo().bar().getClass().newInstance(); This throws *java.lang.InstantiationException*
meetup.com
If you are into games you could check out [LWJGL](https://github.com/LWJGL/lwjgl3) or [libGDX](https://github.com/libgdx/libgdx).
Maybe is someone prepends the name with a "K" :-). Sorry, I hear you. I've had trouble finding groups in the past. It can be frustrating.
&gt; ArrayList&lt;String&gt; foo = new ArrayList&lt;String&gt;(); 😡😡😡
I think it works like this: Mixin is a Functional interface with abstract method `void __noop__()` You can create an instance of such a functional interface by providing any void lambda; e.g.: Mixin m = ()-&gt;{}; In particular, you can create one such instance by using the static method 'Mixin::create'. Because both Quacks' and Waddles' only provide default methods (beside the inherited `__noop__()`) you can cast `Mixin::create` to a class that inherits from both 
The java user group maybe?
List&lt;String&gt; list = new ArrayList&lt;&gt;();
https://www.google.com/amp/s/www.theitsage.com/fix-java-command-line-tool-popup-mac/amp/ FYI, this was the top response after a single Google search.
I didn't get 'java with "k"' :) by the way, yes I found a few groups but even the descriptions are in German. and the exciting part is I cannot speak German. 
keynote.pdf http://web.archive.org/web/20151229055009/http://lcsd05.cs.tamu.edu/slides/keynote.pdf
I'm a programmer, not a comedian! :-) The attempt at a joke was inspired by all of the open source software written by Germans that give the software names starting with a "K".
Sure
OK, apparently the point went right over my head. This is what I get for using Reddit right after I wake up.
It sounds like the download is corrupted. Might want to try downloading (and installing) it again.
Jetbrains is located in Czech, not Germany ;)
Not the software I was thinking of :)
In Russia, actually. They got Czech registration though.
I work in consulting--the client has a "review process" in place that is essentially an honor system (github's required reviews), but their actual quality control expertise is on other teams. As of yesterday I'm the only stateside developer on the team I'm assigned to, and about four others are offshore (including our "tech lead", who is a company employee). Since entering/leaving the team from that part of the world is largely a revolving door process, there's little I can do to influence the situation in that regard. That being said, I've been fixing bugs and performance bottlenecks pretty much the entire time I've been on the project--the application state is much better than it was before, but this particular mess is not something I have the time (or the compensation, honestly) to take on.
For me i rather not have the name of the variable reflect what the type is, I still remember Hungarian notation with dread. I rather have the name reflect the abstract content that the variable points to, for example "customers" and let the type system handle if it's a list of customers, or maybe a map of customers.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Oh absolutely; I don't mean encoding type information into the variable name. I mean that you generally don't need to know what a given type actually is; it's usually clear enough from context, provided your variables are well-named.
This is only two characters more and you get no annoying warning: &gt; List&lt;String&gt; list = new ArrayList&lt;&gt;();
Hahaha, that just makes me laugh. Well... those js guys will probably never understand the point of having static types. Its just not how they think. Somebody who thinks like that probably can't really understand how different having 'var' with type inference is, from... simply having no static types. So to them 'var' is really just as simple as 'another keyword to bind a local variable'. 
&gt;That sort of distrust in your coworkers sounds like it could be very toxic. If problems arise, wouldn’t the proper measure be getting your team together and deciding on a best practice which would cover the corner cases you are talking about? You could extend your linter to enforce them. Starting from my [response to another comment](https://www.reddit.com/r/java/comments/81qfhg/representing_the_impractical_and_impossible_with/dv68w2j/), I see it as more a matter of my circumstances than an inherent distrust of other programmers. Unfortunately I worded it kind of badly in the moment. Almost my entire career involves being called into at-risk projects with a team, and eventually becoming its sole/primary developer once things have stabilized and eventual cost-cutting measures come into place. ^^Realistically, ^^I ^^probably ^^should ^^be ^^looking ^^for ^^employment ^^elsewhere ^^to ^^avoid ^^burnout, ^^but ^^the ^^bills ^^gotta ^^get ^^paid ^^somehow. That's pretty much where my position of concern comes from--I'm not trying to dismiss the feature outright, but simply offering a counterpoint to that of /u/stun based on my experience. 
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Luckily though, JVM runs on just about anything. And pretty efficiently at that. So while it may not exactly naturally run 'on bare metal' it really isn't terribly difficult to have a JVM running on top of whatever architecture tickles your fancy. From ARM based embedded devices to cloud-based clusters of Linux PCs.
&gt; originally being written It still is, at least for PC platform. And as fas as I know that is still the place where they develop new features before they get ported to other platforms eventually.
Disclaimer, I may be a bit biassed... but then... isn't everybody in some way or another. Starting from Java is a good idea. I think you should try to complement that with becoming what they call a 'full stack' developer. Nowadays, I think most applications that matter somehow run on web platforms and or mobile devices. Such an app is not typically written in just one language it will probably have a 'back-end' and 'front-end' (or even multiple front-ends for different kinds of devices). The back-end... has a very good chance of being a Java application running on AWS or something like that. And it may use modern Java framework like spring-boot (if you are lucky). And the front-end will typically be some mix of JavaScript / HMTL and CSS. This is the 'UI' part that faces the users. The back-end deals with the databases and business logics. If you develop all the skills to develop such an app... with the back-end written in Java and tied to have nice HTML / CSS / JavaScript frontend in the browsers... employers will be tripping over eachother to hire you. So start with Java, but don't stop there. Also learn some 'front-end' developer technologies to complement that. 
Not the person you replied to, but the questions are: what are your (team's) preferences and in what environment are you looking at the code? With clear variable and method names, you might not care or need to explicitly specify the type. Another option is the loose and fast rule that any line that initialises a variable needs to have exactly one explicitly written type (to enable code reviews and such situations without a full-blown IDE): YourType result = someMethod(); var result = new YourType(); // but not: YourType result = new YourType(); Code style isn't exactly a hard science. The most important factor, in my opinion, is consistency.
Is there a Berlin JUG?
am I out of touch or is that not java?
Looks like kotlin
At first thought I'd say "IntelliJ" but that's not really true. Sometimes I'm looking at code in Crucible, or grep, or a merge tool. Unfortunately my team has a bad habit of waving off minor issues in code reviews if the code will still work when we're under time constraints, which we of course always are.
Hey guys! I’m really glad that JSON-B support was added in Spring Boot 2.0. I even wrote an article about it: https://www.e4developer.com/2018/03/04/introducing-json-b-with-spring-boot-2-0/
It doesn't focus on Java, but there is the [GOTO Conference](https://gotober.com/) (October). There is also a conference dedicated to micro-services, the [microXchg](http://microxchg.io/2018/index.html) (March). The [BEDcon](http://www.bed-con.org/) (September) has a Java section.
There's a Kotlin user group, does that count? My company, Sauce Labs, uses Java in our Berlin office. (Hit me up if you're looking for a job!)
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
An unfortunate name given Postgres has “jsonb”, which has no relation to this
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt; It turns out that JSON-B assigns a naked null rather than the Optional value to the field when it is not present in the JSON! And who thought this was a good idea?
It's a bit odd that they wrote this recently, but used Calendar rather than the Java 8 ZonedDateTime.
Who else saw the finger?
But that's not what "runs on bare metal" means. In fact, such things often aren't particularly portable.
Who thought it was a good idea to use an Optional for a field?
I don't see why the IDE can't auto-suggest the name in the same way a lot of the time since it'll still know the type. And yeah it will know it. I can't speak for intellij as I don't know how it maintains its view of the code (but I'd be shocked if it didn't work) but since Eclipse has its own compiler it will already implement the type inference and can lift the type right out of it.
They *could* come up with something a little more real world than a GET to a non-parsed(?) endpoint that returns 'Hello, World!'. 
Polymorphism should not be used in the hot path since it can easily lead to the JVM having to do slow virtual calls.
The problem with these benchmarks is that they're incredibly synthetic. Like /u/djihe mentioned; doing an extremelt simple request from memory is typically not the normal workload for a service. A more typical work-load would be the service getting information from one or more repositories or http clients, doing some magic on that info, serialising the result to JSON and returning that. In these kinds of 'normal' workloads Spring is pretty much never the bottleneck. Instead it's typically the IO overhead of going to a database or another service that's taking most time. If you have a very a-typical workload of returning something from memory that almost never changes, and do this often then sure, such a benchmark might be worthwhile. But in most projects developer productivity is a much higher bottleneck and there it's really hard to beat Spring. 
Can't wait to get this. I do hope they move to something more similar to how Kotlin handles it though, backticks are a lot less common on many keyboard than the normal double quote. So """C:\\Program Files\\foo" bar""" instead of `"C:\\Program Files\\foo" bar"` For example.
Take a look on DCEVM. Some times ago I was dealing with it. More on http://ssledz.github.io/blog/2016/05/16/hot-swap-in-java-with-dcevm-and-hotswapagent-a-jrebel-free-alternative/
Are you hyperoptimizing before writing a single line of code?
Undertow is listed - 97% From the Undertow webpage, "Undertow is sponsored by JBoss and is the default web server in the Wildfly Application Server." But, its Java EE - which is old and slow and shit, so ignore this. Go Spring! &lt;/s&gt; 
It's the same as if you would type this today: return new Object() { String name = "foobar"; }; No new features involved.
No other dependencies? This is actually quite nice, but... &gt; Build with common sense to make things simple, but not simpler. This sounds a bit like you'll hit walls once you try to do solve real problems with this library. Perhaps I was bitten too often by the temptation to pick the easy solution, and by the false promises of simplicity. The last 10% of a project sometimes end up taking 50% of the time, not least because of wrong library choices at the beginning. So, serious question: Has anyone using this library some experiences to share on how it performs in edge cases and complex situations? Is it extensible or replaceable once you hit a wall? 
Well, that's what happened with JAXB as well, post JDK 9. It's really not an easy dependency to get right :-/
It doesn't really matter. It's a massively concurrent benchmark where async IO really shines. 
They have those too. [Single query](https://www.techempower.com/benchmarks/#section=data-r15&amp;hw=ph&amp;test=db) and [Multiple queries](https://www.techempower.com/benchmarks/#section=data-r15&amp;hw=ph&amp;test=query). Shows a much different result and again shows that Async IO really shines in these kinds of benchmarks. 
I never really understood Jodd. It's a micro-framework, but instead of relying on existing libraries (Jackson/GSON, OkHttp, etc), they have implemented their own libraries for everything? What is the upside?
This library explicitly targets JDK 8 (https://github.com/oblac/jodd/blob/master/build.gradle), so JDateTime should be deprecated in favour of java.time. Can't get any more lightweight than "native"...
Says the one who, instead of relying on existing libraries (servlet, JAX-RS, etc.) has implemented their own library for... well... a single thing ;-)
But that's the difference, doing a single thing makes a lot more sense than trying to do everything? To me, the point of micro-frameworks is to mix and match the best parts from the entire eco-system, Jodd is creating an alternative to every library there is. Maybe they're the best at everythig, but it seems unlikely.
Undertow is listed - 97%, which is the default web server in the Wildfly Application Server.
It better be a `Method` or you really need to fix your method names.
Plus `java.time` is much more featureful. Like being immutable.
Umm actually undertow has nothing whatsoever to do with Java EE or Spring. It’s just a great nio server that is open source.
It matters in that Spring 5 supports async IO with things like [WebFlux](https://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/html/web-reactive.html). (Of course you could just as well have used Spring to set up Async IO applications without that explicit support)
More disturbingly, they're using `Calendar` as a data value. 
The most cost of spring are at startup. (Potentially) more JARs to load, potential overhead for component scans and AOP proxy creation etc. Spring creates the necessary beans at startup and maybe again on container restart, but that's it. At runtime the overhead is usually neglible, if it can't be totally avoided by not using certain features.
Well they obviously have one, but I meant to say officialy they are Czech company. Most of workforce and good chunk of upper management is russian but juridical person of JetBrains are Czech.
You do not have enough comment karma (10) and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
It looks like in your [submission](https://www.reddit.com/r/java/comments/8262oh/question_is_there_a_java_class_or_3rd_party_tool/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
This subreddit is **strictly** about **Java**, not about **Kotlin**.
Hahahahah this comment is awesome!
This is not a benchmark for speed but for scalability. Naturally, all event based (asynchronous) frameworks scale much better then threaded synchronous frameworks. If you would compare the time a single request takes, or say 10 concurrent, Spring would be much better compared to this benchmark (256 to 16384 concurrent requests). Also, some frameworks are highly tweaked for this kind of benchmarks, e.g. ASP.NET Core. Lastly, Spring 5 with WebFlux is asynchronous, so should scale much better. But is probably slower with less concurrency. And JDBC is still synchronous only. 
The first half is a basically the essence of the theoretical part of his book *Java Concurrency in Practice* (which I highly recommend!)
Horrendous on mobile. Unreadable
Looks a lot like what Rust has fixed: * Make everything immutable by default, * Switches must handle every case, * No null references, * No method overriding (this brings sometimes much more issues than what it intended to solve)
&gt;the benchmark from techempower suggests that Spring would be quite slow "slow" meaning 131,249 requests per second, or about 0.0076ms per request. Don't you just hate it when a web page takes 0.0076ms to load? 
They don't maintain individual frameworks. They expect someone from the Spring community to submit a PR to update the implementation.
Like the author, as someone who has been coding in Java since 1999, I do not see anything wrong or even paranoid with any of these. Just good practices.
Spring's popularity doesn't build on performance. It builds on two things these days: 1. Having it every job description 2. Developers wanting to use it because it makes the employable. Any experienced developer who can reflect on his experience with Spring and other frameworks, e.g. jee, will avoid Spring like a plague. The reality is Spring is horrible, complicated slow magical piece of shit. Additionally, it's a Vendor lock-in. Anyone thought about that?
"Spring Implementation"? WTF? Don't make it sound like Spring is some Spec with multiple implementations. Spring is a product. Complicated, slow, hard to use in development, under-documented shit load of rushed ideas, and on top of it it's a Vendor lock-in.
I personally hate yoda speak as I have to mentally rework the statement in my head I like languages which read like normal English (python eg, go to a certain extent) and this breaks the flow horribly in my opinion 
As others have said the particular implementation of the spring test in that benchmark is both old and incredibly vanilla. This leads to a lower score in the simplistic IO benchmark what to consider here is that its really not that slow if you go by deviation. It would be interesting to see them benchmark springboot 2 or spring 5 using undertow vs what i assume is embeded tomcat from looking at the github for that example.
Thank you for this comment. You just saved me some time.
I've been doing all of these for years. Avoids so much pain. :)
Fyi, spring boot is not actually different than spring mvc. It's just a way to get spring stuff (including spring mvc) up and running quickly.
Starting with the first one, I tend to always do this but people give my code strange looks so lately I've tended to do it the wrong way to keep people happy. Sad but true. #9 is a great idea but even it wouldn't have stopped the great break mistake: http://users.csc.calpoly.edu/~jdalbey/SWE/Papers/att_collapse.html 
What if you are providing an in memory cache?
Not true. Just did a small test. The overhead is neglectable. "Hello world" in Spring is as fast as in Node or Vert.x. It's doesn't scale as well as e.g. vert.x because Spring is synchronous and therefore blocking.
I use `Objects.equals(str, "abc")` instead (JDK's, formally Guava's, and Commons' prior). Now that its in the language, I don't see a reason to use the older convention.
Or just wait for [JEP 169](http://openjdk.java.net/jeps/169). [Minimal value types](https://wiki.openjdk.java.net/display/valhalla/Minimal+Value+Types) are available now!
Do you mean the Elvis operator?
I don't enforce the always final rule, I've seen it done before but never really myself. Is it considered a very good practice? If so I might propose it to my team (we have a "good practice" checklist) in our next retro.
#6 &amp; 7 &amp; probably 8 - I greatly dislike the "make everything final" school of thinking. You know what? You don't trust me not to incorrectly override your method, but I grow tired of not being able to overload methods in code (that I don't control, aka, a library) because of a stupid bug. I don't want to copy/paste your whole class just to fix that stupid assumption/error/whatever you made in your method. Just let me override what I want already - ***I'm the developer. Let me make my own mistakes.*** #9 - I disagree on always throwing an exception. I'd change this to "handle the default" instead of "throw on default". There's plenty of times to have `default:` actually be the default result if there's no other match. 
did you explained why you do it this way? And why it is better? And why it doesn't retract anything from the comparison. So, to recap: no downsides, only upsides. To me it looks like a no-brainer. To do it otherwise is insane.
Not sure what you're getting at there. Most of the time the *equals* method should be used instead of the '==' operator. Given the knowledge that Java uses nulls you should either ensure non null variables and/or use null checks when appropriate.
I can highly recommend enforcing it. 99 out of 100 times you violate this rule, it's a bad approach and there's a better solution out there. It's just a formatting preference in the IDE anyhow, no extra effort needed if your code already abides by the side of sanity.