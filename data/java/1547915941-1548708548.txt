Well, more nerdy hobbies are becoming more and more mainstream nowadays, so I say just go with that - be yourself. &gt; My hobbies have no bearing on my interpersonal skills. Ok, so you're not human then? Everything you do affects your brain - that's how brains work. &gt; I know plenty of shitty people with cool hobbies. Just imagine how shitty they would be without the cool hobbies. But actually, part of the reason they're shitty to you, might just be that they can't relate to you, you haven't gained their respect, talked to them at the water cooler, if you catch my drift. I'm sure their friends think they're fine. They of course might be objectively shitty, I don't know, but I've noticed in my own life that if you dislike someone and give off negative vibes, it's natural for people to respond in kind. 
I'm pretty sure I'm a pretty fun guy I just don't have any appreciation for nature or the outdoors. Your reaction to that is precisely what's wrong with asking this question. I take my team out for drinks and main event/D&amp;B/etc every couple of months. My team is effective and seems quite content. I've also had no real conflict at any jobs coming up. I'm pretty good at dealing with people. Asking about hypotheticals with co workers abd real situations with real interpersonal conflict is a better way to evaluate such things. Especially if the hypotheticals involve the kinds of past issues you've had, or situations characteristic of the personalities on the team.
&gt;Ok, so you're not human then? Everything you do affects your brain - that's how brains work. Ah I should have said they give little insight not that they have no bearing my bad. &gt;I'm sure their friends think they're fine. I say they're shitty people that might be overstating. Just the kind of friend you prepare new people for. "Well he's good people but he can be a biiiit abrasive"
It looks like in your [submission](https://www.reddit.com/r/java/comments/aho44k/i_was_told_to_post_here_please_help/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Everyone googles. Find a project or problem you want to do/solve and keep working on it til you're done. Force yourself to finish what you start.
Being quite experienced with all java related things, i still use google to find things when i'm stuck. It is often faster than doing a search through old source code. And because things change (or even sometimes becomes easier: hello java streams) one should keep using google. Otherwise we all would still be using vectors.
Yeah i don't know a single programmer that doesn't google the most basic of basics from time to time, everyone forgets stuff.
10 years in and I still Google and get stuck. Java is VERY broad and I doubt even the maintainers know the entirety of it. My advice: read Effective Java. Then re-read it every year.
A good programmer doesn't memorize. They know where to look for the relevant information. Getting stuck is mostly a logical problem, not directly programming language related. You need to work on your problem solving skills. This requires practice, practice, practice.
getting close to 20 years with java... google still saves my butt. Don't memorize things change and you need to learn what to ask for 
&gt; Also what is your best advice for a starter Google answers when you are stuck.
You should have a look at this talk: https://www.youtube.com/watch?v=24jWZJoxLxE&amp;t=528
Can you share your Github repo so I can critique it?
If you write it regularly you should get to grips with the syntax and stuff. I'm still looking up the packages for the functional stuff occasionally. And obviously new libraries you have to google. But mostly, no I don't Google too much. Most of my Java problems are "What's the best way to implement #businessProblem". I tend to reckon: * Graduate: Can write a pseudo solution to an academic problem. Won't know most of the language features. * Junior: Should know most of the features of the language. Probably doesn't have much depth. Topics like classloaders, GC and system design are likely fairly vague. * Senior Should know almost all features of the language. Should have studied and had demonstrable experience at least one of the concepts from above. Would be expected to be interested in new features and be able to express an informed opinion on changes in Java 8 and upcoming changes in Java 11. Note that that's for a 'Senior Java Developer'. In general I'm looking for a Senior Engineer. That might mean being senior at Java or it might be that they are good at complex project organisation, microservice architecture, CI/CD, or any number of different things. To my mind there's lots of reasons why you're considered 'Senior' and it doesn't mean you're good at everything. It means that, for the company you work for you've got applicable useful knowledge that makes you able to help steer development sensibly. Right now I'm doing a lot of ReactNative (an unholy hell mix of JS, Gradle, Android and Java) and I'm basically googling for almost every error message. I'm not a senior mobile apps developer. But I am a senior developer because I'm experienced in Java, Scala and JavaScript (from a web perspective) as well as in terms of systems design [at least in terms of company relevance]. So my advice is: * Keep writing code. * Don't get too invested in your code, but instead in solving problems. * Get feedback from other people (i.e. corporate code review or open source contribution) and look at your own code from 6 months ago (you will hate it). * Be curious - look behind the cover - look why Java introduces changes or why an array is a fixed length or why `==` doesn't always work on `String`. There's lots of experience to be had questioning (to yourself, try to research first) why stuff is the way it is. * If you feel like you're not learning new stuff move on. Whether that's switching focus or moving team or moving job or whatever). 
I'm with you there. Too bad you're getting downvoted. I've been asked miscellaneous questions like, "What kind of music do you listen to?", "Do you have a girlfriend". Not sure how any of that is relevant to the job at hand.
Problem is not with googling, but with coping and pasting without thinking. If you go deeper after finding a clue or put an effort to remember things that you come across multiple times - you don't have to worry. &amp;#x200B; Still, if you want to call yourself a senior dev you should be able to write intermediate code (not sockets, networking, advanced regex etc.) without help from Stack Overflow.
&gt; How long did it take you to understand Java to the point you do not google answers when you are stuck..? That depends on what you call Java, I don't google syntax stuff or how the ArrayList class works anymore (that took a year or two), but it's entirely possible that I google "R-Tree java iterator" or "floyd-warshall algorithm path reconstruction". &gt; Also what is your best advice for a starter Practice and look at good existing code, for example the Google Guava library.
Well I got to that point for about a year after 5 years ish and then I started using hibernate and spring...and I'm convinced I will never be at a point I don't need google.
I've been doing Java for 20 years and professionally for 10 and I still Google multiple times a day.
I always google - It isn’t about memorizing the tiny stuff. It’s about understanding the big concepts so you know what you need to google.
It used to be I'd only buy books whose index was awesome, bad index and it would not leave B&amp;N with me. Google is the world's best data indexer. If they stay out of politics and focus on technology, they will be here 100 years from now. Human brains are not great retention devices, we needed good indexes decades ago, today we need Google, Bing, DuckDuckGo, etc.
I usually use duckduck. Does that count?
Professional software engineer for 14 years (plus a few more in grad school before). I still Google too. Clean Code is another good book to read. You don't have to follow its recommendations religiously (like keeping every method couple of lines long, etc.), but it is good to know these general principles like very long methods and very large classes are a bad code smell. 
dont learn how to work without help, learn how to search it better
It took me fifteen years until yesterday. I'm optimistic about Monday, though.
I have to pull up the javadocs for basic stuff on a near daily basis: things like String and Object.
Googling is like 50% of a programmers job. Experts just know exactly what to look for and know what they are implementing 
Don't know. What year did Bing start offering the pretty pictures for me to look at while I try to guess the magic phrase that'll tell me how to do my job? 
Yes, you can't memorize everything and autocomplete only gets you so far. 
I never try to memorize whatever I can google. My mind is full of concepts and ideas, with details stored in computers.
I started programming in Java on 1997 at the University. Started working professionally with it on 1998 and still today I work professionally with it and...well, I still have to google/stackoverflow things I'm stuck with, there is no point of "I do not google anymore". Reviewing my answer...20 years, and still ongoing, earning my life thanks to Java....thank you Sun Microsystems!
I also find sometimes I spend too much time trying to figure out what exactly a method does when really I could have just ran my code. Don’t be afraid to just try things out.
Some things are worth memorizing. Ex: regex
Why memorize when there are sites like http://regex101.com or https://regexper.com that have build in explanations and that let you instantly test your regex?
It looks like in your [submission](https://www.reddit.com/r/java/comments/ahpb2a/how_does_compiler_see_a_key_word_throws/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
If a programmer tells you he doesn't Google at least once a day, he's lying.
You see, java it's just a tool. And there are a lot of usages of this tool. So, I'm not google how to do something with java like to not google hammer. But, can google how to implement something
So as everyone mentioned - no matter how senior you will still google (or bing/yahoo/ask Satan). The main difference is more senior programmers can google better. If faced with a similar issue (an exception for example) a novice would google more or less “java program no work, what do” or copy the whole stack trace into the search bar, whereas a more experience programmer would now what to look for and how to look for it e.g “null pointer when providing hidden .env file to bufferedreader” which addresses the exact problem in enough detail that isn’t redundant (a whole stack trace that has filepaths that don’t apply to 99.99% of others) but the key features that may cause it.
Here's the obligatory quote: &gt;Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have two problems. And an article discussing more in depth: https://blog.codinghorror.com/regular-expressions-now-you-have-two-problems/
Absolutely true. Regex are great when used properly. Wrong use causes more problems than it solves.
Been doing it for 12 years now, I'll let you know when I stopped searching PDFs or Google if I ever get there - it's doubtful I ever will.
Yep, far more efficient to store pointers than duplicates.
Yeah, I started programming when I was 8 years old and I use Java in the industry, and come on, I google stuff. It was interesting in the old days when StackOverflow didn't exist though.
I use that to test my regex but I mean just the syntax. It doesn’t take too long to memorize. 
Yes but what does this have to do with this thread lol?
Been 4 years and I still Google stuff. I'm still learning new things every project and I've learned that bcus things are changing so rapidly, learning new things is inevitable which means, so is googling answers...
Use regex when the alternative code is tricky to understand. And yes you should usually provide some comments to explain the pattern. Regex becomes a problem when working in a team because a lot of people don’t know regex that well and you have to account for that. 
I've been working with Java in a professional capacity since 1999. On a productive day, my search history is 2-5 pages long (I just checked). On not-so-productive, tens of pages - when you work with not-so-popular frameworks, every little bit helps.
It depends, some tricky bugs in your own code would consume you a lot of time, as there will be no google answer there, you just need patience, troubleshooting skills and methodology to figure them out. However, for errors can be googled simply, why not JUST DO IT? Life is short, you will never be able to know everything, even if it's only about Java.
Agreed. Many optimization tips will be outdated as JVM is evolving version by version. Too many such examples, perhaps another example is about list.toArray(new T\[0\]) or list.toArray(new T\[list.size\]), which just reversed since a certain version.
I constantly Google it. There are some things I can do on my own, but usually only if I have a good IDE that will help with autocomplete and JavaDoc. But every project ends up involving Google on some level. Don't worry about it. It doesn't make you a bad programmer. What makes a good programmer is being able to use the tools you have. And to learn how to think about problems. Then use the tools you have to solve them. A good programmer doesn't memorize everything. A good programmer doesn't have to type 50 lines of code per minute.
Wow, not in my experience. If I got the sense that they were asking me questions to get a sense of where I stood on political issues that would be an immediate red flag. Not somewhere I would consider working. I think it’s more that if they’ve cultivated an environment where they like to be open and joke about sensitive topics, they aren’t going to want to hire someone who is going to be marching into HR to file a complaint 5 times a day. conversely, if they have created a culture of sensitivity and don’t want people to feel offended at work, they wouldn’t necessarily bring someone in who likes to tell dirty jokes and constantly steer conversation to controversial topics. I’ve worked at both kinds of places and seen people not work out well for both reasons. It’s not about screening people for their beliefs, it really is about how well they’ll fit in with the people and culture. Again, that’s been my experience. I’m sure there are counter examples, but I think in general development teams are less likely to pull something in an interview like: “So I see you’ve terminated your T-SQL statements with GO instead of the more standard semi-colon. Speaking of terminating, how about all these loose broads killing babies? Just terrible, don’t you think so?”
Well, I'll let you know when that day arrives. While it is also true that I am a much better developer today than I was 10 years ago. My career has advanced into doing the crazy shit junior developers aren't quite ready to handle. I google more now than I ever have...
Thank you. I still mix up regexp but bookmarking this lol
That is true too. In 25+ years, I don't think I've ever written anything that compiled and ran without fail on the first try outside of hello world type stuff.
Politics is downstream from temperament, philosophy, and culture so it's not hard to guess someone's politics if you ask about hobbies, their nightlife, their personal preferences
I just can't picture a libertarian filing complaints to HR about jokes they found unfunny. Going to HR is essentially a political act
Why would I stop using Google when I'm stuck just because I know the language?
You just upgrade from Google to StackOverflow.
You've made an incorrect assumption. More you learn, the more you'll Google. Odds are that someone has done the same thing as you, or had the same problem as you. Even in the pre internet days, programmers didn't memorize everything. There were reference books and manuals.
&gt; With Kotlin’s 100% bidirectional interoperability, it’s possible to mix Java and Kotlin code easily. This is technically true, however, hand written kotlin classes may look bad when you see them from java, so you need to follow some extra practices (for example use annotations like @JvmStatic or MyClass.STATIC_CONSTANT will become MyClass.COMPANION.STATIC_CONSTANT) &gt; First, we can throw away this @Throws annotation immediately. It’s mostly useless in Kotlin. Don't do that if you plan to let java folks use your library. Otherwise they won't be able to catch checked exceptions (aside from Exception itself, which is an anti pattern in java)
I still Google because 1) my memory suck, that's why I'm not a lawyer or doctor and 2) no I'm not willing to remember what works how (or is supposed to) in which version for each of tens of the libs the current project use. &amp;#x200B; Before internet and google I was programming in Pascal and Delphi and there was this handy ctrl+f1 on almost anything. Before that I was programming in Basic on C64 and the manual got a nice cheatsheet and that was enough.
I google and cheat off previous projects where I solved a similar problem. But yeah. First thing I do with pretty much every problem is google. 
Google didn’t yet exist...
11 years professional Java developer, and I hope to stop googling for problems in about 30 years...
I’ve been going for 6 years solidly in java and still google basic stuff now and then. It was probably two to three years of nothing but java programming before I know what I wanted to do just out of gut feel in terms of core functionality of the language maybe four to five when it came to things like spring.
I'd say you are qualified for an entry-level as soon as you don't get stuck fighting the language anymore, and you can build basic apps. This means you can set up your IDE, a project, configure Maven/Gradle and Spring/Spring Boot/some other framework, and resolve the most common issues with them. In short, being able to work on something without constantly getting stuck. In those cases it is important to be able to consult documentation and your favorite search engine, and to effectively communicate with your colleagues and stakeholders. It might be useful to get in contact with a local Java developer community, for example via meetups. Most larger cities have one. If there isn't, becoming part of similar communities might also be useful since many programmers know Java.
To me it's ok to use online help or answers for things related to your problems. Before you go search for answers try your best to figure it out, plot down, draw your thoughts. Learn basics of java first then test your abilities with some forms of what you learned. As well further your education by looking into advanced java like data structures because that can expand your ability to code without help. And in the beginning of your first projects you can look up help and it gives you the ability to remember what you learned from other peoples code for future.
I will never get to that point. The best you can hope for is to understand enough that your answer is the first result. 
Long time ago programmers had long shelves full of medias made from pulp mass from trees. Words were painted on those medias and we got help from those so called ”books”. Now we have Google and everybody reads it daily.
The first law of commercial programming in the 21st centuary is that someone, somewhere, has already solved this problem. If you don't search for an existing solution when first presented with it, you're probably not destined for a lucrative career in this industry.
The only language I do the least googling is C and that is because the language us so small. I use man pages for the standard library functions usually. 
Supposedly Einstein was asked for his phone number once by a reporter in case the reporter had any follow-up question. Einstein got his address book, looked up the number, and gave it to the reporter. Shocked, the reporter responded, “do you mean the smartest man in the world doesn’t know his own phone number?!” Einstein replied, “why waste my memory on something I can easily look up?”
For me, don't care. For entry level, I assume that you don't know shit. If you put down that you know Java, I will ask you some questions to figure out how much you know. I won't expect you to know the answer to everything I ask. I won't care if you've written anything or not and won't look at it. I will want to know if you know/understand things like: \- synchronized \- set vs list vs map, when to use each \- do you understand OOP, polymorphism, encapsulation, inheritance That's probably about it for entry-level. I might ask you to walk through an algorithm to solve a problem, nothing horribly complex, and, again, I won't expect you to know everything. Mostly, I'm going to see if you can apply some concepts of Big O to an algorithm to make sure you're not trying to put phonebook entries in a list and things like that.
Personally not a fan of reading programming books, but I heard that "Spring in Action" is a nice one to read in general. Also would recommend a udemy course(not a book, I know) called "Spring Framework 5: Beginner to Guru". Dude talks about lots of things, the whole persistence thing included.
I’ll take a look into those. Honestly, usually what i’ve seen on udemy its just beginner, i was hoping for more indepth explanations for topics like isolation, database locking! Bur Sprin in Action looks promising, thanks.
This. Knowing the fundamentals (what is an interface, why use a strategy pattern, correctly finalizing) is stuff you need to learn. I still Google how to run a regex in java every time I need to.
22 years coding Java. Still google every day.
Personally I think it is good to google things even when you know how to solve a problem. Because someone may have made a better solution for you to use.
The day you die is the day you stop googling answers. 
Of course, no reason to reinvinte the wheel if it works. 
It’s oddly unsettling when non-trivial code works the first time. 
8 years in. Still googling almost every day. The days I don't have to google something is the days I don't write code.
What do you mean? You will be doing this more, not less, as you gain more experience. You will be bored to tears if you’re only doing thing you already know off the top of your head for too long. The more experienced you become, the more challenging the projects you will be doing, and the more time you will spend thinking, reading, talking and listening to presentations instead of typing in code. My advice for a starter is to keep doing this. If you get stuck, look it up, ask someone else. You shouldn’t get stuck because at your level you’re unlikely to have a question people don’t know the answer to. The juniors who are afraid to ask questions will not be successful. Never apologize for learning something new. A junior isn’t judged on what they know but on the progress they make. 
Years of Perl means my regex game is strong and if all I'm doing is testing for a match I'll use `String.match()` and get my IDE to convert it to `Pattern` etc. It's only when I need to do anything more complicated that I need to check the javadoc.
Books are better honestly, greater useful to useless information ratio.
I wouldn't ask about hobbies, as that leads me towards unconscious bias - your hobby is flower arranging? I go shooting bears at the weekend, will you be a good fit?
Not liking a certain type of question that could be considered personal is arrogant? Honestly your comment comes across as more arrogant than what he said. Feeling the need to police others tone and attitude is itself rather irritating.
IDEA: shit just works and if it doesn’t it gets fixed quickly. Free: hope someone fixes the stuff that isn’t working. That what it boils down to for me. 
Not liking a question is fine. Not liking a question that is one of the most commonly asked questions while getting to know someone because you aren't comfortable with how your own hobbies will be perceived is. No one is asking to reveal your deepest darkest secrets.
1) Build projects that are useful to someone. At the very least, it should be useful to you. Projects for the sake of a CV are pretty apparent, and are pretty much useless - unless the hiring manager is clueless about programming (and there are a few such folks out there) 2) Learn about tests - both unit and functional/integration tests. And add them to your project. Testing is what separates most ameteurish projects from something more serious and worthy of consideration. 3) Add documentation to your projects so that it is readily understandable and easy to setup locally for evaluation purposes. 4) Learn about Version Control - especially Git and Github/Bitbucket etc. Being able to professionally manage your project and being able to contribute to other projects through pull requests etc and being able to merge other people's Pull Requests is a skill in and of itself. 5) Spend some time trying to build a community and be a part of other project's online community. This show cases your ability to work as part of a team - even if it's virtual. 6) Be humble, and try to learn from other people's code - and never hesitate to ask for help or code review's etc from senior people online. They are, more often than not, very helpful time permitting. 7) Blogging about your projectt, it's goals, it's architecture and it's usage is also a great addition to formal project documentation. It showcases your communication skills. 8) A good stack overflow profile is also helpful in indicating to others that you both help others and you are not afraid to ask questions and get answers to technical topics online. 9) Lastly, enjoy programming, and don't be afriad to show your passion when it comes to programming interviews. Freshers often look the same to us during initial interviews. What separates the best from the rest often comes down to attitude and enthusiasm and passion. Good luck on your journey.
Generally I just stick to hobbies, favorite editor/IDE (And why), and preferred management style when I'm asking about preferences and I try not to be judgemental as long as someone can say why, have a conversation, and be respectful. Like I said, I ended up with a mix of people.
It's not about paranoia -- it about people being rational and only hiring people they understand. And generally people in coastal cities only understand people who share their values
I found 'Java 8 in action' pretty useful to learn the new stuff they put in Java a couple of years ago, so maybe spring in action is a good advise. +1 to those courses platforms and their ability to play the videos at 2x! 
senior programmer here, I'd be sleeping on the streets and haunting cats for food without google 
Experts Google all the time, even just to double check what we think we remember. The nature of your Google searches will change over time, but you'll always go back!
Unfortunately, the norm among software engineers is to reinvent wheels, present unnecessary wrapper layers, and generally bodge up things. Speaking from personal experience. There is far too much to know, and each crunch time generates enough material to fill Daily WTF for years. Unless you are directly contributing patches (that are actually accepted) to the GNU/Linux kernel as your day job, you are likely doing at least a little bit of bullshit coding workflows. It's just inherent in the process of getting real world things done. And so is Node.js devs attempting to save themselves time by publishing five hundred thousand "helpful" packages to manage their particular snowflake coding workflows.
John Skeet. (He writes Java at Google last I checked).
James Gosling? Joshua Bloch?
Skeet skeet, motherfucker
lol. that's quite the mentality.
The secret is that at every new problem, you search and actually tries their solutions until you achieve success on that matter,then the knowledge is storaged.
Aside from Gosling, I’d say [Brian Goetz](https://twitter.com/BrianGoetz), [Mark Reinhold](https://twitter.com/mreinhold), and [Stuart Marks](https://twitter.com/stuartmarks) among others.
I get genuinely paranoid when that happens, like... "did we not write enough test cases?" Then I feel weird and idiotic and keep it a secret.
I usually don’t have time chasing down eclipse or NetBeans issues. I’ve used first NetBeans then eclipse for many many years. Then eclipse 4 happened and I switched to IDEA. Stuff just worked. That’s worth my money. My hourly rate is in the 300s of USD. If I get back half an hour from an IDEA in a year it pays off. 
Read a good codebase. [Undertow](https://github.com/undertow-io/undertow/blob/master/examples/src/main/java/io/undertow/examples/helloworld/HelloWorldServer.java) is only 90K lines.
And when a solution they come across is naive/stupid/outdated.
Never. I've been a professional developer for over a decade and I still google often. It doesn't help that I work in a number of different languages (currently Python and Java, previously C, Ruby, Perl) and sometimes it's hard to remember syntax differences. I remember when I was writing C for a class I went into work and in my Java program typed NULL for a condition and stared at it for 3-4 minutes before I figured out why IntelliJ was yelling at me. Your goal should be to get to a point where you can maximize your efficiency when looking up information. You need to know what to search, how to identify relevant results, and how to interpret them to solve your problem. Don't aim to stop googling, aim to become more efficient at it.
You get MLK day off?
There are many rock stars, like father of Java, creator of collections framework, JDK architect and etc, but it seems very difficult to recognize the shiniest star, at least I cannot and I don't know a reliable information regarding this.
IIRC, he was a Java dev that was answering C# questions on SO.
I would suggest reading Spring official documentation rather than book, pickup a sample project and play around with it, and try to build your own, this might be faster than reading books - even that book is very good. After make your hands dirty you might pick up a book to summarize, so that you will know stuff you didn't touch previously.
&gt; you see, the product provides nothing over other IDEs . Said IDEs are free (beer and speech) while this one is not, all while marketing the shit out of it to make the plebs feel good for paying $100/year for it. There is NOTHING saying that FOSS products that are free beer are automatically better than those that aren't. They just get their resources in a more direct way. FOSS products that don't charge a fee ultimately have to get some form of organizational/corporate support in order to be sustainable. They are ultimately funded by the companies that support them who then disperse the cost across their fixed costs. In the meantime, we get to pretend that those things are 'free'; that they don't cost anything. FOSS products that do charge a fee simply ask for it without all of that. They're asking you to vote with your wallet so they can pay their people a competitive rate. We acknowledge that value and simply give a few $ over to support it. You calling it a scam is bullshit. It's incorrect and you're wrong. They do not lie about what they're doing and they deliver exactly what they promise.
Yes this is correct.
FOSS products may or may not be better. These specific FOSS products are better than this specific proprietary one. That's all im saying and that's all that there is. 
No, they're not. That's the retort, and that's what I know. :P
Jon Skeet.
lol. hahahaha. 
Coda Hale
Jake Wharton is undeniably a Java (and Android) guru.
&gt; Personally not a fan of reading programming books I love them, at least the good ones. They usually cover all the boring details that videos/blogs miss and present the information in a way that's easily consumable.
Not all artifacts lend themselves the flexibility of some VCS tool. This seems like trouble in the making. 
Unless the developer puts something like that in the response or provides a RESTful method to request the information, no. You may find some information in the response headers saying the type of server the service is running on though.
The style of the requests would tell you something. Maybe not that it's definitely spring, but you'd know if it wasn't.
I don't care if I get downvoted, but I am going to back up /u/skeliskull here. And I am saying this as somehow who uses [regex101.com](https://regex101.com) on a regular basis. I can write the regex myself, but having a website to test it out on helps me greatly. I could not imagine someone who doesn't know the basics of regular expressions trying to read the Quick Reference for every little detail. What a terribly inefficient way to program.
Thank you. Idk why I’m getting downvoted. Regex is a sensitive topic in the java community.
Joshua Bloch, author of Effective Java? Seems like kind of a bible for the java community.
We’ve done same in our project and also we use aop to extract method parameters and log it. For example you can put annotation @Loggable on the method and see it’s parameters marked with another annotation in log context during method execution. I have idea to put it in public repo.
Java gurus tend to present sessions at Java ONE, now Code ONE, and promote the use of standard Java, not variants done by their employer.
You know, as developer, one should always stay up to date, this means constant learning. Even if I know how to implement some non trivial part, I would check other implementations, examples. 
True, but you have to take into account he started very early and now can’t be overtaken anymore as long as he keeps up the current rate of answering (which can be much lower than new users as his old answers keep generating points)
Indeed, I’m a senior at my company now and I google tons of stuff daily.
BalusC
A lame answer, but for me it would be Andrey Breslav, because he develops Kotlin. The seamless Java interoperability is a killer feature not that easy to pull off.
This is a bit off topic -- Just in case you were looking for a list of people to follow or to watch at conferences, there is literally a list of "java champions". These are developers who have been recognized by Oracle and their peers about the work they do in Java. [https://github.com/aalmiray/java-champions](https://github.com/aalmiray/java-champions) &amp;#x200B;
WAT?!
when i switched from Eclipse to JetBrains all the horrible things from Eclipse, the bugs, the slowness, the lack of features without installing 100k buggy plugins were gone. It just WORKED. Maybe Eclipse got better in the mean time 
I've just clipped your answer, will keep it forever. This is literally a life-changing comment! Thanks a ton for giving such honest and informative insight, cheers mate!
Depends on the security department of the company as in my experience they don’t like that kind of info being public.
It doesn't make sense. If you are using Spring Boot with embeded web server, you don't need weblogic. In opposite: if you want to have an application for Weblogic, the Spring boot is useless. Of course, you can do it, but you are combining one massive library with one massive application server. There is a lot of useless stuff in your deployment.
Jake is incredible. So good to watch his talks. Really interesting and engaging. And always a real world application to the talks despite perhaps appearing theoretical. Top guy.
Early days Bill Joy as well. If inactives count.
&gt; If i hit that endpoint as an end user, is there anything that can help me figure out what this api is built in? In other words how can I determine as an end user, without access to the original code, if this API or Microservice is built in Spring Boot? If anything when you'd do a pentest and these kinds of details would be leaked, it would be a pentest finding you would have to fix. There is no reason to supply this information and plenty of reasons not to. So no, a properly built Spring Boot app won't announce that it's built using Spring Boot. Incidentally this is also where the idea that "the internet runs on PHP" comes from. The internet doesn't run on PHP. There's just a ton of badly configured PHP applications announcing they're running on PHP. 
Yep! As well as Guy Steele.
 In short, the flatMap() function is used to convert a Stream of Stream into a list of values. Not exact. It converts it to a stream. 
I have a project you can help with. Will help you learn git, maven, spring, hibernate, REST, ops, and more. The code is all Scala though.
He can't be caught even if he never answers another question. 
JSF triumph
I'm really interested. I wanna say it again just in case u missed it, i know the basics of Java OOP (builders, setters, getters, etc but just the basics). I\`ve heard that Scala is Java on steroids xD, is the transition really hard? I'd be glad to participate on your project if you think i can be of any help
I will message you tomorrow. 
okay, thanks a lot
I prefer to write a quick test and see what happens (:
It's not about whether or not you Google your answers. It's all about asking the right questions and doing it efficiently. 
I've been reading about Scala for a while. Dont you think it will be too hard for me since I know only the basics of java and scala isnt as similar to java as i thought it was?
Underrated
John skeet knows nothing of the business logic at my company so I am not really impressed.
If the API is written correctly, you should not be able to determine, if the implementation is written in C, Java, Python or Ruby etc. The REST API should be independent on implementation. And you as the end user should be able to use the API without such information. So, such information should be useless. 
TIL cat ghosting is a thing!
I owe that guy my work (and probably every dev in every project out there that uses whateverfaces)
Developing with Java since the early 2000's. Still google. Why keep a lot of shit in your head? 
Gaming? Almas Baimagambetov recently posted a startup FPS game in Java https://www.youtube.com/watch?v=nCQUkvwQncQ&amp;t=0s
Everyone has to start somewhere. 
Effective Java is "must-to-read" for every Java developer. 
I'm currently working on a project, which can be extended at will. The only problem is, it's an android project written in kotlin. I'm not sure if you only want to work with java or if you are open to other languages. Kotlin is a great language and very similar to java. PM me if you are interested and I 'll send you are link to the github repo.
I think, BigDecimal is not useful for real number operations. If you need a real number math, you should use float or double instead. BigDecimal is mostly for financial operations, where the decimal numbers are to be precious with defined precision. In such domain you should not use pow, cos, sin, sqrt and so on, because it has no meaning.
&gt; No one develops a brand new website based on JSF. And of course you have a good survey or something else to prove that? 
Many projects I've come across out there have bits and pieces from BalusC in them :P
That's a pretty common misconception, to think that with experience, you don't Google anymore. What happens is that one don't search for the same things: with more experience, you know about the concepts, you Google for the specifics. I would even argue in favor of forgetting details. They take place in your head, with not much value. On the opposite, concepts are harder to know about with Google.
I mean if you want to help work on a game I'm working on we can. I'm just learning the very basic features of how a game runs. Direct message me for more info :D
It looks like in your [submission](https://www.reddit.com/r/java/comments/ahyf3f/using_timer_creates_too_many_threads/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Probably the only guy that truly understands JSF.
If someone tells you they are proficent enough to not get stuck with anything in any language without google/SO/another dev, suspect. Either they have assigned some sort of repetitive task, or they have huge ego.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/coding] [OpenJDK 11, tools of the trade \[x-post from r\/java\]](https://www.reddit.com/r/coding/comments/ahyqm6/openjdk_11_tools_of_the_trade_xpost_from_rjava/) - [/r/programming] [OpenJDK 11, tools of the trade \[x-post from r\/java\]](https://www.reddit.com/r/programming/comments/ahyqhs/openjdk_11_tools_of_the_trade_xpost_from_rjava/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
I tend to use spring mvc + data for most web (and sometimes non web) work and I'm quite happy with it. Are there any major benefits of using EE9 over the whole spring package? Of course having EE is a good thing, keeps spring from being to dominant. 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Why would that information be useful?
at Google?
Well core Java is so basic to start with a project , you should first learn more Advanced topics of Java which are currently trending (JavaFx, Serverlet , etc). By doing so you can explore yourself to go with a new project from scratch or collaborate with someone. All the best.
I'm recently started learning android with java, basics are pretty much done, now looking at others existing small code but I get scared when I see a very nested thing or deep programming? Would you if I want to hop in?
I really don't think there's a lot of point in continuing this argument, so this will be my final comment on this thread - please feel free to have the last word should you feel a need to. Two points to finish with: 1.) Perception matters. In many cases more so than facts. Java shops have always only ever dealt in major versions, and while you can \*say\* "Hey, we use Chrome versions now", it doesn't mean that people \*hear\* it. So, these versions are perceived as being equivalent to old-school major versions. The Java market is not like the Javascript market, regardless of attempts (e.g. by the late, unlamented Mr Kurian etc) to make it so. What people perceive is that these are major versions that are EOL after 6 months. You can pontificate about how the people that actually use your product are "mistaken", but it changes nothing. "The street finds its own uses for things" is as true here as it is elsewhere. 2.) Java shops in enterprises are by nature rather timorous beasties. Most of them will do a full retest whenever a major version upgrade occurs. This is usually because "once bitten, twice shy". \*In theory\* things should not break, but in theory, theory is the same as practice, but in practice it's not. A surprisingly large number of applications were badly affected by the activation of biased locking when upgrading from 5 -&gt; 6. 6 -&gt; 7 had various GUI breakages, often because applications linked directly to sun.\* classes (which, yes, you shouldn't do, but there was no other way to do certain things before 7). 7 -&gt; 8 had minimal breakages compared to others, but I still got to see a few. So, it is not unreasonable for shops to feel that a full retest when upgrading major version numbers is essential. It is absolutely impossible to convince shops that this should be done every 6 months - it's just too big an ask for a large application. Every 2-3 years is much more realistic. Finally, "These are not really major versions" is all well and good, but it immediately begs the question, even from a receptive audience: "What \*are\* the major version numbers, then?". In the absence of any better or more credible answer, the LTS versions will be understood to fill that niche.
Dont missunderstand me, i would gladly contribute to the project. But i dont wanna be a burden as well
&gt; Perception matters. I completely agree there have been serious problems in communicating the changes. But while perception matters, the actual facts also matter. &gt; Most of them will do a full retest I also agree that testing is required when upgrading to new feature versions. But even old upgrade versions -- also released every 6 months or less -- broke programs as some contained pretty major changes, just not changes to public APIs (see [7u releases](https://www.java.com/en/download/faq/release7_changes.xml) and [8u releases](https://www.oracle.com/technetwork/java/javase/8u-relnotes-2225394.html): e.g. [7u4](https://www.oracle.com/technetwork/java/javase/7u4-relnotes-1575007.html), [7u6](https://www.oracle.com/technetwork/java/javase/7u6-relnotes-1729681.html), [8u20] (https://www.oracle.com/technetwork/java/javase/8u20-relnotes-2257729.html), [8u40](https://www.oracle.com/technetwork/java/javase/8u40-relnotes-2389089.html)). So the real question is: we have to upgrade every 3-6 months, as we always have, regardless of whether we adopt the new feature versions or not; how different is the cost of upgrading to a new feature version compared to a new upgrade version? We simply don't have enough data to answer this question just yet, but that's OK, because there's no need to decide yet. &gt; "What *are* the major version numbers, then?" There are no more major versions. Java has switched to a gradual upgrade process. It's like asking if you have a ramp, what constitutes the steps? and answering that lines that are arbitrarily marked on that ramp take the place of the steps. Maybe, but clearly this is a new situation, and attempts to address it using techniques that are now outated is sub-optimal. The new model will require a new adoption process. What exactly that should be would take a while to figure out. But the new model is new, and those wishing to adapt to it *well* will need to come up with a new process. We believe that this new process will be better than the old one, but we'll all need to just wait and see.
!mvn org.graalvm !so vertx Any other good ones?
Josh Bloch , that dude's a legend. 
By definition, an API is an opaque boundary between applications. If you could discern the details of the application on the other side, you might be tempted to rely on it and then you're locked in. APIs are invented so either side could change their implementation without having repercussions for the other.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Other people could get more bounties, that's the only way
\- Java Core \- Multithreading \- Collections \- I/O (files, sockets) \- Streams \- Spring (Boot, MVC, Data, Security) \- JPA (Hibernate) \- JMS \- JMX \- Unit tests they all are most wanted
The same as before. Check its changelogs and open bugs and decide if it is critical to your project or not.
My opinion is that EE is/was too complex to develop things that shouldn't be that complex and that Spring has made simple almost everything not only not adding complexity but lowering it. Just think about EJBs. Spring has shown another simple way to make things. If the companies at JCP board hadn't have in mind to sell consultancy or certifications instead of ease developer's life (I know Spring do that as well) Spring wouldn't be were it's now. 
It was hard to me to learn Spring at first time. I've started, tried, had many exceptions and... have interrupted the learning. But about one year later I have started Spring the second time with complete project which I've found on GitHub and I've understood everithing! So, don't abandon, keep learning!
Jcmd was created to have one place to go to run all those commands rather than needing to remember each of them by themselves. https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr006.html
I question whether answering the most SO questions makes you a "Guru" or is instead just evidence of OCD. I am not suggesting that the answers aren't helpful but wonder what it signifies, if anything.
Take a look at libGDX for programming games.
Thanks for the pointer!
No problem. 
[Play](https://www.playframework.com/) is relatively simple and easy to get started with and probably looks most like Laravel. However, don't be afraid of Spring. With Spring Boot you can get up and running pretty quickly. Perhaps avoid Hibernate (any JPA implementation really) if you don't want a steep-ish learning curve, and instead use something like JOOQ for querying your database. Whether you like ORM or not, JPA does have a few quirks that you need to get used to before you fully understand what you are doing. 
You could still use spring boot head over to https://start.spring.io/ select the packages you need (web etc) and download a ready to import boot project and change a few setup for use of vue over rest (important what the embedded tomcat in spring boot can access the ressource folder with the client code in) You do say its for a simple side project, but where is also Jhipster https://www.jhipster.tech/ a ready framework where you can choose angular or reactjs as frontend, it is a bit complicated and maybe to overwhelming for a new starter, but you get a very nice base setup ready to use for coding your app, i have used it to make quick prototyping what can be used as base code for real coding after if the prototyping is approved by the client 
I looked at several a while back. http://sparkjava.com was freaking easy. Give it a look.
Recommend start from SpringBoot and move forward with guideline [https://spring.io/](https://spring.io/), late just read Spring Spec form more deep understanding about magic inside spring. 
Interfaces can't be instantiated like you said so `TreeNode` must be a class, otherwise `new TreeNode()` won't compile.
TreeNode is an object.
No, an instance of TreeNode would be an object. At line 10 of the linked code, `n` is an object (of the class TreeNode). TreeNode itself is a class.
It's as if now in Linux you had to do "exec Folder.list" instead of "ls" and "exec Files.concat" instead of "cat". Yes, they are all under one (actually, 2: jcmd and jhsdb) "umbrellas", but that doesn't buy you anything, you just have to type more. Also, now you have "jcmd Thread.print" ("Thread" or "Threads"? can never remember), but also "jhsdb jstack", go figure... IMO it's all a massive step back in usability.
Jcmd has help to tell you which commands are available for a specific process and it works against multiple versions of the jvm
True. "Guru" is kind of meaningless. I only suggested Jon Skeet because the he is known for answering C# questions on SO. I assumed that is what the OP's definition of "Guru" is. If Guru is referring to the language designers, architects, and what not then Jon Skeet isn't the Guru in C# but Anders Hejlsberg, Eric Meyer, etc.
Looks like the first code listing is wrong. It's supposed to be demoing `StructuredArguments` but doesn't use that class. First code listing is the same as the second.
&gt; authentication mechanisms such as OAuth2 I can barely take the author seriously since he calls OAuth2 an authentication mechanism. OAuth2 is an authorization framework. It has nothing to do with authentication. The OAuth2 RFC (https://tools.ietf.org/html/rfc6749) is even titled: "The OAuth 2.0 Authorization Framework"
&gt; Of course having EE is a good thing, keeps spring from being to dominant. Spring uses JakartaEE. 
&gt; My opinion is that EE is/was too complex to develop things that shouldn't be that complex That isn't true anymore. JavaEE 6,7, and 8 vastly simplified things. 
It looks like in your [submission](https://www.reddit.com/r/java/comments/ai3i0s/advice_on_getting_a_job/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I'm interested in this topic, but not enough to sift through an hour long YouTube video to find the couple of tidbits that might be new to me. Is there a paper or slidedeck available to scan more quickly?
Awesome, I have just the job for *jmap -histo* first thing tomorrow morning. Thanks for this
It also completely fails to mention the *map* part of flatMap.
I think creating anything with java or another language is a good way to practice :) go for it
Fixed! Also added a `ProxyContextLogger` to show how to log without passing context around everywhere, and filled out the correlation id stuff.
I learn by coming up with small projects and creating them, actually creating something is the best way to learn :)
Give Spring Boot with Spring MVC a try. 
You could try [Jooby](https://jooby.org/) or [Ninja](http://www.ninjaframework.org/) or [Pippo](http://www.pippo.ro/) (supposedly Sinatra like). However in terms of available resources like guides, tutorials, stackoverflow you'd get the most for Spring Boot.
As long as you having fun is ok. Happy programming!
I'm gonna say no. Video games in general in fact are not that good of an idea to start with. I'd focus on much smaller projects.
Yes but make sure it's realistic to complete in terms of the game's size and complexity.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Smaller projects that target a specific technology or concept that you will learn are likely better in the early stages.
yes, that's how i learned. but it was more of a western rpg
Be warned, going down this path may have you eternal addicted to all sorts of game sub-mechanics and systems that you may lose sight of the overall game. Don't ask how I know this...
I picked this option (and have everything crossed) in hope that there is an old t-shirt with the old IntelliJ logo.
Me too, but since the early 2000's and I'm still here...
I would say as long as you aren’t focused on art and design (like for instance just recreate the first town in your favorite jrpg but lifting the assets) its a good project. But 80% of a game isn’t programming, its design. I would say steal a predesigned game and clone it. Who care if you lift assets if you don’t distribute or sell it. 
To be honest, I don't think this would help a tonne. Building out a simple CRUD site would be a good project for learning. If you can only enjoy making a game then that's fine and you should do that. But if that is the only way you would find Java enjoyable then it may be better to focus on games development and Java is not a popular language for that.
The blog post covered here uses **nation-based Locales rather than language-based Locales**. In other words, it doesn't use Spanish, but it also doesn't use German or Italian. So, it seems your comments are more in general than about the particular blog post that is the subject here. However, my comment still applies to language-based locales: There are [Locale.GERMAN](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Locale.html#GERMAN) and [Locale.ITALIAN](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Locale.html#ITALIAN) and there is no **Locale.SPANISH** and it's reasonable to assume that many authors simply choose from the predefined constants that pop up in their IDE rather than playing favorites with human languages. There's actually a bug written on the lack of Locale.SPANISH ([JDK-4399080](https://bugs.java.com/bugdatabase/view_bug.do?bug_id=4399080)), but it looks like it won't be addressed.
Don't listen to the people who tell you it's a bad idea. Game design and development is a fantastic way of learning to program - aslong as you stick to it with discipline. The reason it gets such a bad reputation among those of us who want to help new programmers out, is because new programmers simply give up, or flood forums with questions that make no sense 'How can I make my dog pick up an inventory and do X,Y,Z'. Make a simple project first, learn how to draw on a canvas, refresh it, buffer images etc. There's so many guides out there it's insane. Highly recommend.
Any project that you find fun and rewarding will be a good project.
Man, I am in a similar situation looking to switch into developer positions, but they are asking me pretty tough algorithm questions much harder than simple reverse or find a an int. And even then I still finish them at the interview, but I still get rejected.... Where are you located or what type of companies ask more basic problems? It's been really tough I had like 5 in person and several final rounds, but in the end no offer.... I would appreciate any tips! Thanks!
It certainly can be! Figuring out how to bring all the systems of a JRPG to life with your code will be great exercise for your programming muscles. And figuring out how to best solve the problems that arise in the process will introduce you to a lot of more advanced concepts and possibilities naturally. &amp;#x200B; Try your best to plan out something that is realistic to finish. (You can always expand and iterate upon whatever you end up making, and make it better. But being able to finish things is an important skill that you surely want to practice.) And try to be very pragmatic thinking about how much of this project is going to involve programming, and how much of it will involve all the other things that go into a game - like the actual designing of the game, and the art, and so on. You can pour your heart and soul into all that stuff too if you want, but if practicing programming is your priority then that stuff may end up distracting you more then you want it too.
I will use Visualvm . 
RPGs in general require programming many different complex systems. Entity systems with health, XP, loot tables, defenses or attack types. A huge number of animations, cutscenes, dialogue systems potentially with choice trees. RPGs are way more work than you'd expect. If that excites you then cool, but it's definitely not a beginner's project.
I don't know a whole lot about video game development. But from the little I do there's not much programming. Generally your just using an engine someone else made. But if it's something you enjoy go for it. Even if you don't get to practice alot of programming no harm in learning something new! You might even be able to sell it on steam and become a hundredaire ;)
No love for [dropwizard](https://www.dropwizard.io)?
Maybe I'm crazy but I feel like a turn based rpg may be the easiest thing to code 
This is a great idea. Don't let these people telling you it's too complicated get to you. Fuck them. They don't actually know how to program. Anyone who actually knows how to program will tell you that the way to learn is to make things that you care about. Make this! If this is the thing you want to make, awesome! You're already 50% of the way to learning to program just by having something that you care about. The absolute worst case scenario is you start and you try it for awhile, you make some mistakes, and you give up. This is a great thing! You now know many different things that you shouldn't do. Next time you start a project, you won't do any of those things. Do it! There is literally no downside to doing this, and I think it will accelerate your learning better than anything else.
Simple console games are really at the easy end of the spectrum. You can write High-Low or Rock Paper Scissors fairly easily, and they introduce the concept of input and output. Then you can move onto a slightly more complex games like Tic-Tac-Toe, as it requires 2D space and more complex logic (arrays or other data structures). Battleship would be next as the grid is more complex, and ship placement requires more consideration. Moving into graphical stuff, you can write Pong without too much trouble. It introduces rendering and, mostly importantly, collisions. Tetris then is a small step up in complexity. Pacman allows you to learn the basics of pathfinding/AI. These examples are all much easier than even the most trivial RPG. That's why I don't recommend starting with RPGs if learning to program. If you're just transitioning to a new language however (especially if you already understand OOP in the case of Java), then the hurdle will be less significant.
All the down voters must also think OAuth2 is for authentication.
To be fair, you can make games that are very small and forgo menus and polish and that sort of thing. If he's looking to create some sort of polished product for sale then I agree with what you're saying but if it's just for practice and fun then I think you're off base.
[Here You go](https://www.slideshare.net/dbryant_uk/dockercon-eu-2018-continuous-delivery-with-docker-and-java)
Doing it in Java is probably a bad idea, using Java2D is in general a pain and it performs poorly. Don't even look at LWJGL if you're a beginner
I'm with this dude here. Programming an RPG will get you to study a lot of different systems. Battle system, quest system, inventory. Even if you go for something like Final Fantasy I, you will have to learn how to use a graphical library, and if you're like me, and you google everything, you will start reading about how your framework/engine works, and will learn all sorts of things. Expect to wait a couple years until you have anything remotely worth anything though. I recommend the LibGDX Java game framework. And I recommend starting with smaller simpler games, like Flappy Bird. But then knock yourself out.
Yes, but... It's an enormous project you are likely to drop when you grow bored of it. Maybe try a simpler thing first just in case, then move to that?
LWJGL is... Complicated.
If something is fun it's not hard to get good at it. Go for it :)
I think the author knows, but simplified things for the article. I fact, I'm pretty sure I saw exactly this point being explained by said author somewhere. The point is of course that OAuth 2 is an authorisation framework, where many applications use authentication as a side-effect of being authorised. That's why they always have to promise they won't post anything on your timeline if you authenticate using OAth2 with say Facebook. You authorise them to post, and if authorisation succeeds you must have been authenticated as well, which is all the info you need. Then in Jakarta EE you would add an authentication mechanism (which is a Jakarta EE term for a specific artefact) based on EE, like this one here: * https://github.com/omnifaces/soteria-google-oauth-client 
&gt; Just think about EJBs. Java EE and now Jakarta EE hasn't focussed on EJB for a looooong time. They were quite simplified in EE 6 though, but all focus has been on CDI. 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
YEAHHHYA WHAT
I like the changes. 
Make a game design document and stick to it. Once v1.0 is out, you can go all-out on other, less vital mechanics and it doesn't hurt the game.
That's what I wanted to mean.
He's also answering Java questions, so there: https://stackoverflow.com/users/22656/jon-skeet - C#: SCORE 215,837 POSTS 19,153 - Java: SCORE 132,419 POSTS 10,381
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
[Only #2 behind John Skeet, in Java](https://stackoverflow.com/tags/java/topusers)
Simple platformers or action games like Snake, Pong, Asteroids and so on are probably way easier to code. Or Sudoku-/Minesweeper like puzzle games. A RPG potentially requires creating a lot of custom content like different weapons, enemies, moves, locations and that doesn't even include moving around in a game world and all the other mechanics. That will make initial testing very difficult and time consuming. On the other hand, it's very easy to prototype a Super-Mario-like game and then you can tweak movement speed, jump height, enemy behaviour and all the other stuff very easily.
&gt; So, it seems your comments are more in general than about the particular blog post that is the subject here. Yes, the blog post just reminded me of this problem I've come across multiple times. &gt; there is no Locale.SPANISH and it's reasonable to assume that many authors simply choose from the predefined constants that pop up in their IDE [...] There's actually a bug written on the lack of Locale.SPANISH [Seems to be the case indeed](https://imgur.com/a/djKpgB7). It certainly doesn't help that they decided not to include Spanish in the `Locale` class. It also goes on to show that this "including German and Italian but not Spanish" problem is several decades old :( PS: Thanks for engaging in reasonable discussion instead of just downvoting.
I started with sparkjava, but the development stopped, so I switched to Javalin: https://javalin.io/ The syntax is a bit different, but development is very active. 
and also closes the unwrapped streams
Most people starts to create small games. Later you can create different type of projects aside from games. [https://github.com/Blackdread/canon-sdk-java](https://github.com/Blackdread/canon-sdk-java)
EJBs are now literally a matter of one annotation (check out @Stateless for example). Works like magic. As a person who started with JEE 7, I can't see why people still blindly claim JEE is way too difficult. 
Honourable mention for [Aleksey Shipilëv](https://shipilev.net) (@shipilev), who is certainly a Guru concerning java performance and more generally understanding how it java works at runtime.
I recommend webtoolkit: [https://www.webtoolkit.eu/jwt/](https://www.webtoolkit.eu/jwt/) Just plain vanilla java, no need to start mucking in javascript or worry about browser versions and/or incompatibilities. You also don't have to worry about client / server communication or maintain different code-bases for client / server (possibly in different languages). Of course, knowledge of HTML/CSS is unavoidable in any web-framework, but you'll pick it up as you go. Have a look at the widget-gallery to see what is possible: [http://jwt.emweb.be/jwt-gallery/gallery](http://jwt.emweb.be/jwt-gallery/gallery) 
Anything semi-complete - something where your motivation runs out, but your discipline continues. Something where all the ugly / boring parts have been at least touched upon, if not addressed. That will be the measuring stick.
Happy to have been of service!
It not about remembering everything (sure, the basics are a bit different) but everyone Google’s things! It sounds like the projects you’re working on are not interesting enough for you, if I was you I’d come up with a project (nothing too complicated) and try to do it. When you get stuck google what you want to do and try to work it out! That’s what I do anyway and it works for me! Good luck :)
Go to [/r/learnjava](https://www.reddit.com/r/learnjava/) you will get a better help there
I think that creating games is actually the closest you can get from the "real world", it develops many skills that you will need. * It teaches you to study, because you need to learn various systems, learn about game cycles, etc. * You become better at problem solving. * You learn how to allocate resources ,because generally, you need to optimize games for performance The bonus is: you can have fun while doing it, because unlike other kind of exercises, you are creating a more tangible experience, something that you want to improve on, other exercises like creating DAOs, RESTful APIs don't give you that. I created some mini-games in the past, just for learning, and I can say that it improved my overall programming skills. But of course, everyone and every situation is different. &amp;#x200B; For reference, Runescape is (or was in my day, I don't know if it holds true today), and if I am really correct, [Wakfu](https://www.wakfu.com/pt/mmorpg) is made in Java too.
If you're interested in not-only-projects, I highly recommend Code Wars :) Plenty of challenges, very well graded on difficulties, many of them suited for beginners but as you start to browse the higher ranked challenges, they start to get interesting and more complex. &amp;#x200B; The easy tier (8-kata) can be really simple, like a simple Math problem or fixing a compilation error. &amp;#x200B; The middle-tiers (6-kata to 4-kata) have interesting problems to solve, ranging from 30 minutes of coding to couple of hours/days. &amp;#x200B; The top levels(1-kata and 2-kata) are really hard, think of them as full-fledged projects, as they require advanced knowledge and sometimes they are even built on top of 2-kata, 3-kata challenges.
I've published a small article on how to get started with Kotlin by migrating from Lombok to Kotlin. In no way do I want to say that Lombok is a bad approach, it's much better than plain Java. I am, however, trying to give a comparison between Lombok and Kotlin, and how migrating can be beneficial to your overall codebase. 
It's not unusual to have to go back and reread some parts to refresh your memory. I can get a sense of a new programming language and use it for a little while but then lose it after a longer period away from it. Programming languages are bit like human languages in that sense, it takes quite a bit repetition before you feel fluent, and quite a lot of repetition until they finally get permanently etched into your brain. While rereading old tutorials may be a bit dry, try if you can find little projects to work on that forces the repetition on you while you're motivated by building something usable with the programming language.
Oh yea, thanks and sorry for that
Im not that far yet, havent finished basics yet, for example loops and arrays, i can understand a bit of a code but when i need to write something by myself its tragic.
I think you have the wrong sub
no problem
Moving to Kotlin because you want to move away from Lombok isn't a great idea
Yes. Writing anything is a good way to practice. To make the most out of it, 1. Reinforce what you already know. 2. Learn something new (e.g. "A single thread here is too slow. I could speed up loading all these resources with multiple threads) 3. Learn to do something better or more properly (e.g. "If you thought raw Thread management was fun, check out ThreadPools and Futures") 4. Learn what not to do next time (e.g. "I ran into a race condition so I just put synchronized on every method and now it works, but I have no idea what went wrong, and now it's worse than when I had just one thread") 
What do you mean with that exactly? What does Kotlin imply?
Change language only to use some syntactic sugar seems to me a strange choice. I don't want to deny the comfort of these functionalities but... change language because I don't have to write @Data? :|
You don't really have to "change languages" . You add Kotlin to your build file, and you can use whatever features you like. I know some teams that just wanted to use it for replacing lombok and adding new functionality. Eventually they started migrating old code too. 
like default references are non-nullable.
Almas Baimagambetov recently posted a startup FPS game in Java https://www.youtube.com/watch?v=nCQUkvwQncQ&amp;t=0s
Maybe the down votes are for the confusion between the EE term “authentication mechanism” and you trying to be clever? ;)
Is it possible to write only beans with Koitlin and the rest with Java?
Yes. 
What's the point of these fad languages other than provide jobs to otherwise unemployable programmers?
This is a bit interesting, but in practice it seems like a hell of a lot of overhead 
Arguably final non-nullable by default is much safer. Nullability and mutability should be explicitly called out
I think this confuses what most people mean by "using JakartaEE". &gt; Spring uses JakartaEE. This isn't exactly true, and confuses what Spring actually *is*. Spring *can* use JakartaEE just like any other application, since JakartaEE is just a set of specs. If you use Spring MVC, then you are using the JakartaEE servlets spec (unless you go reactive). If you use Spring Data JPA, then you are using the JakartaEE JPA spec. Spring is a suite of products that may or may not involve JakartaEE. Spring critics (especially from the JakartaEE crowd) claim that this ties you to a proprietary standard and limits portability. Once you go Spring, you can never go back. When most people say "using JakartaEE", they mean using an app server like Payara, TomEE or Wildfly. "Using JakartaEE" means that you program to the JakartaEE specifications, and your application is guaranteed (more or less) to run on any JakartaEE certified app server. The reason this guarantee can exist is because a JakartaEE app server is guaranteed to implement the specifications (either fully or in more limited fashion with the web profile). JakarataEE supporters claim that this increases application portability, and doesn't tie you to a specific implementation. If Wildfly is too much for you, you can easily (more or less) switch to Payara. This is the "competition" between JakartaEE and Spring, which are otherwise not comparable technologies.
Authentication is not merely a side effect of authorization with OAuth2, it is a [requirement](https://tools.ietf.org/html/rfc6749#section-3.1). In order to get a authorization token in the first place, you have to authenticate with the authorization server. The OAuth2 spec doesn't care *how* you do it, but you have to do it somehow. Any OAuth2 implementation will have to include an authentication framework of some kind, and when you evaluate authentication server implementations (Spring Security, JavaEE or third-party services like Okta or Auth0), understanding how they do authentication is critical to application security.
Oh? Looks like they released in March and September of last year.
Probably Java will add Lombok-like features
Background before mention JPS command: On Windows I do not "install" Java. (eg, I do not use a setup.exe or msi) Double clicking a jar file will not launch it. In Eclipse, I edit eclipse.ini to place a -vm argument on the 1st line, where the 2nd line is the full path to the javaw.exe file. On Tomcat servers, I run them out of their own folders, with a hand-specified path to the version of Java I want to use. I have multiple versions of Java, Eclipse, Tomcat, etc. And each application points to which Java it should use. &amp;#x200B; Now, to the point: I just verified that the JPS command from a java runtime will detect java processes running from other java runtimes. &amp;#x200B; I also use this approach on Linux. I don't make use of the installed Java that comes with the distribution. I set up every program to precisely specify which Java runtime I want it to use. This makes it easy to test a program against different versions (8, 9, 10, 11) or from multiple download sources (Oracle OpenJDK, Red Hat OpenJDK, Azul Zulu OpenJDK, etc) &amp;#x200B;
that its a completely different language on the JVM for example...
I got past the 'compile' problems (mostly) long ago. But I really got past them when I started using an IDE (in my case Eclipse). If there is a compile problem, then I see it right in the editor. If I change something that causes other files not to compile, then I see those files, or their parent folders, turn red, in the project tree structure. So compilation is solved before the first time I ever click Run. (or click Debug, more likely)
Yes, that. I also have plenty of bookmarks to avoid googling certain things. Like bookmark for the JavaDocs for each major version of Java, or important libraries I use.
Back in the day, I had memorized large parts of Common Lisp The Language (a thick book). But that was before the web and online docs. There is nothing to be ashamed of consulting online docs and sources of information. It's no worse than keeping reference books at your desk back in the day.
All languages? Or just Java?
I haven't done C / C++ since the 90s. And tons of Pascal in the 80s. One thing that happens after while is that you know the language syntax so well that you don't have compile problems. Or not often. And usually because they are typos not due to lack of understanding the syntax. So yes, to a degree with C / C++, but mostly Pascal back in ancient times. With Java pretty early on. IDEs are an amazing productivity tool once you get over the learning curve of the IDE itself. But it is HUGELY worth it. In fact, I would say lack of an IDE with the features I've come to expect from Java IDEs is an impediment to learn new languages. It's like going back to a language that requires you to do more work that should be automated by the IDE or editor you are using. &amp;#x200B;
So people not use and IDE with Kotlin? It’s as if verbosity is what kills productivity. Do you not have a keyboard? Just for once I would like an actually convincing argument for picking Kotlin in place of Java (especially 11 moving forward). 
Doesn't Lombok do some bytecode manipulation mumbo jumbo? I'd prefer Kotlin's data classes if thats still the case.
Seems like a classic case of "...and now you have two problems".
I have a preference to use Eclipse. I've tried IDEA before but it did not give me the impression that it is more superior than Eclipse. With Kotlin developed by JetBrain, I know the support for the language would be a first priority in IDEA. Does anybody here use Kotlin in Eclipse? How is the plugin being supported outside of IDEA?
Found the COBOL dev!
This is a question for either /r/javahelp or /r/techsupport, not for /r/java. You will get better help if you are more elaborate. **Removed**
It slows down compilation 
I used to think the same: "What's wrong with verbosity?" I also thought that verbosity made thinks clear, like getters/setters. However, I tried typescript for a small project, and I really liked some of its features, like no need to getters/setters, some weird overload where you put that one parameter could be one of two classes, and optional values for parameters. Then I went to java 8 and soon enough I found myself missing those features! I won't try to convince you that verbosity is not as innocent as you think, because I can't explain how I feel about it. I just... liked programming with less verbosity.
Yes, for sure. It's mentioned in the post too, but maybe not clearly enough?
It looks like in your [submission](https://www.reddit.com/r/java/comments/aiehr2/how_to_find_a_specific_character_in_a_string/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Changing language just because of that would have gained little, I agree with that, so if that would be the only motivation, I'd recommend to just keep using Lombok. However, there's much more benefit to using Kotlin, and this post merely describes on what could be a possible good starting point.
I'd never claim that would be the reason, and nowhere did I say that. There's probably a bigger overhead of using Kotlin than Lombok. I'd use Kotlin for it's readability, the java interop, the concurrency features, etc, and in this post I'm only showing what could be a good starting point.
IMO not noticably.
Overhead as in learning overhead or overhead as in performance? Cause after replacing a half dozen high performance Java systems with Kotlin I can tell you you lose nothing.
There a lot more to love about Kotlin than just the data classes.
"Google Suffers Another Setback in API Copyright Case. Now What?" Good. Google can stuff it.
1. Verbosity. 2. Nullable types 3. Extension functions (both the ability to make your own as well as the amazing set baked into the stdlib) 4. Coroutines 5. Multiline strings 6. Kotlinjs/Kotlin native 
Java creates bytecode, Kotlin creates bytecode, Lombok creates bytecode. Why does it matter? Never understood this argument.
Fair enough. However, my point was not that verbosity is necessarily a good thing, rather it’s not what you spent most of your time doing with modern tools. Honestly, I only see that argument if you write your Java in a textpad or something.
Interesting. You name dropped a bunch of things. None of which are good enough reasons to use a language that from my point of view (as someone who also writes Elm and Haskell) dosa nothing new. Seriously, Kotlin does not change the game at all. 
That's why I choose the word "innocent" rather than "good". I still agree with you: verbosity does not kill productivity, even less with a good IDE and a workstation powerful enough. But... I still miss those typescript features. It's like a quiality of life thing. It's not necessary but nice to have them. 
Agreed. It is. It’s just not enough for me...
yes it is 
When Google built Android, they used an implementation of Java called Apache Harmony, under the Apache license. None of Sun's (or Oracle's) code. Apache Harmony, an independent work-alike, was largely developed by IBM. Sun didn't have a problem with this and said so at the time. Oracle's case only survived by morphing into a copyright case about APIs. If APIs are copyrightable and independent implementations cannot be created, this upends a few decades of existing industry practice. In Android N, Google switched from Apache Harmony to genuine Oracle OpenJDK under GPL + Classpath license. Now Oracle should be happy. Oracle only bought Java because they saw it as a "Sue Google" opportunity. IBM did not buy Sun because Sun has a poison pill, where the founders would get some huge AIG sized payouts making the purchase of Sun unattractive. &amp;#x200B;
If I understood correctly: 1. Build the jlink image WITHOUT the business app, only the dependencies. This avoids your business app to be in the boot modulepath. If your business module is in the boot modulepath, it can't be updated. 2. Add a directory `app` with the subdirectories specified here: https://github.com/update4j/update4j/wiki/Documentation#integration-with-jlink, namely ``` image (the root dir output of jlink) |- app |- business |- classpath |- modulepath |- update4j ``` 3. Add the launcher script in `image/app/launcher.sh` with the code of the link above. The launcher launches the business app (or update4j main class if you're using Service delegate). 4. Put update4j jar into `image/app/update4j` 5. Put bootstrap jar dependencies into `image/app/classpath` or `image/app/modulepath` 6. Setup the configuration XML to download your updated business app module into `image/app/business` I'm still trying to pass step 1 which is create jlink without `--add-modules` argument, which is where the business app module used to be added so jlink could bake it.
What's the pay? 
Around 70-80k a year + equity.
If you're just going to be a winy little troll you're probably in the wrong thread then. I would never use Haskell or Elm over Kotlin, you're welcome to feel the opposite. You should probably take your trolling elsewhere though.
"Winy troll"? I asked for someone to come up with some actually convincing reasons why anyone would pick Kotlin over Java. You did your best, failed to do so - and I can only assume - decided the easiest way out of this for you when not in a Kotlin echo chamber, was to simply label me a troll. I believe you when you say you would never use either of those languages instead of Kotlin. That was also not the point, rather I tried to point out how some languages actually bring new and interesting (and safe) features all the way.
You gotta look at the number of commits per release and number of open issues. I stopped using it when 2.7.2 was released - it was a 6 month wait and contained a handful of tiny commits. There's even an issue about it now on their tracker.
Block chain, crypto, kotlin, flutter - all the buzzwords in one place. The post breaks the "no job offer" rule BTW.
not bad for Estonia
You should watch the James Gosling video on this to get this from the "horses" mouth. Also, Sun went to Oracle because they didn't want IBM to buy them because they hate each other. This should be common knowledge by now. 
Read the post there.. assuming the names match and that was your post.. so there are what, 7 continents, 195 countries, and something like 100,000 cities, or 2 million, depending on the criteria that the API you are calling uses to determine cities. So you have 1 API call that gets you 7 continents. Then you have 7 API calls that returns 195 countries. You then have 195 API calls that each return you some random number of cities. Did I read it right that it took you 7 hours to complete this? A total of 203 API calls took 7 hours to return all the data? After you ran them in parallel it got down to 30 minutes? Is that correct? That seems insanely way too long to me. I would assume something like this would take seconds. The first 8 calls should be instant. The remaining 195 calls to get cities, most I would suspect are not long at all. Obviously some countries like China, India, USA, etc would take longer. Assuming it uses gzip to compress the response, it shouldnt be that much data to send back. What am I missing?
I'm not sure I belong in the same list as the others, but thanks. I suspect you listed me because I'm fairly visible at conferences and on social media. There are others who work on Java, though, who I think are much more "guru" than me, but who have much less visibility on social media.
I agree, but I think following this guide can be the first step. The following steps could be refactorings towards actual language features.
Agreed on Java and Kotlin. But Lombok manipulates bytecode, which \*can\* confuse other tools. But I used it on some projects and it worked well.
I have a question &amp;#x200B; Do I need java today?
&gt;March 2018
It may be a bad idea, depending how good you are. I think you could start with something easier, say Mario clone or Tank 90 (I've did that, it way quite a lot work) and then go for jrpg. 
You’re welcome! The reason I mentioned you is because of your continued interaction with the community and extensive knowledge. Thank you for all that you’ve done!
&gt; You did your best, failed to do so Sure thing troll. Enjoy your down votes.
Good introduction to Spring &amp; extension of knowledge - Spring in Action. I've read it and it is really accessible. For Java: Effective Java. You can read a piece one a week and extend your knowladge greatly. For every programmer: Clean code. Must read. &amp;#x200B;
You can access private members of the enclosing class. Is it superior? No. Definitely not. Is it convenient? You betcha. And now, with lambdas, they're even easier to make and use and abuse.
How many different ones do you have? How many files would you need to create to have each ActionListener in a different class file? What percentage of each file would be boilerplate class definitions? How many places are each one used? Do any of the inner ActionListeners access non-public parts of the outer class? What additional complexity would be needed to support the necessary access?
Thanks for your reply, but I am still confused. What advantages will I get after accessing private members of the enclosing class? Thanks! (•‿•)
I know you are trying to make me understand something, but I just don't get it. Man I didn't even know what is boilerplate code, I googled it after your reply. I am currently reading a Java book, can you please explain me in layman's terms? Thanks!
&gt;You should watch the James Gosling video on this to get this from the "horses" mouth. Link?
Well, do you have any object oriented programming background? Do you know why objects have private and public members and methods? I strongly suggest getting familiar with that first, before diving head first into java (it's not that big of a thing), but , to put it succinctly: An object wants to expose as little information about itself as possible to the outside world. By expose, i mean making methods or members public or protected or package. Why? Because when something is exposes, becomes an API, becomes used by other objects and then is harder to change. Of course, an object to be useful needs to expose things. But the what and how much is the key. Now, having this inner class allows us to update the private state of this object without having to expose it if we don't want to. It would be perfectly fine if that inner class would be an external, standalone class and then it would update our object via a setXXX, or setYYY methods. 
https://www.youtube.com/results?search_query=+James+Gosling+oracle+sun+google
In simple words: learn about encapsulation. It is the core of object oriented programming.
Just give it a shot.
Thanks so much! Really appreciate your reply and learnt something new. Will probably start learning encapsulation, and the basics of OOP.
Thanks! Would definitely look into it!
Boilerplate code is there just to make it work, at least that is how I think about it. So in terms of 'I want to print "Hello World!" in Java' then all the code besides: System.out.println("Hello World!") would be your boilerplate. In your case and as mentioned by OP, the class definition to create an action listener is boilerplate. Depending on how many classes/action-listeners you have to create since you are no longer making them inner classes, it may not be worth the extra effort of implementing and maintaining just for the sake of separating them.
Because the inner class is the best. Trump 2020
'dev' (as in 'blue-haired game dev') is such an insult; he's probably a COBOL engineer
As with a lot of things you need to experience it to really appreciate it. I think there are enough "on the paper" reasons. But paper doesn't convince people. I was easily convinced a couple of weeks ago, because my first proper language was Python, then C# and then Java and Typescript. So Kotlin appears to me as the perfect blend of Python and Java. I started playing around and now write every new code in Kotlin - I am in the furtunate position to be allowed choose. However, I can understand that it depends a lot of the experience with Java. I've only used it for a bit more than 2 years along with Typescript. Some constructs haven't grown natural to me, so even the small things in Kotlin like consistent comparisons and nullability concept with the "all-are-reference" types spare me some valuable brain cycles. For someone reading and writing Java like a comic strip that might be the opposite.
&gt; Kotlin does not change the game at all. It's changes the game for Java developers without throwing the ground out from underneath them. That's a big deal.
Programming related questions should go in /r/javahelp as is stated in the sidebar. **Removed**
&gt; 'dev' (as in 'blue-haired indy dev') is such an insult; What? You personally know "Blue haired indy COBOL devs"?
No?
The issue with verbosity is not writing code, but reading code. It's about signal/noise ratio. Simply put, boilerplate distracts from the actual meaningful code. Of course, you need to find a balance: very dense code isn't easy to understand either.
Java doesn't "need" accessors and mutators, either. It's primarily institutionalized infrastructure that relies on awful bean-like assumptions.
Actually the continents, countries and cities are just example for understanding the hierarchy of API resources, please don't take it literally.
 this is code [https://licklink.net/OJ3Xa](https://licklink.net/OJ3Xa) and instruction fix error "We could not validate your license xxxxxx" [https://licklink.net/FgNZg](https://licklink.net/FgNZg) . it work! thank for wathching ! 
you do realize that at it's core Kotlin is so similar to java that it takes 2 hours to get familiarized with it.
It confuses Kotlin for example
I've read it really fast, my fault :D
Do you actually use JWT? I tried to use it a few years ago, then ran into a javascript problem in the browser I just could not debug. They could have improved since, personally I would not touch it with a 10 feet pole. It's just too complex under the hood. Vaadin worked much better.
10.0 feet ≈ 3.0 metres ^(1 foot ≈ 0.3m) ^(I'm a bot. Downvote to remove.) _____ ^| ^[Info](https://www.reddit.com/user/Bot_Metric/comments/8lt7af/i_am_a_bot/) ^| ^[PM](https://www.reddit.com/message/compose?to=Ttime5) ^| ^[Stats](http://botmetric.pythonanywhere.com) ^| ^[Opt-out](https://www.reddit.com/message/compose?to=Bot_Metric&amp;subject=Don't%20reply%20to%20me&amp;message=If%20you%20send%20this%20message,%20I%20will%20no%20longer%20reply%20to%20your%20comments%20and%20posts.) ^| ^[v.4.4.7](https://www.reddit.com/user/Bot_Metric/comments/8o9vgz/updates/) ^|
Sorry to put it bluntly but you're not the first (and not the last) person to make this mistake. The benchmark implementation is completely utterly useless since you don't take VM warm-up into account. If you want to do synthetic benchmarks like these at least use [JMH](https://openjdk.java.net/projects/code-tools/jmh/). You're 
I already use Kotlin so there wasn't much of a takeaway from this article for me, except: * Java 11 has `var` so you don't need Lombok for that any more. No `val` though, you end with `final var`! * `@Cleanup` from Lombok... I have never used this, I don't even know why it's a thing. Use try-with-resources, it's been around since Java 7! I'm amazed that Lombok hasn't just deprecated this. You'll also need to be aware that nested `use` in Kotlin is actually a pain; you'll end up with something like [this](https://stackoverflow.com/a/46843631/261017).
I work for the company developing jwt. We use the framework for some in-house projects and my experience is that it is quite stable nowadays. But it's definitely easy being at the source whenever running into bugs. If there is a JS error from code generated by the framework, you can always consider it to be a bug in jwt and submit a bug or post on the forum: [https://redmine.emweb.be/projects/jwt/issues](https://redmine.emweb.be/projects/jwt/issues) 
i am using same software.. and had same error. Maybe colleague in Slovanet? :D Set **run as admin** on *jp2launcher.exe* &amp;#x200B;
And there's a lot more coming to Java than just data classes.
What happened?
It doesnt know about lombok classes while compiling. There are hacky ways to fix it but they are not worth it
Me too ;)
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
;-) No worries!
Lol... your opinion still sucks. You still haven't supported your point that they are running a scam.
There's no val in Java indeed, which is very disappointing. Apparently some people didn't like var/val, so they opted to only implement var. I guess the people who didn't appreciate the 'val' could have opted to just not use val, but apparently that wasn't an option. See here for more info, it's quite an interesting read: http://mail.openjdk.java.net/pipermail/platform-jep-discuss/2016-December/000066.html
you mean text base as more console like? no graphics at all?
I have no experience myself with the Kotlin support in Eclipse, but the Kotlin plugin, seems to be actively developed here: https://github.com/JetBrains/kotlin-eclipse
It does not "upend a few decades of existing industry practice," because those practices may (and probably do) fall under fair use, even with the APIs copyrighted. The court determined that Google's *particular* use of the APIs was unlike those "existing industry practices": https://en.wikipedia.org/wiki/Oracle_America,_Inc._v._Google,_Inc.#Appeals_Court_and_finding_of_non-fair-use
That's not because of 'lombok confuses Kotlin'. Classes created with Lombok can perfectly be used with Kotlin. What confuses the compilation of Kotlin + Lombok code is that those processes happen at the same time, and that the Kotlin compiler tries to find the methods which haven't been generated by the Lombok plugin. Moving the Lombok code to a separate module is a feasible workaround for this.
&gt; There are hacky ways to fix it but they are not worth it 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
It looks like in your [submission](https://www.reddit.com/r/java/comments/aims28/help_i_am_making_a_converter_gui_application_for/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
And note that records in Java will be far better than Kotlin with full pattern matching, etc. When Oracle changes/updates the language they have the benefit of also changing/updating the JVM when needed. Stick with real Java for the best experience. 
Or be a real engineer and learn both so you can use the best tool for the job.
Did I understand right? You are happy with Lombok and want to keep it? If not, is doing first Delombok, move to Kotlin and then refactor an alternative? If not, why?
Migrating out of lombok is a ton of work for those services. So they will be kept as is New services are done in Kotlin already
This approach makes sense. It makes sense with alomost all migrations anyway. Thank you for sharing!
XML is fine. I don't understand why people have such an aversion to it. For new projects sure I would go with something else. But I don't see a strong reason to rewrite something existing just to get rid of XML.
companion object in Kotlin is a bloody joke. its a disguised STATIC instance. static state is cancer. 
Parsing XML is a nightmare, and JSON is a better option 100% of the time
It was basically ASCII art. The main character was an asterisk
Wouldn't it be better to use some sort of ETL for this? Assuming the data changes are infrequent (how often are new cities added to a country, much less new continents). You could have a service that extracts that data for you and puts it in some kind of persistent storage. That would give you much faster access to the data as well as the ability to query in a more intelligent fashion (don't give me ALL THE DATA, just this piece).
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Light; it was chosen for me 12 years ago when I started using the IDE. These days I find dark modes hard to read.
For some reason I like light for Java and dark for everything else( mostly web html/css/js ). I've tried coding java in dark mode and something was not right, but I had no problem with javascript in dark mode.
Dark - I find it to be less tiring on my eyes for a day's work.
I am a great believer is just doing something and learning along the way. Don't be afraid to aim high. I'd say go for it, just don't expect everything to work directly and you wil fail, a lot, just just need to keep going, it'll work, eventually. 
Really? Just use JAXB and serialise the xml to an object.
IMHO I think it's not too much, as you have programming experience before. Using selenium in Java is actually very easy, you can even generate code via Selenium IDE. I've been using Selenium in my projects for about 3 years, later I also use JXBrowser for some automation stuff. &amp;#x200B; I think it's always a good approach to migrate to a new language via migrating you old projects, so JUST DO IT, good luck!
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Dark mode for me. I use IDEA most of the time and I always find Dracula theme works much better for me.
Go into it with high hopes but realistic expectations. You have to remember that this is a very different project for your current skill level, but you will undoubtedly learn a LOT along the way. If you just want to learn, then do it, but if you want to make the transition for practical reasons, perhaps it's a project to leave tabled for now.
&gt; now learning JAVA. You're learning what?
Spot on, reminds me of that opengl library that was way more typing and you still had to know exactly what you where doing, no real advantage.
&gt; Dracula theme Did auto-correct change "Darcula" to "Dracula"?
jAVA, I mean, JaVa, I mean, Jawa, I mean, Wut?
Hey dude, I always want to write my own RPG game regarding adventures of a SwordMan, but never achieved till now:( I just cannot find concentrated time to do it, if you are a student and time is not a problem, I think it's a great attempt to master programming skills, keep going and JUST DO IT, and please don't forget to share what you have done after you made it.
I like the high contrast mode of Intellij Idea, makes reading text much easier on my eyes. (Could be a placebo that stems from my belief that our eyes evolved to see reflected light but not look directly at light sources). That being said, its abrupt and painful transition when I have to switch from IDE to browser / other applications or even windows explorer. For some reason black text over a white background is the norm everywhere, which seems very unnatural to me.
I presonally prefer xml over the likes of json and yaml as it has a schema that the editor can validate against and provide autocomplete and it also often contains comments/documentation meaning a quick shortcut to see it. With json/yaml stuff i often find myself switching between a browser and editor to read documentation and then write it and no help against typos. But i guess that landscape is young and schema use will be more common in the future.
Java is a great language to learn with. It is good for backend services and guis. You can learn about data structures and algorithms and multithreaded programming in an efficient manner as it has many data structures and nice, high level abstractions included. I would, however, focus less on "learning a language" and try to focus on learning about Computer Science. The truths you learn there can be applied in any language you then choose (or are forced to use). The best way to do this is to go to university and study CS full time for five years or so. Of course, this may not be an option. If uni is not possible try to find courses and books which have a 50/50 mix of theory and practice. Look at uni syllabus to find what subjects and order they follow. And enjoy the journey! Computer science and coding is wonderful! Great to have another nerd on board :)
Step 1: unsubscribe from /r/java Step 2: subscribe to /r/learnjava
Most of the time I used XML in the same way as JSON, ad-hoc without a schema, but once I started defining my data a bit better XML worked great for me. Its a mature data markup spec with lots of supporting enterprise tooling around it and lots of Java support. Use it if you want to. Or not. Its all in how you use it. 
Dark mode, though it's not really about the color tone, but rather contrast / intensity. Pure white letters on pure black (as in Windows dark theme) is almost as bad as pure black on pure white background. I find that a greyish background works for me, such as IntelliJ's Darcula theme.
Light mode. Back in the day it was a dark crt with green phosphor. When I have to use a Lisa as the development platform for the early Macintosh (eg, 1984) I began using light mode, GUI editors and other tools, and never looked back. The black on white was more like paper. fast forward several decades: I work in a very well lit office and light mode is easier to read. Dark mode, IMO, looks cool. But in practice I wouldn't use it. If I were to seriously try dark mode, then EVERYTHING on the computer should support dark mode. The worst thing about my attempts at trying dark mode is that most everything else is light mode. &amp;#x200B;
I hate having to mess with XML files, but I have to admit that they nailed the whole "everything needs a schema" point. That being part of XML has made it stick around much longer, in addition to being essentially a superset of HTML. If you're actually converting the XML structure into a data structure in memory, it doesn't really matter which format you use, just use whatever is best for your application. We have services that consume XML and produce JSON, or even consume JSON and produce XML, but for the most part that's handled by some annotations that tells the framework how to de/serialize. XML is gross to work with in other languages too. I'd rather use JSON in Python or JS, but those have native and lightweight data objects (dict/Object respectively). But that's mostly syntax and not having to worry about the type system.
Ok, looks like I didn't express it clearly enough. I will update the wiki soon to emphasize it. Your image should *only* include JVM system modules. The current release requires you to add the whole `java.se` module (since we want you to update your app even if you don't currently know what modules you will require in the future) but after [a discussion](https://gitter.im/update4j/update4j?at=5c1fa5582863d8612b79f25f) I decided to leave this to the developer to decide. On a minimum we only need `java.xml`. This change is not released yet, you are free to build from source. So to create the image: jlink --add-modules all.sys.modules,you.will,ever.need --output image --compress=2 If after a while you end up needing more than `all.sys.modules`, `you.will` and `ever.need`, you will have to release a complete new image to your clients. (Nothing keeps you from silently downloading the new image using update4j and move over seamlessly.)
/r/learnjava is for learning Java (not Android) related topics. **Removed**
Light during the day at work. Dark during the evening at home.
For anyone wondering, xml is usually backed with an schema and that alone makes it valuable, think about data interchange between systems. And parsing should never be done manually, there is some encoding to take care of and that is better suited to libraries as JAXB which is very mature which translate between object and xml(as bytes) automagically, as mentioned another comment.
Learn concepts, not languages. You can use learning one language to learn concepts but don’t lock yourself in. If you learn Java, learn how/why Java does things. How it’s good. How it’s bad. Then you can learn any language or structure. 
&gt;(Could be a placebo that stems from my belief that our eyes evolved to see reflected light but not look directly at light sources). How do you think your eyes can tell whether or not a photon was reflected prior to being absorbed by your rods/cones?
I am usually warm towards XML, my favorite that it is a good format to describe tree structure, allows you to have data and metadata (attributes), and there are tools like jaxb to make it easier to serialize/validate the message makes it a good format to use. Granted if I want something lighter, I do use JSON as it is also more web friendly.
Thanks for the reply. So other than the way the image is created, the other steps I put there seem correct?
JSON, YAML, and XML - I've had to use all in the last years and I would say while every format has its strengths and weaknesses, I care more about the hierarchical structure of the data. Super-verbose configurations are the worst, whatever format is used. One fun thing I've got to mention when it comes to readability are XAML files, which are XML files describing a declarative UI (for WPF). A few years ago I was on an XML-crusade and tried to write a custom parser and loader for using YAML instead of XML. I set up a prototype set up and then discovered that I had one readability-related issue: it sucked to come to the end of list or elements and not be able to see what type the parent node is (UI containers) - like having a XML closing tag &lt;/Grid&gt;. I started to miss the one thing that people hate the most about XML and gave up my prototype.
Among other things, I got a pretty cool notepad out of it \^\^
The funny thing about XML is that it is more complicated than objects. While objects can have other objects as members, XML tags can have attributes and contain other tags and plain text in any order. So we use a structure much more complicated than ordinary objects to configure an OOP program. Of course, any kind of config data that is not in the language you want to use in the end, is already suboptimal. 
Yeah XML does not map well into standard objects and data structures. Definitely a benefit of json
Very good point. IDEA is very good at code completion But incremental build is miles better in Eclipse. Problems view is a time saver. I use Eclipse whenever i can.
your point stands on run of the mill repetitive dumb code verbosity is much needed in complex non repetitive code. setters and getters are a godsend. in the IDE.. if i want to modify an object, i press obj.set CTRL+SPACE and i get to know what i can do When programming in Swift who decided to remove setters, its a pain. The funny thing is they had to keep setters for setters with more than 1 parameters.. HOW STUPID IS THAT? Code becomes a mess. 
Those features are the realm of the IDE. IDEs should create all those fields from constructor by themselves. then if you want to tweak.. go on.
Yeah, almost like JSON was created to serialise object to strings like some sort of object notation language or something. Maybe I’m overthinking this. 
Also high contrast. Dark mode in Intellij was too subtle for me. I could not make out differences (even though I used dark mode in other editors like Sublime) 
Nah man, your over thinking it...
&gt;The domain configuration file will grow with JNDI and JDBC properties and be several hundreds of lines of XML which just becomes messy and difficult to read. It's not super common to heavily modify that file. Why did you feel the need to do that? Data sources for instance can be defined via annotations like @DataSourceDefinition.
Good to know. I mean here's me thinking I'd been using XML incorrectly for the last 20 years, being the defacto language agnostic data/metadata interoperability standard. Phew!
I understand JSF ;) Whether I *truly* understand it is more of a philosophical question. Does anyone ever truly understands anything?
There's a max number of points you can get every day. The top SO users hit that limit every day, so they all move at the same speed forwards, or in other words, no-one can ever overtake another.
Uhh, Java EE Security? JACC? JASPIC? Soteria? This is missing quite a few things.
But bounties don't count against that limit, is my point
Languages/environments are not tools in the category whereby you choose what's best for the job. A language/environment is a major commitment that will affect everything about the project: libraries, IDEs, hiring, etc. I've worked on polyglot projects and they're a nightmare. Pick a language/environment and stick to it. If you want Kotlin, fine, do that. 
Light. You see all the glares on your dark screen. Also, it's harder to read text, to me, so eyes are tired quite fast. 
Ah.. ok.. my bad. that makes more sense. So essentially you got an entry API endpoint, that returns some set of responses. From that, HATEOAS style (or similar rather) you take the IDs from the response, and make multiple API calls, each resulting in further (potentially longer) lists of data, with IDs, and then you further "drill down" on that data. First thing is to potentially build an API that can take in criteria in a single call to help reduce the response set you get back. Not sure if that is possible with the API you are actually using, and if you have the option to do this (e.g. build a new API endpoint that can reduce the cost of API requests from clients). 
To each their own, some thrive in polyglot environments. I'm currently working on a project with Java, Kotlin, Scala, Go, and Ruby and everyone has been enjoying the work so far.
...also Jon Skeet.
Selenium has a vba plugin TIL
You can always open a pull request :)
Ah..HOLY COW! You got it dude, the first time I spell as Darcula, then it says there is a mistake, then I googled, just find the first item is Dracula, but got to find the actual one should be Darcula, XD. Darcula rocks.
To misquote Churchill: &gt; Many forms of Data Representation have been tried, and will be tried in this world of sin and woe. No one pretends that XML is perfect or all-wise. Indeed it has been said that XML is the worst form of Data Representation except for all those other forms that have been tried from time to time. JSON is too simple (no integer type for example) and YAML is a [hoax](https://arp242.net/weblog/yaml_probably_not_so_great_after_all.html) perpertrated by pranksters.
Dark, so much easier on the eyes. I was late to the party with dark themes, but now since I discovered the joys of dark themes I can barely live without them in an app.
Dark mode. It's easier on my eyes.
You should take a look at the [Apache Wicket](https://wicket.apache.org/) and its [Apache Wicket examples page](https://wicket.apache.org/learn/examples/index.html). Apache Wicket is a component based framework which provides a fairly clean separation between Java code and HTML. &amp;#x200B;
Yes, please open a PR!
Like Brian Goetz said: even if your code was autogenerated, it *still* is code that you have to maintain, and for the next programmer that doesn't know how you generated the code (and possibly doesn't use the same IDE you do), he *has* to read every single line of code, only to realize, 200 lines later, that it was just a dumb class with 5 properties (and no, he didn't spot the toString being incorrect because properties were added later). There's more than boilerplate that you save when you have a *direct* syntax, what really matters is intent, that's what you are conveying and this is key. This is the same reason gotos were removed in favor of intent-specific control-flows. Obviously we are not going to jump to just any language with lots of keywords and syntactic sugar, but there really is a reason to try and improve the current situation. Whether kotlin is or not the way to go, time will tell.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Yeah, the SDK look expansive at first but are really bare bones if you actually want to get somethingore complex done. Although, I would recommend that people try developing with sources, not just against their own IntelliJ installation where the only thing you see is the api without even javadoc... The simplest thing to do so is to use the IntelliJ gradle plugin, which is gradle plugin to develop IntelliJ plugins. IntelliJ has templates for that if you go with a new gradle project.
Some extra context here - The primary motivation for creating the library is for creating linting rules for avro schemas in an API environment to enforce style checks on models. Related links: Example Impl repo - https://github.com/zsmoore/JSONCustomLintrExampleImplementation Maven info link - https://search.maven.org/artifact/com.zachary-moore/JSONCustomLintr/1.0.0/pom Thanks!
Light, light, light, a thousands times, light.
 A lot of aspiring developers tell me that they want to program a JRPG-style game, with little to no programming experience. Within the past few months, I’ve had several potential students ask me about developing a game like *Pokemon* or *Fire Emblem*for a semester-long project in a high school programming class. 
If you pull your head out of your ass you would be able to see that I did support my point. But, just like with any idiotic idea (antivax,Trump,religion,etc.), since not logic brought you to your opinion no logic will get you out of it. 
Lol, how is it eclipse's fault if you install every shitty plugin there is?
What do you want to make?
 Something like this will probably run a decent bit faster. You aren't supposed to use the global fork-join pool for blocking operations. You are essentially limiting yourself to one thread per core with that. You can construct your own thread pool with N threads and achieve a higher level of parallelism. This isn't the exact syntax. The key point is to pass the executor to the supplyAsync function. private static final ExecutorService exec = Executors.newFixedThreadPool(50); private List&lt;City&gt; getCities() { return getAllContinents() .flatMap(continent -&gt; getAllCountriesOfContinent(continent, exec)) .flatMap(country -&gt; getAllCitiesOfCountry(country, exec)) .flatMap(feature -&gt; feature.join()) .collect(Collectors.toList()); } private CompletableFuture&lt;List&lt;Country&gt;&gt; getAllCountriesOfContinent(Continent continent, ExecutorService exec) { return CompletableFuture.supplyAsync(() -&gt; { return restClient.getDataFromApi(continent); }, exec); } private CompletableFuture&lt;List&lt;City&gt;&gt; getAllCitiesOfCountry(Country country, ExecutorSerivce exec) { return CompletableFuture.supplyAsync(() -&gt; { return restClient.getDataFromApi(country); }, exec); }
don't learn jsps. But servlets yes. Servlets are the underlying tech behind spring web apps.
If you ever end up working at a place that has been around awhile and has legacy code, probably going to benefit from knowing jsp and servlet. Probably doesn’t require expertise, but knowing fundamentals is a huge help
I'd like to get into the web development side of Java
Backend or front end?
My java IDE is white background. Sublime and vim are dark background. I learned java on a white background so it feels different when I go dark.
Learn it! You don’t have to know every intricacy. Spend just a solid couple of days learning the basics and give yourself a sample web app project. I’ve been working with Servlets and JSPs on and off for the past 10 years. Even as the company I was working for moved on to Spring and other solutions, they’re nestled all over legacy systems. I also just went for a senior java developer interview at a new company and JSPs were part of the interview, and I know Servlets will be present. It’s a very low-cost time investment that will strengthen your knowledge of how we got here and is certain to come up at some point in your career anyway. 
backend probably.
thank you! 
Come to macOS, dark mode everywhere is amazing
tl;dr learn Servlets &amp; JSPs, they teach you valuable lessons. &amp;#x200B; Spring, Struts and other (web) frameworks were built to make things easier. Over time, the developers added a lot of features into these frameworks and it might a bit overwhelming if you're trying to understand them. When I was a junior developer, I tried a side project with no frameworks, just servlets, because I haven't really understood Struts at that time and Spring was really overkill for what I was trying to achieve. Lo-and-behold, without realizing it at first, I ended up implementing a tiny version of Struts(mainly, the Front Servlet (or Front Controller if you like). Then ALL made sense and it was easy for me to eventually add, configure Struts and refactor my code. &amp;#x200B; Go for it! Learn servlets! Learn servlet filters! JSP, whilst not really common as Thymeleaf exists, can still be used with Spring, so it's also worth learning.
light mode - Java developer with 15 yesterday if experience I am so used to eclipse color scheme that if it is different I not only can't read it but doesn't look like Java to me ;) Even with Idea I use classic eclipse as color theme. p.s. At least i was able to switch to Monaco font from courier new :)))
My eyes do better with dark mode.
Dude u have 10 years experience and you're still senior?Why? 
I'm personally of the opinion that it makes more sense to start at a high level and once you get that down, go into the lower levels. There are plenty modern web frameworks for Java that don't even use Servlets anymore (Spring Reactive Web for example), and JSP is completely outdated and generally only used in relatively old projects. Once you have a good grasp of developing web apps with (for example) Spring, it's easy enough to learn JSP and Servlets on the job if need be.
Good bot.
Spring is a good place to start. 
I love this library. Saved me a lot of time. Thanks ! 
Unfortunately I don't have ability to modify somehow that API and I should to use what I have
Hu? What else would you be?
Actually I thought about that but I already has some legacy script which did pretty similar task, so I decided try to reuse it just modifying a little bit. As for don't give all the data - unfortunately we need to reload all data sometimes because we use ElasticSearch and we need to modify mapping and repopulate index there.
Thank you for such detailed answer, I'll try to apply it and then share my results!
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Ah, ok. TIL ;)
Your "point" was that VS Code features are &gt; IDEA. Even if I accepted that 100%, you haven't refuted the point I made: namely that *"FOSS products that don't charge a fee ultimately have to get some form of organizational/corporate support in order to be sustainable. They are ultimately funded by the companies that support them who then disperse the cost across their fixed costs. In the meantime, we get to pretend that those things are 'free'; that they don't cost anything."* Also, you accused JetBrains of a scam, and you have not provided any substance to that. Feel free to dish. Or STFU.
From my very limited understanding, there is a significant difference in flux and frequency spectrum of incident and reflected light. The reason we are able to perceive color of an object is because of change in frequency of light when reflected from its surface right ? Incident light has a lot more energy and volume than reflected light.
Failsafe is also the name of the Maven integration test plugin, so there's no way these aren't going to get confused.
Thanks! Who’s still doing Java EE in these days of microservices (eg using spring boot /cloud) anyway? ;)
Pros and cons compared to Resilience4j? [https://github.com/resilience4j/resilience4j](https://github.com/resilience4j/resilience4j) 
A lot of people ;) For MicroServices, specifically look at the tech preview in the announcement: * Eclipse MicroProfile Config, which supports the management of microservice configurable parameters across environments * Eclipse MicroProfile REST Client library, a type-safe approach to invoke RESTful microservices * MicroProfile OpenTracing, which permits the tracing of requests across a microservices-based application * MicroProfile Health, which checks the state of microservices * Extension of RESTEasy, to support asynchronous request processing and reactive return types.
Ditch jsp’s and servlets. They are relics of the past. Either decide you want to become a front end OR a backend dev. If backend dev, and you want to stick with Java, go for spring (boot) and go make your awesome REST API for your frontend to consume. Forget about the idea you can show off with nice and shiny GUIs, instead, accept you’ll never be able to show off your work for any user. If you go backend, you’ll be the unsung hero of the trenches that has to consider all those ‘boring’ aspects like scalability, security, maintainability, life cycle management, integrations, datastorea, queues and so on. :) If you go frontend, even more ditch all this backend server stuff and go for all the nice and shiney frontend frameworks like Angular, Polymer, React or any new fashionable thing that pops up every new year. Show off your nice and shiny GUI and start complaining about the slow progress and performance of the backend. You care about the exact correct gradient of corners of UI elements, UX design and features. If you show your stuff, you wow the customer. Frontend work done by backenders is dead in my view and only relevant in (enterprise) projects where having a super nice and shiny GUI is not really important. Happy hacking ;)
Elder
Gotta propose that to my boss... 😉
Nice! Looks like a neat little library.
Technically higher up in management probably. But that isn't a job for people, that like to code.
How about Arhitect, TechLead,TeamLead? &amp;#x200B;
Good to see a Jboss is now supporting the Jakarta MP apis with their regular server instead of keeping them hidden in Swarm/Thorntail/little rye etc.
Other good frameworks for Java use Servlets, like JSF for example
Java EE/Jakarta EE is a good place to start.
Architect is barely a programming function. You don't code, you make tickets for other people to code, you just tell them how you think it'll work. Techlead is basically senior programmer with a bit more responsibility - I have to give you that, it might be a path, but then again, it's not for everyone, since you don't do much original coding then either (am one, can confirm). TeamLead is also a management function - you code the same, but you also give out tickets. It's a job for a monkey. Was one, can confirm. 
Know it. It is not important to be an expert but is nice to know what they are and how they work. I know them because 20 years ago all that we had was servlets. When writing JSPs it was extremely important that we know servlets to be able to better debug the issues that came up. Nowadays, however, with technologies like Spring, with API-based websites and their heavy frontend, it is less important. It's quite irrelevant, actually. 
Make a hello world and a hello {{ name }} in servlets/jsps and then move on. I see a bunch of people saying you should learn it but I wouldn't go further than that.
No. Been doing java developer for over 10 years, ain't had to use a servlet or jsp in a long time. There's no value in learning it. Stick with spring.
It will only take 1 hour to study and test sample servlets and jsp. You just need to know the basics. Rest you can continue with spring onward.
If I make an 404 request, then the standard error page of springboot can tell the user that it's deployed on springboot. Hence you can configure your error page instead of default springboot error page. &amp;#x200B; &gt;Whilelabel Error Page &amp;#x200B;
You should have referred to this one . &amp;#x200B; [https://dzone.com/articles/this-week-in-spring-january-15th-2019](https://dzone.com/articles/this-week-in-spring-january-15th-2019)
Most of the comments seem to support the idea that XML, having a validating schema, tends to be a better solution and that is something I do agree with. I much prefer XML over JSON for serialization or configuration. But you also mentioned the use of the annotation-based configurations versus XML and my take on this is again I prefer the XML based approach. The primary reason is that if the configuration is via an annotation, if the configuration has to change you must recompile the code so a developer must be involved. If the configurations are in an XML file then a configuration manager/devops person can make the changes. XML based configuration files can also vary by environment and/or lifecycle much more easily than annotations can. 
Nice work Jonathan.
That is all generally true but only for a given light source, not categorically. If you have a light bulb illuminating an object, the object will tend to absorb some of the incident light; reflect some of the incident light diffusely, scattering it; and, if it's at all shiny, reflect some of it specularly, like a mirror. Which frequencies are absorbed determines the color of the object and it is the case that, for anything short of a perfect mirror, the reflected light as detected at any location, is less intense than the light originally incident on the object. However, if you decide on an observation point and precisely know the properties of the object and the power spectrum of the lamp's light (that is, how intense its emission is at every frequency), you could replace that object with a light source that emits exactly what the object would have reflected to that observation point and the change would be utterly undiscernable: Down to the quantum level, there would be no difference in appearance. Reflectedness is not a property of light. An object that is illuminated is, from the perspective of a viewer, as much a light source as is a monitor.
You do know that EE runs perfectly fine in a microservice, right? And that Spring supports it?
Bellsoft has released Liberica JDK for Solaris SPARC and x86: \- 11.0.2 [https://www.bell-sw.com/pages/java-11.0.2/](https://www.bell-sw.com/pages/java-11.0.2/) \- 8u202 [https://www.bell-sw.com/pages/java-8u202](https://www.bell-sw.com/pages/java-8u202)
Use Liberica JDK installer. E.g. version 8u202 [https://github.com/bell-sw/Liberica/releases/download/8u202/bellsoft-jdk8u202-macos-amd64.dmg](https://github.com/bell-sw/Liberica/releases/download/8u202/bellsoft-jdk8u202-macos-amd64.dmg)
Try Liberica JDK. MacOS installer version 8u202 [https://github.com/bell-sw/Liberica/releases/download/8u202/bellsoft-jdk8u202-macos-amd64.dmg](https://github.com/bell-sw/Liberica/releases/download/8u202/bellsoft-jdk8u202-macos-amd64.dmg) More information here [https://www.bell-sw.com/java.html](https://www.bell-sw.com/java.html)
If they're different hostnames why not just link to the boot hostname from the content IIS serves? 
I don't get what this is supposed to solve. It seems to be wrapping an object then does a connect to/from ... what?? Java Object has no concept of TCP. Where is the connect coming from? What is being connected to? Is this a replacement for, complimentary to or not related to Java exception handling?
I've tried it, it hardly works &amp; throws errors all the time.
I feel like FOSDEM needs to grow up and improve their presentation guidelines.
I'm not sure I visual what you're saying exactly. For example, say I have one IP for the whole server: [75.75.75.75](https://75.75.75.75) # IIS: \- **Site A** = same IP and is [www.example.com](https://www.example.com) \- **Site B** = same IP and is [www.another-example.com](https://www.another-example.com) # Spring Boot: \- **Site C** = same IP and is [www.yet-another-example.com](https://www.yet-another-example.com) Two sites are running on IIS and one in a Spring Boot Tomcat container. All need to run on the same Windows Server using a shared IP. If I'm running it in this scenario, would IIS need to be involved at all in the requests for **Site C**?
Thanks for the info .. but *eek*, mastered C# and Java? ... makes me feel even dumber. :(
Thanks for this, good to have a list to read up on and follow relevant players. :)
Thanks for the info u/gnatbeetle. My original question was basically an "overall" recognized expert in the Java community. Not SO or whatever related. E.g., if this was asked for Linux - Linus T. would be one of the top, if not *the* top name. Because of his work, not his activity on a particular site per se.
k.
Usually it's done by using some kind of proxy in front of the servers that delegates the calls to the correct instance. I think you can use IIS for it but I'm not too sure. Otherwise, either apache or haproxy are good and easy to use tools for what you want
I'm going to keep it short. There are many reasons to learn Java. Here are a few that might resonate: - the JVM. It's an amazing piece of technology that has both stood the test of time and kept progressing, pushing forward - so so so many work places use it. You'll be marketable to work on some pretty neat projects. - you'll be perfectly suited to learn Kotlin (which is finally a modern language that has actual momentum. It's Java + learnings from "effective Java") 
&gt; makes me feel even dumber. :( The imposter is strong with this one
The main purpose is to implement the retry pattern, which imo is essential if your java app has to communicate with any external resource. Spring has a similar built in that works well but is clunky in typical spring fashion. 
You already know Python/JavaScript/C/Lisp/Haskell. You should already know all programming languages come with their warts. On top of that, learning another language shouldn't come at great difficulty to you. Therefore, learn Java if you \*need\* it.
Java is just a C based language. Newer versions have some cool features you may or may not care about. The value of Java, unlike all the other "languages" you mention, is the mature, cohesive ecosystem. Cohesive means that for a long time Sun led the way about how things should look and people building libraries that did amazing things followed their lead. That means that if you learned one API e.g. JCA, then you pretty much got every other one for free since they all follow a similar model. In programming whenever you are faced with a new problem domain, you really have two problems. One is the problem domain and the other is the weird way [Python, JS] has tried to solve it. With Java you are already familiar with the way things work pretty much so the cognitive load is significantly reduced. 
Maalus' description of Architect is exactly what I saw at my previous company as well. I had this idealized dream of working my way up to "Architect" until I met 3 of them. I had imagined them to be these masterminds of combining incredible system design skill with robust, *deep* technical knowledge. What I found were oddly disconnected individuals with patchy knowledge, some implementing *horrendous* designs, whose job consisted largely of "gatekeeper" for project managers trying to get their design docs approved. I'm sure the title of "Architect" isn't so misused at every company. For me, it simply wasn't viable. To answer your question, I spent the first 9 years as a full-stack developer with a gradually increasing scope of responsibilities and autonomy. By the end I was a mix of solution engineer and developer designing and implementing entire solutions myself - it was great! For year 10 I switched off of development entirely to full blown Project Manager and discovered I really didn't care for it. Two big lessons I've learned from this first chapter in my career are 1) Titles can be very misleading, it's more important to understand if the day-to-day work is interesting. 2) The traditional career trajectory from "doer" to "manager" is only as valuable as what the "doing" and "managing" *actually* consist of. One isn't inherently better than the other. In the case of programming, they may be *entirely* different disciplines!
In Java, you have monadic lazy operations on Streams nowadays, if that helps. You can also write Clojure which is Lisp dialect on the JVM, so you can also call Java libraries. You can also write Scala, which is somewhere between OOP and functional, can use all the Java libraries, and you can have limited dependent typing (called path dependent types). Typeclasses are more verbose than Haskel, though. 
Thanks for your answer!
https://www.indeed.com/salaries/Java-Developer-Salaries
Thanks for your answer! Yes, but except JavaScript, I was really excited about learning the others. But I will have to learn it, at least enough for the course.
Maybe. Working on it though.
Pretty much everyone who isn't writing a brand new application.
I once was a long time card carrying Apple fanboy and classic mac developer. But that passed when OS X came along, all my expensive hardware was instantly obsolete, and I started using Linux. Although I use Windows at work, where I'm not responsible for maintaining it, I only use Linux for everything personal. I expect that all-dark support will come to Linux, in time. If it is worth having. I'm still not entirely convinced. But I'm not closed minded to dark mode.
Ok, thanks for your answer! I think you're right, and I hope that I didn't offend anyone. But any list which includes C and Lisp by no mean deserves the quotes in "languages".
First, the answer about the JVM and Kotlin is very good. As for the language Java, I would point out that it is extremely toolable. I mean if you use a modern IDE. Eclipse. Netbeans. IntelliJ. The refactoring tools for large code bases are amazing. And other tools. I personally now have some resistance to learning any new language that doesn't have the kind of power tools that Java the language has. It's like, oh . . . to use this language I'll have to go back to the stone ages of an ordinary 'text editor' again. &amp;#x200B;
wasn't using any plugins at all
Thanks a lot for your answer! I will research more about monadic lazy operations in Java. &gt;You can also write Clojure which is Lisp dialect on the JVM, so you can also call Java libraries. Yes, I knew. But now I have to write Java, not Kotlin, not Clojure, not Scala. &amp;#x200B;
 Do it **but keep the following in mind**: When you're passionate about a project, you can often get away with writing large portions of it using very *little* of what a programming language has to offer. When this happens, the game may work but you've only learned a fraction of what you could have! As you're going along, try to apply design patterns and dig into Java features. Ask yourself things like, "Can I create an abstraction layer for this combat function? Rather than take in Player and Mob classes, could I create an Entity Interface or Abstract Class? Maybe I could use Generics? What's the **best** Collection implementation for Inventory, even if it's overkill?" Do this and not only will you learn a lot more but your game will likely be way more modular and expandable! (Especially good for this inevitable rewrites.)
Focus on programming *well* rather than learning language after language. Programming is a lot like an art. Your artifacts need to attain some degree of perfection in order to be taken seriously. To know a multitude of programming languages is not the essence of a competent software creator. 
Summarizing your reasons: * the JVM * the Java ecosystem and its cohesiveness * it is ubiquitous and highly marketable * many languages written for the JVM (Kotlin, Scala, Clojure) * low cognitive load * some cool features like lazy monadic types in streams You have made my burden of "learning" (I won't be a Java programmer in a month) it a little less of a burden. Thank you **very** much for your time and answers!
* great backwards compatibility – your 20-year-old code will usually work even without recompiling * the only major language with a decent crossplatform GUI in the standard library (and a second crossplatform GUI recently separated from the standard library) * huge ecosystem – if you're looking for something, then most likely someone has already implemented it in Java * well suited for large projects * excellent tooling (IDEs, code analysers, decompilers, debuggers, monitoring tools, etc.; build systems also do a good job in most circumstances) * good performance and great garbage-collector Recent versions of Java gave it support for lambdas and thé best date-time library. The language is of course quite verbose and rigid and it's not changing any time soon, but I find it make it easier to analyse huge codebases (as long as developers didn't overdo "best practices" and "design patterns", which is a bit too common in the Java community).
Thanks for the info. haproxy is a *nix only solution, so would not work on Windows unfortunately.
Java has nice features. Keep in consideration what do you want to use it for. Also keep in mind that programming languages essentially are tools. They have their strengths and weaknesses. Bulletpoints: * C/C++ and Java have very similar syntax. * Java is OOP heavy. If you are interested in OOP programming you can learn a lot. * Annotations in language. * Java Virtual Machine: Your code compiles into bytecode which runs on JVM. JVM completely hides CPU architectures from you. You write a piece of code on Linux, you can run it on Windows the next day. (if both OS have the Java Runtime installed of course) (there are a few libraries which break this due to special requirement but their number is minimal). * Java has multiple editions. Java Standard Edition, Java Enterprise Edition. The former is the language itself with builtin libraries and the runtime environment. The latter is Java standard edition plus a collection of standards, specifications and their implementations for the needs of the business environment. JTA, JPA, JNDI, application servers, Servlet API, Portlet API, DI, EJB, Websockets, etc.... * Lot of frameworks and tools to help you: you don't have to reinvent the wheel. There are tons and tons of libraries, frameworks and apis and implementations which take away the burden of implementing common stuff yourself (eg transaction management, database connection, object relational mapping etc). You can focus on your task or on the business logic. * Build tools to help you with your project management and additional dependencies: Maven, Gradle. * Really cool ide support: Eclipse, Intellij IDEA are my picks. So easy to refactor things with these. * Lots of job oppurtunities with Java EE knowledge. Lots of banks and businesses use Java. * There are other languages that can run on the JVM and can incorporate Java in it's code base. For example Kotlin, Scala, etc.
The tooling, great argument there! Wow, I didn't know any of that about the JVM, what a piece! You have almost a converse here. I generally use LLVM and the optimizations are good. Python is absolutely garbage in performance, but in general you use C libraries and only script in Python, or if you need to prototype an algorithm and run it fast, there is Numba, that is a kind of a JIT compiler. I use Python mainly because it's what's used in data science. &amp;#x200B; Thank you so much for such detailed answer!
Failsafe can wrap any executable logic (Runnable, Supplier) you have, it just uses Connections as an example. It's not meant to replace exception handling, but rather to provide an easy way of performing retries, circuit breaking, or other resilience patterns.
You are right, although I'm not a programmer myself, I'm a mathematician and work in applied math. But I have a certain attraction for the beautiful concepts and ideas in computing science, specially language design. I think I "code" quite well, but I can't architect a super complex project. But I will try to improve, I have some challenging side projects that might help with that.
Sorry with the quotes I meant languages without a mature, cohesive ecosystem. While I like Lisp and C a great deal, its very difficult to find any ecosystem like I am used to with Java. Building my own collections for C is fun and all but hardly ever the actual problem I'm trying to solve.
We are.
Thank you very much for your answer!
Wow, thank you so much for such a comprehensive summary of features! I really appreciate it!
Mentioned elsewhere but worth repeating -- consider it an entry to the JVM ecosystem. Loads of interesting stuff to discover there. Java is not the only language to play with there anymore: Clojure, Ceylon, Scala, Kotlin are all reasonable alternatives. 
You'll need to look for the term 'reverse-proxy'. You'll set it up in front of your services to: * accept all traffic from those URLs * Inspect the incoming URL and headers * Forward to either the IIS (running on port 80) or Spring Boot (run it on port 8888 or something), based on the host-headers or URL name. IIS appears to support something called [URL Rewriting with Application Request Routing](https://docs.microsoft.com/en-us/iis/extensions/url-rewrite-module/reverse-proxy-with-url-rewrite-v2-and-application-request-routing). IIS also supports URL Rewriting by itself, but that will end up re-writing the URL to show the Spring Boot app port (eg, 8888). Spring also supports a routing service called [Spring Cloud Gateway](https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.0.1.RELEASE/single/spring-cloud-gateway.html#_header_route_predicate_factory) which performs Http-host header inspection for routing, but in this case, you'll need a second spring boot app and map all the port 80 traffic to it first.
Yes, many people has repeated a lot about the community, and you guys have been really cool answering my question that could have easily been confused as trolling. Thanks again!
No it's not great. Looking at the comments (as former Java dev) I weep in pain. It's bad: It's verbose. There are a lot of projects but mostly old ones. You'll drown in old shitty code. GUI is bad. Java doesn't support hidpi. and UI is kinda slow and ugly. New license on oracle JVM and the Oracle itself. You now pay for prod. Eclipse Whats good: Tooling is great. You can refactor stuff in a blink of an eye. Android. Kotlin. If don't you need to handle lot of clients - stick with JS. Otherwise use java or golang
No, for sure that I'm really convinced of what a marvel the JVM is, and the existence of so many different types of languages that compile to it, is definitely a proof of how good it is. And you all have been pretty convincing respect to learning Java, and maybe if it is too verbose, it doesn't really matter because of the great tooling and IDEs available.
The most important differences between them that I see are: * APIs: The style of the APIs are different. Failsafe has a fairly concise API oriented towards simple 1 line executions. APIs are subjective though, so you should draw your own conclusions. * Failsafe has no dependencies, r4j depends on Vavr Some things I notice Failsafe has not in r4j: * Failsafe support [async execution of any type of logic](http://jodah.net/failsafe/javadoc/net/jodah/failsafe/FailsafeExecutor.html), r4j appears to only support async for CompletionStages. * Failsafe supports [asynchronous API integration](https://github.com/jhalterman/failsafe#asynchronous-api-integration) * Failsafe has an [SPI](https://github.com/jhalterman/failsafe#policy-spi) for implementing additional policies * Failsafe has strongly typed APIs that unify policy configuration and execution Some things I notice r4j has not in Failsafe: * r4j supports a few resilience patterns that Failsafe currently does not (rate limiter, bulkhead) * r4j has registries for storing "policies" for you, by name * r4j has add-on modules for various other libraries
Thank you for answering! Nobody really mentioned properties of the language itself, and one comment even confessed it was verbose, but most of the answers were related to the JVM, the ecosystem and community, and the great tooling. What you are saying about the GUIs is good to know. But I'm particularly interested about the licensing, could you elaborate a bit more on that or provide me a link? I think I remember hearing something about a license complain between Oracle and Google.
I cannot see it happening.
This is part of the [project Valhalla](https://openjdk.java.net/projects/valhalla/), specifically [Generic specialization is JEP 218](https://openjdk.java.net/jeps/218). There are other things to project Valhalla, like [Value types](https://openjdk.java.net/jeps/169). Currently none of this work is done. As you can see in the related JEPs, there is currently no schedule. When it's done, it's done. That said, there are vast amounts of work being done on this. See the Valhalla email discussion archives. E.g. there were 3 (2?) working prototypes being built already, each improving on the previous and exploring and solving some important design decisions. I believe they're currently implelenting [a 4th prototype](https://mail.openjdk.java.net/pipermail/valhalla-spec-experts/2019-January/000791.html) (3rd?). For more information either dig into the emal discussions, or see some recent talk by Brian Goetz, the Java Language Architect. Here's one, 8 months old: https://www.youtube.com/watch?v=A-mxj2vhVAA&amp;t=2112s.
Go with your syllabus and simultaneously work on your Java. Don't try to do too much at the same time. The wider you spread yourself, the less effective you will be. Focus on a few things (Java and Python are already more than enough). Become proficient and then move on. You need a solid *foundation* to build upon. This foundation is mostly language independent.
It is. As stated above, see [JEP 218](http://openjdk.java.net/jeps/218).
Here's another, 2 months old: https://youtu.be/4r2Wg-TY7gU?t=2394. Same level of detail, contains some nice perf numbers, too. Turns out they already built 6 prototypes and are building the 7th.
Thanks for the awesome work. Have been using this in prod for some time and love it's simplicity.
Lol printlines. Well if it works it works. 
We, too. 
In practice it hasn't been a problem.
Take a look at the IIS ARR. 
If you like Python because of science, C because of low level, Lisp because of macros and Haskell because of functional programming, do love Java because of object oriented programming.
Thanks!
Thanks!
ARR should be the solution 
r/learnjava
Good answer, but as I learn FP before really understanding OOP, they quite of criticized it a lot. However I'll learn it anyway. (In Python I almost never write classes anyway because my use case is just for scripting and prototyping).
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
The former is more an explanation of how the JVM optimises your Java code, while the latter is a bit more of a book of best practises for writing efficient Java. The two overlap but have different approaches and reading both will be complementary.
yes. this depends on HTTP 1.1 Host header. This is what allows one to host multiple domains at the same IP. Someone has to be able to parse that and direct to the appropriate location. A reverse proxy like others have mentioned, or maybe IIS knows that or whatever, but someone has to do that before it even reaches the Spring app.
If your already using spring boot check out Zuul or spring cloud gateway
You're a good bot err human. (I'm way to lazy to implement a bot just for this stupid cause)
I feel if you rewrite a program from scratch you don't get to blame the resulting "clusterfuck" on the previous language it was written in. I wonder if the other Kubernetes developers share this belief.
Great job! For the Retry policy, previously I simply using Guice interceptor to implement, those method annoated with @Repeat with parameters like maxAttempts, sleepTime, expectedExceptions and etc, and found it's also simple and useful to me. However, for projects don't rely on Guice or Spring or any AOP library, Failsafe looks a great choice and would play around with it in my personal projects!
```java for (int i = 0; i &lt; 3; i++) { try { doStuffPossiblyFail(); break; } catch (PainfulException e) { logException(); if (i == 2) { throw e; } sleepForAWehile(); } } ``` How many times you get to write boring codes like above? It just sucks and can be extracted to a more reusable pattern, including the repeat times, sleep duration and behavior like that. I've found this pretty boring so I always use AOP interceptor to handle this, but `failsafe` provide the possibility that you can achieve this in a non-guice/non-spring context environment, which IMHO is very important, sometimes you just don't want the bunches of Spring stuff to your little toy projects.
Oh wow, ok, I stand corrected
&gt; as long as developers didn't overdo "best practices" and "design patterns", which is a bit too common in the Java community amen
It's nice, too bad it doesn't seem to play well with Kotlin. You'd have to add some verbosity and I couldn't quickly update my code to 2.0 because I couldn't figure out where to put the types (which could not be inferred, esp. get()).
I would suggest starting with Spring and focus on projects first. In the future you will possibly need to learn and understand Servlet, as it's still the foundation of Spring Web stuff. However, as for JSP, I think you can just ignore it. It's just outdated and only legacy projects will stick to them still. Meanwhile, Servlet is still important, I still remember the first time I found the DispatchServlet of Spring(older versions) and got to know that it's actually useful to understand its mechanism.
So here is the thing: The Java language and the JVM is a specification. Vendors implement this specification and offer their implementation online. The most common provider is Oracle. There are others: Eclipse, IBM, etc.. If you wanted Java, you went to Oracle's website in most cases. There were changes recently in the Java community. I'm not exactly up to date what is the outcome exactly and to be honest I got a little confused during 2018. Oracle provided their implementation for free. Now they decided to change the licensing and to require subscription for certain versions of the JVM. Currently Java 11 is out. 12 is coming in march. And they still provide support for 8. Here is a link from 2018: https://medium.com/@javachampions/java-is-still-free-c02aef8c9e04 I hope someone can chime in. The oracle and google lawcase is detailed here: https://en.m.wikipedia.org/wiki/Oracle_America,_Inc._v._Google,_Inc. 
If you need fast and memory efficient primitive collections that work now, look at trove4j.
I agree. Please file an issue with some specifics about what you need and what isn't working and I'll have a look. I'm happy to tweak things if type inference isn't working as expected.
&gt; rate limiter, bulkhead Any plans to implement this in failsafe, especially the rate-limiting pattern? 
Yep, probably both of these, for 2.1. The [Policy SPI](https://github.com/jhalterman/failsafe#policy-spi) also allows you to implement your own policies and plug them in, if you'd like.
Thank you very much for your answer. It's so shady, I can't believe it, but it's mostly free now, isn't it? The language and the JVM I mean. But I was disgusted by reading the Oracle vs Google case.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
the jvm is a beast.. backward compatiblity until now a GUI that works the same on all 3 platforms out of the box tooling is second to none libraries. there are many out there checked exceptions.. many people hate them because they have their uses concurrent programming model. very well thought out model. 
so you wanted to show us you know how to type random code in some rarely used IDE and can put awful background music on? 
Or eclipse-collections! They have a nicer api.
How well do eclipse-collections compare in terms of performance and memory use? One benefit of using primitives is that primitives don't have 40 bytes per-object overhead+associated GC overhead. And trove4j primitive collection classes are really efficient and make use of that.
Pretty similar, primitive collection libraries aren't that different.
It looks like in your [submission](https://www.reddit.com/r/java/comments/aj4ono/wanted_coders_for_opensource_gnutella_servent_in/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt; Don't do that if you plan to let java folks use your library. Otherwise they won't be able to catch checked exceptions (aside from Exception itself, which is an anti pattern in java) This is a sound suggestion! In concrete example, these were test functions, so it was absolutely right thing to do to ditch these "@Throws" annotations.
I think Java excels in that it allows you to build high quality product with the least amount of time. Try building a multiplayer server by yourself in any of the languages you have listed and you will sooner or later see where they start to fall short. Language is just a tool, and java as a tool is fairly flexible - you can do a lot with it from a hello world application to a web application that is sitting on multiple servers. Being a tool is not enough though, in my experience, if you want to build an application. You don't need the tool, but the high end ingredient as well - libraries, documentation, examples and this is where Java shines. Because of the popularity, industry use - there are a lot of high quality libraries/components/examples for you to use in building your application - things like networking, web, xml, database. Think of Java as Skyrim with mods. By itself it is all right, but the availability and quality of mods make the software development experience awesome. 
JVM languages are different than C. With a JVM language, such as Java, Kotlin, Scala, etc, you compile into JVM bytecode. All the other things I mention, like the C1, C2 compilers happen AT RUNTIME in order to run your platform neutral JVM bytecode. Just to be fair so you can consider all angles, here are two big disadvantages of Java and/or JVM languages. 1. Warmup time. You start up your program, the JVM must launch. Your program starts running. Every function starts out as *interpreted* JVM bytecode until the C1 / C2 compilers hit your code. So a big Java program feels like it takes a couple minutes to "warm up" before it is running really fast. This also means you probably don't want to run a "hello world" in Java. How many times per second can you launch a Hello World program written in C vs one written in Java. Java programs probably don't launch many times per second. 2. Runtime size. The JVM runtime adds significant size to your program if you will be distributing it with your program. Both of those points don't matter for a program that runs as an internet service, like a web application server. And again, the JVM is an industrial strength managed runtime with GC and two stage JIT compilation. &amp;#x200B;
Just learn it for at least one year, and you will be either convinced or not. If not, keep learning for another one year, and you will either be convinced or not. If not, I think there might be no reason to force yourself to learn something you really don't love, since life is so short.
:) It's a pure joy that one do something he or she thinks is really interesting or challenging, and it's OK for him or her to share that joy to others. Meanwhile: I don't use NetBeans most of the time but it's a good IDE and still has a steady group stick to it.
Thanks for expanding!
That’s pretty cool, are you the creator?
Good question. I uninstalled Java on my home PC, last night. Nothing I have installed needs it, and I'll see if there are any sites I visit that use it.
No, I just found it useful.
&gt;tooling is second to none How is this?
Thanks for sharing the . =)
Thank you for the answer! Yes, that's what happens to me with Python for data science.
So deep, man, this not only apply for Java, but all things in life.
you could still do that with etl, just have different polling rates for different sources and the let elasticsearch index you data store. i've built several analytics systems (several years ago) that did something similar. the polling rates for each service were varied base on how frequently data was updated. now-a-days, it's all event stores. 
This report is much more readable than https://github.com/AdoptOpenJDK/jdk-api-diff
Well, in the description it does say: &gt; a fair amount of factory patterns and singletons yup, that's a clusterfuck allright. from inexperienced programmers. great idea, very poorly executed.
JSON makes perfect sense for anything that touches JavaScript since it also doesn't have an integer type so you have to deal with this anyway.
part of this is ecosystem. but beyond that, one of the design goals of the lang is that it should be easily parsed and incrementally compileable. combined with the strong typing, it means most tools are able to give code understanding almost everywhere, even for classes that don't compile want to fix bug in a method but afraid that somebody might be depending on the bug ? alt-f7 will find all usages, in all open projects and dependencies with near-perfect accuracy (the exception is reflection, though if that's been done with best practices, those can be found too) 
I agree with you but are there that many people with the skillset to do devops but not recompile a code base?
Ok, thanks!
Thank you :) I am quite happy with what I'm able to do and I like to share what makes me happy :) 
It is indeed a common thing to hear from functional programmers that OO is somehow bad in my opinion this is not true. Languages like java and c# are slowly integrating features from fp languages into them and the result is quite good in my opinion. Fp is good at certain things and oo is also good at different things. Having access to both is actually really nice. This blog post from uncle bob also explains this. https://blog.cleancoder.com/uncle-bob/2018/04/13/FPvsOO.html
gotcha, that makes sense!
That's fine if your gowl is to release a game, but if it's to learn it's not a particularly interesting approach in my opinion.
I disagree small games can be a lot of fun to program and seeing things change visually when you are making something can be quite satisfying especially to a beginner.
Kotlin still has nullable types (without runtime allocation), and inline functions, which makes logging more performant (no need to push several args on the stack before calling), and also extension methods. Is Java expected to get any of those?
That Foss point is valid. I don't see a problem with it. What's your point? Why would I waste time on it? Jetbrains does operate a scam by charging money for features that everyone else provides for free. Companies do make money off eclipse, by providing add-ons to the ide that don't exist anywhere else. That is fine. Jetbrains....Lol. They do have kotlin , their own language.thats all. The java enterprise it's there in eclipse.
Yeah dude, just keep what you are doing and happy coding! Cheers.
I use whatever fits the lighting around me. Early in the morning or at night I use dark; during daylight times or in a well-lit office I use light themes. I usually switch themes twice a day, once late morning, once in the evening.
&gt; Moreover, no credit card is required to benefits of the quotas above. Is that actually true anymore? I recently had to even set up my credit card to continue using Google APIs in the free quota.
Mmmm... I setup my account a long time ago, I didn't verified if that policy changed. For sure, they are asking for a credit card if you are willing to use Google Cloud virtual instances since there's no free tier. Google App Engine has a free tier though. 
JS has to represent integers as decimals, but that doesn't mean it makes sense for a data represenation format to do the same, even if it touches JS.
I agree with you that many Mac users are not technical users. I also agree that we shouldn't assume most Mac users are comfortable with terminal and homebrew. You equated females with non technical users. I stopped categorizing people by gender over 40 years ago.
Good luck! :)
Why are u so frustrated?
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
This is not the place for tutorials. There is a dedicated subreddit for that.
Thanks mate! :) 
Sorry about that. Which subreddit is that?
/r/programming_tutorials/
Thanks!
I just started to learn Java EE for a brand new application actually.
&gt;You don't have such power with traditional imperative style. &gt; If you call, say, System.out.println in your code, it will print the line to console right away, without giving you a chance to somehow intervene. All you are doing is piling references to the method inside one another and then running all those references. There isn't any functional powered pixie magic going on here. 
Isn't that what functional programming is? 
Sure, we are inside the JVM and are limited by the platform we run in. And yes, all dirty, unsafe, effectful methods that perform actual IO will be called at some point, there is no magic here. The idea here is to suspend execution of effectful code til you explicitly run it (ideally, once per program), and to provide a way of composing these effectful calls in a functional way.
are we talking a huge difference in memory, or is it little and only relevant for high volume operations?
Is it not similar to reactive streams (RxJava or Project Reactor)?
Pretty cool. For comparisons across multiple versions (e.g. Java 8 -&gt; Java 12), it would be nice to see which version introduced the change on the summary page itself, but otherwise very informative.
There is no point, you are already biased against it.
You can still use Java for free in production. Java is open-source so you have many options. All versions of Java are based on OpenJDK and starting with Java 11 Oracle is simply charging for for their version of Java that is built from the OpenJDK. Other vendors are also supplying versions of Java and some of them also offer support services for a fee. It is true you would have to pay to use Oracle's VM in production, but simply use the one from https://adoptopenjdk.net or the one from Azul (https://www.azul.com/downloads/zulu/) or the one from Red Hat, etc. They are all built from the same OpenJDK code-base and are certified by passing a suite of tests.
* verbose -- verbosity makes it highly readable hence highly maintainable, have no idea why this is always brought up as a minus * only old projects -- umm, you must be smoking crack, not even remotely true * old shitty code -- you can indeed find old shitty code, but that is true for any language/platform * GUI is bad -- I guess you are referring to Swing. Swing is a perfectly good GUI toolkit * UI is kinda slow and ugly -- swing is not slow at all, ugliness is pretty subjective. I think Swing looks better than all these horrid Electron apps. * you pay for prod -- for Oracle's VM yes, but there are plenty of free VMs available (https://adoptopenjdk.net, https://www.azul.com/downloads/zulu/, etc) Just mindless FUD against Java. 
Ohh, you have open source versions of the libraries and the JVM, great to know! Thanks for your comment!
I'm interested in playing with this more, and I'm curious to see where you take this. Thanks for sharing
The safest bet is that it won't happen this year. You can expect parts of it to land this year, but probably not the whole shebang. There is a lot of machinery that is still under active development. They've changed their approach several times since the initial onset. Though, it sounds like the current approach they are working with will be the winner. Expect things to be really dull to begin with. Like "Java 13 class file supports marking classes as value types". I doubt the initial implementations will expose value types in Java itself.
Pretty large differences. Object overhead is fairly high, somewhere around 40+ bytes just for the object luggage. That is for each 4 byte int.
It has been in the works for several years now. I doubt they are going to pack up their bags and leave it.
This is super awesome!
This looks like a job for HTTP2! You are likely slowed down significantly by HTTP1.1's connection management. You can get much higher parallelism at a much lower cost by enabling HTTP2. Fortunately, for the most part that is simply a change on the server to enable it, and a change in client. Switch over to Retrofit + OkHttp and you'll get http2 by default out of the box (Yay!), then make retrofit return CompletableFutures. That's it! You'll get even higher performance benefits than you did without changing the server implementation. If you can change the server implementation, you'll get even higher throughput by aggregating and batching requests into the database. But that takes quite a bit more effort.
Since GitHub introduced unlimited private repositories I guess we are allowed to store private Maven repositories there. We was allowed to store public repos there before.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Hmm, you are right, Jeff is in a way similar to Rx. They both approach the same problem but in different ways. They both aim to provide an abstraction to work with synchronous and asynchronous data in a unified manner. But Jeff's primary goal is a bit different: to provide a way to write side-effectful programs in a purely functional way. The main Jeff's abstraction is `IO` monad. `IO` is a way to describe a computation that can perform a side-effect (any input/output operation, global state mutation, etc.). `IO&lt;T&gt;` is a container that knows how to compute `T`, and the computation can result in normal value `T`, take forever or fail with an exception. It is a bit similar to Java's `Future`, but such that can suspend evaluation until we run it. When you create an instance of `IO`, nothing really happens. An instance of `IO&lt;T&gt;` is just a description of a program that knows how to produce `T`. You can compose it with another `IO`, you can reuse it as many times as you want, or you can discard it. Ideally your program will be one big `IO` value that you will evaluate in the end. And only when you evaluate it, all side-effects will be performed. But while you construct the program of small `IO` pieces you have a power of working with `IO` instances as with pure values. Jeff also has `Stream` implementation which is probably a bit similar to Rx `Observable`, because it is also a potentially infinite structure that can produce values, but it is a much simpler concept. `Observable` is push-based (it produces values by itself, and can produce them even if nobody listens). `Stream` is pull-based, which means that it does not produce values by itself, but its consumers read them as they would read from a regular list or from java.util.Stream. Internally, `Stream` is just a chain of `IO` values that are evaluated when they are accessed. For now there's almost no description of the `Stream` class in the README on github page, but you can look at the javadocs in the [code](https://github.com/lpld/jeff/blob/master/src/main/java/com/github/lpld/jeff/Stream.java) and at [the tests](https://github.com/lpld/jeff/blob/master/src/test/java/com/github/lpld/jeff/StreamTest.java) if you are interested.
Love me some failsafe. It's been cranking away on over a hundred production servers for the past six months, and doing exactly what it's supposed to do.
Would love to hear about [where you're using it here](https://github.com/jhalterman/failsafe/wiki/Who's-Using-Failsafe).
Would love to hear about [where you're using it here](https://github.com/jhalterman/failsafe/wiki/Who's-Using-Failsafe).
Wow, that's *very* useful. Thanks for sharing!
&gt; If you use security or ad-blocking plugins, you may see error messages &gt; Our third-party software provider, Qualtrics, does not work well with certain ad blockers and security software. lol
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Hi, Around ~ 2-10 million elements it starts to matter, both in terms of performance and memory used and GC overhead. Smallest Object you can have is ~40 bytes. While int is 4 bytes. So dealing with primitives is around an order of magnitude more efficient. And primitives don't carry GC overhead. Around 80-100 million elements, standard Java collections and GC start collapsing under their own weight. If you deal with volumes above that, you need to start packing things into arrays or memory mapped files etc. --Coder 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Since this is help with programming, it is *off-topic* here. Maybe try /r/springsource.
Thank you for your reply :) So I think I an uninstall my java..
In object-oriented approach I can have the same object in code as the analyst has in his analysis and as the domain expert has in his head. No other paradigm can offer something like this. When the object-oriented analysis is in place, the object-oriented programming is natural way. And the object-oriented analysis can be used for most domains. So, the advantage is binding between domain, analyses and programming. And this is crucial. The rest is bells and whistles.
Premature optimization and all that. If you haven't had problems, chances are you don't need to worry about it.
Thanks!
It's probably worth mentioning fs2, which is the Scala equivalent of Jeffs Stream. 
It can't hurt, and you can always reinstall it if necessary.
Title and author bio are 2 edgy 4 me.
[It looks like this is being worked on.](https://github.com/GoogleContainerTools/distroless/pull/285#issuecomment-457372575)
That's not a scam as there is no deception occurring.
Thanks dude! I got to learn quite a bit about light from that :)
It isn't the rebuild, it is the editing of the code to change the annotations.
If you guys have other suggestions for what I should do to prepare, I'm open to suggestions. It's hard for me to focus on non-graphical introductory tutorial stuff because there isn't much feedback. Graphics allow me to quickly test things and see whether or not they work, which allows me to skim over 90% of the content of a tutorials and speeds up the learning process tremendously. So that's why I'd rather do a deep dive into Java's OpenGL to review both at the same time, instead of reading basic Java tutorials and then spending some separate time reviewing OpenGL.
I agree that they shouldn't I just think it's not because they can't though.
Give us a real world project setup example complete with junit 5 unit an integration tests, code coverage and annotation processing. I personally got stuck when trying to use junit tags to differentiate between test suites and running them separately, how to not run tests on build and reusing version variables. And with stuck I mean 6 months of daily usage until I randomly stumbled over the correct stackoverflow posts. Also source sets are a complete mystery to me, at least how they're configured
You could always manually add the location of java.exe to the path.
Interesting concept. Thanks!
MY NAME IS GREG AND I ENDORSE THIS ANSWER \^\^\^\^\^ &amp;#x200B; Just checked my paths and found some old JavaPath entries. Removed them and just left the JDK directory in the path, opened a new shell window, now `java -version` returns the same version as `javac -version`. &amp;#x200B;
You must be joking, arent you? 
Worked fine for me.
Charging money for a service instead of expecting your service to be subsidized in other ways is hardly a scam. Your description of what they do, and what they actually do, do not meet any definition of the word scam that I've ever seen. Now, I can understand that you wouldn't want to support them simply because their full product isn't free beer, but that's another issue altogether. 
Effective Java 3rd edition by Joshua Bloch
&gt;are you the IT person or your family SIGH
"Have you tried turning off and on again" Best question ever
What?
Whilst you consider trivial, the variables section is important. The access modifiers, the variable hoisting and compile errors due to variables will be heavily tested in the OCA exam. You might even see a threading question and be fooled to think which thread does what and it fact be a variable question. When I passed OCAJP 7 and OCPJP 7, I used Enthuware mock tests. Not only they have practice tests, but they also simulate the real exam and they explain the correct result after your test is graded. I have 2 blog posts about it, covering the exams, resources, their relevance and which one prepared me best for the actual exam. Hope they will be useful to you: http://silviuburcea.blogspot.com/2014/09/ocpjp-7-experience.html?m=1
It was the next question to "are you the IT person or your family?" in the questionary
Yeah "What?" was one of the answers 😂
Lol, i didn’t remember 😂 Yes was my direct answer
I think you are confused. The article is about the maven artifact repository (like nexus), not about the github java repo with maven build.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
This is always the answer. 
Correct answer is correct.
[removed]
* Effective Java 3rd * Concurrency in practice 
*insert_pickachu_meme*
From your experience, I would suggest you to write a certain quantity of Java code first, then or at the same time read Effective Java, IMHO I don't think at current stage a book is fit for you, even it's super good.
Effective Java and Modern Java in Action. 
I came here to post this. There's a lot of OK Java books out there, but this is one which I think will make anyone a better programmer if they read it and already know the basics. I've been working as a Java developer for sixteen years, and still regularly dip back in to this book for inspiration.
[Core Java for the Impatient](https://www.oreilly.com/library/view/core-java-for/9780133791563/) should fit the bill if it's as good as the one I read, which was "Java 8 for the Impatient" by the same author. I used Java 7 a lot and used it to get up to speed with the Java 8 features. It was super concise, fast and still thorough, which was exactly what I needed.
In my projects I usually only hold a few thousand objects in memory, for more than that I either stream onto/of a file or in database. This is either very little data, aka UI with a page showing 20 objects, or it is not time critical and done in batches. Memory footprint is therefore minimal. However this is something to keep in mind, for future reference.
Kathy Sierra. OCA/OCP java se 8 I'm like you, and this book give me my certifications... If you want some pure java
I've been programming in Java for as long as I can remember and I got _Core Java, Volume II--Advanced Features, Eleventh Edition_ (https://www.safaribooksonline.com/library/view/core-java-volume/9780135167175/) on my reading list.
Thanks for this extensive response. It is very interesting. I will think about all this because I have similar concerns in a side project: https://github.com/lbovet/streap
Nice, but it didn't include Java EE for what platforms you used :O
That’s not a trivial project although I just skimmed the reqs. How much time do you give your students to work on this project? From the beginning of the semester/quarter till midterms? Like 5-7 weeks? Interesting though. I’ve been doing programming for a long time but never in Java professionally. I’m intrigued to start it myself. Thank you for the inspiration. 
Good list so far. I would add: Elegant Objects, Design Patterns, Refactoring to Patterns, and Working Effectively with Legacy Code. 
Because if you have jOOQ generate code and Lombok tampering with code you end up with a convoluted mess
I tried your recommendations and that's what I got: as for gzip in http client - it didn't give me any tangible benefit, as for ExecutorService as additional parameter for supplyAsync - it gave me a little bit faster execution time (about on 5 minutes faster).
I haven't been working on the project for couple months now, but I think of coming back :) My plans for the nearest future are: * Write more tests for the basic functionality * More documentation * Create a sample project to show how the library can be used After that... we'll see. Thanks for your interest.
Right, I think I have to even mention it on the github page, because I was looking at fs2 when implementing Stream. I will do when I add documentation for Stream to README. BTW, have you looked at Monix library in Scala? I haven't played with it yet, but I was looking at its source code a bit. Monix has a concept called [Iterant](https://github.com/monix/monix/blob/master/monix-tail/shared/src/main/scala/monix/tail/Iterant.scala), and Jeff Stream looks very much like it.
This is the only answer you need.
Thanks for sharing. I will take a look :)
You can experiment with the number of threads a bit but ultimately you are bound by how much the API can process. They also might not like you hitting it at very high throughputs. If it seems like it could handle more you could spin up even more threads. gzip is enabled by default for a lot of http clients now so that could make sense. Which http client library are you using? Sometimes they have a parameter for a max number of concurrent connections per host. This means even if you have 50 threads it could be limiting the number of http connections.
I'm using Appache HTTP client. As for number of threads - I tried 5, 10, 20 and 50 and it didn't affect the result strongly enought.
You might be surprised. I've worked at a couple of places that had devops or the earlier equivalents of devops, those folks were not developers. They were support or system admins that were responsible for deployments and platform monitoring. Most knew how to put together shell scripts to automate some of their tasks, but ask them to work on Java code and they had no experience at all.
Thanks for the suggestions! 
I would recommend some more books. "well grounded java developer" it doesn't cover exactly java but covers many important topics in Java development like dependency injection, concurrency, polyglot programming and TDD. 
Isn't Functional better than OO? I'm always conflicted with whether I should continue investing time into learning/improving my OO Java skills when at work we use strictly functional and functional Java seems like the goto now? 
Imagine all the possibilities with linux cgroups (do they work with threads nowadays?) combined with isolates (ok you got me, I've only os level file access security on mind..). Or creating super feature-rich (totally don't mean bloated) java app which doesn't require GBs of heap. Or on the heap caches with different GCs so for example RAM eating report generator doesn't halt GC of your main app. Or..actually I can't think of any other use case..
Imagine all the possibilities with linux cgroups (do they work with threads nowadays?) combined with isolates (ok you got me, I've only os level file access security on mind..). Or creating super feature-rich (totally don't mean bloated) java app which doesn't require GBs of heap. Or..actually I can't think of any other use case..
Effective Java.
I learned Java at my university and we used "Big Java late object". It's a really good book and as far as I am concerned it goes in depth. However it is not a proper tutorial book. It will explain the concepts, show how to program them, and give you a few exercices. 
You can write good programs or bad programs in functional or object oriented ways. Leaning to identify ways to organize your programs so that you can deliver value and improve them over time is important... Maybe reading the classic Refactoring book would be good just to become familiar with refactoring patterns etc. In life you will usually work on inherited code much not often than you work on green field projects. 
Y'all know eclipse got replaced right
&gt;Hi to C++ developers who read about the Java analyzer:-) Hi
By what?
Intellij
Is IntelliJ now managing all the Java EE code and specs contributed by Oracle???
Do you know what GlassFish is mate
No idea. Isn't Java EE dead?. All I know it's just like eclipses. But actually works, is responsive, and doesn't look like dog vomit 
Sry I don't use bloated corporate frameworks
And we're back to the usual rubbish. + It is not called Code**A**cademy FFS. It is Code**C**ademy. It is not an accredited educational institution and thus is not allowed to call themselves **A**cademy. A seasoned blogger should know that. Further, CodeCademy is the vocabulary app of programming. It mainly teaches programming language *syntax*, not programming. Useless as a beginner resource + CodingBat is just as useless as a beginner source since the site only provides challenges, but no tutorials + CodeAbbey is just the same as CodingBat. A challenge site, not a tutorial + *The best* Java tutorial is actually missing, the MOOC [Object Oriented Programming with Java](http://mooc.fi/english.html) from the University of Helsinki. Together with the mentioned (the only sensible advice in the whole post) *Java for Complete Beginners* it is the most commonly recommended **learning resource**. + [Derek Banas' Youtube Channel](https://www.youtube.com/user/derekbanas/playlists) is another great **learning resource** for multiple languages. Summarizing: You list exactly *two* **learning** resources along with 3 practice resources. Your posts get worse and worse.
I'm not sure what you're on about. I created lots of Java EE applications, and they were pretty responsive thank you very much. The way they look, I assume you mean the visual look of the application you created with it, it has nothing to do with Java EE itself, but everything with your CSS etc skills. &gt;No idea Then why make the remark??? I just checked, and all transferred Java EE repos are still here: https://github.com/eclipse-ee4j I don't see any of these repos at places like this: https://github.com/JetBrains/intellij-community So, it doesn't seem that IntelliJ/JetBrains has taken over all the repos and projects of Eclipse at all.
Before picking up a hammer or a screwdriver, you should figure out whether your have nails or screws. Certain domains lend themselves more to an OO approach than a functional apprach, and vice-versa.
Naa it hasn't taken over the repos of eclipse. Just like when the car took over it didn't take over the horse stable. People just stopped riding horses.
So what did IntelliJ according to you then introduce to replace Java EE with?
Wow, are you attending the Troll Academy at this moment, and is making that comment part of an exercise?
&gt; lazy monadic types in streams WTF is a lazy monadic type? 
Students are required to finish the project in 3 weeks, and they are encouraged to do it in team mode, like 2-3 students a group. Some of them have programming experience and would choose to do it themselves. The first time I introduce this project to them, most of them got a little bit depressed, however, the skills need for this project and some implementation ideas will be somewhat explained during these 3 weeks, so that their life will be relatively easier.
NO programming help - this should go in /r/javahelp. **Removed**
Nobody believes you. We all know you saw “eclipse” in the title and thought you could grab some free karma by saying “DAE IntelliJ?!!”. Unfortunately you’re poorly informed and didn’t realize that the Eclipse Foundation manages a lot more than the Eclipse IDE. It’s ok. We all make mistakes. But good programmers (and good people in general) admit their mistakes instead of doubling down. 
Have fun with your struts/JSP app dev
Right, we're working on that at [https://github.com/GoogleContainerTools/distroless/](https://github.com/GoogleContainerTools/distroless/pulls) And for now, jib-core lets you chose the base image of your liking.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Struts &amp; JSP might not be my favorite frameworks, but I’m pretty sure they’re not as bad as you think they are. My reasoning is this: You’ve been wrong about everything you’ve posted so far. In my experience, the team and the product have a lot more to do with making work enjoyable than the frameworks we use. I’ve been at this for a while now and I feel pretty confident in my ability to write quality code in any framework. You’ll get there someday. 
Naa. they were pretty good back in 2007
Great to hear, that this is already in action, because I think using distroless is a very good approach to have a cleaner base image. Yes, but the MaxRAMPercentage is missing in JDK 8 as far as I know and this one is very useful in my opinion. 
Sorry dude, but this would probably be the most boring link I've ever met in r/java :) Thanks for the sharing\~
Thank you, Captain Obvious. Did you know **all** software has bugs in it?
"The comments are added to the beginning of the files with the extensions .c, .cc, .cpp, .cp, .cxx, .c++, .cs" When I check "how-to-use-pvs-studio-free" as I want to play around with this tool, just want to make sure, extension .java not included there, is it a documentation issue or actually not supported?
Try changing this http://hc.apache.org/httpcomponents-client-ga/httpclient/apidocs/org/apache/http/impl/conn/PoolingHttpClientConnectionManager.html#setMaxPerRoute(org.apache.http.conn.routing.HttpRoute,%20int)
They probably haven't updated that page.
please stop posting in medium and linking from it.
Why? It seems like a fine platform for posting long-form text content like this
[Medium is a poor choice for blogging](https://medium.com/@nikitonsky/medium-is-a-poor-choice-for-blogging-bb0048d19133) sums up my gripes nicely.
Maybe we should just start /r/mediumreplacement and have bloggers make text posts there, which can then be shared just as easily as Medium posts. 
What's wrong with the factory pattern? I don't think I've ever heard it derided before.
I don't care so much about using it for configuration, I don't like it much for communication. I generally use Json for data exchange. It is highly supported and really easy to work with (particularly if you are talking to a javascript app). I've not ran into a case where the XML schema would save me anything. Most of those are autogenerated, so if you are going to break things, you'll break them. Further, writing a client is fairly trivial especially with example data. So all the autogeneration power is somewhat wasted. But even if I did subscribe to that sort of thinking, I would probably not adopt XML. Why use it when much more powerful app data interchange formats exist, particularly Protobuf/Flatbuffer/Capt'n'Proto. Each of these are support a schema and can autogenerate parsers in various languages. They are also WAY faster. XML works great for doing text markup. It does not do great for app-&gt;app communication. That being said, if I had an app with a working XML communication, I probably wouldn't change it over to Json. That just isn't worth the effort (low gain, high work). And hey, at least it isn't Java Serialization.
It looks like in your [submission](https://www.reddit.com/r/java/comments/ajvlwn/keep_reference_to_object_when_adding_to_hashmap/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
What a shitty way to spam your youtube channel 🙄
Good
lol
I've made a simple test and found that this tool actually don't support Java, I just wasted about 20 minutes on this: &amp;#x200B; I created 3 files, one .c, one .cpp and one .java, via the command line tool, both .c and .cpp pre-append expected comments while .java don't. So it seems that currently don't support or not include. Why I said this is because I tried to add comments manually in IDEA and run this tool, but it keeps saying that I need adding comments in the beginning, got really confused... &amp;#x200B;
All software potentially has bugs. 
You can kind of sort of do these today already with invokedynamic and constantdynamic. invokedynamic can let you do specialisations of code once at runtime and then cache the results. constantdynamic can sort of let you do a similar thing for classes. Or you could already just use a custom ClassLoader that abuses loadClass to generate specialisations dynamically. However, actually building an implementation on these raw primitives requires a lot of thought and may be suboptimal than adding further changes to the JVM. It was already technically possible to generate classes on the fly with a custom ClassLoader in the past. However, in the past there were significant limitations with garbage collecting classes (there still are some today.) In addition defining a new class was heavy weight (and still is heavy weight to some extent today.) There are also some possible future options such as Classdynamic which may make such work easier and it would be bad to be locked into a suboptimal solution. Consider also how the code/class generators might work. It would probably be bloated to have each template function in each classfile directly manipulate MethodHandles methods to generate the code at runtime. So something like a custom bitcode would have to be defined that can be passed to a library like LambdaMetafactory. As well, one would have to limit generics in some ways in order to be viable and not a mess like C++ templates. Should it also be possible to have true variable argument functions? Should it also be possible to be generic over numbers or other data other than types? How well subtyping variancy work if a new class is generated for each instance? Not to mention that a new reflection API for generics and a story for compatibility with older applications would have to be thought out. If you made a new language from scratch today that compiled to the JVM it would be easily possible to have true generics for primitives even if you had to create a custom file format and loader for it as long as you gave up certain features. However, Java is limited today by: - Backwards Compatibility - Well grounded fears of locking into a suboptimal solution. - Tricky implementation choices over top of the raw JVM details. I mentioned you can do these today already and I can show some code I already have that does some stuff like that https://gist.github.com/sstewartgallus/2e30bd27c9a3eae58b94f5e1c98db6ce It actually only took around a week or two for me to write a ByteBuddy plugin that rewrote annotated method calls into invokedynamic calls that dipatched to a bootstrapper that generated custom methods at runtime specialised to sizes and types so I could squeeze a little more speed out. Probably a simpler example is the bootstrap method I made that returns a custom array element creation function for varying sizes. // This method is looked up and called dynamically @SuppressWarnings("unused") public static CallSite bootstrap(MethodHandles.Lookup lookup, String name, MethodType type, Object... args) { // TODO: Figure out way to fit into protocol if (name.equals("newarray")) { // TODO: Cache these? return new ConstantCallSite( MethodHandles.identity(type.returnType()) .asCollector(type.returnType(), type.parameterList().size())); } return DYNALINKER.link( new SimpleRelinkableCallSite( new CallSiteDescriptor(lookup, parseOperation(name, args), type))); } As you may know every time you do: new int[]{ 1, 2, 3, 4, 5, 6, 7 } The JVM has to manually store every single value which generates large amounts of bytecode. Some language implementations have taken to utility classes of methods just for creating such arrays. But using invokedynamic you can reduce all these utility methods to just a tiny, tiny bit of work. The end result being that my own custom toy language I'm hacking on has a variadic array creation operator invoked like ([] 1 2 3 4 5 3) that works for an argument amount of any size (except for I think 253-255 and 124-128 for long/double arrays because of internal JVM limitations.) So the technology is definitely possible and things are getting there but there are very real limitations making it hard to move forward.
After built from source it has been very clear. Current released binary file - not built on the latest code - actually don't support .java extension. If you want to play around with your java code please build it yourself, rather than download the outdated binary exe file. I just spent some time to figure out this...
It could be nice to supply your own executor service 
That's a pretty good first project. I haven't looked into your code too closely, so this might be something you have checked out and decided against, but you might look into using Jackson for JSON deserialization. I don't see any tests though...
This was something that caught my eye too, there's no test folder. So, even if the library has a nice API we can't really be confident that it works.
Fair point. I wasn't sure how to properly implement testing for the code, so I decided to leave it out until I had figured out a decent way of doing it. Do you have any suggestions? 
That does indeed sound like a nice feature. Thanks for the feedback :)
No Job offers. **Removed**
Some things I noticed. 1. Consistency, you're using the @Contract annotation in some places but not others: [https://github.com/Sauilitired/Jenkins4J/blob/master/src/main/java/org/incendo/jenkins/objects/ArtifactDescription.java#L92](https://github.com/Sauilitired/Jenkins4J/blob/master/src/main/java/org/incendo/jenkins/objects/ArtifactDescription.java#L92) . Why's that? 2. Constructors like these might make sense to have as a builder: [https://github.com/Sauilitired/Jenkins4J/blob/master/src/main/java/org/incendo/jenkins/objects/BuildInfo.java#L74](https://github.com/Sauilitired/Jenkins4J/blob/master/src/main/java/org/incendo/jenkins/objects/BuildInfo.java#L74) , consider [https://immutables.github.io/](https://immutables.github.io/), [https://projectlombok.org/](https://projectlombok.org/), [https://github.com/google/auto/tree/master/value](https://github.com/google/auto/tree/master/value) 3. String checks, should they go beyond null? Is it valid to have "" as a display name or job name? 4. Could this be the Path class instead of a wrapper? [https://github.com/Sauilitired/Jenkins4J/blob/fe0de722f5230d0703ff1bddbd3901bdebc3bf26/src/main/java/org/incendo/jenkins/JenkinsPathProvider.java#L35](https://github.com/Sauilitired/Jenkins4J/blob/fe0de722f5230d0703ff1bddbd3901bdebc3bf26/src/main/java/org/incendo/jenkins/JenkinsPathProvider.java#L35) [https://docs.oracle.com/javase/7/docs/api/java/nio/file/Path.html](https://docs.oracle.com/javase/7/docs/api/java/nio/file/Path.html) 5. Some docs don't add much: [https://github.com/Sauilitired/Jenkins4J/blob/fe0de722f5230d0703ff1bddbd3901bdebc3bf26/src/main/java/org/incendo/jenkins/objects/Node.java#L35](https://github.com/Sauilitired/Jenkins4J/blob/fe0de722f5230d0703ff1bddbd3901bdebc3bf26/src/main/java/org/incendo/jenkins/objects/Node.java#L35) . You could group this info and just leave the return. Are there any guarantees to these? Will they throw any exceptions (particularly the bits around completable futures) 6. NodeChild, if you can't re-set the parent: [https://github.com/Sauilitired/Jenkins4J/blob/fe0de722f5230d0703ff1bddbd3901bdebc3bf26/src/main/java/org/incendo/jenkins/objects/NodeChild.java#L50](https://github.com/Sauilitired/Jenkins4J/blob/fe0de722f5230d0703ff1bddbd3901bdebc3bf26/src/main/java/org/incendo/jenkins/objects/NodeChild.java#L50) , would it make more sense to have an abstract class that requires you to pass the parent when constructing instances of NodeChild? 7. Kudos on this: [https://github.com/Sauilitired/Jenkins4J/blob/fe0de722f5230d0703ff1bddbd3901bdebc3bf26/src/main/java/org/incendo/jenkins/exception/JenkinsNodeReadException.java#L32](https://github.com/Sauilitired/Jenkins4J/blob/fe0de722f5230d0703ff1bddbd3901bdebc3bf26/src/main/java/org/incendo/jenkins/exception/JenkinsNodeReadException.java#L32) , really liked that you used the illegal state exception! 8. GSON should be able to do most of the deserialization for you without you having to transform jsonelement, jsonobject [https://github.com/Sauilitired/Jenkins4J/blob/fe0de722f5230d0703ff1bddbd3901bdebc3bf26/src/main/java/org/incendo/jenkins/json/JobInfoDeserializer.java#L58](https://github.com/Sauilitired/Jenkins4J/blob/fe0de722f5230d0703ff1bddbd3901bdebc3bf26/src/main/java/org/incendo/jenkins/json/JobInfoDeserializer.java#L58) , look at the fromJson stuff [https://github.com/google/gson/blob/master/UserGuide.md#TOC-Object-Examples](https://github.com/google/gson/blob/master/UserGuide.md#TOC-Object-Examples) , it looks like you do it in some parts but not others. This one might be another one that can get auto deserialized: [https://github.com/Sauilitired/Jenkins4J/blob/fe0de722f5230d0703ff1bddbd3901bdebc3bf26/src/main/java/org/incendo/jenkins/json/JobDescriptionDeserializer.java#L40](https://github.com/Sauilitired/Jenkins4J/blob/fe0de722f5230d0703ff1bddbd3901bdebc3bf26/src/main/java/org/incendo/jenkins/json/JobDescriptionDeserializer.java#L40) 9. I think the biggest thing I can think of is the lack of tests. When you get to it, this might come in handy: [http://wiremock.org/](http://wiremock.org/)
1. Wrong subreddit 2. **Spam** **Removed** &amp; **Banned**
Well, at least test some best case scenarios and error handling. Add sample JSON files and deserialize them and make sure the mapping works.
Maybe use [http://www.simpleframework.org/](http://www.simpleframework.org/) to start up a small webserver inside the test that mocks the server, and let the tests call that one.
I ended up doing a mix of both. I recorded responses from Jenkins and used them together with a mock web server to compare actual results to expected results. Thanks for the feedback :)
I really appreciate you taking the time to give me feedback on the project :) Anyways: 1. I got lazy. That's about it. I was going to use the annotations but I sort of gave up half way through. I decided to just remove them entirely, instead. 2. Yeah. I usually use Lombok in my projects, but I've gotten far too many complaints in the past to dare use it in a public project again. I think people are scared of annotation processors :( 3. Good point. I'm a bit naive, and just assume that the information Jenkins gives me will be valid. I'll add some more validation. 4. The class was originally meant to do more, and it sort of stuck around. Heh, good catch. 5. The problem is that the parent doesn't have to be there for a node child to be created. I based it off of how Jenkins provide information. For example: A build does not require that a job has been read beforehand, and I wanted to avoid reading the job information unless it is actually going to be used. 6. Very valid point. I decided to use mock-server and some pre-generated responses from my own Jenkins servers to test out the parsing. It probably isn't enough, but it's a hell of a lot more than nothing.
I opened 2 tickets :) 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Dude, awesome. I'm a big Jenkins fan and wanted to build something similar for quite a while now. Bravo! 
Sorry, was away. Any serialisation/deserialisation code has to go through a lot of hoops to work fine in ALL cases, see Jackson or Gson implementations for example. 
You could also try using WireMock in your test classes to just mock the calls.
[James Strachan](https://en.m.wikipedia.org/wiki/James_Strachan_(programmer)) is in there for me. Super helpful guy - thought up and helped implement some great projects, such as Groovy, Camel, ServiceMix, and ActiveMQ. If you get the chance, go to one of his talks and count the number of times he says 'awesome'. 
Love the work being done on Graal and related projects.
Glad you enjoyed it anyway :)
cool
You’re arguing with a troll man. Stop engaging with it. 
Jeez, like a quarter of it is about race and gender. What shit.
I personally like using [Undertow](http://undertow.io) directly and pulling in libraries such as handlebars for HTML and Jackson for JSON. Here is an example of [rendering HTML from an embedded undertow server](https://www.stubbornjava.com/posts/java-html-templating-with-handlebars-and-undertow). The blog itself is open source with all the code on github.
If you are using Spring MVC you are using the servlet spec from Java EE. 
How is your source code converted into a product you can ship to your customers?
Deserialization does not benefit from reified instances since there is no object instance to begin with. Reified instances complicate deserialization by requiring type information to be generated with the object instance. Serialization code benefits from reified instances only when getClass is used. However, getClass is the wrong foundation for reflection based logic. A better alternative is to pass type information in at the call site. Gson and Jackson jump through hoops because they want users to have the convenience of calling e.g. `toJson` without having to type out `TypeToken` boilerplate. The Java language itself could provide type token syntax sugar without requiring changes to type erasure or the JVM.
We ship a medical software mainly used on windows or Mac in offline mode, so It is shipped as javafx native bundle with installer
 &gt; At least with ant I knew what was going on. It doesn't scale very well past a handful of dependencies. Nearly all modern build tools work in a way that is similar to maven.* My typical project comes with 200+ dependencies, and that's fine, I'm not paid to reinvent the wheel. It can be an issue, but the Java ecosystem is pretty sane compared to other languages. And beyond Maven, in my opinion every Java developer in 2019 should have a serious look at Gradle, unless they have a strong reason to use something else. * The notable exception would be Bazel but that's because Google works in a very different way and relies mostly on internal tools and libraries. 
Is that really a good thing to manage dependencies? If you're writing a Hello World, no. Any non-trivial software: of course. Why on earth would you want to try to source reliable, checksummed artifacts with properly versioned transitive dependencies manually? Beyond which convention over configuration for aspects like unit and integration testing, packaging and distribution, is crucial for fungibility in development processes. There are endless resources describing the use cases for Maven; one would have to be willingly obtuse not to see benefits in all but trivial limited use cases.
Ok, I will delete my post. Thanks for your input. 
&gt; Nobody have been able to explain to me what exactly maven is doing in the background. Maybe you could... read a book?
You should try managing dependencies for large scale enterprise projects without maven or gradle. I did this before maven came along. Was a nightmare with the different versions of things like spring and hibernate and all the other necessary jars. You would get hard to solve errors at runtime such as class or method not found due to conflicting versions or jars. Maven handles this by automatically including the relevant jars and compatible dependencies.
Ant is like writing Makefiles on your own. Maven, on the other hand, has a fixed project structure, allowing plugins to get their work done very effectively. Moreover, once you understand Maven's project structure, understanding other project using Maven is straightforward. Source files are located in src/main, Test source files are located in src/test. Icons, config files etc. are located in src/main/resources and src/test/resources. Maven's dependency management is very good. It allows to configure your software in one single file and automatically downloads dependencies as needed. There are a lot of tools supporting Maven out of the box. If you need a test coverage tool, there most probably is a plugin that is configured with only a few lines of XML code. With Ant, you always have to adapt an extension to the project structure defined in your ant file. \&gt; The only reply I get from people at work or on the web is {THEM: Oh, it does not work? Yeah I had the same issue a couple of week ago. I found this plugin that solves it. ME: What is the plugin doing? THEM: I don't really know but it compiles now.} That's not a good attitude. You should always understand the tools you are using. It is very important to know the advantages and disadvantages as well as the limits of a tool. For example, although Gradle is a very good build system there are situations in which Maven performs better.
1. Standards. Given 50 ant projects you'll have 50 different build scripts with 50 different oddities to work out. This makes it hard to share projects between (teams of) developers. Having one reliable system reduces cognitive load for day to day operations. Maven also makes it easy for IDEs to understand what your project looks like. This allows auto complete to work correctly and take into account if you are writing tests or production code. 2. Dependency management. Manually downloading dependencies is time consuming and error prone. Manually managing the classpath is time consuming and error prone. Manually adding test libs to the class path when executing tests is time consuming and error prone. You are worried about 100s of deps. You'll have those regardless of using ant or maven but Maven excludes a whole class of errors. You will still have to inspect them all. Fortunately because you are using maven you can automate OWASP and software license checks. With Ant this just won't happen. 3. Documentation Maven is documented. The plugins are documented. Your ant script probably isn't. Go read up. 
I find it easier to grasp when you think about a build being an abstract pipeline that starts with code and ends with a compiled artefact. This is true for practically all builds. That pipeline is made up of phases, iirc these are : generate-sources, compile, package, install and deploy. What actually happens in those phases are handling by plugins. e.g. you deploy a docker image, the docker plugin builds a image created in the artefact from the install phase. As for advantages : * I'm employed to deliver value to the company. I'm not paid for busy work untangling masses off spaghetti build scripts. Once you get beyond trivial builds. both Ant and Gradle builds become problematic. * One Maven build has the same feel as another Maven build. It's consistent across projects, making it easy for me to switch between projects. If you really want to dig into the internals, I suggest reading [Maven, the definitive guide](http://shop.oreilly.com/product/9780596517335.do). But it's a build system, you're likely not paid to work on that. :-)
You really need to overthink your approach because your content quality is extremely degrading. Here, your posts won't be tolerated much longer as we mods already receive frequent reports.
I laughed so hard in the face of your ignorance but then realized troll doesn’t have ignorance. Bless you.
The reason I asked is -- as others already pointed out as well -- to help you to bundle everything you need into one product deliverable, the same way each time, the same for every developer in your team. In the olden days, it used to take about a full day (2 if you were new) to build a workspace together where all the code would be present and compile... and then we'd still have to hope that when we added something new, we got the Ant script right to get it included into the deliverables. These days, using Maven, setting up a workspace doesn't take an hour (or two if you just reinstalled the operating system). (Note: other systems like Gradl etc will do the same). To me, it's all about repeatabililty: different developers, even those using different IDEs, will get the same build as all the others.
This is really solid for a first project! It's better code than some things I see all-too-frequently (read: every week) from 'professional' developers with years of experience. Design/API suggestions: 1. Good job on adding some tests, and doing so by mocking out the remote end with an actual server (I'd have used WireMock but it looks like MockServer is filling the same role). You have too much going on in each test though; let each test assert one logical 'fact'. This makes it easier to tell what went wrong and better isolates tests from each other (reduces the chances that a failure is caused by state from one call affecting further calls). You could also DRY the setup code. 1. I suggest renaming the `objects` package to `model`, it's more idiomatic. 1. Instead of documenting internal implementation classes as "do not use this, use Jenkins instead", move them to an `internal` or `impl` package and remove the JavaDoc comments. This makes it easier for a user to distinguish between the public API and internal implementation. 1. Good job using preconditions and validation. +10 points here :). 1. Also good use of exceptions. Another +10 points. 1. Looking at the `Node` class: avoid getters in interfaces, especially getters that return a class instead of an interface. You're coupling all implementations of this abstraction to the `Jenkins` class (and moreover, basically requiring each implementation to have a field). Instead, just let the implementations have a constructor that takes a `Jenkins` parameter. (A casual search of the code suggest that the `getJenkins` method isn't really being used, can it be removed?) 1. I don't have time right now to look for a good solution, but I'd try to clean up the `getParent`/`setParent` code. It seems to be a leaky abstraction. Again, this is a really solid effort. Nice work! 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt; And beyond Maven, in my opinion every Java developer in 2019 should have a serious look at Gradle Imho Gradle is similar to Ant that it can stray into a project specific bundle of scripts. A project in Maven almost always follows the same set of steps. Sometimes there's a plugin that I was not aware of before but thats about it. If there's an edge case case that is not covered by Maven or an existing plugin, I could write my own plugin but I just rethink if it is really necessary. It often isn't.
Yeah, the tests will also help with maintainability. Otherwise someone has to manually validate things all work and would create a nightmare as this gets big! 
Obviously I could and I should and I going to. However, my frustration comes from the general lack of knowledge of the developers atoind me.
It looks like in your [submission](https://www.reddit.com/r/java/comments/ak43y4/java_framework/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Bootstrap for starters, then a framework like angular or react
When i am selling you a car for 100k when you can buy the same car down the street for 10k ... what does that say of me? Of you, of course i could say: hey, you should research better. But of me? Am I not a scammer at that point? A con man? 
An old colleague used Ant and checked manually downloaded dependencies (jar files) into SVN.
Either way, that car has to get paid for. You want to pretend the car is free and that someone else should pay for it. One can argue that paying more for it, so you can directly support the car maker, is more honest.
&gt; One can argue that paying more for it, so you can directly support the car maker, is more honest. lol. you're just trolling now. hahaha, now that's one insane statement. kept here for posterity.
Using spring sts and netbeans at work every day and I've never considered paying for an IDE. But after trying the community edition I'm considering begging my manager for the ultimate edition. 
Before doing so, use IJ trial to check that it fits your needs for your stack. If it's possible, then beg for it! And in case your manager doesn't want it, buying a personal license isn't that expensive giving how much a dev earns.
Maybe take a look at JSF (Java Server Faces) with Primefaces
Side question, do you maintain the TypeTools project? That jodah name sounds super familiar to me. 
My manager refused to pay for my licence so bought personal licence it's not that expensive. 
I can't believe a company wouldn't pay for what makes their employees more productive. I only use IDEA at work but they pay for all products pack so we can use anything at home too. As well as a $150 mechanical keyboard (or a special one if you have RSI). 
I don't want to say the name of the company but it's one of the biggest actor in the telecom industry here in France :/
Expecting to get something for nothing is what's insane. It's also insane to hate on a diverse ecosystem of tools. Having choices is a good thing. You don't have to use JetBrains products to see that. But calling them a scam because you won't is, once again, insane; or at least silly.
At least you know what they think of you if you decide to move and they ask why. 
Who cares about Google. Are you saying that APIs should be copyrightable?
I am going to give the short answer, but there is a lot more to maven including plugins, parent projects, etc. Maven has been very successful in enterprise for more than a decade. And yes, you could use Ant but Ant is mostly just a build tool/script for compile your projects, it doesn't do any type of finding dependencies. &amp;#x200B; With maven, you may have twenty jar library dependencies and those dependencies may have dependencies. In ant, you have to specify their specific location and when to include them at compile time or runtime. With maven, you just specify the version and dependency you need, it will find the child dependencies and properly add to your project. It will build fat jars or wars, run unit tests, run test coverage tools and more. Find the proper version from a remote Internet server or internal server in your network. &amp;#x200B; Yes, maven is blackbox. A lot of modern tools are these days. You want to use that declarative syntax and special only what you need. You don't need to specify all the details. &amp;#x200B; You asked, what does maven do? Well it does do "compiling", it does place the proper jar dependencies in your classpath for compile time. Or even run time. It does place the proper jar dependencies in the proper place for a WAR file or EAR file. &amp;#x200B; On specific details, does it matter? There is a local repository that is used for stashing all the dependencies if needed and then bundling the libraries when needed for your project.
There are lots of good answers already, but let me give you a little background, as history has a way of shedding light. Prior to Ant, the entire build was written out in a shell script or makefile. Ant, enabled declarative style with XML to validate syntax (to a limited extent) Maven, brought convention over configuration, thereby greatly reducing the complexity of builds, as long as your project conformed with the conventions. Gradle, a combo shot of scripting and convention over configuration.
if you plan to program in java, you can take a look at GWT or Vaadin, in that order. GWT should require little effort to jump in. I tried it a few years ago and it was straightforward. &amp;#x200B; Otherwise, if you are willing to learn Javascript and your time frame will allow it, I would recommend Vuetify for components and layout and Axios for back-end communication. &amp;#x200B; JSP would not be necessary. We just finish our first SPA with that libraries and a Spring Boot for backend and it's working pretty good. &amp;#x200B; &amp;#x200B; &amp;#x200B;
Because scripts are cancer
I'm saying Google should have just paid the licensing in the first place and then we wouldn't have this stupid shit to deal with now. All we have here is jobs for lawyers and probably bad precedence being set. 
Sorry to see this gets down voted. I think people are shooting the messenger. 
I have a full license for free through college. Intelli j make great products. 
Did the same. My college uses DrJava which I started with but then shifted to IntelliJ and got the Ultimate version through school. Amazing that these companies do that.
That is an answer that presupposes the result. If API's shouldn't be copyrightable, then Google should have been free to use whatever implementation they wanted. If they shouldn't, then yes they should; but putting the blame on Google — and not on Oracle and the courts — misses the point IMHO. If it weren't this case, it would have been some other case. It was a ticking time bomb &amp;#x200B;
https://www.youtube.com/watch?v=JQ7xVO9lqD0
Yeah I have seen that before, I don't see why it is relevant to the question of API's being copyrightable. I don't care if you like Google, and I am not here to change your mind. Either you believe they should be copyrightable, in which case it makes sense that you believe they were in the wrong; or you believe they aren't, and then Google had every right to use an alternative implementation. I am not talking about the ethics of it all, things can easily be legal and unethical. But again, if you believe APIs aren't copyrightable, then it is fine to take delight in something hurting Google, but that doesn't mean it was their fault. The fault belongs firmly with Oracle for making the argument, and the courts for agreeing. &amp;#x200B;
its in their interests to hook people in early. IntelliJ is great, moved to it in the last year or so. Keybindings and the UI changes were my initial issues but goddamn its so much smoother. Don't need a million plugins either.
Jhipster is a nice starter for poking around at something with an angular or react UI and a spring backend. 
[Spring Tools 4 - for Spring Boot](https://marketplace.eclipse.org/content/spring-tools-4-spring-boot-aka-spring-tool-suite-4) [Spring Tools for Eclipse IDE](https://www.eclipse.org/community/eclipse_newsletter/2018/february/springboot.php)
That is what found as well. I use default theme with gray background. I tried dark theme but I cannot make any sense of the carnival color theme, it actually hurt my eyes when I gave it a 3 day trial.
I don't use Java 12, VCS or gradle so this is a bit underwhelming. I'd rather have some of the bugs fixed that have been open for years and dozens or even hundreds of votes. 
Because it's not measurable so it's difficult for a middle manager to make a case for spending 10,000 in licenses (There's more than one dev usually). Most companies have thousands of places where they could spend money to improve something and (sometime artificially) limited budget. In my experience this kind of spending goes as a rider on a big project in the *development infrastructure &amp; miscellaneous* bucket. I know that's what I had to do to get anything while working for a F50.
Interesting, thank you for showing me this! I'll be sure to look at this when I have the chance.
Disclaimer, I jumped straight into Maven (then Gradle) and have never used Ant. &gt; do I need to update the repository indexes and check for latest version every time I want to compile my project Nope, you really don't need to do that every time. Updating dependency versions should be frequent, but on your own terms / decision making power. Updating indices may be necessary if you ever rely on SNAPSHOT versions, but in terms of actual release versions you can go slower and make that choice yourself. --- Would you also ask similar questions about Gradle? If you are already using Ant, then I would draw the comparison that these are all essentially build and project management tools to get reproducible builds. If project management tool offers sugary features like automatically downloading dependencies and resolving the dependency tree for you, I don't think that's something to be sad about. It's a feature for your convenience as a developer!
The vast majority of modern web apps with Java back-ends I worked on are SPA's with (for example) React or AngularJS. So the Java back-end only exposes a REST API and does not do any server side rendering. I'm personally strongly against server side HTML rendering unless there are specific performance reasons to do so. In my experience this mix of client and server side front-end logic is hard to reason about and hard to maintain. If you want to do this by all means go for it (I'm not your boss ;)) but I would personally just use some basic Thymeleaf rendering and still do most of the UI heavy lifting on the Front End with React. 
&gt; The only reply I get from people at work or on the web is {THEM: Oh, it does not work? Yeah I had the same issue a couple of week ago. I found this plugin that solves it. ME: What is the plugin doing? THEM: I don't really know but it compiles now. You have a dev culture problem. Maven isn't the issue here. Your team is. 
It's like 4 or so questions :S
You don't use any VCS? You should think about that, it's useful even on solo projects. 
That's what I get for reading reddit while still in bed and groggy... I just skipped the article and read "CVS" instead of "VCS" and thought "Why the hell do they improve on *that*?".
Oh, ok then :D
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Some options I would recommend A) A minimalistic css framework, skeleton for example. Maybe a static site generator with some vanilla js added in for dynamic content through ajax and the dom API. The backend is just a REST API. B) Depending on scope, server side rendering may be fine. Prefer something not coupled to your backend, pug/Jade for example. Something that simply renders content into a template. Frameworks like vaadin/wicket/jsf is an artifact from when we transitioned from desktop to the web, they make little sense today. C) custom elements API: Polymer/LitElement/lit-html. These are great for building single page apps. They share some concepts with React but promotes use of standards and APIs present in the browser instead of inventing new things like jsx/vdom. If you use Polymer you get material design included with your components. Angular also invents a bunch of new things which makes it harder to learn. 
I too am looking to appear for OCA. Let me know too!
It should be zero. Who gives a shit? Only racists.
Vaadin (easy option) or ReactJS/Angular :) 
I think they deprecated CVS few releases ago. Decided to throw it away.
Thanks for your input I appreciate. I see a bit of hostility even if my posts are good, I have not seen a single post in last 2 year which has done well here, even though they are quite useful but a few of Reddit people dislike making it in-accessible for rest of the Java developers which is part of this group. I joined this group when it was just a few thousand members so it's been a long journey and I feel keep sharing here. I know my posts are not best but recently people have focused more on negative than positive. Anyway, I take your advice with positive and improve but yeah, noted, won't share my rubbish here for a long time. 
How does the content overlap with the book?
Hi. Author here. The book is more theoretical while the course takes a more practical approach. Although the content might overlap in terms if curriculum, it's a different learning experience. If you have any other questions, don't hesitate to ask them and I'll answer them for you.
Hook em early!
Yep 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I didn't know there was a course for this. I bought the book when it first came out and it's on the yearly reading list with Effective Java. Wish I had the extra cash for this.
Thanks for appreciating my book. If you are interested in the video course, send me a private message and I'll send you a discount coupon.
+1 Vlad
One of the most obvious advantages is getting rid of dependency management, so you don't have to manually download all dependencies or upload them to your project making it lightweight. It also helps to versioning so when you project evolves but you want to run an older version that uses older dependencies, you don't have to worry about them. But maven it's not just a dependency management tool. I recommend you to read more about it. You can start by reading [this](https://stackoverflow.com/questions/3589562/why-maven-what-are-the-benefits) stackoverflow answer, but I recommend you to find a book.
Is it free to get the course?
This book is a good reference: [Maven: The Complete Reference](http://cdn2.hubspot.net/hubfs/1958393/eBooks/Maven_the_reference_guide.pdf?__hssc=31049440.3.1548621578450&amp;__hstc=31049440.bb11c2f6dd5744791cacfb7929271696.1548621578450.1548621578450.1548621578450.1&amp;__hsfp=3705199130&amp;hsCtaTracking=ae9a5964-1b87-4ba3-928b-d692e2b19421%7Cce6355b9-53ce-46f8-934d-9b75e3319429) It is free to download on the Sonatype website. 
My 2 cents... There’s no need to download dependencies manually. Ivy can be used for dependency management if you want to use Ant. https://ant.apache.org/ivy/
There are some free samples too. And, you can buy either the full bundle or individual modules. Check out the [courses page](https://courses.vladmihalcea.com) for more details.
jesus. just reading your babbling gives me a headache. 
What's the difference between Mach 1 and 2?
I'm not surprised. I'm obviously too advanced for you. Seriously, if you cannot admit there are multiple points of view on something without "getting a headache", then maybe you should upgrade your discourse.
I have argued with this guy on Reddit before, got the book afterwards. Solid content. While I may somewhat disagree with ORMs ideologically, if you are going to use Hibernate, he is your man. 
what you're saying is just fucking dumb. that's all. go away.
Uh huh, sure. The entire economic basis of a very successful company like JetBrains is, according to you, "fucking dumb". You might not be as smart as you think yet. 
a scam can be successful .it doesn't make it less of a scam. you're the idiot for supporting them.
The point I was making is that the question would never have come up if Google had played fair in the first place you stupid shill. Now fuck off.
IIS, ah I remember those days, try moving away if you can. But for your specific requirement, use IIS as the main web server and then reverse proxy to your tomcat web server. It's a piece of cake in say Apache, but IIS is your ball and chain...
So by that logic Linus Torvalds should have just played fair and licensed Unix? Because if he had, then the SCO (at al) lawsuit never would have happened. Or that any system that clones another system should get permission because that wouldn't be playing fair. I am not pro Google and anti Sun; but companies are/were complex entities with pros and cons to each; and I am not shilling for anyone. The blame here is with Oracle for loving money so much they made this foolhardy and stupid legal argument, and somehow managed to win (for now at least). Oracle — in my opinion — wasn't suing Google out of some sense of justice for Sun. Like I said before, if it weren't this case, then it would have been something else. Until the supreme court rules, or we get a legislative solution one way or the other; this issue was a ticking time bomb waiting to go off. 
https://discord.gg/code
basically my issue now is I'm trying to take user input, but I'm having an issue. If input is between 40-60 I want to print something specific, but I'm having an issue saying between those. my code is something like this `int userInput = input.nextInt();` `if userInput &lt; 30` &amp;#x200B; I'm just having issues saying between those two?
IRC #java
\*look\* I'm embarrassed to say this. i know IRC is just internet relay chat but wtf is it? Is there a main platform? I've just never used it.
Use logic so something like else if (userinput &gt; 40 &amp;&amp; userinput &lt; 60){ //code }
yesss actually someone in discord just told me that too! I didn't know that was legal. Thank you!
This is a verrrrrry basic line of code in any language and usually taught in middle school or high school. I guarantee googling it will give you the answer. Also this question is better fit for the ask or learn programming subreddits. Anyways, here is what you are looking for: if(x &gt; 40 &amp;&amp; x &lt; 60) { ... }
Thanks, yeah I know I'm just starting out. I'll slide to those, do you know of any active ones? Thank you though I'm just learning the &amp;&amp; is legal 
Hey man, no reason to belittle him (he obviously googled to find this subreddit as well). Everyone starts somewhere. 
One popular Discord server is Together Java: https://discord.gg/hVtnwGd
This subreddit is spammed full of these questions, where users don't take a second to read ANY of the sidebar or google their own question for even a minute. It clearly says in the sidebar where you can get help and all of the helpful subreddits, like: * https://www.reddit.com/r/javahelp/ * https://www.reddit.com/r/learnjava/ * https://www.reddit.com/r/learnprogramming/ This subreddit used to be full of high level discussion on current and upcoming Java features, neat tricks, great articles, etc. Hard not to be sad that the mods leave stuff like this, cause it just basically forces all of the good users out and kills the sub. 
Don’t be afraid to try ;) must of learning to code is practice practice
Still no need to be a jerk, you're the reason people are afraid to get into programming. 
#**NO programming help, NO learning Java related questions!** source: look to the right of your screen 
He asked if there is a discord for java, not for help with his issues in his op so he is in the right subreddit. I agree with your points but they do not apply to this post so youre being rude for no reason. Have a great night!
he didnt ask any of these topics source: look at the title of the thread youre in.
Still not an excuse to be an asshole. There's a polite way of doing things, you could have told him politely that this is is off topic for the subreddit instead of being rude. You didn't even consider that he could be in middle school or high school.
You can [download a client for it](https://www.mirc.com/), or you can find a platform online. I personally go to rizon.net for default 
&gt; didnt ask any of these topics Except the title's question is ALREADY answered in the sidebar, and then he immediately posts: "basically my issue now is..." as a comment onto his own post. LOL ok. Here's a third copy paste from the sidebar for you all who can't read: #Please seek help with Java programming in /r/Javahelp! The main concept of the sub is: #Java News, Technical discussions, research papers...
Quite snappy for someone who boasts about being able to read the sidebar but then fails to read the actual rules a couple of lines further down: Upvote good content, downvote spam, don't pollute the discussion with things that should be settled in the vote count.
...that doesn't apply in the slightest. This subreddit is dead due to lack of good mods and users like you spamming basic info to preteens asking how '&amp;&amp;' works. Respond with whatever garbage ya like. Peace.
You may find this page useful https://docs.oracle.com/javase/tutorial/java/nutsandbolts/index.html The [Operators](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html) page goes over all the arithmetic, logical (like `&amp;&amp;` (and) and `||` (or)), and assignment operators, while [Control Flow Statements](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/flow.html) goes over if/else/else if and switch/case. 
Doesn't excuse your condescending tone in the slightest.
It looks like in your [submission](https://www.reddit.com/r/java/comments/akiyii/need_help_with_for_loop/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You should point out what network you're talking about. I assume probably freenode, but there are other irc networks still.
Maven is definitely the most worthless "should work" piece of software I have to deal with. Before: If you got your project to build in the IDE it will build next time. Maven: Uh...yeah...it might build. Or...you might need to run an update. And...yeah, you might need to manually clear out the cache files because our maven is mysteriously error prone and unstable for some reason. (Seen this at 2 jobs now). Before: Well you gotta download the jars from the internet. Maven: It will be so magic, maven will do it for you! I mean...what? A corporate firewall? Who would have possibly seen this obstacle that every single company has? Ok, well what you need to do is setup your own local maven server because trying to through the firewall is unstable. And you need to setup proxy config on your local machine via maven config to be able to get to it. And you need to put in your username and password...oh yeah, don't want them in plain text so we need to setup another website to encrypt it. Oh does your employer require changing your password every so often? Well of course maven will just silently fail without telling you why or how to fix it. Be sure to reencrypt your password and update your maven config with it. Before: Export an ant built. Jars are in your project so we're good to go. Maven: Sure, we download jars? Hmm? Oh, no, not with the default build. You need a plugin in order to do that. Oh our first plugin creates a directory you can't delete on your machine without rebooting for some reason. Ok, configured a second plugin that for some reason isn't maven's default behavior. Now we'll put your jar file a semi-random place on your system. Before: Download the libraries you need including the latest updates. Maven: Oh yeah, so we had another department setup that local maven server we talked about. They put a few libraries in there but now that the excitement has worn off they never update anything. Have fun using old out of date versions of you libraries. A way to contact them? Hahahaha that's funny. 
What exactly to you expect people to discuss here? It's dead because pretty much any type of discussion about the language can be considered "help". Even complicated questions are banned with this rule. We're limited to talking about frameworks and projects made using java This sub is basically a glorified news feed with a sprinkle of self promotion. IMO JavaHelp and this sub should be merged. There is nothing unique or defining about this place and it's existence is pointless.
My old (but still relevant) post on this: [https://rule1.quora.com/Use-Maven-Not-Gradle](https://rule1.quora.com/Use-Maven-Not-Gradle)
Mach 2 contains everything in Mach 1 plus the Batching, Statement Caching and Persistence Context chapters. Mach 3 will be released this year, and it will contain the Fetching and Caching chapters.
Thanks for appreciating my book. I'm glad you liked it.
Please, for the future: Ask: + Java programming related questions in **/r/javahelp** + learning Java related questions in **/r/learnjava** **Removed**
Angular or React seem to be the most popular answers for a front-end. I don't know why. They both suck compared to developing with GWT or Vaadin in Java. Angular or React will require up to 5 times the number of developers you have today just for the front-end. It depends on the philosophy of your company. Once the Angular/React crowd takes root, guess what will be next on the agenda? Go ahead, guess.
I think builders replaced factories yesterday, hard to keep up.
Thanks
Just use one of the free JDKs, and you won’t jave to pay a penny
Yea, I'll be running Open-jdk for the foreseeable future.
Rip Orical
I think the thing that I learned from this post is that Java 8 is also getting the license changes. I mistakenly believed it was starting in Java11 or something. I’ll be moving to OpenJDK 8 then as well as to OpenJDK 11 soon. 
This isn't news; this has been known for a long while now. More to the point, it's misleading. **Oracle** Java is now a commercial product. The thing you're paying for is not really the software (that is merely a fairly simple compilation of an open source repository), it's a mix of commercial support (you can call someone and ask for help), and a continued support of a specific tag in said source repo in the form of applying security patches to it and providing a 'channel' on which such updates are announced and distributed. **Oracle Java SE** is just one of many distributions of said open source repo. You have many other options: * AdoptOpenJDK releases both JREs and JDKs, for a number of platforms, and various versions, with a commitment to continue to build JDKs and update them as long as any security / bugfix patches are released in an open source manner (as in, they'll apply any patches they can legally find or which are contributed, they won't commit to write any themselves). * Coretto is an attempt by Amazon to make and support builds. They are checking them for running well on AWS EC2 instances. For now there's a JDK8 preview release. Presumably, JDK11+ is coming soon. * Oracle themselves also make a free product confusingly also called 'OpenJDK'. They won't support these for long (when OpenJDK12 is released, support for OpenJDK11 is dropped), but there's always a legal, freely provided version available from oracle. * Various commercial entities also release their own builds. Some of them are also provided for free. For example, Azul. Also, the general method by which JVMs are released has been changed to match what it's pragmatically speaking been for a while: If you are a _distributor_ of a JVM-based application, now __YOU__ are responsible for rolling out a VM to your customers, and keeping it up to date. If you are a customer of some ancient product not being updated by its creator and you do still need a JVM to run it on, pick any of the above options. Otherwise, the product you bought will take care of it for you. 
It really doesn't. Java 8 is simply end-of-life. I assume it is NOT news to you that oracle is not currently supporting OracleJRE v1.6 downloads, nor will they ever again. v1.8 is in the same boat now/soon, that's all.
&gt;An old colleague used Ant and checked manually downloaded dependencies (jar files) into SVN. &amp;#x200B; Current situation I am in: * No build tool. Eclipse is the build tool * No deployment tool. Eclipse is the deployment tool * Libs are stored in git(making clones excessively slow) \#FML
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
**Removed** + *Clickbait Title* + *Misleading Information* - there were, are, and will be open source and free Java versions
I mean, &gt; Public updates for Oracle Java SE 8 released after January 2019 will not be available for business, commercial or production use without a commercial license. That’s pretty clear to me. And my company is slowly converting to JDK11 in the first place, so OpenJDK8 first will be an easier step. Java8 is getting security updates. This is arguing semantics at this point, but is that truly EOL? Or is EOL when there’s *no* more updates at all?
do we get lifetime subscription if we buy the course? And when the course gets updated, we will get the updates right? 
Cost of tools for IT companies are just peanuts compared to salaries and office rents. The price for highly efficient and production boosting IDE is under one dollar or euro day. Managers not willing to pay that are not only incompetent, they should go to work in some basic manual labor since they clearly lack the cognitive abilities required in tech.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Nice read
I was happy with NetBeans for years and am still using it, but IDEA gets more tempting by the day. Every time I start it up I stumble across something new to be impressed by.
*Hey just noticed..* it's your **2nd Cakeday** lsivashov! ^(hug)
I enjoyed this, but feel obligated to point out ms is milliseconds, not microseconds.
You are very welcome.
Yes, you get lifetime access. Updates are coming whenever something changes and needs to be included in the course.
I just feel the cost is too high especially for people in developing countries. 
Play framework 
Writeups like this are why I come here in the mornings.
Post says it can't be web based, doesn't that eliminate Play?
Can I dm you for a little help?
Author here: I am glad you like it! I did some edits today, but nothing about units. In the fact I had been lazy when drafting it and I used "us" instead of "μs" in the original text. However I had figured it was too lazy:) and changed it before the post was published. 
&gt; maven is a blackbox You could literally say this about any abstraction. * How does System.out.println work? Don't know, blackbox. * How does the javac compile your application into bytecode? Don't know, blackbox. * How does the JVM execute your bytecode? Don't know, blackbox. * How does the Operating System implement the JVM's commands? Don't know, blackbox. You rightly point out that abstraction has a cost: You lose knowledge, visibility and experience of how something works under the covers. Not using an abstraction also has a cost: You must manually do everything the abstraction did for you automatically. Leaky or useless abstractions need to be avoided and abandoned but valuable abstractions are always going to win out because it lets you focus on problems that were previously too complex for you to solve. It sounds like you know how to do everything that Maven does for you and are getting frustrated because Maven's abstraction is getting in your way. I completely understand that. However, I would recommend you take the time to learn abstractions if they become well used by other developers (and Maven definitely qualifies) because it is very unlikely that your colleagues are going to agree to give up the abstraction and acquire your knowledge on how to do things manually. On the other hand, when you do understand how your manual knowledge maps onto Maven's abstraction, you will be in a much better position that your colleagues to work out a fix when something breaks. &gt; Maven download the dependencies for you. But is this really a good thing? I mean I have hundred of dependencies in my repository that I don't know of and I don't know why I need them and what exactly they are doing. Okay but you decided to pull at least one dependency in, right? And the authors of that dependency decided to pull in the other dependencies that you have no idea about. So stop pulling in dependencies you don't trust and either pull in ones that you do trust or write all that code yourself. This is not a problem with Maven. If you did it manually, you would still have to pull in all the nested dependencies manually (and likely make some mistakes along the way) or the dependencies that you do want won't work. You might argue that dependency managers (not just Maven but all of them), make it easy for inexperienced, careless or time-pressured devs to just pull in dependencies regardless of the consequences. However, I've seen just as many devs download random jars from thisisdefinitelynotavirus.com and stick them straight into their dependency folders without using any form of dependency manager. Everybody can make crap decisions regardless of the tools they use. &gt; And do I need to update the repository indexes and check for latest version every time I want to compile my project? Are you deliberately depending on snapshot versions? Then yes you probably do want to regularly pull down the latest version. Probably not every time you compile but then Maven won't do that unless you force it to with the -U switch. Are you depending on non-snapshot versions? Then no, you should rely on those versions never changing and your cached copy is fine. No reason to every redownload unless you clear the cache or build on another machine. &gt; I am sure I am missing the advantages here, so I am eager to hear about your xp with maven, especially, when did you say to yourself that It really saved you some hurdle? Maven forces our hundreds of projects to build in a standard way. When we used Ant/Gradle it was the wild west and it was really difficult for developers to move between projects because they could never get a project to build and run. There were some projects that only certain individuals could build and run on their machine because they had pulled down all the dependencies manually (like you propose doing) and the knowledge of how to do this existed only in their head. If I wanted to do something very unique/bespoke or for an ecosystem where it was more standard (e.g. Android development or IntelliJ plugin development), then I would use Gradle instead with tons of documentation to compensate.
Great news. You can isolate near real time parts of your program while still taking advantage of simple and fast interprocess communication. One of the possibilities that come to mind is keeping the cache (long lived objects) in separate isolate than the program logic and the rest.
Had similar experience with Thread.sleep() on Windows NT based systems running Java back in late 90's. You'd always get a granularity of 10 millisecond, despite what value you entered into the sleep() call. Going below 10 milliseconds had no impact on WinNT. Linux back then was already happy to respect the 1 millisecond granularity (nanos were not available yet).
I don't have an answer, but I'm curious ... can you explain why a web based client isn't permitted? 
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
It is reserved for very small applications used by a very limited range of users (&lt;10). The new Java stack would be used instead of our old MS Access stack. The goal here is to get something done with the minimum overhead, be highly maintainable, quickly updatable and could pententially use the Windows desktop PC to generate OpenXML documents which is very limited using a Linux based server.
That's quite an argument you've made there. Very convincing. /s
The fun thing here is that is completely up to the OS scheduler. And when Loom hits, it may be up to the JVM scheduler! So there is almost no guarantee with what happens next. These issues are, as a consequence, the reason why Java makes a poor real time language.
Thanks. I understand. Just for the sake of discussion ... If all of the users are on the same network and they are all connecting to the same database, that a Tomcat server installed on the db machine serving up a web app providing a front end to connect to the db is exactly what I would propose if I was the architect. Even if I was building a desktop db client application, I would have it talk to REST services running on the Tomcat server rather that putting the business logic a fat client running on each PC. Also, another advantage of the one central web app design is that there is one installed application to be updated and maintained ... you won't have to deploy upgrades to all of your users. All of these are some of the reasons why the industry has moved towards web apps and away from desktop apps. If you find what you're looking for, please post back here. I'd be curious to know if there's a "fat client" generator like that.
Funny the assumptions they make in that survey. They assume I might have ever updated a resume. Or even written one in the first place. They assume I might have changed jobs in the last almost four decades, or early eighties. They assume I might have had an interview sometime in this millennium. Despite having a Senior Developer title in a company that employs several thousand.
It's beautiful the way frameworks are integrated seamlessly into the architecture of the IDE. I tried to get glassfish to work on eclipse and it was a nightmare.
I'm available on the [Hibernate forum](https://discourse.hibernate.org) if you need help.
What HW? (you only need that for SPARC, not X64)
Maybe [EMFForms](https://www.eclipse.org/ecp/emfforms/index.html) (e.g. to generate JavaFX or Swing Forms from model)? Not sure how well it works or how maintained it is.
I agree with you but one can't deal with absolutes, especially when more than 300 fat client applications are involved. Most of them can't be rewritten on our Java/Angular stack but some won't. Let's say 80% will and 20% won't. Note it would be very easy to build fat client applications in such a way I'm looking for with C# and a commercial framework such as DevExpress. But we're focusing on Java here. Thank you for your insights and your time. I will sure post something again should I find something relevant.
Before I share my data: what about you ;-) Also which people are you asking? Because a Junior Dev will 100% have different time allocations than a Senior
You’re right we have some sparc hardware and need to get some Solaris intel installed
Junior dev. My experience is wierd, one team it was about 90% code writing and related activities and 10% support type work, next team it is exact opposite where almost all my time is support work. I am not complaining as I am learning a ton of stuff. Writing code is definitely more enjoyable though.
can you give more details about what should one know about collections API ? other than being able to use a given collection say Hashmap. I see many questions being asked from collections.
Thanks , can you explain the use of JMS and JMX ?
as a Java Developer with 2-3 years of experience.
To add to this. My company has hundreds of libraries and projects. I can go checkout any of them and be up and running with it in less than 1 minute, tops. Can you do that with ant? Maybe, but not easily. Now what about adding a dependency? With maven it is a 5 line change to the pom file and the next time your team pulls in that update, they'll download the new dep. What about ant? Well, depending on how you do things, you'll likely have to coordinate with the rest of your team and get them all to download the right version of the new dependency. What about updating dependencies? With maven, 1 line change. Ant? Good luck updating things or making sure everyone updates them. And good luck diagnosing problems when dev x forgets to update and gets random "NoSuchMethod" errors, sometimes. Maven isn't a perfect build system, however, it is leagues ahead of ant.
for hashmaps one shall know about purpose of equals and hashcode methods. You shall know sorting logic of different collections. One shall know that Set cannot have duplicates and List for instance can. You can actually google for interview questions regarding collections. Also streams API of Java 1.8 is nice knowledge to have for interviews.
I bought myself a personal license at a job that didn't provide one. I'm still using my own license even at my new job, which allows me to look on with amusement when everyone else freaks out because corporate let out license lapse for a day lol.
It could be used to show racists that diversity already exists.
I'm going to join as Addie. Hope to see you there
I use that to signal doneness. TDD works wonders for code organization and confidence.
The above isn't wrong, but... &gt; Maven is documented. The plugins are documented. Maven documentation (and documentation in the maven ecosystem) is not great.
Overly simplified and MHO: The goal of maven is to create a stable project structure in which "mvn package" builds and packages your software. If you have problems with maven you are applying maven wrong. Embrace it's philosophy, do not work against it. Sidenote: Oh and Gradle is still far from feature complete for enterprises: Still no decent (skinny) EAR support. This is a deal-breaker for large enterprises which have many large JavaEE apps.
What does "join as Addie" means?
JMS - it's the standard of async messaging between applications. It may be one of two types: point-point and publisher-subscriber. There are enterpise solutions based on this technology: ActiveMQ, JBoss Messaging, OpenMQ, RabbitMQ, Oracle Weblogic and others &amp;#x200B; JMX - it's the (native) technology which gives a possibilty to one Java application to connect to another one Java application for exploring its status, parametres, affect its processes. This technology is based on ManagedBeans (not JavaEE Beans!). Simple observer application is JConsole located into JDK/bin directory.