I get it, with Aion AVM you can write smart contracts in Java ?
I'd argue that the term use case is relevant. It's not a request handler, that is married to what ever framework is providing the request. I especially liked the fact that all the business logic, including validation, doesn't know anything about the technical implementation, aka frameworks. Hence I'd be very interested, how an implementation of the mentioned email use case using vertx, jax-rs and your framework would look like and compare.
You may be interested in Amdatu, check out there 15 min tutorial on a rest based todo app \[amdatu\]([https://amdatu.org/components/amdatu-blueprint/#\_15\_minutes\_tutorial](https://amdatu.org/components/amdatu-blueprint/#_15_minutes_tutorial))
oh, jshell is an interesting consideration, would probably need to make a few utility methods or higher level abstractions to enable a quick start of jplotter. Maybe in the spirit of matplotlib...
That’s correct.
Thanks. Changing the title that way would change the idea of the post, however. I wanted to underline the importance of the reflection API in the ecosystem, not simply that developers should know how to use it - that can be a separate blogpost with different arguments
I've been working as a java developer for years without one.
If you don't mind me asking have done any certificates or associates degrees?
This is a common pattern, one class for request handling - in this case one class for setting up routes/use cases and one for the implementation - the use case. The only difference is introducing the term use case and mapping requests to routes in a more magical and slightly less readable way. Abbreviated example in jax-rs ``` @Path("/") class ... ... @Path("/sendMail) public MailResponse sendMail(Mail) { return mailUseCase.sendMail(Mail) } ``` Example in my framework https://github.com/codingchili/zapperfly-asm/blob/master/src/main/java/com/codingchili/zapperflyasm/handler/ConfigurationHandler.java Edit: newlines for markdown
No, but I had a lot of experience programming in other languages before I moved over to java.
the problem is not ability to write code, you can certainly do that without a degree (though in some cases it is beneficial to have the experience of one), but the ability to convince someone to hire you without one. if you can do that, you're golden.
And how'd validation look like? Jsr 303 annotations?
It looks like in your [submission](https://www.reddit.com/r/java/comments/bz3lrk/if_you_use_excelsior_jet_you_have_3_days_to_get/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I think that there is nothing better than the official documentation
No, the jackson mapper used to deserialize the "Mail" class can be configured to validate that there are no unknown properties in the request data etc. Validation such as checking if the recipient is a valid email goes in the business implementation, the email sending implementation that "mailUseCase" uses to send email. If needed we can use exception mappers to further customize the error code and body.
This is news, this isn't asking for help.
I'm familiar with Java but I was interested in making 2d games and read c++ was the way to go, was this this wrong? Be sure I don't like c++ so far lol
Antivirus
I'd love if it continued to evolve a little faster tho
Speaking as a software engineering hiring manager: if you don't have a computer-related degree you'll have to work a bit harder convincing me you know what you're doing. But you can do that by showing work experience, showing a certificate alongside a BS or BA degree, or demonstrating in person you know how to write good code.
I love writing Kotlin, but I'm not sure I'd enjoy maintaining a large codebase of someone *else's* Kotlin. All of the boilerplate in Java makes it very hard to do wacky shit that shoots your teammate in the foot with a rope.
Python does a lot of things well, but suggesting someone switches tools to avoid researching which distribution to use is overkill. If the team running OpenJDK team and Oracle provided a professional looking page that explains that OpenJDK is now opensourced and there are many options, but here is the OpenJDK and Oracle suggested distribution, then there would be no confusion at all. Instead the [OpenJDK website looks like it was built in 1998](https://openjdk.java.net/), links you to a [download for major version 12 when most people are using 8 or 11 since they are LTS with other distributions](https://jdk.java.net/12/), OpenJDK's distribution does not have a LTS model meaning you'll have to upgrade every 6 months, the download is only a zip and not an installer and has a note that "Alpine" version of this build was removed because it wasn't production ready without an explanation of what the Alpine version is. Like 3/4 of the problem is literally Oracle/OpenJDK is failing to deliver a message. The other 1/4 of the problem is that the official source of the code has no intention of providing a business ready solution that doesn't require major version updates and the subsequent testing required (and subsequent backup plan if the testing fails) every 6 months.
Hate it when it does that. You can disable real-time protection or something like that in Windows Security I think, but that also disables antivirus. The alternative is to just access the file from the downloads folder.
Reflection is both great and powerful. I have recently put it to good use, but I would never want to see my fellow Devs using it Willy Nilly. Thanks for your post.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Yes, you can code without a degree. I knew a software architect graduated in Biomedicine once (in this area experience counts more than degrees). However for sure being in a graduation program makes it easier to get a job (at least as intern). If you don't like hardware stuff from computer science, try to find another one focused in programming e.g.: software development degree, game development degree, software engineering (of course it depends on the options you have in your region). If you still want to go with certificates start with Oracle Certified Associate Java SE 8 - OCA (replace the number with the version of Java you are interested in working with, this one is the entrance door for java certificates but you can go straight to Java 11 if you want). Also you can upgrade you certificate version to new ones passing in upgrade exams later.
Here's a puppeteer script in node.js to scrape the knowledge base articles and the supplemental downloads they sometimes come with: ``` const puppeteer = require('puppeteer') const fs = require('fs') const https = require('https') main() async function main() { // launch headless browser const browser = await puppeteer.launch({headless: true}) // make new tab const page = await browser.newPage() // go to JET Knowledge Base and wait for it to finish loading await page.goto('https://www.excelsiorjet.com/kb/', {waitUntil: 'networkidle2'}) // get a list of articles that aren't hidden const articles = await page.$$eval('.article-link[style="display: block;"]', pList =&gt; { const urlList = [] for (let p of pList) urlList.push(p.children[0].href) return urlList }) // make ./pdf/ try { fs.mkdirSync('./pdf/') } catch (e) { // do nothing } // go to each article for (let article of articles) { await page.goto(article, {waitUntil: 'networkidle2'}) // get article title const title = await page.$eval('.page-header', div =&gt; { return div.children[0].innerText }) // removing the colon from the title const pdfname = title.replace(':', '') + '.pdf' // kill the random unknown character at the end of the articles await page.$eval('body', body =&gt; { body.childNodes[10].remove() }) // kill the top floating bar, this ends up hiding text in the resulting .pdf await page.$eval('.topbar', div =&gt; { div.style = 'display: none;' }) // kill the header await page.$eval('header', header =&gt; { header.style = 'display: none;' }) // kill the footer await page.$eval('footer', footer =&gt; { footer.style = 'display: none;' }) // make the pdf await page.pdf({path: './pdf/' + pdfname}) console.log(title) // check for supplemental #downloads if (await page.$('#downloads') !== null) { // get list of download URLs... there's probaly only 1 though const downloads = await page.$eval('#downloads + ul', ul =&gt; { const downloadList = [] for (let a of ul.children) downloadList.push(a.href) return downloadList }) // download each one for (let url of downloads) { const filename = url.split('/').pop() console.log(filename) await download(url, './pdf/'+filename) } } } await page.close() await browser.close() } // download with node.js' https module function download(url, out) { return new Promise((resolve, reject) =&gt; { const fileStream = fs.createWriteStream(out) https.get(url, response =&gt; { response.pipe(fileStream) fileStream.on('finish', _ =&gt; { fileStream.close() resolve() }) fileStream.on('error', err =&gt; { reject(err) }) }) }) } ``` To run it, install node.js, save the code as `index.js`, then: ``` npm init jetscraper npm i puppeteer node index.js ```
I know I’m probably biased but having done both .NET and Java development in an enterprise environment I have a hard time making a case for Java. In my experience Oracle makes licensing feel like traversing a mine field and the modern Microsoft is iterating .NET in a fast and open way. Given the two, unless you’re supporting a legacy code base it’s just hard for me to see the appeal of Java.
You might want to grab all the docs and knowledge base articles while you have the chance too. The whole site is going down on June 13th. You can get the docs at [https://www.excelsiorjet.com/docs/](https://www.excelsiorjet.com/docs/) Here's a puppeteer script I just wrote in node.js (yeah, I know, shush :p) to scrape the knowledge base articles and the supplemental downloads they sometimes come with: ``` const puppeteer = require('puppeteer') const fs = require('fs') const https = require('https') main() async function main() { // launch headless browser const browser = await puppeteer.launch({headless: true}) // make new tab const page = await browser.newPage() // go to JET Knowledge Base and wait for it to finish loading await page.goto('https://www.excelsiorjet.com/kb/', {waitUntil: 'networkidle2'}) // get a list of articles that aren't hidden const articles = await page.$$eval('.article-link[style="display: block;"]', pList =&gt; { const urlList = [] for (let p of pList) urlList.push(p.children[0].href) return urlList }) // make ./pdf/ try { fs.mkdirSync('./pdf/') } catch (e) { // do nothing } // go to each article for (let article of articles) { await page.goto(article, {waitUntil: 'networkidle2'}) // get article title const title = await page.$eval('.page-header', div =&gt; { return div.children[0].innerText }) // removing the colon from the title const pdfname = title.replace(':', '') + '.pdf' // kill the random unknown character at the end of the articles await page.$eval('body', body =&gt; { body.childNodes[10].remove() }) // kill the top floating bar, this ends up hiding text in the resulting .pdf await page.$eval('.topbar', div =&gt; { div.style = 'display: none;' }) // kill the header await page.$eval('header', header =&gt; { header.style = 'display: none;' }) // kill the footer await page.$eval('footer', footer =&gt; { footer.style = 'display: none;' }) // make the pdf await page.pdf({path: './pdf/' + pdfname}) console.log(title) // check for supplemental #downloads if (await page.$('#downloads') !== null) { // get list of download URLs... there's probaly only 1 though const downloads = await page.$eval('#downloads + ul', ul =&gt; { const downloadList = [] for (let a of ul.children) downloadList.push(a.href) return downloadList }) // download each one for (let url of downloads) { const filename = url.split('/').pop() console.log(filename) await download(url, './pdf/'+filename) } } } await page.close() await browser.close() } // download with node.js' https module function download(url, out) { return new Promise((resolve, reject) =&gt; { const fileStream = fs.createWriteStream(out) https.get(url, response =&gt; { response.pipe(fileStream) fileStream.on('finish', _ =&gt; { fileStream.close() resolve() }) fileStream.on('error', err =&gt; { reject(err) }) }) }) } ``` To run it, save the code as `index.js`, install node.js, then: ``` npm i puppeteer node index.js ```
yes, but only if you can develop. make something to prove it.
Swing is still in the JDK and JavaFX is now developed separately from the JDK. Java has two great UI toolkit options that aren’t going away.
Swing is a perfectly fine UI toolkit and isn’t tortuous to use at all. Why do you think it is tortuous?
I've been doing it for 20 years. Write some open source stuff or contribute to open source so that you can have something to show.
What to say... People and by extension businessis are focused on continuously delivering new features. Not some security Nice To Haves. But even HTTPS will not protect you from rouge repository hosting forged jars with perfecly valid SSL certificatr chain. Shouldn't the build tools support some additional dependency digest declaration? Security of the transfer protocol would then be less relevant. I guess maintenance of such dependencies would a little more complicated. FreeBSD ports do this if I am not mistaken.
Something that should be simple, like adding a scrollbar to a textbox, requires about 50 lines of code in swing. In any other UI framework, you just set a property and there's your scrollbar. Suck Fwing.
&gt; Python does a lot of things well, but suggesting someone switches tools to avoid researching which distribution to use is overkill. It's not avoiding, just reducing the need and/or reducing the financial impact of doing research wrong. And I am not recommending people abandon Java, only that investment in Java for new projects will shrink if mistakes burn shops with surprise bills or lawsuits.
A jar is effectively just a archive so it's probably being scanned for viruses.
Thanks!
It looks like in your [submission](https://www.reddit.com/r/java/comments/bz6dew/using_mockito_and_a_helper_class_as_configuration/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
To be totally honest, I like java and this is just a fun personal project I can show off so I wasnt looking for the most optimal way of doing It i just wanted to keep learning and have some fun :)
Thank you! I am quite the proud momma hen :)
To be totally honest that part doesnt bother me. I'm not doing this to make a game that everyone loves, I know a ton of people who love the tomb raider series and to be totally honest I never did and still dont really care about it. It's not for everyone and I'm not silly enough to believe it is. He had something nice to say as well and I really appreciate that :)
This is the good start witB Spring
This is the good start witB Spring
As a hiring manager for a large corporation, your resume would never make it out of HR and on to my desk without a degree of some sort. The only way I’d see your resume is if someone I trusted handed it to me directly - and even then I’d have to see something that made me feel like going out on a limb to get you instead of all the other candidates. I’d also get pressure to pay you less because people without a degree make less. It’s like choosing to play the find a job game on ‘hard mode’ at best.
Agreed. When a company receives a ton of resumes through their web portal, they need some heuristic to narrow down the list of candidates. Having a degree is an easy filter that can eliminate a lot of wasted effort interviewing people without degrees. Since it's likely HR or recruiting staff, it's likely this will be one of the only ways they can guess at candidate quality. That's not to say people without degrees can't code, it just means that they don't get past most basic requirements for coding jobs. Another common filter is the '5 years experience' hurdle. You can significantly reduce your candidate stack with people more likely to pass your interview by applying both education and experience filters. Additionally, if you don't have a degree expect to get paid much less, not just because of the lack of education but because we know how much harder it is for you to find a job, so we will give you the minimum. Of course none of this applies if you can figure out an alternative way to stand out and make your way to the top of the resume stack. Good luck!
 new JScrollPane(new JTextArea()); I will assume you just like spreading FUD about Swing.
Shit, what are those. First time I hear about them!
OpenJDK is being much faster given the new six month release cadence. It is also being open, as it always has been. “Open” is even in its name! People have made things a lot harder than they should be. Question: Do you want to pay Oracle for Java? If yes, get a subscription. If no, use a ***free*** OpenJDK build.
With the new [six month release cadence](https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence), it is.
I’m not experienced with nodejs, but it seems to have the largest ecosystem of any Async non blocking framework (with maybe Play as second place). This seems to be its greatest value when I think of where it should be used. When you have any app that you know will have high concurrent request counts, but doesn’t need to do anything computation heavy in memory (blocking main thread) then this paradigm really shines since you don’t have threads eating up memory just to wait. Maybe the purest example of this would be if you were to roll your own api gateway (or just thin server layer) in front of some Microservices.
Damn, you git dusted, bro.
Get it done. Don’t quit. Find a tutor if you need one. Make sure you’re not taking too many technical classes at once
the best thing that happened to Android is Flutter.
This is only relevant if you've been a paying customer, right?
Standard edition is/was free, although I think you still need a key to download it.
Same here, I only have a highschool diploma. I went to university, just never graduated. Started on a recommendation from a university classmate and worked my way up from there. Currently enjoying the level of senior software engineer.
I wonder if there any way for Spring to warn about http requests in your own applications. They could probably only do it via `RestTemplate` as Spring doesn't generally manage Apache HttpClient or OkHTTP.
If only there was an article to explain what they are. :P * Single responsibility principle - A class should only have a single responsibility, that is, only changes to one part of the software's specification should be able to affect the specification of the class. * Open–closed principle - "Software entities ... should be open for extension, but closed for modification." * Liskov substitution principle - "Objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program." See also design by contract. * Interface segregation principle - "Many client-specific interfaces are better than one general-purpose interface." * Dependency inversion principle - One should "depend upon abstractions, [not] concretions."
I agree it's important, but I think it's been for all the wrong reasons. Reflection is a wonderful tool, which together with annotations have been used to turn a simple, conceptually clean language into a meta-nightmare (if you use certain frameworks). Case in point, the things a "DI Container" does for you is not only slower than actual (aka "manual" as it's currently known, unfortunately) DI, but also completely does 180 on all of DI's goals and intent to arrive back at what is basically global variables with extra steps.
&gt; Just declare all of your dependencies in your constructor and guess what - you’ve done DI. Well it's the first half of doing DI. Then you can instantiate the object properly, and you've done DI. Or you can autowire it from a container and then it undoes DI, because it turns the constructor arguments into "pick what global variables aka singletons you want me to give you". God I can't stand DI containers. Worst trend in Java development ever.
Fascinating!
It's all explained in the article, along with examples.
What's sad is that many people think HTTPS is a magic bullet for all security problems. Also, hashing/digesting dependencies isn't even the safest way. If the adversary can change the content of the dependency on some host, they can also change the hash/digest that's shown to you to check. The proper way is to have everything signed and also have signature checking in the end user, not just on Maven Central.
There is a fault in the code for "running the application" Sales tax in the SRP explanation: tax.determineTax(); //returns 0.3 Nothing gets done with the returned tax. One would assume that it should be stored somewhere.
I thinks it's just to show how to seperate classes so that it satisfies SRP
oh sh-t!....
Well it's not evolving any faster; we're just getting those features quicker. :P But as you say elsewhere, the speed of evolution in the language is a feature; we don't want half baked changes
Indeed!
There's no licensing issue; Java is 100% GPLed. There's only a question about whether you want paid support or not.
I don't really get the point of even discussing this. He's a kernel programmer. Java doesn't make much sense to use in that space.
Even if it is just for demonstration, the code should be correct. A prerogative of tutorials is that they are correct. Code correctness is important.
Downvote? I'd love to hear a reason.
Well to be fair, the project I'm working on is porting a monolith legacy application that has circular logic. Yes, we have circular dependencies and it's up to the life cycle management of the application to make sure everything works, since the logic is impossible to un circle-ify. But that is unrelated to how we use DI, which we use with global context, singletons (kinda, one per running application window), that were instantiated long before any part of the UI. Thus things like tool items, menu items, dialogs, tables, tabs, etc, all are safe to use this global context, no risk. Now if some newbie decides to inject his random garbage, that's on him.
There are several available. Tim buchalka (if I wrote that correctly) is a good instructor, also has YouTube videos. But if you're expecting quality support for such a low price, you're going to have to find it elsewhere. Fast replies don't necessarily mean quality replies.
Wrong subreddit. /r/learnjava is for such questions The sidebar there has some good suggestions. Personal advice: the MOOC [Object Oriented Programming with Java](http://mooc.fi/en) - free and excellent **Removed**
I do not remember the last time I even got a NPE to be honest, so that null check operators don't sell me. What I do like about kotlin are coroutines
Thanks! Im looking more for ones with good instruction support. Hard to find it in the pinned posts. On a time crunch to learn java dev :/
&gt;Why do you think it is tortuous? because GridBagLayout
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Aion is a public blockchain like Ethereum. Hyperledger is a permissioned blockchain, which is same as using a centralized database since it doesn't have the immutability of a public blockchain. The validators on Hyperledger can basically censor &amp; reversese transactions for your application if they want to, just like how Facebook can block your app.
Except the community asked for this. Before, people paid in a different way, with a search toolbar and field-of-use restrictions. People also pay for .NET, Android and iOS in various ways so they can be funded. Can you think of another way Oracle can fund OpenJDK?
&gt; If the team running OpenJDK team and Oracle provided a professional looking page that explains that OpenJDK is now opensourced and there are many options I agree. &gt; download for major version 12 12 is not a major version, and neither are 11 and 13 for that matter. 9 was the last major Java version ever. The whole point of the new release model is that you can gradually upgrade without having to go through another major upgrade again. We understand that people are confused by the fact that the six-monthly get a new integer number (instead of the original naming scheme [which would have seen 10 named 18.3 and 11 named 18.9](https://mreinhold.org/blog/forward-faster) that was rejected by the community), but it will take some time for people to adjust. &gt; OpenJDK's distribution does not have a LTS model meaning you'll have to upgrade every 6 months You need to upgrade your JDK every couple of months to a new version if you want to stay secure whether you're on LTS or not. What has changed is that an integer-numbered release is not much more disruptive than a patch release, and the upgrade model that is offered freely by Oracle is the recommended and easier one. Again, it will take some time for people to adjust. If you can't keep up -- whether you're on LTS or not -- that's not the end of the world; upgrade at your own pace. You can go from 11 to 13 just as people went from 8 to 8u40. &gt; the download is only a zip and not an installer We may have an installer but it's a feature that the JDK does not need one. All you need is to point `JAVA_HOME` to it and you're done. The JDK is intended for developers, who should create their custom user-facing runtimes. We are working on [a tool](https://openjdk.java.net/jeps/343) that lets developers easily create installers for their applications ([early access here](http://jdk.java.net/jpackage/)). &gt; that doesn't require major version updates and the subsequent testing required (and subsequent backup plan if the testing fails) every 6 months. Oracle is providing a business-ready solution that doesn't require a major upgrade *ever again*. As I said [elsewhere](https://www.reddit.com/r/java/comments/ba79hh/beware_of_computation_in_static_initializer_much/ekb4s3s/), you absolutely must perform full regression tests with every Java release, whether it's an LTS patch or any feature version, as the probability of a feature version breaking your code is not significantly higher, if at all, than a patch. And if you used to get lucky without tests when going from 8 to 8u40 -- which was a significant jump -- you can get lucky going from 11 to 13. There is a messaging problem, but you should also understand that there has been a significant change to how Java is delivered, and it will take some time for it to sink in. The old release model is gone, and in its stead people need to choose one of two brand-new upgrade models. One that is free and gradual, and should be significantly cheaper than the old one, of upgrading to the recent JDK version, and another that is paid (or provided by companies other than Oracle), is significantly *less* gradual than the old model, and is suggested for companies who would rather not pick the gradual path and prefer a big upgrade (bigger than before) every few years. We think the new model is much better: the JDK is open source and there is a modern, more gradual and cheaper upgrade path, as well as a new funding mechanism that we think people prefer over search toolbars and field-of-use restriction. But regardless of messaging, making a change of this magnitude to a community this large takes some adjustment.
The fact that Swing is not developed anymore means it is effectively killed. No one is going to base an application on a framework that will not get updates. I really hope that someone picks up the torch and keeps Swing relevant.
UI toolkit without a multitouch support is not going to fly (Swing). JavaFX is not dead, but one could think it is in limbo after Oracle stopped maintaining it.
I've been toying with flutter recently and the hot reload is dope. Although I'm still getting used to dart (mixins, future, factory, the weird syntactic sugar, etc...), I can't imagine being as productive using java or kotlin.
Since this comment has been upvoted I'd like to understand your justification for it. I write blog posts that talk about the changes to Java, both from a technical and distribution perspective. Since I work for Azul, I obviously mention that we provide a range of JDKs; both free and commercial. I try to ensure that I provide correct information to help developers understand what is going on. Being on the JCP EC and Java SE expert group as well as having worked for both Sun and Oracle gives me, I hope, a good view of the Java ecosystem. In this post, I only mention Azul once and make it clear that there are other options, "There are several providers (including Azul) making older versions of the JDK available with updates either free or with paid commercial support". Could you explain how my posts are making the situation worse?
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Swing can be horrible if one doesn't grasp the MVC model. It doesn't help that most examples out there are piss poor implementations. JTreeModel and JTableModel with CellRenderers are absolutely joy to work with. Componets are easily customized and JGoodies Forms or MigLayout are absolutely killer implementations of dynamic form layout engines.
Many artefacts published on Maven Central do have pgp signatures, but as far as I'm aware neither Maven or Gradle check these. Additionally, to be truly useful, everyone that publishes artefacts needs to be in a web of trust.
Yea I know that, (I think) I can read. But it doesn't change anything about the impression, that such primary constructors would likely be only allowed for records, no other classes or am I missing something. And special init constructs only for records. So for me, it doesn't fit too nicely into the language, that's all.
pfff...who needs them when you have if statements
"JAVA CONTINUES TO EVOLVE", did someone get inspired by playing Plague Inc?😂
This is my take, as well. Java is absolutely, undeniably, an extremely capable language. While there are probably some niche cases, you can do anything in Java that you’d care to do in C# and vice versa — especially when you talk about what a “corporate developer” does. The syntax is so close, too. But, Java just feels so much “heavier”. The syntax, itself if a bit more primitive and the overall ecosystem (maybe not the right word) is cumbersome. The way I’ve explained it is that, if I want to make a chair, Java makes me go cut down the tree. That leads to better understanding of some things (don’t ask most C# developers about setting up a reverse proxy), but isn’t great for mean productivity or just enjoyable coding. Oracle being an unpleasant company to do business with is something of icing on the cake. I try to avoid anything they do because they are such asses. Yes, I know MS has a history, too, but they’ve largely fixed their culture. I’d rather work with Java than, say, Ruby on Rails, PHP, or a number of other languages, but it has no “wow, cool” factor.
I'm the author of the article: Neither Maven nor Gradle checks the GPG signatures.
I appreciate you coming in here to respond. Those are pretty decent answers to most of my gripes.
Author here: The signing isn't good enough, you also need some sort of tie between identity and the namespace of the artifact. For example, anyone operating a MITM could sign the artifact as "John Smith" and a naive implementation would say "Yep, it's signed! We're good!"
I know right?!
 &gt;"Yep, it's signed! We're good!" That's not how proper signature verification works though. It's not just whether there's a valid signature, it's whether the signature is by the correct person for the correct data.
GridBagLayout was not meant for humans, it was intended for GUI builders. BorderLayout with nested panels using BoxLayout is all you need.
Hi /r/java! We’re very pleased to announce the release of Javalin 3.0. The most important changes are: * Support for OpenAPI (Swagger) with Swagger UI and ReDoc * Re-implementation and simplification of WebSocket API (`wsBefore`, `wsAfter`, `wsException`) * Complete rework of configuration * Improved support for running Javalin on a non Jetty servlet container A huge thanks to Tobias Walle ([GitHub profile](https://github.com/TobiasWalle)) who contributed 99% of the OpenAPI implementation, as well as all the other people who have contributed to the release. If you want to get involved, please head on over to https://github.com/tipsy/javalin
Good
There is a maven plugin, but no one uses it and not everything is signed and there's no web of trust between publishers.
There are no systems in place in the ecosystem currently to verify that the right person has signed the right JAR file. At least as far as I'm aware. If you know of some existing infrastructure please let me know.
I would love if maven gave you the possibility to specify some sort of trust anchor on dependencies. For example specify the gpg-key the artifact should be signed with, or the sha1/md5 of the artifact (even if those to algorithms are broken they are better than nothing). I commited a bit to a plugin for maven that verified the gpg-signature, but since plugins are distributed through the same channels, it's easy to MITM the plugin also if you want to MITM something.
Many artefacts are PGP signed. These are the .asc files you see next to the jars. Unfortunately, I don't believe there's a correct web of trust between publishers to prove that the PGP key belongs to who they say it does. In Debian, for example, you need at least two other Debian developers to verify and sign your key before you can become a Debian Maintainer and upload to the archive. This means meeting them in person and checking government issued ID. That's the level of verification that Maven Central should require.
Sometimes the customer requires that 'all persons working on a project need to have proper educational qualifications'. Rare but it happens. Luckily we have people with proper degrees to show as front and the customer will never know that almost the whole application (that they really like) was designed and written by someone without any kind of degree at all and the qualified persons are mostly doing configuration and installation / setup work. ;-)
And also, if you have the capability to MITM jar's, then you also have the capability to MITM the plugin jar. This functionality needs to be in core maven and not as a plugin. Sadly the maven developer community isn't very receptive to these kind of suggestion (in my experience at least).
Yes you absolutely can. Big corporations and public entities tend to prefer formal education, but for smaller companies that is not an issue. At all. It could be different there in the States but here in Finland we have a huge shortage of qualified programmers and companies are basically competing for coders and offering all kinds of benefits.
There're so many nice use cases for reflection that I find it perplexing how much some people seem to hate it. One example that I have used is a class with contains fixed values, a classic HUMAN\_READABLE\_VARIABLE to ID container that allows to referring to certain fixed objects with variables bound to int values. We have reserved 'different spaces' for different subsets and the class contains hundreds of these mappings. To ensure there are no duplicates I have created a simple test method that uses reflection to loop through all class variables and make sure there're no duplicates with values. This feature is then used with automated testing environment, e.g. all classes that have the same kind of 'built in' test feature are automatically checked for errors.
It's nice to see them taking action immediately. I also like how they encourage others to do so also. I switched my blog over to full https this year and I'm ashamed that I didn't do it sooner.
&gt; Java is not the problem but all the hardware classes that are part of the computer science program are pissing me off. It's worth it to power through. Most of us hated certain classes or struggled in others. Just remember: C's get degrees.
Absolutely, it's a 'last resort' thing
Can we assume that the library exists and imports successfully? `import lombok.Getter;`
You must enable annotation processing on Settings.
no, lombok as a symbol isn't being recognized
It is just like any other library, it must exist. Not that it requires Maven/Gradle, the jar just needs to be in the classpath.
You need to declare it as a dependency in your build tool, so that it downloads the jar from maven central. maven : add below &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.8&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; gradle : see https://projectlombok.org/setup/gradle
I'm not using a build tool. Do I need to?
How do I add it to the classpath, after downloading the file? I see the classpath currently set up to my jdk.
It does not require a build tool to work, it hooks into the javac stages to work. However, you should use a build tool if you can. It'll make your life easier.
Got it, its definitely something I'm planning on tackling.
I don't typically do that; I mainly use Maven. I think there is a way to do that in IntelliJ though, in the Project Structure dialog.
Figured it out. Thanks so much!
If you're working with libraries, you'd be silly not to.
Lombok is very special because it works with annotation preprocessing inside the compiler. It is not sure how long this will be supported. To get it work you have to set up compiler annotation preprocessing (I think somewhere under settings / build tools / compiler). Everyone who wants to use your code has either set it up or you have to „delombock“ everything but then the advantage of Lombok is gone. In my opinion Lombok addresses issues which are bad design in Java (equals, hashcode, getter, setter etc. ) and needs to be fixed in Java. I would really think whether you can skip Lombok or use a language like Kotlin which solves many Deign problems of Java (and still runs on the JVM)
I know maven/gradle/whatever can seem daunting and confusing at first, and they are, but they are worth the extra overhead in the long run. I can guarantee any serious dev team will be using a build tool of some sort, the sooner you learn it the better.
/r/kotlin
Looks good. Might have to try it instead of defaulting to spring boot all the time
File &gt; Settings &gt; Build, Execution, Deployment &gt; Compiler &gt; Annotation Processors &gt; Enable annoation processing
I think 1. is the better approach. As an alternative you could also create the website by simply serving static html with little JavaScript (-&gt; SSA). With templates such as Rocker, Pepple, Mustache or Thymeleaf. Then there's also JSP or Vaadin with different approaches.
Wait. What are *those*?
Thanks, don't hesitate to reach out on GitHub if you have any issues or questions!
I wonder how other ecosystems like .NET do?
When writing this article I was actually thinking about this. I don't know enough about .NET to have explored their package manager logic or audit repositories, but I 100% support research in this area. I highly recommend everyone reach out to the most popular artifact hosts in all languages and request that they consider dropping support for HTTP by 2020.
&gt; or the sha1/md5 of the artifact I'm about to join Gradle Inc. and this is something I plan to push for. Going to use SHA-256 though. SHA-1 only costs \~$100,000 to perform a second pre-image attack against with today's hardware.
I think my favorite line is "Open source is 'free' as in 'free puppy'". The puppy may be free, but it needs lots of love and care by the people who adopt it. That being said, this is something I absolutely want to push forward. I'll be trying to push for it internally while working for Gradle Inc.
&gt;In Debian, for example, you need at least two other Debian developers to verify and sign your key before you can become a Debian Maintainer and upload to the archive. Unfortunately, since Java is the most used programing language in the industry (according to the Tiobe index), I highly doubt that this will ever happen. There's no way that we can restrict authors this much. Some sort of happy medium needs to be reached. &amp;#x200B; There are other issues we also need to iron out, like namespace takeovers. We saw the first actual attack against the Android ecosystem last year. Namespace takeovers are arguably a far more realistic attack vector than a widespread MITM. [https://blog.autsoft.hu/a-confusing-dependency/](https://blog.autsoft.hu/a-confusing-dependency/)
&gt; Everyone who wants to use your code has either set it up or you have to „delombock“ everything but then the advantage of Lombok is gone. The lombok annotation processor should be setup in the build tool i.e either gradle or maven. Then the IDE should just delegate the build process to the build tool. Then each developer doesn't need setup the IDE for annotation processing.
So do you recommend *Rocker, Pepple, Mustache or Thymeleaf* or *angular* ?
Any plans for supporting other languages?
Yes, I have a plan to build a static analysis for Kotlin. What languages are you interested in using?
Not much. Because I'll pay for machines on digital ocean, so it costs me. I'm looking at around 4-6 cores
Good luck, i hope that you succeed :) If i would dream about a system, it would be one where the crypto mechanism is plugable, so that the system can be fault tolerant when/if the current algorithm breaks.
Slides available \[here\]( [https://speakerdeck.com/maciejwalkowiak/the-state-of-java-relational-persistence](https://speakerdeck.com/maciejwalkowiak/the-state-of-java-relational-persistence)).
We are 100% keeping this in mind.
Seeing that Oracle has recently made the JDK 100% free and open source, as opposed to the old mixed free/commercial JDK we had before, any risk of that has been eliminated. But completely open sourcing the JDK has consequences, like the proliferation of builds, just as we see on Linux.
C# and TypeScript. All are statically typed ones 🙂 P.S. Awesome project. Should be very useful for sure!
AFAIK, [JavaFX is heavily maintained](https://openjfx.io/), including by [Oracle employees](http://hg.openjdk.java.net/openjfx/jfx-dev/rt). Oracle has reduced its investment in the client, but OpenJDK is open, and companies like Gluon contribute a lot to JavaFX, just as companies like Google contribute to areas of the JDK they care about.
&gt; any risk of that has been eliminated Their lawsuits against Google over the API's suggests that Oracle may find unanticipated ways to create risk. Their JDK change may have reduced some types of risk, but not all. &gt; open sourcing the JDK has consequences, like the proliferation of builds, just as we see on Linux. True. Trade-offs.
&gt; Their lawsuits against Google over the API's That's preposterous. Google has been heavily using and contributing to OpenJDK throughout their court case (here they are speaking about it *at Oracle* in [2013](https://video.oracle.com/detail/videos/featured-videos/video/2630310903001) and [2014](https://video.oracle.com/detail/videos/featured-videos/video/3731062156001), at the height of the lawsuit). The lawsuit had absolutely nothing to do with OpenJDK or Google's use of Java. Android's copying of Java's API has been extraordinary and unprecedented (regardless of your opinion on the merits of the case), which has played [a significant role in the court's ruling](https://en.wikipedia.org/wiki/Oracle_America,_Inc._v._Google,_Inc.#Appeals_Court_and_finding_of_non-fair-use), and any extrapolation from that case to any company using the JDK is just ridiculous.
C's get degrees, indeed! LOL. I've sat on interview committees and candidate screenings. Fewer and fewer candidates (a) include their GPAs, and (b) have at least a bachelor's degree in CS. Some interesting smart folks who we've hired or that I've worked alongside: a JD (lawyer) who coded Java, an accountant who did Cloud migrations, and indeed an Oracle Certified Professional w/ a BS in CS :) +1 to others above who recommend building a portfolio of work. You can do that through: GitHub Resume: https://github.com/resume/resume.github.com HackerRank: https://www.hackerrank.com/dashboard
Hey! How does this compare to [https://github.com/ngallagher/simpleframework](https://github.com/ngallagher/simpleframework) ? &amp;#x200B; I've been very pleased with Simple (been using it for over 13 years.) but it's not exactly thriving anymore.
&gt; There are no systems in place in the ecosystem currently to verify that the right person has signed the right JAR file. That is just not true. The folks who actually host Maven Central, so Sonatype, talk about this problem all the time. (They call it "software supply chain security"). But they are commercial and so have a paid offering around it. This $subject is as old as computers. Locking down chains-of-trust since way back when (DNSec, IPSec, CA Auth, etc.). What always happens is the solution boils down to needing a central authority (in CA speak) that "blesses" the root (in DNS speak). And the backlash comes from paranoid / smart folks who say such a central authority will become Big Brother. It analogous to how Americans don't want a national ID.
It depends on what you intend to do with your website and what you fancy doing. Server Side Rendering gets you far, especially for CRUD applications. It generally has great performance. Also that way you have no need for a parallel setup. With Angular you have more flexibility when you need the site to be more dynamic. There's more content (libs, how-tos, themes...) to reuse because the whole ecosystem is web ui centric.
The open closed principle has evolved and I'd like to mention that there's a best practice out there for years now stating "favor composition over inheritance". Meaning that the fields of the base class can be an object on their own and used by the different report engines. Most important for a good architecture is a good dependency management. Loose coupling is basically the opposite of a plate of spaghetti. Functional Inheritance is the strongest form of coupling available, that is spaghetti without oil or plain and simple glue. For a more modern version of the open closed principle read https://www.cs.duke.edu/courses/fall07/cps108/papers/ocp.pdf
This is pretty cool. Good job.
Cut my life into pieces! :)
I've never heard about that framework. I'm guessing it hasn't been promoted much the past ten years? I had a very (very) quick look at the examples, and simpleframework looks a bit low level compared. Javalin is Servlet based, and leans on Jetty to do the heavy lifting. I made it primarily to provide a great developer experience, performance is secondary (although, since Jetty does everything, performance is still great).
&gt;"Open source is 'free' as in 'free puppy'". The puppy may be free, but it needs lots of love and care by the people who adopt it. Stealing that one! :)
I'd recommend a web service endpoint (httpmate would be clean and simple: https://blog.envimate.com/httpmate-intro ) and a react based website that communicates with Ajax or websockes with that endpoint. Also, just to be safe, if you allow the execution of plain sql, make damn sure that only those users, who you deem trustworthy, have access to the application. Either by physical security, VPN controlled access or a more simple authentication mechanism like jwt tokens or basic auth. Note that this list is ordered descending by safety.
&gt; [...] serialization extracts object state and recreates objects via privileged, extralinguistic mechanisms, bypassing constructors and ignoring class and field accessibility [...] The compiler won't help you. [...] Magic methods and fields. [...] Makes a mockery of encapsulation. [...] Readers cannot verify correctness merely by reading the code. It's interesting those are being recognized as a problem. Are people aware that DI containers do a lot of that (not all, but most) as well? This is why I've never used Java's serialization features. I have my own interface an object can implement and convert itself to a data tree (think like JSON, but as an object tree), which can then be serialized via a generic recursive walk.
&gt;I wonder how other ecosystems like .NET do? &amp;#x200B; Happened to NPM, with a huge user base. That was the one where the rogue committer socially engineered the trusted maintainer. Well, I say "socially engineered" despite the industry usually reserving that term for lazy email users but IMO we've been too polite about the maintainer not reviewing the code better and "trusting" the rogue committer. The same term should be used. Whether techie brainiac or lazy email user, we are all social creatures. &amp;#x200B; [https://hacknews.co/malware/20181127/rogue-developer-infects-widely-used-nodejs-module-to-steal-bitcoins.html](https://hacknews.co/malware/20181127/rogue-developer-infects-widely-used-nodejs-module-to-steal-bitcoins.html)
You can do that even without CS degree or certificates, but you must build up reputation and knowledge to prove you know your stuff. I've studied Japanese language and got into programming very late, long after I've graduated. I have two certificates, one is Japanese Language Proficiency Level 1 and the other is OCA for Java 8, which I did only after working as a coder for few years. It's always nice to see recruiter WTF faces when they review my resume for certificates 😃.
&gt; So I can choose 1 of 10+ different OpenJDK distributions, but how do I know it will be supported long term and patched quickly. You ask a commercial vendor. Using the term "support" in the context of upstream / community is overloading the term. What exactly is community support? A bump in a stale thread with the subject line of "HELP: Prod down?!" :) Support, IMO, needs some contractual obligations (SLAs, EOL dates, etc.). There are several Java vendors. The OP was about Azul, who is one such vendor. The others are Oracle, Red Hat, and IBM. If you like, add AWS to that vendor list, though I'm suspicious of what kind of support you'll really get from them.
I've been using it recently to build a simple web app for fun and it's really great how easy it was for me to get everything set up. Thank you for your work.
To be honest that killed JavaFX interest. If something happens to Gluon, JavaFX is dead. I always though that desktop Java suffered from Sun not understanding what the desktop stack is all about. And I say this as owner from "Filthy Rich Clients".
Looks great indeed. Will check it out later too. Too bad about the annotations though. I like them ;P
Happy to hear that, thanks!
The problem is that Maven Central isn't the only artifact host developers use. Now there's JCenter (from JFrog) which is far easier to publish to and doesn't require PGP signatures. Then [JitPack](https://jitpack.io/) came along and said, "Why create an account at all?! We'll just publish the source directly from having built your GitHub repository from source on our infrastructure". Now GitHub is coming along with the [GitHub Package Registry](https://github.com/features/package-registry) and further increasing the attack surface. I'm not saying GitHub isn't going to do a nice job keeping the ecosystem secure, but any increase in attack surface is an increase in attack surface. Unfortunately, it's the simplest solution that's what's going to end up winning (have the most users), so we need to convince those that decide to host this infrastructure for artifacts that these sorts of security checks are important. &gt; users have a tendency to continue downloading dependencies that are known to have vulnerabilities This is 100% something that we need to figure out a solution for. NPM has a good solution around alerting users when they do `npm install` that they have X number of vulnerable dependencies and providing a quick way to resolve them. Additionally, GitHub providing alerts about vulnerable dependencies is incredibly powerful and will help the JS community. We need to get the same infrastructure in place for Gradle and other popular JVM dependency management engines.
&gt; It's a bit kludgy for right now What do you think it can improve on out of curiosity? I want to start a project and I'm currently evaluating micronaut and ktor.
First option is better, more organized, clean, with freedom to do cool stuff for user interface and not slow at all (unless your frontend is deployed in a server in one country and the Java backend in another then you will have a big network latency). About the second option, you don't need a new project... Before the existence and popularity of these frameworks such as Spring Boot and Angular we used to build a single Java web project serving the http responses to a JSP (Java server Pages) or JSF (Java server faces) configured through .xml inside the same project.
Smart thinking
https://openjdk.java.net/jeps/154
Well but that's exactly the problem with public interest. If "something happens to Gluon" and others don't pick it up (although, again, Oracle is still contributing to JavaFX) that only means there isn't sufficient interest and that Oracle has been right to make it a low priority all along. Sure, you can try and swing for the fences -- again -- but with the browser being so dominant that seems like an unnecessary risk.
Thank you. I hope this can help many people work faster :)
Thank you. If you have Java repo that you read and review code often and would like to have that repo indexed, please don't hesitate to let me know
Type erasure was a great decision in retrospect, and reification has been a *huge* mistake for CLR. They got some slight added convenience in C# at the cost of having virtually no interop among CLR languages, and the platform becoming unattractive as a language target. Retfied generics (for reference types) bakes a particular variance model into the platform, and means that languages must either conform with it, not be able to share code and data, or incur high interop runtime costs. Java, Kotlin and Clojure all have very different variance model, and they can all share code and data thanks to erased generics.
Surely, but due to the passivity regarding desktop Java, WPF/UWP, Cocoa, Android J^++ and Qt are what matters nowadays regarding native UIs consulting projects. I remember Java3D, Java IO, Java Desktop, JOGL and a myriad of other desktop related projects that eventually died.
Mainly web based applications
Yeah, I remember them fondly, too, and, BTW, some are still used; there was just a talk recently about a [JavaFX-based tool used by NASA](https://www.infoq.com/presentations/java-science-aerospace/) (and I still use JOGL for personal projects). But in this case, the difference between "sometimes used" and "what matters" is not big enough to make a difference. No one seems to care deeply enough about desktop except games and that's a whole other matter.
I don't doubt that they can engineer a better solution, but I'd be curious what kind of timeline they'd attempt it in. There may be a _lot_ of Java apps that don't use serialization (or use default serialization behavior that would transparently migrate to the new approach), but I imagine there's plenty of enterprise-y and/or legacy JEE applications that rely on the last 20 years of behavior.
Small nit, OpenAPI 3.0 is not Swagger. Only Swagger 2.0 and OpenAPI 2.0 were the same, as the specification transitioned from SmartBear to OAI under the Linux Foundation.
You know, it was an April fools day joke?
As everything with Java, you'd have both solution side by side for maybe over a decade. The new solution is more a "mea culpa" and "here's how you do it" in my eyes, than something you need to wait for in order to do it right. In fact I'm a bit confused why we need this brand new "pattern" syntax, it seems off. Honestly Java already provides us with everything we need in order to do it right. Everyone can implement a basic Visitor pattern to walk objects and serialize them with full control of the objects. It just takes a bit of insight and a bit more effort than falling to defaults. If you implement your own solution, the adapter you'd need to transparently switch to Java's native new solution would likely be very small.
Try r/javahelp
The new approach to this in the current Java release cycle is that you'd keep running your stuff in a VM that supports it while the new JDKs can wave you bye bye and move forward at full speed. There is a reason why the document boldly and openly states: "we can get this over and done with and drop the old serialization mechanism in as little as 18 months" (even if that's a bit optimistic). The thing is, I've read recently that 1 in 3 security issues in Java target the serialization mechanisms. It's been holding Java back immensely and they want to drop it like a hot potato, as soon as possible. In all likelihood, they were only waiting for pattern matching to be done first to then tackle this. I have seen a talk by an OpenJDK developer recently that went as far to say, in passing, that serialization was one of the two blatantly stupid and shameful design decisions in Java. Since it's becoming increasingly easy to support different JDKs running together, with virtualization and container technology, without having to even touch Java code to get it done, my guess is that the approach by the OpenJDK team is going to be "use your old JDKs until you can update your old code yourself - if you can't, then just keep using your old JDK forever, see if we care". As with other recent updates to the core Java language, it's going to sting, but it's for the better and you can definitely see the reason why it needs to be done. Not only it's a benefit for your own code (and security!) but it's going to free the internal development to be that much more ambitions and faster. The people who have Java code running for decades that absolutely no one will touch anymore (and often with good reason) are going to have to setup themselves to keep running old JVMs forever ¯\\\_(ツ)\_/¯
I have only one practical question, if anyone would care to take a guess: what does the acyclical and data-only serialization model would mean for my typical use case, where I have a tree-like graph of objects that could, some of them, refer to their parent nodes or the root node? If the new serialization model wouldn't handle that as it does today perfectly, it sounds like a big issue for developers to have to deal with themselves on a case-by-case basis (especially when they can count on the JDK to do that today). I understand that even today the serialization mechanism won't handle every cyclical referencing scheme and that the new mechanism is going to cover even less of them, but being able to have some self-references in an object graph would surely be a goal for any serious serialization model in 2019, let alone one built into Java itself and supposed to replace the older one, which they could be throwing away in the latest JDKs as early as in 18 months, as per the article? Any feedback on to what extent this should be possible would be appreciated, since the article doesn't go into any lengths about it. Now that I think of it, there aren't any examples on the article that references serializing a graph... Should I be worried or should support for serializing graphs to a basic extent still be possible with the new approach?
Fyi I don't use chrome as my main browser
You can make games in Java: https://www.youtube.com/watch?v=51IJbqyaUp0 Check out Unity as well (it's in C#, which is quite similar to Java).
So Java will not be the new Cobol for too long
I have plan to support other browsers. Supporting firefox will be straightforward as code can be shared. Do you have a repo in mind that you might want to use Lilit on?
If you believe the design of serialization by breaking encapsulation etc. is "shameful", I wonder what you think about autowiring DI containers.
It doesn't need to be "as productive using java or kotlin", because you need two code bases for the same app if you want to reach android and ios
The `pattern` syntax is not part of this JEP, but it's from the pattern matching feature that they've been working on for the last few years.
The only thing remotely in common with DI containers is the long discouraged field autowiring that uses reflection to set the fields, ignoring visibility. Constructor autowiring has been the preferred method in Spring for the best part of a decade.
There are more similarities. Constructor autowiring is also making a lot of assumptions, match-making dependencies based on type etc. But OK.
The assumption being that if you only have one object of that type, that's the one you want. That's not a very big assumption. If you have more than one object of that type, you need to explicitly say which one you want.
&gt; Impact: Twitter: High 😂
Nope JDBC
2-1 laptops, tablets and phones are desktops as well, specially the models that plug into screens. I have spent the last four years doing greenfield development in WPF/UWP, while maintaining some brownfield Swing applications on the side. There is plenty of new development to be done on the technologies I mentioned. For each NASA presentation, you have companies like VW stating why they gave up on JavaFX and went with Qt instead.
Honest question: why not deprecate it without an officially sanctioned replacement baked into the language and the runtime? Like the man said, &gt; There is a veritable cottage industry of libraries that are either intended as serialization "replacements", or that are valid alternatives to serialization for some use cases (an incomplete list: Arrow, Avro, Bert, Blixter, Bond, Capn Proto, CBOR, Colfer, Elsa, Externalizor, FlatBuffers, FST, GemFire PDX, Gson, Hessian, Ion, Jackson, JBoss Marshaling, JSON.simple, Kryo, Kudu, Lightning, MessagePack, Okapi, ORC, Paranoid, Parcelable, Parquet, POF, Portable, Protocol Buffers, Protostuff, Quickser, ReflecT, Seren, Serial, Simple, Simple Binary Encoding, SnakeYAML, Stephenerialization, Thrift, TinySerializer, travny, Verjson, Wobly, Xson, XStream, YamlBeans, and surely more).
Micronaut by itself seems pretty nice. I meant specifically the interaction with Graal native binary generation. A basic hello world app works fine, but you can see there are still [tons of issues](https://github.com/oracle/graal/issues?utf8=%E2%9C%93&amp;q=is%3Aissue+is%3Aopen+micronaut) that need to be ironed out when combining the two.
Any plans to support gitlab?
You would also have to solve this problem if you wanted to expose your model over a JSON or SOAP web service. As the article says &gt; For example, many modern services are built around exchanging JSON documents --- which cannot even represent the notion of object identity! The fact that JSON is considered a viable encoding strategy for nearly all services underscores the fact that Java serialization is solving a much harder problem than it actually needs to. So instead of MyType parent; You would need to have String id; String parentId; You would then need additional traversal methods or would have to map these web service classes to you internal model. I would assume that in an ecosystem of long-lived (in the sense that the applications are in use and maintained for years or decades) applications talking to each other, which I think is a large part of enterprise Java development, there is a lot of mapping between representations of the same entity for versioning and decoupling reasons.
Wow,it's sound great, there is a option to join to you and try develop that? I'm interesting on writing java project to learn more about this language
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Ardor has actually let you write Smart Contracts in Java for a long while (https://ardornxt.io/deploy-your-first-ardor-lightweight-contract/). AionVM is certainly not the first to do this.
Ok, thanks for clarification. It seems perhaps Undertow or even Netty could be used to replace Simple and there's always embedded Jetty option.
Unless I missed something, he is only suggesting throwing away the old serialization forms of jdk classes, not the concept of readObject altogether.
DI containers do not generally do that to the extent java serialization does. Yes, DI containers use reflection, but brian goetz is referring to apis like unsafes object creation. DI containers also don't always touch private fields, so they do not necessarily break encapsulation. And finally, they are usually annotation-based like this proposal, not based on magic method names.
Creating a viable, compatible replacement is better than just dropping it altogether.
I'm not sure if I missed it in skimming this, but what about parameter names? In this proposal the "destructor" and "constructor" do not expose variable names (except with debug flags) so serialization libraries for other formats like json would be unable to take advantage of this.
What was the other stupid decision?
Re~~posting~~ spamming your very same submission [from two weeks ago](https://old.reddit.com/r/java/comments/bujyyp/java_web_service_bootcamp_2019_from_beginner_to/), eh? That's totally not spamming your videos across Reddit, right? https://imgur.com/IJx3df1
It is pretty common you add @Autowired to a private field even without a constructor. Forcing you to use reflection to be able to properly instance that class (handle by your DI runtime, normally). Thankfully, it looks like constructor injection is getting much better support now days.
You should really bite the bullet and just learn to use Maven. Doing dependency management / .jar building by hand is a huge pain.
Wow, cool idea! Is the code of lilit opensource by any chance?
Can I use this with Perforce version control? We are using it to maintain our Java code and also looking out for a good tool to review code entered by team members.. Do let me know. Thank you Rakesh
That's been discouraged in Spring for around a decade. Constructor autowiring is the preferred approach.
&gt; There is plenty of new development to be done on the technologies I mentioned. I totally agree. It's just not enough to justify a large investment at the expense of other areas. But if anyone is interested to contribute to JavaFX or Swing beyond what Oracle and Gluon are doing, they are more than welcome.
To be honest I fail to see anything that would make it a *better* serialization. This proposal is simply enforcement of implementing *writeReplace()/readResolve()* pair (aka classic memento pattern) with some syntactic sugar on top. And while it might make serialization more secure (which I doubt - see below) it is not *better* for sure as it forces developers to do more work. The whole premise of Java serialization was that it is supposed to be transparent and cheap to implement. It is rooted in Smalltalk/Self and the idea of a program image and transparent state migration. Why are we giving this up? A *better* serialization should be simply a better implementation of this idea - what we have here is retraction instead. What's more - it does not really address security concerns! Even the example of non-serializable *ServerConnection* being recreated based on *serverName* upon deserialization illustrates it - *serverName* is not sanitized/validated and as such is a security hole (as may lead to for example information leak). The issue here is that we try to fix security issues in the wrong place. Almost all security issues with serialization are not really caused by serialization itself but by: * huge classpath with all libraries accessible to each other (ie. deserialization gadgets availability in classpath) * running applications with no *SecurityManager* (starting a JVM with no *SecurityManager* a default was the single biggest mistake Java designers made in the past IMHO) There are issues with current serialization but IMHO they can be fixed with small adjustments to the spec/API: * Add an *@Unshared* annotation on a member field - that would signal requirement for the deserialization framework to make sure the instance is unshared * Use *ObjectInput/ObjectOutput* interface everywhere instead of *ObjectInputStream/ObjectOutputStream* classes * Provide easy way to register invariants validation (right now registering *ObjectInputValidation* is a PITA) - it can be done by introducing *@InvariantCheck* annotation or similar. * Provide a way to designate a constructor or a static method as a deserialization facility * Make use of *ObjectInputStream.GetField/ObjectOutputStream.PutField* interfaces easier/more obvious My point here is - current serialization offers a lot and getting rid of it instead of making it better is a huge step back.
&gt; There is a reason why the document boldly and openly states: "we can get this over and done with and drop the old serialization mechanism in as little as 18 months" It says, "legacy serialization can be phased out of *JDK classes* in as little as 18 months." Not the mechanism, but serializable classes in the JDK. &gt; my guess is that the approach by the OpenJDK team is going to be "use your old JDKs until you can update your old code yourself - if you can't, then just keep using your old JDK forever, see if we care". I very much doubt that. It's one thing to drop some methods or classes that nobody uses and a whole other thing to drop a heavily used feature. Backward compatibility is a high priority for Java. The old mechanism could be deprecated but I don’t see it being removed any time soon.
The test containers stuff looks interesting if it means I can replace hsqldb with a production database.
Why does everyone repeat that mantra around a decade? Do you want shitty 30 arg constructor or 30 private `@Autowired`? In business code I assume every service is just available from global configuration scope. I don't care about academic architectural purity, who pays money for encapsulation if you aren't library/framework dev?
It looks like in your [submission](https://www.reddit.com/r/java/comments/bzp111/why_php_scripting_language_is_used_by_most_web/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
If your class requires 30 hard dependencies, that's your problem right there.
If you have 30 dependencies, you might want to rethink your design. That a constructor forces you to think against many dependencies is just one of the reasons why it's the preferred method.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I can't figure out why one would use this. What's the use case? What kind of applications are helped by using this tool box?
Generally speaking web services in general, web applications and specifically those using micro services, which is probably a good 70% of all applications out there which are current being created.
With current Spring, you can just leave out the @Autowired annotation in your constructor, making it look much cleaner. Just pop an @Component or @Service on top and you're good to go.
Does anyone use the inbuilt Java serialisation anymore? I've honestly not seen it used anywhere, people always seem to just use one of the many libraries mentioned in the post. That said whilst the 'magic' of reflection makes these libraries have low entry barriers, maybe we should accept the extra leg work and utilise features like '@JsonCreator' for Jackson.
Thank you!
I struggled with this a few weeks ago. Turns out that the java keytool stores the alias in lowercase. The alias name I was using was all in upper case.
I just have to point out this article (just currently surfaced on this sub) [http://cr.openjdk.java.net/\~briangoetz/amber/serialization.html](http://cr.openjdk.java.net/~briangoetz/amber/serialization.html) &amp;#x200B; Getting rid of the RMI and implementing custom serialization is starting to look better day by day. Anyone who is going to take a look at that custom implementation is going to have a much, much simpler time than with dealing with the pitfalls of RMI and default java Serialization.
I have been trying to remember since yesterday but *I think* it's somewhere in this video, if you want to give it a watch (and maybe report it back here) :) https://www.youtube.com/watch?v=kpio9jFhpD8&amp;list=LLsw2O1KwUji4k9Elo2q0D1A Also I might have gone overboard in saying that the speaker said the two were a "stupid" decision, but that's still the gist of it, if not literal.
&gt; You would need to have That just plain sucks though because in that case the convenience of using Java serialization is entirely thrown out the window (at least for me). As you've said, there are enough ways of persisting and transmitting data (JSON, XML, YAML, etc), the beauty of Java serialization was that is was mostly transparent in putting everything as-is and getting it back again. I am completely for persisting only data and making all the language mechanisms explicit but having the ability to persist an entire complex graph at once is extremely valuable and definitely one of the only reasons in a shrinking list of features that make me stick with Java and not some slicker, more modern language. It's neither a security issue in itself nor something that cannot be done (since it's being done with the current serialization anyways) so I don't see why we would have to give that benefit away in the newer version. I can only hope that they will come around regarding this because it's a big deal for me. I mean, what's even the point, as an end-user, of using the new Java serialization if it's not going to be in any way more powerful than what existing libraries already accomplish? Legit question.
&gt; Backward compatibility is a high priority for Java Serialization has been a major burden for Java for very long now and basically the champion in security issues. It is also actively holding back the evolution of the language, as the OP goes to great lengths to explain. I will honestly be surprised if old serialization as a whole isn't dropped like a hot potato at the earliest opportunity, be that 18, 30 or 60 months from now.
&gt; A better serialization should be simply a better implementation of this idea - what we have here is retraction instead &gt; &gt; current serialization offers a lot and getting rid of it instead of making it better is a huge step back I am absolutely for losing some conveniences and power if the benefits make it worth it, which has been a common trend with recent Java developments - in this case though, we are losing maybe too much and not gaining enough. I will gladly adapt my old code to keep up with best practices and language idioms even if that's not really "productive work" but at this point it seems I may need to rethink my entire established serialization approaches and that's just too much. For the first time ever I'm having to think of looking outward Java for a better replacement than the one they are proposing for the core language as a replacement. At this point, why should I use the new serialization instead of some random serialization framework out there, as an end-user? (Which the proposal made a point of mentioning there's dozens of already). What is the actual benefit of this new approach? I'm afraid the real answer to the new approach is just "we can do away with the old one which has been a burden and a problem since its inception" and as such they are benefiting more the JDK developers than the Java developers...
On a similar note, would anyone with moderate experience recommend me one of these frameworks, since right now I'm feeling uncertain about the new proposed serialization mechanism? In particular something that will easily handle semi-complex graphs of objects would be welcome.
&gt; Does anyone use the inbuilt Java serialisation anymore? Yes. It's by far the easiest, most convenient and guaranteed-to-be-there mechanism for my use cases. I have no reason to use anything other than that as of today. But I do agree that it's maybe too easy, in a "too good to be true" sort of way and it's clear for me to understand that all the magic behind-the-curtains has been taking its toll when it comes to writing new language features and such.
This is my favorite topic. Instead of having a table for everything try to model your value objects as a more 'general containers' that can be mapped in EAV style database. Creating a separate table for each class / object is an extremely myopic solution that requires no engineering skills at all and produces maintainability hell. You don't have to go full EAV in order to reap immense benefits. You get reusability, much less code, much easier to adapt/change and since you no longer need a 'persistence library X' you can optimize your DB loading routines to be orders of magnitude faster than with any framework that only handles the most simplistic cases and requires you to write anything even remotely complex by hand if you want decent performance.
Did anyone else got the feeling that the whole point of this Serialization 2.0 is: &gt;For new language features such as value types, we can go farther: make the new serialization approach the *only* way to serialize a value type. I do not see how switching from Jackson to this will provide any benefits.
I wrote a library akin to Ruby's `pp` method, to pretty print objects to make really deep hierarchies easy to debug, log, etc. My job involves large event chains which have objects with deeply nested data, so this library is extremely useful for debugging those events. Let me know if you find anything you think could be improved, or any general bugs that I should fix.
And the “finding a needle in a haystack” award goes to
&gt; serverName is not sanitized/validated and as such is a security hole It's sanitized in ServerConnection contructor, I guess
I use Apache Commons Lang [ToStringBuilder](https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/ToStringBuilder.html) for pretty printing objects.
&gt;Does anyone use the inbuilt Java serialisation anymore? Hell yes. It's functionality that's guaranteed to exist, it's stable, is backwards compatible. Using some third-party library gives up all of those things by default unless I as the library client now spend effort to ensure otherwise. In the first case I have to ship the library, which is a concern in many of my customer's environments. In the second case the burden of maintenance is shifted from the JDK people onto me. In the third case I now have to review all of the changes in the library to make sure they haven't fucked something up (spoiler: all of them have at least once). Stuff that hasn't changed in several years is nice and stable and dependable and easy. Third-party code is often none of those things, but has a shiny infinite scrolling website telling me how awesome it is.
I'm not sure I understand. You build a custom builder for each toString? Or you use the `reflectionToString` method? What does the output look like?
Then the example has nothing to do with security as if that's the case then ServerConnection could (and should - if it is serializable) make sure its state is sanitized upon deserialization. It is not the responsibility of its client to make sure its invariants are met. &amp;#x200B; But the problem is worse than this: security issue is really that the connection is performed to a wrong host (because a bad guy provided a hostile server name in the serialization stream). Such policies in general cannot (and should not) be implemented in deserialization/construction code but should be enforced externally (in case of Java - by a SecurityManager). The proposal does not really address security concerns as they cannot be addressed at this level! &amp;#x200B; In other words - this proposal means loosing convenience and not really gaining anything in terms of security.
Is that true, though? Most people are using one of the options above today and just ignoring built-in serialization. I'm worried that this will be similar to the Java 9 module work: beneficial to Oracle (e.g. easier to secure the platform) but a headache to everyone else (e.g. additional language and platform complexity, migration effort required).
The versioning approach is less error prone. If the serialization format is pluggable, you also gain platform independence / performance / size. I think the hope is that all those serialization frameworks will integrate with the new serialization approach, so you gain flexibility. But you have to think about cyclic graphs, that's the price. Thinking about it, a generic approach could try representing those as adjacency lists, but the nodes would need to be mutable so references can be set.
There are almost certainly security benefits, but like you I am also struggling to see much benefit here for most non-Oracle users.
But serialization format **is** pluggable **now**. There is nothing in the serialization API that enforces a particular serialization format.
Heroes don’t always wear capes.
&gt; You build a custom builder for each toString? That's how it is typically used, which is why it is called `ToStringBuilder`. Commons Lang also comes with `HashCodeBuilder` and `EqualsBuilder`, when you want to override `hashCode` or `equals`. &gt; Or you use the reflectionToString method? That's the method you would use, but you don't have to use it in `toString`. In `toString`, you would pass `this`. Outside of `toString`, you can pass whatever you want. `ToStringBuilder` can be used to pretty-print third-party objects. &gt; What does the output look like? The output can look like anything, depending on which `ToStringStyle` you use. See the Javadoc I linked, which has examples. As an example of its flexibility, you could pretty print the object graph [as JSON](https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/ToStringStyle.html#JSON_STYLE), if you want.
&gt; platform independence / performance / size None of these are issues for your average use case, not that I've encountered them so far. Also I'm pretty sure I have loaded serialized payloads between platforms without a hitch to it before. &gt; a generic approach could try representing those as adjacency lists, but the nodes would need to be mutable so references can be set However it's accomplished, it's already being done today. I don't see how this has to be at odds with the goals of this new proposal, which are the explicit syntax and related benefits from it.
You mean that you can use e.g. Jackson's `ObjectMapper` instead of `ObjectOutputStream` on serializable classes, right? That will only work if the object graph has no cycles and no piece of data needs massaging before being written out. If you want to customize the data that is written, you have to use framework specific annotations at the moment. With the new approach, the same logic can be reused more easily.
I will again say that I hope you take these issues to the appropriate mailing lists. You are very clear, well-written, razor-sharp on point and in a much more of technical way than I could address these things, or I'd do it myself.
&gt;You mean that you can use e.g. Jackson's ObjectMapper instead of ObjectOutputStream on serializable classes, right? You can subclass ObjectOutputStream and implement *writeObject()* using whatever serialization facilities you want. Not straightforward - I admit - but still doable. And if there is anything in serialization API that I would like to change - this would be one of these things: there is a not-so-well-known interface pair *ObjectInput/ObjectOutput* that is implemented by *ObjectInputStream/ObjectOutputStream -* personally I do not understand why the stream classes are used everywhere instead of the interfaces.
Yes, you could study and take the Oracle Certified Associate then Oracle Certified Java Programmer.
&gt; security benefits I agree but let me point out that a lot of those security benefits are just shifting the burden from the JDK to application and library developers. That is fair to a great extent, especially when it comes to giving developers convenient ways to enforce the security issues in their domains. On the other hand though, I don't like this being sold to me as "yay, security!" while it's really only 1) allowing me to do my own security; 2) taking away a lot the convenience I had before with really no benefits that aren't tangential (like the `open` keyword), meaning that to an end-user these approaches are *equivalent at best* (and a downgrade at worse, with lots of rewriting old code to it). As I've said several times, I'm OK with paying the price as an end user so that the language itself can become leaner and grow even faster and better, even more than it already has been lately. On the other hand, I think this time the downsides are really approaching and even overtaking the benefits and that makes it a hard sell if you're not a JDK developer per-se. My use-cases for serialization are not concerned with security at all - and if they were, I would probably be using another framework for a long time now, making the old serialization approach a no-issue either way. I just wish they were clearer in comparing how the old and new proposed approaches would work in practice, highlighting the pros and cons and changes in the process. The current proposal leaves a lot up in the air, as far as I can see and obviously that makes me fear for the worse in assuming that my current approach to persistence is not going to work at all and require a major rewrite of my model, especially when concerning object graphs.
I guess a kotlin dependency would be acceptable, but com.ibm.icu:icu4j ? The jar is 12mb (https://repo1.maven.org/maven2/com/ibm/icu/icu4j/64.2/). As a small and focused helper library, I would not expect that much transitive dependencies.
Hum, I've been using Jackson, gson, snakeyml, and jaxb for years and not had a problem with them. We use them for rest, queues, nosql, file interfaces, which are consumed by not just Java apps just fine. Can you give an example of where you use the inbuilt serialiser? What sort of interface is it on? Maybe we're in a lucky position we don't ship to 'customers' we run our own components, we control the client device software so any changes to our interfaces can be handled by us.
I'd love to see some performance comparisons between pretty-print-pp, apache commons to string building and Lombok generated to String methods. Edit: I forgot: nice job, it's hard work to pull off an open source framework - it shows stamina!
I meant platform independence in the sense of more generally supported serialization formats like JSON, not the default binary format. That's obviously available today, but relies on custom annotations. The proposal wants to avoid breaking encapsulation, which the current mechanism does. But I guess it's impossible in the general case to deserialize cyclic object graphs without circumventing constructors. If objects A and B reference each other, you need to create one of them first without knowing the reference to the other (ignoring the constructor), then create the other (could use regular constructor, passing the incomplete object), then break into the first one and set the reference.
Might make sense if you need to serialize the same DTO into different formats. Could be better than a mix of annotations.
That seems like a lot of work to debug an object. &gt;when you want to override hashCode or equals It seems like you misunderstand the purpose of this library. It's not for changing how an object prints it's own `toString`, else you might need to change thousands and thousands of objects in order to get the printing you want. This library prints, without using json, a standardized object format. Also you don't have to depend on apache commons. It seems like ToStringBuilder is designed for a fundamentally different use case, where you might want to change the toString which could affect actual code/checks/etc. pretty-print is designed to help you debug massive object graphs, write to logs, etc. It's not designed to replace `toString`. Technically you could say it's designed to replace `System.out.println()`
Yes, that is to provide unicode line breaking support. If you use gradle I will be adding support for Feature Variants in case you never ever want to line break. Otherwise, pretty printing will fail if you want it to break at things like invisible spaces, hyphens, etc.
&gt; The proposal wants to avoid breaking encapsulation, which the current mechanism does. But I guess it's impossible in the general case to deserialize cyclic object graphs without circumventing constructors. Strictly speaking it is possible. In the end the cyclic references have somehow been set. So a deserializer can use the same code to re-initialize the graph. It does not make sense though :) Serialization can be thought of a way to take a snapshot of application state (ie. snapshot of the object graph). It is no different than for example taking a snapshot of a virtual machine by dumping its memory to a persistent storage. Does it require any constructor invocation to deserialize? Nope. Is it useful? Of course!
 \-Djavax.net.debug=all Does this not work anymore?
Thanks for the input!. As I mentioned in another comment, this isn't intended to replace ToStringBuilder, or toString methods at all in fact. It's meant as a replacement for `System.out.println()`, in order to print objects in a nicer format. It has no side effects on existing objects (like modifying the `toString` would cause) and as such can be used safely no matter the situation. This library is useful to help debugging large CQRS object hierarchies (the reason I built it actually), and makes debugging large objects graphs much easier. I could still try to make a performance comparison, but I don't think it would be fair to my library, since it's not meant to do the same things ToStringBuilder does.
That caused me sleep trouble for weeks , couldnt access server's logs
There are still many products, applications, systems etc that rely on it. Without a viable Java alternative, they would have to switch to a 3rd-party solution, and then switch again to the official Java replacement when it arrives.
Jackson and Gson both definitely have issues with round-tripping Java data correctly, particularly if you want field-based serialisation (instead of bean-style serialisation), and don't want to festoon your class definitions with Jackson annotations. Jackson also has various security issues.
I feel like my current use-case's object graph is a fairly simple and common one. I'm sad to say that a serialization solution that doesn't support it will always be a lesser approach to one that works, as much as I'd want to support the language evolving. This comment on r/programming has an interesting point to make about cyclical graphs and about the whole of the new proposal https://www.reddit.com/r/programming/comments/bzgz0n/towards_better_serialization_in_java/eqw2nlt/
Great idea! Thanks!
Yes, I want to support every platform. So, Gitlab is in our plan. Could you share which public repos you would like to use Lilit with? If it's private or on-premises, could you send me a message through [https://lilit.dev/try](https://lilit.dev/try)? I'd love to learn more about your setting. Thank you.
Thank you :)
Hey Rakesh, Yes, supporting perforce should be straightforward from our side. Lilit would be perfect for a team that reviews code often. Could you send me a message through [https://lilit.dev/try](https://lilit.dev/try)? I'd like to learn more about your setting. Thank you.
Thank you. However, I'm not looking for a team member right now. You can drop me a message through https://lilit.dev/try. When I look for a team member, then we can talk.
Thanks for the link, I'll check it out.
r/kotlin
I agree I am not a fan of class pollution, to be fair we keep our interface classes separate from the domain objects, and try to avoid annotations by configuring the 'ObjectMapper' or whatever lib is being used. I'm not sure what the difference is between field and bean serialisation (could probably hazard a guess)?
&gt;It's not for changing how an object prints it's own toString I was explaining the origin of the name `ToStringBuilder`. You can use it for third-party objects. &gt;you might need to change thousands and thousands of objects in order to get the printing you want. `ToStringBuilder` can recursively pretty print third party objects without modification. &gt;This library prints, without using json, a standardized object format. I only brought up JSON to point out that the output format is completely customizable. &gt;Also you don't have to depend on apache commons. Apache commons-lang. But, many projects already depend on it, so `ToStringBuilder` might already be available as a transitive dependency. &gt;It seems like ToStringBuilder is designed for a fundamentally different use case That's what it's designed for (hence the name), but its flexible enough to be used to pretty print arbitrary objects. I have used it to dump arbitrary objects, such as in a unit test failure messages.
The argument still works. It says “no compatible cipher suite” when accessing the server via https. When I listed the contents of the keystore and saw the alias name was all in lower case and reconfigured the server to use the correct alias name, on server startup, the network debug logs showed that the key was successfully loaded. HTTPS Access to the server was okay then.
If possible, search for bootcamps. Many companies offer internships as well, don't know if that's an option for you though... Other than that - you're right. Build up your project portfolio
Thanks, I wrote just "Swagger" in parens, but maybe I should have written "previously known as Swagger" ? Which isn't really correct either.. It's hard to specify this without going too much into detail.
Undertow is probably a lot closer, yes.
I don't understand your comment. I posted over there months ago. It's also usable from Java so I thought it belonged here.
This sub is for Java the programming language. If every JVM library posted here because its more or less usable by Java, it'd become a useless sub. People could even start to post Python or C or Ruby code here because of cross-language interfaces. New Java library releases are also generally not posted in /r/kotlin, /r/groovy, /r/scala, /r/clojure etc.
Field-based serialisdation is where objects are serialised according to the (non-transient) member fields that comprise them. So a class X with member fields a and b, might be serialised as a node (e.g. an XML Element or a JSON Object) corresponding to X which has child elements corresponding to a and b. Bean-based serialisation is where a class is serialised by looking for getXXX methods (and usually corresponding setXXX methods). So your class needs to have getA/setA and getB/setB methods to arrive at an X node with a and b child nodes. I have literally never wanted or needed bean-based serialisation, but Jackson defaults to it. Trying to make it consistently do field-based serialisation always involves annotations and configurations, and every time I attempt it I eventually hit a brick wall and revert to hand-crafting type &lt;-&gt; JSON de/serialisers.
There are also remote work platforms, one of them is called up works, you can try your luck on. Be warned though: The money is bad in the beginning and you might end up liking the freelance life too much to actually go for normal job again soon...
Right, if the objects are mutable, it's theoretically possible, just not really usable. Serialization is useful, no doubt. But it's a clever hack, and if the cost of keeping it alive in the current form includes slower language evolution and less optimal new language features, maybe it's time to say goodbye. I haven't looked at all the listed serialization frameworks, but with enough work it should be possible to build 3rd party libraries that accomplish the same.
Unless the employers are weird or you're in a very hierarchical country (india and most of SEA come to mind), the 3+ years is like 95% basic programming knowledge -- loops, iterators, output, objects, etc. The other 5% is the language. The other 100% is the ecosystem :) Just start building projects with Java. Re-implement something like the Spring PetClinic with a new Java framework. PHP is a C-like language, as is Java. It's not going to be completely foreign to you, so just get going. Literally search google for "Java interview questions" and make sure you understand the answers to those questions. Then learn Maven or Gradle, and learn the basics of Spring, and you should be on your way.
Java has gotten so much new life in the last few years. It's like a fresh new platform, but with an extremely mature management ecosystem.
Ok, so I went and tried out ToStringBuilder to see what the difference to my library would be. I'll need to make a comparison chart showing the differences in output between the two. It seems much harder to get good output from ToStringBuilder unless you are willing to write quite a bit of code. If you are willing to write that code then you could probably get output that is quite close.
it's ridiculous, literally, to be hand-managing JAR files. learn Maven or Gradle, it'll make your life so much easier.
Shit like this is why I love the Spring Framework. Not only did they respond to a likely ridiculous attack vector, they explained all the steps they took so that others can do the same. They also explained their security breach process. They're using their weight in the ecosystem to help move others to the more secure mode of operation. This is like peeking behind the wizard's curtain and seeing what pros do.
Of course! Thank you!
What are you trying to achieve? I use `ToStringBuilder` to dump object graphs so I can debug the output. I'm not looking for the prettiest output, only usable output. I get `ToStringBuilder` as a bonus from commons-lang, which I am already using for its `StringUtils` library (which is essential in Java, because of the pathetic lack of features of `String`). A lot of projects already use commons-lang, so it's probably already available. I don't have to install yet another dependency just for pretty printing.
I see no rule about this. Kotlin tends to be closer to Java than Scala or Groovy, so as a result Java devs might want to know about related libraries. I wrote this library _not_ for Kotlin users, but for the whole JVM. I wrote it _in_ Kotlin because that allows Kotlin users to get the greatest benefit from it, in regards to named parameters, extension methods, and so on. If you think it doesn't belong here, report it, and make a request to the moderators to update the rules. Otherwise I'm going to keep posting libraries I make that are written _for_ Java, even if they are written _in_ Kotlin.
That smells fraudulent.
&gt;Nobody cares about people's opinions. That's just, like, your opinion, man. One that doesn't seem to be super well-supported given the positive vote count of this post. &gt;Let's deal with facts! Yes, let's.
Ah yup makes sense, I thought (at least for Jackson) it used the default constructor for deserialisation and then used reflection to populate the fields. Serialisation I thought it defaulted to using the field and only the getter if you instruct it to (yes with an annotation 😉) I have in the past used getter based serialisation allowing subclasses to override the how the field is to be represented. I seem to recall (Jackson again) really not liking a getter with differing return types to the actual field, forcing the use of custom de/serialisers (usually am lazy and create inner classes on interface objects unless it's common, although I find this makes it easy at a glance to understand what's going on)
&gt; I see no rule about this. Still, the subreddit title is **/r/java**, not /r/jvm_languages. Also, the description is: + **News, Technical discussions, research papers and assorted things of interest related to the Java programming language** Again, it doesn't say **related to JVM languages**. Kotlin != Java. **Removed**
Just let a recruiter place you in a company with both php and java backends so you can branch out.
fallacy of limited choice much?
You do not have to deal with modules to use JavaFX. Just use the OpenJFX libraries from maven central as regular dependencies and you are good to go. Also, no, the "observer pattern" is not deprecated, just the interfaces Observable and Observer, because they have always been horrible. Just create your own Listener interface if you want something that basic. In my ten years of Java development I've never seen even one person actually using these interfaces. These interfaces have long been superseded by other classes that are more tailored to their specific use case. For example, see the new Flow class since Java 9. Now that I've debunked both of your examples, I reject your overall premise. I think the future of Java is brighter than ever before. Exciting times! Finally we are seeing changes that were long overdue.
Deterioration? What deterioration? With the new six month release cadence, features are being delivered faster than ever before. There are also a lot of great features in the pipeline. I suggest looking at projects [Amber](https://openjdk.java.net/projects/amber/), [Loom](https://openjdk.java.net/projects/loom/), [Panama](https://openjdk.java.net/projects/panama/), and [Valhalla](https://openjdk.java.net/projects/valhalla/). In regards to Swing, you don’t have to use it if you don’t want to. JavaFX was removed from the JDK, but it is still being evolved. In regards to modules, they were designed to allow internal APIs, such as `sun.misc.Unsafe`, to be encapsulated. Once again, if you don’t want to use them, you don’t have to. That is why automatic modules were added.
Not so sure about it. Usually questions on SO is quite narrow, and.. how to say it? Good questions hard to answer, and questions that easy to answer not very beneficial. Will be happy if someone prove me wrong
I reject your premise. JavaFX is still supported and unbundling it from the JDK men's it can have it's own release schedule. You just have to add a dependency like any other library. If anything I'm optimistic about Java's recent past and its future. I'm excited about the language changes like switch expressions and text blocks. I'm excited about pattern matching and Project Loom, Valhalla and Panama. I'm excited about GraalVM and the native AOT compilation of Java. Java has never been more exciting.
It is also worth to mention that JavaFX was never part of the Java SE specification. Yes, Oracle bundled it with **their** JDK, as they did with many other things that were never part of Java SE. OpenJDK never included JavaFX. People using the bundled JavaFX of the Oracle JDK should have been aware of the potential vendor lock-in.
Yep! Great points as well!
&gt; The deterioration of Java over the years is notable. Java is now seeing levels of investment and participation it hasn't seen in many, many years. Lots of new capabilities have been added and lots of projects are in the works, Oracle has recently open sourced the entire JDK, a more modern release cadence has been established, and we're starting to see increased participation from companies other than Oracle. &gt; The observer pattern is deprecated since Java 9. The 25-year-old `Observer` *interface* has been deprecated, not the pattern, because better alternatives are available. As of JDK 12, it is not marked for removal, so it's here to stay, at least for a while. &gt; What if I still wish to use JavaFX? Well, I need to deal with Java modules to actually use JavaFX. You don't. You can use JavaFX the same way you use any Java library. Using modules is entirely optional. &gt; Java module is probably the most complex language feature I have never seen. Whole books are dedicated on that topic. How can it be? I'm counting even more books dedicated to lambdas on Amazon. Every unfamiliar feature seems complicated at first, especially a feature like modules that doesn't exist in most other languages (not in a similar way, at least).
As much as it pains to admit, our whole enterprise application uses Java serialization for client-server communication. We are basically tunneling RMI over HTTPS.
Oh! You good
JavaFX is super easy and awesome. Source: Me with a two year computer science associates degree working on a JavaFX project.
Hmmm. Is 'wget' not working?
I check with, &lt;plugin&gt; &lt;groupId&gt;org.simplify4u.plugins&lt;/groupId&gt; &lt;artifactId&gt;pgpverify-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;check&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;failNoSignature&gt;true&lt;/failNoSignature&gt; &lt;failWeakSignature&gt;true&lt;/failWeakSignature&gt; &lt;keysMapLocation&gt;${basedir}/pgp.keysmap&lt;/keysMapLocation&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt;
Sorry, how did you learn it?
I believe that that simply verifies that the signature is present or not, not who signed it. I could be wrong though.
It verifies the artifact is signed with the correct key using the keysmap.
By doing it, my boss taught me some stuff too. Just got put on a project with a lot of JavaFX.
Thanks, I think I will look for some reps with JavaFX
It's a great little way to make some cool front ends. I'm using it for an embedded device(raspberry pi) and a touch screen. We use it for the interface and a lot of different graphs to display test algorithms. If you have a general understanding of Java and Swing, JavaFX won't seem bad. There's a lot of good into tutorials, scenebuilder is also pretty nice.
And why is that? Is it just a legacy application, or was it a consious decision to use it over one of the more modern libraries?
Yeah, I have some expirience with Java and Swing l, so there actually no issue for me, only I was afraid that JavaFX is quite complex and hard to start. I had hard times with WPF, which some people consider as JavaFX analog.. so I was trying to decide what to use for small project: Swing or JavaFX. Thanks for clearing it for me. Will try JavaFX for sure.
Yes. I use default serialization for low volume objects and hand tuned custom serialization (old externalizable interface) for high volume ones. No libraries.
Not that I've looked into performance tuning of the in built serialiser, but I've seen posts showing libraries like Jackson being faster by default. Why do you use it? Is it purely based on performance and the ability to tune? How do you tune it?
Thanks, I hid the post.
Not on S.O. But yes, here on Reddit, over on Experts Exchange, in \#\#java IRC, and random questions I see on Mastodon. It helps because it forces me to look at topics I normally wouldn't encounter.
It looks like in your [submission](https://www.reddit.com/r/java/comments/bzyo4n/how_do_i_put_quotation_marks_in_my_line_using/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Don't feed the trolls
Hey, I'm a little new to anything beyond beginner Java -- aren't Maven and Spring basically the same thing?
You may be thinking of Maven and Gradle, which area both build tools and are similar to each other. Spring is very, very different and much more extensive than they are.
Depends on your region, but I'd probably tell people I've been working with Java outside of work for the past 5 years. Or would be good to back this up with some of your portfolio.
Nice! Welcome to the club :) &amp;#x200B; I notice it still says copyright Skymind. Isn't there normally a copyright transfer involved when a project joins the Eclipse Foundation?
Does it support code injected by Project Lombok?
Wow, Brian is ripping Serialization a new one in this post. Maybe I am an amateur, but I never really had any serious issues with Serialization.
Yeah, as it often happens, with cheap serialization, you save time at the beginning of the project and then maintain it for the rest of its life :)
Not yet. But it will. Right now the code generated by Lombok will be missing. The code refers to the lombok-generated code will be broken. Which repos are you looking to use Lilit with?
Ahh gotcha. Thank you for the reply!
There's too many people on SO who are under the impression that SO points mean anything that spend a rather substantial amount of time there answering any and all question that comes in. I don't have time for that. I much prefer to help out on the beginner subs here on Reddit.
Don't worry too much about the "X years of Y" type requirements, these tend to be quite flexible. Send a motivation with your resume where you explain you understand that there is a skill gap, but that you're eager to learn. Bonus points if you can already show a Java 'pet project' online. Not every company will bite obviously, but it's very likely at least a few will give you a chance.
Why are people even spending time answering this?
This is a very important principle to keep in mind while attempting to create an object oriented design of your solution system. Having said that, this is something that need not be remembered, but should become a part of your DNA, so that a compliant solution comes naturally while designing a solution.
I get your point (no pun intended) but I don't mean the points specifically, but rather the knowledge and experience you get from trying to solve issues broader than what you're working on
&gt; Improving the Reading Experience It's actually the worst reading experience I've ever had.
But they're moving to HTML, which is actually great news!
Every one has a different learning style. Some people like to learn by solving problems. If you fall into that category then its a very good source of a wide range of problems. Not everyone likes to learn that way. Another learning style is by teaching others concepts and guiding them to solutions is a scaffold way. My personal learning style I describe as "jump right in" sometimes referred to as "sink or swim" which was actually the way my farther taught me to swim, now I swim like a fish. I use SO a lot for solutions as a result I try to answer any questions I can when I bump into them in my searches. If you do adopt your SO learning strategy, if possible try and avoid answering the "do my" "homework" / "assignment" style questions.
Because when people see something so obviously wrong they have an urge to correct it.
Who said DI containers do everything right? They repeated the same mistakes as serialization.
It's interesting because I see it as an example of how we fail to learn from mistakes. Serialization in Java is seen as problematic, but DI containers are still a "best practice".
I don't know about 'stupid', but there are a number of things around threading that have aged badly. All objects having monitors (you can lock on any object) regularly pops up as an annoyance. These days you'd be crazy to use that stuff, but like serialisation it still exists.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Yes. Answering questions on StackOverflow works both ways. Not only that you are going to help many developers to fix a certain issue, but you are going to improve many of your own skills too: 1. Improve your writing skills. Unless you're an English native, writing on StackOverflow will allow you to perfect your English writing skills. 2. Improve your teaching skills. Explaining to others is much more difficult than simply understanding a problem. The best way to learn something is to try to teach to someone. 3. Improve your knowledge in a certain area. Although you might know a technical area very well, you'd be surprised how vast the domain is, and how many problems you haven't bumped into are still to be discovered. Answering questions will allow you to enhance your problem-solving skills, which is great if you plan on doing consulting work. As of writing, I [answered 1478 questions](https://stackoverflow.com/users/1025118/vlad-mihalcea) and got a 63k reputation. For more details about this topic, check out [this article](https://vladmihalcea.com/how-to-get-a-10000-points-stackoverflow-reputation/) as well.
Did you never really have any serious issues with serialization when *using* serialization, or when *maintaining* serialization.
Spring is a framework, Maven is a build tool, and their use cases are completely unrelated to each other.
&gt;so have 7yrs of experience in Java and am Struggling with 7 years experience? Any insight as to why from the places you are applying? That seems strange
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Vanilla Swing too ?
What do you mean by "hierarchical"?
No, but I report threads here that should be in /r/learnjava so I can improve the subreddit.
I don’t believe so.
How about Objective C interop?
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
It looks like in your [submission](https://www.reddit.com/r/java/comments/c08zyy/silly_question_is_effective_java_book_useful_for/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
yep.. robovm now forked mobidev Microsoft bought it and killed RoboVM NEVER trust Microsoft. They are evil.
had the same problem with a project using lombok.. never found a fix. lost many hours.. unpopular opinion: Lombok is a painful lazy joke... intellij creates getters and setters in a few commands.
India is my specific reference point, and even then, I'm probably committing a hate crime -- I apologize in advance to everyone. In folks from some societies, the manager may as well be your god. You do what your manager says, unquestioningly. There is little-to-no room to disagree with your manager. Likewise, when these same folks are in a position of management, they expect absolute loyalty from their underlings. In the USA, however, developers are often expecting to have technical battles with their bosses and peers. Devs of all levels debate and throw ideas and challenges around. It can be difficult, *or so I've heard*, for folks from India to adapt to this change. Second-generation immigrants don't seem to have this issue as much, either.
can you explain the intrinsic advantage of coroutines please? And why can't Java have them since they both compile to the same byte code.
the version of jdk is growing so fast.
I use Swing for my crypto currency project. I love Swing. spot on. no multi touch is a potential problem. Hopefully they introduce it one day. JavaFX has support for it. I did a demo. Unfortunately.. neither Sun nor Oracle found a business model for Java UIs
lol i use it.. tables are ten times better than JavaFX.. millions of rows in split seconds. reloadable look and feels. intellij was first built with Swing.
you wrote that book? :)
Good catch. Where does it say copyright Skymind? Not on the repo, right? Do you mean on the DL4J website? We'll fix it, in any case.
they could add multi-touch though since it works on JavaFX....so i guess the mechanics for the getting the events from the OS is there already. at least on windows where i did some conclusive tests on a 10 touch points screen with a JavaFX demo app.
Interesting. I had no idea. This is true for Seattle as well (based on your original comment)?
Yep! Every six months!
Well, coroutines make it look like asynchronous code is writen sequentially, much like if every call returned right away, so it adds for brevity, at least in my opinion. RxJava solves this, but I've found it to be more readable with coroutines. I also never said Java can't have coroutines, in fact there's project Loom that will add "fibers", there's also Quartz (and several other frameworks) that do coroutines. These libraries/frameworks however give the same feel as streams or RxJava, I prefer regular function calls over a stream-like call chain passing method references.
Pretty sure they meant Southeast Asia when they say SEA
Oooh, that makes more sense.
Oooh, that makes more sense.
I think Jetbrains did some work with the mouse support so that with their bundled JDK you are able to use sidescrolling with two fingers. AFAIK Oracle / Open JDK only supports vertical scrolling with two finger emulation.
Either. As I said when I mentioned the word "amateur", I may not have used Serialization to the extent and depth someone more experienced. I do know that versioning of Class being serialized is an issue.
Old 1.14 versioning is also used in a few places...
Now you TOO can be sued by Oracle!
It's pretty simple. A lot of the problems and overhead related to 'it just works' default serialization is related to the fact that it cannot assume nor optimize anything because even small changes would break it if it did and it deals with versioning problems which are irrelevant in our case. Externalizable for high volume objects. Basic writeExternal, readExternal methods. &amp;#x200B; Few examples of optimization would be: 1. An object could have multiple fields that can be null. For simplicity let's say you have five String fields. You could then write out a single byte containing bit info whether those fields actually have String values or if they're just nulls. 2. I use Stephanio Vigna's Fastutil collections a lot. (IntList and others). There are multiple cases where I know that these collections (which there can be many) will only contain either less than Byte.MAX\_VALUE or at least less than Short.MAX\_VALUE. When you have complex object structure these small details make a big difference compared to standard serialization which encodes the collections sizes as int. I don't remember anymore how big the average reduction in size was (most of the optimizations were done some 15 years ago) but since the object structure contains countless references and 'reference collections' the bandwidth requirement dropped at least 2...3 times if not more. For smaller payloads the difference is huge since default serialization contains class information which is not needed when you're just pushing bytes into the stream and reading them in reverse order at the other side. &amp;#x200B; Writing an object into a byte array (and then reading it back) is actually one of the most simplest tasks in Java. It's not that much harder to write it out as JSON or some other more verbose format either but if you want to keep it as efficient as possible, the binary format is easy.
Actually no. It doesn't make sense to put mindless requirements on people (must have university diplomas) after they've already done the work. The customer picked our software after rigorous testing against competitors and was making a project with it. The people working with the 'project' were qualified, of course, and the customer was happy. Why should we ruin the mood by broadcasting and announcing something insignificant? I get my validation from other customers and from other great projects so I can easily live with one customer who thinks programming is about formal diplomas.
I am not sure such a transpiler (if I get the idea correctly) will work for any complex case. On top of that, as the readme mentions, the result will likely be ~~unrusty~~ bad, because Java and Rust are rather different languages. If it is simply needed to use some high-level functionality of a Java library in Rust, then there is quite good [JNI Invocation API support](https://github.com/jni-rs/jni-rs).
I know your preferences.. but JDBC didn't have to exist in order to have database connectivity. It would've been a messy and chaotic db connection tool landscape, but things could exist without it.
&gt;It doesn't make sense to put mindless requirements on people (must have university diplomas) after they've already done the work. That may be, but customers aren't obligated to make their requirements sensible.
Fair enough, we have some interfaces that are very specific (I.E for DRM) and for those we wrote a specific interface class to convert to Byte Stream, maybe we should have used the default serialiser, saying that I don't think it really added any significant work, maybe the grass is greener maybe it isn't. I do quite enjoy writing those, they're more of a challenge shoving multiple pieces of info into an int/short etc than just letting a spring HttpMessageConverter handle everything. Reminds me of my c/c++ days.
Totally agree, I cannot read anything
You can just download the PDF and read that.
What I'm reading is that they got GraalVM native builds to run on iOS. Or am I missing something?
Hows the performance??
Related to your #1: Even if you are an English native, you can perfect your English writing skills by doing that.
I can only see it in a single comment. I did see 1.10 but they've used 11 etc from then on.
What’s the use case?
It looks like in your [submission](https://www.reddit.com/r/java/comments/c0cdk3/what_are_some_good_resources_to_learn_web/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Is any interesting Java language feature potentially coming to JDK 14?
Yes. You can. However today spring mvc is a better option to learn and use. But good to understand the jee tech too.
Yes you can and Spring mvc is a framework that makes doing so easier.
Linux master race
unrelated but servlets can't redirect you back to main page right? you must go to a new page with the action tag
13 just entered RDP1 today, so it will be a little bit before we hear anything concrete. I am thinking `switch` expressions and text blocks will exit preview, though.
A redirect to the main page is an HTTP 302 response, which can be generated by the server through the `HttpServletResponse` parameter to your `doGet` or `doPost` implementation.
so when you redirect, you have to go to a NEW page and then you redirect back to the main page?
An HTTP 302 response isn't a page, as in HTML, which I would associate with an HTTP 200 response, but I think I see what you're saying.
Why, have they violated some license?
A login scenario is a good example of redirects. -&gt; HTTP GET /protected/page &lt;- 302 Found Location: /login -&gt; HTTP GET /login &lt;- 200 OK &lt;html&gt;...login form...&lt;/html&gt; -&gt; HTTP POST /login ...url encoded bad credentials... &lt;- 200 OK &lt;html&gt;...forward to login form with error...&lt;/html&gt; -&gt; HTTP POST /login ...url encoded good credentials... &lt;- 302 Found Location: /success_login.jsp -&gt; HTTP GETA /success_login.jsp
What would you do? I need the servlet to perform an action(parsing string and adding changes to a locally stored txt file)
Step back from servlets and think in terms of HTTP, since this is presumably a web service. You need to send an HTTP POST to a URL with parameters, and the server will respond by performing some server side action and returning the appropriate HTTP response. From that basic premise, design your requirements. Then, you can use servlets, JAX-RS or Spring MVC to implement those requirements.
I just need a way to get the servlet to redirect back to the main page without creating an intermediary dummy page... if no such method exists then I will do that
Call [this method](https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletResponse.html#sendRedirect(java.lang.String) on the HTTP servlet response parameter. That will generate a 302 and a location header that will tell the browser to fetch the next page.
Any apps in the App Store yet?
Yeah, that's exactly what it sounds like. I know that AArch64 support was recently merged into GraalVM, I guess this is leveraging it.
I'm guessing JavaFX would be more likely?
Codebase conversion, something like c2rust tool: [https://github.com/immunant/c2rust/](https://github.com/immunant/c2rust/)
Contact your corporate lawyer.. I can't say. I know simply that oracle's licensing for their version makes java no longer free. Where I work we were universally required to move everything immediately to openjdk. At the time of said fiasco I'd seen blog posts recommending abandoning java outright given oracle's lawsuite habits and licensing change. Your mileage may vary and I am not a lawyer...
I did, but I am also based in Seattle, so ... I can understand the confusion :)
&gt; I know simply that oracle's licensing for their version makes java no longer free. Really? [This is Oracle's JDK](http://jdk.java.net/), and it's GPL + CPE. Or do you mean [this Oracle JDK](https://www.oracle.com/technetwork/java/javase/downloads/index.html) that's under the OTN license and intended for Oracle support subscribers? I'm not sure what you mean by "no longer free", though. Oracle has recently open sourced the entire JDK for the first time ever, making it freer than it ever was. Prior to that the JDK was available under the BCL, which was neither free nor $free, as it contained both closed source and paid features. &gt; I'd seen blog posts recommending abandoning java outright given oracle's lawsuite habits and licensing change. The license change is that Oracle open sourced the entire JDK. I'm also not aware of any lawsuits of anyone who has not violated a license. &gt; See the following for some context That refers to the old license, and to companies that violated the license, which wasn't free. As Oracle now completely open sourced the JDK which is now completely free for the first time ever, this is no longer relevant.
I don’t know much about Rust, but I thought it’s trying to solve the memory safety issues with C, so I can understand the desire for C to Rust. What’s the value proposition for Java to Rust?
I remember the version spree Firefox went on several years ago. I quit using Firefox then.
There will be a new version every six months. If you don't want to upgrade, you don't have to.
Thanks for the real info..
Just stick to LTS versions, you don't have to update every 6 months.
When will Java program itself?
[In time.](https://openjdk.java.net/projects/metropolis/)
Features targeted for JDK 13: * [Dynamic CDS Archives](https://openjdk.java.net/jeps/350) * [ZGC: Uncommit Unused Memory](https://openjdk.java.net/jeps/351) * [Reimplement the Legacy Socket API](https://openjdk.java.net/jeps/353) * [Switch Expressions (Preview)](https://openjdk.java.net/jeps/354) * [https://openjdk.java.net/jeps/355](https://openjdk.java.net/jeps/355)
None, really. I don't have any project worth it.
You can, just like you can just use JDBC for database access, but they both involve a lot of boilerplate that other libraries and frameworks have made easier for you. There's nothing stopping you mixing and matching Spring MVC and your own servers.
JavaFX would be so nice. I always wanted to live in an alternative world where web did not exist and we develop desktop apps.
Things could exist without reflection. It would've been a messy and chaotic byte code analysis tool landscape, but things could exist without it.
I mean that *might* make sense as a motivator for a developer (though in this case, not really). But for an end user to drop a piece of software due to the versioning scheme used is beyond silly.
I know what you mean, but the push for web means less windows-specific software. I hate that browsers are becoming the new operating system but it means i can more comfortably recommend linux to people
If you are having trouble keeping up with the pace of Java on your project fearing BC breaks, try to use CI pipelines to compile (and test!) your project against multiple versions. Upgrading will increase joy of development, your team is worth it. If you can, please don't stay on Java 8. This is not the Python 2 community.
Awesome I got it. Do you know if there is a way to dynamic update a list of shopping items with servlets + JavaScript? Currently have a makeshift one with html JavaScript but it doesn’t actually show the users chosen items(which will probably happen with servlets aid). Javascript is there to create and stack each item “box”.
I didn't realize people still use IRC. Is the Java channel active?
It's graal, so perf isn't too bad. However I hear graal isn't really a full jvm just yet.
I'm with you. &amp;#x200B; If you create all default setters and getters why not public properties?
Javafx is the point of this exercise. It's gluon after all.
That is not true. GraalVM 19 is a TCK certified Java SE 8 distribution https://twitter.com/thomaswue/status/1139090360456663040
The 2 leads of OpenJFX are from Oracle and Gluon.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Speed.
I thought the non-preview version of switch expressions made it in to 13?
This one is specifically about using yield to return a value from a code block instead of break.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I meant the header in your source code, but also the site I think. No worries, been there myself, there's a gazillion things to take care of :)
Yea, you're right - I asked the guy and he says his info was outdated.
Beta-support only means "it kinda runs ok on emulator and devices".
So excited for multi-line string literals!
How did you go from an Oracle Java product that runs on Apple iOS, to Microsoft...?
that would be great! Thank you!
Yep. Over on irc.freenode.net.
We never forgot them. Java just made them terribly inconvenient and pretended they didn't exist, in favor of an object-oriented approach.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
The problem with java is that true value objects do not exist (yet). [JEP 169](https://openjdk.java.net/jeps/169) &amp; [JEP 218](http://openjdk.java.net/jeps/218) are still needed for that to work.
Is this what records and inlined (Valhalla) classes are solving?
Is this like the new "sealed" and "record" keywords and types?
I see the point of Brian and the motivation of getting rid of legacy serialization, but I'm not sure if the suggested alternative is sufficient. What I find most strange is that "serialization 2.0" would enforce a heavily declarative programming style, which Goetz wanted to minimize with another JEP presented days ago: https://www.reddit.com/r/java/comments/bxzwrs/looking_beyond_records_better_constructors_and/ Goetz should know that syntax convenience is not mere convenience, but also helps avoiding mistakes by removing ceremony (being the point of project amber in the first place). I agree a lot with Michał Kłeczek on the mailing list. One of the main problems right now is that is that deserialization **cannot check** itself for integrity. And presumably, with a more declarative deserialization deserialized objects **will not check** itself for integrity. I agree with Brian that a shift is necessary, but I can't see how the proposal is substantially better than implementing your own serialization. Could it be that this JEP was given birth by Brians frustration over serialization? It seems to violate several of his most valued principles such as "semantics over syntax". I don't think there can be a 100% solution, but I'd wish to see some use-cases tackled by legacy and new serialization. It feels like everybody has very different experiences with serialization and talks about inherently different things. What I would wish for is a new type of interface which provides **some of the magic** of previous serialization, but with several opt-in options such as overwriting/overriding serialization/deserialization and post validation constraint. If you think about it, preconditions and postconditions in the language would already be a huge step forward. You will always need some kind of state validation, the problem right now is that serialization makes it fiendishly difficult and has many death traps. But it seems like the JEP merely delegates the pain from library/JDK maintainers to ordinary developers. I'm also afraid that (de)serialization code will bloat up classes immensely over time as new versions of serialization are necessary in your domain. Can't we delegate this to a factory to hide all the ugly bits and not pollute our classes? Thanks. Serialization is a first-class-citizen within the JDK and the only sensible replacement can be another first-class-citizen. Java is about to become a much more semantically rich language, we could use this to elevate serialization and make it a superstar of the language again with an ubiquitous design that communicate its needs to the programmer very clearly. The current proposal does not to this at the moment.
Just wait. Java will have this soonish: See JEPs 169 and 218, and Project Valhalla in general. &amp;#x200B; There's a lot that becomes relevant when you try to solve this. For example, once you have VO's, pattern matching on them is convenient, but to do that, you need 'deconstruction' (the ability to take a VO and splice it back up into its constituent values automatically). And if you're going to play with that, perhaps other objects should also be able to be deconstructed, or perhaps not. Also, if you have deconstruction as a feature, hey, you can make serialization much better so lets spend some time making sure we don't introduce a new language feature that is unfortunately lacking if/when serialization is tackled. &amp;#x200B; Also, whilst VOs are nice, the fact that they have identity (you can synchronize on them, you can check ref identity with ==) is actually annoying because it costs memory and CPU cycles to process this extra memory. In many ways, an array of Point objects (with 'int x, y;') is muuuch less efficient than an array of ints, where each odd number is a y coordinate and each even number an x coordinate. Perhaps this can be fixed by treating VOs as essentially structs, making the performance and memory load of Point\[10\] be exactly equal to int\[20\]. &amp;#x200B; And whilst we're on that, hey, List&lt;int&gt; is not valid java, but then if VOs can behave like primitive, then List&lt;Point&gt; also wouldn't be legal, but that's real annoying, so maybe tackle that too. &amp;#x200B; &amp;#x200B; But so far it seems like that's where it ends, and, yes, ALL these topics are being actively debated and solutions are being proposed. There are already proof of concepts for most of these things.
I think this is a misunderstanding. The word "Value Object" as defined in UML is an object which carries no identity and is differentiated purely by its state. This is opposed to an "Entity" which has a life time and having equal state does not mean they are factually equal. In Java, String is such a value object. And I think this confusion is part of why the Oracle guys decided on the name "inline class", since "value type" has too many different meanings.
"Just wait. Java will have this soonish" I'm afraid you are a bit optimistic... it will surely take another 3-5 years. Maybe even some more.
Nowadays I think it easier than ever, if you use some modern javascript framework like react, vue or angular for the UI. Forget about JSP, go the Rest way, use a servlet for each resource, implement the doGet, doPost, etc as you need, serialize and deserialize json via GSON. Use filters to manage security, commons-upload if you need to upload something. &amp;#x200B; If you dont want to mess with Node.js, choose VueJs as framework and [https://lusaxweb.github.io/vuesax/](https://lusaxweb.github.io/vuesax/) as a component library, and use webjars to include your javascript libraries directly in your POM. Or you can even use no javascript framework at all, and use [http://w2ui.com](http://w2ui.com) wich is a nice (but old fashioned ) jquery based component set.
Well you could think of this value-object design as an encapsulation of message passing between objects. Passing messages as value-objects enables simple solutions to logging, auditing, undo and replaying.
Again, step back from servlets. The better question is, is there a way to dynamically update HTML with Javascript, instead of forcing a full page reload with `&lt;form&gt;`. The answer to that is of course [AJAX](https://en.m.wikipedia.org/wiki/Ajax_\(programming\)), which can be straightforwardly done with [jQuery](http://api.jquery.com/jquery.ajax/). jQuery is a bit antique in this era of React and Angular, of course. So, all you have to do is make an AJAX HTTP query, and have your servlet respond. You can return a fragment of HTML (server side rendering) or you can return JSON and create the HTML using Javascript (client side rendering). In the SSR case, you could forward to JSP. In the CSR case, you can write directly to the HTTP servlet response [writer](https://docs.oracle.com/javaee/6/api/javax/servlet/ServletResponse.html#getWriter\(\))
This value-object is not Value Types. Records, patterns and sealed types are relevant to this design concept. It's just an unfortunate overloading of terminology. Records will deal with the boilerplate. Patterns and sealed types might make certain use-cases of working with them easier. It won't eliminate the object overhead. Value Types and Records are orthogonal but obviously will play very nicely together. And primitive specialisation in generics is another one - not directly about Value Types but an obvious thing to pursue if it allows List&lt;Integer&gt; to be as cheap as a List&lt;int&gt; would have been (and maybe even safe to desugar from List&lt;int&gt;). I think we'll see records before value-types (though the latter is the one I'm most interested in for its performance &amp; space benefits).
Yes it's a design approach that Records would make much easier. Patterns and Sealed Types will make working with them easier too. It's not Value Types (though Records and Value Types will definitely be used together a lot).
Rich Hickey has given an amazing talk on values: https://www.youtube.com/watch?v=-6BsiVyC1kM
Nah, I'd be surprised if records aren't at least previewed in JDK 14. Sure, we don't get the ideal *performance* model until value types land, and they could be a few years yet, but at least we should get the *programming* model much sooner.
Let me save you from asking another 100+ questions on this thread. You are basically looking to build a site, with a cart, submit payments, etc or something along those lines. You originally asked about servlet+jsp. Now you are venturing in to javascript. Today, most of us use modern day kits like ReactJS, VueJS, Angular, and make AJAX requests to a back end server that can be implemented in a plethora of technologies. If this is a school project, or if you are working for a company still stuck in the early 2000s, either way, you need to get yourself a book or two, OR do some searching on the web. Everything you asked is easily found with a few searches, and there are literally 1000s of tutorials on the questions you are asking. Not trying to be an ass, just trying to save you days of back and forth where someone as nice as /u/_shorugoru_ may continue to answer your questions. I suspect his responses are a bit above your head as he has introduced you to several keywords and concepts that may not make sense or be needed (especially if you are working for someone stuck in the early 2000s... they got much bigger fish to fry). I would urge you to look and learn from what is available.. everything you asked could be found/read/tried and learned in a few hours to a day, though it would take a lot longer to truly embrace and learn the variety of things involved.
I agree we never forgot them. We've been talking about value objects in Javaland for years. I'd have to disagree with the statement that Java made them _terribly inconvenient_. There are several popular libraries to autogenerate value objects such as [@Value in Lombok](https://projectlombok.org/features/Value) or help generate them [like this example](https://dzone.com/articles/value-objects).
And for those that are interested in playing with inline (value) types now, there is an [early access build](http://jdk.java.net/valhalla/).
Why?
A related concept is [tiny types](https://techbeacon.com/app-dev-testing/big-benefits-tiny-types-how-make-your-codes-domain-concepts-explicit)
You’re welcome!
sorry for being unclear, I was actually referring to project Valhalla, not records.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
I was actually referring to project Valhalla, which still causes the devs a lot of headaches. Some of the posts on the mailing lists are really eye opening what a deep cut value types actually mean for the whole JVM: https://mail.openjdk.java.net/pipermail/valhalla-spec-observers/2019-May/001008.html
In Java, we already have a name for objects that carry no-state: immutable objects. There is a reason that I wrote "*true* value objects. I am aware that you can emulate the architecture using immutable java objects, its just wasteful. One of the advantages of value object is that the have equality, but no identity. Thats not something that applies to java objects. they always have an identity and equality. Another advantage of value objects is that you do not need an inheritance tree etc. they are just data. You also can not have that with Java. Take for example 3-dimensional vectors using floats. Thats 3 floats for 12 bytes. add 8 bytes object header and then you get padding to match a multiple of 8, for 24 bytes. So your value object for a vector3f takes twice as much space as would be needed. A true value object would only need 3*4 = 12 bytes. it doesn't need an object header, it doesn't need padding. And it can always be allocated on the stack since it would by pass-by-value, just like primitives. Those properties -- along with the architectural considerations -- make value objects extremely strong. I absolutely agree with the article, all of the points it makes are valid. its just sad we can not leverage *all* of the power of value objects in java (yet) and need to emulate them with immutable classes.
It is not necessary to have a legitimate complaint in order to initiate a lawsuit. See: SCO vs IBM in Mar 2003. See: Oracle vs Google, which devolved into copyright over public APIs.
Well, that's always true, but I think Google very much conceded that Oracle certainly has a legitimate complaint when they said their actions will probably result in a lawsuit against them by Sun (which was, by then, on its last legs). That they believed they have a case doesn't mean they thought the other side didn't.
Servlets CAN send a Redirect to the browser, to cause the browser to redirect to any URL. But a Servlet CAN also directly emit the JSP of the main page, or any other page in the application in response to this particular servlet request. No matter what the URL of the servlet. Don't think of a servlet and JSP being necessarily tied together. The JSP is what renders what the browser sees. The forms on that JSP may call to various servlets which respond with more browser content from other JSPs.
"Java Magazine Error"
It seems the reason to choose Apache Harmony is that it was a completely independent open source implementation under Apache license. I'm not sure what Sun's or Oracle's complaint would be when none of their code was used. Oracle's complaint ended up being about the API compatibility. But that is one of the major purposes of an API. Copyright should not be about preventing independent implementation. But this kind of thing is what court fights are about. The reason you never want to end up in court is that courts don't always do the right thing. What may happen is unpredictable. Illegitimate complaints don't always get thrown out. See SCO vs IBM, which technically, is still alive to this day, but in zombie form.
That *you* think a legal complaint deserves to lose does not mean that it should, and it certainly doesn't mean it's illegitimate. &gt; I'm not sure what Sun's or Oracle's complaint would be when none of their code was used. Oracle's complaint ended up being about the API compatibility. But that is one of the major purposes of an API. A lot of their code was used, only that code was API, and Google certainly did not use it for compatibility, which was one of the reasons this kind of copying was unprecedented and [a major factor in the court's ruling on fair use](https://en.wikipedia.org/wiki/Oracle_America,_Inc._v._Google,_Inc.#Appeals_Court_and_finding_of_non-fair-use). Again, whether or not *you* (or I) think the licenses can apply to that code is not what matters here. &gt; The reason you never want to end up in court is that courts don't always do the right thing. Sure, but that doesn't mean that you get to decide what the right thing is. &gt; In a nutshell IMO, Oracle bought Sun because they saw a big "sue google" sign on their back. I wouldn't know because I wasn't involved in that decision, but I'll take your word for it because if you're commenting about it on Reddit it means you've probably researched the subject extensively.
The plan is to release it in stages. \_MAYBE\_ it'll take as long as 3 to 5 years for every last bit of it to land, but there's already lots of proof of concept code and early access builds, and even then, we'll be receiving bits of it in between.
You shouldn't conflate value objects with value types, they are not semantically equivalent. In fact, C# has value types, but .NET developers are often [advised](https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/microservice-ddd-cqrs-patterns/implement-value-objects) to implement value objects using reference types rather than value types. That link is official Microsoft documentation. Value types are an implementation detail. They have certain storage characteristics (not as much data required as a object) and calling conventions (they are copied). And very nicely, `==` is equality out of the box, not identity, so a value type acts like a primitive type. No insanity like `==` and `equals` returning different values for `String`. But the implementation details of a value type might make them not suitable for a value object, particularly if they have a lot of fields. Then, it might make sense to implement a value object as a reference type, to improve performance. It also helps in languages like C# that you can override `==` to be equality instead of identity. That allows a C# `string` to behave like a value object while still being a reference type.
so I can hope this will happen, so I can kill eletron and do javafx + kotlin then native? should I dream for this?
That's what I don't get to this day. If Java is free, you can reimplement it for any purpose. Even if it weren't free, reimplementing things should still be possible. If Google violated some license, it should be sued for that license violation, not because of compatible APIs.
Project Lombok certainly helps. And the necessity to use such a preprocessor strengthens my argument that the java language by itself makes value objects terribly inconvenient. A convenient architecture for value objects would not have required us to employ preprocessors. (Also: shout-out to u/rzwitserloot, who is 1 of the originators and maintainers.)
I've used Apache commons-lang in the past: class Person { public final String firstName; public final String lastName; public final int age; public Person() { ... } public boolean equals(Object other) { return EqualsBuilder.reflectionEquals(this, obj); } public int hashCode() { return HashCodeBuilder.reflectionHashCode(this); } }; It's not the efficient approach, but very convenient. Lombok is awesome because it generates the `equals` and `hashCode` methods at compile time.
Ah! Thanks for the link. Looks like quicksand. Run away! :)
You kind of lost me on your first example. You have a class named `BusinessIdExtractor` with an `extract` method. For me, that seems extremely self-documenting. Anyone with a brain can glance at it and know that what will be returned from `extract` will be a business Id. Yes, it's technically "just some String", but come on. If I were using this API, I'd do something like this: String businessId = new BusinessIdExtractor().extract(token); The variable name makes it completely clear what the String is, without the additional inconvenience and bloat of wrapping it in a `BusinessId` class. If somewhere down the line I try to use `businessId` as, e.g. a name, then that's my own dumb fault. I guess maybe the example is overly simplistic, but as written, I would disagree with your assertions that it it isn't self-documenting and needs a wrapper class. In general, I don't like wrapper classes with only a single field.
Care to elaborate what issues you had while using or maintaining Serialization, so we can all benefit from that?
As you say, I don't decide, you don't decide, that's what the court proceeding is for. And as I said, you don't want to end up in court if possible, because unpredictable things can happen.
Thanks. When I searched for tutorials online it was a lot of people using JSP and servlets. For rest, what you described sounds pretty much near similar to what I’ve been doing bare bones JSP+servlets this whole time.. what’s the difference?
Thanks. I tried googling of course and results largely pointed towards jsp + servlets methods. Even looking for books on the topic on Quora has people recommending books like “murachs java servlets and jsp”. I don’t know what sort of search query you are making but if you can point me to the right direction and give me a road to follow I would really really appreciate it.
But what does this have to do with Java? Oracle is not known for making frivolous lawsuits over it. Even if you think Oracle is in the wrong re Android, even Google wouldn't consider it frivolous. It was an unusual circumstance to say the least, and the defendant anticipated being sued.
&gt;The variable name makes it completely clear what the String is, without the additional inconvenience and bloat of wrapping it in a BusinessId class. The reason for `BusinessId` is for the opposite reason that what I think you are suggesting. It's not to tell you, the reader of the code, that the string is a business id, but using the type system to document that the receiver wants a business id, and because `BusinessId` is an object, that requirement is enforced by the type system, rather than a API comment. Kind of like how `Optional` advertises to the caller that there might not be a value, instead of returning `null` and hoping that the user read the API docs to account for the possibility.
You are talking about something else entirely than what the article covers. But yeah... good points I guess. Value objects even become cheaper with value types.
This is a tad inaccurate. GraalVM is a name of a suite of products. When Graal is used as a Hotspot JIT it's compliant, but SubstrateVM, AKA Graal Native Image -- and that's what's being used here -- is not. Nevertheless, it can run many useful programs.
Clearly we won't agree or convince each other. The way I see it was that Java was GPL, Google didn't even use that, they used a workalike implementation. By May 8, 2007, Sun had completed releasing all of Java under GPL. As I understand GPL, that means anyone can study, modify, and make compatible implementations. Certainly the API code would be under GPL. A compatible API must, be definition, be identical. &amp;#x200B; I don't want to continue this. But I would be informative to me to understand what you think Google did wrong. It would help inform my thinking about that. Because I just don't see it. So please explain briefly what you think Google did wrong, just for my enlightenment. Thank you. (really)
You make a clean cut between backend and frontend. Rest services are the interface. The backend handles database access and business logic. The frontend is the UI. You can choose whatever technology for it. JSP / JSF, templates, some JS framework, ... Additionally the backend can be used by other machines, desktop applications, RIA, ... You can deploy and scale them seperately and have a WAF or API gateway in front of it too.
&gt; Sun had completed releasing all of Java under GPL. Not exactly. [Oracle completed open sourcing the JDK only last year](https://blogs.oracle.com/java-platform-group/oracle-jdk-releases-for-java-11-and-later) (JDK 11). &gt; A compatible API must, be definition, be identical. But it's not compatible, and not intended to be compatible. Even if the API were compatible, Google could have used compatibility as a fair-use defense, but as it isn't, that defense was rejected. &gt; But I would be informative to me to understand what you think Google did wrong. What they did wrong is irrelevant. What matters is whether what they did was illegal. The court ruled it was, but it may yet reach the supreme court. Still, because you asked, here's what I think they did wrong -- *ethically*; I have no opinion about the legality of their actions: they wanted to use Java to gain developers and tooling and significantly lower their costs, but didn't want to have a compatible implementation. They could have licensed it from Sun, but didn't want to pay. In addition, they could have used OpenJDK (as they [have recently done](https://android.googlesource.com/platform/libcore.git/+/refs/heads/master/LICENSE)), but at the time, they didn't want the open source license, either. Licensing Java for mobile was one of Sun's major income sources to fund the development of Java, and by not licensing it, Android both directly attacked Sun's business, fractured Java, and rejected open-source Java, all while employing the tools and the community that Sun had spent hundreds of millions of dollars on. So they employed a company's investment to directly attack its business and in the process hurt an open source project.
Ok that makes sense. I had overlooked that aspect of it.
It's an idea from another land. Paraphrasing Yaron Minsky of OCamML fame, value objects let you make illegal states unrepresentable. Strings can represent anything.
Can it run JUnit test cases? Does it support Gradle and Maven? Can it halt processing during debug at a predefined code line?
Yes. Maven. Yes. * There is a 3rdparty extension for editing Gradle config files, and then you can just use Gradle from the command line in the embedded terminal.
Thank you!
Maybe learn GraalVM, or tune your JVM according to your use case
It looks like in your [submission](https://www.reddit.com/r/java/comments/c0n7vo/beginner_question_about_primitive_data_types_in/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
JavaEE?
Can do, sure.
I'm hinting at Brian Goetz having been *maintaining* serialization for ages and having been ranting about it all the time, and as such, this is the context in which to read his latest rant :)
&gt; Use filters to manage security Nope, don't use filters to manage security. They are not intended for that! Use the ServerAuthModules (SAMs) that Tomcat provides. These are specifically designed for this purpose.
Yes. You can. However today JSF is a better option to learn and use. But good to understand the base jee tech too.
I agree that using `instanceof` is mostly a design error but the need for it usually comes from somebody else's code. There are still APIs that only return Object (like `equals`) and I've seen many XML libraries that only return a "Node" where you need "instanceof" to derive a useful type. And on top of that, you have many low-level APIs like Reflection where polymorphism would be a bad case of overdesign. Instanceof is not bad, it's a necessary evil. Which also means that it can be used as an unnecessary evil.
Nice. I will be downloading.
If you haven't given VS Code a shot before, I would suggest checking it out. It is now my defacto dev environment for pretty much any codebase I work on. (Java, Python, Go). Previously I usually used Eclipse and jEdit. Never was a large fan of IntelliJ or Netbeans, but used them as needed for work. The reasons I really like it I Jump between Windows and OSX/macOS multiple times a day. It works the same way in both with the same plugins. It's free. With the shortcuts and command palette, I very very rarely have to touch my mouse while inside the IDE. (CMD+P / CTRL+P then '&gt;' is your friend) It's fast, can handle large files (gracefully disables syntax highlighting etc) You can easily set Global/User settings and workspace level settings. &amp;#x200B; Downsides It only really works with Java 1.8 or greater. IntelliJ is really good at working with multi-line string values in Java code, including SQL embedded as a String. This doesn't do that. Very Git centric, but there is a reasonable SVN third party plugin Non MSSQL support is very limited Poor Gradle support, really no Groovy support While it has a debugger with support you expect, (Breakpoints/step-in/step-over/etc), the inspection of Java objects (CharSequence/Iterables) shows the guts rather than the representation. Eclipse/IntelliJ are much better in this regard. Each plugin typically supports a bunch of options, but don't be shocked when you'll need to edit the settings.json file directly. Thankfully, it supports auto-complete for settings via JSON Schema.
Thanks, looks better on mobile.
You don't touch my Java!!! Competition is good though.. just had a Hololens project and thought Visual studio is a pest.. didn't get warm with it. Hopefully others can enjoy this!
https://github.com/esaulpaugh/headlong
I guess it will be a nice alternative to three big Java IDEs if you only work with Java irregularly and are famiilar with VS Code from other languages. I don't see it getting close to Intellij any time soon, but competition is always nice. In any case, I'd rather use that than Eclipse :-)
Forgive my ignorance, but what is this exactly? I thought vs code was for the .net ecosystem. IntelliJ Idea is (in my opinion) quite good, why would one use vs code instead of Idea? Is it targetted at developers already into C#/.net and who intend to use java for minor stuff, and to make it easier for them by using the same IDE? Is it intended to compete with Idea? Is it intended to support java development (_where java is the primary language, not an addition_)? As you can probably see I'm quite new - but still, I do wonder about these things.
It looks like in your [submission](https://www.reddit.com/r/java/comments/c0o47m/designing_a_queue_for_async_spring_batch_job/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Demo apps in the store would be a great way to generate interest. Some of the existing javafx demo apps are pretty cool and compatible ones could be thrown into an iPhone demo.
I use vscode already for this, although you may miss some features from intellij. Remember that vscode is not trying to replace other IDEs, and it comes with a number of features that other editors don't have to offer, like better integration with other languages, general purpose text editing tools and plugins, a very customizable interface, and being more lightweight than most. But it does the job pretty well. I prefer having several vscode windows open to having a few intellij windows, and often launch it from the command line inside a directory. It's a different workfkow for sure, and one that isn't suited to everyone's tastes.
Visual Studio is the .NET IDE, and Visual Studio Code is a multiplatform and multilanguage code editor (it's really more like a modular IDE).
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
For frontend code (including mobile apps via Flutter) I prefer vscode over the traditional Java IDEs, usability is great and available actions can be searched inside the IDE without cluttering the UI. Obligatory nitpick: I hope the added exposure adds some more pressure to remove the anachronistic Eclipse artifacts in the vscode-java plugin, like random `.project`, `.classpath` and `.settings` files [generated in the middle of the project folder](https://github.com/redhat-developer/vscode-java/issues/618) or [appropriating the `bin` folder](https://github.com/redhat-developer/vscode-java/issues/634).
I'm a fan of this idea
Very nice initiative. One thing I always end up missing though is advanced refactoring and searching options as present in other IDEs.
&gt; The fact that JSON is considered a viable encoding strategy for nearly all services underscores the fact that Java serialization is solving a much harder problem than it actually needs to. I wonder how loose the idea of "viable encoding strategy" and "nearly all services" is. Most of us have made our peace with JSON. It's main advantage is in its dead simple (I'd even say dumb) representation of data that is mostly human readable. But I doubt any serious developer who has worked with it over the years feels like all the ceremony needed around it on both sides (sender and receiver) in order to correctly parse out all the data we need could actually fit into that idea of "viable encoding strategy." All we've done (usually) is move the complexity of encoding or parsing the data into a new layer in our application. I recently had an issue parsing a date from JSON to a LocalDate type. That kind of thing comes up all the time.
Project 16x16 :D [https://github.com/Stephcraft/Project-16x16](https://github.com/Stephcraft/Project-16x16)
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
That actually looks kinda fun! If you don't mind, can you add me to contributor list? My github account name is RedDogCode.
Look at the [README.md](https://README.md) we have a discord server you can join👍
Okay, so it's just a flat out good editor that now has better support for java?
https://line.github.io/armeria/ https://line.github.io/centraldogma/
Yes.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
https://github.com/WPIRoboticsProjects/GRIP Basically a GUI for creating OpenCV pipelines, with some extra bits on top
Will hopefully be introducing Kafka and Spring Cloud at work.
It used to be JetBrains astroturfing here, now it's Micro$oft. \[Developers, developers, developers!\]
oh cool, what's it used for if you don't mind me asking?
&gt; that now has better support for java Than VS Code had previously, not relative to IntelliJ IDEA Community. Minor clarification. I use both every day. VS Code for JSON, TypeScript, HTML, Markdown, various scripting languages. IntelliJ IDEA for Java (and Rust currently as VS Code integration has never worked as well for me).
Visual Studio and Visual Studio Code are completely different things though.
Without a viable Java alternative, they would have to switch to a 3rd-party solution *with no extra platform / language baggage* ~~, and then switch again to the official Java replacement when it arrives~~.
It encodes ethereum smart contract function calls so that they can be broadcast across the network and executed. This will also decode the function return values
Yes, sometimes the use of `instanceof` is inevitable and necessary. &gt; I've seen many XML libraries that only return a "Node" where you need "instanceof" to derive a useful type. I do not know any real good XML library in the Java world unfortunately. The old JDK API is paticularly bad. &gt; Instanceof is not bad, it's a necessary evil. Which also means that it can be used as an unnecessary evil. Agreed, however the pattern matching is neither reflection nor a low-level API. Simplified it is nothing more than an if-else statement with a syntax for easy use. Often that if-statement includes an "`instanceof`" / type-check. For example: return switch (shape) { case Square(double a) -&gt; a * a case Rectangle(double a, double b) -&gt; a * b; case Circle(double radius) -&gt; Math.PI * radius * radius; } Is something like: if(shape instanceof Square) { return Math.pow(((Square) shape).getA(), 2); } else if(shape instanceof Rectangle) { return ((Rectangle) shape).getA() * ((Rectangle) shape).getB(); } else if(shape instanceof Circle) { return Math.PI * Math.pow(((Circle) shape).getRadius(), 2); } Of course pattern-matching made it way more readable and it's easy to write. Too easy maybe. Because I'd say the design is bad in this case: The logic should have been placed inside the concerning class. It's a perfect fit for polymorphism: `return shape.getArea()`. The client doesn't need to see the internals. It's not leaking and cohesive. If you have a `Shape` already, you don't need to import any area-calculator. &amp;nbsp; So I think many examples that pattern matching is supposed to help are actually better of done "where the information is already present". That includes most use-cases with `enums`. However there are also good examples for pattern-matching. E.g. when the the types to pattern-match over are too loosly related, you don't want touch the concerning classes, the logic doesn't make sense to be in there or you can't because they are not yours (See Integer, Byte, ... example in JEP).
These are all so very cool, so I'll share what I'm working on! I'm working on several projects, but my most recent one is a one I call OverTheWifi: https://github.com/RedDogCode/OverTheWifi The entire purpose is to create an open source, cross platform wifi-based data transmission SDK and so far the results are pretty promising. I managed to make it work with Android on a test application, and I will have to refine the code within the next few releases but it's so far going great, no bugs. My other is a bot I call Kara. Kara uses Python and has many features including a custom consciousness, basically an extension system to extend Kara's capabilities. The URL is https://github.com/RedDogCode/Kara . I hope to use machine learning and natural language processing client side in the near future to expand upon her responses, and to create an interface for her. Anyone is welcome to DM me if they want to contribute code to any of my projects.
&gt; and available actions can be searched inside the IDE without cluttering the UI. FWIW, [Find Action](https://blog.jetbrains.com/idea/2009/06/find-action-saves-time/) (bound to ctrl-shift-a) in all the JetBrains products will search through all actions, (visible or not), the preferences, and I believe the intentions, too. It's so overwhelmingly useful that I've started to lust after it in every application I ever use. Searching through menus is for people who aren't busy. As one might expect, it also displays the bound keyboard shortcut for any action, so you can switch from searching for the action to using its shortcut and still never know where they hid it in the menus.
I'd rather use Notepad than Eclipse. I'm pretty happy with IntelliJ but I'd love for vscode to be an alternative.
You forgot the main downside - VSC is slow af.
&gt; all the JetBrains products ewww
Yeah, no. If you mean the default Windows text editor, it's close to being the worst graphical text editor there is... and it's not an IDE.
That's the joke :P
All that's coming through here is static. Eclipse is a perfectly good IDE at least as far as Java and I'd sooner use Notepad++ and half a dozen editors than use windows notepad except maybe for reading text files or a very quick edit of a settings file.
idk what you're talking about, it was literally designed to be super fast. If yours is running slow, you are doing something wrong. Like having a f**k ton of plug-ins always so it has to load them. for this issue, you're supposed to have different environment profiles for your different use cases so you aren't loading unneeded plug-ins. What editor is faster then vsc that has so many features of an IDE? It's definitely faster than traditional workplace ides
Oh dang you're the GRIP guy! Love the app, been using it for FTC for a while!
https://www.gnu.org/software/emacs/
The Gradle support is not very good yet. Here's the primary Java extension: https://github.com/redhat-developer/vscode-java. Granted these days I sometimes use Code instead of IntelliJ as some actions (e.g. opening a menu) has become very slow on the latter.
Thank you!
https://torbuntu.github.io/Leikr
Does go to definition happen instantly like in the other Java IDEs, or do I have to endure the VS Code loading spinner as with Typescript/Angular?
Should be fast as it uses the Eclipse Language Server behind the scenes.
It has most of the commonly used code actions now. Give it a try and let me know?
Java support on VS Code is provided by the Red Hat extension "Java Language Support", which uses the Eclipse Language Server behind the scenes. Because of this, these files are generated. But in latest versions, these files are automatically hidden and users should git ignore them.
Faster than Eclipse and IntelliJ. Slower than vim. I can respect your preference, but it's fast enough for my tastes.
I misread. You're absolutely right. Was reeeally tired.
To be honest, VSC with Java is not *that* fast, although I'm guessing it's due to the JDT based language server that is slow. I've often seen the code completion loading for the most simple things over and over again.
Right, but I think it's fair to say that this is sweeping the problem under the rug. It would be nice to change that behavior at the root, i.e. Eclipse itself. Ideally, it would generate those files inside a `.eclipse` folder, with something like `.eclipse/private` containing files that shouldn't be added to version control. I really appreciate your work on this though, that's my only little gripe with it, everything else is awesome! :)
That's good feedback (.eclipse folder). I'll pass it along!
No, these technologies from the end of the nineties do not cover even a fraction of the requirements for a even a simple web application and they are obviously not state of the art. A fully functional web app will require an API with security, authentication, authorization, caching, monitoring, performance, maintainability, easy testing, logging, internationalization, scheduling, zero downtime deployments and many other features which you can only reasonable accomplish using a framework like Spring Boot or Jakarta EE+Microprofile in combination with many other libraries and frameworks. Parallel to this, you may want to have a modern UI which supports security, data transmissions, data query, internationalization and other features plus having a good UX, which is something you will usually do with a modern Javascript framework or even a native solution for mobile devices or desktops. And finally a fully functional project may have a complex architecture and infrastructure, and therefore you will find that topics such as container orchestration or CI/CD are also a huge part of this. Don't listen to anyone given you simple advises. Creating a functional web application nowadays is not hard, but requires a lot of effort and the combination of a lot of different methodologies and technologies.
I am working on "Retro Commander". It's an RTS game for PC, Mac, Linux, iOS &amp; Android. [https://twitter.com/noblemaster/status/1139801922783682560](https://twitter.com/noblemaster/status/1139801922783682560)
Is there a difference with a typedef in C?
Thank you.. if you don't mind me asking ,where do you learn all of this and when you were a beginner how did you tell what was bullshit and what wasn't? I go online to search and many different resources point me towards going down the jsp+servlets path and I don't know any better. Also, learning spring mvc now.
But java remote debugger is horribly slow
What's your machine specs? It is slower than sublime text but it is definitely much faster than IntelliJ / eclipse even on my previous dated machine. Try reinstalling or try installing the insiders version or explorer version too.
Nearly same here. I use vs code for Java too and I only fire up IntelliJ if I need to remote debug something over java. Rest I don't miss much IntelliJ
First, you need to stay informed and up to date. Reading material from websites, blogs, Twitter, Github projects and so on is a good start. But most important, you'll have to invest hundreds of hours to learn to program. &amp;#x200B; For the time being I recommend you building a Spring Boot project and run it with Docker. After that compare it to a Jakarta EE project with Microrpofile and run it with Docker too. From there, just keep testing adding more functions to your project.
I have tried it on multiple machines, both laptops and desktops, with 7th gen Core i7 CPUs and 32GB RAM. Slow AF for any project more complex than hello world.
Definitely slower than IJ multiple machines I've tried.
IJ is faster in any scenario on any device I tried.
reading conventions. Javadoc can easily tell you if the setter does something specific or not. easier to tweak afterwards.. if you want to remove write access to some properties. Also setters allow to for more than one change parameters Swift tries to remove all setters because muhhh verbosity.. guess what.. they can't in the case above... you still need to do button.setTitle(title: String: state: State)
ok thank you for your input. I didn't imply that you did. But every kotlin fan boy shouts Kotlin has coroutines. Kotlin's better. So in my mind, the matter wasn't settled clearly, until i asked you and you answered. since you are knowledgeable.. is the type erasure the same in Kotlin and Java?
What about the good old *if/else*?
i got massively downvoted lol RoboVM was a tech gem that enabled Java apps to run on IOS flawlessly as soon as 2012. Imagine that. Few people knew about it. You didn't have Xamarin at the time. I fault Oracle for being myopic here. Anything related with client on Java is mismanaged. Anyways.. games (libgdx) like Ingress (ancestor of Pokemon GO) run on RoboVM ... or used to.. until RoboVM got bought by Xamarin with the intention of selling itself to Microsoft. What's the first thing Microsoft did? Does Microsoft like Java? Gluon is using a fork of the last open source RoboVM. Movidevelop is another fork. But all the valuable closed source add ons for which game companies paid RoboVM creators a license are gone. MS took the tech and applied it called it Xamarin to push its C# stack on mobile devs. Java community lost a lot of time. If only Oracle had bought RoboVM...
I am far from knowledgeable 😀 I've used both Kotlin and Java in several projects, so I have some experience with both. Type erasure is pretty much the same in kotlin as it is in Java, but Kotlin has those reified generics, they work somewhat like templates in C++ where the code for that type is generated, there are some restrictions where it can be used though
&gt; Of course I can create another class with the same code but change the name to parentSendMail and then call it in the parents Servlet but I feel there must be a better way out there to accomplish this. You can make your SendMail class abstract and give it two children, UserSendMail and ParentSendMail. Shared code goes to the abstract class.
Programming help should go in /r/javahelp. **Removed**
Hello Holothuroid, If I do as you said, wouldn’t I be repeating the code? Cos the method itself is pretty Long. I am thinking of using a filter method so that if day the user email is null since the user servlet is not invoked then it will use the parents email. My problem is if the 2 servlet are invoked at the same time then how do I overcome this problem?
https://github.com/nhl/dflib Lightweight pure Java implementation of a common DataFrame data structure. With DFLib you get essentially the same data manipulation tools you may be used to in SQL (such as queries and joins), only you can use them in-memory and over dynamically defined data structures. Not my project but an interesting new one that's seeing active development from a very competent developer.
&gt; you get essentially the same data manipulation In Soviet Russia, the same data manipulation get essentially **you**! ^(this post was made by a highly intelligent bot using the advanced yakov-smirnoff algorithm... okay, thats not a real algorithm. learn more on my profile.)
&gt; you get essentially the same data manipulation In Soviet Russia, the same data manipulation get essentially **you**! ^(this post was made by a highly intelligent bot using the advanced yakov-smirnoff algorithm... okay, thats not a real algorithm. learn more on my profile.)
I would recommend to open an issue on their GitHub.
I'm going to work on a flash card android app. I want to be able to put information in excel and import it into the app for easy use. After that maybe an app that can help me plan my life better.
That's a cool project but the reason behind creating apis is abstraction of internals. Since I cannot evolve my implementation without breaking the API this is basically the same as exposing a database to the world.
I repeatedly tried to use Codenome One for creating apps for IOS and Android. That should count for a challenge!
VS Code is my favorite 'lightweight' text editor on Ubuntu, like when I need to paste some JSON or XML, format it and browse through it.
I found a postfix plugin for Eclipse but it is rather abandoned by the original author (5 years last commit) and he is not really accepting PRs as far as I saw and the whole plugin pipeline is kinda icky, so I wanted to get it up and running. Also, the IntelliJ plugin is far ahead and I wanted to look if I can adapt some postfix commands like `.switch` or `.if` &amp;#x200B; * original [https://github.com/trylimits/Eclipse-Postfix-Code-Completion](https://github.com/trylimits/Eclipse-Postfix-Code-Completion)
Yeah, it's pretty nice. Sometimes I feel all that smart search is making me dumber though: I don't know the names of executables or where they are under windows, just try some keywords in the search. Too lazy to type correct URLs, just mash some letters contained within, the search engine will figure it out. Retention vs. recognition etc., but that can't be healthy.
I think the existing eclipse setup is good. It allows me to easily import projects into eclipse when I want and enables the Gradle eclipse plugin project generator (./gradlew eclipse) to work for vscode. The eclipse files can easily be ignored using gitignore are not a problem.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
[https://github.com/pgjdbc/pgadba/](https://github.com/pgjdbc/pgadba/) \- an async database driver for postgresql
Good as an editor, unusable as an IDE. It's sluggish as hell on any big projects.
"Good questions hard to answer", I think that's the point. You challenge yourself by answering questions you don't know the answer to at first, but can find the answer to. Also, writing down a difficult answer can help improve your communication skills.
Also see https://blog.habets.se/2010/09/gettimeofday-should-never-be-used-to-measure-time.html for more on the topic of monotonicity.
Anyone can confirm the Performance Benchmarks? I thought log4j2 was superior for performance against all other multithreading loggers. Would like to get some insights on how they manages to beat log4j2. :)
In practice this bricked some iPhones some months back, so it did allow it.
You can find the benchmark code here: https://github.com/pmwmedia/tinylog/tree/v2.0/benchmarks Maybe have a go at it? I haven't run them myself
This is interesting to me, because as someone that lives in VS Code and IntelliJ I get irrationally angry when I have to fire up IntelliJ just to do a quick edit/compile. Maybe it's just that my projects are far different from yours, but for me needing a full IDE to edit code is sometimes an inconvenience, particularly when I'm swimming between several languages at once in VS Code. Adding Java will only be a good thing for me, and using the video in the link I was spitting out to the console frame in minutes on Ubuntu. For me VSCode lives somewhere between a text editor and an IDE and firing up IntelliJ feels like 'breaking out the big guns' to tackle a problem.
I use Notepad++ for small edits. I've also limited myself to using only Java and TypeScript, so IntelliJ does the job.
How does it infer calling class and method name from a static method ?
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Sure, everyone in the Eclipse world got used to it. For newcomers it's suprising though: Only default settings were used, so why do those files exist at all? Eclipse assumes ownership over all aspects of a project. That was necessary in a time when Eclipse *was* the build and dependency management tool, there was no standard directory structure etc. But hat role is now filled by more specialized tools like Maven / Gradle. So it seems to me like most autogenerated Eclipse configuration is superfluous at this point. But let's assume they are necessary. The most obvious question when seeing those editor specific files is: Which ones do I need to check in? Having well defined places for files that can be shared and those that shouldn't answers the question immediately. It's also more flexible for Eclipse: New Plugin needs its own configuration? Nobody needs to update `.gitignore`, because the parent folder is already there. Major refactoring of config file structure? Nobody needs to update `.gitignore`. There already is `.idea`, `.vscode`, `nbproject` (NetBeans also keeps some files like `nbactions.xml` outside that directory, but at least it's clear that they should be checked in), so having `.eclipse' makes sense to me. It's respecting the project structure by only reserving a small domain for the IDE that doesn't conflict with the actual project files. From reading the bugtracker I understand that this would require a massive coordination effort of different plugins, but maybe the time has come. At least on the surface, it seems like looking for a folder like `.eclipse` first before falling back to the current behavior wouldn't break existing tools. This was a pretty big rant, sorry. But that's my main gripe with Eclipse.
Agreed, it's an unfortunate example. I suppose it was an arbitrary choice to demonstrate the conciceness of switch expressions rather than the semantics. Personally, I am much more excited about the concept of Deconstructors: Point(int x, int y) = point; It's essentially a named tuple structure.
Does somebody have experience with TinyLog2 and can make a comparison with more established loggers such as log4j2? I'm currently trying to find new logger libraries and would be interested in some opinions :-)
google's Flogger framework will generate a stack trace and use that to figure it out, but, unlike tinylog, you do create a field for it (`private static final FluentLogger log = FluentLogger.forEnclosingClass()`) so you eat the performance cost of that song and dance routine only once for each class being loaded that wants to log stuff. There aren't any other options, really, unless you involve post-compile plugins, annotation processors, build tool plugins, etc. This code straight from tinylog2's git repo: https://github.com/pmwmedia/tinylog/blob/v2.0/tinylog-api/src/main/java/org/tinylog/provider/LoggingProvider.java strongly suggests it does the same thing, but on every log invocation. I conclude that I'm either missing something big, or their claims about performance are blatant falsehoods.
My company works with OSGI and relies on BNDTools in Eclipse for a lot. I would love to switch to vscode as my primary too but the OSGI part is a blocker. Anyone have experience in that arena with vscode?
https://www.gnu.org/software/emacs/ https://melpa.org/ https://elpa.gnu.org/
If eclipse used a .eclipse folder then that would be great, but otherwise it would be breaking compatibility and the only benefit I see is less clutter.
JDK 13 EAB is now available [here](http://jdk.java.net/13/). It includes the previews for `switch` expressions and text blocks.
TLDR: use jooq eh ... it has its places i suppose. more often than not ORM is the better choice. unless you know for a fact that jooq is better for you, go with ORM.
How many logs need to be "reinvented"?
Maybe you have some badly behaved plugins? That does sound rather long...
VS Code is very quick to greet you with editable files, that's true. But the Java language server only seems to get going 30 seconds later or even more for me. As for Intellij: I simply never close it except for updates.
The LoggingProvider implementation ends up [here](https://github.com/pmwmedia/tinylog/blob/v2.0/tinylog-api/src/main/java/org/tinylog/runtime/LegacyJavaRuntime.java) on Java 6-8 and [here](https://github.com/pmwmedia/tinylog/blob/v2.0/tinylog-api/src/main/java/org/tinylog/runtime/ModernJavaRuntime.java) on Java &gt;9. For 6-8 it's throwing an exception to capture the stack trace, and on &gt;9 it uses the StackWalker API. As far as I can see it does this for each log invocation. I'm struggling to see how this can be faster other logging libraries, particularly on Java 8.
[Relevant xkcd](https://xkcd.com/927/)
Inheritance is only a problem, when you have inheritance. And as the old saying goes, we should rather use composition in the first place.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
annotations are cancer but ok
Hi, I'm the founder of SwiftWaiver, an electronic waiver company that specializes in customer photos for the escape room industry. Sucks that I'm not a technical founder, but I work with a team overseas in India who were initially able to get my project up and running with a lot of bugs which have ultimately been fixed but the bugs always hurt the brand you know. Our project is pretty stable now and we have a few paying customers and I'm strategically positioned in the market because I also run one of the largest escape room start up group and help consult with a lot of new business owners which is how I closed a few of my deals. We scraped an email list and my virtual assistant cleaned up the leads list and we're pretty much ready to load the list in and launch a cold email campaign however our apps are a bit subpar and we're working on converting our hybrid app to native so that we can be up to par with our 2 other competitors, we also have other companies that I invested into which I'll be bundling with our product which kinda hedges the risk and it's worked so excited. I actually made a post in another thread looking for an experienced java developer with google cloud engine experience because most of the developers I'm finding have java experience with little knowledge on how to navigate around gce. Y Combinator is around the corner, maybe I can find a technical co-founder in this thread.
Hey, My friend owns a crypto publication blog, so feel free to reach out to me if you ever need PR for your projects.
Removing licensing from the equation, what would be the reasons you'd choose an ORM rather than JOOQ? Just familiarity of more developers with ORMs or what? I've used JOOQ for the last couple of years and Hibernate for 10+ (and before that TopLink) - I'm not sure I would choose an ORM over JOOQ purely on technical merit.
You forgot Spring JDBC Template and QueryDSL as alternatives to an obfuscation layer (ORM)
I always viewed ORMs as an anti-pattern. The extra layer of obfuscation they tend to add to the data layer outweighs the "boilerplate" code people complain about. The pendulum tends to swing in the opposite direction when the headaches introduced to solve a problem overshadows the benefits the supposedly bring. To each their own I guess.
What about a GUI to track IP addresses?
I've learned that arguing against a trend is a bit like pissing against the wind. It doesn't matter if you're right or wrong. &amp;#x200B; It's like walking in Berlin in the early 1940s and saying "hey, has anyone thought through the negative side of all this Hitler stuff?" &amp;#x200B; Just let everyone individually shoot their own individual feet and try to focus on implementing good practices in your own workplace and projects.
The last time I worked with a database, we used Groovy’s database stuff which is a lot closer to JOOQ than an ORM. I really liked that I could use my expertise of SQL instead of having to learn all of the ins and outs of using an ORM for the specific data model we were using (which I had to do before). I’m not a fan of solutions that make the easy things easier but the hard things harder.
I presume the Groovy DB stuff is all dynamically typed? It's the combination of explicit SQL plus static typing that makes JOOQ a big deal for me.
There's no point to the [performance numbers](https://tersesystems.com/blog/2019/06/03/application-logging-in-java-part-6/). The performance benchmarks for all the logging frameworks are measured in nanoseconds, and they can all generate gigabytes of logs in minutes. The real problem is what to do with the logs afterwards.
Anything specific you're looking for? Features you're using, etc?
I don't know, but I think it looks at the current stack, and gets the method from there: new Throwable().getStackTrace()[0].getMethodName()
Well, if you look at log4j, slf4j, and logback, they were all written by the same person. Might be a reason?
The amount of time wasted globally on logging frameworks is unfathomable
Whenever I see this overblown "boilerplate" issue come up regarding JDBC, I always try and set this straight. I'll leave a recent comment I made: I always viewed ORMs as an anti-pattern. The extra layer of obfuscation they tend to add to the data layer outweighs the "boilerplate" code people complain about. The pendulum tends to swing in the opposite direction when the headaches introduced to solve a problem overshadows the benefits the proposed solution supposedly brings. To each their own I guess. With a couple of helper classes, your up and running with straight JDBC calls leveraging the full power of SQL. I'm mystified beyond words sometimes the love affair some devs have with ORMs in general.
Python is easy and you can develop with it really fast. Give it a try :)
I don't know why you're getting downvoted. Python is perfectly suited for his use-case. I think you're just getting downvoted for choosing anything but Java seeing as we're in /r/java.
Thanks for the input.. Will try it.
I would choose Java.
I think the language doesn't matter at all, use the most comfortable for you. But if you like learn something new, try python, it knowledge path is simple and maybe for simple automated task you wouldn't need too much info about how python works.
Python. Alternatively if your on windows doing a lot of windows specific tasks powershell is better than people admit.
I will try Java, just because I have some exp with it. And if implementation is hard or there luck of libraries for these tasks, then I will try Python.
Thanks for the inputs.. Hope there isn't much like dynamic polymorphism in Python..
Thanks for the inputs.. Majority of tasks involving fetching data from some legacy ERP &amp; other data sources and creating data dashboards.. few other task are file movements for data maintenance ...
Thanks for the input..
Thanks for the input..
What are your system specs? I am running IDEA on a PC with Core i7 6700, 32GB RAM, and a 3 year old SATA SSD.
That post doesn't really seem to address contention and the universal scalability law.
Python is easy to use.
I wouldn't choose an ORM over jOOQ but I'd choose raw SQL over jOOQ. While jOOQ gets you closer to the lowest common denominator of SQL, SQL removes the impedance mismatch entirely -- _and_ it immediately exposes all the functionality of the underlying database. I like Jdbi 3 (but I prefer not to use the annotations).
I would try python... Gives you an opportunity to learn something new 😀 I am a Java developer, but tried my hand at python to sort out 200 gigs of photos (my wife likes then organised a specific way). Was good fun.
Well Python is an OO language so there is, but for automating excel spreadsheets you can keep everything very simple. FYI check this out https://automatetheboringstuff.com/chapter12/
Thanks for the link..
Thanks for he input
Thanks for he input.. You have good use case compared to mine !
Java 11 introduced the [ability to run](https://openjdk.java.net/jeps/330) single-file source code files so you can almost use Java as a scripting language. There are limitations like only first class in the file gets run, only standard library, but it could get you started with simple tasks.
Don't think any use case isn't good if it means you learn from it and it helps save you some time in daily life
Thanks for he input.. Will try reading into it.
It looks like in your [submission](https://www.reddit.com/r/java/comments/c18mqt/how_would_you_do_this_code/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
&gt;Because the usage of SQL with the Java API JDBC (Java Database Connectivity) is painful and error-prone the first choice is usually an ORM like JPA/Hibernate. Painful and error-prone? Why? JDBC is one of the simplest, cleanest and most one of the most stable APIs out there. There's nothing painful about it. I view ORMs as tools to keep going with a failed design that doesn't do abstraction and generalization so you end up with a framework that can automate your bad design.
Yeah python is a good scripting language. But if you already know java; you’ll probably just be quicker doing it in java.
It looks like in your [submission](https://www.reddit.com/r/java/comments/c18tqq/a_diagram_i_created_that_shows_the_relationship/) in /r/java, you are looking for code help. /r/Java is not for requesting help with Java programming, it is about News, Technical discussions, research papers and assorted things of interest related to the Java programming language. Kindly direct your code-help post to /r/Javahelp (as is mentioned multiple times on the sidebar and in various other hints. Should this post be not about help with coding, kindly **check back in about two hours** as the moderators will need time to sift through the posts. If the post is **still not visible after two hours**, please **message the moderators** to release your post. Please **do not** message the moderators **immediately** after receiving this notification! Your post was removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Thanks for the input..
Hibernate doesn't make the hard things harder. If you want to run SQL, that's just calling `createNativeQuery()` instead of `createQuery()`.
SLF4J is very different from log4j and logback. SLF4J is an API, and not a logging framework. Logback is the native logging framework for SLF4J and both were developed based on the authors experiences with log4j.
I agree with this. I started a new job six months ago and we used an ORM. It was my first time working with an ORM in an Enterprise scale application. It has given us so much grief lately I can't even begin to do it justice. A decent chunk of it was our own fault for misusing it, but none of the problems would've happened if we had just been using SQL. Oh and these problems I'm talking about were causing the app to crash. 😂
JPA does a ton of magic to allow you to work in the object model instead of the DB model. It does make hard things harder if you find that your web of relationships between entities are being eagerly fetched with a new connection opened for each one at one point in your code. That's a real example my company had to deal with. It was causing our app to crash and it took us two weeks to weed out all the spots this was happening in.
Sounds like you should first study HTTP. That is the protocol for sending requests across the web. Most things you have mentioned wanting to do in this thread require HTTP. Understanding how HTTP works won't help you build the app, as it's not code you can write. It will however help you understand how to use whatever technology you choose to go with when you start coding.
Nothing specific. Mostly readability and easy of use. Speed isn't critical as long as it's not excessively slow. Some configuration would be nice, but not a config hell.
You could consider TinyLog as the implementation, and use SLF4J as the facade. That way, if you ever run into an issue, you can replace it by a different implementation without issue. Just an idea
And you can skip all of that and work directly with SQL and get a map of results if you want.
I wrote something to do daily tasks and decided to go with java as I like the concurrency model with completable futures more than pythons concurrency (my opinion) It was nice Specifically when I wanted things to happen in stages - and I learned a ton of stuff about java concurrency
I've got an i7 4770k with 32 gigs of RAM as well, also running on some SSD.
The JDK has always had a large feature-filled versions every six months (e.g: [7u4](https://www.oracle.com/technetwork/java/javase/7u4-relnotes-1575007.html), [7u6](https://www.oracle.com/technetwork/java/javase/7u6-relnotes-1729681.html)). We're now just giving them an integer number.
Whether you stick to LTS or update to new feature releases, your upgrade frequency will need to be the same for a similar measure of security. If you think that upgrading, say, 11.0.1 to 11.0.2 is significantly less disruptive than, say, 11.0.2 to 12, then you need to learn more about what the new JDK upgrade models are (feature releases vs. LTS). Neither of them is similar to the old model, and they don't quite mean the same thing as in other projects.
So i have a lot of experience in java, but nearly none in python. But for the tasks you described, i would recommend python
Thanks for the inputs... Do you have any suggested frameworks / api to look into it specifically
Thanks for the inputs
Completable futures are part of the java sdk 1.8+
I'm a software engineer with \~5 years of experience total, 4 of those years I've been using Java, while slowly transitioning to Python so I have about 1,5 year experience with Python. Sometimes I have to work with whatever language they throw at me so I've touched a fair bit of other languages: JS, C#, Groovy. In my opinion Java is a great language for stable, long-lasting, large-scale projects because of typing, scalability and robustness. Python on the other hand is great for scripting, automation and small projects with fluctuating requirements, because of the fact that you can make changes very quickly without a lot of boilerplate code.
If you want to learn python, learn python. If you already know java and just want your scripts fast, do it in java
Surprise no one has mentioned Groovy. It runs on the JVM so you have access to all existing java libraries but it has some nice syntactic sugar. You can also just start writing it like a script I.e. you don’t have to put your code in a class (but can if you want). What is also nice about groovy is all Java code up to 7 is legal groovy code so you can always write java code as groovy until you pick up the groovy way. Groovy already had support for most of the Java 8 language features so it doesn’t need support for java 8 syntax (although it is being added or has already been added, haven’t checked the status of that recently).
That is a marketing piece for Jooq thinly disguised as a blog post.
Is your desktop / laptop locked down at all? Make sure you have access to install everything you’ll need before settling on a language. Aside from that, for what you described, python seems like a better fit. Check out https://automatetheboringstuff.com/
depends on your data composition and whether your data is mostly of numberical nature or behaves more like real entities. Entities have connections, which is where ORM really shines. It's a technology with pros and cons, so it depends on your use case. Don't forget: If the only tool you have, you assume your problem is always a nail...
I think it does: contention and the universal scalability law are not relevant, because logging is not a bottleneck. There is a paragraph about using an lmax disruptor based async appender, which is a lock free ring buffer: &gt; I'll skip the benchmarks and discussion about the ideal configuration, and just say you should use an async appender to wrap writing to file or network, and add a shutdown hook to close it safely.
Written in Visual Basic, right?
I like Spring Data Repository lately, seems pretty powerful.
If you are on Java 9 or later. java.lang.System.Logger is a nice little logging framework. System.*getLogger*("somename").log(Level.***ERROR***, "Oops") No dependencies except java.base, you can easily install your own implementation via a service loader.
Thanks for he input
Python is a more productive language for 1 man scripts under 1k lines. &amp;#x200B; Then again, kotlin, clojure, scala and other JVM mixes might be competitive, and for example scala, if you get really good you can move into things like spark with better performance traits than if you spent all that time on python.
What're you using it for in FTC?
Python is my favorite way to work with CSVs and XLS (excel) files. Super easy to pick up for Java programmers. I definitely recommend it. It’s honestly just an afternoon of syntax work. You’ll find it to be super functional.
Yes.
If it makes sense, yes.
Depends. Not as a rule, because streams can be very inefficient. Where speed doesn’t matter, yes, because they look nicer and reduce LOC.
Why can streams be very inefficient?
Yes, we started using them a few years back.
Just google java streams performance. There are several articles detailing this.
It takes time to set up a stream pipeline. If your stream contains only a few elements, then it is more efficient to use loops instead.
Yes, but not for pragmatic reasons. Some of our stuff looks like a demo for Java 8
It depends. Sometimes I have code that is greatly simplified by using streams. Sometimes it's not worth the overhead. I do use lambdas pretty heavily though. They're just too useful.
Extensively. Wrote my own Either too.
they are 2-4 times slower than simple plain loop
Some have also tried to use `parallelStream()` on a `LinkedList`, which splits terribly.
No. Most of the codebase still on Java 6..
We use lambdas so often but not streams.
they are faster in GraalVM
I hate it when colleagues overuse Optional, passing it as parameters to regular functions, using it as return type for a create method. I mean, it creates something, how can it be optional?
Yes AWS lambdas being used all over the place instead of writing services.
I do all of my Scripting/task automation in Kotlin any more, and if you have a background in Java you'll find it easier to learn than Python.
Kotlin brings you the best of both worlds.
Yeah, but it's made the codebase more difficult to parse and read. Some places it's loops, some places it's lambdas/streams/etc, and the Java8 stuff seems to take about twice the space in code vs the older way of doing it, and is less flexible if it needs to be modified.
For those who may not know, lambdas will work with any interface that contains a single abstract method. The interface doesn’t even need to be recompiled. Brian Goetz talks about this [here](https://m.youtube.com/watch?feature=youtu.be&amp;v=MLksirK9nnE&amp;t=9m9s).
They’re talking about [lambda expressions](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html) in Java.
Right, that's what I was saying, but you phrased it far more clearly than I did.
Can you share? That sounds cool
My condolences
Lot of overhead compared to a simple loop. I tracked a huge performance issue in a third-party component down to a use of `.forEach` on a huge (thousands of entries) collection multiple times per second. Once they patched it to use a foreach loop, the performance issue vanished.
We just recently moved to Java 8 from 7 and all new code uses them extensively.
Do managers abuse this cultural relationship or do they make it worth for the underlings to accept the requests and go full on because they know the manager is doing decisions right ?
any half reliable stats about java &lt;version&gt; distribution ?
Eithernet
Absolutely. If used properly and with tasteful styling, they greatly improve code readability and conciseness, a win-win.
If the task is filtering vs iterator.remove, I tend to use iterators. It just looks cleaner imo.
A wise jedi said: only a Sith deals in absolutes. Inheritance is useful. The problem is that some people used inheritance to reuse code (like java.util.Stack which inherits from java.util.Vector). There is a simple way to know if inheritance is relevant: replace the 'extends' keyword by 'is a'. Samples: Stack is not a Vector Set is a Collection.
Lol I was making a joke but I'll take my lumps
They’re probably doing this to avoid NPEs and hoping the use of Optional encourages the consumer to use isPresent to check if the value is there
Constantly. I think they’ve 95% replaced the Old Ways.
Yes, we use rxjava a lot. Some of our source files have 1 lambda per 2 lines.
Lambdas yes, streams decently enough except in the most performance critical code. It also depends on what exactly the code needs to do and if there are potentially checked exceptions getting thrown
Using it as a return type for a method that always returns a non-empty value isn't overuse, its misuse. The exception being if the method is an override.
About 2000 lambdas in my project (grep for ` -&gt; `)
For low-level stuff, not so much (i.e., nested loops that run frequently, where stream latency and object creation would become non-trivial); for static inits and low-traffic things where a simple stream/lambda can replace manual loops and collection-handling, absolutely.
I am guess you are still using Windows XP then 😝
I would be interested to know if the author has a financial arrangement with the author of jooq
Lambdas *are not* just anonymous inner classes. Otherwise you'd get them before java 8.
F
Is there not a good implementation readily available. I'm a Scala/Kotlin dev when on the JVM so couldn't tell you off the top of my head. Most of the complaints I see around misuse of Optional in this thread are where someone should be using Either.
First off, the way lambdas are implemented is not exactly super efficient. Especially dynamic lambdas with an access to some class scoped or method scoped variable. They cannot be cached and so has yo be created and allocated every yime. Second, you need a lot allocations of various support datastructures just to get a simple for loop. You cannot do scalar replacement because those refrences are leaking. Lastly boxing and unboxing of primitive types is simply an overkill to do with streams. Good old indexed for or for each loop will beat streams any day any time due to it's impure nature and ability to have local statr on the frame.
Or you just swap them for indexed for or foreach and save your self one GraalVM proprietary license. The Community Edition Graal compiler in GraalVM will still optimize streams somewhat. Buy hey, is it really so hard just to use simple foreach? Do we need a metacircular compiler so that we can write sloppy code?
&gt; the way lambdas are implemented is not exactly super efficient have a blog post you can link to ?
There are several libraries that give you more monads. It's just that I didn't have much use for another dependency. So I'm not sure which to recommend.
That fair.
Yes, and slow too. for instance you could use anonymous inner classes which are generated at compiletime. No difference there... lambda generation is delayed to runtime so instead of paying the cost at compile time you pay it at runtime and you pay it every time you load a bytecode that needs to spin up lambda factory via invokedynamic.
That is actually an incorrect use of Optional. Any decent IDE will mark such method signature as bad and will warn you that this wrong. Of course, one can ignore IDE hints, because she knows better or whatever.
&gt; Do we need a metacircular compiler so that we can write sloppy code? yes.
Totally! A lot of code review comments in my team are to replace loops with streams!
There are implementations available in several functional java libraries. Here is an [implementation by Vavr](https://static.javadoc.io/io.vavr/vavr/0.10.0/io/vavr/control/Either.html). Theoretically, you'd only need `flatMap` to fulfill the common definition.
&gt; Lambdas are basically anonymous inner classes Yeah there's more to it but it's the same general concept both code-wise and theoretically, just with other stuff added to it.
I am sorry, but they are. To get Java 8 lambdas you need invokedynamic, method body desugarization and a bootstrap method. Everything was doable in Java 7 already. At run time, lambdas are just anonymous classes generated by ASM code in LambdaMetafactory from the signature stored in constatnt pool invoked by invokedynamic opcode.
I suggest you read LambdaMetafactory sourcecode from the OpenJDK.
That’s not true. Their implementation details can change, given the flexibility of indy. Goetz talks about this [here](https://www.youtube.com/watch?v=MLksirK9nnE&amp;t=12m2s).
Nice. Now I start to see why Java devs are often called ignorant and clueless about the hardware their code runs on.
No. Many other devs are from C++ era. They refuse to learn and use new things.
I personally prefer them and shame others for not being as java woke as me if they use a for loops like a peasant. Last project I was on the whole team embraced them. I don't think we had a single for loop.
F
No, it can't. Nothing can change for the gazillions of existing Java 8 bytecode with desugared method bodies in a specific way that is only compatible with the current LambdaMetafactory bootstrap. I mean seriously, even SubstrateVM does not support invokedynamic in full and does not plan to. That is a talk from 2013 for god's sake. Before Oracle's first official Java release. You do realize invokedynamic plays no role in Oracle's current Truffle/Graal setup.
I would have thought that this was already a saturated market.
Yes it can... Goetz talks about it [here](https://www.youtube.com/watch?v=MLksirK9nnE&amp;t=20m8s).
We need this compiler not because java developers are clueless about hardware their code runs, because almost every developer is clueless about it. Can you tell me how much RAM does your production env has and how many cores? How many cores are available to your database and how big DB and JVM cache is? You have no fucking idea, don't blame you, almost no one has. We need this compiler for 100s of others reasons, like polyglot compilation, addon-based AOT compilation (you can write your own AOT
Surely, I've got downvoted because of writing something factually incorrect.
I am really looking forward to the date when the desugared methods of existing precompiled Java 8 code bases move to some other classe at random. Just ping me when that happens.
We have many internal functional frameworks and utility functions utilising lambda/method-references and also use streams fairly extensively, some of the external frameworks use lambda too but there are few of those so far (beyond ones that already used interfaces for commands/events that were already valid functional interfaces). We don't convert our loops just for the sake of it - sometimes the old-style loop is cheaper and more obvious, sometimes the code benefits from composition and being an expression. I would say that streams are probably used more often than the loops despite the performance overheads and increased allocation.
There will be no issue. The whole point of indy is existing code can gain performance without having to be recompiled.
I can even even tell you kernel boot options and the IO scheduler configuration if you wish. As a performance architect, you surely know you can emmit assembly from HotSpot. It's easy to analyze it JitWatch, you know.
The whole point of indy was to provide some level of level of metacircularity on the production grade JVM. This is now a thing of past thanks to project Metropolis, a.k.a Graal and by extension Truffle. The next stage of metacircularity surpases indy in every aspect.
I was referring to the use of indy in lambdas, not the feature as a whole.
Yes, and I did not agree with you. But that does not seem to matter to you.
And slow everything down by a factor of 10
You don’t have to agree. That’s the implementation strategy that the architects chose.
Haha I agree. Sometimes it makes sense to me, but sometimes I'm like the for loop is just the better path though!
Right, architects also architected EE, which was then kicked out and is on life support and webstart and all sorts of things. Architects also invented the original java memory model, which had to be amended and which is still provably broken under some conditions. So, yeah, I've got your point - just ping me when the change happens.
Nah, enterprise software so everything is stuck in a certain way. However during a lull in projects a few of us started working on some new tech, ground up, and we are using reactive streams/webflux so lambdas are used a lot.
[Optional was not intended for parameters](https://rules.sonarsource.com/java/RSPEC-3553)
I once saw a "refactored" code base that basically just moved to java 8 and replaced everything with lambdas and streams. :/
Interesting to watch the downvoting on this comment. The thing is, I actually hear this a lot from people with C background. And my stance is that Java has a really cool tooling if you want to walk the extra mile and write great software - JMH, JitWatch, visualvm, solaris studio analyzer, various disgnostic options etc. Almost all the tools are free, anybody can use them. And I try to as much as I can. I was under impression everybody should try to write the best sofware. If you feel offended by my comment, maybe you should check those tools and see how they could help you. GraalVM will not save planet earth overnight and in my opinion, it may even hurt Java in the long run.
The fact you are even having to deal with "eager fetching" suggests to me you are doing read-only queries with entities. Don't do that, use HQL/JPQL. The only time eager fetching comes into play is if you are having to query a one-to-many for updating/inserting the many side. The fastest way to get into performance trouble with Hibernate is letting it generate queries. The only time that comes into play is for updates. Other than that you should be writing HQL/JPQL.
&gt; JDBC is one of the simplest, cleanest Umm, JDBC is pretty painful to deal with directly. However, a simple JDBC helper library takes the pain away (either one of the handful of ones out there or one you whip up yourself).
&gt; they greatly improve code readability People that say this must be living in the twilight zone or are delusional. Lambdas obfuscate code, they in no way make code more readable. On very rare occasions a lambda may make something more readable, but that is the exception, not the rule.
I think if you are familiar with them, they are understandable and help code readability (if used properly with code styling, as I said before). If you're not familiar with them, you don't use them often, maybe you're a junior or new to the language, then yes, they are definitely not helpful and obfuscate. I felt the way you do before taking the time to familiarize myself with them.
It's not far off the same. Streams can be really useful (a godsend for more complex maps or multidimensional arrays), but they aren't always the most readable thing. Too much of our code has been done by people who both refuse to document, and base their ego on how unreadable their code looks, unfortunately, so every loop is a stream.
I'm sorry you work under somebody who is clearly incompetent. That's the worst reason to do a code review. Code reviews are for inefficient and/or unreadable code. There's nothing unreadable about for loops, even nested ones, especially if they're well commented. And since they're forcing you to refactor old code to be MORE inefficient, the business is suffering overall because of this.
Oh wow, this is exactly what I feel about some people, they seem to display pride over their code being unreadable. Some times it seems like that's kind of the culture a team can choose to promote too.
No one used tasteful styling on my last gig, and lambdas made the code a mess to read. Dunno how it would look if styled well but I was do relieved to get onto a project with "old" iterative code you could just read it, rather than trying to parse through an inline lambda creating an inline completablefuture surrounded by try/catch. I've yet to see any well written lambdas that are really better than iterative versions...not always worse but never better...only examples are playing tricks where they poorly implement the iterative code then write really well formatted lambdas.
Lambdas: Yes, a lot. They're great. Streams: Too much, and it's making some otherwise trivial loops slower.
^ The most accurate comment in the thread, sadly.
&gt; However today JSF is a better option to learn and use. Are you that one guy who keeps trying to push the dead and let die Jsf stuff?
Ty qt. I'm going to mention your dirty for loop at standup though :(.
Yes, and they are wonderful.
No, its cause you're an asshole and provide no sources.
I rarely ever see it except for in my code. At best, I'll see some streams filtering and mapping a list, but rarely anything more complex.
I've seen new code bring written using the default Serialization in the last year, putting java objects in a Reddis cache. If you forgot to implement java.io.Serializable it would throw exceptions.
You must have an extremely unusual title or department structure. I've never heard of an environment where such different specializations fall under the responsibilities of the same position. Particularly not in a language designed to run in a virtual machine. It's sounds really inefficient or extremely specialized -- or perhaps both.
F
yall need new management
Oracle make bucket-loads of money from so many other avenues. Enterprise Software licenses, cloud hosting of their services, absolute bucketloads through consultants. There's an entire ecosystem of profit generating projects in Oracle's portfolio. I would think it's in their interest to have the foundation of that platform open-source and free (Java and the runtime), and let people pay for the additional systems on top of that. It would encourage people through Oracle's door, where they might start paying for software. Because they've instead created a perception that Java = closed/ expensive. They've created a perception that Oracle is litigious (which is true). Compare with a company like Microsoft that have gone the exact opposite way. They've open-sourced their software/ compilers/ runtimes. They've made the development so bloody easy. This creates a fantastic environment where people are praising Microsoft and their efforts. C# is now moving towards being a more popular language with new developers I know. And Microsoft then make money with loads of companies using Azure. I think in the end Microsofts new platform will generate more money, and ultimately result in a healthier ecosystem for them. I love Java, but I'm upset at how Oracle have handled the platform.
Be sure to do it in a low voice and like you're discovered some horrible shameful secret you can't believe is happening. When in reality you're just being a dick. ;-)
Yes. &amp;#x200B; Context: company is a high throughput SAAS company, Java shop (mostly), most teams are on Java 11 - some have to continue using older versions for very good reasons. Lambdas make more sense used liberally - same concerns that others have registered for streams - that they don't always make sense for efficiency or code legibility reasons.
yeah well your mom said she wished i had a dick last night.... LOL
Absolutely. We didn't use them prior to ~2017, but I pushed hard and we're now allowed. It's made life much easier.
I don't have numbers, but considering the number of full-time OpenJDK developers, I would expect Oracle's expense to be ~$100M a year. That is not a charitable contribution, and if it were, I'd rather see it go to worthier causes. It's not a marketing write-off either. Now, I don't understand why you're upset that Oracle must fund the platform somehow while Sun did the same. Among other things with field of use restrictions, that are gone now that Oracle open-sourced the entire JDK. As to other companies, they fund their software platforms because they control a closed ecosystem. Microsoft funds .NET through Windows, Apple funds iOS/Swift through the iPhone/iPad/Mac, and Google funds Android through Android ads. Oracle doesn't control the much more open Java ecosystem, and so it has to fund Java somehow, like all those companies do and like Sun did before. Instead of field-of-use restrictions, search toolbar and a closed JDK with paid features, they've open sourced the JDK completely and charge for support. I don't understand your complaint. &gt; They've created a perception that Oracle is litigious (which is true). Compare with a company like Microsoft that have gone the exact opposite way. FYI, Microsoft has extracted more through litigation and threats from Android than Oracle ever asked for. &gt; They've open-sourced their software/ compilers/ runtimes. Java has done this before. &gt; They've made the development so bloody easy. This creates a fantastic environment where people are praising Microsoft and their efforts. I understand Microsoft has a better perception among developers, as they're pursuing a marketing strategy similar to one they had in the nineties. But make no mistake, they're not giving out $100M-worth of work for free, and they're certainly not contributing it out of Azure's revenue. Companies simply don't work like that. &gt; C# is now moving towards being a more popular language with new developers I know. Those aren't at all the numbers we're seeing. .NET is well behind Java in adoption, and the games MS is playing with backward compatibility may make them developer favorites, but CTOs and architects -- the people who make the decisions for large projects -- don't trust them for continued support, and rightly so.
code review last week: I suggested to replace streams with loop in places it made sense, 3 reviewers total, my comment got ignored, 2 other devs approved PR and it went in, no discussion
just curious, why grep over ack?
There's a lot of Java work where nobody really cares about CPU performance, because it's just not relevant or not the limiting factor. You seem to be assuming that the domain you focus on is universally applicable - thus the downvotes.
No, not yet. We still haven't started using generics...
The parent statement has quite some merit to it when considering second order effects. Lambdas are pretty nice and readable in a direct comparison to e.g. anonymous classes, but a nicer syntax also leads to wider use. Excessive use of functional actors would have been too obviously ugly before, now I keep seeing it too often. Lambdas expressing otherwise meaningless glue logic for overzealous code de-duplication across vaguely similar methods, overdone code splitting, nested lambdas, several lambdas in one invocation and other abuses come to mind. In a way this is like operator overloading. It is up to the team employing these features whether there is an overall net benefit or not.
When I first learned java 8 stuff I was trying to fit them anywhere possible, but I quickly learned from a more senior dev that it makes code less readable/maintainable for other devs. So I try and limit the use to utility methods and complex map stuff. Still think they’re sexy when used well but can Deff be annoying/unnecessary when someone gets trigger happy with em.
I love streams. One big advantage I see is that I can grab all the data I would ever need in the beginning of the service layer, and then use streams to get what I want later on. This is much faster than doing database calls in a loop (performance hit when opening and closing connections). However, if there's no need to filter, map or do something like this, I use a normal for-each loop instead. As far as lambdas go... Maybe it's just my lack of experience but I haven't really encountered a situation to use them yet besides with a Completablefuture (IIRC).
Yeah I was the same way. When I first started using them, I went crazy lol. But I found them really useful to grab data all at once and query through it, than to do some database calls in a loop (for example).
Streams are overused with little to no care for the overhead incurred. Just take a look at the byte code generated with a stream implementation over the equivalent for loop. Besides code bloat (which dents your instruction cache) you also give up some compile time optimizations like inlining and loop unrolling. In general they are anywhere from 3x to 4x slower when I have benchmarked them using JMH. This is probably not a big deal if it is not on the hot path, but if it is then it can yield poor performance. Streams definitely have their place and very useful when actually consuming a stream (e.g. reading bytes off a network or reading a file or iterating over a recordset). However I find people overuse them for the most basic iteration of a collection (often a very small collection). As for lambdas I often see 10 to 20 line lambdas with a try catch block and the works. For shame! Use a method instead...it will be more readable and testable. Please let's not turn this into a JS promise spaghetti code. Also keep in mind that 2 equivalent lambdas at different call sites will produce essentially duplicate byte code at runtime. Most of the time these are static methods, but sometimes can be classes.
Some people take it to the extreme with the new toys, and caused a few performance issues in the process when doing streams etc in tight loops just create alot of overhead. &amp;#x200B; Thankfully IntelliJ has a simple convert stream to for-loop hook which has been used far more than the reverse..
F
Really interesting; are you at liberty to share some (anonymized) examples? Most of the places I've been at have done Java 8 features quite well. Side-note: I've only really noticed a lot of developers going overboard with some of Kotlin's features, and that might just be because it's new.
Wrong subreddit. /r/learnjava is for learning Java (the sidebar there has learning resources and much more) /r/javahelp is for help with Java programming **Removed**
Vision pipelines, just like FRC. We made a pipeline to detect the location of the gold mineral in the sampling field this year, it worked way better than the built-in TensorFlow.
&gt; Does that matter to you? Not at all, unless you're looking for a new job? ;)
What about method references?
Why ack over ripgrep?
.forEach on a collection doesn't use streams though. It's just a for loop which executes the lambda, but the lambda might make optimisations not possible.
I'm on a High School FTC Robotics team, and we make heavy use of Lambdas. We don't rely on any frameworks, we wrote our own library which uses Lambdas. &amp;#x200B; (Warning: lots of robotics code jargon, please ask me to explain if you don't understand). &amp;#x200B; We use Lambdas as part of our async non-blocking state machines, which hold our autonomous (driver-less) routines. A state machine is just a collection of "states" to run in sequence after each is completed. We store each state as a lambda which returns immediately, returning a true to signify that the state is completed and ready to move on to the next. and false to signify that the state is not finished executing. The state machine looks like this (this is simplified code, ours is more complicated and uses lambdas): &amp;#x200B; ```java runAutonomous() { while(!done) { runStateMachine(); updateSensorInformation(); } } runStateMachine() { switch(state) { case 0: setMotorPower(100); if(inchesDriven &gt; 10) state++; break; case 1:
Yes and it is creating a lot of clean up work for me when I need to go in and figure out performance/memory issued in tight loops. No complain so far as it seems to give me a steady stream (pun intended) of job securities :-)
I think it was specifically on a stream in this case.
Hey, that's cool, never heard of that, I'll have a look at it! thanks!
You're right, but what are the *actual* downsides to using Optional like that except for people *telling you* you shouldn't?
Using Java 7, so not.
No he doesn't. It would be illegal in Switzerland to not disclose such an arrangement, and both me and the author are Swiss.
just curious, why grep over Search in IDE?
This was already posted [here](https://reddit.com/r/java/comments/byxc5o/love_it_or_hate_it_java_continues_to_evolve/).
Only 500
Yes
So what was the justification for using the default? We mainly use couchbase (with their SDK) with spring data over the top which under the hood uses Jackson, we are pretty much hidden* from any implementation which is easier for us. *We did have to modify the behaviour slightly as it writes the full class name as part of the record.
Yes, don't forget optionals :)
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
As jpl75 previously mentioned -&gt; [Optional was not intended for parameters](https://rules.sonarsource.com/java/RSPEC-3553) &gt;With an Optional parameter, you go from having 2 possible inputs: null and not-null, to three: null, non-null-without-value, and non-null-with-value. Add to that the fact that overloading has long been available to convey that some parameters are optional, and there's really no reason to have Optional parameters.
If you accept IntelliJ / JetBrains's 2019 survey as half reliable, then https://www.jetbrains.com/lp/devecosystem-2019/java/
Yes to everything including the edit
very nice to see that r8 is mainstream
This is misleading. The cost of building a `CallSite` is paid only on the first `INVOKEDYNAMIC` call of `LambdaMetafactory.metafactory`, later the same `INVOKEDYNAMIC` call simply reuses the `CallSite` instance the first call provided, and this is being done by JVM itself. After the initialization, `INVOKEDYNAMIC` works pretty much like a `INVOKESTATIC` call. To clarify, consider the following class. import java.util.function.IntUnaryOperator; public class LambdaTest { private static IntUnaryOperator getAdder(int a) { return b -&gt; a + b; } public static void main(String[] args) { IntUnaryOperator adder = getAdder(3); adder.applyAsInt(3); } } The byte code is as follows. // class version 54.0 (54) // access flags 0x21 public class LambdaTest { // compiled from: LambdaTest.java // access flags 0x19 public final static INNERCLASS java/lang/invoke/MethodHandles$Lookup java/lang/invoke/MethodHandles Lookup // access flags 0x1 public &lt;init&gt;()V L0 LINENUMBER 3 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V RETURN L1 LOCALVARIABLE this LLambdaTest; L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0xA private static getAdder(I)Ljava/util/function/IntUnaryOperator; L0 LINENUMBER 5 L0 ILOAD 0 INVOKEDYNAMIC applyAsInt(I)Ljava/util/function/IntUnaryOperator; [ // handle kind 0x6 : INVOKESTATIC java/lang/invoke/LambdaMetafactory.metafactory(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite; // arguments: (I)I, // handle kind 0x6 : INVOKESTATIC LambdaTest.lambda$getAdder$0(II)I, (I)I ] ARETURN L1 LOCALVARIABLE a I L0 L1 0 MAXSTACK = 1 MAXLOCALS = 1 // access flags 0x9 public static main([Ljava/lang/String;)V L0 LINENUMBER 9 L0 ICONST_3 INVOKESTATIC LambdaTest.getAdder (I)Ljava/util/function/IntUnaryOperator; ASTORE 1 L1 LINENUMBER 10 L1 ALOAD 1 ICONST_3 INVOKEINTERFACE java/util/function/IntUnaryOperator.applyAsInt (I)I (itf) POP L2 LINENUMBER 11 L2 RETURN L3 LOCALVARIABLE args [Ljava/lang/String; L0 L3 0 LOCALVARIABLE adder Ljava/util/function/IntUnaryOperator; L1 L3 1 MAXSTACK = 2 MAXLOCALS = 2 // access flags 0x100A private static synthetic lambda$getAdder$0(II)I L0 LINENUMBER 5 L0 ILOAD 0 ILOAD 1 IADD IRETURN L1 LOCALVARIABLE a I L0 L1 0 LOCALVARIABLE b I L0 L1 1 MAXSTACK = 2 MAXLOCALS = 2 } Once `getAdder` is called, a new class `LambdaTest$$Lambda$1/1468177767` gets generated (the name will vary, but that doesn't really matter) with two methods: `private static IntUnaryOperator get$Lambda(int)` and `public int applyAsInt(int)`. The first one is a constructor for the lambda, and this is the call site that gets cached by JVM. The second one is an implementation of `applyAsInt` method` that simply calls `lambda$getAdder$0` (which shouid be fast, as JIT should inline the call). Note in particular the following part of bytecode. ILOAD 0 INVOKEDYNAMIC applyAsInt(I)Ljava/util/function/IntUnaryOperator; [ This looks a lot like `INVOKESTATIC`, doesn't it? That's not a coincidence, after first call to `INVOKEDYNAMIC` function, it essentially works like `INVOKESTATIC`, the entire `LambdaMetafactory.metafactory` machinery is skipped.
Which is problematic, as Mixermachine mentioned, the Optional can still be null, so isPresent can still throw a NPE.
What about jdbc makes it so painful? Any examples and/or little more detail would help seeing your point?
That's why we have `Collection.removeIf()`.
I agree that familiarity really helps to make them more understandable/readable. It took me a while, but I definitely prefer the step by step approach of streams to the equivalent non-stream code. Obviously there are many places where trying to convert to streams is less efficient or less readable, but for the simple cases I much prefer them.
OP is the jOOQ author.
Out of curiosity, is there a reason one should not accept the survey?
kotlin, just like java are trash, still no value type and autoboxing everywhere, worst of all is no way to easily get AOT compilation, and please don't mention the joke that is GraalVM native image - they way to slow to evolve - they don't comunicate - they use ancient VSC - they use ancient form of messaging good luck getting the new generation of developper interested when you lack vision, when you are only hiring 80yo developers, you finish in the graveyard early
Clickbait, compile 10x faster would be a more accurate title but I was curious; Start-up time of 4.683 on my $650 second-hand Inspiron 5570 (8550U, 16GB, 256 SSD). You can mess around with cheap laptops with virtual machines and Mac's all you like but you just can't beat a decent laptop for performance per cost.
alphabet[6] Coincidence?
Yep
Jetbrains/IntelliJ isn't the only choice of IDE and has a bit of a "hipster" reputation so their survey coverage may not represent the entirety of the Java ecosystem.
I'd say yes. In my previous project we slowly migrated most code that was about data transformations to streams, and were using lambdas were applicable. Not dogmatic though. Sometimes it still makes more sense to create a one-method class, rather than a lambda.
grep is much simpler right off the bat.
Instead of streams, what do people use? Java NIO?
Less writing code. ORM combined with Spring data: happy cruising. Oh, SQL X gets a bad performance? Sure, let's make it native, and optimize the shit out of it. There is absolutely no reason whatsoever to give up the ORM. None. Zero. Nada. jooq provides nothing to make it so. More code to write, more code to maintain, for the promise that that 1 in a million sql statement is better optimized. It's laughable, really.
Some people just happen to be competent. It's ok if you can't recognize this within yourself.
Yes, where it makes sense. Especially when passing code pieces for later execution.
https://github.com/pgcodekeeper/pgcodekeeper Schema migration with dependency management for PostgreSQL. Some interesting parts, some dull parts. Custom SQL parser built with ANTLR and dependency graph traversal algorithm are more interesting parts, though messy in places.
Pretty cool.
We're talking about these things, not IO streams: https://docs.oracle.com/javase/9/docs/api/java/util/stream/package-summary.html
Counter Point: Streams have been benchmarked as slower than traditional for loops. Every ms matters.
This is one of those circular issues I think. Oracle buys Java. JavaFX is part of Java and the successor to Swing. Companies and developers start learning about JavaFX as next generation desktop apps are needed. Oracle drops JavaFX, support is picked up by 3rd party firm. Companies take this as a sign JavaFX isn't valuable and stop pursuing it, thus making it appear there wasn't sufficient interest to begin with. All new technologies take time to be adopted, most particularly in an enterprise space which is where you'll find the bulk of Java desktop apps. I've followed JavaFX since it first was announced, before it was shipped with the JDK. Same with Swing, followed it since it first came out (one of the original javax. packages) before it shipped with the JDK and was a separate download. But during that time for Swing it was being developed by Sun, not a third part firm so people adopted it, though in all fairness the choices were Swing or AWT (or Bongo) as UI options so choosing to adopt Swing wasn't a hard choice. So this isn't to critique Oracle's handling of JavaFX, more just to point out that what you perceive as a *isn't sufficient interest* could very well have been caused directly by Oracle's moves in this regard.
Python is crap at server side (painfully slow and global lock), but it excels at the task you are mentioning. I used to rely heavily in Java in the past, but after having learned Python, I'm way better at automating boring stuff since Python is more convenient for this task.
I actually prefer GridBagLayout to nesting Border and Box layouts. I'll admit it took time to really understand it but I guess having had experience using the **pack** commands in TCL/TK made it not quite so bad. Created a couple of support routines and classes that I reused over the years made it less onerous.
&gt; push the dead and let die Jsf If it's already dead, there's no need to let it die. If there's a need (according to you) to let it die, it's not dead. And what are you actually, a ghost? Isn't that a dead being?
Perhaps, but here's how I see things. First, Oracle reduced its investment in JavaFX (it hasn't dropped it, as you can see from [the commit log](http://hg.openjdk.java.net/openjfx/jfx-dev/rt) -- kcr works at Oracle; jvos works at Gluon) only *after* it saw that the interest is not worth the investment. Second, and this is more important, virtually no one is investing a lot in desktop toolkits these days, except maybe for companies who are consumer-facing. I don't think anyone can deny that interest in the desktop, particularly for business applications, has dropped precipitously in recent years, as HTML has taken over the client side. But, despite the diminished status of the desktop across the industry, I don't think people should be turned away merely because a smaller company now contributes to OpenJFX. After all, Red Hat now runs the 8u and 11u projects, as it did for 6u and 7u. That's just how OpenJDK works. Oracle invests its resources according to its interests, but OpenJDK is big enough for other companies to invest according to *their* interests, sometimes in domains that perhaps Oracle sees as too small or outside its expertise.
Perhaps, but here's how I see things. First, Oracle reduced its investment in JavaFX (it hasn't dropped it, as you can see from [the commit log](http://hg.openjdk.java.net/openjfx/jfx-dev/rt) -- kcr works at Oracle; jvos works at Gluon) only *after* it saw that the interest is not worth the investment. Second, and this is more important, virtually no one is investing a lot in desktop toolkits these days, except maybe for companies who are consumer-facing *and* own the client platform. I don't think anyone can deny that interest in the desktop, particularly for business applications, has dropped precipitously in recent years, as HTML has taken over the client side. But, despite the diminished status of the desktop across the industry, I don't think people should be turned away merely because a smaller company now contributes to OpenJFX. After all, Red Hat now runs the 8u and 11u projects, as it did for 6u and 7u. That's just how OpenJDK works. Oracle invests its resources according to its interests, but OpenJDK is big enough for other companies to invest according to *their* interests, sometimes in domains that perhaps Oracle sees as too small or outside its expertise. Now, it is true that when a huge company invests a lot in something, *maybe* it takes off. "Supply-side" economics of sorts, if you like. But even a big company can do it only for a small number of domains, and they need to pick the best bets. Do you think that the desktop is where you'd want to see Oracle's investment in Java?
The LambdaMetafactory is only used when the callsite is linked, not every time the lambda is called.
Maybe they used it with an explicit \`[collection.stream](https://collection.stream)().forEach()\` instead of the direct \`collection.forEach()\`
And now 19.0.2 is already available: [https://www.graalvm.org/docs/release-notes/](https://www.graalvm.org/docs/release-notes/)
&gt;I don't think anyone can deny that interest in the desktop Would agree with that if you follow all the internet hype, but interestingly enough, at least firms I've worked for, there's still plenty of demand for desktop applications versus web apps and for Java that means Swing. &gt;I don't think people should be turned away merely because a smaller company now contributes to OpenJFX I think the issues are predominately one of longevity. Most firms expected Sun to be around (and they were for quite a while), now they expect Oracle isn't going anywhere soon so they were willing to bet on those firms supporting the technology. A firm like Gluon is honestly too much of an unknown to make a bet on. &gt;Do you think that the desktop is where you'd want to see Oracle's investment in Java? Only in so much as adding the multi-touch support to Swing. Otherwise, I'm actually fine with Swing as a technology. I never truly adopted JavaFX as it didn't really offer anything I couldn't do in Swing. The internal apps I've built either were happy with the desktop L&amp;F they ran on or the company defined its own L&amp;F which we implemented so have externalized CSS for desktop styling wasn't much of a draw. OpenGL accelerated rendering also does decently well for doing basic 2D graphics visualizations and having access to LWGJL + GLFW provides for very nice 3D work as well. I personally am a huge fan of the existing Java2D graphics library capabilities in the java.awt.Graphics &amp; java.awt.Graphics2D classes that Swing is built on. I've not really run into a widget that I found missing in Swing so to me, at least, it feels mostly complete. So just adding some additional support for multi touch or perhaps additional controls (i.e gamepads) is really all I see.
Sounds like an exaggeration.
&gt; So just adding some additional support for multi touch or perhaps additional controls (i.e gamepads) is really all I see. I know nothing of this subject, so I can't even estimate how much work this would be.
&gt;With an Optional parameter, you go from having 2 possible inputs: null and not-null, to three: null, non-null-without-value, and non-null-with-value That's like arguing that by returning \`Optional\` you go from having 2 possible outputs to 3. Plus overloading only works when you have just one optional argument.
Unless your stream splits nicely and you parallelize it across multiple cores. As always, it depends. Optimize when it matters. Don't optimize prematurely.
From the JDBC tutorial (https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html) here is a method for executing 2 update statements. You don't think this is painful? public void updateCoffeeSales(HashMap&lt;String, Integer&gt; salesForWeek) throws SQLException { PreparedStatement updateSales = null; PreparedStatement updateTotal = null; String updateString = "update " + dbName + ".COFFEES " + "set SALES = ? where COF_NAME = ?"; String updateStatement = "update " + dbName + ".COFFEES " + "set TOTAL = TOTAL + ? " + "where COF_NAME = ?"; try { con.setAutoCommit(false); updateSales = con.prepareStatement(updateString); updateTotal = con.prepareStatement(updateStatement); for (Map.Entry&lt;String, Integer&gt; e : salesForWeek.entrySet()) { updateSales.setInt(1, e.getValue().intValue()); updateSales.setString(2, e.getKey()); updateSales.executeUpdate(); updateTotal.setInt(1, e.getValue().intValue()); updateTotal.setString(2, e.getKey()); updateTotal.executeUpdate(); con.commit(); } } catch (SQLException e ) { JDBCTutorialUtilities.printSQLException(e); if (con != null) { try { System.err.print("Transaction is being rolled back"); con.rollback(); } catch(SQLException excep) { JDBCTutorialUtilities.printSQLException(excep); } } } finally { if (updateSales != null) { updateSales.close(); } if (updateTotal != null) { updateTotal.close(); } con.setAutoCommit(true); } }
Can anyone comment the status of the Python implementation?
I believe r/kotlin is appropriate place for such a question... And if no answer is provided, then it is an answer in itself
&gt; So just adding some additional support for multi touch or perhaps additional controls (i.e gamepads) is really all I see. I know nothing of this subject, so I can't even estimate how much work this would be. But both the [Swing](https://mail.openjdk.java.net/pipermail/swing-dev/) and [AWT](https://mail.openjdk.java.net/pipermail/awt-dev/2019-June/thread.html) mailing lists are active (as they are actually both still developed), and this may be a good thing to bring up there (I'm guessing AWT is more appropriate).
I think for me "The Anticipated GA Release" is GraalVM XX.X base on Java 11 (or later). It's probably going to take a while though. Looking at [https://github.com/oracle/graal/issues/651](https://github.com/oracle/graal/issues/651) they seem to have vastly underestimated the work needed.
I'm not an expert in Kotlin, but I don't see why Kotlin can't just provide different compile targets like Java has done it for years. Unlike Java, Kotlin is only loosely coupled to the JVM. If you look at the feature pipeline of the JVM, they are mostly performance related one way or another. So, once the JVM has native Value Types Kotlin can generate more efficient byte code if it targets higher byte code versions. I really don't see your problem. Kotlin can be seen as a further abstraction on top of Java, so the compilation process has more choice when it comes to generating byte code. After all, this is the whole selling point of the language for Android: It's less tied to the Android JVM and it's horrible rate of progression.
which kind-of defeats the purpose of streams, stream() is lazy, foreach() is not. Foreach is also heavily frowned upon by my team because forEach has implied side effects
ACK
GraalVM seems like a revolution, but I don't get its purpose entirely. Is it just a one-combiler/vm-multiple-languages project? Can anyone elaborate why this is good?
If you're using Graal in HotSpot, you can use it in any OpenJDK release. Are you talking about SubstrateVM (AKA Graal Native Image)?
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
https://www.graalvm.org/docs/why-graal/
Being able to compile a JVM application to a native binary is a huge deal for cloud environments with dynamic loads. If it takes 1 ms to start a new instance of your application vs 30 seconds, they can be created and destroyed at a much faster pace.
Agreed. This is a strawman argument against SQL. I actually feel it's better for devs to write SQL so that they better understand the data model they are working with. Far too often in interviews candidates don't have any clue about how a DB works but their top 3 projects are all some sort of REST API over a DB thingy.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
you shouldn't return null from a function that returns Optional. Overloading works with however many parameters you want.
Yes, mainly interested in GNI. &amp;#x200B; MethodHandles, Lookup objects and friends in java.lang.invoke are being pushed more and more for every release of Java. But it is basically impossible to get an overview what kind of support these are going to have with native images.
I mean the shop I left recently does, but... I think that javafx is the staple.
I think the alternative is web apps these days.
never seen that approach not in "child examples" will check your channel man, I've interested in adopting such workflow at work and home pet projects.
Do you really need an older version of Java 8? I think Update 211 ([JRE](https://java.com/de/download/win10.jsp) or [JDK](https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html)) would run just fine and it doesn't need an account. If you really need JDK-8u181, alternatively you can get the [OpenJDK build here](https://adoptopenjdk.net/archive.html) (specifally [here](https://github.com/AdoptOpenJDK/openjdk8-binaries/releases/tag/jdk8u181-b13)) Installation is unzip and setting [JAVA_HOME](https://www.mkyong.com/java/how-to-set-java_home-on-windows-10/).
Javafx is surprisingly robust tbh, go with it.
JavaFX is very comfortable with Scene Builder and Property binds.
For the state of development: [changelog](https://github.com/graalvm/graalpython/blob/master/CHANGELOG.md)
Most of the pain above comes from exception handling which is an issue you always need to take care of. Systems do occasionally fail and you need to decide what to do in those situations. Then there's some boilerplate code that every example has simply because they are examples. If you're repeating the above for every statement you have a mindset problem. Programming is about generalization, as much as possible. Composition, inheritance, parametrization. You need to be lazy and create solution that utilizes the simplicity of JDBC and adapts it to your application. Perhaps it is an utility class, perhaps it's a connection pool with wrapper classes, only you know what is a best fit to your current problem. As an example: I use my own ConnectionPool which in turn returns Connection wrappers which return Statement wrappers and so on, so the service thread gets to do commit at the end of each successful 'service call/request' and rollback on fail. Autocommit is off, as it should be in every real life application. Out of about 500k SLOC there's only about 12k of code that deals with the database. Connection pooling, wrapper classes, the loads, updates and query engine. (Users can construct complex queries with a visual tool which get 'translated' to SQL at server side). And it is a very database heavy/centric application. I wouldn't ever use ORM or any other tool to implement the most performance centric part of the application. IMO JDBC is simple because it has so little moving parts. It's your responsibility as a programmer to build something from those parts. Not to mindlessly repeat yourself.
IntelliJ products are still built on Swing. JavaFX is pretty OK, but you can make Swing look decent if you try.
I would use Python for something as this. Java really doesn't make too great of a scripting language IMHO, while Python is pretty well suited for such tasks.
I downloaded OpenJDK8U-jdk_x64_windows_hotspot_8u181b13.zip and when I it finished I was unable to open it, it just sat there with a blue ring around it, and when I went to click it my wallpaper went white and my computer crashed, I’m restarting now
What program are you starting? The JDK needs to be unzip and installed like I mentioned above. The JDK itself is just the environment to run on. It does nothing when double-clicking (java.exe).
FWIW, some advice, but not an answer to your question: Look into using MVP (model-view-presenter). It's design pattern that will allow you to easily port the same code base to Android, Swing, and Web (with Vaadin). Views are dumb, which helps make apps easy to port.
Javafx is generally considered superior, but Swing is still used and can look and be good in general too. For a project from scratch, I'd recommend Javafx (+ SceneBuilder)
yes. I use it. I like the pluggable look and feels and the power of the JTable framework.
Not where I Work
on the desktop with java you have JavaFX. cool and good. But Swing won't go anywhere and is stable and it works. but if you don't need desktop specifically, look at the web. you hit all platforms at once with not so much effort. of course, not everything is suited for the web or even possible there and it comes with its own set of problems.
You can build UIs in libgdx (NB my opinion is biased).
Swing has guaranteed support on Java SE 11 until at least September 2026; after that it will probably be handed off as a third-party project, as JavaFX was. If I were starting a new desktop project I would probably go with JavaFX, but there's nothing really wrong with Swing and there are still plenty of projects using it.
Me: JDBC is a little painful to use without a helper library You: Show me an example of it being painful Me: Provide example You: Well you need a helper library to take care of the boiler-plate Me: Yeah, that's what I said.
I've been doing a lot of Android Development but never tried JavaFX for "regular" apps. What tools do I need to develop for this framework? Just IntelliJ?
If you need a UI on anything but X64, you're probably better off with swing. OpenJFX builds are not available for the plethora of platforms that [adoptopenjdk.net supports](https://adoptopenjdk.net/releases.html).
jooq tech articles have been some of the best ones in the past few years. those guys regularly publish great stuff.
the author is the author of jooq, iirc.
Hmm.. so are you building an app only for desktop? Will it make API calls to a back end over network? Is Java the only way you can build the app or can other technologies be used? &amp;#x200B; Today, me, without a doubt I would look towards PWA with NodeJS and React or Vue for the UI front end bits, and use Golang or Java on the back end for API, bundled in containers and deployed in the cloud. Tons of info around it, and you can build some pretty robust applications this way. If you need a bit more desktop like feel, wrap the PWA inside of Electron 4/5 wrapper, which is pretty easy to do. If you are purely staying Java, then JavaFX is probably the way to go as it is still being supported, though I think it broke off and is open source now? Cant remember. Depending on what you are doing.. e.g. a simple desktop Java app or something potentially bigger and developed by a lot of folks, I would consider the growing popularity of front end microservice (or plugin based) UI development so you can break components/pages/etc into separate dev/build/deploy chunks that could align with back end microservice APIs. It allows for a more modular faster dev cycle, but there is a bit to the overall architecture to really make it work that adds some complexity to this style. It is great for growing/larger teams or working on individual modules as needed, but does complicate the build/test/deploy process.
and thus give up all the benefits of using an ORM in the first place.
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
Yes, I too think it's huge ... plus reduced memory usage and image size of containers.
No because you can use an ORM to do the easy bits and drop down to SQL when you need the power. You can even create entities from SQL if you want a mid way.
because I don't know what ripgrep is, I'll look it up, thanks.
because intellij is not very good at search (on ultimate)
And so is netbeans.
Some say Swing is old-fashioned and that JavaFX is there to kill it off. But then there's stuff like [Webswing](https://www.webswing.org/) that could make Swing persist way past its supposed due date.
Holy crap. How for real is that?
good to know
&gt; Run your java application in a web browser Gee, if only that had been thought of before.
Lambas are really a godsend. Sometimes all you want is to have a helper method that does a thing with a piece of code. Yes, it turns into spaghetti pretty quickly, but sometimes it's alright because the alternatives are worse. Case in point: Streams. They start out innocent, and a single `map` or a well-behaved `reduce` are quite easy to comprehend, even if they occur together. But I tend to run for the hills and use good old loops once side-effects creep in or inter-loop interactions and crazy exit conditions start piling up.
Holy fuck why do some of these implementations even exist?
Thank you for pointing out Webswing. I never knew this was a thing.
The command java -jar "C:\&lt;directory-path-to-jar&gt;\&lt;name-of-jar&gt;.jar" didn’t work, Why do I need to completely uninstall java?
Maybe I'm missing it in the article, but I can't find what JVM version these were run on.
C# 🙂
Exclude the tests when checking for usage?
Thanks for this info, did a little research on WebSwing and I like what I see. 👍
https://stackoverflow.com/questions/9256878/intellij-find-usages-but-exclude-test-files-from-results
Even if you wantrd to manually traverse Alt+F7 on every possible method in a project, it still wouldn't identify code islands.
Some simple solution is to temporarily delete your test classes and see what comes up, or if your source is well organized just tell it to run on only the main (non-test) directory. There could still be all kinds of things referring to your dead code though. At then end of the day only you can say which endpoints/interfaces are valid to be used, but if you start on that end of it then things will often start to unravel quickly. If you're using any kind of Spring Configuration classes or such then you'll want to review those too, and a dependency chart could potentially show things that don't fit anymore.
That wouldn't identify any isolated code (as per the example, where a collection of classes and methods may refer to each other, but exist as a chunk of unimplemented features)
As per the other replies, this still isn't a solution. The scenario is where two or more classes may rely on each other, but aren't implemented into the rest of the project (hence isolated). The tests reference was just an example scenario. For further clarification, think of a bunch of classes/methods that comprise a feature that, at some point, was removed from the functionality but not the codebase.
A jvm boot does not take 30 seconds, that's most likely a heavy framework like spring
Our main product has around 1500 tables. Manually mapping those would be a lot of busy work.
Pretty much everything is terrible with `LinkedList`. :-)
😱
Haha, indeed! I’m surprised Dr. Deprecator hasn’t marked it with `@Deprecated(forRemoval = true)` \s
I think what you really need is a dependency graph of all classes in your project. Everything at the top level is either something that does I/O with another system and/or something dead, or maybe some terrible reflection-based nonsense. Of course this still doesn't include something that is referenced but blocked from ever running by some obscure config. No automated solution is going to know what config items are still in use vs something not touched anymore. For this level of issue maybe the solution is real-time bytecode instrumentation / clever logging / application monitoring. Then at least you'd know what IS used so you can better focus in on possible candidates for dead code.
Because its the easiest solution to make sure nothing else interferes with the new JDK installation. What does it print when you type `java -version` in console?
[And Eclipse](https://www.javalobby.org//java/forums/t78926.html) (2006)
It says “java version “1.8.0_211 Java (TM) SE Runtime Environment (build 25.211-b12) Java Hotspot (TM) Client VM (build 25.211-b12, mixed mode)
What is the entry point into your application? A rest endpoint? Message listener? For this type of cleanup I typically have to know enough to manually delete that first part, then the ide can help me peel off layers. I add some custom aspects and annotations to log when deprecated endpoints are called so I can safely remove them if I see they are not. (Internal app so we control the consumers, this is just a sanity check) I suspect you won't find a really satisfying answer here.
Ok, so your old Java installation (1.8.0_211) - which is actually newer than the one you're trying to get - is still active. Why do you need 1.8.0_181 exactly?
Well, see this: https://mobile.twitter.com/DrDeprecator/status/668447303481495552 But practically speaking, deprecating LL will generate a lot of warnings and complaints from the community, probably outweighing any benefits, at least for now.
I think that's possibly the answer - the problem is 'scale'. It's a pretty substantial project (partially, I suspect, due to this issue) as it used to be a lot more functional than it is view, where a lot of functionally has been migrated away without, it seems, a structured or considered divorce of the code. I guess the _ideal_ solution would be a dependency graph that can be analysed by something else, to avoid the manual inspection task
Ha! That's what I would expect, though. I assume you also feel the same about deprecating the pre-collections classes?
I trying to get a JDK to open my optifine with and use it to install a shader
Doesn't Eclipse use another UI toolkit called SWT ?
DING! DING! DING! DING! We have a winner! &amp;#x200B; If you can at all build a web app . . . then do.
No, overloading doesn't scale well if you want defaults for multiple arguments, and even less so when they have the same types.
 &gt;Code reviews are for inefficient and/or unreadable code. That’s a spectacularly limited definition of the purpose of code reviews.
It sounds like you are trying to identify the [components](https://en.wikipedia.org/wiki/Component_(graph_theory)) of the class graph. I don't know any off the shelf solutions, but have you thought about generating a UML class diagram? The human eye is pretty fast in identifying disconnected islands. IntelliJ Ultimate [seems to support this](https://stackoverflow.com/questions/8942751).
It's a 15 year old JavaEE app that comprises of easily several hundred classes. It's mostly front-end driven, but does have soap in abundance. A lovely combo of spaghetti code with lasagne practice applied over the years. I thought there might be a less manual approach involved - I'll traverse the analyze menu in IntelliJ to see what is on offer!
IntelliJ and JProfiler (just to name the two I remember from the top of my head) make a good case of how swing can look good and be really responsive. &amp;#x200B; Netbeans on the other hand (at least last time I've used) ...
Thanks - I have Ultimate, and have seen this on a macro level in the Structure tab, but will have a look at the larger scale applications it might have.
if you would like to put together something simple and easy to learn and tweak later on, I'd stick with what I know &amp;#x200B; on the other hand, if you want an excuse to learn something new, go for python (or whatever you feel like)
You do not have enough *comment* karma and as a result your post has been automatically removed. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/java) if you have any questions or concerns.*
No offense and not really criticism either but Vaadin is crap. I use it at my current job daily and still cannot figure out for the life of me why it was ever chosen. Totally agree views are and should always be ignorant wrt data (model) and the underlying controller (presenter).
[Yes](https://www.eclipse.org/swt/)
The Eclipse IDE's UI is based on a toolkit called [SWT](https://www.eclipse.org/swt/). Original goal was to give a more native appearance than Swing, although Swing's SystemLookAndFeel makes the comparison somewhat more even.
I ran these on java 10, somewhere in the references I do mention its on my 2018 macbook pro java 10 :)
 BC and commons where created at their time, because the sun jdk was perceived as lacking or too complicated. The clojure lib is a shame because it really is easy to use and get security right. However, having done these benchmarks I'll be moving to vanilla java for my encryption.
AWT for the win.
Static analysis tools should report you, that you injected a class as a parameter but are not using it locally. public Result doWork(Dependency dependency) { return null; } Not sure how else an unused functionality could look like.
SWT can use various UI backends (GTK+, win32) so why not AWT/Swing...
You don't have to have an absolute trade-off like that if you don't want. If you like (\*) you can run both an ORM and JOOQ at the same time. At the end of the day, JOOQ is just a library for SQL generation with a bunch of (totally optional) bells and whistles for loading objects and doing CRUD. &amp;#x200B; (\*) i.e. if the project truly justifies the complexity (and I can imagine plenty of large-ish projects that might).
Unused functionality, in this context, is a collection of objects or classes that form a collective functional purpose, but are not practically used by any logical flow or process. Nothing at all to do with unused local parameters.
&gt; no reason whatsoever to give up the ORM. None. Zero. Nada. &amp;#x200B; The first big thing you lose when using an ORM instead of a query generator like JOOQ is statically typed SQL queries checked at compile time by the Java compiler. The unexpected benefit I found was much better and early support for advanced features of each specific database (Postgres is my main experience here). The straight-forward path of an ORM is "lowest common denominator" across its supported databases. JOOQ tends to support new features of individual databases much more quickly. Both tools can drop to hard-coded SQL if you want, but the more advanced SQL features and hard-coded SQL are more natural with JOOQ.
I think this happens a lot because articles often frame comparisons as a competition and they want to declare a "winner" (either for click-bait reasons, or because they're pure content marketing). IMO, a query DSL like JOOQ is much more "JDBC library" than "persistence framework" (in the sense of the word "library" as in the above dialogue). &amp;#x200B; There's nothing stopping you from using JOOQ purely as a helper library to assist with generating SQL and loading rows (into JOOQ generated objects, your own objects, or just collections if you want).
OTOH, there's some efforts attempting to get JavaFX to work on mobile platforms, which is unlikely with Swing.