Perhaps this could be helpful for your journey. If you plan on doing the mooc.fi online ducation they provide a pre packaged netbeans wich includes their plugin for getting assignments and sending them for checking. Netbeans is good enough, it will not matter much in the beginning which one of the famous ones you use.
I'm still work on Java 7
But why do you need to see all billions of warnings in one window? :)
Long time eclipse user (mostly as STS). Also use it for my c++ projects as Cevelop.
I would also like to give you a useful tip for Reddit. There is a search function. You can even search inside a specific subreddit. I tested it by typing the words: "what ide" (without quotation marks) into the search text box and I found a bunch of discussions about this already. That can be useful in many cases.
Can confirm. Sent them a copy of my student ID (German university, no unified layout) and they gave me the student account within a week.
To be fair, some Java 8 code could be unrecognisable to a Java 7 programmer. But heavy use of Generics and Lambdas would definitely confuse a Java 4 programmer who's unfamiliar with the concepts.
Why not just try the 3 big ones? (Intellij/netbeans/eclipse) it is obviously a mostly personal preference and they are all free. It looks like most people prefer intellij (including me) but then again different people like different things.
Also various improvements to Java FX (removing the private API methods and replacing them with better public methods, e.g. things related to skins), which is of great interest to me given that I am having to struggle with a bunch of their half-assed implementations of default controls or completely rewrite them from the ground up (looking at you ComboBox). http://openjdk.java.net/jeps/253
vim is not an IDE
please subscribe
Yup, I'm not an american and use the deal (edit: for IntelliJ ultimate) myself. It would be strange if it was any other way, tbh (jetbrains is a european company, iirc).
Don't forget to like, comment and subscribe. 
i currently use Spring Tool Suite, NetBeans, AndroidStudio, Xcode and Brackets. Until AndroidStudio and Spring Tool Suite came out, I used Eclipse for all Java development and NetBeans for any Spring dev. There is no best. All of them have things I like - online api doc access, code cross reference, code completion, automated build/release blah blah blah. All of them have things I don't like - Android Studio was upgrading way too damn often, all of them can do automatic updates and i don't want you to change my dev env automatically, they are all memory/resource pigs. Except Xcode - I HATE that Apple says the only way you can develop/release is with Xcode. 
The license lasts one year. You can renew it as long as you are still a student
Thanks, I'll take a look
Eclipse. Currently the only realistic contender for serious modern OSGi/Bnd development with Bndtools.
I still have no idea what it is they do after reading that. It looks like an AES-GCM wrapper for database fields but the key management explanation is awful.
You're doing vim wrong then.
I'm not using it
I can actually see myself having this conversation with my management. How anyone ever thought putting MBAs in charge of software projects was a good idea will always mystify me.
I don't know if you can have another after the first year. Mine will end in October :P
Only 3 months for the moment ...
I was an attendee and I have to say that this was a great event. Good speakers from all over the world, professional and respectful atmosphere and excellent food. In addition to a flawless execution from the crew. Met a lot of current and previous colleagues and schoolmates. Also got some nice leads that might lead to future work. All salutes go to [javaBin](http://java.no/) (Norwegian JUG) contributors for creating and organizing this event on their free time.
Dear God, Android is even more stagnant than I dared imagine.
this framework looks really good. What I'd also like to see is a JWT implementation so I can choose between JWT and oauth. 
If IntelliJ could get view placement correct and could make errors more obvious and the community edition was as capable as Eclipse plus Eclipse's massive Plugin system and it could serve as a full OSGi application platform with true project management and true workspace management and a few other things...I'd say it would almost be about equal to Eclipse, but ugly.
It's weird that Eclipse is rock solid for millions of developers around the world. It works great even on my old laptop from 2010. It takes some mastering. If I were just going to punch out JavaScript all day (not going to happen!) then IntelliJ is suited well for that.
TidelandsGuy: I'm Sid, founder and CEO. As a security guy myself, I appreciate your skepticism. The FIPS 140-2 standard is specific to the core cryptographic module (not the larger software system that uses it). We're using a licensed cryptographic library that's FIPS 140-2 certified. Plus FIPS-140-2 covers "key management" very thinly, just immediately around the cryptographic module. The broader tasks of transporting the encrypted encryption keys over a network, their long term management, the UX etc is outside the scope of the standard. Even OpenSSL's FIPS mode addresses this [here in figure1](https://www.openssl.org/docs/fips/SecurityPolicy-RE-2.0.10.pdf). Also worth noting is that cryptographic routines/libraries, in by themselves, are just a small fraction of the overall platform solution we provide. Why don't you give us a shot? Our community edition is 100% sponsored by Crypteron. I think you will be pleased. If not, I want to hear from you.
Same sh%t (at least for Apache ActiveMQ). We had pain with it for many years. It's pretty unstable, in our experience. We upgraded it many times to newer more stable versions, and now we have to upgrade it one more time because of issue that leads to disk space exhausting. 
I understand your point. Java is still, far away from a bloated programming language though, at least if compared to the level of C++. It wont be weird once you get used to it, if people can get used to functional programming/closures then implicit typing with 'var' is not really hard to adapt to. 
Thanks! Rapidoid's token mechanism (http://www.rapidoid.org/security.html) is similar to JWT. It serves as a generic dictionary which contains arbitrary data (by default the username and expiration time). The token data is typically signed with HMAC-SHA256 and encrypted with AES (the encryption is useful if more sensitive custom data is serialized into the token, but should be configurable). It looks like the token mechanism can be used and adjusted to implement the JWT standard. I will try to incrementally adjust it towards the JWT spec, as long as it remains compatible with Rapidoid's security concepts.
e.g. the first step would be supporting `Authorization: Bearer &lt;token&gt;`
Nobody using Atom? wow.
False assumption ("it looks like most people prefer intellij"). :-)
Have used various IDEs over my career and I prefer NetBeans for Java development, because it's free, simple to use, and has the most common features straight out of the box. IMO Eclipse is the worst of the big 3 Java IDEs.
Just signed up for student account through reading this thread. I had used webstorm and intellij previously and am now more motivated than ever to get back deep into programming.
very interesting!
Any features in particular that make it worth the fee? I've only dabbled in Java recently and the community edition seems great to me, not sure what I'm missing though!
Ugh
You've enumerated quite a few bit that I am not interested in. As an IDE user I need 1. Allow me to quickly locate anything I want, including commands/class/files/symbols 2. Be smart enough to guess what I want to type for the next character and present it as the first item in the autocomplete list IntelliJ is definitely a winner of both aspects when comparing to Eclipse (Disclaim: I've been using Eclipse since 1.5 through to 3.0 for more than 8 years)
&gt;Scala doesn't offer anything that increases readability YMMV. I find Scala perfectly readable, and the copy-paste boilerplate of Java almost impossible to understand. &gt;having a ridiculous nullity system via Optionals instead of the cleaner, more elegant ? system that Kotlin uses. Handling nullability through the type system is also the approach Java uses now. If you don't like it, the JVM may not be the best place to work in. Its also a little strange to see someone refer to Option typing as "ridiculous". Care to expand on that? If anything, creating a specific language feature and syntax for each monadic context that can exist seems far more short-sighted.
Hey SerCeMan - fair point. There are many open-sourced projects that use 'community' to imply the free version, but I don't think the converse is necessarily true. We're fellow developers ourselves, so when we say community, it's our desire to sponsor the monthly service for security conscious fellow developers. Out of curiosity, if we published the source code on GitHub, what would you really want to do with it? How many hours a week could/would you spend on it? If we ever go down that path, we'd like to make sure we've got processes in place to handle it (e.g. pull requests, review/audit 3rd party commits etc)
Facebook's GraphQL
&gt; IntelliJ IDEa since 1998 Wikipedia says: "The first version of IntelliJ IDEA was released in January 2001" I am genuinely interested to know if it was out that long ago? Maybe as a beta version? How did you hear about it back then?
How come every Scala dev seems to argue that null is "just another monad"? It's by far the most common scenario of its kind, and null itself is a "blessed" language feature. The possibility for a variable that holds a value of type T to just not hold a value of that type? That's very special and primitive. It shouldn't be handled by higher level functions, but should be baked into the language itself. In Kotlin, the syntax itself accounts for the nullity of everything that you work with, making code easier to understand. It's expressive and readable. It's one of the few things that I'd argue should prioritize conciseness, because it's so damn common. To put it another way, null isn't the billion dollar mistake. The billion dollar mistake was making developers handle null. The language should embrace null, not fear it, and handle it for the developer so that they can use it expressively. 
The year I remember because a massive project started in that year. (was on Borland C/C++ 3.1 before that..). You could be right though in that it may have been the next year that IntelliJ dropped in our laps? (it was so long ago). When we started the IntelliJ build number three digits. Our site may have been on some kind of EAP? Not sure... but the only time I remember a lot of gripes with IntelliJ from the dev team was when the build number was in the low 1xxx range. Lots of system hangs and the IDE just locking up. (Can't remember what year that was). It was at that time when there were discussions about moving to another IDE. (for a long time intellij &amp; eclipse were pay-for products). Lucklily we didn't switch because it's been a sweet ride ever since.
I've been using Betbeans since I was in college. It's great for general java programming. I've found it to be rather stable for general Web Development using maven for building. It can be a memory hog at times though.
Based on your use case, I'd use Jackson. I'd gather all the data by reference in a big list or map or whatever and then serialize it to X* using an appropriate [view](http://www.baeldung.com/jackson-json-view-annotation) or using an [ObjectWriter.writerFor(Class&lt;?&gt;)](https://fasterxml.github.io/jackson-databind/javadoc/2.7/com/fasterxml/jackson/databind/ObjectMapper.html#writerFor(java.lang.Class\)) with a class that extends the full-set collection but only exposes the fields I'm concerned about. You can add in the [afterburner](https://github.com/FasterXML/jackson-modules-base/tree/master/afterburner) module for a bit of a speedup. The [MrBean](https://github.com/FasterXML/jackson-modules-base/tree/master/mrbean) module lets you create instances of classes based on interface alone, which might be helpful if you serialize using that interface and don't want to bother actually implementing the class on the other end. The fact of the matter is that I do exactly this already with Jackson, except the users all expect to receive JSON, though I'm hoping to use Protobuf in the future for Android endpoints. Changing format based on requestor is relatively trivial. *Jackson has modules to serialize/deserialize a gazillion things besides JSON, like Avro, Protobuf, XML, YAML, BEncode, [etc](https://github.com/FasterXML/jackson).
Definitely use tools like ctags, cscope and set your makeprg so you can do :make and get quickfix mode (works with ant, maven, etc). Completion can use ctags and cscope. Also check out tools like syntastic for syntax checking.
Lately, I've just been using Jackson combined with Lombok. So essentially my DTO just look like: public @Data class MyDTO { long afield; String secondField; } Still required to manually define it. There's quite a bit of implicit default behavior going on, but you can always override that manually to get a different behavior if need be.
There's basically no value for JVM targets unless you're going into ridiculous optimization territory for embedded or high-frequency / mechanical sympathy territory for performance. On Android, however, changes like the ones covered can make a difference when applied across the OS, libraries, and your application code (especially in hot pathways on the UI thread). For example, before we started actively killing synthetic accessor methods they comprised 8% of the methods in the app by count.
Mastering data persistence takes time because you have to know: - how a DB works - how the JDBC driver works - how to choose the best performing features of Hibernate - how to manage connections and transactions - etc. You can can check out [these tutorials](https://vladmihalcea.com/tutorials/hibernate/) that I've written on my blog as well.
For the first run every single time I start Android Studio. Also not everyone of us have IT department giving us SSD machines.
404?
If you're developing Swing/JavaFX application - don't buy the Ultimate version. In my company we're producing standalone clients and all team is working on Community Edition. https://www.jetbrains.com/idea/features/editions_comparison_matrix.html This is the comparison between these two versions
be simple: new ArrayList&lt;String&gt;(map.keySet()); new ArrayList&lt;String&gt;(map.values());
So this list is weird... most of them are very specific to some domains that people will not have to work on usually. 1) Commons Math, don't need it. 2) LWJGL 3, why? 3) Jsoup, ok, but it isn't a must. 4) SWT, well, I don't develop standalone apps, so no. 5) FreeHEP, for developing what?... 6) Apache Log4j, yes, but a while ago since I use SLF4J &amp; Backlog 7) Jackson. This is the first one I agree. 8) JFreeChart. Sorry, I think it isn't a must either. 9) Google Guava, yes. 10) Hibernate ORM, I agree. 11) Java WordNet Library (JWNL), wtf? 12) Apache Pivot, not bad idea, but not a must. 13) JGraphT, are you joking? 14) DOM4J, I agree. 15) OpenNLP, not bad to know. 
Great! Another crappy video that doesn't even follow the [Java Coding Conventions](http://www.oracle.com/technetwork/java/javase/documentation/codeconvtoc-136057.html) - just what the world didn't need. There are so many excellent resources out there, so there is zero need for low quality ones.
Out of the ones you mentioned, MapStruct is the most modern.
s/Every Developer/About 5 Esoteric, Academic Developers on This Planet/g
...and? What was the point of posting this, what possible discussion come come of it, what benefit to the community is it, etc?
Yes, Android apps are developed in this way, Spring applications also.
[removed]
let's say you have a blog which allows a new post to start with already-tuned things, a page with settings, and in that you have the settings for the default article data. If you create a new page to edit the default-article data, it's a Feature, but if by doing that you remove something from the settings page, it's a Breaking change. Fix is, for example, either something not working as intended, or changing a color (something that's not worthy of being called a feature). If you introduce a shortut, it only breaks something if that shortcut was used by an OS, or if you were using that shortcut for something else. Also, if you remove the old, more convoluted way, you also make a compatibility-breaking change, because prior to the update, you were able to do a thing in a certain way, and now you're unable to do that same thing in the same way. The whole concept of semantic versioning might fall apart as soon as it comes to GUI, but the Explicit Versioning does not.
yes, JASPIC authenticate fixed :) https://bz.apache.org/bugzilla/show_bug.cgi?id=59823
If you do not want to re-iterate over the collection again a `stream`solution might look like this final Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); ... final List&lt;Integer&gt; keys = new ArrayList&lt;&gt;(map.size()); final List&lt;String&gt; values = map.entrySet() .stream() .peek(entry -&gt; keys.add(entry.getKey())) .map(Map.Entry::getValue) .collect(Collectors.toList()); at some point you have to question yourself if you **have to** do **everything** with the Streams API
Have you ever had your code go through an external security review? What were the results?
Nice, thanks! 
Not sure that is a good idea.. Having a mutable principal object seems like asking for a security breach and potential confusion inside Spring security. Just defensively copy the User Entity to a immutable POJO. edit: Just found the same reccommendation in the Spring Docs &gt; Concrete implementations should be preferably be immutable – they should have value object semantics, like a String. The UserDetails may be stored in a cache and multiple threads may use the same instance. Immutable objects are more robust and are guaranteed to be thread-safe. This is not strictly essential (there's nothing within Spring Security itself which absolutely requires it), but if your UserDetails object can be modified then it's up to you to make sure that you do so safely and that you manage any caches which may contain copies of the object. -- [UserDetails JavaDoc](http://docs.spring.io/spring-security/site/apidocs/org/springframework/security/core/userdetails/UserDetails.html) 
Yes that would do no harm for sure, just one more step in the middle. 
The search bar is right there, this question got asked less than a month ago latest: https://www.reddit.com/r/java/comments/4wwdgx/bestfavoritemost_commonly_used_ide/
 Nice to see that the Vietnam of computer science gets fresh troupes.
6, 7, 9 &amp; 10 are the only ones that belong on a list with that name. And 6 is borderline.
Repost to r/ProgrammerHumor to maximize karma 
&gt; It's by far the most common scenario of its kind, and null itself is a "blessed" language feature. I'm not sure calling it a billion dollar mistake is blessing it, nor introducing a replacement (Optional) into the standard library. It's not even captured by Java's type system, which is normally strongly typed. At this point, I'd consider it more of a backwards-compatibility kludge like type erasure than something Oracle is proud to have in the language. What have you seen that makes you think otherwise? Genuinely curious - the vibe I get from Oracle is that null is on its (slow, death-by-a-thousand-cuts, backwards compatible) way out. &gt;The possibility for a variable that holds a value of type T to just not hold a value of that type? That's very special and primitive. It shouldn't be handled by higher level functions, but should be baked into the language itself. Like, a type in the standard library specifically meant to reflect that concept? Some kind of...optional type? ;) &gt;In Kotlin, the syntax itself accounts for the nullity of everything that you work with, making code easier to understand. It's expressive and readable. It's one of the few things that I'd argue should prioritize conciseness, because it's so damn common. Which is great! And, IMO, not "really" null since it's no longer the type safety destroying monster of legend, but semantics schamantics. And, to some extent, toma-toe toma-toh: I really don't care that much how you get rid of null *so long as you get rid of it*. Kotlin's null dereference operator, Ceylon fully integrating it into the type system as Null, Scala and Java's monads - all are valid approaches. My concern, however, is that Kotlin's, and to some extent Java's, tendency to invent brand new syntax for each problem results in a sort of syntactic overload sooner or later when doing the hard work upfront to settle on a single approach (monads, Ceylon style union typing) would be way better. Like, how do you handle all these exceptions? Oh, lets add checked exceptions! How do you handle null? Oh, let's add a special syntax of "??" and "?" And so on. Where in Scala, the first is handled with "Try", and the second with "Option", and both are the same underlying abstraction at heart instead of a totally new solution for the same recurring issues. What's Kotlin going to do to handle composing and parallelizing async operations? Can't have a scary monad, so I guess that'll be a new syntax as well? What about list comprehensions, new syntax? This is like programming before OO, or even before structured programming, with no ability to create and use a higher level abstraction that captures the commonalities of these cases. The funny thing is, *Java* seems to have realized this. Handling optional values, operating on collections, and async programming now officially have stdlib monadic approaches (even if the last one decided to give all the monadic functions different names...) with libraries adding even more. I think if Oracle, the self-proclaimed champions of blue collar programming, caved in and added monads to their standard library then you have to give them a *little* more credit than you seem to be doing right now. I mean, meet me halfway. I see how the concise syntax and easy-to-learn nature of null dereference can have advantages (I actually snuck it into my Scala project using extension methods, don't tell Martin Odersky!) Do you understand why Scala (and Java!) developers like the unified abstraction monads provide, despite the initial cost understanding them requires?
One thing I was wondering is does the Java build use Gradle? I have found Gradle to be slow(compared to Maven or Ant or raw Javac) we might be hitting Gradle startup times as a hard limit on the compile time here.
I've had to roll all my systems back to 8.0. 8.5.3 would have this issue that after several hours cpu load would jump to ~40%, then a few hours later to ~60%, then 80% and so on. I've seen others reporting the same issue on stackoverflow, but no solutions. Anyone have any ideas about this?
Interesting. TIL about the Gradle daemon. Is there anything comparable in Maven? I guess this is where Eclipse shines, having built their own in-IDE compiler that also speeds up after time when JIT kicks in.
That was I would like to know (comparison w/ Maven). Never heard if Gradle before, wonder how new and popular it is. 
No, because Maven is implemented in Java and quite fast. It doesn't need a daemon to cache its code.
IDEA IntelliJ from JetBrains, for both personal and professional use. Also, all the other IDEs from them are awesome, I use RubyMine and PyCharm daily. 
[removed]
It is very good mature build tool, that has reached v3.0 recently. Spring project and Hibernate library both use it
Are they misunderstanding what "de facto" means?
[removed]
You have three main choices: Netbeans, IntelliJ and Eclipse. If you're willing to pay actual money, then InteliJ is hands down the best option. If you're a commercial java developer, there shouldn't be any question about which IDE to use. It's one investment in your tools that makes perfect sense. If you're not willing to pay money, then really it's more a matter of taste. There is a free Community version of IntelliJ, but it lacks many of the plugins for frameworks that makes it so compelling. Netbeans has a lot of fans. Eclipse has a large community of users. 
FYI in the crypto sections there are some parts that should be carefully looked at: The use of Arrays.equals in https://github.com/rapidoid/rapidoid/blob/0e9a952611ce7f4d27523199ff888fd49d62effa/rapidoid-commons/src/main/java/org/netnix/AES.java#L112 is susceptible to timing attack. You should use MessageDigest.isEqual . Another issue: the IV vector is always a 0 filled byte array. I'm not sure if in this specific case there are some security implications, but you should be _very_ careful: https://github.com/rapidoid/rapidoid/blob/0e9a952611ce7f4d27523199ff888fd49d62effa/rapidoid-commons/src/main/java/org/netnix/AES.java#L77 I would advise to do an auditing on this parts.
No, but with IntelliJ being more popular in use it's kinda silly to claim Eclipse is the de facto IDE. 
Is it though? Reddit popular is not the same thing as real life popular. I encounter a lot of Eclipse in the workplace and education spaces.
Might be nice for mobile apps where you are the only consumer. In general the ease of parsing Json outweighs the efficiency of protobufs.
I highly recommend packaging your java protobuf compilation as a submodule or dependency. It makes a more convenient source of truth for java than the .proto There are several good options for java proto compilation. With gradle I found it easy enough to write an integrated task.
You probably didn't get the point about JIT from the article...
&gt; There is also protonpack which has windowed streams That library implements what many FP libraries call "windows". SQL's window functions are something quite different (i.e. much more powerful). &gt; Which Java 8 support library to include? [The answer is again on the jOOQ blog](https://blog.jooq.org/2016/05/12/cyclops-react-organises-the-cambrian-explosion-of-java-8-libraries/), i.e. [cyclops react](https://github.com/aol/cyclops-react), a library that builds on top of all the other libraries :)
Write some projects and push them to GitHub. Use it like a portfolio to prove your competence.
Well, by not being a Java programmer, but just being a programmer. Started out as a junior doing some maintenance stuff in some ancient language, moved on and got certified for C# / .NET, transitioned to Java in my next job (which originally used the same ancient language I started out with).
Went to college and took co-op.
IntelliJ had in-IDE compiler too, and they extracted it in its own process in [IntelliJ 12](https://blog.jetbrains.com/idea/2012/06/brand-new-compiler-mode-in-intellij-idea-12-leda/)... Few years back I have made a compiler daemon for IntelliJ, and it was super fast, unfortunatelly they did not adopt it, but rather made only a preloading of the compiler process... :(
/r/cscareerquestions might be a good place to get started. My situation is probably not the same as yours. However, "how did you land you first [insert field]" is probably not a great question. The reason why most people land their first job is usually well beyond their understanding. Instead, you should be asking, "why would someone hire a junior/intern/entry level developer"
Only one of them is reeallyyy a word
Like most things in tech there is no one best platform for everything. Why type of application are you interested in? JEE solves problems that are not solved by other frameworks. If your application needs those things then it great. But it maybe too heavy wait for some more simple apps. 
Well. I have a very sophisticated application, that is clustered over 50 server's and uses asynchronous queues. JEE is perfect for my app. 
Did some projects in my spare time. Decided to apply for a Java dev job. Got hired.
It's awesome that you included the license in the list!
That was me. Degree in philosophy. Self-taught html and amiga basic (I owned an amiga 500). "Can you program in Java and perl?" "Uh, yeah! Yup!"
Applied to different companies until someone was eager to hire a novice. The more professional experience you have the easier is to find a job.
I'm actually a bit curious what extra functionality you use in eclipse. I use the maven felix bundle plugin and specify any manual stuff I want in the manifest and the plugin takes care of the rest during the build.
Different definitions of simple. If you are utilizing those services I wouldn't call it simple. It may not be complex either. But as you say JEE saved you from writing some complex things. 
A college degree could be a must to get a job in most IT companies. But some of these can certainly offer you a contract based job if you've good Java/J2EE skills and experience. So, first of all, get some freelance experience in Java/J2EE. Join something like UpWork or other. You can also start a Java based tech blog with WordPress or Blogger. Train yourself and share with others. Just keep learning, till you reach your goal.
Spring is a must, but I didn't write the list of the article ;)
This is horrible, the server only accepts one connection and then shuts down. It doesn't listen for any follow-up messages.
Kindly explain number 1, 5 and 6
thanks. i still have trouble understanding no1, but thanks nevertheless 
These are also useful questions for the OCA exams
What sort of projects?
Kindly recheck, all answers are correct and validated through execution.
Fun Android apps, for instance. Start small to avoid losing interest, then move into bigger ones over time
I'd imagine this: &lt;div class="aspNetHidden"&gt; which can be found from the site source.
The examples are for Java 6 and older
...which is probably why Swing is a section instead of JavaFX.
I would recommend using gRPC rather than just protocol buffers. There's a spring boot starter here: https://github.com/LogNet/grpc-spring-boot-starter and the official website: http://grpc.io
There are some JEE standards that I think are done fairly well, such as CDI, JAX-RS, and EJB 3.1+. JSF sucks, and I prefer using Angular 2 or even 1.x for an MVC. My current comfort zone is writing an Angular 2 MVC with a RESTful backend in JEE.
I think it is mostly the type of projects you are working on and the type of people who are using your products. I spend at least 20% of my time doing math, and probably another 20% interacting with math heavy code or reading research papers which require math familiarity. I rarely struggle to explain an algorithm to a coworker (once I understand it well enough) because the language used to express it happens to be math, which we both speak and is fairly unambiguous.
Had some experience with web development with PHP, in 16 years started working on android apps then moved to server side. After doing some Open Source got an email from HR for remote job and accepted it (but didn't tell them my actual age)
The "The Silver Bullet Syndrome" by Hadi Hariri is quite interesting.
I have little to no experience in Java programming. I applied to a nearby IT company that gives training/bootcamp if you pass their IQ test. I passed their exam and have received their training and oh boy, I've learned a lot!
IMO, the point is here that Indians (as well as many other Near/Middle/Far East nations) are good at *memorizing*, but fairly bad at *creativity* and *application*. This seems mainly to be a cultural - upbringing - problem, though. In countries like India (and generally in a lot of the Near, Middle, and Far East countries) the commonly accepted method of learning is through *memorization* (i.e. learning by heart, or parrot learning) rather than through learning by understanding. Schools often focus more on how well the students can replicate what they have learned than on how to *apply* the learned skills to create something new. In general, this leads to the "qualifications exams" obsession. People can study for these exams and pass them with quite high grades, but will still be unable to code anything outside what they have learned. Creativity is often suppressed in these cultures and as long as this will not change, there won't be any better programmers coming from there.
It's really nice, prefer it to maven 
I see that 2 new JDK9 committers have been nominated in the past few days (after that email that sounded like delays). If a project is late, throw more developers at it? http://mail.openjdk.java.net/pipermail/jdk9-dev/2016-September/
1st of all what would be a better page 2nd you're right 3rd it's okay I'll live 
Google some freelancing websites and post an ad on a reputable site.
&gt;started in support This is a big one that shouldn't be overlooked. Many shops I know are looking hard for folks with basic coding knowledge who can work a support role, but too many developers have a negative opinion on support work. By taking on a application support role, you'll be exposed to existing code, likely helping to triage issues and making some code changes. An application support team also participates in project and code reviews because they pick up ownership of the code when it hits production. These are good ways for someone with basic coding skills but limited work experience to gain experience and there's usually a growth path available.
How about [High-Performance Hibernate](https://vimeo.com/album/4133413/video/181896822)?
&gt; unify both OOP and FP C++?
Red Hat isn't one to fork without reason, but if Oracle ends up dicking the Java EE spec around I suspect they will happily do so. Oracle may control the JCP, but there's absolutely nothing preventing a fork from happening except for not being able to get Oracle's seal of approval.
A fork is "easy" if there are only few stakeholders in the product. E.g. the same can be said about Hudson / Jenkins. As for JavaEE, I'm not 100% convinced that Oracle's competitors will not get further fragmented.
Is this a parody? Sarcasm? Why in hell wouldn't you just store the epoch millis as a long like developers have been doing for thirty (forty?) years. Some people just need to over-engineer everything. K.I.S.S.
&gt; … there's absolutely nothing preventing a fork from happening … There is. It's called IP law. All Oracle led JSRs (JPA, MVC, Servlet) effectively belong to Oracle. If you fork them, you'll be sued — see the Google case.
The native timestamps offer all sorts of parsing/extracting functions which are very useful and practical. Numeric columns are meant for storing numbers, not date/times. Check out [this StackOverflow question](http://stackoverflow.com/questions/409286/should-i-use-field-datetime-or-timestamp) for more details.
Those API's come from open-source reference implementations.
I really like this. As the author points out, this is really useful in sql, but I am coming up short on java usages for these (in my world anyways). I write a lot of analytic queries, but those are best left to the database (where I can easily keep track of how expensive my query is). It would be cool if there was a tool that did something similar for this.
The actual product (the RI) can still be forked, as its GPL licensed. You do lose the spec part of it, and it would become a "regular" OSS project, right?
Does anyone know of any efforts to incorporate LetsEncrypt directly into the JVM ? I'd rather not involve proxies.
same
Are you sure it's not in 101? I think I could connect without cert errors.
It's since 8u101
Very interesting read and well written, thanks for this.
Thank you!
There are libraries for [issuing a certificate via the ACME protocol](https://github.com/shred/acme4j). Otherwise I'm not sure, what you mean by that, in the end the LE client just creates a cert file, which can be referenced by a application/web server (e.g. Underow/WildFly). My problem currently is, that I have to shut down my reverse proxy (which sits on port 80) to renew the certificate, because the tool needs the port to verify the domain. I'm not sure, if there is a elegant workaround, which doesn't compromise security :(
List here projects that were donated to Apache, then died within 2 years. Is HudsonCI still alive? 
Wait, what? Oracle doesn't want NetBeans any more? Damn. What the hell did they buy Sun for, anyway? So they could lose fucktons of money on lawsuits?
Well I'm sure killing MySQL was a bonus for them.
Is this anything beyond a proposal? Has Oracle voiced any interest in getting on board? If not, the proposal is a pipe dream, albeit an interesting one.
Which leads me back to... "This is cool, but not that useful"... :/
I'm calling shenanigans on these ImportJava issues. It included the "15 Java Libraries Every Developer Should Know" article, which was posted on this sub and many agreed that these are not libraries every developer should know. I just question the quality of this "publication" and whether they are just recycling links from this sub. 
"Standards" rant: I wrote an app targeting Payara (Eclipselink). Works fine. Switch to JBoss (Hibernate), get LazyInitializationExceptions, use fetch construct, works fine, YAY! Test it back in eclipselink and now I'm getting duplicates returned so Hibernate is autofiltering them while eclipselink isn't (and apparently EL is eager fetching the associations in the first place which is why I wasn't getting LIE before). Settled on "accessing" the collections before getting out of my EJB method/transaction to load the collections. Anyone know a better way?
Well I meant MySQL proper. Thankfully the project founder is moving forward with MariaDB.
It wouldn't be there if Oracle wasn't on board...
There is a relatively large list of contributors in the announcement (myself and another guy from our company included). I don't know if we'll be able to make NetBeans fly as an Apache project but one can hope... I think that one of the big benefits here would be easy forking, e.g. we would be able to distribute our own version of NetBeans with our own plugin already installed which will make the process of user acquisition much easier. Previously this was possible but with the Apache license there is less legal concern as it is very lenient. 
[Here's an interesting talk from OOW14](https://www.youtube.com/watch?time_continue=2&amp;v=fzCpd4j72jA). Already a bit outdated, but I'm pretty sure that trend (more staffing, more engineering) continues. If you're interested, I suggest following [Morgan Tocker](https://twitter.com/morgo) (the MySQL product manager) and the articles on the [team blog]( http://mysqlserverteam.com/meet-the-mysql-engineering-team) PostgreSQL is interesting too, of course.
Nobody wants to use JEE, just like nobody loves Java. It can be a reasonable choice for very large companies to create server systems that must live 20 years or more, maintained by ever changing teams of people with very little computer science experience.
Yeah, I know. Silly me. Recently went to the U.K. and couldn't plug in my hairdryer... Sheesh. Had an electrician fix it. Came back to Switzerland and damnit, didn't work *again*! ;)
Yup - my bad
I have a cron job that automatically updates the LE cert - every 90 days, I think - without having to reboot apache.
[removed]
But the AC is following the same rules of Physics, so it's a Standard.
The U.K. exited physics some time ago.
You will most likely get better feedback in a subreddit that is either general as /r/learnprogramming, or in an angular specific subreddit as in /r/angularjs. Your post is completely off topic here and against the purpose of the sub that is stated in the sidebar: **News, Technical discussions, research papers and assorted things of interest related to the Java programming language** Your background as Java dev is completely irrelevant to your question. **Post removed:** Off topic.
Okay. Thanks 
But why would you use Hudson instead of Jenkins?
Well that's a bummer. Assuming this goes through, it will now be postponed from its original GA date by ten months.
You *sure?* The proponent of the migration (Bertrand Delacretaz) is an Adobe guy. Nowhere in the rationale or history is there an indication that Oracle is backing away. Is there another source for this?
Just to be clear, I'm not an Oracle employee...
They should switch to shorter release cycles and release the "smaller" improvements / additions in between the big ones. They are mostly finished and we are basically waiting for the module system (which is not really warranting a delay for the rest **imho**, especially when using OSGI already).
to be hipp disclaimer: we just replaced our hudson with jenkins
once upon a time they shared the same code and then it was forked
can someone ELI(first year CS major student)
Its been years since I followed NetBeans. Was it a 100% open source project -- no business sponsorhsip? Is this proposal about the project folding up and the code being stored at Apache? 
AWT was good enough.
From what I've seen so far it looks pretty good. I especially like the link tool. 
Awesome - that's exactly the kind of thing I was looking for.
That's like saying that eating salad is good for you. I've seen people coding PHP living over their 30's, but never thought about their lives. I think we need more people like you. Let's go full Java.
I like rust's 6 week stable-&gt;beta-&gt;nightly model. What gets on stable every 6 weeks is what has been tested for at least 12 weeks (and usually longer). They don't have major "goals" for each release, they are strictly "we hit the 6 month mark, what can be promoted?"
Logistically speaking, that is insanely difficult for a project at the scale of Java SE. A game you can just push out an update. For something as cross-platform and industrial as Java, it just isn't a simple task
On the other hand, Linux kernel releases and distro updates happen pretty regularly. It's not "insanely difficult". It's actually easier to release often than to do these huge every-couple-years-or-so releases. 
ok i guess i understand the basic point. but then whats the point to this? do you know any practical applications? 
I'm pretty sure _forked_ has become a euphemism at this point.
Technically the community voted to rename to Jenkins. All Oracle owned was the trademark.
hmm. dont see how this would make it a practical use if you dont have a time limit. why cant you just use the regular exec methods then?
I personally favor spring (specifically spring boot). It does most the bootstrapping (e.g. auto configurations) for you - so it's off to the races fairly quickly. The perk of something like Spring is that you're tapping into a fairly cohesive ecosystem, so if you need persistence (spring-boot-starter-data-jpa), secured routes (spring-boot-starter-security), service bus (spring-boot-starter-amqp), etc. each of these coming with fairly sane defaults, and typically only requiring a few configuration parameters (well, security is a little different story, as it always is). Additionally the spring context enables some nice inversion of control and makes testing pretty darn simple. All that said, using spring typically pushes you toward the spring way, for both good and bad. Some people really prefer more manual control and architecting each piece. (E.g. Django vs Flask, Rails vs Sinatra, Sails.js vs Express, etc.)
This what I have running on Ubuntu Server on AWS: 30 2 * * 1 /opt/letsencrypt/letsencrypt-auto renew &gt;&gt; /var/log/le-renew.log
Are you brent? Thanks for the tutorials man :)
Yes. People forget the benefits of getting quality software because they are so horny for new fresh features. The stability of the java echo system is the reason for its success. That's why companies has wanted to bet on it. 
Even if you don't like Spring itself, this tells about the design of the components, reasons behind it, etc. by the guy behind the decisions.
[removed]
Nintendo lawsuit in 5...4...
Slow release cycle vs. flawed releases is false dilemma. 
Yea, this was made using Libgdx, pretty cool tutorial. 
Well, at least with Java 8 there is this: http://www.informit.com/articles/article.aspx?p=2216988&amp;seqNum=2
Bonerific
It took me a while, but intelliJ rocks (I'm a licensed user). I also still love Eclipse for its freedom. Netbeans, not so much.
Kinda confused, feel like I'm missing out on something here. How is that relevant to the source code or libgdx? Is it that signed primitives aren't as useful for game development as unsigned?
This is the spec version, for Java EE among others.
I actually don't like the stream API. I think it makes the code less readable.
Clearly, but at some point you've gotta lose faith in the folks running the project. If it was just implementation bugs that needed ironing out it wouldn't be so bad, but design issues that fundamentally undermine the goals of the project? I mean, look at this [list of unresolved issues](http://openjdk.java.net/projects/jigsaw/spec/issues/). Seemingly fundamental questions that don't appear to be settled yet: What are legal module names? Are cyclic dependencies allowed? Should the module graph be mutable? How should separate modules containing non-exported packages of the same name be handled? How should different versions of the same module be handled? What is the syntax of version strings? This list is *absolutely batshit crazy* when you consider how long the project has been active, and the idea that they'll get the answers right in 4 months when they haven't in 9 years seems, uh, optimistic.
It can, but that really depends on how you use it. It also adds much needed "Linq"-like features, along with functional programming features. 
I agree with you on that!
How does it compare to Jackson json?
This is an API, for converting json to java objects.
This should be in Standard Edition, same as JAX-B
Not sure. Most feature are (close to) finished. Just waiting for Jigsaw.
yes, it has some neat little features like using maven for local deployment (so you do not need to deploy all your dependencies) or only package the required parts you are using making the deployment even smaller (forgot how the feature was called)
I believe you need a JDK and set the path/environment variables along with the JRE. 
&gt; Kinda confused, feel like I'm missing out on something here. How is that relevant to the source code or libgdx? Is it that signed primitives aren't as useful for game development as unsigned? First, the obvious once: &gt; 0/255 An unsigned byte stores values from 0 to 255. No unsigned bytes, so it scores a "0" out of "255". UPROARIOUS LAUGHTER. The less obvious one is that the NES, the platform for which Super Mario Bros was originally released, is an 8-bit platform -- thus the processor's upper limit being a single byte. To fully exploit this, you'd use an unsigned byte when programming, raising the maximum value you could store in a byte to 255. SUBTLE HUMAN LAUGHTER AT REALIZATION OF TIE IN WITH PREVIOUS JOKE.
Matter of preference I guess. I find streams code far more readable in the majority of cases. If the stream refactor is less readable, it could be an indication that your code block has too many responsibilities and should be abstracted to another method. 
I wish Java had a better fit for "efficient ad-hoc data structures" than having to create plenty of classes for POJO projections explicitly. Hell, even JavaScript has "hidden classes". Objects compile to hidden classes behind the scenes, so the hashmap representation never kicks in (except in rare circumstances). Java has hashmaps... but, they're just that. No optimization, no direct access to fields, no hidden classes. Just naive hashmaps.
Confusing name considering binary json is referred to as jsonb.
It is exactly like Spring Boot, but if you are a Java EE developer, you take advantage of that knowledge, because you use EE features and APIs
This question is really general, but yes - we are. We have a spring boot app serving the client assets for a react app. We are using the maven-frontend-build plugin that installs a local node and builds the front end on compile, dumping it to the public folder so spring (tomcat) can serve the client assets. What are you looking to do? If you aren't bundling them together they're totally separate entities and have little relation (that's the direction I'm pushing my teams).
It's strips component from JBoss eap instead of tack on to tomcat.
This is ugly code. Would never get through code review, and would probably be flagged in build.
You're right - your GameMap class should have all the state and behaviors of the TiledMap class. Are you saying your GameMap object can't call any of the TiledMap methods? Looking at the documentation, I don't see anything that would imply that you couldn't extend it, so I don't know why it wouldn't be working. Can you post your code?
If your back end is a REST API, it makes no differences what you implement it with. Spring is great choice. It's not especially well or poorly suited to mesh with React.
I guess what I don't understand how to set them both together. I'm super new to react but have a couple months of experience in Spring. And I'm not to sure on how to pass the data to react. Do you just do a API request to pass the data from spring?
Ahh i see ya that makes sense. I guess I was confused because I usually pass my data using ModelMap instead of doing API requests most of the time. Ill try to find some tutorials on putting the 2 together.
AFAIK you can already use jaxb annotations with jackson today. It isn't as powerful as the full jackson feature set but it's decent enough, and compatible :) 
Or a condensed equivalent for lazy assholes like me.
Well that and [jsonb](https://www.postgresql.org/docs/9.5/static/datatype-json.html)
What is so bad about copy pasting, when you are a beginner? You learn by imitating it. Personally, when I started I did not think "ooh what a cool concept" but more like "oooh it worked \o/". Positiv experience is a much greater factor to improve learning (especially motivation). 
What do you mean stolen content. Can you please clarify
What time-saving features? Could you provide some examples? I'm on a fence when it comes to switching to Intellij, maybe those features could convince me finally :) 
Lol that graph of popularity over time was just horribly made.
Apache Incubator is where projects go to die... :/
Eh it's closer to a graveyard for already dead projects.
I like to think of it as a crucible. The projects that make it out of incubator have to do so by (among other things) proving both demand and support exists. The "I like this product, but not enough to pay for it or help maintain it." attitude of many OSS users is a big part of the challenges that OSS as a whole faces.
&gt;The "I like this product, but not enough to pay for it or help maintain it." attitude of many OSS users is a big part of the challenges that OSS as a whole faces. +100
I was flirting with the team lead of a Java project and asked if she had any openings I could fill.
A pity, there was a lot of good technical aspects of the NB platform. But, arguably, it is a pale option compared to what IntelliJ offers today.
Why do so many people assert that consumers should help maintain anything? Consumers don't want to help their suppliers keep their businesses running. Why should they? OSS is free beer. If a vendor doesn't have a good business incentive to offer the free beer (e.g. to increase demand of some other product), then the beer will go stale very quickly.
I see but the NetBeans is not the first project what the Oracle gives to the ASF and after a while the project slowly dies. And the NetBeans is not really developed in recent times... :(
It depends on which software you are downloading. Not *all* need it.
Give Oracle some credit. They're pretty good at killing stuff, too.
i looked into Vaadin for some of my personal projects, but have not yet used it. IIRC all the code is written Java, and the Vaadin framework separates the code intended for the front-end from the backend processing; then Vaadin uses GWT to generate JS from that Java code for the FE, for execution on the client side.
&gt; is pretty much equivalent to most of NB functionality. Is that true? I use Jetbrains products with a student license, so I've never had to use community, but if that's true...that's awesome!
Hey-hey... the Linux has some commercial "attitude": lot of companies support and develop it as an open source software.
THANK YOU FELLOW HUMAN I AM NOW LAUGHING HAHAHAHAHA
Repost
In principle no, because hidden classes in JavaScript are determined at runtime. The engine doesn't try to predetermine all possible classes the app uses ahead of time. So it's a distinct VM feature, not something one could fake with source generation. In practice, it depends what would those generated sources be based upon. I'm not aware of any succinct way to express an inferred type in Java inline, in a way that's susceptible to generating classes out of that.
Those developing applications on the netbeans platform are probably getting nervous. 
Thank you very much! This answered all my questions, i think i'll go with Spring as it also is the most popular java web language. What are your thoughts on Play? As for employment, upon research Spring is more popular here in the Philippines :))
So it's kind of like Flask and or Express? More minimalist approach
One of the most important things you'll learn doing Java development is that you often don't need a full JavaEE application server. Instead, you can use a Servlet container and add the libraries you want directly to your project/application.
That doesn't mean NB is better
Intellij refactoring is so much better than NB's that you can't even compare them. Also automatic duplicate code detection and so much more than NB
Very cool additions!
I just finished doing a POC with Spark Framework and, boy oh boy, was that fun. If you want a light, no frills framework, I highly recommend it.
Why the hell Swagger is in "Top 6 Frameworks for Creating RESTful Services in Java" list!!!???
And where are the Java EE 7 implementations? Where is Wildfly Swarm? :)
Shhh. We do not talk about JavaEE 7 here..... Standards are bad, dont you know! (/s) 
Hell, the list is Missing vert.x. it is awesome!
Why is this shit post getting up votes? 
I meant features like Java EE support. That being said, I use IntelliJ. 
Because it's pretty cheap to buy 30 or so upvotes to get something high on the front page of a sub. 
&gt; The Java Script is one such language which is stayed up with the latest and is for the most part utilized for little to enormous activities. Relevance? And also... wut?
Agreed. It'd also be nice if a CompletableFuture could be mapped and flatMapped over (thenApply, thenCompose) in a way that didn't make checked exceptions so annoying. You can write your own method that catches any exceptions and returns an exceptionally completed instance instead, but it's annoying as hell.
I only buy the Enterprise edition because it has other plugins that I like, like Cucumber etc. But for regular Java development, it's a great choice.
I just registered to say one thing: Inb4 someone tells you that Jhipster is actually just Spring boot with angular and that you could very easily adapt it to fit your needs. But you know what future smartass ? Don't. Op asked for everything out of the box, no adaption of anything is that so hard to understand ? No don't suggest him the spring starter projects, those are just cheap examples but not templates. 
Well, it is and at the same time it is not. There is a lot of configuration going and if something goes south I would probably have to spend at least a half a day to track the bug down, debug and probably in the end change some random variable in the config. What I like about JHipster is that it gives you token authentication out of the box with registration mails and whatnot. What I don't like is that in order to add an entity and have everything working I have to go through some dumb creator, which doesn't even let you remove entity if I screw something up in the process. Huge no-no for me. 
Thank you very much. I came to the conclusion that what I am looking for is something like a maven archetype with already generated User entity and everything that goes with it.
You still have to write shit with hashing passwords, passing authorization token, sending confirmation mails etc. This is actually pretty standard and does not differ from app to app that much.
I believe this isn't new, and has been going on for the last few versions at least. Industry-wide APIs are using more static code over the more Object-oriented ( Or "Instance" oriented? ) approach of the last decades. Constructors in general are used less, and static factory functions are used more. I've been doing this myself, using an "Immutable by default" approach to objects; "final" classes with all final members and with private constructors only but static factory methods. It seems that is tied to moving to a more Functional approach to languages and APIs. As higher concurrency requirements are causing this approach to look more attractive every day.
I mean beyond all of that, manually boxing the primitive like this shouldn't ever be necessary
`Integer.valueOf(theInt)` as the deprecation note says, or rely on autoboxing.
i dont know how I overlooked that, thanks for the reply
They are immutable, so it makes sense. There's no reason to construct them that I can think of.
I use `new Character(c)` as a workaround for a performance issue (https://tavianator.com/java-autoboxing-performance/), so I hope they fix that issue at the same time!
&gt; Constructors in general are used less, and static factory functions are used more. Constructors should still be favored when possible. They make for a better API experience as you don't have to go hunting around for some randomly placed static function. Though in this case it does make sense, as the constructor interferes with caching.
Since this is programming help it should go in /r/javahelp as the many hints on the subreddit indicate. Please read the [*Posting Guides*](https://redd.it/48eykt) there and *repost* there. **Post removed:** programming help
I would suggest that you search for "Java console typewriter" that should help And if not, try to do something like this: 1second is 100 percent of the String. And the time passed you can get with the following idea: Current time MINUS starting time. If you do not know how to get the current time I suggest to Google for "Java current time"
They have done the same for the constructors of `Boolean`. Good. There should never be more than two instances of `Boolean` in a VM.
&gt; Though in this case it does make sense, as the constructor interferes with caching. How so?
[removed]
Type "new ClassName" for a list of all available constructors. vs. Search through the docs for anything that returns the correct type 
Boolean.TRUE, Boolean.FALSE, Boolean.MEH
This is fairly common: static Integer lock = new Integer(0); You need a separate object instance for that to work as expected.
It's fairly common to use explicit `Integer` instances for locks. You can't use the auto-boxed values for this because something else might be locking those instances. Of course, `new Object()` works equally well for obtaining a lock object, so this pattern has always been a bit bizarre.
&gt; It's fairly common to use explicit `Integer` instances for locks It is? I've never seen that, and don't understand why it'd be sensible. I guess if you have a class with a final Integer field and some other mutable fields, and you don't want to synchronise on the object's own lock because it's public... Yeah I can't see that coming up often.
“Fairly common” might be a bit of an exaggeration. I'm not really a Java programmer, but I've seen it in Java code. At least it's better than using a string literal (which the JVM will intern and share with who-knows-what other code, potentially leading to deadlocks). Explicit, private lock objects are not *that* rare, but most of these use `Object` instances, which work equally well.
True, false, file not found: http://thedailywtf.com/articles/What_Is_Truth_0x3f_
You can use `static final Object lock = new Object();`
Or use anything under the Lock or ReadWriteLock implementations.
That sounds similar to lazy initialisation: if it already exists, use it, else make a new one. Edit: corrected to say it is similar, not the same as lazy initialisation.
&gt; You can return a subtype, very useful when dealing with interfaces. You are putting the horse before the cart. Abstract interfaces are a solution tool, not a goal. *** If you need to be able to return different subtypes based on parameters, then a factory makes sense. But that's pretty rare. More often than not one actually knows what concrete class is desired and the combination of factory methods and abstract interfaces are nothing but masturbatory exercise in unnecessary complexity. What's worse is when application code actually needs its own factory method. If the library doesn't offer public constructors, you end up with this weird situation where you have factory methods wrapping factory methods.
What does deprecation mean in this case? Will the constructors be removed in Java 10+? If not, then it won't change anything as long as there are old libraries or deprecation-ignoring authors around.
I don't know about that. I wouldn't be surprised to learn that `new Integer(5)` gets interned by the compiler just like a string.
Has Java ever removed a deprecation method?
No compiler or VM will intern `new Integer(5)`, at least not casually, not unless it were explicitly enabled as a special option. The specification of `new` is that it returns a *new object*, always. To do otherwise would mess around with reference equality and would violate the langspec. String interning is different -- that is explicitly specified that it must happen, so to *not* do it would violate the langspec.
&gt;`valueOf()` might cache a few common values (0, 1, ..., 127) To be precise, `valueOf` is specified that it *must* cache -128 through +127, and *may* cache any other values.
But now, if they do start interning the Integer objects, this will potentially start causing deadlocks. Better change it to new Object().
Autoboxing isn't being deprecated, only explicit constructor invocation, in favor of `valueOf` or autoboxing.
Not really, but they plan to eventually change that. http://openjdk.java.net/jeps/277
Actually, lazy initialisation is to only create it when used, not on declaration. Think of an object with a `init` flag, defaulted to false and switched to true once a method of similar name is called, and that method will initialise every data field of the object or do nothing. Probably will get called with every method call. Actually, I don't know how to map the concept to a Java class, but this is the easiest, yet brute, way to somehow manage lazy Object initialisation I can think of this time of the morning.
Ah OK cheers. Sorry
You don't have to do that. You can add the entity yourself, if you choose to or delete it by hand (by the way, I think there is an option to remove created entity)
Set your environment variables. See [link](http://stackoverflow.com/questions/3820954/java-home-environment-variable-and-java-jdk-fun) 
No worries! :)
&gt; Their sizes cannot be modified. Arrays are meant to have a fixed size. It is like that in most C-like programming languages. &gt; You cannot alter their contents (object is immutable exception) That's completely wrong. The *types* you listed are *immutable* (`String`, `Integer`). &gt; Converting from one to another is a major pain-point. What do you mean here? &gt; Converting an array to an ArrayList is also very tedious. It isn't. There is `Arrays.asList` ---- &gt; Here's an example that combines all of the above points: &gt; Let's say that i am receiving multiple strings from the user. Each line of which contains lots of numbers ("5 15 546 45 87 94 1 2"). &gt; Now I want to store them as an ArrayList of int arrays. It should be a simple thing right? It's not. &gt; So I can first split them using " " space character and return a String[]. But I cannot dynamically convert it into int in one line. So I need to first store them in a String[] array and then access them one by one and parse them into an int array. However, for an int array the size needs to be declared beforehand and once you declare the size then you cannot modify their individual members. &gt; It's like a catch 22. Whenever I have to work on a problem involving arrays I really hate it. Here you are making plenty completely wrong statements. &gt; However, for an int array the size needs to be declared beforehand and once you declare the size then you cannot modify their individual members. You can modify the individual members. Why do you think that you can't? The size needs to be declared in advance - so what's the problem? The split `String[]` array has a `length` that you can use to set the size for the `int[]` array. ---- Seriously, your rant is incoherent and mostly wrong. It shows that you lack lots of fundamental understanding of the concepts. You need to learn a lot more before you can make any rants - especially since you don't really know what you are talking about. 
Java's arrays are bad, but not for the reasons that you've listed. --- &gt;Their sizes cannot be modified. That's by definition. An array is a contiguous part of memory. Changing its size would require a reallocation, and that's precisely what an ArrayList does. --- &gt;You cannot alter their contents (object is immutable exception) Arrays *can* be modified. where are you getting this from? --- &gt; Converting from one to another is a major pain-point. T2[] array2 = Stream.of(array1).map(x -&gt; foo(x)).toArray(size -&gt; new T2[size]) --- &gt; Converting an array to an ArrayList is also very tedious. Arrays.asList(array) EDIT: Corrected the method name. EDIT2: I didn't mention that this will only work properly for non-primitive arrays. For most primitives such as ints, you can use streams: IntStream.of(intArray).boxed().collect(Collectors.toList()) --- &gt; Now I want to store them as an ArrayList of int arrays. int[] intArray = Stream.of("2 53 234 1 2".split("\\s")) .mapToInt(x -&gt; Integer.parseInt(x)) .toArray(); Frankly, most people just don't use arrays directly and stick to the collections.
I could swear that I got the exception "Unmutable types" or something like that when I tried to assign a value directly.
This might come as a shock to you but ArrayList uses Arrays underneath.
&gt; The *types* you listed are immutable (String, Integer). Even so it's annoying to have them as immutable. I don't understand why they're immutable. At least Integer[] array should allow for replacing that element with a new Integer object. &gt; Converting from one to another is a major pain-point. I meant converting an array from one primitive type to another. For example converting String[] to int[] or int[] to long[]. It feels unnaturally complex. &gt; It isn't. There is Arrays.asList Whoops. I guess I missed that method. I had been trying to do this with for loops. &gt; You can modify the individual members. Why do you think that you can't? I tried modifying it on multiple occasions and received exceptions. Yes I did use the length (the one which is an attribute not a method) and yet I had problems. From what you are saying it sounds like I've run into specific problems and it makes sense to resolve those issues one at a time online. Anyway, I'm sorry that my rant didn't make any sense. :(
FindBugs has been bugging me about not using these constructors for some time now, but I had no really good reason to mitigate those warnings in legacy code. Seems like now I have. Great! :-)
&gt; I don't understand why they're immutable. You don't understand a lot of things. Next time you should ask instead of assume. Most of what you said sofar is just plain wrong. And a lot of the stuff you don't get can easily be [googled](http://stackoverflow.com/questions/22793616/why-integer-in-java-is-immutable). 
So does his stream and Arrays.toList example. In fact you will have a hard time trying to "convert" (Atleast primitive types and immutables. As for references, copying is the same as converting)
&gt; add @Deprecated to java.util.Observable and Observer (JDK-8154801) I don't like that. As long as there is no standard lib unified way for this pattern. Is there any standard alternative? What is _1.1 Beans/AWT event model._? 
&gt; Converting from one to another is a major pain-point. That's not converting from one to another. That's copying elements. &gt; Their sizes cannot be modified. And you are not modifying the size of an existing array, you are creating a new one!
&gt; And you are not modifying the size of an existing array, you are creating a new one! And that's exactly what an `ArrayList` does when it needs to resize.
Which is also the reason why I commented your original post and not OP's. I just gave a performant alternative to streams for copying. That said, I wonder if parallel streams would outperform arraycopy at a certain size.
This is usually a better option: static Object lock = new int[0]; 
Why `new int[0]` and not `new Object()`? The empty array object still needs space to store the array length, so an `Object` instance could be slightly smaller. There is also this variant: static final Object lock = new Object () { }; This creates a separate class, which can be helpful for type-based biased locking optimizations.
Except the second line of your code would result in an ArrayStoreException. Please, before being a smartass, do some research and learn how to admit your mistakes.
Example works fine if you do not mix types obviously.
And I clearly stated that my example takes an array of one type and maps it into an array of a different type! Not to mention that the original example was an answer to the problem of parsing an array of strings into an array of integers. Please, learn to read.
You're right - this was the recommended usage for older JVM's because it was faster to allocate a `new int[0]` than a `new Object()`
There is also the fact that in most cases being tied to a type is not a big problem and a factory only adds noise.
That is also converting, not just copying. 
OpenJDK supports `java.lang.Integer.IntegerCache.high` system proprerty and `-XX:AutoBoxCacheMax` option. You can't set them below 127.
And since it's not obvious from the headline: [`new Character(char)` is also being deprecated](http://download.java.net/java/jdk9/docs/api/java/lang/Character.html#Character-char-).
EventListener and EventObject?
Read more about a factory in [effective java item 1](http://www.informit.com/articles/article.aspx?p=1216151). Noise is not that much of a drawback when you consider the pros and cons.
&gt; Will the constructors be removed in Java 10+? Not in 10, because it's not marked forRemoval. Maybe not ever. But they are removed some deprecated methods in Java 10 for the first time.
So use collections instead you whiny dufus. 
Wow. Do people really on this? (It does not matter for a static field, obviously), but I actually found a few examples like this: final Serialize lock = new Serializable() {}; Ugh.
Well, the best way I've found to make a serializable lock is to either use the new classes (ReentrantLock) or to use this idiom I found in Lombok: final Object lock = new Object[0];
Yeah, I know what a factory is and I've read the book. Thing is that I don't see the items as "a must". In fact it says "consider". From what I've seen most of the time when I consider them the answer is that it is not needed. And seriously, even if you it said "you must use static factory methods when possible" I would say it is wrong. I don't see it as a bible.
We're discussing the pros and cons for a factory method. It is not perfect and no one is advocating to go *only* with factory methods nor that it is a must. They have usages that are valid and in the case of the class `Integer` they make sense. If there's a class that should have never had a public constructor is `Boolean`. Why are we allowed to have multiple instances of `true` or `false`?
Thank you very much for the feedback. I fixed the timing attack vulnerability. It would be great to have external security auditing, indeed.
JSF2.2 /primefaces too power for web frontend , angular just javascript and angular by itself learn from JSF, look at angular2-&gt; it is try to be component control as JSF. angular can be leader win the java script world, but JSF bit more just front end and it has all what need every front.Just developer must write right code. JSF can be stateless or statefull . So just learn JSF!:)
Apparently. Looks like my reddit app doesn't like having poor cell coverage and shit itself. 
Close. In practice, `javac` compiles autoboxing conversions into the appropriate `valueOf` call, but this isn't required by JLS 5.1.7. It might be possible in the future for autoboxing to be accomplished some other way which would allow JIT compilers to avoid allocation in more cases. This would address /u/tavianator's problem.
This is *sort of* interesting if viewed as a standards-ey take on relatively lightweight frameworks like Dropwizard. This is *extremely* interesting if viewed as Red Hat and IBM's hedge against Oracle doing nothing (or the wrong thing) with Java EE 8.
True, thanks for clarifying
Thank you. I'm considering deleting this question so that it doesn't show up on the home page and I don't get any more flaming replies. But I'm sure I'll need to reference this often as I go about learning to use Java.
Looks nice. Is that the new replacement for java.net et al?
I am shocked to know. Edit: (for the love of God please don't reply anyone asking whether I'm being sarcastic. I'm not).
The screen shots use the default theme. http://netbeansthemes.com/ 
If I type "java" into google - this is one of the sites that would come up. There's nothing particularly newsworthy about the main site. Better if this was a link to some article or something, no? I guess u/lukaseder hasn't got enough attention this week. 
One of the reasons why I still use it. I love the old swing theme. 
First time I see Oracle's .java TLD in action. It's crazy when you think about how much people pay for names.
I used Tapestry years ago... I suggest contacting Howard Lewis Ship, the creator and getting some direction. He was always very helpful. 
Compatibility is a technical reason when you have this much code. Erasure is relied on deep within the API itself and in a lot of code. It allows adding generics where none existed before. It's better than the reification approach. In fact C# did reification and it's pretty horrible there with so much code/samples not working and one collection type not working with the other. 
Is it important if the name is wrongly written? &gt; Name of Contact Person: Martin Scott Nicklus even though he is written Nicklous
I see erasure as a very convenient feature. E.g. while the [jOOQ](http://www.jooq.org) API is type safe with tons of generics, the implementation can take many shortcuts, making things a lot easier. There are a few occasions in the JDK itself that profit from this convenience in a similar way.
https://tapestry.apache.org/mailing-lists.html http://mail-archives.apache.org/mod_mbox/tapestry-users/201609.mbox/browser https://tapestry.apache.org/community.html You can start with the tutorial: https://tapestry.apache.org/getting-started.html and Tapestry JumpStart by Geoff Callender: version 5.4.x: http://jumpstart.doublenegative.com.au/jumpstart7/ version 5.3.x: http://jumpstart.doublenegative.com.au/jumpstart/ http://www.tynamo.org/tapestry-security+guide/
Compatibility is the only reason really. But keep in mind there are a few types of compatibility being considered. Here's a good paper that goes over this... &gt; For Java programs, there are three main categories of compatibility: &gt; Source: Source compatibility concerns translating Java source code into class files. &gt; Binary: Binary compatibility is defined in The Java Language Specification as preserving the ability to link without error. &gt; Behavioral: Behavioral compatibility includes the semantics of the code that is executed at runtime. Source : https://blogs.oracle.com/darcy/entry/kinds_of_compatibility The designers can fix this. But of course any application relying on the inner workings of erasure will obviously break Source, Binary, and Behavioral compatibility all at the same time. This is what the .Net folks did. They ripped it like a band aid. And soon after, everyone forgot pre-Generics .Net. Meanwhile, we are still tied to pre-Generics Java, i.e. Java 1.4. Java 5 came out 12 years ago, keep in mind.
Always. I want to be with you. And make believe with you. And live in harmony, harmony.
No, some people who were involved with Java think so. Java designers clearly stuck with erasure. Erasure is remarkably convenient as it removes the need of foresight. E.g. I can just write code and harden it into an API without knowing the types. A year later someone can specialize my code and narrow it down to a type without breaking binary compatibility... Notice I said binary and not backwards compatibility! In fact this is something we do a lot, we ship an API that is public and existed since before generics were available. So we were able to add generics without a problem. The thing is that even after adding them we still want to change and further specialize things and we can still do that. Strongly typed is one aspect, generics is layered on top so this isn't really the same thing.
Looks like we will have support for both JSON B and JSON P in Java 9. JSON B does the basic binding of Java objects to and from JSON and JSON P supports streaming model while processing JSON 
LOL! I think that's a bit too meta for these guys. I appreciated though! For everyone else, [Always by Erasure](https://www.youtube.com/watch?v=lWqJTKdznaM)
It was reading well I thought, until I hit Thymeleaf. Anyone learning to build apps that might some day need to pass a rigorous due diligence screening, might want to be using technologies used in the Enterprise. I've worked in many places, never saw Thymeleaf used any where. What's wrong with JSP? It was a good introductory article, easy to read and hit key points. 
Well, you'll learn to recognize all sorts of files as you go along and get better with Java. In this repository, I see a `.project` file, which means it's an eclipse project. Try opening it and building it via eclipse.
I guess I have not made that mistake just yet :) There is no argument between weakly vs strongly typed language because no matter how strongly typed, there's always a workaround in every language. E.g. if a language supports reflection, your strong types are all gone (if the user wants them to be gone). I do agree though that overloading on generic type parameters would have been useful from time to time, but you're barking up the wrong tree. Overloading is the wrong tool. A much better tool would be union types (and perhaps defaulted parameters), such that you can write: `funct(genType&lt;a | b&gt; aOrB)` Union types could still be introduced with erasure in place (I think)
This is help with **programming** and thus should go in **/r/javahelp** as is indicated in so many places on the subreddit. **Post removed:** programming help.
It is the right direction, but don't underestimate how much work it is to break up a monolith and go to a services architecture. Besides code you need: * Infrastructure to support it * Have a way to deploy and build easily * Agree on how to do api-changes in services * Think about service discovery These are the ones I can think of off the top of my head, but there might be more.
Never move forward without a plan and without knowing what to do first. If for example your downtime is high, you can still use something like Kubernetes (even without using its full potential) or some custom made load balancer supporting rolling updates. Determine which part of the deployment takes up the most time. Is there some part of your application which requires a ton of updates and thus deployments (parts move at different speed)? Is there a part which is particular interessting for clients to use as a service? Also think about how many teams you have access to after you finished the migration. You generally say, that a team manages and maintains one microservice. They mostly are determined by geo location. Also look into using docker because this makes it very easy to manipulate ip tables. E.g if you company is callled foobar and reached by www.foobar.com you can redirect this to another IP for local development even though this is hard-coded. Also automation is the key! Deployment pipelines, integration, regression testing, etc. whole setup should be automated. 
did they seriously drop MVC 1.0? Or did I get this wrong? https://pbs.twimg.com/media/Csq3BNuVMAAXhoS.jpg
The survey asks a question about this, says they're considering it, not that's a done deed.
Given that Oracle wants to move it away to Apache, it remains to be seen for how long.
It wasn't only the Eclipse 4 rewrite, apparently many developers also left the project, or at least IBM decided to move some of them elsewhere. At least this is what I got from some random comments on the Internet, not sure how much they match reality.
You'll have to pry NetBeans from my cold dead hands. Seriously though, at the rate of decline Eclipse is seeing around 2020 NetBeans will be the second place IDE. Of course this assumes it doesn't die completely at Apache.
I have some time to plan, but the sooner I come up with something, the sooner I can get my resources. Our downtimes are of two types: 1. upgrades, we are looking at a classic installer here, data has to be backed up... Downtimes like this are a bad thing for our customers who run their transactions 24x7 2. we use old systems and databases that need to go through a cleanup daily. Because of the monolithic architecture, the whole system goes down. Architecture that is needed is something like GitHub/GitHub Enterprise. A SaaS solution for clients who don't want to have on premise installations with an option to host our system on client's machines with clients managing the infrastructure.
I don't think that an interface with only a single implementing class is over-engineering per-se, as using interfaces allows for easier unit testing and mocking.
Will your knowledge of walking on a carpet help with your new carpenter job that you found?
&gt;i.e. overload on generic parameters. Does this really require reification? Overloads are resolved statically.
It's available as metadata, but the actual type signature on the descriptor will just be genType. Besides the generic type information of genType isn't guaranteed to be available at runtime.
.NET had the advantage of being only at a 1.1 release at the time and most devs were still on VB6 etc..
Why repost this? [It was discussed to death on /r/programming](https://www.reddit.com/r/programming/comments/52mcf3/the_fall_of_eclipse/) The entire article is pure bullshit, quick &amp; easy clickbait. [You can easily find data that points in the opposite direction.](https://www.reddit.com/r/programming/comments/52mcf3/the_fall_of_eclipse/d7m4ql6)
self-hosting microservices is actually a bit cumbersome. This actually requires that the clients all need to have a similar abstraction for virtualization (or you use a virtualization which is supported by everyone). On the other hand, if you can get a working base, you already solved a part of the installation of dev environments for newbies. 
How difficult is the move from Eclipse to IntelliJ? Wondering how long it would take me to get used to the new IDE, a week? A month?
My experience based on Android Studio, at least a more beefy computer.
Difficult at first, but you'll be glad you did it once you climb out of the valley of low productivity. It's like being able to ride a bike and learning to drive a car.
&gt; For example, your libraries will be completely different. Obviously :). But if you look at how classes/modules, private, public, constructors, getters/setters. I've done a small bit of work in TypeScript and I can see the resemblance with Java.
Curious, why would it die at Apache? No active development once it gets there?
&gt; How after all this time is there still no global preferences. Preferences are global to the workspace and can be shared among workspaces. If you only need one workspace, use only one. Even with only one, you're still able to manage whole projects/modules where IntelliJ only lets you have one project and attempts to treat a "module" as a project when it is really a module.
https://eclipse.org/membership/exploreMembership.php http://dashboard.eclipse.org/ 
Two different things are being confused here. Generic type information is not retained/computed for *instances*. However, generic type information *is* retained for methods and classes (this is not reification as this type information is statically known). To implement generic function overloading, it is only necessary that type signatures reflect statically knowable generic type information that is already retained at runtime. There is no reification involved. They are two separate things.
They really need to learn from Go. Puts out new release like clockwork every 6 months, with good incremental improvements that make it worthwhile to upgrade on the day it's released. Do you all know Go has already had full HTTP2 support for 7 months now? Shame on Oracle for putting so much focus on a feature that really is not such a huge requirement (every single other language lives fine without module/Jigsaw equivalents) and dragging the entire language improvement cycle with it.
I agree, it helps, I'd forgotten to mention that. Even if the client doesn't expose a way (speaking in general Swing terms) you can pass a parameter to Java when the JVM starts, IIRC.
&gt; But if you look at how classes/modules, private, public, constructors, getters/setters. I've done a small bit of work in TypeScript and I can see the resemblance with Java. You basically just restated what I said.
That's the normal reason stuff dies at Apache, yeah. I mean, it's a bit bleak, and some projects really do flourish under Apache governance. OpenOffice went there to die because there was already a genuinely viable, better, alternative fork. Netbeans may do well, though, because it *isn't* forked, and has a small-but-deeply-ingrained userbase.
I use IntelliJ and Clion for my development, it is pretty easy to set up once you know the general file layout of openjdk. I think there are also ready to use Netbeans project files in there, but I have not used them myself. Building is done using a simple configure and make.
I've been trying to follow Oracle's statements on this matter and, as far as I have seen, they haven't. However, they're very insistent now on how much they care about Java EE and how much they believe it will be crucial for the future of enterprise Java, so I guess you could take that as a form of apology...
Unfortunately you're going to need reification on the instance for this to work because of runtime binding. Consider: public interface I { &lt;T&gt; void f(java.util.List&lt;T&gt; l); } public class C { &lt;T&gt; void g(I i, java.util.List&lt;T&gt; l) { i.f(l); } } That will compile fine. Now at run time you provide an implementation of I: public class Impl implements I { void f(List&lt;String&gt; l) {} void f(List&lt;Integer&gt; l) {} } The problem now is that if C.g is called using this Impl class the JVM is not going to know which implementation of "f" to call because all instances of List lose their generic parameters. 
That's not overloading. That's multiple dispatch. Java currently does not support this at all - not even for Class types. Reified generics is not going to give you multiple dispatch.
It means that Jigsaw, which I don't care about at all, is going to stop me from getting the HTTP 2 client, the streams and optionals improvements, and all the other nice features in Java 9 that matter to people who are writing enterprise code rather than space-constrained mobile or embedded apps. (If anyone can tell me why I'm wrong about Jigsaw and should be excited it's coming, please correct my misconceptions about it!)
Random question, I'm relatively new to JS (ES5/ES6), and I'm generally a java dev. It seems like type script is trying to make JS OO rather than embrace it's functional nature. Thoughts? 
You could have just posted that you think java is going to die, would have saved us reading the rest of your post.
I think the idea is to have the option of having type information in javascript so that you can do strongly typed things like checking for compile time errors and doing code auto-complete. Arguably these things make it easier to maintain larger code bases
&gt; How on earth can throwing away types at runtime for a Strongly Typed Language be a desirable feature? In Java you get strong compile time checking which can be circumvented using reflection. In C# you get strong compile time checking which can be circumvented using dynamic, etc. What exactly do you think you're losing/gaining? 
VS Code never ceases to amaze me!
Dual core with 8GB and a 512 GB HDD. Perfectly fine for VS 2015, Eclipse and Netbeans. 
SWT looks like pure and utter shit. It doesn't look anything close to native, not sure why people say that. 
The "ONE gd window" is exactly why I despise Eclipse. I have no desire to have all my projects in a single window. The Eclipse "workspace" is an atrocious idea and to this day I still have no clue what perspectives are. I never have crashes when doing large refactors and Jetbrains is very responsive to bugs you open in their bug tracker.
It's been losing relevance since Spring 0.1
"SWT is an open source widget toolkit for Java designed to provide efficient, portable access to the user-interface facilities of the operating systems on which it is implemented." https://www.eclipse.org/swt/ SWT is the underlying operating system widgets. If you dislike that, then you're saying you dislike the look of the OS you're using. 
I've used Netbeans all the time, but its sad to see Eclipse has fallen like this. Both are popular IDEs that each has its strengths and weaknesses. It would be nice to see both Netbeans and Eclipse become better. For coders the more good IDEs to choose from, the better. 
Ah. I don't understand why you'd want that, but if you do...IntelliJ is definitely better. I work full-stack, and usually have multiple babel transpiler scripts, multiple sublime windows for php/html/js, git, ssh client, filezilla, a coulpe browser windows, and some other misc stuff. Long story short more windows is a big problem for me. I strongly disagree that it's an "atrocious idea." As long as you don't go full-retard and put every single project in one workspace it's amazing. Being able to easily check references/etc in multiple projects, and swap seamlessly between them is invaluable to me. At one point I had a bit of lag, but was then told I was doing things wrong (I stuck everything in one workspace.) Now I have separate workspaces with ~20 projects apiece, and everything is very fast. Seems to work very well for maven modules as well. Though not being able to build everything into the parent's directory is absolutely infuriating. These days I've run into one category of bugs, and it's my main beef with Eclipse. Nested lambda intellitype breaks sometimes...really hard. I've broken it in IntelliJ, and it's easy to break method extraction ("heu heu this method is too complicated"), but I've only broken intellitype 2-3 times in intellij. Eclipse is certainly a very imperfect solution, but it's the least bad one for me.
I listened to an interview of the designer of the language last night for over an hour. Same guy that designed C# Turbo Pascal. * Add types to assist with finding bugs * Add types to assist with tooling (e.g. autocomplete, refactorings) * Add the features of ES6/ES7 * Not take anything away (e.g. all your existing code and JS knowledge)
Never thought about moving to Intelij till I found out that's what my team uses. I've used it for about 2 weeks now..... I'm never going back to Eclipse. I've seen the light. 
Yeah, atom is pretty nice. 
Yeah, I like the workspace features of atom more than code, code opens large files much better than atom. I thought that code was a direct fork of atom with less fancy stuff but that appears to be incorrect: https://stackoverflow.com/questions/29966093/what-is-the-visual-studio-code-editor-built-on
Todays links to the sessions have been posted. Enjoy!
It'll generate server or client stubs for handling all of the communication, and has auth baked in. It also supports bidirectional streaming and can be synchronous or asynchronous. It still uses protocol buffers, but gives you a layer of abstraction for doing RPC too
I suppose I should also add that you can generate JSON based REST end points with automatically generated swagger docs using gRPC-gateway
There's some early proposals to add interface driven support to Java EE. But nothing concrete, and nothing for EE 7 as of now.
Thanks, this is awesome! 
brooklyn tech what?
Love Visual Studio Code in OS X. Have always wanted the ability to write, debug and run standard java (NOT javascript) from VSC in OS X. Installed the above extension, and found the following extension which allows you to debug and run java from VSC: https://marketplace.visualstudio.com/items?itemName=donjayamanne.javadebugger Followed the directions as best as I could. Trying to run my java app, and I am getting a bunch of "error: cannot find symbol" errors in the debug-console window when I run my java app in VSC from OS X. App runs great in eclipse. What am I missing in either VSC or somewhere in OS X so I can properly run java code from VSC in OS X?
The project name looks like `vertx-game-server`. The package that's currently open is named `com.redhat.middleware.keynote` and the class is `ServerVerticle extends AbstractVerticle`. It might be a local demo project they have created. But it looks like they are using vertx. Are you aware of https://vertx.io? Take a look at https://github.com/vert-x3/vertx-examples too. 
Why is this proposal better than returning Stream&lt;T&gt;?
Eclipse is a pile of nonsense and incoherent ideas, but I don't use NetBeans because the Mac version has weird non-native font rendering that is hard to read.
Is it really a good idea to inject consumer references into your DAO? 
Can confirm: used netbeans in one class because of a professor's preference, but used eclipse in the workplace. Right now we're using eclipse for the Java stuff because of some in-house plugins, and IntelliJ webstorm for front end. It is SO PAINFUL switching from IntelliJ to eclipse. The quality difference is incredible. I wish we were able to switch from eclipse to Idea. (Yes I know Webstorm isn't free. But man is it worth the price.)
IntelliJ makes it incredibly easy to set key bindings up to be eclipse-like. The switch is easier than you'd think
All code is basically executed in a runtime. I don't think java is worse than any other. But it's popular so it will be targeted.
Say `getAllMyTs()` has to keep an open ResultSet (or some other io resource) while it is enumerating the results - how would you manage this lifecycle if you return a Stream? Spliterators do not have methods for managing lifecycles like `close`.
They could easily have the build method throw an exception. Or use scala...
Just use https://www.youtube.com/channel/UCdDhYMT2USoLdh4SZIsu_1g/videos what's the point of creating a sub for this ?
Someone correct me if I'm wrong, since I've only started playing with it, but it seems like it doesn't support contextual/smart code completion? I expect if I type in "this." and wait it should present some member functions and variables to auto-complete, but instead I'm only seeing auto-completion of simple things like variable names that are within the file and no member functions.
This is described as one possible option in the post I refer to at start of the article. One possible case where this doesn't work so well is when you have part of a component which must be specified but can be specified in multiple different ways. For example, if we wanted to describe which host something could connect to, you might have one "setter" that takes a hostname and one that takes an InetAddress. Both of them satisfy the condition and flip the flag. You should also note that I do explicitly point out that this is an esoteric solution and solicit suggestions on where - if anywhere - it might be useful.
From the article: "Note that this article is less dogmatic than some of my previous ones, as I will not attempt to convince you that doing this is a good tradeoff of effort vs. reward. I’m exploring it for its academic value."
how is that worst than dealing with ArrayList?
it possible to add a atClose callback on stream see https://docs.oracle.com/javase/8/docs/api/java/util/stream/BaseStream.html#onClose-java.lang.Runnable- but from the doc &gt; Streams have a BaseStream.close() method and implement AutoCloseable, but nearly all stream instances do not actually need to be closed after use. Generally, only streams whose source is an IO channel (such as those returned by Files.lines(Path, Charset)) will require closing. Most streams are backed by collections, arrays, or generating functions, which require no special resource management. (If a stream does require closing, it can be declared as a resource in a try-with-resources statement.) wonder why they could not close it on the terminal operator?
It means my desktop app built with Java won't offer HiDPI support on Windows for six more months. (Java 9 is porting HiDPI support from the Mac version of the JDK, which has worked with Retina displays for a few years.) Instead my would-be Windows users with HiDPI displays will continue to experience the app as too tiny to see or use. So I guess that will cost me some lost sales. :( 
Kinda defeats the purpose of using a Builder in the first place, since the idea of a Builder is to allow for fluent setting of parameters rather than one long list of 10 comma separated values.
You are correct but it does feel clumsy to require the caller to close the stream this way. One of the advantages of "streaming" results with a callback is that clients do not need to manage the lifecycle of open stream handles.
Haha, the feature list of deltaspike looks uncannily similar to Spring's. I'll definitely check it out in a feature project, thanks!
:-( Some keep going on and on and on, about heavyweight JavaEE has lost compared to lighterweight, dynamic, innovate frameworks like spring. How many here have not even bothered to try TomEE, for example. Because its JavaEE. TomEE is really *really* awesome, in the speed it takes to startup... And, this: http://www.adam-bien.com/roller/abien/entry/java_ee_7_thin_wars Really, if you're still in the Spring or nothing world, you're missing out.
Internal or external iteration... If in doubt, I usually prefer external iteration any time, but I don't think there's a *general rule* for one over the other. Though, reasons against the suggested approach: - A lot of problems can be solved by returning an `Iterable` or `Stream` - `Consumer` is not a very functional interface in terms of FP, because it's all about side-effects, which you should often avoid.
Won't load for me. I get a page saying 'Java Magazine - Error' whatever that means. Do they still require some Java plugin?
yes that could become an issue, you will need to set the isolation level to the right value. 
too many links, too unclear which one describes what the project is
If that's true, why the fuck bother. 
Thanks for that comment, I'm very happy for you that you can have that level of certainty.
THANK GOD, I LOVE VISUAL. Its so simple and easy to navigate but so complex. I remember when I tried learning C++ and used visual the hardest part was the code and not learning the IDE unlike many java IDE's, unless I'm just retarded.
`Stream.close()` needs to be called for the `onClose` to be called. Terminal operations won't close the stream for you.
Yep. Don't expect something that took years of development for big Java IDEs tto land in VSCode, which is itself just year old. No point in using it for Java coding, yeah. 
This builder "pattern" madness will hopefully finally stop in a near future: https://twitter.com/arungupta/status/777627608087339008
 new AbstractSpliterator&lt;T&gt;(size, characteristics) { @Override public boolean tryAdvance(Consumer&lt;? super T&gt; action) { return ...; } }; And: There's your `Consumer`
... it's all in there :) 
Hi, could you once write a post explaining more in depth tip 7 from this blogpost: https://vladmihalcea.com/2016/06/28/14-high-performance-java-persistence-tips/ ?
Serious question: What's the point?
Big +1 on infrastructure to build and deploy. If you dont have tooling in place to automate deployment, get it, it will save you lots of manhours over time.
Glad to see. I had a few years where I worked in C# shops after 10 years writing and was surprised to see how much I appreciated the existence of 'var'. Once I used it I realized how silly it was that I needed to specify the type of my variable twice. Now that I'm back in Java-land, I look forward to replacing: Map&lt;SomeReallyLongNamedType, SomeOtherReallyLongNamedType&gt; mappyMap = ...; With.... var mappyMap = ...; Will this revolutionize anyone's ability to write code? Not at all, but I hope people appreciate the minor convenience for what it is.
And that's why I love Kotlin.
Pff, and they say competition doesn't work. Thank you Jetbrains for making Java see the light.
Yeah, val is way more useful than var, I don't know why you would do just the lesser of the two.
Fairly lightweight article. A better source of info is the [JEP page for Local-Variable Type Inference](http://openjdk.java.net/jeps/286).
Honestly, I think it should be flipped. We should have to write an extra keyword to make things mutable. It'd make people think twice. The only language I've seen do this is Rust, but I believe it is the right approach. 
I always type int x = new ArrayList&lt;String&gt;(); and then use the IDE auto correct to fix it for me :) It's not ideal though.
I think I tried learning cpp in 2015, but stopped after a month or so because I started taking a class. I just saw VS in the title and got super excited, however the idea of VS Code also makes me excited because its modular and I cant seem to get my head around any IDE besides maybe Jcreator
Yeah I agree, i barely ever reassign variables.
Better than eclipse and netbeans, competitor to Intellij. Between only 2 robust Java IDEs having a third one is very good.
Definitely a neat trick while writing the code, but there's an excerpt from the talk in the article about their goal being to make it easier to read the code rather than write it. Even with your auto-correct trick, I still have to read that 60-character monstrosity when I look a the code a month later.
I would type "new ArrList" then autocomplete. Write the String type and then press ctrl+2 +L to write that same statement. Nevertheless felt like a hassle. 
But Kotlin is ;).
Are you me?
I don't know. Are you?
Why do this instead of returning iterable?
I'm not sure how such a wrapper would work. You could automatically close after the last element is reached but terminal operations don't necessarily enumerate all the elements of a stream.
I'd actually find it more readable to see List&lt;String&gt; catNames = someMethod() than var catNames = someMethod() because the former tells me more about the type :P
Used Eclipse for a long time. Then started a job where everyone used IntelliJ, and decided to give it a try. I've now bought a personal Ultimate license for it because that's how much I fell in love with IntelliJ. I couldn't ever go back to Eclipse.
Oh the time index was a very good idea, I skipped last year videos since they were not indexed in any way and you didn't know what was in that ! edit: well that sub might be usefull after all... we again have 10 hours+ in single videos... sigh...
This is a good point. Readability should always be considered and this is a potential great example of when not to use var. If the method was named something like "getStrings" then maybe not so much, but if it has an arbitrary name, then the reader will likely need to check and see what type the variable actually is when looking at the code. 
Does bytecode enhancement work well with JRebel? I tried once a few months ago and I didn't manage to make it work, so I ended up giving up on bytecode enhancement.
Looks neat. Its too new for me to use at work though. My first thought was how would I make this use https instead of http. I'll look through the source code when i get home.
please give InteliJ a try. In fact any editor made by the company that made it (they have free ones) rocks so hard.
&gt; and also the Iterator is kind of messed up. does not follow CQRS. Well iterator does what an iterator should do very well, its not messed up. It provides an interface for someone to get an iterator over something. I'm not sure how it interferes with CQRS, could you elaborate on that? I mean if I wanted to I'd just consume the iterable into an arraylist, no different than your consumer example is doing.
Nothing special to it really, and the fact that not all the elements are necessarily enumerated has no bearing on it that I can see. Off the top of my head ... Just implement all the terminal operations in your `ResourceClosingStream&lt;T&gt;` class, or whatever you call it, like e.g.: public void forEach(Consumer&lt;? super T&gt; action) { try { // open io resources component.forEach(action); } finally { // close io resources, perhaps just `component.close();` } } And wrap all the non-terminal operations something like this so we don't let the component to escape from its wrapping: public Stream&lt;T&gt; skip(long n) { return new ResourceClosingStream&lt;&gt;(component.skip(n)); } where the `component` field is obviously just the wrapped stream. It's just a bit of leg work since there are a lot of methods. I think Stream guarantees lazy evaluation by contract, so it should work as is, but it'd only take a couple of extra lines to guard against unexpected eager evaluation in non-terminal methods too. Edit: `iterator()` and `spliterator()` may also need special consideration, but it's nothing complicated. Probably in those cases you'd just want to dump the stream into a list then iterate over that rather than trying something cleverer and possibly failing to clean up the open resources. I know that's exactly what we were trying to avoid, but I reckon those methods are used pretty infrequently so seems good enough to me.
Yep. I don't like the language as a whole, but they introduced some very good ideas and were one of the first major alternative JVM languages.
the CQRS discussion is relevant to implementing the iterator Martin on the subject from the article " It's a good convention because most of the time it works well. Consider the java idiom for iterating through a collection: the next method both gives the next item in the collection and advances the iterator. " that leads to difficulty of implementing where hasNext needs to try and fetch the next element and store it, also store the fact that it try to fetch. next need to check if it was fetch, if not also try to got the next element return the value reset the flag and the value. if instead we add boolean next(); T currentValue(); it would be a lot easier to deal with. the consumer is a lot easier to implement, and also you avoid resource leak. If you have an iterator backed by a resultset, when do you clean the resource?
This works in the common cases (assuming you are thorough with your overrides) but you have no guarantee that people aren't creating derived streams outside of these overriden methods. For example, what happens if someone passes your `ResourceClosingStream` to `Stream.concat`? The Streams API just isn't built to support this sort of thing.
You should give it a second look, it's an acquired taste :) A few months ago everyone here was screaming bloody murder over type inference and now the tone has changed a lot. People used to say that lambdas are impossible to understand and debug. Using optional to avoid null-pointer exceptions used to be controversial. Brian Goetz has been talking about pattern matching &amp; at the JVM language summit they were talking about better threads (fibers/co-routines) and tail-call optimization... Maybe Kotlin will pave the way for Scala like Scala is paving the way towards Haskell/Frege ;)
Exactly.
&gt; what happens if someone passes your `ResourceClosingStream` to `Stream.concat`? It would work just fine. The space gains would unfortunately be lost if you implement it the way I described, as internally `Stream.concat` calls `Stream.spliterator` on the two streams, and I did suggest eager evaluation for that scenario (it is a terminal operation after all). But pretty much any way they could choose to re-implement `concat` it would still work. Any method like that can only operate on your `ResourceClosingStream` via the same API everything else accesses it through. **Edit:** personally I think the choice to implement `concat` by invoking terminal operations on the streams was the mistake here, and the true cause of the performance cost.
I dissent var. Leave it in the scripting world.
I don't have any experience with JRebel, but with Spring it used to work just fine.
That makes sense, the only time you could close it with the iterator is if it completely drained the iterator, so early exit would just have to wait until its automatically closed. On the flipside the consumer still suffers from that to an extent right? It either drains the whole thing or is unable to know when to close it. Also the consumer API this article presents feels uncomfortable, I don't think its intuitive just looking at the method signature. I could see using this approach in special cases where there was a big query but in most cases I have where its get a few things and then do something with it I think the more natural api of query and then return a stream/iteratable over a List would be preferred.
I did not see your edit when I posted but yes, you could implement the spliterator by collecting a list internally.
You are so wrong.... Java EE, is a *standard*. as in, if you have written your stuff to the Java EE standard, it should just work on any JavaEE complaint server you want to. Because that is what standards is all about. If you write your stuff in Spring, however, the only thing you can ever run it in, is spring, without huge major refactoring. It appears that pivotal is actively going out of their way to use the Pivotal way, rather than anything that happens to be standard. Any external API, they will attempt to wrap it in their own.... So, instead of easily migrating to a Spring free environment, a developer would have to unwrap every call to anything else. Its pure and simple lock in, that Microsoft would be proud of. However....and it really does pain me to say this. Your opinion exists in far too many development shops, where snr architects have been burnt by the bad old days of J2EE. I think its almost too late to change, the choice is now either use Spring, a mature framework with enough bells and whistles to do anything you want, OR, use a new immature framework that has far less industry backing. JavaEE just doesn't get a hearing today, there is too much baggage associated with it, and too many people, like you, want it dead. Spring has won, simply by enough people having the exact same opinion that you hold. And, this is a huge loss to the Java ecosystem, caused by one business, Pivotal, wanting to control the market and playing hardball with the competition. 
Yes no early exist with the consumer if you don't allow for - could do that by using your own functionnal interface that returns a boolean, or add a Predicate to indicate when to stop. and agreed for a lot of code a List might be good enough, not suggesting everybody replace all the List everywhere. just that there are some benefits to use a callback instead. also the callback can be more complicated than a simple consumer. as for the intuitiveness I guess it's a question of familiarity with this kind of code. hence the post. as with everything it depends, always a tradeoff. 
Java should take that damage, honestly. It's not a good language. Kotlin is better than it in every single way and the stdlib is very lean at this point (smaller than most big libraries like RxJava and Guava by a large margin).
As others have noted, returning a Stream offers a lot more flexibility. It does have the drawback that if it holds a resource, the caller is required to use try-with-resources to guarantee that the resource is released. Ideally you'd want the callee to be able to manage resources within a single call, which is I think what primarily drives the proposed consumer/callback approach. An interesting alternative to passing a consumer that's called repeatedly with T values is to pass essentially a consumer of a stream of T. This gives the callback all the flexibility of streams while preserving the callee's ability to control resources. To add flexibility we also want the callback to be able to return a value instead of requiring it to perform side effects to communicate its results. Thus the callback is a Function instead of a Consumer. A full signature would be something like &lt;T, R&gt; R getItems(Function&lt;? super Stream&lt;T&gt;, ? extends R&gt; f) An example of this approach is the StackWalker API, new in JDK 9: http://download.java.net/java/jdk9/docs/api/java/lang/StackWalker.html#walk-java.util.function.Function-
I have. I do not like the implicitness of Scala. Kotlin and Scala share the same functional roots, and the same love of immutability, but Scala likes to let things happen magically while Kotlin forces the user to be explicit. It means that Kotlin code ends up being more verbose, but simpler and easier to follow. I'm not a fan of clever languages, so Kotlin, with its leaner stdlib and perfect interop back to Java 6, is perfect for me. Plus, I think Kotlin's `?` is a more elegant solution to null than Scala's `Optional&lt;T&gt;` (but you can still do the same Scala-ish monadic composition in Kotlin for other data types), and Kotlin has some simple but powerful features that I don't think Scala has, like delegation, smart-casting, and inline functions. The two have different design goals. I think Scala encourages too much "cleverness."
If you think `var` is just an alias for `Object`, you must be actively trying *not* to understand how it works, because everyone has been repeating this ad-nauseum: **`var` is still statically typed**. C# devs have been using it forever. The compiler still knows what's in that variable. Autocomplete still works. Refactoring still works. You will still get errors when you try to use members that don't exist. The only difference is that you don't have to type like you have a stutter: `List&lt;String&gt; list = new ArrayList&lt;&gt;();` vs `var list = new ArrayList&lt;&gt;();`.
Well yes, but it also looks and acts like C# var.
Yes, and it's way easier to read `var mappyMap` than it is to comb through the former declaration, trying to figure out where the generics end and where your actual variable name starts. The two are equal in length, but the example with `var` is *far* more ergonomic.
ITT: Your standard Java developers crying as if it's the end of the world because they fear change, spreading FUD that `var` means that Java 9 is basically going to remove types and we're all going to just start writing Javascript or something.
It reduces expressiveness, introduces visual ambiguity and hurts readability. That's what's wrong with it.
It improves readability if used properly. Are you upset that lambdas in Java 8 don't require you to specify a type for the params, or specify a return type? The compiler knows all of this information. When it is useful for the human reading it to know, too, you can explicitly specify the type. Otherwise, it's just clutter. We all use IDEs, which sort of reduce the need to know what type a variable is. You just need to know what methods and fields it has, usually.
As a Scala programmer, I approve of this message.
that would tick all the boxes for sure, as you would expect from an API expert. also reminded me that I did not put use &lt;? super T&gt; in there... It is slightly more involved as you need generate the stream but definitly worth it for a public api, specially if you already generate the stream. 
On Ubuntu 16 running inside VirtualBox on Windows 10...I just get a black window. To be fair, Chrome fails in this scenario too unless I start it without 2d canvas or some flag setting, can't remember. http://imgur.com/a/fjaLv Update: I fixed it by turning off 3D acceleration, Visual Code runs correctly now. 
true, but you will also be able to: var myMap = Maps.newHashMap(x) or: var myMap = getThatMap()
It doesn't make sense when you name things like in the example - names are everything. which one would you prefer? var populationByCity = fetch(); summarize(populationByCity) or summarize(fetch())
DeltaSpike Data is great. The criteria support is sooooo much more concise and readable.
Ah, that must be where they got it from! Rust also uses `let` and `let mut`. It's perfect, in my opinion. If you're using mutability, you should have to explicitly opt in. Even Kotlin and Scala's `var`/`val` is not enough, IMO. They're both 3 characters. People are equally likely to pick `var` when it's almost never the right option.
I am all for it. Looks decent. Its shame it wont come soon enough. Readability doesn't seem to be effected either or yhe integrity of the typing system. 
Spring Boot is a technology that makes it easy to create Java and Groovy applications utilizing the full power of Spring, with minimal setup. It allows you to create applications that 'just run' without hassle; and even the project setup becomes a breeze. Read on to find out how to set up a fully-functioning project and secure it with JWT in almost no time!
Why do I see lots of tutorials implementing own custom filters to validate JWT while Spring Security supports JWT as part of OAuth2 out of the box?
You can do this with lombok, although i agree that it isnt the cleanest solution. :) https://projectlombok.org/features/val.html
here i was thinking it can increases expressiveness, and can help readability. in some contexts there can be ambiguity, but if it's a problem skip it (or consider improving your poor nomenclature).
eh? if you're basing that response on "nomenclature", i wasn't referring to the content of your post.
Ive not really seen much var in the Scala ecosystem. Most new scala devs get the use val over var drilled into them when starting out.
[removed]
Yeah you're right actually. I'm thinking of how I use it in Kotlin where it's `val list = mutableListOf(...)`, so you don't actually call a list constructor, it's a factory method.
Thanks, I'll try this :)
But in both cases, you have something keeping you from compiling the code if you don't check before you dereference a nullable var. They are literally the same semantically, except that: - Kotlin's syntax is much more concise - Kotlin's `?` is not a wrapper like `Option&lt;T&gt;` is, so it has no runtime overhead.
I've never seen Optionals used yet. If they're already in Java 8 then yeah I guess they should've already been added to the core libs, that's odd. Actually, Optionals are the only thing added in Java 8, well that and interface default methods (finally!) that I'd like to start using and see being used. I suppose you have a good point about other languages, the only one on the JVM I've used that didn't hurt my eyes, ;-), and was actually fun is Groovy; but others I'm sure will have favorable opinions about their languages.
Can you recommend one? A tutorial offering a more native implementing that is.
I did not mention Spring with one word. Oracle itself abandoned it's JEE evangelists, and has for a year tried to create a competitor to JEE and Spring (and failed). You failed to mention how Pivotal could achieve such an evil deed of misleading so many people while competing with companies such as IBM and Oracle.
so what does this buy us? saves a few keystrokes?
You are missing what I am getting at. I use Option&lt;T&gt; on methods return type that might not return a valid value. That saves developer time 6 months later, when I might not remember all the details. However I can't ignore that type declaration. As far as I can see ` ?` is not used like that. It's syntactic sugar for checking nulls. 
`Map&lt;SomeLongDAOClassEntity, List&lt;MyOtherDAOEntities&gt;&gt; customersToOrders = getCustomersAndOrders();` `var customersToOrders = getCustomersAndOrders;` Tell me that the first one is actually readable. It isn't. You have to scan a huge line of code to figure out what it's actually representing.
I'd prefer `val` and `you_are_making_a_huge_mistake_stop_using_goddamn_mutable_variables` personally. :) But I'll settle for `val` and `var`. Scala and Kotlin both use them.
Too late for C#, but Java can still go that route.
in the second, you are just hiding relevant, but unwieldy, information about what type customerToOrders is. 
It's not relevant. Who cares if it's a `Map&lt;CustomerEntity, List&lt;OrderEntity&gt;&gt;`? You're just gonna do `customersToOrders.`, press Ctrl+Space in your editor, and get a list of the methods on it. The reason you don't know what `var customersToOrders = getCustomersAndOrders();` is is because nothing came after it. If it did, you would clearly be able to see that it's a Map or related data structure that holds orders. Let the code speak for itself. The type names are just a distraction. C#, Scala, and Kotlin devs use `var` (and `val`) all the time and aren't suffering for it. Their code is more readable, more concise, and has a higher signal-to-noise ratio. And for those incredibly rare instances where you do need the type explicitly written, nothing is stopping you from doing it still.
The vast majority of the time the type is only relevant to the compiler. Hell, look at /u/shadowdude777 's example again. He isn't telling you what type `customersToOrders` is. All you know is that it happens to implement the `Map` interface.
 summarize(fetchPopulationByCity())
Except Android is moving to openjdk which is the specification implementation of java. So it will.
Martin Odersky worked on Java before Scala. All of the Compiler people, he was one of them. There is a large segment of the Java committees that kind of looks at Scala as future Java.
Java already has type inference with Lambdas, so they are halfway there.
And once you start going "reactive" (which 99% of us will never actually need in reality) you end up with Future&lt;Option&lt;Foo&gt;&gt; which is a nightmare to work with.
&gt; Your generalizing is plain wrong. people shouldn't understand the tools they're using? i'd hate to be in a world where that kind of generalization is wrong.
I like you. You are funny. 
I was so lazy I would do something like x x = new ArrayList&lt;String&gt;(); I mean two extra characters, that's a lot of extra keystrokes!
You could also look at it this way: I'm in a jungle with a local interpreter. He points at an animal and tells me it's a guard dog. I'm not sure it's a dog per se but I take his word for it. I know now thaw we have some sort of guard animal with us, so I am now aware that we might be heading towards a dangerous area and be on a lookout for intruders. Guard dog helps, but I should be alert in any case. Types tell me take kind of animal I am dealing with, but not its purpose. Knowing something by type tells me of its capabilities, knowing its name tells me of its purpose. Knowing a purpose is more informative in the local context. Knowing its type allows me to better utilize its capabilities in the service of the purpose. 
For any queries(not simple CRUD operations) I always write down plain SQL and then translate it into HQL/JPQL. I never understood that how anybody can get away with Hibernate without knowing SQL!!!
Nobody forces you to use var. In practice I've found that local type inference is never problematic. YMMV of course. 
Not just Rust. Plenty of languages have this: F# and Ceylon come right off the top of my head, but there are more for sure. 
I don't think the other type inferences result in semantically different types do they?
Hibernate was actually the very and sole reason I got my first gig. Or rather, my predecessor 's shitty use of it. The company was in panic mode and I had some free hours during a particularly easy semester at school so I helped out. Was as easy as to tweak some fetch strategies and do proper joins. I ended up dropping school and now I'm up to my &lt;some body part&gt; in work. Thanks Hibernate!
So basically the author doesn't know what hibernate is and how to use it, but still uses hibernate for everything. Guys, watch out for computers, they can ruin your careers!
ORM really sucks. this isn't just a hibernate issue. When I started my Career, I was writing applications using Microsoft Q-Basic (included with Dos 6). Persistence was handled by random access files....basically a flat, fixed record size file which any record could be addressed by number. Fields of the file were defined in code. I made from scratch Q-sort and radix sort routines to sort records and then access the required record by binary searches. Oh joy.! not! Then, I moved to Mainframe/AS400. The files were very similar, record formats were still stored within the code. however the database provided its own index's (or logical files) that you could use to access records, rather than you have to keep sorting manualy, and using binary search. Really, coming from Qbasic, this was *so* much nicer. Later versions of the database moved the record format from your code, to the file itself. You no longer needed to define what fields were in a file, you just defined a file, and all the fields were automagically included into your code where you could access. Amazing! However, you still needed to define what index to use, for each way of accessing it.... Then SQL came..... and this restriction went away. Files became tables, Fields became columns. My program didn't care about how tables were sorted, or what columns were in them. I just added some SQL to map the data within those data tables, to internal data structures. And the database automatically decided which access path to use. And later on, if others needed new columns added to some database tables, then they could add them, and nothing needed to be recompiled. The schema of the database was stored in the database, independent to the program. Type mapping between database and internal fields was handled automatically. SQL, FTW. .....And then Hibernate happened. Hibernate forces you to define the schema of the database with your program, in Domain classes. Change the database, recompile your program Hibernate forces you to define the relationships between tables in your program. If you want to access data in a different way, different order, joining to different tables, then you are SOL..... you need to add your new custom relationship into your domain, so hibernate will do this on your behalf. But, really, the idea of storing the schema of your database with your code, is just really old fashioned....as in this is what I used to do back in the QBasic days, with a FIELDS$ statement. And, the world was a better place when it was banished to the database itself. Hibernate has just gone the wrong way. Each step in the evolution of persistence has brought about more encapsulation of the schema, making it more easy to change the schema without breaking things. Hibernate brings back the schema into your program, exposing to everyone. This is a *REALLY* bad idea. its against OO principles, and really the same kind of headaches I had when developing stuff back in the 90's have returned. http://www.yegor256.com/2014/12/01/orm-offensive-anti-pattern.html 
Gavin King - the genius
An antiquated Mainframe datastructure spec, defining an order file. This defines the actual physical file, all the fields within it, and what keys are in it. This is decades old....and, I kind of hoped this idea was consigned to the history books when SQL arrived http://i.stack.imgur.com/uutFx.png Unfortunately, hibernate has brought this idea back. There is not much difference between this mainframe code, and a hibernate domain. "Those who do not know history's mistakes are doomed to repeat them."
&gt;The vast majority of the time the type is only relevant to the compiler. Do you want bugs? Because this kind of attitude is how you get bugs.
It's an optional shorthand, so no, it doesn't reduce expressiveness.
&gt;it would not be available for method formals, constructor formals, method return types, fields, catch formals, or any other kind of variable declaration. /facepalm Type inference for formals is admittedly pretty hard, especially in the presence of overloading. But return and field types should totally be inferred.
Well yes, of course it's relative but I'm trying to get an idea of what I'd get myself into as not to waste time. How steep the *learning curve* is and so on... If Java programmers would ask me how difficult it would be to break into the Oracle DBA field, I'd reply basic admin is pretty straightforward but if you want to install databases and application servers and get Oracle RAC/Dataguard/Goldengate/... up and running, that'd be a whole different story. The latter would be pretty hard for a non-Oracle DBA to learn by him/herself at home in their free time without a large company's support and infrastructure. I have a limited amount of time available (busy 6 year old at home :) ) and want to spend it wisely. I want to learn some new skills but I'm not sure whether to continue in the Oracle DBA field (plenty left to learn there) or add a totally new skill, Angular.js to my resume. If experienced Java/Angular/... developers judge the learning curve too steep, starting from zero, I won't waste my time. 
I didn't know..... I thought it was something to do with CAP theorem. So, I just googled for it...... And now my IP address has probably been associated in a government database with someone looking for C.hild P.orn. FFS :-/ 
&gt; Hibernate doesn't remove the need to know and use SQL Hibernate is sold - just like it was put in the article - as something that means you don't have to deal with SQL. When people come back and complain, suddenly someone claims that Hibernate doesn't remove the need to know and use SQL after all. At which point on should really ask - does Hibernate do anything at all? Every "hibernate is so amazing" point always seems to be followed up with "well no, hibernate doesn't actually do that". Since the author brought in hibernate because they were told (or deliberately implied) they wouldn't have to use sql, but it turns out they do, then the obvious conclusion is that they shouldn't be using Hibernate at all because it does nothing for them other than add in additional complexity.
Ok, but then what on earth do you gain from using Hibernate? If I were to tell you I write books, but first I write them in Russian, then I translate them into Spanish, then I translate them in English. And they're only sold in English - no one buy the Russian or Spanish version. One would ask - what would you possibly gain by doing that rather than just writing it in English to begin with?
Sigh. If only something even *remotely* as good as the Java VM existed outside the control of one vile megacorporation or another. But nothing does. .NET is under another megacorporation's control. LLVM is not at all designed to be used on a JIT basis. Everything else is too obscure to be generally useful. There is no grand community portable high-level bytecode VM, like how Linux is a grand community operating system kernel, KDE is a grand community desktop, etc. And that's tragic. Software infrastructure like Java is far too valuable to be left in any one entity's control.
&gt; Nobody wants to develop Android the way Google does. Most of the enterprise gigs I have worked on, only allow the Google way for Android projects. Good luck getting those Square libraries through the technical leads and legal departments. &gt; Kotlin creates Java 6 bytecode. Google would have to break significant parts of the toolchain to prevent us from using it. Last time I checked it still had issues with the annotation processors and data binding.
Yes, because we always rename functions when we want to call them. This way functions can be called in exactly one place.
How hard? Probably really hard. Take a look at [this barebones full stack demo](https://github.com/timmolter/XDropWizard) (Java, AngularJS, SQL) and see if you can make any sense of it.
I like it when angularjs goes after coma with Java in the same sentence :) Too bad it is in every job ad these days...
That only changes which megacorporation has control.
For rdbms - don't use plain hibernate, use it via jpa. Dont just use plain jpa but go with spring data. You can always manually tweak bottlenecks. There is no point and very unproductive to go any other direction. Hibernate is a tool for a specific job, it was not built to solve any problem related to data persistence for any use case.
&gt; but then what on earth do you gain from using Hibernate? It saves me from writing the boilerplate of extracting data from ResultSet and populating into beans, closing the resources etc.
For Oracle it matters whether their investment in money puts them in front of the competition, or the competition in front of them. Regarding the competitive product, I don't know the name, but here is the link: http://www.theregister.co.uk/2016/07/07/oracle_java_ee_8 "The Register understands that roughly a year ago, a movement started within Oracle to mothball its Java EE efforts and create a new proprietary enterprise-friendly Java runtime and API in its place – which Oracle would have total exclusive control over and wouldn't have to share with IBM, Red Hat and so on. "
+1 for your comment. Hibernate converts SQL back to a 3rd gen language. The amount of times i've seen code that uses hibernate to fetch a bunch of entities, from the database, loop through them, and then use hibernate to retrieve additional data for each row, before storing it in yet another hibernate entity.... its bordering on the stupity, restricting access to a 4th gen language so it can be used within the confines of a 3rd, like java, and then using Java to do the data processing which ends up 1000x slower! I do not know how to make performant code using Hibernate. You can just not express what you want to do using the interface hibernate gives you. 
I work with both on a day to day basis. PL/SQL is one of the biggest pains in the ass to debug and write without some serious tools I haven't discovered yet (in other words: do they even exist?). It's for this reason if I have the choice between writing something to run in the DB and run on the app server written in Java, I'll take writing it in Java any day and twice on Monday.
Reassuring you prefer Java to PL/SQL. For me, PL/SQL coding is an absolute breeze and delight, so Java should be even better then :) Debugging tools for PL/SQL. I use Toad for coding, but for debugging, I simply dump messages to a logfile (actions, values,...) and then read that logfile as one big CLOB in Toad. Works well for me.
&gt; Debugging tools for PL/SQL. I use Toad for coding, but for debugging, I simply dump messages to a logfile (actions, values,...) and then read that logfile as one big CLOB in Toad. Works well for me. Holy shit. Okay, you're either going to have a lot of tools to learn, or be overwhelmed how great the tools we have are. What you've descirbed is basically the most simple form of debugging I could bear to cope with. At least PL/SQL developer has *some* rudimentary breakpoint abilities.
Ugh, enterprise gigs. I guess that makes sense. I'd never want to work at one of those places. Don't know about databinding, but the Kotlin Android Extensions are better anyway.
Awww poor Monica she took the role of architect with zero experience. After two years of starting the project she is asking what is Hibernate's cache :( Give John this job
It's worth noting that angular is JavaScript which is completely different from Java other than the similar names making things confusing.
But you do need to learn JavaScript? Any other technologies needed?
Nowadays, all IDE provide a way to deduce the type, so there is no more need for it. Adding some thing in a language which is not really required is not a good idea in general. C++ didn't respect this rule and became an incredibly complex language (I am a C++ developper) 
I am a Java/Javascript programmer who is now picking up PL/SQL for my current job... and wow, what a difference. PL/SQL reminds me of my BASIC/Pascal days of the late 80s. I thought Java was verbose and picky, but PL/SQL takes the cake. For comparison, go through a few online Python tutorials and see the difference. It'll even make Java seem old school, and PL/SQL even more so.
That's exactly one of the reasons why I like PL/SQL so much, it *has* to be the *exact* right syntax and nothing else. I'm curious, why do you feel that makes PL/SQL seem old school?
Eclipse in of itself is not a valley of low productivity, switching to a new IDE is.
Java Developer with 15 years experience plus a lot of projects with front end development. I also work closely with our dbas. I'll be honest, it will be tough. It's a different world the database world and the server side and front end world. Build a schedule and set goals and you'll get there. We all started somewhere. It's all about time and not giving up. Goodluck. 
Yes JavaScript and typescript if you want to use angular 2. don't worry actually makes JavaScript easier and more organized. Learn angular 2 instead of angular.js. Angular 2 is a huge improvement and easier to understand 
Ser querydsl for SQL or jOOQ, to get compilation errors when you change the db
Java is still at the top of the rankings and given how widely it is used in the corporate world, it will be at the top for years to come, but Oracle's commitment to the Java eco-system is ambiguous at best and I suspect it does not bode well for the future of the language. On the other hand, the JVM is unparalleled and there is no way that something like node.js is going to displace that any time soon. JavaScript on the server-side? Please. 
I suggest you watch this. https://www.youtube.com/watch?v=sBzRwzY7G-k
that sounds like a Thrift service to me, but Thrift is kind of a pain
Aren't dbas paid more than java or js devs? Why the move? It's a big headache. As java dev who also has done frontend work his entire life, the current frontend climate is exhausting.
I know there are plenty debugging tools but I'm old school, I "think" better when I am holding a piece of paper and can actually draw and scribble my thoughts about a possible solution on them.
The [Microserver](http://micro-server.io/), [micro-reactive](https://github.com/aol/micro-server/tree/master/micro-reactive) plugin will do this with json serialization.
Very much needed, now I don't have to create variables to hold a return value which I'm not interested in just for the sake of debugging 
Data access is a complex topic because you have to understand how database systems work, transactions, JDBC, and how to read/write data in a very efficient manner. [When used properly](https://vladmihalcea.com/2016/06/28/14-high-performance-java-persistence-tips/), Hibernate offers you a great variety of [data access optimizations](https://leanpub.com/high-performance-java-persistence/read#leanpub-auto-jpa-vs-hibernate): - extended identifier generators (hi/lo, pooled, pooled-lo) - transparent prepared statement batching - customizable CRUD (@SQLInsert, @SQLUpdate, @SQLDelete) statements - static/dynamic entity/collection filters (e.g. @FilterDef, @Filter, @Where) - immutable entities (e.g. @Immutable) - write-through caching so that you reduce load on a Master node in a Master/Slave replication - optimistic locking and versionless optimistic locking - support for multitenancy If you are interested in how you can tune Hibernate, check out this [High-Performance Hibernate](https://vimeo.com/181896822) presentation from JavaZone.
That's not necessary true, otherwise [cargo cults](https://en.wikipedia.org/wiki/Cargo_cult) wouldn't exist. It is human nature to blindly follow authority figures without actually understanding what they are doing. Then they blame the authority figures or external circumstances when things inevitably go wrong, instead of looking critically at their own actions. ORMs have a purpose, except that most people don't critically analyze that purpose or understand the applicability of what they are doing to that purpose, and then inevitably blame the tool instead of their own thought processes. TL;DR When you see 99% of the people complaining about the same thing, saying "they don't know what they are doing" or "they are doing it wrong" **does** work, and for a whole lot more things than ORMs.
I am no defender of Hibernate, I think it's terrible for the reasons you describe. You build expertise in a tool that has no utility anywhere else (the translation, in your analogy -- although it's translating without really learning either language). However, the one and only benefit, as I see it... is consistent saving of state. That said, I can recall countless times where controlling when and how data is saved is the difference between a performant application and one that chugs. Personally, unless it's dead-simple CRUDing of a really basic entity, Hibernate hurts a lot more than it helps. JdbcTemplate has never lead me astray. I will admit that there is a lot of boiler plate in using it, but there are some nice templates that you can design to save, cache, update, delete and fetch your data models in a consistent way for your app. 
I'm not sure I agree with you. The engineering community, in general, are very competent and capable people. The 99% includes "leaders" of the community also.
I love the Yegor link, as usual, his overly dogmatic arguments are torn apart in the comment section. The knowledge of the schema, the relations and columns, are embedded in the SQL just as they are in the ORM. And they will break just as easily as the ORM if you start messing with the schema in the DB. That's one thing that sucks about an application that has SQL statements strewn about, because you have no idea which queries you are going to break. The purpose of ORMs is to map is projections of the relational model onto the object model in bidirectional fashion, what you'd be doing by hand in SQL, and vulnerable to the same problems. You're not replicating the schema in the application with the ORM anymore than you are replicating the schema in the application in SQL. If you want to define different access patterns, of course you will need to add custom relationships to the domain, because those different access patterns define different projections from the relational model to serve different purposes in the object model, which serve a different abstraction and should actually be separate! That is not a flaw, that is OOP. Furthermore, because you are defining the mapping in terms of metadata, the ORM at least has a chance to verify that the mapping is still valid in the face of schema changes - Hibernate will fail to start if the mapping doesn't match the schema. How do you verify that all of your SQL queries are still valid after you perform a schema change?
I strongly disagree with that statement. Both the existence of [Cargo Cult Programming](https://en.wikipedia.org/wiki/Cargo_cult_programming) and StackOverflow are proof of that. EDIT: And [Coding Horror](https://blog.codinghorror.com/)! Engineers are not a special breed of people. Most are just trying to solve the problem with the minimum amount of effort and thinking possible. Most engineers are mediocre. As with any field of human endeavor, there are a few who are truly outstanding and "thought leaders", while most are just getting by.
&gt; &gt; customizable CRUD (@SQLInsert, @SQLUpdate, @SQLDelete) statements That's not an "data access optimization", that a basic, ordinary, everyday think that SQL gives you out of the box. 
Strictly speaking there is no Java EE on Tomcat. TomEE is a Java EE webprofile compliant application server. I think one of the easiest options is to go for a book which leads you by example with good IDE integration. https://www.amazon.com/Java-Development-NetBeans-David-Heffelfinger/dp/1783983523/ref=sr_1_1?ie=UTF8&amp;qid=1474474972&amp;sr=8-1&amp;keywords=Java+EE+7+Development+with+NetBeans+8 I haven't read it myself but Netbeans IDE has great integration with Java EE application servers and comes ready installed with Glassfish. So this book should help you to get up and running quickly without having to install applications servers and get setup Eclipse etc... 
The good old COBOL copybook, I love it. When you are reading file streams produced by mainframes with fixed width columns, the copybook provides a precise specification of the data that makes deserialization a breeze. We can even feed the metadata to Oracle to synthesize a table so that we can SELECT from the file. The copybook has absolutely nothing to do with ORMs.
its currently very diverse yes, but paradigms seem to change every year resulting in massive relearning.
I discovered that you can just copy the code into alt+F8 (Evaluate Expression) in IntelliJ the other day. Was doing what you were doing as a bad habit from using Eclipse so long.
Alt+click also works.
SQL will know to do an INSERT when I do "new" in Java? Or will know how to do an UPDATE when I change the values of fields in a persistent object? Or will know to do DELETE when I remove an entity from a collection? Or sequence INSERTs properly for foreign key consistency? SQL can determine the delta to an object graph synthesized from SELECTs, and issue the corresponding set of INSERTs, UPDATEs and DELETEs? These are features of SQL I was not aware of!
Hi I just quoted what my professor told about java ee And we use netbeans with tomcat Thankyou for your input :)
Well, it is. Because Hibernate can automatically detect any entity modification, you don't have to write the update for every such business use case. That being said, when you add/remove/rename a column, Hibernate will adjust the update query as well. You want optimistic locking, Hibernate will add the version column in the WHERE clause. More, you can opt to use the same UPDATE statement and benefit from statement caching or generate the UPDATE statement based on the modified columns only (useful when you have lots of indexes). 
False. Statically inferred types become part of the method signature when the method is compiled.
Just like grpc/protobuf, Thrift proposes a cross platform solution, which is great, but not needed if you're in pure java, and which comes at a cost in terms of overall complexity.
Yes, seems more or less what I'm looking for. do you have any (positive or negative) experience using it in real life?
That's really strange to me that, unless I missed it, something of this nature do not exist of the shelf. Now that microservices and distribution are all the rage, this seems like a basic need if you have two services that need to exchange a mildly significant amount of data. By the way, I'm not a specialist, but I think that c# WCF has this out of the box, with the possibility to expose IEnumerable over a remote service.
&gt; But we are talking here about complaints from 99% of People that &gt; use Hibernate. This is also an observation and a conclusion. Do you have any rigorous statistical analysis that shows that 99% of engineers that use Hibernate complain about it in a *fundamental* way? I mean, beyond the ordinary, complaining about a bug or missing feature. ORMs in general are very popular, and Hibernate itself is one of the most popular in the Java world, even being ported to .NET. Are all of these people idiots? How about instead of saying Hibernate or ORMs are crap, appreciate that they must have a reason for existence that causes people to choose it for good reason, but that it is simply not *your* cup of tea. I mean, if we are calling for humility. My point is, appealing to 99% of people's opinion on anything is a [logic error](https://en.wikipedia.org/wiki/Argumentum_ad_populum), *either* way.
You need to distinguish between Java (the language and JDK) and Java EE. Oracle has not, as you put it, "continued to neglect Java." They have revved it consistently and have a large team of engineers working on it. The article is about Java EE, which is a different product. There, the acitivity has been very much up and down.
not only are there a lot of different technologies, there are also a lot of very opinionated people/organizations that believe a certain framework is the best way to go.
Jesus, I don't have the patience to finish reading this. Can't consultants speak straight, why does every single point they want to make turn into a soap opera screenplay, complete with fake dialogs between fake people. If you can't make an argument, writing overly long fictional drama isn't a suitable replacement.
What exactly is the problem, can you dumb it down for me please?
No one has so far been able to explain to me how Hibernate caching manages to maintain the ACID properties of an SQL database. You can't cache something and serve from cache, when you don't know of this state is still relevant at the source. So what is Hibernate doing here? Blindly returning stale cache and calling it a feature? This alone should be enough to doubt the entire product.
I would start with the web frameworks, and drill down from there. I believe the 2 top frameworks currently are "Spring MVC" and "JSF". Source : Personal experience and https://zeroturnaround.com/rebellabs/top-4-java-web-frameworks-revealed-real-life-usage-data-of-spring-mvc-vaadin-gwt-and-jsf/ for example. Then you can go through that list and find web/blog comparisons that would help you pick the the right framework. E.g.... http://stackoverflow.com/questions/2249706/spring-mvc-vs-jsf At least so far, I've used Spring MVC and I'm happy with that choice. But choosing your Web Framework isn't all. Now you should pick your view techology, e.g. JSP vs Thymeleaf, etc. You can continue using Stackoverflow and the web for those comparisons, but I'd also recommend investing in this process and purchasing a few good books on Amazon on the topic. E.g. Personally I still use JSP even though it technically deprecated. There's just a ton of resources around JSP and I doubt Oracle has the energy to remove it anytime soon. In fact I believe it's due for some updates next JEE release if I remember correctly.
Woot! Finally!
The problem with Java 9 is, I believe, that they are still finding backwards-compatibility problems with the modules system and existing libraries and frameworks. [They're trying to reach out](http://mail.openjdk.java.net/pipermail/discuss/2016-September/003990.html) to library authors so they try out Java 9 and report back to fix these asap. Also, to be completely fair and IMHO, part of the reason Java development has slowed down since the Oracle takeover is that a significant amount of time has been spent on stabilisation.
We need to talk. Do me a favour and try jOOQ. You won't look back. :) - Type safe query - No boiler plate for extraction - Result is a type safe record with tons of utilites - Result can even be a Java 8 stream - You can populate beans - Resources are closed automatically And you're not limited by the mediocre HQL/JPQL query languages that can't even properly do derived tables or unions.
No no no, you must use hibernate EVERYWHERE. Never run a query directly against the database, or a trigger, or anything else, ever. 
By running the automated tests, of course. 
Well... That's why they called it javascript.... Right? 
I assume your question is about the second-level cache (the first-level cache is scoped to one Session/EntityManager, meaning within one Session will only load an object by id once and then obtain it from the cache; you could use optimistic/pessimistic locking if concurrent updates by other sessions are a concern for you). You'd use the second-level cache usally for immutable issue, in which case you naturally will have no issue with stale data. For second-level caching (rarely) changing data, you could use a transactional cache such as Infinispan, ensuring the cache stays in sync.
My question is for *all caches*. The problem is present at any possible caching at any point in the pipeline. &gt; you could use optimistic/pessimistic locking if concurrent updates by other sessions are a concern for you How is this even an *if*? Why is consistency optional? - What guarantees are provided by optimistic/pessimistic locking precisely for cache read skew? - Would cache from one session be used in the next session? - Would an update in some other session cause my session to be interrupted because I have stale cache (I doubt)? Would the cache automatically update (I doubt)? What would cause it to detect the problem at all? &gt; You'd use the second-level cache usally for immutable issue If the cached content is immutable and doesn't expire, sure, cache is easy. But what does *usually* mean? Does Hibernate enforce this or just allows users to blindly corrupt their domain state? 
Yeah sound like an "architect" position to me. Push terrible crap out to the team, when it shows itself to be crap try to pretend that other people were responsible for the results of your awful decision making. You're not trying to make the project run better and smoother, you're just trying to be loud and in charge.
Stackoverflow tag wikis
I don't know anything about Dapper, and since I'm in Javaland I won't put much effort into looking into it (because I can't use it), but what you're describing is what I would consider ideal. - Write regular sql. - Removes boilerplate code for setting up the connection, try/catch/finally for rolling back the transaction if it fails, etc. - Copies properties from the result set to the objects automatically. Doesn't do anything else - no hql query language (only use sql), no caching schemes (I've run into issues with Hibernates), no reinventing the wheel. If there's already an sql way to do it, then do it with sql. 
Unless I'm reading it wrong, it's the same functionality as going into the settings (gear icon) of the Debug pane in IntelliJ and checking Show Method Return Values. Plus IntelliJ adds this information at runtime to the end of the line that executed. Both of these are relatively new features, I want to say added within the last year? https://www.jetbrains.com/help/idea/2016.2/debug-tool-window.html Search for Show Values Inline and Show Method Return Values.
&gt; You'd either get an optimistic lock exception when committing a transaction which writes outdated data (meaning the TX will rollback, allowing you "to start over") or only one TX could obtain a lock on a given record (so no concurrent writes). How is that related to read cache? It's about what data you've read, not what data you've updated. It's a different problem, not solved by putting optimistic locks on data you *write*.
Please don't take words so literally. What I mean by "translation" is: We have data in DB tables/columns and we have our object model Objects/Properties and Hibernate helps to map them. Now we need to get data out of DB. If you want to get data thinking in terms of Tables/Columns using SQL then you write sql query expressing your intent in terms of tables and columns. If you want to get data thinking in terms of Object model then yo write HQL/JPQL expressing your intent in terms of Objects and properties. As simple as that. 
Evaluate expressions does apply the side effect (if any) of the code you execute, and is therefor not always an option. And evaluate expressions is not allowed if at any point of the code a lambda is involved, which is rather silly from a user perspective to disallow this. Still, I too use it for this. 
The term "over engineering" to me is code for "this is too hard to think about so we're just going to get started." I rarely see "over engineered" anything, but I do see a lot of terrible architecture surrounded by people who say "don't over engineer" a lot.
It's not on by default which is surprising. Must have a bad effect on performance but when you really need it it's indispensable.
[removed]
Yes!
Well, first off, [anyone claiming a library or tool means you don't have to know how things work under the hood is lying](http://www.joelonsoftware.com/articles/LeakyAbstractions.html). &gt; So what big advantage does using hibernate have over using sql? The ability to quickly model database tables to Java objects, the ability to use JPQL (which is a good substitute for SQL, though note that you should still know approximately what SQL it's going to generate) and the fact that you have an abstraction over your database provider (though I heard JDBC also does this). There's plenty of good reasons to use an ORM. I know I'm a lot happier when I know what type my queries are going to return instead of having to retrieve it as a Number and then casting it to whatever type I really need. JPQL is definitely a good substitute for SQL most of the time, and I really like that you can use almost any arbitrary class with it. So, quite a few reasons to use an ORM. I've even heard someone say "they who do not use an ORM are doomed to build one themselves". But you never not need to know SQL. And it's hardly the tool's fault if someone sells it with false claims. In the programming field, you'd expect people to look things up a bit.
It's very simple. I summed it up in the following articles: - [A beginner’s guide to Cache synchronization strategies](https://vladmihalcea.com/2015/04/20/a-beginners-guide-to-cache-synchronization-strategies/) - [Things to consider before jumping to application-level caching](https://vladmihalcea.com/2015/04/16/things-to-consider-before-jumping-to-enterprise-caching/) - [How does Hibernate store second-level cache entries](https://vladmihalcea.com/2015/04/09/how-does-hibernate-store-second-level-cache-entries/) - [How does Hibernate READ_WRITE CacheConcurrencyStrategy work](https://vladmihalcea.com/2015/05/25/how-does-hibernate-read_write-cacheconcurrencystrategy-work/) - [How does Hibernate TRANSACTIONAL CacheConcurrencyStrategy work](https://vladmihalcea.com/2015/06/01/how-does-hibernate-transactional-cacheconcurrencystrategy-work/) - [How does Hibernate Collection Cache work](https://vladmihalcea.com/2015/05/11/how-does-hibernate-collection-cache-work/) 
&gt; Well, first off, anyone claiming a library or tool means you don't have to know how things work under the hood is lying. Ok, but as I keep saying, this is exactly how Hibernate is sold, then when it turns out to not be true people are like "oh we didn't mean it after all". &gt; The ability to quickly model database tables to Java objects If you already know sql I don't think it's any faster other than automating copying the results from the resultset. &gt; the ability to use JPQL (which is a good substitute for SQL, though note that you should still know approximately what SQL it's going to generate) That's empty marketing speak. You're basically saying the advantage of using hibernate is that you get to use hibernate. &gt; and the fact that you have an abstraction over your database provider (though I heard JDBC also does this). Again empty marketing that doesn't mean anything it just sounds pretty. &gt; There's plenty of good reasons to use an ORM. I know I'm a lot happier when I know what type my queries are going to return instead of having to retrieve it as a Number and then casting it to whatever type I really need. It still does that exact same thing behind the scenes. The one advantage of hibernate is automating copying the ResultSet back into the object. But I think that could be fairly easily automated without all the other overhead of hibernate. &gt; JPQL is definitely a good substitute for SQL most of the time, and I really like that you can use almost any arbitrary class with it. Again marketing speak, you haven't listed any actual advantage other than "Hibernate is great because you're using Hibernate". JPQL is pointless - it's almost sql, but slightly different, and it's translated into sql when it's actually run. Just use sql. &gt; So, quite a few reasons to use an ORM I only see one out that that whole list - automating copying resultsets into and out of objects. But that could be done a lot simpler without all the other overhead of hibernate. &gt; I've even heard someone say "they who do not use an ORM are doomed to build one themselves". But you never not need to know SQL. And it's hardly the tool's fault if someone sells it with false claims. In the programming field, you'd expect people to look things up a bit. It's absolutely Hibernate's fault that they market it with false or misleading claims. I've worked at 3 places in the last 2 years and hibernate was sold the same way at all of them. 
&gt; Then you are buying it from the wrong people ;) Like I said though that's usually how it's sold. I worke 3 jobs in the last 2 years and it was sold that way at every one. &gt; By no means intents Hibernate that you should not know SQL. On the contrary, the first thing I recommend to people is to enable query logging and actually inspect the queries emitted by the ORM. I've done that, but after taking on a project of moderate complexity I found that Hibernate was noteably worse to use than just writing the sql myself. I think the last issue was that an existing legacy table had a compound key that we didn't have a choice in using. 3 of us tried, none of us could get hibernate to work with it's compound key. One guy actually got hibernate to work with a compound key on a different table, but for some reason it refused to work with the table we needed. I just wrote it in sql finally. That was easy. &gt; Why use an ORM then in the first place? It let's you deal with complex object graphs (i.e. modify them as you like) and then takes care of the synchronization with the database in a safe and consistent fashion. That hasn't really been much of a problem just writing things with straight sql either. Hibernate does introduce new, unexpected bugs though. Like if you thought a column was a unique primary key, but it turns out it isn't, it will silently overwrite good data with bad and fuck everything up without throwing an exception or letting you know about it. It's a result of how it's caching works. &gt; That's the tricky part to get right. Use it if you benefit from it. There are scenarios where using an ORM isn't helpful, analytics and batch processing being two examples. Hibernate never was meant to be used for everything, despite some people apparently believing this :) Because of the way CRUD apps work, having all their data submitted from the web at once, I just didn't find an advantage to hibernate for that either. The browser submits data as strings, spring turns it back into your objects, and you know which tables to modify because of the screen they were on. There's no use case in CRUD apps where the user could modify data on several different screens that aren't related or part of the same flow then suddenly decide to save. You can't (well technically you could but that would be a nightmare for locking your database up) keep the database transaction open between requests in a way where you didn't know data had been modified.
&gt; it was completely impossible to even add a property to the entity because you would for sure break half the queries I'm not sure what that means, queries don't break because you add a new field. If it worked before it continues to work, you just might not get the extra field data back.
&gt; Having 32 and 64 bit versions is no criticism for a program. Programs that auto-detect that are in the distinct minority. IDEA is the **only** program I've used that has that issue. Everything just runs and figures it out on it's own, without any apparent performance issues. (And if you choose wrong you get some very strong performance issues with Intellij). &gt; And I've had no trouble with Maven at all with IntelliJ. Our entire team had the issue and there was an official bug from numbers of other people with the same issue. &gt; I find IntelliJ's code completion to be light years ahead of Eclipse's. It runs smoother, with less lag (the indexing period when you open a new project notwithstanding). It's error detection and code suggestions are amazing. Having used both, I really couldn't tell the difference. &gt; Just in terms of helping my day-to-day coding work, IntellliJ has been light years beyond Eclipse. Any time someone starts saying things like "light years" I'm pretty they're just enjoying a "it's better because it's new and different" effect. I definitely did not find it to be any better, just annoying to get over the learning curve, then it was about the same. &gt; It has it's issues. I think some of the project setup (module settings) is a bit too convoluted for it's own good, but I'm willing to accept that in exchange for everything else. Ok. I just didn't see anything else. Like I said it worked fine. It wasn't worse than Eclipse. It was just full of it's own bugs, quirks, and oddities.
Tell me, how without knowledge how hibernate works I could create a story which so many people agree with?
I would love to conduct scientific proof (10 years needed?) but it would ruin my health and bored you to the death.
&gt; in terms of functionality however you really can't compare it to hibernate imho... Probably not, if by "functionality", you mean mapping, locking, caching, et al. What are you missing in particular?
At the moment Clojure proficiency isn't exactly going to open up the job market though.
You could look into session variables and then access it in the other class.
Lukas I carefully specified that I was talking about a **typical** OLTP scenario. I certainly don't deny that there are scenarios which are atypical, and it sounds like your problem domain was one of those. If you have a program where 80% (!) of your queries are doing something like what you've exemplified above, then _quite clearly_ we're not working in a sweet spot for ORM, and ORM probably isn't appropriate or useful (except, perhaps, _in the parts of the app where it is appropriate and useful_). It seems clear to me that the scenarios I've described as "typical" are far more common than the ones I'm calling "atypical". &gt; Depends if you're in the camp of "oh my god, business logic in the database??? ghasp!!" I don't think I'm in any particular camp. I do things that make the most sense in context.
&gt; Obviously, the 99 number is arbitrary and based on my own observations from my co-workers and other people in multiple companies I've seen. The plural of anecdotes is not data. There are plenty of anecdotes that run contrary to your observations. That is all that is needed to be said about this.
loading entities partially is not worth the overhead in my opinion. I don't wanna worry as UI Layer if my "User" object has all fields set. Same goes for ordering in the UI. If you're not building the latest shit with 1mio+ users/day keep it in your pants. Let the database do what it does best (search / order / group data) and don't reinvent the wheel in the Application (hence ordering).
Tomcat supports a very tiny subset of JavaEE, that is Servlets, JSP's and Websockets (and maybe a few other things like database management) It is not the full JavaEE by any means, but the Specifications it does supports are JavaEE 7 compatible, and I think its a good place to start. Think of it a as a bare bones 'arduino' type device, good to get going with, good to learn about technology with, but....really, you probably wouldn't want to make anything complex with it. TomEE, is an enhanced version of tomcat, that adds many more API's to the mix, bringing it up to the WebProfile JavaEE standard. 
&gt; Deeplearning4j is the only commercial-grade, open-source deep-learning library written for Java and Scala. Don't forget about H2o http://learn.h2o.ai/content/tutorials/deeplearning/ And Aerosolve is always worth a look https://github.com/airbnb/aerosolve I'm not sure how they compare yet, but it's not the only one out there.
I hope you'd follow your own advice and notice reflection-based, annotation-driven containers were never a part of the pattern, but a supposed convenience that has slowly become a hindrance. DI is trivial if you allow it to be. 
'serverless'
As long as it's someone else's problem...
If you're looking to get into web development with no prior experience I would suggest you stick with the basics of HTML and some web specific languages like PHP, Angular, etc. Java is a powerful language which will take sometime for you to familiarize yourself with just the basic so it will take you more time to actually work with web development using Java.
RouterFunction readability is awful. Maybe I'm just getting old.
Agree, I'm starting to think it's time to switch my career to Ruby or PHP; Java is going down hill fast.
Or even better, JavaScript
Care to elaborate? It's basically a function from Request to Response. You might wanna look at the section discussing [Method references](https://spring.io/blog/2016/09/22/new-in-spring-5-functional-web-framework#method-references) for a way to structure code so it still stays readable.
I'm getting old and haven't been following Spring lately. The last thing I learned was Spring MVC and Spring WebFlow. What exactly is this framework replacing? Is it an additional framework? If so, can someone give me a quick explanation as to why its different than the ones I mentioned. 
hehe, well JavaScript through jsweet transpiler wouldn't be so bad as long as they don't make it jsweet functional/reactive.
It's functional, so now it's webscale. /s? You tell me.
&gt; &lt;T, R&gt; R getItems(Function&lt;? super Stream&lt;T&gt;, ? extends R&gt; f) If this is where Java is headed, the Enterprise better get ready for some hefty long term maintenance costs. 
So you're saying Intellij is now behind Eclipse in what it does? Eclipse now tells you the value returned, sounds like Intellij now only tells you the result of running the method a second time, which may be a different result.
Thanks for the explanation. Spring MVC and the servlet model have been working great for me. I don't see myself switching. Although I'm sure there must be valid business and tech reasons to switch to this model, I just simply don't know them.
When I think of web scale, I think of hardware, not complicating the software.
Great answer, but a small correction: the reactive frameworks, both annotation based and functional, run on Servlet 3.1+, Undertow (native), RxNetty and Reactor Netty.
Ruby or PHP?! I'm also a little concerned with the state of Java, but it's still light ears ahead of either of those two languages. I hate it, but JS would be a much better field to switch to if you are thinking of jumping ship.
guy there that left java to ruby. give a try to ruby, you will smile. After battle with .xml, hibernate, servlet, inject shit, DI, moving to ruby/rails/sinatra. Put it this way: I'm, enjoying now programming
&gt; .xml, hibernate, servlet, inject shit, DI You don't actually have to use these things. 
no need to judge java by spring, i don't use spring at all. it's a jack of all trades and master of none - there are better ioc and config libs out there
As I understand it, Reactive runs on whatever containers [have been adapted](https://github.com/spring-projects/spring-reactive/tree/master/src/main/java/org/springframework/http/server/reactive) to the Reactive Streams API. I assumed the present list reflects what is available, not what is possible. For example, how hard would it be to adapt Vert.x to Reactive?
This is what I've struggled with when using functional routing in Scala via Spray - the functional part makes it easier to think about, but then the actual construction is ugly and eats up more of your thinking than ever. I hope this gets addressed somehow.
&gt; I hate it, but JS would be a much better field to switch to if you are thinking of jumping ship. Are you seriously saying that Ruby is worse than JS?
This is the issue? I mean for the past decade we've been spewing our configuration (and random bits of codes via aspects) all over the codebase using annotations and just now its going down hill?
I used guice in place of spring about 2years ago, was impressed with the ease of use and speed. I believe Dagger is now the more popular ioc specific library.
&gt; reactive frameworks And [Akka](http://doc.akka.io/docs/akka/2.4/java.html).
I implemented something almost exactly like that as part of my current project at work, a few weeks ago. The project will be open sourced soon (but not, like, the next few days soon) so it unfortunately won't help you immediately. I might ask around and see if we can perhaps open source it in chunks. At any rate, it's not hard to do. If you're experienced with RPC you could do it in a few days, tops. Basically I combined the following things: * Artemis MQ for routing and queuing of binary messages. * java.lang.reflect.Proxy for dynamic generation of proxy objects. * Kryo for object serialization. * RxJava for observables. There's no IDL - just a simple Java interface that defines the exposed RPCs and then the objects are serialised directly. The tricky part is handling the observables. I did it by defining custom Kryo serialisers on the server and client. RPCs that can return observables are tagged with an annotation and calling such a method sets up a queue to receive the emissions. When the response is serialised, any observables that are found are subscribed to on the server side, and the subscriber serialises and posts the emitted objects to the client, where they're deserialised and pushed onto an Rx UnicastSubject. There are a few details to be careful about, which took up most of the time. One is to make sure you don't lose any emissions on the observables, i.e. everything is atomic. Another is what happens if the observable emits objects that in turn contain more observables, which is quite a common need in our project. The framework handles this correctly.
Ah. You are talking about the community. I agree that Ruby community is shit. But to me is as shit as the whole Node.js community that loves the hype of the hour.
Honestly I'm not a baked in DI user, I use Spring because jobs ask for it. I'd be just as happy using POJO no DI and plain Servlets. And yes, I recall when Aspects came out and my view was seeing a cloud (not the good kind) of crap code and debugging messes. Then EJB was a mess too but a different kind. I wish the Java world would just adopt Spark Java, Per Wendel should be given a medal. Although Spring Annotations makes for readable code. Not sure I care for this type of stuff: dog() .eats() .apple() Then throw in lambda to be politically correct and it's a visual mess again. 
It's the same as Java 1.5 and Java 5. Internally it's still 1.x. 
Yea, I will make no defense of JS communities, generally or for specific frameworks. Even very big ones like angular leave much to be desired. Like I said (not that you are really arguing the opposite), I'm not a fan. But at least they are big, there are a lot of opportunities to move around. Ruby, unless where you live (or willing to move to) has a lot of opportunities, you are going to have far less mobility. To me mobility is very important. It gives you a lot more leverage in salary negotiations and you don't feel locked into the company you are working for. 
That escalated quickly. To remove type erasure does not mean all compatibility will be lost. In fact source compatibility would remain, probably binary could also be achieved (although a lot harder to do). Behavioral compatibility would of course be broken because that is the idea. Also you don't have to be full in on compatibility. You can make a compromise. And there are lot of compromises you can make: * Never break source compatibility. Which already happens that is why we have @override and not a keyword. * Only break source compatibility it every X major versions, or every major version. This means minor versions would never break source compatibility. * You could break source compatibility every 5 years, but break behavioral compatibility every 2 years.
You can introduce the concept of variance and ask the programmer to define it explicitly. If you defined ArrayList as covariant on its type argument then yes you could pass an ArrayList&lt;FancyString&gt; to a function that expects an ArrayList&lt;String&gt;. You could also make a decision and say the compiler will always make it invariant, contravariant or covariant, whichever you think is more appropriate. Of course it will be a lot of work. Do you think introducing the streams API and lambda expressions was without lot of work? Certainly not. But their usefulness is very well worth it. In 2004, when Java 5 came out, it was both a business/marking decision as well a technical decision, because if the compatibility was broken, there was a high change that a lot of programmers would abandon Java. So the decision to implement type erasure was correct, as in, it was made to facilitate the migration from Java 4 to Java 5. But now 12 years later the decision to still keep it no longer makes sense. [Nowadays Java **6** usage is very low (~10%)](https://plumbr.eu/blog/java/java-version-and-vendor-data-analyzed-2016-edition), so you can extrapolate and say Java 4 is unused in practice. This means we are using a system that is designed to maintain compatibility with something that is no longer used. So nowadays it's just a marketing/business problem, they could very well have implemented reification.
Dependency passing: fun saveToDatabase(user: User, logger: Logger) {} Dependency injection: @Inject var logger: Logger fun saveToDatabase(user: User) {} Hope it makes more sense to you now, happy to drill down otherwise. And look, we can have a discussion while being respectful of each other, imagine that. 
&gt; unlike spring it doesn't interleave object startup with wiring Spring doesn't interleave object startup with wiring. Spring beans have [lifecycle](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-factory-lifecycle) callbacks. The most common ones are `@PostConstruct`, which gets called right after wiring is completed and `@PreDestroy`, which gets called before the container destroys the bean. A bean can also implement the [`LifeCycle`](http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/Lifecycle.html) interface which allows it to respond to start and stop events on the container, far removed from wiring. &gt; it compiles properties files via includes into a Config object, that &gt; is then available via dependency injection like any other object. This is [available](http://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-typesafe-configuration-properties) in Spring Boot. Spring Boot doesn't even limit you to properties files. You can use YAML too.
It was/is an expression of a sentiment, nothing more.
Figured I'd throw this out there. H20 doesn't actually do its own deep learning. They just wrap python libraries and other frameworks that do the heavy lifting. None of it is actually straight jvm. Few differentiators: Via java cpp we do our own memory management of cuda and native c++ memory: https://github.com/bytedeco/javacpp We also support first class cudnn nd cuda integration TESTED with spark and hadoop environments. You may get a kick out of our spark page: http://deeplearning4j.org/spark We also have a JVM first scala wrapper called Scalnet: http://github.com/deeplearning4j/ScalNet/ This implements the keras interface. Aerosolve is great but doesn't have gpu support and is more for price forecasting. They don't have much in the way of deep learning. They focus more on interpretable featuress. Aerosolve is maintained by airbnb's dynamic pricing team. They are obviously java only.
Our marketing team got it wrong. Thanks for calling this out.
&gt; Hard to say anything without further context but that's exactly my point: turn on statement logging (also DDL) and see what is executed. You'd see right away that something is not as you expected it and could alter the mapping etc. Which erases the advantages of hibernate and leaves me doing the same work as if I had just written sql to begin with. &gt; On the entire notion of "selling it" in the way you describe, I don't know where this comes from. It's certainly not a line of thought in the team nor is it described like that in the documentation. Maybe unexperienced consultants out there? Maybe you should read the article that this entire comment chain is based on. &gt; John - Look. DBA guys have a different perspective. They are afraid of Hibernate because it seems to replace their role in the project. Moreover, databases have built-in query optimizers so you don’t need to worry how those queries will actually look. The database will optimize it for you. It’s all about rapid development, which SQL can’t do. &gt; Monica - Really?! No longer dealing with SQL? Amazing! Last time a DBA spent weeks trying to optimize some queries. Weeks! Oh, I feel so embarrassed telling you this, but did you know that we were using … stored procedures (laughing). Oh, it was such a mess. Can you believe the project is still using it? I feel so sorry for people out there. They still have to write this tedious code over and over again. I wonder if it’s still a Java or SQL project? This is how it's gone every time I've been on a team where someone is trying to sell hibernate. "no more sql!". 
&gt; It is absolutely not, and has never been "sold" that way. Hibernate in Action, first published 12 years ago, explicitly repudiated that notion, and nobody on the Hibernate team has ever promoted it. Every team I've been on where someone has been trying to get us to use hibernate has had several team members pushing the idea that we wouldn't have to learn or use sql because hibernate would take care of it for us. &gt; "suddenly" More than 12 years of saying the same thing over and over to everyone who was interested is not "sudden". Before you implement hibernate "omg no more sql!" after you implement hibernate "oh well of course we still have to use sql". I'm not sure whether it's "bait and switch" or "motte and bailey", but it's the same skeezy sales tactic. Maybe you're right and the hibernate team itself doesn't push this, but everyone I've met pushing hibernate pushes this idea, whether saying it directly or carefully implying it so others think that's what it means. &gt; "Were told" by whom? &gt; "Deliberately implied" by whom? &gt; Quotes? Links? Names? I'd suggest trying reading the article, because that's how it's gone on every team I've been on: &gt; Monica - I absolutely agree! I have the same feelings about it. In a previous project, we were using mostly SQL via plain old JDBC. Ridiculous! I know! But, here’s the thing: We have really smart SQL guys in the team and when they saw SQL generated by Hibernate they got nervous. It seemed ugly and unreadable; will this be a problem in future? &gt; John - Look. DBA guys have a different perspective. They are afraid of Hibernate because it seems to replace their role in the project. Moreover, databases have built-in query optimizers so you don’t need to worry how those queries will actually look. The database will optimize it for you. It’s all about rapid development, which SQL can’t do. &gt; Monica - Really?! No longer dealing with SQL? Amazing! Last time a DBA spent weeks trying to optimize some queries. Weeks! Oh, I feel so embarrassed telling you this, but did you know that we were using … stored procedures (laughing). Oh, it was such a mess. Can you believe the project is still using it? I feel so sorry for people out there. They still have to write this tedious code over and over again. I wonder if it’s still a Java or SQL project? &gt; John - That’s exactly the difference between an object-oriented approach and the relational one. It’s a so-called object-oriented impedance mismatch. Hibernate can close this gap. Developers can focus on building business logic. Push features make stakeholders and the entire management happy. Do the things that matter most: Business! Lots of boilerplate code will disappear, and you’ll have a magical, invisible, but reliable, connection between the logic and the data. Oh look at that, he technically carefully implied that there'd be no sql, then didn't correct here when she stated is explicitly. That's always how it's gone in my experience, if the 1st person isn't the person directly claiming no need to learn sql.
just curious, what exactly did you do to achieve a higher throughput than the standard executors?
I'm in the same boat lol, thanks for the info guys
Sure, having a proprietary object mapper is usually even worse than hibernate. Hibernate has a lot of sucky stuff but sometimes the internet has answers and workarounds and at least the time you invest might benefit your resume in the future. And investing time and effort into solving it means you might be able to use it at another job. But if it was just hand crafted queries it shouldn't be the huge problem you were describing. Existing queries would continue working if you added a field. The promotional idea likes to claim that you'll gain a big improvement by not having to modify your queries in the future, but in addition to security concerns (If I hacked the submit to change properties on the object that I wasn't supposed to and hibernate updated the database accordingly) reality is that no screen flow is going to add the new field automatically. You have to go through each flow anyways and add a field into the jsp, then test it. After that it's just a matter of whether you also add an annotation to the field, or add a column name to the sql query for that flow, so it didn't result in any time savings in my experience.
There's always the Play routing DSL (aka SIRD): http://developer.lightbend.com/guides/play-rest-api/
h2o didn't roll their own deep learning. they built an MLP, which is 1980s tech. for the state of the art, though, which is CNNs and RNNs, they wrap caffe, mxnet and tf. they didn't build those libs, and they can't really sell support around them, let alone extend or customize them. and they wrapped the *python* layer of tf, not the c++, which is stupid. arno candel is the only DL expert at h2o. the rest of the company is selling random forests and GBMs, or trying to. they fired their sales and marketing team last week, and look like they're imploding. the ceo fired the cto earlier this year, and with that, the man who had led the product walked away. as for aerosolve, all i can say is: there's a difference between libraries and enterprise distros. you want libs, sure, go with aerosolve. there's no one behind it to back you up, no number you can call, and no organization aligned with the users/clients. 
&gt; I can just quote the article for this thread: You're quoting a fictional conversation between fictional characters. Written by someone who is _criticizing_ Hibernate, not advocating it. That is to say, you're quoting a straw man. &gt; Typically your response will be something like "well technically they didn't say that!" but that's just because it's skeezy sales. Imply, imply, imply something without quite saying it, knowing the audience will make the obvious assumption. Nonsense. Nobody from the Hibernate team, from JBoss, or from Red Hat says or implies anything of the sort. And you can't find me any evidence at all in support of your assertion. Accusing us of "skeezy sales" is obnoxious.
&gt; Every team I've been on where someone has been trying to get us to use hibernate has had several team members pushing the idea that we wouldn't have to learn or use sql because hibernate would take care of it for us. ... I'm not sure whether it's "bait and switch" or "motte and bailey", but it's the same skeezy sales tactic. But you can't find any online evidence of this. Surely, if this view is _so_ widespread, then someone, sometime, must have written a blog post, or tweet, or _something_, saying that with Hibernate you "wouldn't have to learn or use sql". But I've never seen such a blog, or tweet, and you don't seem to be able to find me a link. 
&gt; You're quoting a fictional conversation between fictional characters. Written by someone who is criticizing Hibernate, not advocating it. That is to say, you're quoting a straw man. No, I'm quoting a story from someone who works in the field who's either seen this happen or been the person it's happened to. And I've personally repeatedly been on teams that have gone through this as well. &gt; Bullshit. Nobody from the Hibernate team, from JBoss, or from Red Hat says or implies anything of the sort. And you can't find me any evidence at all in support of your assertion. Accusing us of "skeezy sales" is disgusting. That your response here is so full of manipulation and identity politics style stuff just makes me think more than yes, the hibernate team is behind this. But on one thing you're misreading what I'm saying. I'm saying the person in the organization I've worked for pushes it with that. I don't know exactly where the source is. I don't know if it's the Hibernate team or not. I don't know if it's the Hibernate sales people or not. I have no idea who makes this sh!@#! up. I just know that that's how it's sold by the local person pushing it, and that they got it from somewhere else because it's the same rhetoric at several different places with no employees in common other than me (and I know I'm not the one pushing it). I'm not saying it's only hibernate. Maven, Angular, Intellij, all these I'm most familiar with all being sold with the same bullshit manipulative sales tactics. A few developers were shocked - shocked! and tried to argue with me that it wasn't true when I told them that you didn't need Maven to download jar files, there were other common ways to do it and in fact everyone just downloaded the jar files manually before Maven existed. Shocked. I couldn't believe it. I've heard a whole list of similar b.s. regarding angular and intellij as well. You point me to a place on the official hibernate site (not just a random forum post from someone unknown) where it officially states that you need to know enough to be able to write all the queries yourself in order to use hibernate well on a large project, and I will start saying that the hibernate team doesn't promote it but other people do. But it won't change that every time I see hibernate being sold into a dev group it's either heavily implied or outright stated that using hibernate means not needing to know much about sql. And by "sold" I don't mean "money changed hands", I mean someone is trying to sell everyone especially management on the idea that we need to use hibernate in our project.
Sure I can learn how to code "hello world" in five minutes :) but it's the whole ecosystem I'm worried about. It's a totally new world, a set of technologies working together. The more I look at it, the steeper the learning curve seems.
i can partly agree with you there. in my special case we had the hand-written resultset mapper which required the new field to be present. ofc this could have been fixed by implementing some optional mechanism but it was just not worth the hassle. Concerning security: good advice on never trusting client input. My biggest issue is that you have to test every hand written SQL statement you modify (for syntax errors / wrong parameter count / ...). In a perfect world you have a unit test for each statement, but yeah, sadly that was not my world. however I do see your point. if you have a good enough test coverage (or code which is easy to user-test) and can live with "some queries return the field, others don't" it will work.
So the person you're accusing of "skeezy sales" is not in fact a salesperson, nor any sort of well-known advocate for, or expert on, ORM, JPA, or Hibernate. Indeed, it's just an unnamed colleague of yours. Thanks for clearing that up. It would have been _way_ more helpful if you had made that clear from the start, instead of broadly implying that the Hibernate community is guilty of "skeezy" (that is, unethical) "sales". So look, none of your assertions in this thread are supported by evidence that can be independently verified. You claim that some unnamed person or people say or believe something that's clearly incorrect, but based upon the wild mischaracterizations contained in your posts here on this topic, I would not be at all surprised to discover that you're also mischaracterizing or, more likely, simply _misunderstanding_, the arguments of your own colleagues. Whether that's the case or not, it's certainly very well-understood that one needs to have a very solid grasp of&amp;mdash;and be very comfortable with&amp;mdash;SQL and the relational data model before using ORM on a serious project. This is something I and many others have emphasized over and over for more than a decade. I recommend [this book](https://www.manning.com/books/java-persistence-with-hibernate-second-edition) for a great coverage of these topics. For example, right here, [in the very first sample chapter](https://manning-content.s3.amazonaws.com/download/1/89cdf62-d6f4-46da-80e2-d22d74971deb/Sample-ch01.pdf) the book states: &gt; To use Hibernate effectively, you must start with a solid understanding of the relational model and SQL. You need to understand the relational model and topics such as normalization to guarantee the integrity of your data, and you’ll need to use your knowledge of SQL to tune the performance of your Hibernate application. Hibernate automates many repetitive coding tasks, but your knowledge of persistence technology must extend beyond Hibernate itself if you want to take advantage of the full power of modern SQL databases. Note that this passage is unchanged since the very first edition of the book, 12 years ago. So enough with your crazy strawmen!
&gt; impossible for Spring to pivot That'll be a "pivotal" event for Spring, right?
AWT in 2016?! 
I've read the article, but there is no point in arguing about some fictional talk between some fictional characters. The fact remains that no one in the Hibernate team makes the claims you describe. If people in your environment do make such claims, they are just wrong. I recommend to check with primary sources (e.g. a tool's reference guide), talk to proven experts on a given subject and of course collecting your own experiences instead of blindly believing things claimed by the next person.
&gt; it does if you use (abuse?) init-method and destroy-method for start/stop Spring is only doing what it is told to do. &gt; for a framework that has a very high opinion of itself, this isn't a very good effort. Why? It works pretty well.
I apologize for hurting your feelings. It was not my intent.
I see your point. However I'm not certain with reification the code will fail, you are just performing a cast. Even more with reification if Map as defined as covariant the cast shouldn't cause any problems. Java is not a [dynamic language](https://en.wikipedia.org/wiki/Dynamic_programming_language). You can say that it is when you use reflection, but is a little stretch to classify the entire language as dynamic.
I love VS Code, but it's an editor, not an IDE. Why not use an IDE? 
joke's on you as spring is very modular nowadays. it can be as bloated or as lean as you want it to be.
I don't think there are enough "hibernate"s in that URL...
Aside from all the inner dependencies. Spring this relies on Spring that which relies on Spring who, by the time we're done we have 40 transient jars.
The method wouldn't compile. T can be an interface or an abstract class which cannot be instantiated. Currently you can't do that, why would removing type erasure allow for it? Testing is not a problem. If you had the need to make a generic class then its because you need to have some type that is only defined at instantiation. But it doesn't mean you will have to test your class for all types. For example, how do you implement tests for List&lt;T&gt;? I don't see the bad habit you are referring to. This would be a better use case: class SomeClass { public Person composePerson(List&lt;String&gt; fields) { // some implementation } public Person composePerson(List&lt;Double&gt; fields) { // some implementation } } In the current java version this code does not compile. However it could be extremely useful if it did. 
I think AWT stopped being of much interest to most Java developers in 1999 or so, when Swing was first released. 
Selenium is the best UI automation tool I have ever used. Definitely a valid component.
I'll have to admit that compared to some of the other languages Java is quite intimidating. It's been around for sometime and there are a lot of libraries in the core Java and J2EE alone, not to mention hundreds of other open source libraries. It will be intimidating at first but definitely will be rewarding to learn the language. Best advise I can give would be to learn the basics and focus on a specific tech/framework after that. Best of luck and welcome to Java 
I have been using Selenium for about 5 years now and its still the way to go. Its also nice to be able to use portions of test scripts to automate portions of 'manual' tests as well. If you didn't use the Page Object Model style, I would recommend looking into it.
25k lines of ant? What the hell were you building!?? o_O
tell me which "hobbled together mess" of tooling you experienced. I find the JS tooling experience to be unmatched. (Here for a discussion not bashing)
I've recently been working on a project in my spare time, and one of my goals was to NOT use Hibernate, and use pure JDBC instead. By using a consistent query structure (in terms of the order of the columns) and utility classes for the repetitive code, I've actually made the process of parsing ResultSets and populating PreparedStatements incredibly easy and re-usable.
That looks hideous
While I'm not aware of any, I guess there could be. If you know that you won't ever need anything else, then sure. But I find that to not be true most of the time.
WebStorm is great. If they released a community edition it would be perfect.
Look into IntelliJ Idea. It's fairly lightweight and free. You'll thank yourself for it later. 
That's a very big question. Spring is an umbrella of frameworks. I assume you're talking about Spring MVC and/or Spring Beans (IoC/DI). Those are very popular frameworks. Probably the most popular for their specific roles, but there are others that work just as well and have similar/same concepts. If you learn one MVC framework, you've learned enough to be portable to any other one. Ditto for DI. If you know Guice, for example, you'll be fine with Spring if your company uses it.
I've seen Spring MVC in a small number of job descriptions, but by and far, they have all mostly been "Spring" or "Spring Framework." 
I looked at moving a site from Spring to React (to take advantage of isomorphic js) but the js libraries are so poorly made it's a joke If you're gonna do it, keep your Java backend as a REST service and use JS for GUI only
You must be an enterprise developer. I've found that log files can be the best way of figuring out what the heck happened with a piece of code. You can't always recreate a situation, and there are environments where you can't just go attach a debugger to the JVM.
The npm system itself for instance. Not thought through at all. Then the need for a linter, babel, etc. Marginally better texteditors that call themself JS IDE's. Jake, Grunt, Gulp,... build tools come and go. No standard test framework.
I do agree there are a lot of frameworks and libraries being built. That can make it a bit difficult to chose one. As far are using linters, its your option, if you want to keep your code consistent. In fact every single one of these tools are optional. Most languages don't have a community like JS's to constantly create and improve open source projects. Btw how have you not heard of Mocha?
No, JS is inevitable. You can of course use tools that compile *to* js. GWT is one such toolkit (but not very good) for java. There are also other statically typed languages that compile to JS.
I'm actually surprised to read this. I don't know any Java developers who actually like JSF. More recent versions have made it somewhat tolerable, but I really don't meet a lot of developers who like it. It's always been the crying baby on an airplane of web frameworks. This is especially noticeable if you have to use it without Omnifaces. The fact that Java EE 8 has a new MVC framework (that looks a lot like Spring, as usual) is rather telling.
Are you hiring in the DFW Metroplex? ;-)
Personally, I would say yes, it is the most popular. But like others have said, spring is a vast umbrella. Mostly likely the job postings refer to spring mvc and spring beans (dependency injection). Learn those two(will take some time) and you'll be good in an interview. 
How about [Play framework](https://www.playframework.com/documentation/2.5.x/JavaWebSockets#Handling-WebSockets-using-callbacks)? It supports websockets, separates views from code using scala templates, and you can use this fresh and new coffescript instead of old-n-plain js. Here is a websocket example: https://github.com/playframework/play-websocket-java
Not sure what kind of JSF they migrated from, but the technology they were using is also outdated. Anything replacing the improperly used tool is always new and shiny; also JSF makes always sense in certain domain. A good reason why it will co-exist with MVC in JavaEE 8.
Within its pockets of adoption, I'm sure it gets a lot of good press. I experienced the same thing while using GWT with Smart GWT. Great product! As long as you can live with its trade-offs. That said, Spring is one of the most widely adopted frameworks in the history of Java. I'm not sure what else would have really achieved higher market penetration. But that's only when you're talking about Sprint IoC. Now, if you want to talk about UI frameworks, Spring is also leading by a healthy margin there. See https://zeroturnaround.com/rebellabs/top-4-java-web-frameworks-revealed-real-life-usage-data-of-spring-mvc-vaadin-gwt-and-jsf/ if you'd like some data points. To OP's question though: Yes, learn Spring. Heck, learn all of it. It's VERY marketable and seen by many shops as a must-have "skill" (in quotes because just knowing more than one part of Spring actually qualifies as MORE than one skill, but I digress). 
Well, it's quite easy to cry about JSF, because it has quite a steep learning curve. Especially, if you're new to the Java EE stack, because combining those technologies can get a bit cumbersome in some scenarios. But I don't think, that it can be considered dead. Just look at [PrimeFaces' download numbers, they're quite high](https://twitter.com/cagataycivici/status/740642360330223620). I also know some local businesses, who use it pretty heavily. One advantage may be, that it is standardized. That's quite important for some enterprises. Another thing is, that MVC may be dropped from the EE 8 umbrella, but there's still JSF 2.3 in it. So I don't see that as a strong argument. (Although I want to make clear, that I'm not a fan of dropping it.)
&gt;Well, it's quite easy to cry about JSF, because it has quite a steep learning curve. It's not that. Since day one, JSF has been non-extensible. Our way or the highway. Doing easy, school project demo? Sure, use our standard components. Oh, you need more complicated stuff? Good fucking luck to you! For example, in JSF 2.0, if you wanted to add custom HTML attributes to a component, nope! You need to make your own for that (seriously!?). Oh, what about the randomized ids that you can't manage? JSF 2.2 added all that, but it's patches over patches over patches. It's terribly frustrating having to jump through hoops to do what you could do easily in plain old javascript. JSF adds a tremendous amount of complexity to a project.
Well, JSF is all about components. I wouldn't suggest using it without a component library, most of the time it's PrimeFaces. In most cases this covers most of your use cases and lessens the pain. So if you look at plain JSF, it probably sucks. But then again you wouldn't use most languages without further libraries. I would rather see JSF as the groundwork in this case. The mentioned combination between OmniFaces and PrimeFaces is mostly all you need, atleast in my experience. 
That's simply not true. Rails is that simple for you because you have set all the plumbing up correctly and know how to do it. 
Polyglot Maven is a fantastically stupid idea. Completely missing the point of Maven.
Most popular Java framework, likely. It really depends on where you are geographically. For example, in West Michigan I see a lot of people looking for ASP, but in the Detroit area I see tons of Rails job postings. I know some parts of Texas, Django is super popular. I know this question is asked in the context of a Java sub, but....yeah.
Assuming i have some type, MyClass&lt;T&gt;... If I give the plain &lt;T&gt; as shown here I can't do anything with T in MyClass other than what Object allows. I can call Object's methods, i can work with an existing T reference -- that's it. All code that's more specific has to be in a different class that invokes that specificity using an explicit type, i.e. MyOtherClass extends MyClass&lt;String&gt;. This is not only proper, it's simply good design. I can reason about both MyClass and MyOtherClass without seeing any particular invocation. And, thanks to that reasoning, I can know my tests can cover all the behavior that my class is capable of. If reification provides any real tangible extension to what is possible with erasure it must do so by relaxing that scenario -- by allowing you to use type information that's not explicitly defined by the types present in the definition. Anything else is just an optimization. Your example here saves you a few lines of code. The reification of generics over value types will save us a few cycles of cpu and a bit of memory. I simply don't buy your premises that 1) generics somehow make your code weaker and 2) that reification is the salve to fix it all.
So why downvote him?
&gt; So by the time you get done with your "standardized" web application, it's just a cobble of third party libraries like OmniFaces, PrimeFaces, YourFaces, OurFaces, EverybodyFaces. JSF was designed to allow a marketplace of components. It's standard ''library' of components that ship with it are on purpose very basic. JSF doesn't want to compete with component vendors out there, but instead provide an environment in which components can be used. &gt; Also, show of hands, who here has run into bugs with Mojarra? Another show of hands, who has run into bugs with any framework, or even with any software tool for that matter? &gt;I'm not expecting all of my software to be perfectly bug free, but damn if Mojarra isn't broken out of the box. Any particular bug you're referring to? Any particular version? I use Mojarra out of the box daily and it runs fine. Some of the sites I've build do tens of thousands of views and they run just fine. 
The point of Maven, as I understand it, is that the POM contains only a high-level description of the project and the tools needed to build it. Actual scripting is kept to a minimum, and goes in plugins or external script files. The POM is simple, readable, and easy for tools (IDEs, report generators, dependency analyzers, etc) to understand. Maven obviously didn't fully realize this goal, but at least on paper, it seems like a really good idea. Polyglot Maven lets you define a POM in terms of a Turing-complete scripting language. There's no easy way for tools to examine it; the only way to make sense of it is to completely evaluate it in an interpreter. This completely throws out the aforementioned ideal, and reduces Maven to just another scripted build tool. Meanwhile, no one is showing any interest in fixing what's wrong with Maven's XML schema (excessive nesting, not extensible, overly verbose, etc) and execution model (plugin goals can't order themselves before/after other plugin goals, etc). And that's tragic. Maven is basically dead, and Polyglot Maven is dancing on its corpse instead of reviving it.
I don't think that a collection of components really counts as "extension", but to each their own.
Spring Boot it is as simple as clicking some checkboxes in the Spring Initializr, generating a project, opening it up and clicking Run in your IDE. It takes minutes at worst.
Oh tell me about it. Last semester I had to work on c++ and visual Studio has been the best IDE for C, C#, C++ that I've seen
Where I work we use both spring boot and newer technologies like React/redux, so I wouldn't say it's a waste of your time to learn. A lot of places are slow to change the way they deploy code, and are still very java/tomcat focused. In our case we use spring-boot as a way to deliver our React apps.
Yup. Take the time to learn Spring. Even if the job you're applying for doesn't use it, understanding the concepts translates into implementing them using other frameworks. There's literally no disadvantage to spending 10+ hours learning Spring, even if it's only running through (and understanding) the sample code. 
It's more important to understand what spring is doing if you are just starting out, like what is di and why should you care. Frameworks come and go (rip struts) but the reason they exist doesn't change. Spring is great now I use it every day, but if you use a framework you will inevitably learn the details about it. 
+1 for Geb. Had a great proof of concept set up using it and it was awesome. We switched to Protractor for some silly reason and I'm in the process of getting the hell away from Protractor. 
a) as the sidebar, the submission page, and pretty much everywhere states: &gt; Please seek help with Java programming in /r/Javahelp! b) believe it or not, this _has_ been asked before. There's thousands of threads about learning Java, FAQ and wiki pages about it. Try having a look around first before submitting yet another question about that.
Angular 2 came out 10 days ago, give it some time.
It is very popular, but the most popular? Not sure. Our customers are still very much on the JEE stack.
Celyon, Kotlin, and Scala all compile to JS. But frankly if you don't know JavaScript you're going to have a bad time anyway.
&gt; I would like to ask what exactly the difference between spring and spring boot is. Spring Boot is basically a set of preconfigured starters that help you get started quickly and easily. Instead of setting up everything yourself it has an 'opinionated' idea of what you'll need and sets it up for you. So it's not a different 'version' of spring; it's just spring + some starters. 
FYI: This sub is about &gt; News, Technical discussions, research papers and assorted things of interest related to the Java programming language For personal help there is /r/javahelp
&gt; I hate Selenium with a passion. It is, however, the best solution out there. Same here. If only it didn't just get 'stuck' randomly it would be a lot better. 
This is about learning to program in Java and thus should either be in /r/javahelp or in /r/learnjava where both have plenty good resources linked. Commonly, the most recommended resources are: + MOOC [Object Oriented Programming in Java](http://mooc.fi/english.html) + [Java for Complete Beginners](https://www.udemy.com/java-tutorial) Bot are excellent and free and teach from the ground up assuming no previous knowledge. Next time, please read the sidebar of the subreddits first and post where appropriate. Also, next time spend more effort on your posts. "Need help" is an unacceptable title as it gives no information. Learning to program in any language requires lots of effort and lots of self research. **Post removed:** looking for learning resource
We do not tolerate abusive language at all. Consider this a warning. Further misbehaving will have consequences.
This. Exactly.
It's not the best solution, but it is the best free solution.
I said spring boot is another story. 
True-ish, a collection of components themselves is not an extension in the most common understanding of that term. But... especially OmniFaces, and back then TomaHawk and A4J (later incorporated into RichFaces), the separate Facelets, and to a lesser degree PrimeFaces are not just pure component libraries. OmniFaces is the clearest example. It contains only a few components, but most things are extensions. OmniFaces hooks into JSF by wrapping things like the ViewDeclarationLanguage, ResourceHandler, ResponseWriter, RenderKit and much more. All those things are extension points that allow you to deeply integrate with JSF, augment core functionality or even completely replace it. A4J and Facelets are rather clear examples as well, and even PrimeFaces that indeed mostly contains components does provide an amount of functionality that makes use of the JSF extension points.
[removed]
[removed]
&gt; I have zero experience with it in any setting. You don't need experience. Just put enough `@Bean` everywhere and maybe `@Component` until it works.
i am curious about GWT via Vaadin -- can you expand on your warning?
Maybe the project I worked on was super bloated or poorly set-up, but I had to do a full build to update static content. Like basic CSS. It was a nightmare. And what /u/yawkat said. I don't even think Google uses it much.
&gt;you know, that you can have all that in a Gradle build, right? In Gradle, the project name (equivalent to Maven `&lt;project&gt;&lt;artifactId&gt;`) is taken from the name of *the folder the project is checked out into.* I'm sorry, but that is batshit insane. Build systems should be trying to isolate projects from the build environment, not add even more environmental unpredictability! I Googled for a solution, and learned that bizarre hacks in a *separate configuration file* are needed to remove this bit of insanity and set the project name to something constant. The group and version, on the other hand, are set in the main build file. WTF?! I don't even *want* to know what else is horribly wrong with that thing. Gradle has good ideas, but atrociously bad execution. &gt;But you seem to have thought fairly long and hard on the shortcomings of Maven and still seem to prefer it to alternatives. Yes, in that Maven is the least bad of a number of bad options. I'm thinking of giving SBT another look, but I'm not hopeful… &gt;adding namespaced attributes and elements to Maven POM, while certainly doable and sensible approach in an XML formatted document, would make Maven Poms even less readable for mere humans than it currently is. How? `javac:sourceDirectory` doesn't seem any less readable than `sourceDirectory`. More so, I'd say, since the namespace makes it clearer what kind of sources can be found in it. If the concern is the namespace names themselves, we could adopt a convention where Maven plugins' namespaces are named after the group/artifact identifiers of the plugin. Example: `xmlns:javac="maven-plugin:org.apache.maven.plugins:maven-compiler-plugin"` (namespace declaration for `maven-compiler-plugin`) &gt;XML Namespaces are an elegant solution to a problem that maven Pom files should not have. Maven POM files (in any language) already have that problem. Different plugins have different settings that may or may not have the same names. Again, `sourceDirectory` is a common example—lots of different plugins have their own idea of what a “source directory” is. The current solution to this problem in the POM (again, in any language) is to stuff almost everything into `&lt;project&gt;&lt;properties&gt;` and `&lt;project&gt;&lt;build&gt;&lt;plugins&gt;&lt;plugin&gt;&lt;configuration&gt;`, and pray that it all works like you expect instead of falling apart in some obscure way. In my experience, those prayers often go unanswered. Namespaces (and proper validation) would be a massive improvement. And you won't get that from YAML, at least not without inventing YAML namespaces, because this is fundamentally a namespace problem. Trying to avoid it will only result in more pain.
Eh. It does not seem to me that there's much for either me or you to gain from continuing this discussion. You seem to be absolutely bent on the idea that XML is the only sensible maven Pom declaration language and nothing I have to say is likely to dissuade you. About XML namespaces - they are in many ways like aspect oriented programming - great idea in theory but in practice there aren't just any real good examples out there in the wild where their use has not come with a host of drawbacks. 
I'm not even sure what you're asking. Can you please clarify? How do XY coordinates relate to the alphabet? Are you asking how tall and wide each character of the alphabetc should be? If so, that depends on the font and which alphabet you're using. 
Apache POI suit your needs? I've used it a couple times and I recall its easy to use. Don't know about tracking changes though.
It's just XML, so all you need is the standard libraries. Am I missing something?
Tests in web project, page objects, selenium, cucumber JVM, BDD. Works a treat!
No worries.
DI = Dependency Injection, correct?
How well does Jetty supports JASPIC?
&gt; Don't use that either :P JSF is being improved constantly, and it has a lifespan of more than 12 years already.
&gt; MVC has been dropped in JavaEE 8, mainly in favor of configuration and Health Check. https://youtu.be/Th9faGLhQoM?t=23m11s
I'd wager 99% of orgs using Spring are using MVC. They're not technically the same thing, but effectively they are.
.......give it a year, and we'll have the headline: "Migrating 25k lines of Gradle to ${futureBuildTool}"
Not sure about tracking changes but I've done editing with some of these tools - currently using POI. What makes it a real pain in the ass is that a single word can be spread across array elements of text and even different paragraphs depending on how the Word document was edited. So I've made routines for find and replace in small files using POI but that is the extent of what I can tell you. I also tried DocX4j and it is comparable. If I remember right DocX4j hasn't been updated in some time and relies on an iText library which has commercial licensing restrictions.
Xslt - there's a abuse of XML syntax gone awfully wrong. But that's just my pov. Namespaces are not horribly complex or confusing. My main beef with them is that they have some nasty surprises up their sleeves almost every time I've seen them used. Conceptually, they tend to bring in new dimensions of semantics, which tends to increase cognitive load of complexity of the document in exponential progression. Secondly, in theory they are supposed to work like import statements in Python but they fall horribly short in this respect as far as practice goes. More often than not, the namespace URL offers no clue about the actual schema behind the namespace. Every time I see people use namespaces, I find some novel and surprising ways they've come up to abuse and misuse the concept. I've seen people declare a namespace multiple times with slightly different prefixes, I've seen them importing same namespace in a nested scope. I've seen default namespace being imported again and again for each element individually, ... The list could go on. And where the f**k is the schema! Maybe the schema even existed at one point in time, but the domain name has long ago fallen off the edge of the known internet and nobody remembers the schema. 
Or the rock solid, stable and well thought out UI made in JSF, that js people have an urge for to rewrite, and then end up with some horrible mess that crashes all the time, gets stuck in event loops, doesn't respond when certain button are pressed, sucks up a gigabyte of memory, and eats CPU cycles like break fast... But, it's stateless and webscale and HN said this stuff is the sh*t!
Ok so you probably had a lot of problems with staleelement exceptions and adjusting wait times for Ajax calls. Selenide takes care of that. I also like the selectors and the Api of selenide more. Nowadays I integrate selenide into my cucumber bdd tests and prefer this way to my old way of your testing.
For publishing the tasks I use a thread local volatile field instead of a compare and swap operation as in the standard executor service. The algorithm used in the vmlens executor service do not need to wait for other threads also trying to publish tasks while the standard executor service needs to wait.
That's an awful lot of fanfare for a fucking group of dependencies. A completely unnecessary one, at that, since you can write those three dependencies into your project yourself. The stupid. It burns.
Will check it out. Thx 
They are just stating that they propose to drop it. Does not sound final though highly likely
Hardly, since they are using the swarm dependencies. Thus you can gain the benefits from using swarm (if that is why you are using swarm in the first place) automatically. Also since the microprofile is still an in-progress depending on the community the dependencies of a microprofile could change based on their needs. 
Check the languages as libraries paragraph at the related work. Furthermore, [Rascal](http://www.rascal-mpl.org/) has been used as the implementation for Recaf since it made really easy (and natural) to express the transformations. Finally, Java doesn't have a macros facility. BTW in our case transformations are also hygienic due to HOAS (high-order abstract syntax).
Sounds like somebody repeated a Hibernate tutorial slightly wrong.
Because there is no way to do so. Otherwise, yeah, I would.
Manager doesn't make people rewrite stuff thats "rock solid" and just because your JS code is shitty doesn't mean everyone else's is too.
What platform? From what little I was able to discern about what WildFly Swarm actually does (the buzzword bullshit is nauseatingly thick and hard to cut through), it appears that the only “platform” is Java SE itself—everything above that is bundled with the application.
The [MicroProfile](http://microprofile.io/faq).
Sorry, I'm allergic to marketroid bullshit. Could you summarize the meaningful, technical parts, please?
&gt;&gt;What platform? &gt;The MicroProfile is a baseline platform definition that optimizes Enterprise Java for a microservices architecture and delivers application portability across multiple MicroProfile runtimes. The initially planned baseline is JAX-RS + CDI + JSON-P, with the intent of community having an active role in the MicroProfile definition and roadmap. What part of that are you having a problem understanding?
&gt;The MicroProfile is a baseline platform definition that optimizes Enterprise Java for a microservices architecture and delivers application portability across multiple MicroProfile runtimes. There's that marketroid bullshit I was talking about. Achoo! &gt;The initially planned baseline is JAX-RS + CDI + JSON-P Cool. There's your *actual* set of dependencies. What do we need this “platform” for, again?
&gt;&gt;The initially planned baseline is JAX-RS + CDI + JSON-P &gt;Cool. There's your actual set of dependencies. What do we need this “platform” for, again? The part you chose not to quote gives a hint: &gt;, with the intent of community having an active role in the MicroProfile definition and roadmap. It's also addressed in the link from OP: &gt;For the first release what is present was deliberately kept small. Going beyond 1.0 the community will provide valuable ideas and feedback on both the types of technology that should be included within the MicroProfile, as well as concepts, such as Service Discovery, that should be addressed.
&gt;application portability across multiple MicroProfile runtimes 
I don't understand what you're trying to say... In general, portability allows you to avoid having to rewrite your application in order to take advantage of a runtime that fits your needs better than whatever you're running on currently.
Should support it, but hassle to get going. This bit disadvantage of Jetty.
You know one now! I like JSF, it's very good and doesn't change underneath you every week, no?
The only thing you're “running on” is Java SE. Everything else is a bundled library that you can replace as you please, not a platform that you have to conform to. This “profile” is trying to solve a problem that doesn't exist.
The concept is more than starters I think. I see it as more along the lines as Spark Java. A standalone server, something that listens on its own port and has its own JVM lifecycle as opposed to WARs deployed in the same Tomcat instance. That makes it a lot easier to do things like A/B testing using Apache or nginx reverse proxy maps for one example. 
Ah yeah, on a closer read over the issue it seems like this isn't GUI related 
I'd plan for about a year. Get a domain registered somewhere, get a VPS like Linode or Digital Ocean and then get Eclipse. (Or if you want to spend the dough get IntelliJ Ultmate - skip the Community Edition for web work.). Alternatively, get STS (SpringSource Tool Suite), I prefer Eclispe JEE build and then add the STS plugin (version 3.8 is the latest.) Then do each of the following: 1) Using STS (either standalone or in Eclipse) and run the new project wizard that lets you select Spring components like Data, Security, etc. Set up Tomcat and deploy your new WAR to it. Get it working with at least an in memory database like HSQLDB or H2). 2) New project to see what Spring Boot is about, go to http://projects.spring.io/spring-boot/. Alternatively, for Spring Boot starters, you could go here: https://start.spring.io/ PS There's the "old" Spring way, configure beans in XML files, sometimes hundreds of them. There's the "new" way which uses Annotations. There's a newer way apparently for the reactive/FP crowd which only someone totally into FP could love. It would not hurt you to start the old way and do the configs since there's so much of that code around. I avoided Spring as long as I possibly could. The DI pattern is just backwards to me but if I can make a game in assembly on an 8088 I can program anything and I like Java enough to have gotten into Spring, enough to do damage at least. Good luck. 
Didn't Java make the world a better place by not having pre-processing to redefine language elements? Kinda one of the keys to Java's success. 
You definitely don't want to modify the XML directly. OOXML is a horrible format that is only made worse by its documentation. The actual specification document is over 5000 pages, and that's only the first part of five. It's almost like Microsoft made an 'open' format so insane that nobody would even try to fully reimplement it. As for the OP, Java is not the right language for this. Office automation with .NET is really the only way to proceed.
You don't need .NET and there is nothing wrong with Java. XML is XML and OOXML isn't really that complex. You don't need the spec let alone 5000 pages of it. I just think it's sad that a lot of developers seem to be stymied when they can't find some library or tool to "help them do it" rather than rolling up their sleeves and getting to work. I have done it many times before (once on a project **at** Microsoft in an internal site that generated reports to be reviewed by Ballmer himself). It seriously isn't that hard. 
Agreed. Its a fun idea, but can you imagine trying to maintain some guru's completely macrofied and customized version of java? Terrifying. 
What's with all the 路
Page is being treated as a "Simplified Chinese" encoding instead of UTF-8. The `·` and the surrounding bytes are being recognized as some Chinese character. You can test this by forcing the page to "Simplified Chinese" from browser menu. 
Clickbait title. This isn't about ordering. The blog is about "can you be pragmatic". The obvious answer is: yes. There are very very few situations where the time 'saved' by having unit tests fail because the one they depend on fails is of any significance. And if time is so significant you probably just want to run your tests in parallel. In the case of integration tests the time saved can be substantial. In our case we often bundle our Cassandra integration tests together because starting and destroying a Cassandra instance for every test takes too long. In situations like these not following the "one assertion per test" rule is IMHO perfectly fine. 
I'll start with the inherent fragility of "web tests". Selenium is fragile... not in the "it breaks all the time" way, but in the "it breaks randomly" sort of way. Sometimes you can "fix" your tests around Selenium, but sometimes it's just not possible. I've found the solution is to care less about web tests and use those for broader based regression tests instead of testing my full application with them (instead opting for more focused integration tests on top of a full suite of unit tests). I don't blame selenium at all. It's hard to do what it's doing, but it leaves me hating it all the same so I try to stay away (which is, not really possible because it's the best at what it does at present)
In my past 3 jobs (12 years or so), we've all used Spring - none used MVC until very recently when my most current job added MVC to do the latest version of the api. So, your 99% is probably off by a bit. Everyone is biased to their own experiences though.
Just out of curiosity, what's the paid alternative that's better?
This is going to sound weird, but Spring boot is a framework for the various Spring frameworks (and other frameworks.) meta... edit: meant to reply to the parent to this post, whoops... 
[Why not start at the beginning?](https://docs.oracle.com/javase/tutorial/java/) Also, did you not notice the multiple links to /r/javahelp?
Ummmm - It was supposed to be EL. http://docs.oracle.com/javaee/6/tutorial/doc/bnaim.html 
I am one of the main authors of Bootique. Yeah, Bootique is brand new, though we run it in production all over the place. HTTPS support is included in the upcoming 0.20 train release per [this task](https://github.com/bootique/bootique-jetty/issues/42). Snapshot builds of 0.20 are available from [here](http://maven.objectstyle.org/nexus/content/repositories/bootique-snapshots/). So give it a try :)
Are application server vendors even going to be applicable anymore? If the EE spec allows you to compile down to a Docker container instead of an EAR or WAR then why would anyone care about what's inside the container? By definition the container's contents should be completely transparent.
The most mature one of these is entirely written in Scala and they're not production ready
He was implying the JS community switches tools every few years, not that your comment was using JS syntax.
So is this basically the spring boot for wildfly swarm components? Also JSON-P really needs to be called something different. JSONP already stands for something entirely different and it's confusing.
I just found PDFs of the slides on the Oracle site where we scheduled our sessions. Expand the "triangle arrow" next to each session in the Session Catalog, and you'll find a "Download Presentation" link below the session description.
Actually it's not about Java or a specific programming language. They think your brain is no longer "wired" in developer mode. You will not be as productive as someone in it every day. But if they rate people on SLOC, you don't want to be here anyway.
Let me know what you think. This is from the [github](https://github.com/dessalines/flowchat): [FlowChat](http://flow-chat.com) is an open-source, self-hostable, **live-updating** discussion platform, featuring communities, discussions with threaded conversations, and voting. It can act as an alternative to forums, as a private team communication platform(like slack), a content creation platform(like reddit), or a voting/polling platform like [referendum](https://referendum.ml). Flowchat tries to solve the problem of having a fluid, free-feeling group chat, while allowing for side conversations so that every comment isn't at the top level. Multiple conversations can take place **at once**, without interrupting the flow of the chatroom. It uses [range voting](http://rangevoting.org/UniqBest.html)(also known as olympic score voting) for sorting comments, discussions, and communities. Range voting is *more expressive* than simple :thumbsup: or :thumbsdown: votes. Check out the default community, [vanilla](http://flow-chat.com/#/community/1), or create your own. It features: - A complete discussion platform with communities, and live-updating threaded discussions. - Private or public discussions and communities - Customizable sorting, by recentness, and popularity. - Hashtags for discussions and communities. - Discussion/Community creators can block users, appoint moderators, or delete comments. Tech used: - [Java Spark](https://github.com/perwendel/spark), [Bootstrap v4](https://github.com/twbs/bootstrap), [Angular2](https://github.com/angular/angular), [Angular-cli](https://github.com/angular/angular-cli), [ng2-bootstrap](http://valor-software.com/ng2-bootstrap/), [ActiveJDBC](http://javalite.io/activejdbc), [Liquibase](http://www.liquibase.org/), [Postgres](https://www.postgresql.org/), [Markdown-it](https://github.com/markdown-it/markdown-it), [angular2-toaster](https://github.com/Stabzs/Angular2-Toaster) Check out a sample discussion [here](http://flow-chat.com/#/discussion/13). Join the subreddit: [/r/flowchat](https://www.reddit.com/r/flowchat/)
SLOC? I stay "wired," too bad my resume doesn't reflect that. Not even sure how I would put that on there without looking like complete nonsense.
Updates are still handled the normal way at the database (via transactions or just sequentially). These APIs are about not blocking the underlying network connection to the database while they're processing the request - giving room to other requests.
Hello World is absolutely useless, anybody can write hello world applications as there are hundreds of tutorials for every language. Find something worth working on and build it. It could be an open source project that needs contribution, or it could be something you need in your daily life. I would recommend a multi-tiered application that solves some level of complexity for some problem.
The fact that it's not in Java SE makes it a bit of a pain, and enabling working TLS 1.2 support is cumbersome, particularly if the server's certificate doesn't happen to be signed by a CA that's included in your specific JVM's bundled list.
Alright, so no performance gains ?
He won't be able to prove that because in the OP title it states he hasnt been. I know you're just being brunt about it to them, though. They should take the advice and start coding side projects that simulate his potential to code/apply themselves. 
SmartBear TestComplete HPE Unified Functional Testing Both tools are aimed at testers rather than developers. They separate the object identification away from the tests themselves. They work on more than just web applications, and can used for almost any application. They operate outside the browser context, not within it.
I don't see how those aren't problems that can't be papered over with a wrapper API.
queues*
Any benefits over [Apache Commons Email](https://commons.apache.org/proper/commons-email/) ?
If there's an easy way to add a TLS cert at runtime, I've yet to discover it.
Those recruiters are idiots.
This looks really interesting! I like the tech stack too.
Might have to take this for a spin at work... Really cool!! 
You can only send emails with that one.
This is not the sub you are looking for. Try /r/learnjavascript or /r/javascript 
You need to serve the page from a web server most likely. If you're doing it locally and from a CDN it may cause issues
Not to nitpick, but this should be in https://www.reddit.com/r/Javahelp FWIW, it would be more helpful if you provided your current attempt so that users could correct its problems.
thank you, I will take that in mind!
Pretty cool, I'd like to see a floating chat textbox so you can always be ready to post
Free ebooks and instant spam for *codequs* - this is not acceptable.
I think it's better to look on something like [RxJava](https://github.com/ReactiveX/RxJava) instead. And I don't think that embedding a queue actually gains you any _avaialbility_. Imho.
Would you hire you? It's a bit of a risk if you haven't done anything for a year. What have you been doing? I had about three months off once, forgot a lot and got out of practice.
CompletionStage, if possible.
Also could be titled "Never write code like this". ☺ (though yes it is an interesting brainteaser and cool to know)
(true)
Aaaw, recruiters confusing Java and JavaScript again, eh?
As a first step try reading the sidebar, and post this to /r/javahelp instead. When you do, include the code you've got at the moment, and where you think it's going wrong. Don't expect anyone to do your work for you, or that anyone is a mind reader.
No, this code is different. The code in the post didn't include a return in the finally block. If you include a return in a finally, other returned values are discarded.
This is clearly *programming help* and thus should be posted in **/r/javahelp** as the many hints on the page indicate. Your post is in no way suitable for here or there because: + Unclear title - it is obvious that you need help, but you should specify in the title already what problem you face + Nothing to work with; no code. We cannot help without code. + You don't show [**what you have tried**](http://whathaveyoutried.com) - no effort, no help. Please, before posting there **read** and **follow** the [**Posting Guidelines**](https://redd.it/48eykt) so that you can write a *proper* post. **Post removed:** programming help
the survey considers JavaScript and NodeJS as two different things... if taken together, it looks like Java is number 2...
why should I use Selenium for API testing through a browser instead of doing direct HTTP calls with frameworks like REST-Assured???
This is really cool. Great work and thanks for sharing.
Nice app. First thing what I noticed is image magnification over mouse over event. It would be better if you can see image in another div which is over that title, instead of whole image maximization (and screwing with the rest of site). Something like this [this](http://www.dreamweaverclub.com/dreamweaver-show-larger-image.php). It shows image but it's not resizing rest of the page.
Yes, that leaks the DNS. I checked with a sniffer
That's an easy question if you have the OCA certification. 
The return statement in the finally clause has priority over the return statement in the try clause. Basically, the return in try is ignored if there's a return in finally
Love vJUG! High quality content by amazing people.
I think the more people get this wrong, the better. Because if you see that code, You should say "my god what is this" and then rewrite it. 
If you're talking about Atmel AVR based microcontroller boards (which I believe includes the Arduino), here's a neat document from Atmel: http://www.atmel.com/images/doc32049.pdf There's also NanoJVM which runs on the Atmel AVR Atmega8. I can understand why C is the dominate language for the Atmel products. Not only is C used everywhere, but back when I started embedded programming with Atmel processors back in 2004 the dominate controller board was the Netburner and it had a custom C language (A preprocessor bundled with the SDK) that made life easier.
http://haiku-vm.sourceforge.net
Nopes. I'm thinking of building of my own implementation and learn on the fly. :) Till then I will try out Unirest.
[Apache Net](https://commons.apache.org/proper/commons-net/) has some *basic* IMAP/SMTP implementations. 
you're right, 3 hours delay, omg
Or something like TypeScript.
I guess they used square checkboxes.
You can use AsyncHttpClient's 2.1.0 alpha client, which is built on Netty 4.1: https://mvnrepository.com/artifact/org.asynchttpclient/async-http-client/2.1.0-alpha1 You will probably want to check to see if you're using Netty's async DNS resolver though. 
https://www.typescriptlang.org "Types are optional". It was looking good up to that point. 
Water found to be wet. Java as a language is not going to evolve anymore. Time to fork everything.
Look, if you feel it's really a problem for the recruiter, just make up an excuse and act like it's not a big deal. Where I am at least there are nowhere near as many Java programmers as there is demand for them, and the only way to shoot yourself in the foot is to make it sound like you think it's a big horrible deal as well. 
https://www.braintreepayments.com/blog/switching-datacenters/
&gt; var myMap = getThatMap() This is where it gets annoying though, what value is the var there? I could be anything and you can't tell by looking at the code. Map, HashMap, LinkedHashMap, Collection, ArrayList, String, Integer, MyCustomObject5, etc...anything. I like var for reducing duplicating info, but it looks like it will introduce new annoyances in not being able to look at the code and know the type in some cases. 
I guess that's why it's only for local variables.
Seriously? Making things *mutable* is what causes issues. There's a reason everyone opts for immutability. I should be able to hold it in my head that the value of this variable is *always* what it was initialized to. Maintain mutability in builders and other intermediary structures. There's a reason new languages are pushing for immutability. It's less error-prone.
You must be the guy on my previous team that makes coding a nightmare for everyone who comes after him. "So part of our code is in Java, part of it in in Kotlin, sometimes we use Groovy, we have some jsp, but also we use angular!". IDE's made compiling extremely efficient by compiling everything in the background, now I had to use Maven and wait 5 minutes for a compile (it was a large project) at least 25 times a day. And that's if the compiled worked. When I do interviews now, I specifically ask to see them create a new page in their app, so I can avoid apps that have framework/language of the month explosion. It's a nightmare.
They adress this example in the article as well, basically repeating what you said with a bit of clarification: &gt; One thing to note is that **the return value of the finally block will be the one returned** to the caller of the method **if there is a return statement in the finally block as well**. This is because the specification says that the return in try will be ignored and the return in finally will the one returned if both try and finally have return statement.
Build something that showcases the skills/technologies the job(s) you're applying for care about. If it says Spring all over the place then build a Spring Boot application showing you know how to use DI, MVC, etc. if that's what they're looking for.
Manager doesn't ask for it, until youngsters convince manager current code is a risk and must be rewritten. 
He asks for it when there are constant bugs and customer complaints in the shitty code.
Try kotlin :)
Better prepare, do not repair.
**Potential Pitfall!** Any exceptions thrown in the *try* clause will be overlooked, and likely dismissed. Thus errors can be hidden away from view for days or even longer.
hmmm wasn't working for me on Android Chrome.
I use mariadb for all our servers at work. Thousands of queries/sec on one e5 box needs it.
~~No it doesn't, it complains that `i` is not effectively final.~~
Holy shit stack overflow really is dead. Students are turning to reddit to get people to do their homework for them.
[Yet another insignificant Programming notes](https://www.ntu.edu.sg/home/ehchua/programming/index.html) - A bunch of notes on programming and various other things. Has a very good java tutorial. [Data Structures and Algorithms with Object-Oriented Design Patterns in Java ](http://www.brpreiss.com/books/opus5/html/page9.html) - Title says it all [java programming wikibook](https://en.wikibooks.org/wiki/Java_Programming) - Surprisingly very good. Overall, all 3 are very good, you can pick based on your needs.
This post is for help with Java programming (or learning to) and thus should either be in /r/javahelp or in /r/learnjava of which both have links to resources. Commonly, the most recommended resources are: + MOOC [Object Oriented Programming in Java](http://mooc.fi/english.html) + [Java for Complete Beginners](https://www.udemy.com/java-tutorial) Bot are excellent and free and teach from the ground up assuming no previous knowledge. Next time, please read the sidebar of the subreddits first and post where appropriate. **Post removed:** learning help.
Can do you both? In my opinion, you should just write the services normally. Then auto-generate both RAML and Swagger metadata from that. 
In theory RAML can too, but I've been very disappointed with the .NET libraries. Haven't tried Java yet.
Yes, we can do that as well. I am not sure what's easier, docs-&gt;code or code-&gt;docs. I don't have many REST APIs under my belt. I guess once we start implementing the APIs, it's gonna be harder and harder to use code generation anyway.
The irony! One of the most successful articles (2.7k shares) on Topal blog is about [Hibernate Multitenancy](https://www.toptal.com/hibernate/build-multitenant-java-hibernate).
Please consider flexible REST APIs based on stuff like GraphQL/Falcor/OData - will reduce the amount of up-front thinking you need to do if an external supplier is building this.
Let's fork the OpenJDK, how hard can it be! /s
That last one is definitely different with the more recent changes, especially around the Pipeline DSL. 
I haven't used it myself, but RAML has the [RAML for JAX-RS](https://github.com/mulesoft/raml-for-jax-rs) project that does auto-generating of JAX-RS code.
Worth looking into https://speca.io it's a great tool for rest API Design and allows you to export the specs in many format
Uh yep, sorry! Viewing on mobile messed with the indentation and I got confused.
Bava
Too late is too late and don't pretend you don't know that.
I hope they will introduce samba's with hot Brazilian chicks.
The parameter marker stuff is the most contentious part of the proposal. Everybody who has looked at this API has their own idea of how parameters should be indicated. I just picked one proposal to use in the JavaOne talk. So don't worry about this even a little bit. That said &lt;&lt;column_name&gt;&gt; is syntactic sugar for column_name &lt;&lt;o column_name&gt;&gt; It's an abbreviation for a very common pattern. It would be incredibly common to want to select a column and to access that column value. You would select the column by mentioning its name in the select clause select foo ... then you would indicate that this is an out parameter by putting an out parameter marker after it. select foo &lt;&lt;o foo&gt;&gt; ... Instead of requiring all those characters you can just write the syntactic sugar which expands to exactly the above. select &lt;&lt;foo&gt;&gt; ... Does that help?
What about high volumes of concurrent requests to large numbers of databases, eg sharded databases for example? We have lots of examples of good apps getting hung up with large numbers of idle/blocked threads. Reducing the number of threads will definitely increase the throughput on those apps. One the other hand this is not a replacement for the existing JDBC API. It is targeted at a very specific kind of use case. There would be no justification for migrating the vast majority of existing apps to the non-blocking API or of writing many/most new apps in the non-blocking API. If your app won't benefit then by all means use the existing API. We don't foresee it being obsoleted, deprecated, discouraged or anything like that for a long time if ever.
No.
/s
Eclipse Omega: Now based on IntelliJ Community Edition ;)
The most popular programming language is old news? Damn...
&gt; And the Graal compiler (which is giving us this AOT here) has not even started to yield what is what supposed to bring in the beginning. What what was Graal supposed to bring in the beginning?
&gt; Substring code completion It's better than sex.
&gt; I'm confused. Didn't we get this a while ago? I don't use Eclipse daily but I thought Mars had substring completion. Are you sure? There's **keyword** completion available in Mars.
&gt;The aim of this project is to expose VM functionality via Java APIs. Namely, we want to make it feasible to write in Java a dynamic compiler and interpreter for a language runtime. These components will seamlessly integrate and leverage existing VM infrastructure (e.g., HotSpot). &gt;The design of the dynamic compiler uses features of Java that make it highly extensible such that adding extra IR nodes and/or transformations is straightforward. At the same time, it should produce excellent code quality without compromising compile time and memory usage by the JVM. &gt;Building on the compiler, we aim to develop a multi-language interpreter framework. Java will be just one member in the family of supported languages. The use of partial evaluation will allow the framework to deliver competitive performance.
GUI builder?
Don't cross the streams!
They didn't have word wrap until now?!
IntelliJ will be a plugin.
Would like to see CDI (Weld) compared to Spring. Also nice to find out Spring has decent performance injecting singleton beans (which is what you do 90% of the time)
Unfortunately the first document is not very comprehensive and the other two were written without swagger 2 in mind.
I think it was available but not turned on by default.
I don't know why this made laugh. 
Since Dec 2000, certified Java Compatible in 2005.
I work for Excelsior, feel free to ask questions (but bear in mind we are in GMT+7).
🎊 Woot! Another victory, before another battle begun! I'd prefer to not have to see another trial, the last one has me on the edge of my seat, and that's not a good thing.
The worst thing happened to JAVA world is when oracle bought SUN, dam it if just IBM or Google bought SUN first. 
That's the one. Thanks.
I thought oracle **did** win on copyright grounds. This article says they didn't.
These lawsuits have been bad enough that I have stopped choosing jvm languages for personal projects and stopped choosing or suggesting java at work. I don't trust Oracle to maintain the platform, I don't trust them to not prevent other implementations of java, and I don't trust them to not find new ways to sue companies that use the language. 
For the latest trail google won: http://fortune.com/2016/06/08/google-oracle-alsup/ I think google appealed the last decision and won the appeal
As long as it doesn't ~~touch~~ affect end-developer I don't really care, it's their business
Oracle won on “APIs are copyrightable,” but a jury found that Google’s use of the Java API was fair use.
You can create a `ArrayList&lt;E&gt;` for value-type `E`. So `ArrayList` is no longer generic, it is reified for different `E`.
Value types are coming, but only in JDK 10, and even JDK 9 is postponed now. We need to wait at least two years. That's a long time. There's a chance that these feature won't be needed at that time: maybe Rust will become stable and popular, maybe .net on Linux will be usable. Multiple heaps per process are not even planned.
Is AOT worth it for Enterprise applications where startup time isn't really an issue? I guess what I'm saying is JIT'ing would probably produce better code than AOT for long running processes due to being able to profile and analyse hotspots.
&gt;The administration of President Barack Obama had in its opinion sided with Oracle and said that the APIs can be copyrighted like other computer code. Thanks, Obama. Asshole.
Moronic and childish infrastructure guy pretending he's a programmer now that he's learned JavaScript and wasn't smart enough to figure out /r/java is different than /r/javascript
Wait till JDK 9 comes out with jigsaw... Java will just define APIs and the implementation may contain DRM. in other words, to get certain things to work correctly (for eg encryption) we may have to pay for a specific implementation of the API. Like it or not, it is true that Oracle is working towards locking down Java for exploiting it. Oracle has no interest in maintaining Java as an open source standard.
what am i doing wrong here? Exception in thread "main" java.util.IllegalFormatConversionException: f != java.lang.Integer at java.util.Formatter$FormatSpecifier.failConversion(Formatter.java:4045) at java.util.Formatter$FormatSpecifier.printFloat(Formatter.java:2761) at java.util.Formatter$FormatSpecifier.print(Formatter.java:2708) at java.util.Formatter.format(Formatter.java:2488) at java.io.PrintStream.format(PrintStream.java:970) at java.io.PrintStream.printf(PrintStream.java:871) at incometax.IncomeTax.main(IncomeTax.java:31)
/r/javahelp
Since this is help with **Java programming** it should be posted (as so many hints on the site indicate) in **/r/javahelp**. Please, **read** and **follow** the [**Posting Guidelines**](https://redd.it/48eykt) there before posting. You need to explain your problem much more detailed and include relevant code - more than you posted. **Post removed:** Programming help
Interesting - I didn't know you could use profile guided AOT. How do you collect the profile information and pass it into the compiler? 
Ahh, I only use Eclipse for CDT. I guess they though embedded developers enjoy trying to figure out why their changes aren't showing up when they compile. 
Copyrighting facts is totally okay now
Google could have paid Sun in first place.... https://www.cnet.com/news/java-creator-james-gosling-google-totally-slimed-sun/
&gt; People seem to misunderstand that Oracle actually sued Google because Google purposefully made Android incompatible with standard Java. This is what makes me side with Oracle. Now we have Java™ and Android Java, and when Java 9 and 10 get released, it will be even more fun writing portable Java code that works across both platforms.
it seems as if you're presuming the scope of impact would be limited to java.
[deleted] ^^^^^^^^^^^^^^^^0.5845 &gt; [What is this?](https://pastebin.com/64GuVi2F/05667)
I LIKED it 
Deriving the language is one thing, lifting the extensive library API and making it incompatible is another. Microsoft made an implementation of Java and iirc then deliberately never developed it in an attempt to kill it in infancy. Not a good thing you'll agree. Especially as it worked on the client, just as they hoped. Creative work must be protected for at least a short while to encourage innovation in the first place.
You don't understand Oracle's business model then. their enterprise suite is all Java software. it's in their best interest to have as many Java developers as possible.
this is incorrect, Android already supports features of Java 8 and Java 9 is bringing more modularity. it should be the opposite edit : people downvoting don't know what you're talking about. https://developer.android.com/guide/platform/j8-jack.html
this is fud , source? because it's modular that should make using alternatives easier
What is the learning curve on JavaFX, I am very tempted to do the project in C# as it would be fairly simple but I really want the Java Practice. I don't want to spend a bunch of time learning a Java UI I probably won't need anytime soon.
Yea thats what I thought I just really wanted the practice in Java.
I don't think Google's entirely the "Good Guy" in here. Both of them are evil.
What on earth are you talking about?
What's a good alternative language to learn if java is all I know?
Wish Red hat had the money to buy sun. Maybe C# can be a first class citizen on Linux servers in the future. 
IBM would have fired everybody and replaced them with Indians.
&gt; Google never called it Java nor was there any Java on Android. Alright. It's just that the language syntax was identical to the Java programming language, the source files ended with the extension '.java', and I'm pretty sure you're wrong because [they clearly use the word Java on their developer site](https://developer.android.com/studio/write/index.html). &gt; Oracle originally sued because of the IP used in Android's VM and lost. They then sued because of the SSO of 37 Java API packages. I don't know the specifics about the lawsuit but I have it from the blog of an IP lawyer that Google is not quite the good guy. I don't agree with what Oracle is doing, but I'm very sure they're not actively going after their own customers.
As /u/AcePhoenixWebster says, you're not the first to ask this by a long shot, use the search bar. It all comes down to personal preference &amp; what work is being done - typically IntelliJ idea comes out on top, but the other big two still get mentioned. Try them all, figure out which one you like the most, and realise it really doesn't matter which one some other people you'll most likely never meet prefer.
The open source version was deliberately not copied as it would mean that Android would also have to follow the GPL, which it doesn't. The second answer here is a better explanation from a legal point of view: http://opensource.stackexchange.com/questions/1421/how-is-oracle-suing-google-for-copyright-infringement-when-java-is-open-source
They don't call it Java so they don't have to. Nor do they use any of the Java trademarks. As for your link, that guy isn't a lawyer. He's a paid Oracle shill. http://www.theverge.com/2012/8/17/3250148/oracle-tells-court-patent-blogger-florian-mueller-is-a-consultant http://www.dailytech.com/Top+AntiAndroid+Blogger+Florian+Mueller+is+Being+Paid+by+Oracle/article24633.htm http://fortune.com/2013/12/25/florian-mueller-hypocrisy-thy-name-is-google/
They just started the switch to open jdk, eventually it will support everything. http://arstechnica.com/tech-policy/2016/01/android-n-switches-to-openjdk-google-tells-oracle-it-is-protected-by-the-gpl/ 
No they won't. Have you bothered to attend Google IO 2016 fireside with the Android team, or watch it online afterwards? They specifically asked the audience which features would be most critical to be added.
No it doesn't, Google is cherry picking the classes from there and in some cases the methods have empty implementations. People should bother to read Android's source code and attend Google IO (or watch the sessions) instead of spreading half-truths.