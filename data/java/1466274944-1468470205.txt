Needs example code. Can't understand the description. 
for example public class square { public double squareSurfaceArea() { double surfaceArea = sqHeight * sqWidth; surfaceArea = (getHeight() * getWidth()); return area; } } and i want to get the area that is stored there and return it in a different class like this: public class squarestats extends square { public double getSurfaceArea() { (so i want to know how by calling this i can grab the answer from square for the surface area and store it here.) } }
Start with researching what language Hyperlapse uses, and which appropriate subreddit to post questions to.
I triggered :/
you guys I'm so annoyed right now...
No snark here: what exactly are the _Java EE Guardians_ doing? I browsed the Google Group, and it looks like not a lot more than people signing a petition. Is this just a petition, or is it going to become an io.js type thing?
Spring fixed their xml config mess with Java config classes. Symfony is just a clusterfuck of yaml all over the place.
ANT: because that what we were using 15 years ago and we fear change.
That's how I read it too.
Judging from StackOverflow activity, Google Trends, and pure anecdotal evidence... I would say that Spring surpassed Java EE years ago, and the gap has widened with each passing year. I don't mean that to be a flamewar about which is "better", just a statement of fact about adoption. Now, you can argue that "portions" of the Java EE spec (e.s. servlets) show up in Spring and other alternative frameworks. But even that point grows weaker by the year. Modern Spring Boot apps are moving away from Tomcat or Jetty, and toward non-servlet options like Netty and Undertow. JSP's have been de facto deprecated for ages. Message queue systems are moving away from JMS, toward AMQP or ad hoc API's (e.g. Apache Kafka). Etc. There are hundreds of millions of lines of legacy code out there, which certainly aren't going away anytime soon. However, the case for building new applications on a Java EE stack, even in large conservative environments, is steadily declining. I'm not convinced that's even a problem. 
There's three-ish main frameworks worth learning: JavaEE, Spring and bringing up the rear, Play. As for transitioning into Java, I'd suggest that you find yourself an Open Source project and start contributing to it. This will be helpful for two reasons. Firstly, it'll help you learn Spring, and secondly it'll provide potential employers with evidence of your Java experience. 
Apache Struts is a popular framework for java web development Source: first year CS student
Watch spring-boot videos. Wow, 7 years on PHP (sorry), you've got a lot to catch up on.
Is Spring not written on top of and reliant upon JEE?
Don't do this unless it covers Java 8.
It depends on what companies you want to work for and what skills you want to emphasize. If you are looking to be a full-stack person, then spring boot or play are probably your best bet. If you want to be a first class backend engineer I'd throw jersey into the mix as well. These days, I'd be more concerned with growing your distributed systems and data store knowledge over learning a specific framework.
Once upon a time I would have agreed with you on the open source advice, but if he already has experience in the industry I'd say just go head first into learning the different frameworks and libraries
Agreed that some experience is better than none. I'd be more inclined to interview someone that maybe did side projects in Java and had a command of the language through that. My only concern with the open source stuff is that he might spend more time dealing with the overhead of contributing to a project rather than actually learning libraries and idioms. I don't necessarily disagree with you, but personally, I'd opt for a personal project to showcase.
is it? There are still a lot of legacy systems using Apache Struts out there, but it looks like a dying technology... ie not something for a new project. Learning it can be still useful, but would be more effective to learn more popular frameworks like Spring (and partially JEE) btw, I saw you got quite a few downvotes with no explanation... :( I guess the others thought something similar to what I wrote...
remember that $ is a valid character for variables in java, so just write String before your variables and continue as before. Like this: String $var = "foo"; 
They've been working as a Java EE evangelists for far too long and it's been an easy money for them. Now Oracle start to strip these luxuries from them.
The dead of JavaEE is just a blip in a Java Universe. Far too many alternative out there and most of them are just as good, production ready, and supported commercially.
Looks promising...its Ubuntu !!! 
The fact that *that* is what annoys you about this is the real joke here.
It's fun watching languages adopt broken half-implementations of functional programming concepts.
I'd argue that it's not just knowledge of the language, but also of the tools around the language, and they all have their own idiosyncrasies. A PHP developer would know Composer and Laravel and other tools, while a Java developer would know Spring, Hibernate, Maven, Guava, and tens of other libraries. Yes a good developer can move from one to another. But, as I said, if offered two otherwise identical candidates with one having a demonstrated experience of those tools, frameworks and libraries and one without any evidence, which one are they going to pick. Don't give yourself a disadvantage. Demonstrate you know the ecosystem.
Spring is a huge portfolio, and plays nice with pretty much anything. However, you don't *need* Java EE components in a Spring project, and I'm seeing fewer and fewer components used in Spring projects with each passing year.
It's developers who already knows java that wants to learn python :-)
I'll respond to this as well. As a 1st yr student, you may not be as familiar with technologies that are used in the real world. Struts really is an older technology that is dying out. This is coming from someone who took a Struts course and was ready to convert my group into using it! I failed miserably because using the JavaEE stack of JSF/EJB/CDI/JPA just made more sense.
I do not know Python (hate the indentation rules, since coming from C I prefer to use my own style which works well for me) so any scripts I write that execute on the shell are written in POSIX shell. For more complex programs, I just write small Java programs.
This is actually true though.
http://i2.kym-cdn.com/photos/images/newsfeed/000/992/401/e37.png
You would likely be better of asking in a Javascript (/r/javascript) or general technical support sub-reddit. Your question has nothing to do with Java. Note that the file extension of a file does not specify its contents, if you are opening a binary file then use the correct program for the input data or use a hex editor. 
Could this have something to do with a wave of students doing research for college? I've found myself googling Python a lot lately since it's a new language for me and the one we're learning in class.
As the others pointed out, this is the wrong subreddit. Try /r/javascript or /r/learnprogramming. Also, when posting there, include more information, best even the `.json` file (hosted on a binary hoster like dropbox - not on a sourcecode hoster like github) **Post removed:** wrong subreddit
I prefer Java even for my own small programs. A little basic Bash coupled with a short Java program goes a long way.
&gt; I prefer Python over shell scripts unless it's something ridiculously simple. Python is a lot less cryptic than shell scripts, and just as fast to write. I started shell scripting again after decades, as I work in a unix environment and a lot of aging scientists like it. Some older shells like csh, which some pooba mandated as the default for our work stations and some servers has really bad quarks. Invisible characters here, a tab there, can break a perfectly fine script. No clues from the shell what the problems is and these quarks aren't documented. The other day I had to go through a directory of files and remove one line. BASH and sed were perfect for that. Otherwise, a coworker is gluing together a bunch of home spun programs he wants to use indefinatley. I might learn a bit of Python to help him, even if it is more verbose than shell commands. This script will be around for a while, he will be able to move it from machine to machine and I will not go nuts hunting for hidden characters with no clues and I will only have to deal with one syntax. 
If you have a legacy project, switching may not yield much. If you are starting afresh spring boot is definitely better.
Boot is a bootstrap framework for Spring which makes it easier to get up and running. I'd go with Spring Boot.
Spring and Spring Boot are, basically, the same thing. It's just that Spring Boot gives you an opinion on how to execute your application. That being said, I work with a monolithic Spring project (3.2) and currently refactoring a Python project into Spring Boot (1.3.5). Both of these aren't pet projects but actual production running code (the Spring Boot one will be eventually) and have had nothing but fun with the Spring Boot refactoring project. So much so, in fact, that I'm going to propose that we also refactoring the legacy monolithic project into microservices. I guess what I'm saying is that if you were to hold a gun to my head, I would choose Spring Boot. Dealing with XML wasn't so much a pain in the ass but it was more of a "loss of focus" in that I'd have to switch between the XMLs and the Java classes to get the "whole story" whereas the annotation gives you the lay of the land right then and there. It almost feels intuitive to me. EDIT: Forgot to answer one of your questions, sorry about that. The projects I'm working with deal with 2 different functionalities, one is a massive integration framework that connects various proprietary software endpoints over a services bus (3.2) and the other (1.3.5) is a refactoring of a Python project that provides ETL services from non-standard, non-canonical data objects into proprietary canonical ones. Hope that helps!
So, the Python project uses Oracle as its backend persistence layer and because of its usage C bindings, it makes it harder to scale, deploy and administer. As much as I enjoy Python, Spring Boot has reduced the amount of boiler plate code considerably.
I do find Boot really productive, so Boot all the way. In a way you can't go wrong either way, it looks like a matter of personal preference and skill.
I did this transition about 8 months ago, I was a middle dev at the time and I worked with Symfony 2/Doctrine stack mostly. Symfony 2 is essentially a Spring clone and Doctrine is a JPA/Hibernate clone (JPA is an Java EE API, Hibernate is one of the implementations). Luckily I got accepted into a company as middle dev rigth away, so in fact I didn't take a pay cut, I've received a raise rather because Java devs get paid more, I guess lucky me. What I personally did is just went ahead and built little something that closely resembled what I've been building in past 3 years before transition - in my case, small multi-tenant SaaS using Spring/Hibernate and included that in my resume. I've got lucky with my interview and they didn't ask me stupid questions, but unfortunately its not true for every company, they will ask you stupid questions, like "whats the difference between abstract class and an interface". On top of Spring you'll need to know about Java EE (servlets and JPA is a must, JSP, JMS maybe and generally know what kind of APIs are there), about how JVM works and a lot about concurrency, like what kind of thread-safe collections are there in standard Java library, what are their performance etc. Also I'm not sure what kind of methodology books you've read, but one that helped me personally was Clean Code. Also Effective Java looked good, although I came up with some of the solutions in it just after reading Clean Code. As for language/standard library reference, I'm reading Schildt's Complete Java Reference 9th editions (think includes features introduced in Java 8), but generally people recommend Thinking in Java by B.Eckel, and its a fairly good book actually. I hope everything will work for you, OP. Personally I was deeply unhappy about being a PHP developer, I just didn't like the language, still don't to be honest, its just not my thing I guess. I've became much happier when I transitioned to Java, especially when I learned about features in Java 8 - there is a lot of functional stuff and I'm a real FP-head. 
Thanks for the reply I have heard good things about Maven. Do you think I should learn both Maven and Gradle?
I am coming from Drupal / Symfony. I think spring sounds like a good way to go.
Thank you for your suggestions these are great. I've been reading Head First Design Patterns and thought of reading Clean Code also.
Well to be honest its more for long term money. Around here PHP is mainly for agencies and you will get maybe 100k max and thats pretty competitive. But looking at indeed the java positions are upward of 120-140k. Money is not the only reason but I am also burnt out on building websites and want to get more into application development or web application development. I would be even open to C++.
or you know, solve it at the language level so you don't have to do stupid hacks.
Agreed. I was able to refactor some projects with a LOT less code. Love the productivity.
&gt; Dealing with XML You don't *need* Spring Boot to do Java/annotation config.
It's almost always used in a cargo-cult fashion by people who don't know what they're doing and are poking at thing to fix symptoms rather than underlying problems.
If you find it hard to understand the spring.io docs and examples, then you should brush up your base java-maven-dependency injection-ioc ect. skills. There are some books but i find them a bit dated with current versions.
Absolutely right but it was one of those "things" that my mind went to when comparing my personal experience with legacy Spring 3.2 and Spring Boot. 
Honestly, no amount of libraries, frameworks or well written code can ever make up for the fast that strong-typed languages are just easier to maintain on an enterprise scale. I never want to write a quick script to wiggle my mouse in java, and I never want to maintain an enterprise midtier in python.
Or maybe Google is skewing the results in favour of python like they did for Clinton. 😉
Sorry you feel that way. I sent you a private message. 
I value my time, so I avoid Boot. It literally takes me half an hour - if that - to set up a new Spring MVC application from not even having Maven set up. That's everything that I need to get going. The Spring Boot way may save some time from that, but the magic that it introduces invariably causes a lot more headaches down the line, when it starts doing things that you don't want it to or you can't work out how to make it do things that you do want it to.
I can understand where you're coming from because this has definitely been the case for most project that try to reduce setup; you end up paying the cost on the other end when things start getting complicated. However, I highly recommend you spend some time with Spring Boot to get a feel for how they handle configuration management. It's meant to be opinionated, which means there's going to be a little learning involved but overall, I've found that projects with Spring Boot are actually easier to manage in the long run. Adding new modules is very easy and clean, and there's a lot of optional integration points. At the end of the day, if all you use Spring Boot for is the initial bootstrapping, you're still able to provide configuration to Spring or other libs/modules through conventional means. Getting a REST service setup and functional with persistence and documentation takes literally something like 1-2 minutes. That alone is worth looking into Spring Boot, imo. 
Basic features on both are pretty simple, iirc it was advanced features that were more learning. 
It's roughly the same when you move from C++ to C# - everything feels way easier. In short: C++ is generally an *unmanaged* (still, you can write managed code in C++) language (you need to take care of memory allocation/deallocation, etc.) versus Java and C# are *managed* languages where the virtual machine takes care of memory management, garbage collection, etc. C++ is a very concise language whereas Java (and C# to a lesser degree) are very verbose languages.
EG membership is not paid but volunteer work. If anything, a company participating in the EG had to pay Oracle. Reality is thus exactly the other way around as you seem to think it is.
Spring (java only version) because it is the de facto standard and it is amazingly documented. 
Dagger, because it validates the object graph at compile-time. 
Cdi
I've been through some, and at some point you realize that while the underlying technique of DI is great, the tooling we're given in the form of "containers" is more of an obstacle than an aid. All you need, IMHO, is a simple class with getters, each returning a dependency. The body of those methods is typically a one-line instantiation statement (that can freely call other dependency getters, in order to build that "object graph" every container keeps talking about). The benefits over using a dedicated container component are many: - Implied, but you don't depend on some other container that may go out of fashion (which unfortunately happens a lot in modern programming). You're not locked-in to anything. - It's as fast as possible, as there's zero magic happening at runtime, and heck there's zero magic happening at compile time... it's just Java code. And since you write in Java, and not some makeshift DSL or a fluent API: - You can use your existing Java skills, rather than learning a poor substitution full of its own quirks. - You won't ever be limited in the way you create your dependencies... it's just Java code. Your dependencies don't need any container specific annotations. They don't need annotations at all. Just constructor arguments and in some limited cases - setter methods. - You get full static type checking (not many containers offer this, some do, but Java also does already). - Auto-completion from your IDE speeds work up significantly. It's - again - just Java, so all your IDE tooling works fine in your "container" (which is just a Java class). By using Java also you will be spared some of the "shortcut" techniques that some containers offer (such as magically planting dependencies in your object's private properties, or binding otherwise reusable classes to your app-specific configuration through purpose-defeating annotations like "@Qualifier"). Such shortcuts seem like a win in the short term, but they always turn out to be the wrong thing to do architecturally if your app is actually useful and has to be maintained over the long run.
That's a really good point, actually. Especially in larger projects with several developers, you want to avoid circular dependencies.
and then you move to ruby or any other scripting language and it will feel even easier... depends on what are you going to do.
culture has nothing to do with it price, and management shortsightedness, has *everything* to do with it 
Guice. Why? Because I work at Google. And it's not that bad, really.
CDI! :D
I use DI extensively, and circular dependencies are very rare (and once you get any, you'd just get a stack overflow exception with the stack that spells out the loop). So how important is this feature, really? In practice.
Spring!
java code. and I favor constructor injection to setter injection. 
Really curious your pain points with cxOracle since you've mentioned it a few times. I've used it numerous times for one off scripts / ETL jobs but never for a large application. I understand that it's a PITA to deploy since you need to install the Oracle Instant Driver, set env variables etc... but is this why you didn't like it? I'm genuinely curious since we have a big Oracle deployment at my company and was consider using Python for larger web based apps in the near future.
Would you rather have your production software break when you compile or when you deploy and run locally/in your test environment? It is safer and saves dev time.
A lot of people are unhappy with the direction that systemd has taken. Therefore a motivated group has used the freedom that they have to fork Debian and provide a systemd free distribution. There is plenty of material out there on why people don't like systemd if you want to look. It's a bit of a large subject to get into here.
Sure, but in my experience the problem is so rare that it simply doesn't matter. It happened to me once 2 years ago, for what I can remember. When we talk about saving time, we should account for how often does something happen. Otherwise it's a shiny bullet point for Dagger that gives you nothing in practice. Is your experience different? You keep getting circular dependencies in your containers? 
Spring. Think that's what we're used to and when you don't include the whole Spring stack it's ok. But we don't have real objections to other DI frameworks.
Here are few more free e-books Docker for Java Developers by Arun Gupta http://shop.oreilly.com/product/0636920050872.do My own compilations: DS and Algo books - http://javarevisited.blogspot.com/2016/05/5-free-data-structure-and-algorithm-books-in-java.html and more Java books https://java67.blogspot.com/2013/11/10-free-java-programing-books-download-PDF-HTML.html
&gt; C++ is a very concise language whereas Java (and C# to a lesser degree) are very verbose languages. some see verbosity as a disadvantage but I think brevity in a language almost encourages bugs, its a shame some of the modern features have resorted to random sprinklings of ascii and not actual meaningful words... 
Java was easier because you already spent some time learning C++. If you had started with Java and then tried C++ you probably would have had the exact reverse experience. Also, what you experienced is, I think, generally positive. As you learn to develop software and get more languages, and frameworks under your belt things should get continually easier to learn. You can draw on your previous knowledge and experience to make new topics easier for yourself.
Switched from guice to spring boot.. Guice is much better. Dagger 2 looked interesting as well
Do you use the new (second) version?
Spring Boot for sure, but I'd change some of the defaults starters to the ones I prefer : Jersey JAX-RS over Spring-MVC, log4j2 over logback. Also, I find it easy to convert existing Spring projects to Boot projects, you don't have to do everything at once. Keep the XML context for those beans that need it, annotate the code where possible. You move a few more components over at every release.
ATG Nucleus
This is a good answer with some truth, and the biggest truth is that DI isn't as magical as it looks and isn't hard to implement, which you've just proven by explaining how to implement a minimal DI tool. But you're still _reimplementing_, and whether that's worth doing varies on context -- sometimes CDI is best, and sometimes it's more than you need.
I don't see how monolith application servers can compete on the cloud with easier and more robust deployment and management techs like jetty+docker+kubernetes. I never want to go back.
SlimFast is in an entirely different market and there's no chance for confusion. It's not infringing.
CDI of course. It is the standard and works great.
Just because the company behind it says so does not make is so. It is pretty popular but to be a de facto standard it would need to have a significant majority share. It probably did 5 - 10 years ago but not today.
Unfortunately there is no definitive source to show the market share of each framework. I would put forward it is up to the person making the claim to prove it and back it up. I can only go by my anecdotal personal experience and polls i have seen. 
Awesome! Two questions: 1. How are the 1000 microservices deployed? Are they in an OSGI container? CLI in Docker container? 2. Fatjar solves the classpath CLI startup issue, making a single service easier to start. How do you propagage the classpath definition from your build env to your runtime env?
Looks pretty cool!
But once you write these Types, the mapping is quite straightforward. 
capsule looks like it still creates a sort of "phat jar" by zipping up the dependencies. 
i have been doing Java long time but never EJB/OSGI. is it useful ? Can you point me maybe to an article that describes its merits and uses.
Great questions! 1. Our applications run in a Mesos environment using [Singularity](https://github.com/HubSpot/Singularity) as the scheduler. Singularity supports deploying docker containers and we sometimes use that for 3rd party things (nginx, ChromeDriver, etc.) but at the moment our applications just run as separate Java processes using the cgroup isolation that Mesos provides. 2. We configure the `maven-jar-plugin` to construct the classpath at build time and add it as a `Class-Path` entry to the manifest. This is a special manifest entry and on startup the JVM automatically adds these files to the classpath, so our thin JARs are runnable with `java -jar` assuming the dependencies are dropped in the right place. To make sure the dependencies are dropped in the right place, we include the output from SlimFast when notifying our build service at the end of the build. This output includes the S3 key for each dependency as well as the place where it needs to copied to, for example: &amp;nbsp; { "s3ObjectKey":"jars/org/slf4j/slf4j-api/1.7.19/slf4j-api-1.7.19.jar", "targetPath":"lib/org/slf4j/slf4j-api/1.7.19/slf4j-api-1.7.19.jar", "filesize":40743, "s3Bucket":"hubspot-jars", "md5":"45e27d98d5558ae47a584ff2d69b9e2e" } Singularity supports downloading as many S3 artifacts as you want on deploy. Previously we used this to download a single artifact (the fat JAR), but now we give Singularity all of the S3 URLs (for the thin JAR plus all its dependencies). It handles downloading these files (if it doesn't have the file cached on disk), verifying the file size and checksum, and copying them to the right folder. So when our application starts up all of its dependencies are present at the right paths and it continues on its merry way.
No, I still use square's version http://square.github.io/dagger/
Based on your article, what you basically wrote is a `rsync`-like plugin which only uploads dependencies which have actually changed. `pack200` is an actual compression algorithm specific to JARs. `pack200` efficiency depends on how many classes exist in your JAR. A JAR that consists mostly of classes will pack better than JARs which contain generic data. If the size of non-class specific entries is significant then that will add to the size of the packed file. `pack200` cannot handle JARs within JARs and treats it as non-packable data, so they require extraction beforehand. An example JAR with 422 classes (845,542 bytes) and 102 non-classes (69,765 bytes). Using `pack200 -G -g` to remove debugging information for maximal packing/stripping. You can keep debugging information if it is important. You can also allow `pack200` to lose the original JAR file order which can potentially increase the compression ratio. 63308 __onlyclass__.pack.xz (14%) 71504 __onlyclass__.pack.gz (16%) 74696 __foo__.pack.xz (15%) 85389 __foo__.pack.gz (17%) 152286 __onlyclass__.pack (34%) 223017 __foo__.pack (45%) 446775 __onlyclass__.jar 493044 __foo__.jar The `pack200` file format is **VERY** compression friendly. It utilizes data deduplication and stripes the data (similarly to RAID) so that similar data is placed next to other similar data. This means that the DEFLATE (which is used in JAR files, compressed HTTP, and `gzip`) or other window based compression algorithms can find similar data faster and since the data is closer it means less bits are used for sliding window references. At the cost of speed (depending on the JAR size), if you `pack200` individual JARs and then compress the contents with `gzip`/`xz` you can save on more bandwidth.
There are also minor details, like the split between header files and non-header files, the linking process to manage, no mature build tools made for convenience (cmake is just the least of many evils). But mostly I believe that Java just has less esoteric symbols (non-self explaining), compared to C++. E.g. compare: std::cout &lt;&lt; (items.begin( ) + *si)-&gt;get&lt;0&gt;( ) &lt;&lt; "\n" ; to System.out.println((items.begin() + si).get(0) + "\n"); The set of non-word symbols used by java: [.()+;] by C++: [:: &lt;&lt; . + * -&gt; &lt;&gt; ;] This also makes Java very easy for beginners.
You know, at the end of the day it was just a cacophony of things: version mismatch issues, general lack of knowledge on our junior developers, implementors and deployers and the design wasn't optimized (lack of input from stakeholders). So, it's really more on the people rather than the technology but people have egos so they blamed the technology :) But aside from the installation issues, there were some queries where SQLAlchemy didn't seem to query using the index and so the performance was slow. A couple of workarounds was to use SPs or re-write the query but then that sort of defeats the "boilerplate" code part. Weird exceptions (which I'm sure could be attributed to compiling against 2.6) sort of came up unexpectedly and just general people frustration. Hopefully, you're on better footing than I am (in terms of supported versions) but that's some of the generics off the top. Hope that helps.
Two such getters of your solution would easily be circular, but that's the least of problems. And if you optimize for speed that way, you do premature optimization. Modern Containers really are the result of people doing things your way in increasingly complex projects, ending up with mature frameworks. Modern Containers are also "just java", annotations are "just java". And if you really ever desperately need IDE completion to retrieve dependencies, writing your accessor class for container-managed entities based on a container is also quite easy.
If your ultimate goal is to get deployments to use as small as possible bandwidth and disk space (at the cost of speed) then you should use `pack200`. Compressing pack files will reduce the space even further (at the cost of speed). If the deployment server does not need to use JARs (and just hosts them) then you can store the compressed pack files and send them as-is to the clients when they need them. Clients need not save the pack file, but should have a hash so it knows the original pack file that was used (to check if a dependency has changed). If you need to access it programmatically then `java.util.jar.Pack200` is available. It is `compact1` so any standard Java SE VM must have them (since Java 5). Packed files need to be unpacked into JARs before they can be used by Java, so you can think of it as JAR serialization. 
It can also download on runtime
I tried it as a bar chart but didn't like the look :(
&gt; One thing you missed however is using synchronized around volatile reads and writes. "Missed" as in "did not cover this obviously excessive synchronization example"? I guess we can add it to "Volatiles and synchronized are not really different". &gt; If you were to delve into Java ME, there is no requirement that BoxedType.valueOf() returns the same object every time even for the first 128 members. Oh yes, nice one. This is another part of compatibility story.
Merits and uses? I'm not sure I have any marketing material that would help with that. http://kevinboone.net/osgitest.html 
oh man that sounds way more complicated than the other alternatives.
Yes, ditch BlueJ and never come back, as tempting as it is to go back to what is familiar. I'll put it this way: day one you walk into the office and ask "why isn't anyone using BlueJ?" Day 1.000000001, you're now going home and looking for a new job. My advice is to play around with just a basic main class and learn the flow. Learn how the Eclipse console works, and what it looks like when you have an exception. Build and debug are what you need to know (I don't know about BlueJ, but in Eclipse, you have to compile the code before it will run; I usually have "automatically build" on, which will compile the code whenever you save). Google is very useful; I use Eclipse at work, and even though I'd say I'm pretty familiar with it, I'm always looking up something that I'm not sure about. 
Who uses oracle cloud and why?
don't trust this article, it contains blatant mistruths like java SE has languished under oracle (when in fact in languished under sun).
That's a good question indeed. From an article &gt; There's some controversy over Oracle's reported cloud sales numbers, however.
Sun already prepared A LOT of work. The just didn't release it. When Oracle was at the helm, it was releases. But much of that was not developed under Oracle's stewardship. For a while there was still much of the inertia going on when the company went through the transition. Now Java 9 has been delayed multiple times, and besides the jigsaw one, do you see many people working on the list of other JEPs that are open? No? Me neither...
First you should learn Java through the console with java and javac. Then you go learn some eclipse.
&gt; The set of non-word symbols used by java: [.()+;] by C++: [:: &lt;&lt; . + * -&gt; &lt;&gt; ;] Huh? Java uses all of those in the C++ list (and more)
makes me wonder if the authors of this new library knew about capsule before they went to all this effort.
Actually, both companies had ups and downs when it comes to Java.
Projects Graal, Valhalla, and Panama are all in active development.
There's speculation that clients who (for example) renew $1 million in on-prem services and switch 1 sandbox to cloud have the whole renewal counted as cloud. Who are the client wins and go-lives? I just don't see it.
Don't worry. You will adopt to Eclipse in no time and never look back at BlueJ - trust me. BlueJ is an abomination, not an IDE. Once you have worked with one of the big three (Eclipse, IntelliJ, Netbeans) you will understand my statement above. The big ones offer so much convenience over BlueJ that you will very soon think "why did I have to even touch that crap" and "how could I program without those features". I would advise you to follow a Java tutorial that uses Eclipse as IDE - this way, you will quickly learn its basic features. My go-to recommendation for such a course is: * **Java for Complete Beginners** by John Purcell (probably the best and easiest entry into Java) - video based (Uses Eclipse as IDE) - the three links below lead to the same course hosted on different servers. I would use the Udemy link because it has an active community where you can ask questions and get answers. * [CaveOfProgramming link](http://courses.caveofprogramming.com/course/java-for-complete-beginners/) - John Purcell's site * [Udemy Link](https://www.udemy.com/java-tutorial) * [YouTube Series](https://www.youtube.com/playlist?list=PL9DF6E4B45C36D411) Also, take a quick tour through the [Eclipse tutorial of Vogella](http://www.vogella.com/tutorials/Eclipse/article.html) which explains the main features and usage. **Good luck!** PS: use /u/sadjava's advice and turn on Autosave and Autocompile - they're absolutely great!
That you should switch to IntelliJ instead.
C++ not suppose to learn in weeks. It takes years of experience to master it.
Care to elaborate?
&gt; BlueJ is not an IDE. It's a learning environment that in my opinion does more harm than good. **Amen**
How do you handle shutting down services when they may require cleanup and order matters? For example, suppose you've got these services: 1. `Merchant`: provides an API for making credit card transactions with an external provider. 2. `Database`: manages the connection pool with your SQL database. 3. `SubscriptionProcessor`: uses `Database` to discover which of your users are due to make payments, then uses `Merchant` to process those payments. You're shutting down the application server. How do you ensure that `Merchant` and `Database` are shut down *after* the `SubscriptionProcessor` is shut down? It seems the container is well-positioned to handle this (for "free") because it knows the entire dependency graph. Some DI frameworks do support this via `@PreDestroy` or `dispose` methods. (AFAIK Guice and Dagger do not support this at all.)
Oh man, wait until you try perl or python... 
All with delivery dates to eventually Java 10 or later. First we still need to get Java 9 and then lets see.
I've run into the issue of 3rd party repos disappearing so I've found it very important to maintain our own repo containing the 3rd party libraries we depend on.
You have some nice responses here, but it should as well be mentioned that this post should rather have gone to either /r/javahelp or to /r/learnjava as it is not really suitable for this sub here. You were somewhat lucky that our people were nice enough not to immediately report your post as off-topic (that's why you got downvoted) and thus get it removed. For the future, please post your questions to either /r/javahelp or to /r/learnjava where the people will be very willing to help and guide you.
Or just don't learn those
Objects already have their own scope, as in, as long as they're referred to by something, they stay alive. So when you have multiple scopes, you can have containers in a hierarchy that matches the desired scope. Let's say we have a root container that contains dependencies that remain live throughout the application, we'll call this class "AppContext". We instantiate this once on startup and the object stays live. AppContext appCtx = new AppContext(); Now let's say the application handles multiple user sessions. We create a container (which I'll call a "context" from now on) for the session, which exposes the necessary services from "env" via proxy methods, but also exposes session-scope services it creates within itself: SessionContext sessionCtx = new SessionContext(appCtx); We can create as many session contexts instances as we want and pass them the same AppContext instance. And whenever we have a request, we can pass the session context to a new instance of a request context, which, on its own turn can expose any necessary app-level and session-level dependencies, as well as create its own request-scope objects. RequestContext reqCtx = new RequestContext(sessionCtx); So it's as simple as that. I'm implementing scopes through basic DI... In essence, a new scope is simply a new object. When the object gets collected, the scope is effectively destroyed, along with any services accessible through it. Sometimes you'd need an explicit shutdown sequence for a context, to close services in a given order, or clean up, then you can either implement finalize() and wait for the garbage collector to eventually call it, or if you need a more strict guarantee, the convention (as is for any object), is to implement method close() or destroy() or whatever, and explicitly call it when a request in your request loop is complete (likewise when you close a session or it expires, etc.). This is essentially what scopes in DIC are anyway (I'm simplifying a bit, but it fits conceptually) - a set of nested loops where the further you go into the loops to create a context, the more short-lived it is. A context is created at the beginning of a cycle iteration, and destroyed by the end of the cycle iteration. In many cases multiple instances of a container exist in parallel (multiple live sessions, multiple concurrent requests), but I hope the basic example is clear.
Object scope is not a DI framework feature, it's a built-in Java feature. You can create an object and once you no longer need it, it's garbage collected. Having "scopes" is as simple as that. If you need services at specific "scopes" (app, session, request etc.) this means you have separate containers for them, and create as many instances of each container as you need, and when you need (and destroy them accordingly). There's nothing to implement in a framework when you just have objects holding objects, because what a "scope" is... is entirely at an app's discretion. There's nothing to reuse here, so this is why after years of practice, I've not arrived at a DI "framework". I'm quite zealous about producing reusable code, but sometimes the value of making something reusable is imaginary when you take a few steps back.
You implement finalize() and/or close() (and call the latter explicitly) as you would with any other object. A container is just a plain Java object in my case. If I want to shut it down (and in this way shut down the services it provides), I just do what I'd do to shut down any other object. Inside that method, I can do whatever I prefer in whatever order I prefer. Plus. The shutdown logic, whenever present, is often more complicated than just the order of destroying the graph. You may want to run checks, you may branch on given conditions, you may want to log something, etc. So having the container do it according to some fixed logic driven by limited annotations is inherently restrictive. The best approach is a consistent interface: have it known you need to call close() when you're done with the container, and let it clean up after itself whatever logic it needs. A reusable container may have some generic knowledge about the graph, but nothing beats the knowledge the developer has about the container *they just implemented for this specific app they're working on*. A library writer never knows more for your app and your dependencies than you do, so this is why one should be careful to choose what's worth delegating to a library (and there's a lot, but not everything) and what to keep in the app code.
What was the reason to abandon Spring?
&gt; BlueJ is not an IDE. It's a learning environment that in my opinion does more harm than good. Wow, never expected to hear so much against BlueJ. I'd love to know what are some poor practices that BlueJ reinforces with Java. I'm definitely going to pick up Eclipse/IntelliJ now, but I want to hear it from the perspective of those who are experienced in both.
Thanks for the video suggestions. Highly appreciated. &gt; PS: use /u/sadjava 's advice and turn on Autosave and Autocompile - they're absolutely great! Just curious - I've always been used to Saving-&gt;compiling manually. Are there any downsides to having autocompile done automatically after saving? 
Sorry! I'll talk note of that for future posts - these responses have been incredibly helpful to me, though.
&gt; Are there any downsides to having autocompile done automatically after saving? No, there are no downsides - actually there mostly are upsides as Eclipse constantly analyses the code and immediately points out potential errors. A typical case is when you define a method with a return value and don't place a `return` statement in the execution path (so that it will always be executed) - Eclipse immediately highlights the potential problem. Personally, I really like those features. Also the direct access to the Javadocs is great - you immediately see what parameters to use and then you can go to the actual Javadoc page (provided that you have installed the JDK Documentation, of course).
As per the language, Sun's up points were that they released a new major version of Java up until 6 every two years. The most enhancing release of Java would be Java 5. They missed the two year cycle with Java 7 (which was released by Oracle), Java 7 being a major advancement. Community wise Sun has been known to quickly vote and other times completely stall on some issues. Sun also started bundling the Ask! Toolbar in Java. Sun also started the OpenJDK project to make Java open source. Sun also abandoned J2ME for the most part. Sun sued Microsoft and won. Oracle had two fantastic Java releases (7 and 8), 8 was only 3 years away so it was not bad. Both Java 7 and 8 were major stepping stones in Java much larger than the 5 to 6 transition. Oracle did revive Java ME and released Java ME 8 but now has not touched it much since, however with the Android invasion they missed their chance. Java ME 8 could still be used for IoT but it appears they are not doing much for that either. Oracle did remove the Ask! Toolbar and instead chose to change a homepage and install a custom Yahoo! Chrome tab (which is not spyware infested). Community wise, they have stalled on issues while handled other ones quite nicely. Oracle sued Google and lost. 
These so called EE guardians are starting to get really silly and cringe worthy. So much drama.
I was going to say the first five words are also accurate
Hell I use J2EE and I question the value of it
We all question the value of J2EE. But that hardly matters anymore, J2EE was more than 10 years ago. This is about its modern reincarnation called Java EE, which is rather different.
Only because you're a Spring fan, right?
I'm not a fan of technologies/framework. It keeps changing and putting sentimental value on it is a waste of time. I'll use anything as long as it works, well-tested, and production ready.
&gt; I'll use anything as long as it works, well-tested, and production ready. Which is, no matter if you dislike or like Java EE, and whether you're a Spring fan or not, the case for Java EE implementations. Actually, there are very few frameworks out there that have been so much battle tested and used in production for such a long time as Java EE. Yes, Spring has that same status, and things like the Linux kernel, the Apache server, and a bunch of packages from the C/C++ world have that status, but overall it's something to cherish, IMHO, and not to blindly throw away just because it doesn't match some 3 month term sheet of some manager in some ivory management tower.
my bad. yes, java ee is an improvement. that's not saying much 
As clear as it can be, I guess :). Thank you for this great explanation. One last thing: I assume you are using some kind of framework, let's say JSF. All major DI's have built-in plugins for a variety of such frameworks. How do you approach this limitation on hand crafted solutions? Put another way, where do you code your bindings? Do you try to keep your library ignorant of the underlying framework (i.e. by binding via application code whenever you feel like it's time do dive into the context)? Or do you try to keep your DI as transparent as possible to your application (as it seems to be the case in Spring and others) by writing custom plugins?
Well, it would be a shame to lose such a stable and reliant specification of a well appreciated and widely used framework. Due to the JCP it's not in the hands of a single company, who can change public APIs whenever they want to. Look at almost every JS framework. Either it's outdated after 2 years or you got something like Angular2, which is totally different than the original angularjs (and therefore outdated / needing major refactorings as well). Please correct me, if I'm wrong with the last point, but I think that the loss of Java EE would be a major setback for enterprise development. Not letting that happen isn't that cringe worthy to me. If it wasn't an issue, do you think it would be picked up that often?
We use dropwizard so we fall into the second camp. We package some of our deployables as docker containers, usually 3rd party applications, and we've considered packaging all of our applications that way but we don't see that many tangible benefits (besides Docker being really hip right now). Our applications already run packed densely in our Mesos cluster with cgroup isolation. And we have yet to find a fix or work around (besides rebooting the AWS instance) for [this](https://github.com/docker/docker/issues/13885) issue, which makes us really hesitant to put everything into docker containers.
Despite being tragic and really bad news, you missed the purpose of this subreddit. This subreddit is about the **Java Programming Language** (as is outlined in the sidebar), not about the island. **Post removed:** completely off-topic
This is the problem with EE fanatics. They readily assume that you are Spring fan if you criticize anything related to EE. So much energy is wasted in Spring vs EE debate. 
Play Framework is a good competitor for both Spring and Java EE.
Possibly, I have really no inside whatsoever into what Oracle management is thinking. The only thing which I mentioned is that EE is bringing in money to be a sustainable branch of what Oracle does, and it's IMO good PR to keep supporting it, and bad PR to just drop it in the middle of working on a new version. Things may have been received a lot better if they announced to be winding down on EE, finish EE 8 (perhaps in a minimal way) and then hand it over to whomever wants it. A bit like how Google handled GWT.
hey, i dislike J2EE, Java EE and Spring
and pay never ending subscription fees for something you get for free with Eclipse/Netbeans.
[This has been discussed to death](http://stackoverflow.com/questions/40480).
Reza sucks, who cares what he says. 
Posted yesterday, along with some comments: https://www.reddit.com/r/java/comments/4oz1tz/an_alternative_to_fat_jars/
My guess is that Oracle sees the Java Community Process as broken. And it is. It's not so much JEE as it's the process that leads to it's implementation. Just look at JSR 107: it's first draft was created almost 4 years ago. It takes them 4 years to design a friggin' caching API. Th process is broken. The Java Community isn't a community; it's just a bunch of 'industry giants' (and the London and Morocco JUG's, for some reason) that all have their own agenda. The real Java Community is the open source community where every developer has his vote. My guess is that Oracle recognizes that they can't compete with the real open source community and that the JCP is just time and money wasted. Look at Servlets 4. What does it have? HTTP2. That's all. Whoop-tee-doo. 
Are you using your own repo or are you using something like Artifactory?
Microservices and other SOA-like systems often eschew tight language coupling and use network interfaces for services, even if the services are found by the discovery layer to be co-located. As the number of services grows, you can't always co-locate them, and as the sytem grows, it's import to give your operations and performance team the freedom to move services around without having to go back through the development cycle to re-implement interfaces on a new transport layer; often this is impossible in large systems since developers and technologies move on. As a result, large frameworks tend to become larger and essentially monolithic, and new systems get built around them. With microservices and other SOA-like architectures not tightly bound to a single framework or implementation language, the system can grow without special treatment of nested frameworks.
Would be nice if the article compared code but hey
Yet Netbeans and Eclipse have some of the features found in the Professional Edition of IntelliJ and it's still free. I like and use IntelliJ and recommend the beginner to give it a try, but I'm not about to suggest that IntelliJ is as free as the competition. I do agree that most people will be happy with the feature set of the community edition. I would recommend IntelliJ CE before I recommend Eclipse. However I would recommend Netbeans more to those wanting to concentrate on learning Java.
Netbeans support Java EE, Javascript and has database tooling which isn't included in the community edition. Netbeans has an integrated profiler which isn't included in either IntelliJ CE or ultimate. Since I have the ultimate edition, I had to get the missing features of the community edition from Jetbrain's website. EDIT: I wouldn't dissuade anyone from using Eclipse. I just recommend Netbeans more since it has more features included without resorting to plugins. A more advance user or a polygot programmer would be happier with IntelliJ or Eclipse.
&gt; and it's IMO good PR to keep supporting it, and bad PR to just drop it in the middle of working on a new version I didn't disagree with that :) &gt; and then hand it over to whomever wants it Oracle doesn't hand over things. Oracle sues you 10 years later. &gt; A bit like how Google handled GWT. You cannot possibly compare any company with Google.
&gt; They wanted full control (business view), and thus killed the voluntary contributions. Oracle does not understand how open source works. I have no idea what Oracle as a company thinks, but at least for JSF and the new MVC that was not how things went in practice. The spec lead, Manfred Riem in this case, very explicitly asked for code contributions from the EG members. Repeatedly even. It's archived in the EG mailing lists (if you wanna look it up, look at late 2014, early 2015).
&gt;You cannot possibly compare any company with Google. But companies can look at Google and copy some of what they do ;)
Since this is help with **Java programming**, please have the courtesy to post it in the appropriate subreddit **/r/javahelp** as is indicated in many places on the subreddit. **Post removed:** programming help.
javadoc, librairies, available answers
are java ee solutions typically bundled with spring et al to make them easier to create?
It's not really reimplementing anything. It's applying a pattern, specifically constructor injection, and factory methods. Compare [this example in Dagger](https://github.com/square/dagger/tree/master/examples/simple/src/main/java/coffee) to [this example using factory methods](https://github.com/newjam/coffee/tree/master/src/main/java/newjam/coffee). It's just a toy example, and the real benefit of using an "autowiring" DI library comes much later. However, I think it illustrates that using factory methods works very well. 
ok, so java ee is an attempt to solve the wordiness/boilerplate nonsense rampant in java
That's a good point, but the Guardians seem to be mostly concerned with trying to force Oracle into some kind of action. I don't think they care if it's putting more development effort back into Java EE or allowing other stakeholders to take over JSRs. There's still significant motivation in the community to push Java EE 8 forward. Soteria, the security API has already been folded into the Payara Server v5 branch, along with JSF 2.3 and MVC 1.0 is on its way. Despite JSR 107 being all over the place, there's a compliant implementation in Hazelcast which has been in Payara Server for almost as long as it's been around. It's frustrating that things have bogged down with Oracle, but I think you're spot on with your reasoning for that. Oracle are in business to make money and have no interest in community right now. 
Earn trillions in advertising such that they don't need to care about anything at all and can completely waste their time on hundreds of useless but hey, perhaps a good idea and fun projects? Somehow, there just hasn't been a second Google yet... :)
Right in time when JSON just starts picking up momentum...
The day I stopped using BlueJ in college is the day I started getting A's on all my programming assignments. Unit Tests, Debugging, Source Exploration, ... the list goes on and on. BlueJ is *maybe* a step above using a text editor and javac from the command line ... *maybe*.
In reality they're all behind JS, but tiobe doesn't count all the front end JS hackers who don't have 'programmer' (or 'engineer') in their job title - and none of it matters. Just use whatever language you enjoy or lets you get things done. Tiobe is, after all, an arbitary metric running ona proprietary system (do we even know it's legit?). One thing they should do (IMO) is expand their query to cover 'scripting' as well as 'programming'. Not doing this causes them to under-rate a lot of the languages like PHP and JS (and to some extent Python and Ruby).
&gt; something you get for free with Eclipse/Netbeans. Believe me, you don't get the same thing. Sometimes, just sometimes it is worth it to pay for something. To me, $150 a year for ALL of their IDE's is a steal.
Curious how this differs from spring reactor http://projectreactor.io/ . At this point if you can use scala to do reactive you'd be in much better shape.
And now GWT is pretty much dead. 
You made a Java command line program... Command line programs are generally easy to make. Java was derived from C so it makes sense that you would find it easier as a developer.
Golang is pretty easy for command line programs too
http://www.jetbrains.com/idea/features/editions_comparison_matrix.html There's **a lot** of use cases over on the right hand side. Besides, ultimately it's a matter of software freedom for me. I stick to software I can read and fix. I can't do that with proprietary software from IntelliJ.
Not asking whether it's pass by value or pass by reference, was looking for a more in depth as to *how* it works in the JVM
But does it compete against all Springs libraries (Data, Integration, Security, Batch...)?
Spring 5 will support Reactive while not making you miss out on injection or all the great Spring MVC convenience features. So calling it a competitior is clickbait, if anything.
That's true.
&gt; Would a poor JSON binding API carry its weight? I personally consider JAXB a success. Now, copy paste that, make 1-2 adaptations, and done.
"datamill is a Java framework for web applications using a functional reactive style built on RxJava. It is intended to be used with Java 8 and lambdas" You can already use Java 8 and lambdas in Spring, and also you can use Reactor with Spring https://projectreactor.io/ext/docs/reference/ and RxJava https://spring.io/blog/2016/01/04/springone2gx-2015-replay-introducing-rxjava-into-a-spring-boot-rest-api Datamill looks nicely engineered and bundled with nice features, but if they want to gain new users they should show that they are committed in the long term. Stability is the first thing that I would like to see when picking up a new framework/library/jvm language.
Can someone explain to me how this is information disclosure? &gt;Description: A malicious client can send file upload requests that cause the HTTP server using the Apache Commons Fileupload library to become unresponsive, preventing the server from servicing other requests. &gt;This flaw is not exploitable beyond causing the code to loop expending CPU resources.
Yeah Matt Raible looks real hip. ;)
If you always follow the bandwagon it may take you to many places but you might never find who you are yourself.
I can't tell if that was a subtle joke or if he's serious. Definitely a hipster.
I agree. I believe that Spring MVC module is the thing that attracted people to Spring as oposed to JEE. JSF 2.x is decent but it is component based and many peple dislike it.
Yeah. Nah. 
Here's the [overall new and noteworthy](https://www.eclipse.org/eclipse/news/4.6/) and here's the [Java new and noteworthy](https://www.eclipse.org/eclipse/news/4.6/jdt.php)
Please no. This whole lets use whatever flavor of the month that runs rampant on the internet gives a false impression. Most Java devs are happily doing productive work with Java EE or Spring. They don't even come to places like this. It is good to keep learning and advancing of course but better to weed out all the bad ideas than switching to a new platform every year.
I hear this story all the time everywhere.
Wow, I'm surprised it's still alive. Is it still as shitty as it used to be?
I am looking forward to the new ECMA/JS features.
I'll take a wild guess and say eclipse will probably still be alive for many years after your own death.
I've been giving the SQL Profiler a good shake in nightly builds. Pretty happy with it, atlhough there's [one outstanding feature request](https://netbeans.org/bugzilla/show_bug.cgi?id=262457) I submitted that I really hope gets looked at before release 
I enjoyed the space themed names, I wonder why they decided not to call it Neptune.
IDEs these days are all about the plugins. If you're having a bad time, you're either a newb or you need to fix your plugins. So many people use each IDE now that it's not likely to be the fault of the IDE anymore.
jhipster just provides tools to integrate Java with a frontend. Nothing "hip" about it, it's just Spring when you boil it down to brass tacks, with some scaffolding CLI helpers a la Rails. Where you're getting this idea on new tools and techniques is beyond me. You can stick to the Java dev, let a frontend developer do the frontend stuff if you want. The only thing I don't agree with jhipster is bundling the javascript app within the war, would rather keep them separate, but that's just me. 
I allways hear people complaining that eclipse crashes a lot. I've used eclipse nearly every day at work for the last 4 years and in my experience eclipse has been quite stable. We don't really use a lot of plugins so that might be a reason for this.
Let's see you say that to the guys at Twitter ;)
Using Mars. Never crashed but I see caught problems to report cloud quite often. And I'm not using any special plugin. 
Same way it works on the native (C/C++/machine code) level. Say you have java method `foo(int x, int y, Object o);` The equivalent native signature would be something similar to (this is by no means exact) `foo(jint x, jint y, jobject* o);` Note the pointer because every nonprimitive variable type is a *reference*. On invoking foo, the arguments are pushed onto the stack (or loaded into registers, depending on architecture and JIT) and then you call the receiver function.
A lot of it depends on which window manager you use, and on whether or not you build from outside eclipse. Eclipse (and Java GUI apps in general) doesn't play very well with awesome-wm, which probably explains a lot of the crashes. 
Abused how ? It is just a zip file...
ctrl-enter generate equals + hashcode select from implementation methods click done
You're complaining about those issues here (the first of which isn't an issue so much as a warning that you won't be able to go back), which makes me think your smug capper is not at all true--that you're not actually debugging it ever or making any effort improve it.
A lot of discussion and work, but there are still corner cases and oversights to address. https://bugs.eclipse.org/bugs/show_bug.cgi?id=382972
ok except it has node modules and other lib dirs on ignore by default so....
[Let me illustrate your question with an appropriate meme](https://i.uploadly.com/8dn4wjzq.jpg)
`getClass` or `instanceof`? Which fields for `equals` and for `hashCode`? The methods on `Objects` or manual computation? You still have to know what you're doing.
huge? I'm not even convinced its good practice... sub class I can see... local class not at all sure...
I hope they get it sorted soon, I really liked eclipse until I got my HP Spectre with a HiDPI screen. I moved to IntelliJ b/c it is 95% smooth sailing w hidpi
Well, this is the first thing I see when I open up Eclipse Neon: http://i.imgur.com/2CEUF5n.png Thought, this used to happen as well on Mars.
Just an FYI, if you're running Java in Docker, you might hit memory problems that initially look like memory leaks. There's a good amount of discussion, with a possible fix, going on in this GitHub issue: https://github.com/docker/docker/issues/15020
There's a bugzilla on this... Neptune was first contender, kicked down by another product with the name. https://bugs.eclipse.org/bugs/show_bug.cgi?id=453927 Nabuu was also briefly considered .;)
Nail. Head.
That's spiffy, but since it's happening to your **beginners** and not to seasoned pros, I'm gonna assume that it has more to do with the user and not the tool. More to the point, what the heck are newbs doing with Eclipse or any other IDE anyway? It's not a good starting place and it doesn't focus on the programming and/or the computer science. Until they even understand what a Java program, or any other program, actually is; they won't be able to even appreciate an IDE. It is frankly ineffective to start with an IDE. Yes, a lot of productivity is to be gained by using an IDE, but beginners don't need productivity, they need understanding.
I find Eclipse much faster to use (both the speed and its usability). YMMV.
I'll admit, the fracturing of the enterprise environment has a layperson like myself really confused. I thought until this article that Spring was based upon JavaEE, not competing with it. It seems that developers are just expected to know the history about why these competing frameworks were created... 
What is the difference, or benefits, of using this over Xtend?
Huge discovery from Java 1.0 when we defined *(method-)local* AWT ActionListeners for reuse ;-)
&gt; It seems that developers are just expected to know the history about why these competing frameworks were created... In the Java language, developers are expected to know the history why a given language feature was implemented the way it was... for backwards compatibility.
I'm asking the same question about Intellij every time someone mentions it. Why you think I should switch to it? What does it can that Eclipse can't or do the same better? I have nothing against Intellij IDEA as IDE but I hate blind optimism of fanboys. So I'm still waiting for constructive criticism and examples that goes beyond "I hate Eclipse, I hate it!" and "Intellij is great, I love it so much!".
Hey, can you please repost this to /r/javahelp Also this is the defacto TDD book for Java http://www.growing-object-oriented-software.com/ Thanks
I've followed too closely what Jason and the Takari folk are doing with generations, but my understanding is they're more geared around continuous deployment - and making improvements to how the maven-release-plugin works. From memory, incremental builds is only one part of what the custom lifecycle changes from standard maven.
Eclipse Neon - Still not as good as IntelliJ
From the looks of it Xtend is a DSL on top of Java. Halva is a tiny 80K Java library. It's pure Java 8 - no magic. It uses Scala syntax (as close as possible) to add Case classes, for-comp, pattern matching, implicits, type aliases and Tuples.
To be fair, I don't think the author made a convincing case for their API. I'm not sure even what "differentiating between try/catch and throws" means. How could you confuse those?
I like it. Do you know if there is such a maven plugin for additional packaging systems. apt/deb, pacman, flatpak, snappy, etc?
It's pretty painless in IntelliJ. But, yeah. The way I use it is I declare the case class first, let IntelliJ build the class and then work. Once the classes are generated you can move them, etc. Also, Pattern matching, for-comp and Tuples don't use annotations. Those are straight java.
I've used [stagemonitor](http://www.stagemonitor.org/) It has worked very well!
Because using that means you know nothing. I've seen it been used to fix so called 'memory usage problems' while there weren't any. 
I like to use the "metrics" library ( http://metrics.dropwizard.io/3.1.0/ ) and then feed that into Graphite. ( http://graphite.wikidot.com ) Graphite is the weak spot on that combo. It's got nice functionality, but it's not easy to set it up to do all that you want. 
The [ELK Stack](https://www.elastic.co/products) is pretty popular and completely free/open source.
Details of what's new: http://wiki.netbeans.org/NewAndNoteworthyNB82 Not too much Java side really, but editable multi-caret alone will be worth the update if it works like it does in Idea.
try https://glowroot.org/
Can someone who understands this frustration explain what's going on and what they want from Oracle? Despite seeing a lot of news articles I am finding it hard to know exactly what they want or what their goals are. Is there uncertainty about some direction or are there current proposals that are blocked? Are people / organizations requiring some ordained pattern or standards? Why are they being bottlenecked by Oracle? Most of my career has been in the Java ecosystem and we have been solving problems, creating new patterns, and building new frameworks without much an issue. Much of this work which originated from EE, so I'm not disparaging the group or their efforts. But as somebody who works in the corporate world and would presumably benefit a lot from a focus on enterprise, I'm not sure what I'm missing.
It's also happened to me. I was just pointing out that I saw it happen a lot in a large sample size. This has also happened in upper division courses I've taken to numerous people. How could a beginner, who doesn't even touch anything besides File&gt;New Class and the Run button be causing eclipse to corrupt its config directory? Don't tell me how using an IDE is wrong. I'm not the one writing the courses. I was an undergrad teaching assistant. I also fail to see how having something compile for you is bad for a beginner. This lets them focus on learning the code and not how to work `javac`. No one in industry compiles Java via the command line (if eclipse is as popular as everyone in this thread says), so it doesn't matter if they know how to do it before they get to C in their second year.
Basically Oracle has recently fired a bunch of Java guys and does not seem to be putting much effort into Java and specifically Java EE. Oracle has not said anything publicly about why. These guys want to know what is going on. 
A. What changes could novices have made that ALL of them did it even though we were watching? B. What plugins besides basic Java stuff that comes with eclipse in the package manager?
yup, that was pretty much how I saw myself when I posted the question :D
Even worse. The main argument for introducing the API seems to me to introduce allot of undue coupling. This can't be used in anything but root of the dependency tree. And even then, I seriously doubt handling all exceptions categorically (by class) the same way is desirable. Nevermind the logging used in the example actually hides where the exception first occurs. This means you can't configure your loggers to listen for specific components.
I have no idea. I wasn't there. And the plugins that are installed in Eclipse has a lot to do with which edition you download. Did anyone take time to troubleshoot the situation? If a bunch of people all start having the same problem, then you know... it can be fixed. It's easier to just blame the tool I guess, and certainly problems do happen, but Eclipse is successfully used by so many developers that it's a bit rash to assume that Eclipse itself is the sole reason for the problem. Edit: Lastly - this is a much better tool for Java beginners: http://www.bluej.org/ You might want to suggest it next time you work with beginners.
Java EE sure, but I fail to see how Oracle can be accused of not putting effort into Java. It powers their cloud offering, its used in the bulk of their middleware offerings and the mailing lists &amp; repos are very busy by any standard.
My company specifically didn't go with NewRelic for that reason. We talked to the company and they said they offer only cloud based. It's a shame because we would have happily paid for a non-cloud based version. We'd also love to know of alternatives as we're still looking for something instead of home grown options.
It's quite useful for creating quick ad-hoc implementations of interfaces, to pass to a constructor or return from that method. In larger architectures, writing adapters from one API to another is common-place. Those adapter classes are very specific, as in they're needed at a specific method and nowhere else, and have typically short one-line method bodies. The most readable approach therefore is to define it at the only place you'll use it, thus improving the cohesion of your code.
Oracle and other huge companies are highly dependent on both Java and Java EE. Neither is going anywhere anytime soon despite what the hipsters say.
This actually looks pretty good!
Appdynamics, maybe dynatrace. NewRelic is just "ok" for Java - does not provide any reliable insight into the code or cause of the slowdowns.
Ebean is an implementation of some of the JPA spec, so I'm not sure what you mean by how it "stacks up against JPA". As for adoption, seems there is plenty of discussion on the Ebean google group each day. And anecdotally we use it in production (Play 2.5.x with Ebean). I find it works pretty well and the query framework is pretty straight forward. EDIT&gt;&gt; Really? Downvoting because you don't like that someone likes and uses Ebean just fine? Give me a frickin' break.
Is it better to learn Spring Boot, Play, and Jersey than Spring MVC? 
I am actually using Eclipse and IDEA side by side. Some projects are on Eclipse and others are on IDEA. I think both are good IDEs. And whether IDEA folks admit it or not, IDEA needs Eclipse (and NetBeans) to keep themselves honest and progressive. It is only a shame that Eclipse developers let their ball fall down for long enough that we have to talk about IDEA in this comments thread. Let's hope they'll pick up the slack from now on
TL;DR "...concern that Oracle, despite its role as steward of Java, has not made any public statements or explanations for the apparent lack of activity on Java EE"
Some I am sure but not a lot in the scheme of things. It is these frameworks that have made Java so popular.
Yes, it's planned to be released by August 2016
Where can I find that releases?
Oh man, my favorite part: "Avoid the misunderstanding of try/catch and throws by eliminating the need for throws." Wat??? I'm unsure if the authors know when to use throws or not. 
Not everyone wants to move to Scala. Java 8 is perfect for many organizations. And now, you can use some of the nice features that Scala has in Java.
Look around, half the people in /r/programming dislike Java, also in Silicon Valley, Hacker News, basically any group of diverse amount of software engineers. I don't think these frameworks attracted anyone to this language. I'd rather attribute things like college, the name of the language, Minecraft, Android, 90s hype and other stuff rather than enterprise frameworks. Java doesn't have to be slow or verbose. The JVM has frameworks with the fastest HTTP servers on earth, yet most Java enterprise apps are slow. JavaScript, Python and Ruby, even Scala are getting tons of traction while Java is still popular because of legacy "enterprise" web apps which require tons of devs. This isn't a good place to be.
Sequences are separate database objects, so they don't require a lock. They're quite flexible, and are designed to increase concurrency (or rather to be used in highly concurrent environments). Just look up the documentation for sequences on DB2 or Oracle. MySQL doesn't support them, though.
I agree with you about the people on r/programming and Hacker News. I have worked a lot of different places over the last 20 years and I don't think any of the programmers I worked with ever even heard of Hacker News and do not visit r/programming. Those places are filled with hipsters that give a false impression about what is popular in the Job market. Java was extraordinarily popular before it was being taught in college, before Minecraft, and before Android. None of those are the main driver of Java's current popularity although Android certainly helps. Java is not slow. It is verbose and that is a good thing. The very smartest programmers may be marginally more productive with a less verbose language but the average one does much better with a more readable language. The fact is the main reason Java is so popular is because of stable powerful frameworks like Java EE and Spring. There are a bunch of languages out there that are really not that different but the tooling and frameworks available for Java are great.
Dismissing the future of programming as "hipsters"? I'm not saying Hacker News or /r/programming are the only groups that dislike Java. It is widely disliked by a LOT of people because of unnecessary verbosity. Java didn't become popular because of "stable frameworks", it got popular because of cross platform hype, a replacement finally for C++ but when people realized Swing wasn't optimal for desktop apps it gained middle ground in the enterprise server side. Java EE and Spring are not the reason people want to develop in Java, it's the reason people are forced to develop in Java. &gt; Java is not slow. No it's not, but Spring and Java EE apps are, even more than Python apps. Just take a look at the [Tech Empower](https://www.techempower.com/benchmarks/#section=data-r12&amp;hw=peak&amp;test=plaintext) benchmarks. Java dominates the fastest frameworks but the frameworks /r/java keeps recommending like Spring Boot are almost all at the bottom. Java is a great choice for server side but when the frameworks the community keeps recommending are bloated overcooked monsters it suddenly seems not. I'm not calling Java verbose, I'm calling popular Java frameworks verbose. Notice how the fastest Java frameworks are also the least verbose?
Whatever vlad* name. Based on the account that posted it. 
When you refer to Scala you must mean Idiotmatic Scala. 
I never said that you couldn't. I've given you all of the help that I will.
give moar
You're being downvoted because it's a question about how to do something very, very stupid. /u/the_hoser gave you too much information already.
Who?
[removed]
interesting... testing REST endpoints is relatively simple, so I was wondering why bothering with a specialised test library, instead of just using plain good old JUnit 4. But REST Assured does seem to provide some interesting syntax to avoid boilerplates and potentially making tests easier to read. 
Right, the article is poorly written. What the author is really suggesting is to refactor all of the exception-handling logic into its own class, so that exceptions can be handled in a consistent manner. That's pretty sound logic, but the way the article does it - with a non-threadsafe singleton, no logger markers, etc. - is a pretty dumb way to advocate a pattern that can be really powerful.
Here's my tutorial: 1. Download Gluon Scene Builder as Oracle no longer provides builds (That's the most difficult part) 2. Install Scene Builder 3. Goof around a little and get to know it It really is incredibly easy and intuitive. That's all you need to know, imo.
Yeah, that's what I've been doing those last hours. Although, I'm still looking for a nice tutorial mixing JavaFX and Scene Builder so I can go further.
I'd rather consider switching to PostgreSQL :-) With PostgreSQL you can use GenerationType.IDENTITY and it will use a sequence behind the scenes.
Is this better in some way than `jjs` which ships with the JDK? [Here](http://winterbe.com/posts/2014/04/05/java8-nashorn-tutorial/) is a little tutorial. Java has had various REPLs for a while too, I have used both [BeanShell](http://www.beanshell.org/) and the Display tab in eclipse, both work pretty well for exploring an API. The Display tab can be a bit unwieldy at time, but autocompletion works!
It's really just drag and drop. You won't need it and I'm not sure anyone would take the trouble of writing a tutorial that reads like: Drag the TextField to the VBox. Click on the TextView. Give it an id using the javafx:id field. And that's really all there is to it.
[Concurrency!](http://jcip.net/)
Do you know Sublime Text? I love multi-caret in it.
I doubt this is a good idea, considering the risk of plagiarism At my uni we aren't to share code ever (EDIT: IN ASSIGNMENTS, if that wasn't clear enough already)
im not fussed about plagerism, 
With a title of "_Moron tries to do Java_", not too sure I would even want to consider watching this. Inviting others to laugh at you just calls for a toxic atmosphere which can do far more harm than good. 
Generics with recursive type bounds
Horrible uni. If university does not support open source software then you should immediately quit paying them and change school
Reflection
Even if it is **your** code it might be rejected because publishing/sharing even your own code is forbidden in most universities. If your uni is a hardliner it could even lead to suspension or getting expelled. I would never risk this. BTW: Had I caught one of my students doing this, I would have rejected the submission on the exact premises of sharing the code of an assignment.
Lambdas and Streams
Well, my timeline is my vacations (scholar ones) in France.
If you're looking for a fun way to learn it, Almas Baimagambetov runs a great series on game design with JavaFX. https://www.youtube.com/channel/UCmjXvUa36DjqCJ1zktXVbUA
Gave an upvote but this is kind of obvious and that bean in the middle of the page looks like a vagina (not that there's anything wrong with that).
[Disclaimer: I'm the author of Javaslang (http://javaslang.io), a functional, Scala-like library for Java 8+] The case classes and case objects approach is very interesting! The suggested Pattern Matching approach is based on an internal DSL, which has its limitations. The first attempt in Javaslang worked similar but it introduced unsolvable problems like result type bound calculation. Please find Javaslang's current approach here: http://www.javaslang.io/javaslang-docs/#_pattern_matching Please also take a look at this example of a For Comprehension in Java 8 that is not built with a DSL (like in Halva) but takes a compositional approach instead. This approach takes the iterated values into account when yielding the result: https://gist.github.com/danieldietrich/244adee1f3d3089c958ad8059100b35e Every (Java 8) library comes with its own impl of Tuples now :) A future version of Scala might implement them as HList, which scales well. The number of elements would be theoretically unbounded. Syntactic sugar for the notion of tuples would help. Without proper type inference (see http://openjdk.java.net/jeps/286) HLists are not practicable in Java. 
Very true point there. But the code is not quite self-explanatory.
&gt; the convention of an 80 character right margin Why is this still a convention? I haven't seen an 80-character terminal in 20 years.
I totally agree here, it shouldn't be convention. At my place of work most people have a rMBP and a 34" 3440x1440 display so we increased our right margin to 240 so that wrapping was more related to making code readable than some superficial 20 year old spec.
Is there any way you can refactor the code or rename a method or variable (or create a new private method or a new variable) to make the code more self-explanatory?
it's 2016, you can have 120. :) we went from 80 to 120 at my company and it fits fine on everyones laptop and made the code a lot more readable. also, I second the "not at all" rule. Sonarqube by default flags it as a code smell and gives a pretty compelling reason as to why. Comments before the line are almost always more readable.
&gt; Every (Java 8) library comes with its own impl of Tuples now Yeah - that sucks. It's like Guava. In Halva, Tuples exist mostly for case class decomposition. Again, I don't see why you think Halva is a DSL. The For-comp is a single class with a few methods. 
If something deserves a comment, then the comment deserves its own line. If a comment doesn't deserve its own line, it doesn't deserve to exist. End of line comments are a major code smell, usually means someone is dumping their internal narrative, which means they haven't bothered to revisit their code once they were "finished" to remove any ambiguity, and to tidy up names and break out methods. A large number of developers think "it's working" is good enough.
The choice of 80 is historical and not based on much if any research. For prose, optimal is much less, but for code, somewhere between 70-90 coincidentally works quite well. Reading long lines is extremely uncomfortable -- it's easier to lose track and harder to detect patterns. If lines are short, I can fit multiple windows next to each other on my 24" display, and I can still develop comfortably on a 15" display. If that's not enough, VCS is still line based, so long lines have a detrimental effect on the usefulness of VCS -- destroying annotation and causing merge conflicts. These things have real (negative) impact on maintenance. Sticking to 80 columns doesn't magically solve all those problems but moving above that only makes it worse. And it's not difficult even in Java. It has the additional advantage of forcing you to not rely on IDEs' poorly generated identifiers.
Absolutes are impractical. You should prefer the latter but some things can't be solved with code. Comments should be used mainly for whys, though, and occasionally to summarise an algorithm. Two weeks ago I wrote a three-word comment that I now regret not turning into a method. Structurally the method would be completely unnecessary overhead and the comment is strictly easier to read, but the comment is much easier to delete accidentally.
what are all of you guys on about? 80 lines is a convention cause thats how many characters per line fits on paper. however yes, ive never printed production code, so it might be a bit aged.
That's what makes it a historical accident (we didn't design media for the content but adapted content to existing media). Specifically 80 [probably comes from IBM's punched cards](https://en.wikipedia.org/wiki/Characters_per_line). The technical limitations have turned out to have some very desirable qualities (some of which are consequences of other technical limitations, such as line based VCS). People deride it today because we have word-wrap and massive resolutions while failing to acknowledge the advantages of that limit.
Many companies would tend to disagree with you on that first part. Comment as little as possible and only do so after you have exhausted all other options. Comments should always be a flag to indicate that you weren't able to explain what you wanted with code. This should be an exceptional circumstance, not something you do often. 
Comments should be before every method? We don't live in 90s man. Good code should be self explanatory, writing a comment is confessing your guilt as you failed to write good code (besides some obvious exceptions such as explaining your choice of path you've taken, or some other minor exceptions, where comments are a good choice). Of course public APIs are a different thing (and java doc is must have) but internal well written code definitely shouldn't need a comment on every method, it's a sign of shit code, not good one. 
There is still a "lock" (probably rather a latch) on the sequence itself, though. When a sequence is accessed very frequently and the sequence cache is not big enough, there can still be quite a bit of contention generated by this concurrent access. E.g. in Oracle, under heavy load, if concurrent inserts pass through trigger-generated sequences, and the sequence cache needs to be re-filled, there might be a significant impact on the insertions.
Hi Lukas, you're right, I was referring to the lock on the table. The stuff about caches is why I was referring to the documentation: there are lots of things you can tweak with sequences to get the behaviour you want. It's sad that MySQL doesn't support them, in cases where you don't have the choice of supporting MySQL it's quite annoying.
Hardcoding your API key is a bad design...
+1 for 120
Good rule of thumb that I think you'd be wise to learn from. If your code is so complicated that you need a comment, start by simplifying it. An easy way is to factor out parts into other methods. (A 20+ character name is smelly, but do do this, just use shorter yet descriptive names.) This will make the calling method more clear. In general, a method should read like a paragraph. If it doesn't, you haven't done your job well IMO. 
Yeah youre right, I forgot I had several google api searches that I used during my first iteration of the project that I am no longer using anymore. Thanks for the heads up
I usually increase the margin to 120 or 160
I don't work in a company so I don't know about that, but I always comment a lot, at least for myself. Generally speaking, too much information is better than not enough.
Too much information is fine as long as it's accurate. The problem with comments is they don't need to be right for the code to still work and are always the last thing to be updated. When you refactor your code and your method functions differently, what happens if you forget to update your comments? What is your source of truth? For example: var name // user's name to log into the system Elsewhere in my system I decide users should actually log in with their email address. The code is correct but the comment is wrong. So what happens when another developer comes along and wants to adds some validation on the user log in process and follows the comments? It is much better if your code can explain itself without comments.
What's unsafe about Halva? It's completely typesafe unless there's a bug you see.
I mean it can easily throw exceptions ; in a pattern match, the get() function is unsafe (if there was no matching caseOf), also it looks like you can use extractors (Any) irrelevantly of the case, so that can also throw.
Is there best practices for this? Im a noob
Man, I'm barely getting into Java 8.. seems useful tho.
 var loginIdentifier
I prefer none, it makes the code harder to read IMO. I don't mind long lines though, just not comments dangling off the end like an afterthought or a hastily crafted postscript.
&gt; If your code is so complicated that you need a comment, start by simplifying it. Seriously? Have you ever worked on a code base that has lasted more than 3 decades? Bring the comments on, preferably not at the end of the line but bring ... them ... on. Your brand of simplification might not be mine. Put in some English (or whatever's applicable). 
Haha, we'll be two!
&gt; Many companies would tend to disagree with you on that first part. Many more would agree.
http://jslwin.sourceforge.net/
The functional stuff is useful and can shorten your code a bit. But it stops being useful when its abused and makes the code unreadable.
I know that, but they decidedly chose against using that terminology in Java 8. Why choose it now in Java 9, when the "established Java terminology" is `limit` and `skip`?
&gt; [comments] are always the last thing to be updated. Yes in this case it makes no sense, code and comments must be written together. I wrote them early so I don't lose my kittens while coding. For personal projects in PHP and javascript I use "flags" (like $TODO, $TOTEST). &gt; what happens if you forget to update your comments? We shouldn't, as mentioned in [How to write unmaintainable code](https://www.se.rit.edu/~tabeec/RIT_441/Resources_files/How%20To%20Write%20Unmaintainable%20Code.pdf) ! ;) Edit : great quote by the way : &gt;Incorrect documentation is often worse than no documentation. &gt; - Bertrand Meyer
&gt; You sound like exactly the kind of person attracted to academia. That's exactly why I have left it 17 years ago... - no, seriously, it got boring as hell - every couple weeks the same courses - felt like running in a treadmill and never get anywhere.
"Start" was the key word there. If it's still complicated after refactoring to a simpler form, because many things are inherently complex, sure, add a comment. But don't start there. 
What kind of ranty blogger would start fights over that? Only crazy people would even consider that. *awaiting_your_post_sometime_this_week*
Yeah I agree it's a dick move to steal work, but sharing it shouldn't be discouraged. This is a fun thing to do for OP and probably a big learning experience.
Nice to have, but please, for the sake of all heavens, don't abuse these things! "conciseness != readable" 
The extension function is also wrong, because the extension function that is defined is not the one that is used. In both the Lombok and Kotlin cases, they define a method "String.extends()" but use a method "String.toTitleCase()" Also, synchronised is part of the Java spec, not just part of Kotlin. Kotlin can make use of it because it's Java, but so can normal Java code without Lombok.
The only problem I see with that is that is being planned for Java 10 or later.
Do you know the difference between *comment* and (API) *documentation*? Hopefully :-) So you probably mean documentation?
Needs a build system using maven or gradle. Readme needs how to build the project. License on the source. Project files should not be committed, but generated.
&gt; In this case, it will call the default exception handler, that also prints the stack trace by default, then throws a runtime exception, wrapping the original exception inside. This is wrong. Either log the exception or rethrow it, but don't do both. In fact just rethrow it. Spitting into the log and continuing as if everything were fine doesn't count as handling the exception.
Keycloak is one the hidden gems in the Java world. It is among the best at solving the single-sign on problem. More information can be found at [keycloak.org](http://www.keycloak.org/)
https://github.com/kohsuke/winsw We use winsw for a Spring Boot application that needs to run on Windows. They have a sample for it at https://github.com/snicoll-scratches/spring-boot-daemon
There is also Kotlin as a good example how to handle NPEs https://kotlinlang.org/docs/reference/null-safety.html
And yet they're the easiest exceptions to avoid. It's actually pretty much programming 101: 1) don't return null, and/or 2) check to make sure it's not null before you do something that can throw an NPE. var element = null; element.getAttribute("id"); // crash Yeah, no shit.
how?
What's the oldest code base you've worked on? I've worked on code bases back to the 80's at several places.
Man, I dunno, the feature set is nice, but the API is atrocious and barely documented (arguments aren't labeled as required or optional, and expected values are very unintuitive.) There's also a memory leak in their user cache that's been challenging to get addressed.
From 1999... but what's the clue about that? 
A new name is needed since Java is a trademark. There are many companies that want some sort of a "standard" that's backed by large software companies (e.g. RedHat, IBM). If there's a demand, there will be an offer too.
Nice summary page! simple and to the point. May I suggest a few additions? * static methods in interfaces, it is a not so popular addition to java 8, right below defender methods * a comparator using Comparator.comparing, it is a really cool way to make comparators, you can include nulls in ordering, order by name and then lastname, etc Thanks! 
Actually that is the first java game I had written a while ago, thanks for pointing out the problem :) This game is good for starter but you certainly will want to write a neat code after you have mastered the java programming language
You are attempting to declare a method inside of a method. You cannot do this. Put it outside the main method.
What do your compiler errors say? Is there anything about those messages that would help you fix the problem?
the_hoser and Dusteh are correct, methods need to be defined outside the main method. also: http://www.take-a-screenshot.org/
Please, next time, follow the rules (and the plenty hints on this site) and post programming help questions to **/r/javahelp**. Also, make sure to read the [**Posting Guide**](https://redd.it/48eykt) there. Further, note that **screenshots of code** are not allowed. **Post removed:** programming help
It’s not unique, Kotlin does that, too. See link from /u/thatsIch below.
Thanks. Check this comment about Kotlin: http://dobegin.com/npe-hell/#comment-2755370087
Sure. My point is that if you do something really dumb, then the compiler/parser should be able to stop you and warn you until it's too late. When you fix this bug for 1000th time it's not funny anymore. It's often not your own code.
 PreparedStataements 
You've heard of google, right?
no?
Value types are essentially raw structures similar to `struct` in C. A value type in Java would contain multiple primitives and references represented as if it were a primitive type. It would essentially at its basic level work the same as assigning and setting values to C `struct`s. A use for this would be for example to return two values from a method. Normally in Java you can only return a single value, if you wanted to return more you would have to create an object or pass an array. With value types you can return the raw data directly. This means there are potentially no heap allocations (although this is not the case right now) and no requirement to pass arrays. Another useful example would be types that only contain public fields and no methods, such as a mutable 2D point for example. Instead of having a `Point` class and a `getX()` and `getY()`, you could instead return the `point` value type and access it directly as if it were a public field. 
Is this targeting JDK 10, or probably even further out? 
What does your certificate chain look like? Have your previously made changes to the keystore/truststore that got wiped out by the new JRE install?
Probably a bug in the JVM. JK we can't really hellp without code... Try posting on javahelp
FYI anyone wanderer who Dan is: http://therealdanvega.com
I bought this course awhile back and I definitely learned a lot from it, at the time I remember getting confused and wishing it was strictly in Java as I had not seen groovy before lol. Really awesome that you are helping the sub out with it though, thank you. Edit: Not sure how to get the coupon, I assume by pm. Here is the course for anyone interested https://www.udemy.com/spring-boot-intro/ 
I have done this.
I would love to participate in the course. What I need to do?
Why? Vlad is a cool guy, you should meet him
Depends if the AssertionError is valid or not. Paste the error message and the code.
You need to elaborate a bit more on what you *exactly* want to do. Your post does not give enough information to be able to help you. Show some code you already have, and **most important**: This question is about **programming help** and thus should go in **/r/javahelp** (as is outlined in many places here). But before posting there, please read the [**Posting Guidelines**](https://redd.it/48eykt) **Post removed:** Programming help - should go in **/r/javahelp**
This post is about **programming help** and thus should go in **/r/javahelp** as is outlined in many places in the subreddit. Please, make sure to read the [**Posting Instructions**](https://redd.it/48eykt) before posting there. **Post removed:** Programming help - should go in **/r/javahelp**
Well that's googles fault, and irrelevant to the java community
Conclusion: Use SQL to avoid NullPointerExceptions
Does it mean they are not going to wait for Oracle any longer? How many things from EE 8 landed in EE 8 MicroProfile or is it totally separate stuff?
&gt;Option types are known as Nullable&lt;T&gt;, Optional&lt;T&gt;, Option&lt;T&gt; or Maybe T in different programming languages (where “T” denotes a data type). Such type lets you express an explicit intent that a value can potentially be null and requires an explicit cast if you want to get to a contained non-null value. Saying that `Optional` is something that may contain null is like saying that `ArrayList` of size 0 may contain null which is not true. Optional is more like collection of max 1 element. Some collections may contain null but their size must be bigger than zero first (because null is a valid element of this collection). Try this code: ArrayList&lt;Object&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add(null); System.out.println(arrayList.size()); // prints 1, not 0 Also languages like Haskell or Rust doesn't hide null in Options. They just doesn't provide null ref/pointer. If you try to get value when it's absent you may even get problem with compiling your program. And that's nothing to do with null. Optional in Java may be used to solve similar problems but that doesn't mean they are similar concepts.
X-Post referenced from /r/scala by /u/alexandr-nikitin [Bloom filter for Scala, the fastest for JVM](https://www.reddit.com/r/scala/comments/4qe20l/bloom_filter_for_scala_the_fastest_for_jvm/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Kotlin makes it appear to the programmer that there are value types when in reality they are stored within another `Object` or array. This would add actual support for value types within the virtual machine. Technically after the lawsuit, Android is not Java so there is no reason to expect this feature to appear in Android. 
Which library is the best to start out with for someone just getting started with XML? I'm just starting the third semester of Java programming through University. Looking at the article DOM4J looks the easiest to use, should I use something else?
This would actually be rather good for ReactOS if it can be backported to Windows 2003 level, this way the open source ReactOS can actually bundle an open source JVM.
As far as I can see at least CDI 2.0 landed in it. JAX-RS is the EE 7 version. Security is under discussion, as is Bean Validation 2.0. The latter still needs to start, but it's owned by Red Hat so could start at any moment.
Ahem... &gt; Java compiler is not well optimized yet compared to C++. I would dare to challenge this with the latest implementations. The JVM is the main difference between C++ and Java - where even the JVM is optimized like hell nowadays. &gt; There is no separation of specification from implementation. Not necessarily a disadvantage - only for C/C++ programmers &gt; The lack of templates can limit the ability of Java to create high quality data structures. What? Doesn't make much sense to me &gt; One can find some bugs in browsers and example programs. That's perfectly common for every programming language and definitely has nothing special to do with Java. Also: Java &amp; browsers? **What century is this? Java applets are basically dead.** The "Where is Java used" section misses one of the biggest applications for Java nowadays: **embedded devices** - basically everything from mobiles, DVD/BluRay players/sat receivers/fridges/cars/maybe even roombas have Java. All in all, the article seems clobbered together from some outdated or questionable sources with an author that hasn't much clue about the real power of Java. 
It's just an advertisement for offshoring dev to India. You see tons of these low-effort zero content posts that just contain links to these kinds of companies. 
Quite likely - should've known from the clickbait title already.
&gt; - One can find some bugs in browsers and example programs. Okay. &gt; - There is no separation of specification from implementation. What is the author trying to tell us here?
Learn the JDK's standard DOM and JAXB (and perhaps SAX, although that's used less often). I suspect most people just use JAXB for simple XML use-cases, where little transformation (XSLT) and querying (XPath) is needed.
A wireshark trace of the TLS handshake would probably be more helpful. Especially for comparison with the last version that worked.
It just confuses me cause I'm used to seeing vlad share vlads stuff and t Jansen sharing his. 
Have you compared cipher suites? Any restrictions (non default settings) on either side? (security properties file) 
It's using unmodified Java 8... No policy changes, no security restrictions (that I am aware of). I control both the server and the client side and I have experimented with changing the nginx cipher suites as well, but we have other applications working just fine (non-java). I have also tried both Oracle and OpenJDK with the same results.
It's for performance. Imagine defining an object like Point with three integers inside it (x, y, z). And now imagine you use these objects all over your codebase, like for function parameters. Actually don't imagine, just play Minecraft and see. Well this creates a lot of GC load. And when you have big arrays of them, you are running slowly because the CPU cache is poorly utilised. The JVM has some optimisations that can chip away at these problems, but to fully solve them, you need to extend the language and runtime. Basically in Java an object has virtual methods, a lock, a stable hash code, and can be of arbitrary size. Providing these things has a cost, they are not free. Value types cannot have virtual methods, they cannot be synchronised upon, they do not have a stable hash code and it only really makes sense for them to be small. But if your structure fits into that criteria it can make a big speed boost.
We're just people reading blogs for a living and trying to get some sweet sweet karma on reddit.
That makes sense. I figured you all knew each other or work together. I think I recognize your name on a lot of hibernate stuff. 
I've been obsessed with Java AOT for over ten years (although not obsessed enough to purchase an Excelsior JET license! lol) It would be great to write and distribute GUI (and maybe even non-GUI) applications and not have to worry about dependencies on the target machine. However, since JavaFX gave us `javapackager`, and I can now easily create a standalone app installer that's just over 40 megs, my thirst has somewhat quenched. If Java 9 and Jigsaw gives us the ability to bundle only a subset of the standard library, and whittle that embedded JRE size down substantially further, then for me AOT will go from "holy grail" to "nice-to-have".
What ciphers are enabled on nginx server? Edit: I was reading https://www.java.com/en/download/faq/release_changes.xml for u91 . Could this be your problem? &gt; The MD5withRSA signature algorithm is now considered insecure and should no longer be used. Accordingly, MD5withRSA has been deactivated by default in the Oracle JSSE implementation by adding "MD5withRSA" to the "jdk.tls.disabledAlgorithms" security property. Now, both TLS handshake messages and X.509 certificates signed with MD5withRSA algorithm are no longer acceptable by default. This change extends the previous MD5-based certificate restriction ("jdk.certpath.disabledAlgorithms") to **also include handshake messages in TLS version 1.2.** If required, this algorithm can be reactivated by removing "MD5withRSA" from the "jdk.tls.disabledAlgorithms" security property.
Thanks Vlad and lukaseder for sharing this. For everyone else here is video on the same topic that I found very helpful: https://www.youtube.com/watch?v=u25Xc88d_iE
It's a small world. And yes, indeed, Vlad's useful information now hogs all the traffic I've tried to divert to my ranty websites ;)
Even if we don't work together, we are all in the data access frameworks business. Lukas is the CEO of the company behind jOOQ. I work as a Hibernate Developer Advocate, and Thorben offers training for Hibernate. 
Apologies... done
Apologies... I added the coupon to the description 
Apologies... I added the coupon to the description 
Thank you! Now it's correct. Think you need either *loads* of caffeine or *loads* of sleep ;) But I understand the "long week" - same for me (feels extremely long because of boring, monotonous tasks)
There's also one video about [High-Performance Hibernate](https://www.youtube.com/watch?v=BTdTEe9QL5k).
JavaScript is becoming a key technology for building single page applications. Then, there’s ReactJS , a JavaScript library developed by Facebook and Instagram team, which is an awesome front-end framework providing a different approach for building UI on the client-side. [Java web development services](http://www.softteco.com/services/java-app-development) will still be in demand for building web apps. 
Really? I have it seen seldom happening. Any example to try out with JITWatch? Also not everyone deploys with the Oracle JDK.
It's a secret. Sorry.
It's not a violation to make it hard to download the distribution from the website, though, is it? The agreement is for use of the website. And I don't know what it means (nor do I have time / passion to find out myself). But I had the same feeling, too.
Mission accomplished! It happens to me way too often too.
The only way it would not be a violation would be if by agreeing to download OpenJDK through the website, that you agree not to distribute the program despite it being GPLed. However, Red Hat does not own all the rights to the GPLed program so this would be impossible because they could only get you to agree not to distribute the parts they do own (they cannot squash Oracle's ownership). If this is upstream OpenJDK (and this is just a build with an installer) then any code contributions Red Hat makes would be owned by Oracle (Red Hat would own only the installer). In either case, you could always get someone to distribute their copy of OpenJDK to you outside of Red Hat's site. It would not be a violation if it were hard to get binaries or source initially from their website, but once the binaries/source are out there then it must be really easy to get the source.
Indeed, but do you really use S(t)AX APIs directly, or do you use XSLT instead?
Sure, but the GPL means once someone has hold of the binaries they can redistribute them anyway.
Jeez. Cool down man. Grab a pill or something...
GNU Compiler for Java, I'll bet. Look inside for META-INF/manifest
Kotlin isn't doing value types. Scala has "value classes" but they are only a layer of type safety on existing primitives. Real value types require bytecode support.
Scala is so last year.
They are fighting a losing battle. With things like Docker, Spring Boot or NodeJS, you don't need big iron application servers or enterprise java anymore (though admittedly, Spring Boot does use a subset of Java EE). https://blog.fabric8.io/the-decline-of-java-application-servers-when-using-docker-containers-edbe032e1f30
IntelliJ Ultimate it's my favorite, but you have to pay (my work pays licenses) On the free domain eclipse and then netbeans. If you are going to do swing stuff go for netbeans, everything else Eclipse.
There have been azul openjdk builds for Windows for a long time though 
Thanks for the suggestion!
Curious; in the 'free' domain why not IntelliJ CE? 
You should give all three an earnest try, and pick the one you like. Being said, netbeans is my personal favorite, with IntelliJ as a close second. [For Java, I do mostly SWING Desktop GUI stuff with some EE projects thrown in for good measure] Eclipse is a distant third; I desperately want to like it [since it has some neat plugins], but every time a new release comes out I give it a try, and I cannot fathom how anyone can tolerate such unusable crap
Compiler for java ... It has option to compile java to NATIVE code, not only to byte code. Generally speaking, around 80 % percent of Java code (base librarires) can be compiled directly to machine code. Java compiler that comes with JDK can of course do no such thing. It compiles to intermediate language ByteCode, which is in turn interpreted in Java Virtual Machine. There is a white list of base java classes, that can be used in source code to be compiled to machine code by GCJ. 
huh, not many people like Eclipse in this thread. In my opinion, Eclipse is great: everything is in one window, code suggestions are pretty good &amp; you can customise it pretty easily if you want to.
Getting rid of the tabs was maybe the best change I ever made to IntelliJ. Ctrl+E is superior. 
Eclipse. Because I've always used it and I'm turning into that old fart who doesn't like new things anymore.
&gt; Java compiler that comes with JDK can of course do no such thing. The Java compiler that comes with the standard Oracle JDK or the OpenJDK cannot. The Java compiler that comes with the Oracle Embedded JDK, IBM J9 JDK, PTC Perc Ultra JDK, JamaicaVM JDK, ExcelsiorJET JDK, CodenameOne JDK, Multi-OS Engine JDK, IBM i JDK and many other commercial third party JDKs can of course compile to native code. Also Oracle is in the process of making an AOT native compiler for the Oracle Java SE JDK as commercial feature, as of Java 10 or later timeframe. This knowledge should be more widespread in the Java community, not only among us compiler geeks.
Are you planning to start programming in Java? Are you lost in the sea of tutorials, and books, and forum threads? Learn how to get started from this handy Beginner's Guide! http://www.softteco.com/blog/java-web-development-service-start-coding-java/
I can not relate to this. I use a debugger nearly daily. It's an easy way to get into problems other people produced or to catch Nullpointers and such things. 
Here we go again.
If you have absolute control over your software then maybe you won't suffer much for this. If you work on any kind of team (open source or industry) then expecting well written, nicely logging code everywhere is a pipe dream. If you're contracting and jumping from code base to code base it is even worse.
[It changed in Java 8](http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/java/util/HashMap.java): &gt;Implementation notes. &gt; &gt;This map usually acts as a binned (bucketed) hash table, but &gt;when bins get too large, they are transformed into bins of &gt;TreeNodes, each structured similarly to those in &gt;java.util.TreeMap. Most methods try to use normal bins, but &gt;relay to TreeNode methods when applicable (simply by checking &gt;instanceof a node). Bins of TreeNodes may be traversed and &gt;used like any others, but additionally support faster lookup &gt;when overpopulated. However, since the vast majority of bins in &gt;normal use are not overpopulated, checking for existence of &gt;tree bins may be delayed in the course of table methods. &gt; &gt;Tree bins (i.e., bins whose elements are all TreeNodes) are &gt;ordered primarily by hashCode, but in the case of ties, if two &gt;elements are of the same "class C implements Comparable&lt;C&gt;", &gt;type then their compareTo method is used for ordering. (We &gt;conservatively check generic types via reflection to validate &gt;this -- see method comparableClassFor). The added complexity &gt;of tree bins is worthwhile in providing worst-case O(log n) &gt;operations when keys either have distinct hashes or are &gt;orderable, Thus, performance degrades gracefully under &gt;accidental or malicious usages in which hashCode() methods &gt;return values that are poorly distributed, as well as those in &gt;which many keys share a hashCode, so long as they are also &gt;Comparable. (If neither of these apply, we may waste about a &gt;factor of two in time and space compared to taking no &gt;precautions. But the only known cases stem from poor user &gt;programming practices that are already so slow that this makes &gt;little difference.) &gt; &gt;Because TreeNodes are about twice the size of regular nodes, we &gt;use them only when bins contain enough nodes to warrant use &gt;(see TREEIFY_THRESHOLD). And when they become too small (due to &gt;removal or resizing) they are converted back to plain bins. In &gt;usages with well-distributed user hashCodes, tree bins are &gt;rarely used. Ideally, under random hashCodes, the frequency of &gt;nodes in bins follows a Poisson distribution &gt;(http://en.wikipedia.org/wiki/Poisson_distribution) with a &gt;parameter of about 0.5 on average for the default resizing &gt;threshold of 0.75, although with a large variance because of &gt;resizing granularity. Ignoring variance, the expected &gt;occurrences of list size k are (exp(-0.5) * pow(0.5, k) / &gt;factorial(k)). The first values are: &gt; &gt;0: 0.60653066 &gt;1: 0.30326533 &gt;2: 0.07581633 &gt;3: 0.01263606 &gt;4: 0.00157952 &gt;5: 0.00015795 &gt;6: 0.00001316 &gt;7: 0.00000094 &gt;8: 0.00000006 &gt;more: less than 1 in ten million &gt; &gt;The root of a tree bin is normally its first node. However, &gt;sometimes (currently only upon Iterator.remove), the root might &gt;be elsewhere, but can be recovered following parent links &gt;(method TreeNode.root()). &gt; &gt;All applicable internal methods accept a hash code as an &gt;argument (as normally supplied from a public method), allowing &gt;them to call each other without recomputing user hashCodes. &gt;Most internal methods also accept a "tab" argument, that is &gt;normally the current table, but may be a new or old one when &gt;resizing or converting. &gt; &gt;When bin lists are treeified, split, or untreeified, we keep &gt;them in the same relative access/traversal order (i.e., field &gt;Node.next) to better preserve locality, and to slightly &gt;simplify handling of splits and traversals that invoke &gt;iterator.remove. When using comparators on insertion, to keep a &gt;total ordering (or as close as is required here) across &gt;rebalancings, we compare classes and identityHashCodes as &gt;tie-breakers. &gt; &gt;The use and transitions among plain vs tree modes is &gt;complicated by the existence of subclass LinkedHashMap. See &gt;below for hook methods defined to be invoked upon insertion, &gt;removal and access that allow LinkedHashMap internals to &gt;otherwise remain independent of these mechanics. (This also &gt;requires that a map instance be passed to some utility methods &gt;that may create new nodes.) &gt; &gt;The concurrent-programming-like SSA-based coding style helps &gt;avoid aliasing errors amid all of the twisty pointer operations.
There are all kinds of performance optimizations that you can't break down. You just have to comment them so the next guy understands why you didn't implement the "legible" code that you found took 4 times as long to run. 
A debugger is an absolutely amazing tool. It allows you to quickly find bugs in code (often not your own) before fully understanding it. It allows you to have a look at the call stack (super useful when using libraries) and even modify variables on the fly and evaluate expressions. If you only ever work with your own code, you're highly privileged. Of course you'll always know how it works and won't need any help understanding it.
Where even "big iron" is only ~40mb in total size and starting up in a second. Then this will be even smaller than that. And both can be used perfectly fine with Docker. We use it all the time (TomEE WebProfile deployed as docker image)
Yes, i really like that one! I currently use it to develop apps with libgdx, schoolwork(am student) i do in netbeans since it is the most commonly used at college
I had a stack very similar to yours. After many years fucking with Glassfish, about 8 months ago I finally made the switch to [Wildfly](http://wildfly.org/) and it was the best decision I ever made. Honestly, fucking with Glassfish was none-stop. There was always some issue with it. Wildfly is far more stable, gives better error messages, and once yo figure it out, is much better to configure. Also, the migration is pretty painless. Just switch out the Glassfish dependency for Wilfly's and change a few xml files and you should be good. Also, Wildfly is based on JBoss, so even though it's fairly newer and you won't find as much info online, if you have questions just look for JBoss questions and they should mostly apply. Stop wasting your time with Glassfish, Make the switch and you'll be much happier.
You are right! I think that is the best solution for the problem (I have been reading about it a lot) but - sadly - the Glassfish is not my decision. :(
That sucks. Well I'd try to convince whoever to switch. But if you absolutely can't, give me some time and in a bit I can try to dig up an old Glassfish install I had all set up well for Windows (after much fucking around with it) and send it to you. Edit: Also, remind whoever you have to convince that Oracle has competing products and a vested interest in people NOT using Glassfish and using their enterprise offerings instead. You're essentially using a test product that no one really gives a shit about any more.
WildFly is not really based on JBoss, it's a beta (community/unsupported) version of JBoss. It's at the moment also not newer. The last JBoss EAP release is newer than the last JBoss WildFly release.
True, but if a majority of your code base is a performance critical section that needs to be handled this way, then you are either an outlier that really requires special handling, or you have a series of really bad technical decisions. At least in java it is easy to hide such sections behind a sane interface.
That doesn't sound right! Some questions: * Are you limited to GlassFish 4.1 only? You couldn't move to 4.1.1 or the latest Payara Server? (disclaimer: I work for Payara) * What exactly are you trying to deploy? Lots of EJBs, just WAR, etc? * Could you upload your server.log to pastebin or somewhere so I can see what happens in deployment? 
Oracle kinda abandoned GlassFish, didn't they? Commercial support for GlassFish was stopped a long time ago, and commits to the OSS version have all but completely dried up. These days Payara is the way to go, they are fixing a lot of bugs in GlassFish that Oracle can't be bothered with and are providing commercial support for if you need it.
&gt; I don't really see the difference. You kinda implied that JBoss was the old server, and WildFly is the newer thing that came after it, which is not the case. Also based on, even though Red Hat themselves uses the term, is questionable. Would you also say that Windows 10 - public beta 1 is "based on" Windows 10? It's a bit weird to say it like that, isn't it? &gt;It's newer than Glassfish and also has more momentum/community support/fervor than Glassfish. It's also newer than Windows 3.1, but that was not the point being made, was it? You can't say "WildFly" is newer than "JBoss". It just doesn't make sense to put it like that. It would make sense to say that JBoss WildFly 10 is newer than JBoss EAP 6.0 and JBoss EAP 7.0 is newer than JBoss WildFly 10. GlassFish pretty much stagnated, but Payara lives on. And Payara 4.1.1.162 is pretty new. And when Payara 4.1.1.163 comes out, it'll be newer than WildFly 10.0.0.Final. 
Yea, exactly. So whether he switches to Payara or Wildfly, he should do one of them. I chose Wildfly bc I was so frustrated with Glassfish in general I didn't want to just move to a new version of it. And I'm happy I did.
It uses linked list to store collided elements, from Java 8 onward an enhancement is done to replace this linked list with the binary tree once a threshold is crossed. This will boost worst case performance of hashmap get() from O(n) to O(logN)Sometime back I had written a blog post about this, you may like to see http://javarevisited.blogspot.com/2016/01/how-does-java-hashmap-or-linkedhahsmap-handles.html . 
Your statement is only true for Java 1.7 and before, no longer true for Java 1.8.
TL;DR just use mvn install assembly:single
Fair enough, use whatever tools you want. Personally I'm comfortable using a debugger and find it extremely useful. 
Yes, the implementation is different but on the surface it looks the same, what with smart casts after null checks and what not…
Indeed /u/pjmlp as /u/sievebrain says, if you look at the hotspot-dev mailing lists there has been a load of vector related code committed over the last year or so. Sometimes they refer to it as SIMD, so you might have missed it if you were Googling.
My two main stacks at work are .NET and JVM, depending on the project, so being on what is latest on Java also matters to me. Thanks for the heads up.
Yeah, right. And trade it for NULL that is not even equal to itself. 
Math.arcSin()
&gt; It compiles to intermediate language ByteCode, which is in turn interpreted in Java Virtual Machine. On x86 platforms, "hot path" bytecode is compiled to native x86 machine code by [HotSpot](http://www.oracle.com/technetwork/java/whitepaper-135217.html#client). So it's not really accurate to say that the bytecode is interpreted. Rather, the JVM uses a mixture of interpreting and compiling. Bytecode benchmarks are used to decide what to compile to native code. That native code itself is benchmarked, to decide which pieces of code to recompile more slowly with optimization turned up. This is known as [tiered compilation](https://docs.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html).
Even OpenJDK has native code compilation on OpenJDK 7 and up, as [HotSpot](http://openjdk.java.net/groups/hotspot/) was open sourced.
What do you not like about Eclipse?
 array_merge(&amp;$myArray, &amp;$Another_Array); (Tip: Arrays in PHP have value semantics.)
I notice that with the Oracle JDK, the `/jre` subdirectory is over 185 MB. With this OpenJDK distribution, the `/jre` subdirectory is 98 MB! I know that OpenJDK omits some of the `com.sun.*` classes that you shouldn't use anyway, and some of the proprietary monitoring executables that Oracle throws in. However, a 50% reduction in size seems kinda extreme. Which half of the Oracle JDK is missing here? 
I use Emacs. It's a decent IDE with an excellent editor. All other IDE's are decent IDE's with lousy editors. 
I use [butterflies](https://xkcd.com/378/)
Wow, finally version 1.03! I was waiting for it for so long. No, when we will get 1.0.4? I heard there will be revolutionary changes!!! And don't forget to make multiple posts here on reddit when it come, so no one will miss it.
You welcome
&gt; I'm not even sure what point you're trying to prove That JBoss/WildFly is a marketing trick and that not everyone sees how things really are.
Eclipse
This is the best tl;dr I could make, [original](http://arstechnica.com/information-technology/2016/07/how-oracles-business-as-usual-is-threatening-to-kill-java/) reduced by 91%. (I'm a bot) ***** &gt; This time, it&amp;#039;s happening to Java-more specifically to Java Enterprise Edition, the server-side Java technology that is part of hundreds of thousands of Internet and business applications. &gt; As the company fought in court with Google, Oracle executives had already defunded and gutted teams working on Java EE. The absence of any official comment from Oracle has led some within the Java community to question Oracle&amp;#039;s commitment not just to Java EE, but to the whole Java platform as well. &gt; June 2013 Oracle changes the license on an open source version of Berkeley DB from a BSD-style public license to the Affero General Public License, which requires users to provide source of their applications to anyone who connects to them over a network and to apply a GPL v. 3 or AGPL license to their code. ***** [**Extended Summary**](http://np.reddit.com/r/autotldr/comments/4qrn6g/how_oracles_business_as_usual_is_threatening_to/) | [FAQ](http://np.reddit.com/r/autotldr/comments/31b9fm/faq_autotldr_bot/ "Version 1.6, ~74597 tl;drs so far.") | [Theory](http://np.reddit.com/r/autotldr/comments/31bfht/theory_autotldr_concept/) | [Feedback](http://np.reddit.com/message/compose?to=%23autotldr "PMs and comment replies are read by the bot admin, constructive feedback is welcome.") | *Top* *keywords*: **Oracle**^#1 **Java**^#2 **open**^#3 **source**^#4 **company**^#5
This project could use a vagrantfile / docker-compose.yml for development environments ... Thanks for sourcing this.
Java isn't going anywhere and there are enough alternatives to EE that it wouldn't be the end of the world if they stopped supporting it.
That doesn't mean it lacks a native code compiler. Nor does something being a .EXE binary mean that it's native code.
You could just downvote and move on.
Spring for example
It's 1 alternative yes, but how do you think Spring will do with Java EE gone? They sort of keep each other sharp now. Plus, that Spring actually builds on Java EE, it's not a completely isolated thing. And what other alternatives are there? You said there were "enough", Spring is only 1.
I don't know about /u/HerrVoennchen, but I personally don't like what many perceive to be Eclipses strength: everything is a plugin. Let's give an example: Many enterprise projects use Maven as their build system (pros and cons of which are a separate issue). Oficially there is the m2e plugin, bundled into Java EE edition of Eclipse and developed independently from base IDE. Not bad, You would think. Except pretty much every single build phase and plugin needs its own connector to m2e. Many of which do not exist. Integration with IDE commands is nonexistent. Most developers in my office told me this about using maven integration: "Don't - You're better of going to command line and executing mvn eclipse:eclipse and the importing it as Eclipse project". This is not the case with NetBeans. Tight integration into IDE commands (main Clean and Build command executes mvn clean install), integration with IDE dependency management (or rater the other way around - adding a dependency in IDE adds it straight to maven project files). IntelliJ is somewhere in the middle in this regard: dependencies are synchronized only from maven to IDEA, executing a single goal is a non-issue and you can define your own run configurations to run - there are no default configurations.
For each of the areas where EE provides functionality, there are probably at least a half dozen frameworks that do the same thing. Don't really feel like googling and listing them out here.
I mean, you can certainly have JIT compilers and AOT compilers that compile to something other than native code, and Java did indeed start off as a [p-code system](https://en.wikipedia.org/wiki/P-code_machine) which lacked a native code compiler. For a while the native code compiler was a paid-for add-on offering. But that was quite a long time ago at this point.
The original comment and this whole thread is about GCJ. So it is 100% about AOT compilation to native code and its redistribution. So how does Hotspot provide the same features for code redistribution as GCJ?
Clicked on the complete list of of changes, was greeted with 'Sorry, you can't view this page'.
I'm personally holding out for 1.0.3 R2
..... Just curious. I have used both Spring and Java EE, and prefer Java EE because I end up with tiny wars that hot deploy quickly. But, appart from this, I wouldn't really say one is much better than the other. But, what is it about spring that you prefer, just so I can get my head around why there are so many spring advocates... 
I give up
Makes sense but it requires some manual steps. I guess the release procedure is automated as much as possible, including the release announcement.
It's always easy to say "there are better options!" or anything like that. But when you *actually* need to start a new project for a half decent company you soon learn that's it's not so easy and that Java EE (and Spring) are pretty good deals. Yes, BB23-coder may claim that TopFrameWork-X is the best he ever saw. So you check it out, and when you test it something crashes. So you ask BB23-coder again and he says you only need to add package WonderCode. So you look for it, and WonderCode isn't there. So you ask again, and the response is, "Oh... you only need to compile it from source, but it doesn't work out of the box, and you need to add a little integration code, but that's 5 minutes of work". So convinced (or wanting to be convinced) that all those other things are so much better you attempt it, and 5 minutes become 5 days, and then you have it running, sort of, and something fails, again. So you again ask BB23-coder and he doesn't reply anymore. Really, everyone always thinks everything else out there is SOOOO much better, until you ACTUALLY have to use it all.
You nailed it pretty good. An IDE with a deep plugin concept is basically good. But eclipse misses the point of no return where this turned into an disadvantage. Even a basic Java console application does not run out of the box without configuration. I as a developer working my ass off to deliver the best features and (more important today) seamless and easy using experience possible. And I expect (to a descend grade) the same from tools I'm using because I'm the customer to these tools. Eclipse may deliver this to obviously many people which is fine. But it doesn't work for me and I'm thankful to have a choice. :)
Going by the top comment he apparently meant a jar file. But hey, at least you got upvoted for your answer :)
Very helpful example! One question tho, when you are retrieving a token you use `btoa(`acme:acmesecret`);` Why wouldn't we want to put the user's actual credentials in the header? Thanks 
JavaFX.
I am very satisfied with Kotlin. I used it to write a small migration tool which extensively makes use of pattern matching and it really saves many lines compared to plain Java without being overly complex like Scala. Keep up the good work!
They even have `ArrayList` patched for value types already: http://hg.openjdk.java.net/valhalla/valhalla/jdk/file/62c3b03ef4ed/src/java.base/share/classes/java/anyutil/ArrayList.java#l170 Hope to live to the day when Valhalla released.
Look into visual vm
It's standard oauth2 mechanism. You authenticate user posting his credential and authenticate app using basic auth header.
gradle is a DSL which is a turnoff for some.
I've heard the Pivotal Labs guys pronounce it "haughty-OS".
I've been very happy with Dropwizard, and know of at least two public companies using it. edit: There must be some really butt-hurt devs going through these comment threads down voting whatever isn't their preferred technology. Grow up.
XML is not a programming language, and shouldn't be treated as such.
Uh what? That second article just describes how they wrote their very first node.js application. The very first line of the article is: &gt; For the most part, eBay runs on a Java-based tech stack. Our entire workflow centers around Java and the JVM. The faster this fad of running Javascript on servers dies, the better we'll be. 
True, what I really want there to be able to say `T.class.getConstructor()` or maybe even `T::new` with a method reference (the later would only work for zero-arg constructors - the former would fail at runtime if unavailable ). _ideally_ I want static methods as interface contracts - since `T` is generic, you'd have to constrain it with `&lt;T extends SomeInterface&gt;` to use any of these style things. Having to pass in a factory makes for a somewhat arse API design IMHO, that could be mitigated with implicit arguments ala Scala, Idris tho.
Even `&lt;T extends SomeInterface&gt;` won't cover the fact that you want `new T()` to be valid since you can't specify constructor requirements in an interface. What's the big deal with passing a `TFactory` instead of a `T`, anyway? Besides, with Java 8, you don't even need to create a factory class, just ask the caller to pass you a lambda that instantiates the object and you put the requirement where it belongs: on the caller. I've never understood the point of requesting `new T()` to be valid. 
&gt; have completeley dumped Java Yeah I've heard of that fancy Java to node.js translator. It works miracles. It can also convert COBOL to node.js, direcrly in production with no downtime
If anything, you'd pass in a `Factory&lt;T&gt;` so that its tied to the same type, in a _generic_ fashion. One reason tho - and this is more for the ability to have a static method contract than a constructor, but it make certain functional patterns possible in a cleaner fashion, such as a `Monoid` type instance: public interface Monoid&lt;T&gt; { static T zero(); T append(T other); } Currently you no means of specify a contract for the class, everything has to be on an instance of that class. So with the above, in order to generate an empty instance of something that implements the interface, you either need an existing instance in which to call `empty()` on also pass in an additional `Supplier&lt;T&gt;` argument - but it would be nice to be able to specify that the contract for the interface requires certain behaviour of the class, not just its instances. Languages like Haskell etc. don't suffer this since all functions _are_ static, including class member functions.
&gt; If anything, you'd pass in a Factory&lt;T&gt; so that its tied to the same type, in a generic fashion. Yes, of course. As for monoid, and type classes in general, I don't think it's realistic to expect this kind of support in a language that doesn't support higher kinds (I'm also not sure I see the connection between that and `new T()`). 
Ew, they're going to duplicate `java.util`?
You can indeed create an instance of T if you have a lambda. https://github.com/benjiman/lambda-type-references/blob/master/src/test/java/com/benjiweber/Examples.java#L23 http://benjiweber.co.uk/blog/2015/08/04/lambda-type-references/
Rather than using a mythical generic constructor with `new T()`, I was meaning you could provide a contract means for creating an instance. If `T.class`was available somehow - and have that return the class of which ever real class is being currently bound to `T` then we could get most of the way - only you'd using reflection. Even being able to refer to `T::new` as a method reference, relative the bound `T` would be handy. There havn't been _many_ cases where I've wanted such behaviour, but there's been a few where it would have certainly made some of the libraries/APIs I'm writing a bit cleaner to use.
You understand that value types are exactly what Valhalla, the source of this post, is working towards right? They're doing a pretty great job so far if you follow the mailing lists.
No, pretty certain they're not... It's just easier to develop it like this.
I always found the one in IntelliJ itself pretty good. For long term production monitoring of performance then Dropwizard metrics or any kind of statsd type thing works well (have used datadog a lot and influxdb). 
Just make sure you make a backup copy of your left pad function ;)
It's because of the Ask Toolbar installer ;) Seriously though, JMC alone takes almost 60MB. It's an Eclipse RCP application. The executable (`jmc.exe`) is just the starter `.exe`. The rest is located here: %JAVA_HOME%\lib\missioncontrol
&gt; Hope to live to the day when Valhalla released. [Ironically, this is impossible](https://en.wikipedia.org/wiki/Valhalla)
n
IntelliJ itself has no profiler, only YourKit Agent to profile the IDE itself, what are you talking about?
Play, anyone?
Yeah I usually do SPA with it. You can pretty much do whatever. I used mustache rendering as well and it supports wicket and velocity and all that crap via bundle plugins. Drop wizard is just glue on top of bootstrapping and jersey. You can do whatever suits your fancy 
&gt; I figure those omissions would explain less than 10MB JavaFX itself is about 50-70MB (webkit lib is huge ;)
I'm Stupid, What's wrong?
Try that with Java 8. You cannot do it: public static &lt;T&gt; void method() { T[] array = new T[0]; }
If you use the ninite installer, it's replaced by nothing.
My apologies you are indeed correct. I was thinking about NetBeans. The peril of switching back of forth is they kind of blend in your memory :-)
In C# you can put a restriction over a generic type T and the compiler knows that new T() is valid. Something like T implements new(), in pseudo Java. I was expecting Valhalla to steal that idiom
-&gt; /r/javahelp This sub is for discussions surrounding Java. 
-&gt; /r/javahelp This sub is for discussions surrounding Java. 
I don't need to login to view individual issues. But I need to login to see release notes? I just think there's some wrong security setting somewhere...
Oh, yeah. Anything by Cay Horstman is good. He is the best technical writer I have ever read. (And I'm a picky S.O.B. when it comes to technical books. )
http://plugins.jetbrains.com/category/index?pr=&amp;category_id=44
Solar Microsystems:D?
As an aside, I've read you can put Desktop apps for sale in the Windows Store and then it doesn't matter what they are developed in, as I understand it. Though I don't know how long Microsoft will allow non-UWP apps.
Incredible
 "zero".replace('z', 'h') works only for that input
Hmm tables... like this? #i5-3570K @4,4GHz: Compilation | Indexing; general responsiveness; EDT responsiveness ---------|---------- - 7m 23s 432ms | 168 223ms; 4/166 sluggish; 2/166 sluggish - 6m 17s 494ms | 162 336ms; 3/160 sluggish; ok - 4m 18s 319ms | - 4m 18s 175ms | 
Well it is one of the cheapest and it looks like that it is fast only on paper, at least in my case cleaning of output directory was 2-3x slower than on MX100 (10-20s difference). It is known that if you want SSD for work, then 850 PRO or something else, never EVO. The problem is that most benchmarks test a write/read performance, not delete.
The speed difference is probably to do with the fact that the MX100 is a MLC SSD while Samsung's EVO SSDs are all TLC with SLC emulation/cache to try and cover some of the inherent slowness of TLC.
Probably. It is really bad at deleting stuff - http://i.imgur.com/yo56ISn.png
Could someone explain how to read the data? What do the numbers (5/171, 3/166 etc.) mean? Is the 'sluggish'/'ok' just a matter of personal experience? Various rebuild times are just successive rebuilds? 
Catch all exceptions, leave it empty, and forget about it. 
I simply moved cache files to a persistent ram disk, not only did that speed things up.. It also lowered my CPU temperature dramatically. I guess all that constant ssd access in a laptop can heat things up inside. Ssd is Samsung 850 evo. I did not follow instructions on internet. Instead I used symbolic links in windows for cache and index folders
Sure I bought mine for 79 CAD in Christmas shopping season when CAD was lower than now . Liked it so much I bought another. Personally I think this is a great price for a 5 year warranty ssd. 
Get a PCIe drive and watch shit fly around so fast you'll think you hired NASA to construct sewers. Intel 750 was the first one I got, put some m.2 Samsung 950s in laptops and have been happy with those as well.
i7 920 right?
more like where you can compare stuff better. I always had to scroll up and down to search if the specific aspect was compared. like | | Win 7 | Win 10 | |-------------|-------|--------| | Compilation | ... | ... | | Indexing | ... | ... |
What's your indexing like if if you swap from using CMS GC to G1GC?
Already did that, everything was worse or equal.
I know the examples are trivial. So I'd like to know where this is useful in real life.
Recursive data types like trees, which is in the example, is a super common structural matching use case. Pretty much any algebraic data type (including inheritance hierarchies, think polymorphic jackson deserialization....). Literally anywhere you use the visitor pattern to get around endless non typesafe instanceof checks Lots of use cases. Languages like f#, Haskell, and scala heavily leverage pattern matching and structural decomposition. 
2 more MB of last level cache and faster memory clock speed will do the trick.
I'm just guessing but from my knowledge OpenJDK isn't nearly as optimizing as Oracles, it may be that the extra code required to recognize the extra optimizations that can be made balloons this out + the API's and resources that arn't included in Open
Looks amazing to me.
I have been doing this for some time now (even using "match" as the church function name) and it works really well (e.g. leads to good, well-maintainable code). I usually throw in another function "matchVoid" which takes Consumers instead of Functions, doesn't return anything and only produces side-effects.
FTR IJ can be built from source: https://github.com/JetBrains/intellij-community The Community Edition is the basis for Android Studio. I went for IJ because it tended to have experimental support for things long before NB and Eclipse but YMMV.
I definitely agree, but the case is (was) that until Java 8 it wasn't really possible to apply FP principles, so industry adjusted by using GoF patterns everywhere (and remember we're talking about Java, the biggest enterprise ecosystem in recent years).
[The book was first published in 1994](https://en.wikipedia.org/wiki/Design_Patterns), mostly targeting C++ development, shortly before [Java made its first appearance in 1995](https://en.wikipedia.org/wiki/Java_(programming_language%29), certainly not with the "enterprise" as a target audience. [Lisp had been there since 1958](https://en.wikipedia.org/wiki/Lisp_(programming_language%29), so there would have been definitely some potential for "the enterprise" to go a bit less object oriented. Also, since you mention the "enterprise", XML was about the most enterprisey thing that was ever invented. And with XML came [XSLT](https://en.wikipedia.org/wiki/XSLT) (1998), which is also a functional programming language that knows pattern matching. In Java, we're just about to recover from this absolute madness of the 90s, when they even tried to push objects into RDBMS like Oracle, PostgreSQL or Informix. At least, *that* never made it into mainstream
They are downvoting you because you show the tipical "I know better" FP silver bullet attitude. I disagree with you because GoF gave a very neccesary common jargon to comunicate previous solutions found in practice. I can tell anyone "this is a decorator" and probably he will understand perfectly. And don't tell me a decorator is composition because in OOP 90% is composition.
&gt; They are downvoting you because you show the tipical "I know better" FP silver bullet attitude. So, pretty much like they did 20 years ago when everyone showed the typical "I know better" OO silver bullet attitude? :) I explicitly tried to be differentiated wrt this by saying *"in more than half of the cases"* - which still allows for almost half of the cases to be OK to be implemented in OO. &gt; And don't tell me a decorator is composition because in OOP 90% is composition. I... oh well. Call it a decorator, then. :) I agree. At the time, jargon did help. The GoF book didn't actually do damage. OO did. The jargon would not have been necessary if people didn't insist on making *everything* an object. Anyway, still no one who downvoted me has shown to me why the visitor pattern is better than pattern matching.
Maybe I wasn't clear, but I meant that **in Java** applying FP principles wasn't really possible before Java 8 due to its (language and design) limits. Java wasn't really designed with any but OO programming paradigm in mind. What it meant in practice: GoF book was considered _the_ book for Java programmers / architects, who, by coincidence, have become majority in "the enterprise" as Java grew larger and larger in our industry. Now there are millions of Java programmers who learned exclusively OO / GoF programming style, which obviously makes me sad, but hey! - Scala is also there (tiny note: just convince your company it should use it instead of Java).
&gt; Maybe I wasn't clear You were, and I think we're saying the same things. &gt; Scala is also there (tiny note: just convince your company it should use it instead of Java). That is a *very* risky bet. While Scala does help creating much better internal DSLs than Java, it is also: 1. Extremely hard to implement it backwards compatibly 2. Not so sure where lightbend will be heading with Scala 3. Probable that Scala killed Slick (in my opinion) (Yes, I'm aware of the conflict of interests here)
the video is blurry
could you explain what tools you use for the persistent ramdisk? And what exactly did you copy to ramdisk? ( IntelliJ + jdk + source? or also mvn cache ?)
The problem with FP people is that they do not accept any other techniques, whereas programmers knows that FP is good only for simple things; otherwise it is really a mess to debug and to modify (the addition of an if can be a nightmare). So, Ok to promote FP but please stop saying that GOF or OO is really bullshit because this is not true. 
I'm the author of this presentation, as well as for the [High-Performance Java Persistence](https://leanpub.com/high-performance-java-persistence) book. Don't hesitate to reach me on this kind of topic.
I was not convinced at first either, but I thought it was surprisingly easy (and fun) to work with. Why do you think this would be harder to maintain than for example an Angular app (if you do) ? The total size of the application ended up a lot smaller than most other TodoMVC examples.
To be fair, I wrote without *writing* JavaScript x)
FYI there's apparently a subreddit dedicated to that product where your post might be more useful to its users.
I definitely don't think it will replace Angular, but about half the Angular projects I've seen have been too basic to justify using Angular in the first place. 'Very basic application work' is the category most projects fall into, I think. Personally I found the intercooler syntax very easy to read and understand, and it felt similar to writing an oldschool non-js app (you just add a few ic-attributes when you're done). Makes progressive enhancement easier too. I understand the skepticism though!
It's not dead. I worked with the lead developer for this tutorial. They released a version last week. Last commit seven days ago. 1.0 scheduled for this fall.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/intellijidea] [Real world performance comparison between i7-6700k and i5-3570K (Skylake vs Ivy Bridge) in IntelliJ (x-post \/r\/java)](https://np.reddit.com/r/IntelliJIDEA/comments/4r7l1m/real_world_performance_comparison_between_i76700k/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
No.
Will cars replace motorbike ? Hell no.
ahah! fair enough! xD
I wrote my first database backed web app more than 20 years ago. I've written them in (in no particular order) javascript, java, scala, python, C#, ruby, C++, and PHP. It's ok if you don't share my opinions and I'll be happy to be wrong someday. Let's talk again in a decade. 
You're right. OK, should a person learn node.js ?
I'm curious your motivation for posting this. Are you genuinely curious ?
I don't see any reason not to, depending on your industry. it's caught on quite a bit in smaller shops and social media, but as I mentioned above, best case scenario it won't gain mainstream acceptance in larger corporate and military development for a couple of years. 
cool. What have you learned ?
i also suffix param names and method names. it's concise, and makes the intention clear when i want it to be clear.
So, wait, does Optional::stream just produce a stream over 1 or 0 elements?
&gt; Why are applets on a webpage considered a security vulnerability? **Applets** are not the security vulnerability; the **Plugins** (NPAPI) that run the applets are - because they are often not written properly - the **NPAPI** Plugins have been removed from most major browsers and thus applets can no longer work. &gt; Is there a possible obstacle course to traverse in order to distribute an applet via webpage? No, because, as I have elaborated above, the **Plugins** that enable applet execution do no longer work and are no longer supported by browsers. ----- &gt; I always start out with applets, and then switch to JFrames at a certain point in the curriculum. Why don't you just start with *console applications*? There is nothing wrong with console programming. Graphical programs are often confusing for beginners - console programs win in that matter. &gt; they are very useful for allowing new students to see visual output from the things that they program. Console output can be just as good. Have you heard of a company called *INFOCOM*? They have written some of the arguably best, most immersive Roguelike, RPG-like *Interactive Fiction* games - and they solely ran in the console.
ideally yeah. but javadoc rots easily, and in a team of devs with varying abilities it's safest if the info is right in their face. also adding OrNull to a method name means you see it at the call site.
you could also return a Runnable (functional interface) from the match method and call run on the result: save you from using 'return'.
Yes, and that's a great way to handle it. It's much more similar to Scala, actually. 
https://github.com/javabeanz/owasp-security-logging/wiki/Security-Related-Log-Events
As former technical techer/tutor I honestly cannot condone your ignorance in that matter. Your questions can be answered with some simple Google queries and especially in your profession it should be one of your utmost duties to stay informed and on top of the technology - even if it is on account of your own time. Your post hints that you seem to be locked in your own, little ecosystem of a syllabus that you have built upon a now obsolete (and originally questionable at best) technology and that you are searching for any excuse to stick to your outdated course structure. Make yourself familiar with the new ways of how to distribute Java applications over the Internet (Oracle has tutorials on these technologies) and maybe also look into the approaches of reputable institutions, like the **University of Helsinki** (http://mooc.fi/english.html) on how they teach Java and OOP/OOD - you won't find a single applet in the whole, very comprehensive syllabus.
Optional *is* useful. I suspect you don't really understand how it is supposed to be used if you are weighing the pros and cons of it vs a variable naming scheme.
I'm an 18 year old who started teaching myself Java when I was 11. I program in Python, C, C++, C#, both iOS languages, and most web languages except for Ruby on Rails. I will be entering college as a CS major this fall.
&gt;Why don't you just start with console applications? Of course I do. Fundamental programming concepts are always first - I thought that was implied...? I start with applets for them to be able to visualize, after they have learned the fundamentals.
i guess not. i've played with the api, i've read blog posts, and it still seems a bit worthless. it's as if it's in the jdk for completeness, like java.util.logging.
Been thinking about this post a bit more. I think there are two things that _might_ change my opinion on node being a player in the long run for larger projects. 1) If typescript is used, I think the typing problem can go away. I'm not a fan of java's verbosity, but the flip side is libraries with parameters and no definition as to what they are, are broken. So original style JS is broken. 2) The callback hell. Promises only paper over this problem with a slightly better syntax. But fundamentally I don't believe humans think in terms of callbacks, and I believe that code that uses them ( all JS code ), is hard to follow. There is some hope in the future with the async/await stuff, but really JS needs true continuations to really work properly. Human's should not bend their minds to make the computer understand, that is why we no longer program in Assembly for the most part. If I have to write a function just to continue writing my function, then the language is broken. So I could imagine a future style of typescript with lots of libraries now written to do await async properly, that it might fly. It ain't here now. 
I think applets are dead as a platform you can count on in a web browser. Chrome, Firefox and IE don't support them out of the box, and they are unsupported by mobile browsers. If you are thinking about writing an applet, consider: * Why does it have to be an applet? * If because it has to be a rich media application, then why not use html5 canvas? * If not using html5 canvas because you want to code in Java and not JavaScript, why not [GWT](http://www.gwtproject.org/)? My advice therefore either to use JavaScript/HTML5 Canvas or Java/[GWT](http://www.gwtproject.org/). I personally dislike HTML5 as a platform on which to build performant and efficient applications, but, in 2016, and prior to the rise of web assembly and the CAWL, it's the only common platform that we have, and GWT makes it easy for the Java programmer to access that platform whilst maintaining the benefits of a statically typed language.
TL;DR: *"the work we're doing is not a standard."* *"we may eventually take it to a standards body"* *"Although we're starting with Java EE as a basis, we're not going to tie ourselves to that."*
I use a debugger for the same reason I don't walk to my holiday destination. I don't always use a debugger to solve every problem, but a debuggers solves more problems than it creates.
Here was wrong information.
Hungarian is fine if used as it was meant to be used, but the type system is often better. One of the most common uses has to be instance variables. I wouldn't go so far as to make a type for those, so naming them differently works pretty well. That said, `Optional` is extremely useful, though I tend to even call the variables `maybeFoo`, which leaves room for a `foo` if I retrieve the value too many times.
Consider the following example: if(foo.getBar() != null)){ Bar bar = foo.getBar(); if(bar.getBaz() != null){ bar.getBaz().bloop(); } } vs Optional.ofNullable(foo.getBar) .map(Bar::getBaz) .ifPresent(Baz::bloop) I think the latter is far more readable and less bloated.
I like IntelliJ. Everything you press needs to be pressed once. Good autocomplete. Good shortcuts for searching. Intuitive use of space and tab for prediction. You learn some of the shortcuts and you'll wonder how you ever survived without them. It also predicts what classes you want to add and has a bunch of nifty features to personalize code style and integrate it with git and github. Everything in IntelliJ just works like it's supposed to. Netbeans is alright. I personally dislike the shortcuts and some stuff seems downright annoying. The autocomplete is quite irritating. Plus it's kinda hard to read in, but I'm rather used to Darkula. Eclipse requires too much setup for something that should be simple.
I don't understand this idea that print statements are better for multi threaded code. In particular I have found that print() statements are slow, to the point where the presence of a print statement will often affect the racey behavior i am trying to debug. They also add a memory barrier in the form of a synchronized block that would not otherwise be there.
Pretty sure that's wrong. Return gets discarded in this situation. A method reference can still coerce a method to return void. Go test it; java happily lets you treat a non-void method as a void-return consumer. The breaking issue is actually the fact that the return type changes at all. It's a byte-code level thing that can actually be hacked around if you try hard enough, but per the specification, a method is uniquely identifiable by EXACT return+name+parameters. Changing return at all in any way is breaking at a bytecode level, with the exception of some generics compiler workarounds.
You provided discussion and for that I'm giving you an upvote. Together we fight the good fight!
Every place I've worked that has adopted node after having used a statically typed language has always switch back to statically typed languages after seeing the maintenance horrors of any node js app that does something more complicated than the most basic CRUD operations. Some of these companies even wrote medium posts about how great the switch to node was. They just wrote those articles too soon before the headaches set in. If anything is going to eat significant java mind share, I think it's going to be Go. I've seen companies with the right requirements switch to go and love it.
So much boiler plate saved! No more if present checks!
 if(foo.getBar() != null &amp;&amp; foo.getBar().getBaz() != null) { foo.getBar().getBaz().bloop(); }
I had a rough go with it at first. I finally understood that its real value is to reduce incidents of NPE caused by returning `null` from a method invocation. The typical API of e.g. `Customer getCustomer(int id)` which returns `null` if the corresponding customer can't be found, allows the caller to do things like printName(dao.getCustomer(42).getFirstName()); either out of laziness or ignorance. Instead, you can return `Optional&lt;Customer&gt;`. This forces the caller to deal with the fact that a customer might not be found. (Granted, they can still abuse the `Optional` API, but that's not your fault or problem!) For the typical case the result looks more like dao.getCustomer(42).ifPresent(this::printName); You can also use `orElse` and `orElseThrow` as appropriate; in this case you might have printName(dao.getCustomer(42).orElse(Customer.NONE).getFirstName()); Here, `Customer.NONE` follows the null object pattern and `getFirstName()` returns "". On the anti-pattern side, don't use Optional as a field or a parameter. And try to design your code so that Optional is needed only at boundaries between your code and the outside world. Your own objects should be almost entirely null-free. 
&gt; I thought that was implied...? Not really: &gt; I always start out with applets That kinda strongly implies that you you know...start with applets.
Certainly more readable than the mess created by the various `accept()` / `visit()` methods.
Sure: **Extremely hard to implement it backwards compatibly** The language is incredibly rich in features. There are some features, like `implicit`, which I don't think can be used in a backwards compatible way. They help client code compile things that are completely unexpected from an API designer point of view. Now, if you add an implicit function somewhere at a later stage, what happens? Will this create compile-time ambiguities in your client code? When? Another thing is that Scala libraries have to be compiled towards a target Scala version (I may not be up to date on this one). So, even the Scala libraries themselves aren't really being developed (binary) backwards-compatibly. I'm not saying that this isn't possible, but it is much more difficult than in Java, where maintaining a DSL is already very difficult. **Not so sure where lightbend will be heading with Scala** This isn't official information, and not necessarily true, just my interpretation of what's going on, after reading up on the topic and talking to people from Lightbend. While Scala continues to be an interesting business for Lightbend in projects, their platform is JVM oriented and unopinionated about the concrete JVM language. In order to make [their investors](http://www.wsj.com/articles/lightbend-raises-20m-led-by-intel-capital-1464262200) happy, they have to do so, because the Java market is immensely bigger than the Scala market, and by selling Lagom, ConductR, Spark services, etc. they're targeting the Java EE market, who might change platforms, but probably not languages. Apart from Slick (see below) all their libraries (Akka, Play, etc.) work on Java as well. Besides, Martin Odersky doesn't make a secret out of the fact that he's "bored" by plain old Scala and looking into [new type system architectures](http://www.scala-lang.org/blog/2016/01/02/new-year-resolutions.html). This stuff is extremely interesting, but I don't think it resonates well enough with (or responds to enough real-world needs of) the enterprise masses that the investors like to please. Thus: Not sure where they will be heading with Scala. **Probable that Scala killed Slick (in my opinion)** (disclaimer: I work for the company behind [jOOQ](http://www.jooq.org), so my answer is obviously biased) The Slick approach is academically interesting. Already when SQL was first pushed by IBM and later Oracle, everyone knew that SQL is the technically inferior approach. There were better ideas at the time that were more mathematically and syntactically sound. But Slick won't work for the same reasons that other SQL alternatives never worked. SQL is incredibly *useful*, and Slick cannot take advantage of many of those useful SQL features, it allows only for a very basic set of queries. Some criticisms: 1. It's very hard to write even simple joins with Slick. The nested nested nested tuples that are created by Slick joins are just a PITA. They're technically correct in terms of relational algebra (which also nests tuples), but SQL made a "wiser" choice by flattening joined tuples to the top level. It helps getting the job done quicker. 2. The `Option` semantics that is imposed by Scala is wrong for SQL. I've [criticised this a couple of times in the past](https://blog.jooq.org/2016/03/15/ceylon-might-just-be-the-only-language-that-got-nulls-right/). In my opinion, monads are often the wrong tool for the job, and Scala rigorously uses monads to encapsulate behaviour. For plain old `NULL`, this is an overkill and makes the type system very heavy, and hard to use in a DSL. In particular, there are many cases where it is also wrong, because even if a SQL table column is `NOT NULL`, it implicitly becomes `NULL` when outer joining, doing unions (in some cases), applying functions on the column, using `GROUPING SETS` (or `CUBE` or `ROLLUP`), etc., etc. I've tried supporting `Option` (or Java's `Optional`) in jOOQ and I came to the conclusion that `NULL` type safety in an internal DSL modelling SQL is just not possible. It's also not that important when working with SQL (especially in Java, where `null` is still a first class citizen). 3. Slick cannot be implemented in Java, and that's another killer for it, given Lightbend's moves towards Java. [It got re-open-sourced and Stefan Zeiger was removed from the project](http://slick.lightbend.com/news/2016/02/01/slick-extensions-licensing-change.html) (working on the Scala compiler). If you're following the user group, you'll notice it's gone quite mute, and the lack of management PR regarding these moves is hinting at the fact that this product just doesn't fit into the Lightbend ecosystem, which bets much more on Spark than RDBMS (a huge mistake in my opinion). 4. We have quite a few customers who are migrating off Slick to jOOQ saying Slick is just way too complicated even for simple queries, and they never really know what the SQL statement produced by a Slick query will be. This makes it rather hard to tune. Even if jOOQ is not native Scala, it works very well with idiomatic Scala (apart from the lacking `Option` type). 5. Slick queries take forever to compile. I've seen reports where a single query took almost 1 minute. No one pays this price, and with Scala further "improving" towards heavier type systems, this can only get worse. Again, none of these musings are official. Just my personal observations and thoughts as an outsider who knows 1-2 people at Lightbend and who competes with Slick.
You are right.
Nice tool to flatMap an Optional into a stream: Stream.of(1, 2, 3, 4) // Stream&lt;Integer&gt; .map(someFunction) // Stream&lt;Optional&lt;Integer&gt;&gt; .flatMap(Optional::stream) // Alternative to filter(Optional::isPresent)
[I knew it](https://jaxenter.com/debate-where-is-java-ee-headed-to-127356.html). This is all an "unfriendly" move away from the JCP. The only remaining question, why didn't they just call it Summer? :)
4 companies involved and a jug, directly using open specs. It's a question what they will add as their own code, and what license that will have and how many implementations of whatever their own code is will have.
I have written this function so many times. //Stream&lt;Optional&lt;T&gt;&gt; .flatMap(opt -&gt; opt .map(Stream::of) .orElse(Stream.of())) //Stream&lt;T&gt; Nice to have it in the core lib. 
You never use `&amp;&amp;` operator?
Says the Spring fan.
i use Map::computeIfAbsent for caches.. it's great :)
bus till no sintactic sugar for optionals. When will be possible to do String?, List? etc ?
Maybe a REST API, take a look at jax-rs.
So because I like working with X more than I like working with Y while I have experience with both you're just going to dismiss whatever I am going to say because I prefer X and you prefer Y? If that's the case fine, but why even respond then?
It's just a very typical response for a Spring fan...
As others said, restful webservices are the standard. A possible alternative is gRPC. It provides features like bidirectional streaming, flow control, header compression, and multiplexing request.
I am interested in the Java Servlet spec updates: "Servlet 4 by comparison is the most significant update to the specification in many years – bringing standard HTTP/2 support to server-side Java developers." A good overview of JEE 8 is here: https://javaee8.zeef.com
&gt; chrome extension Java**Script**, not **Java** - two completely different, unrelated languages.
&gt; As others said, restful webservices are the standard. What's RESTful is mostly a matter of which "REST" subculture you stumble upon. I'd call them "simple HTTP APIs, typically returning JSON" to avoid unclear connotations...
As with most programming interview questions, if you're asked half of these just politely decline and walk out. Any development manager that won't hire you because you don't have the exact value for Double.MIN_VALUE memorized is a moron and you're going to have a bad time. The N resources by N threads is about the only worthwhile question as it actually exercises your ability to solve a problem rather than test your rote memorization of language/library nuances that are easily looked up online.
oh ok, there's a map method on Optional, i missed this :) Thanks!
Client Server, in this day and age, single page javascript apps running in a browser, talking REST with a server. Long gone of the days where the client itself would be a stand alone program to be installed / updated, etc 
I'm a big fan of Vert.x for building micro services. It's got a few sharp edges but I have been pretty happy.
Can you post the github repository where you keep your tests? 
RPC is another options. Though it's more tightly coupled, I believe it's more efficient. Besides, I love love love protobufs!
Instead of worrying about any subculture, just focus on the value provided by decoupling and progressing on the Richardson Maturity Model. Most of the APIs I build do not need to go beyond level two, but they almost always get there as we add features (contextual URLs in response for pagination, CRUD, etc..).
Yeah, it is nice. I've even contributed a little, but in the end I was missing all the nice spring gimmicks very much, so I went back to Jetty for microservises.
Would be interest in seeing the final thing if you can do that on github or blog about it.
Sometimes I'd worry that the getters are expensive and would instead write: Bar bar = foo.getBar(); Baz baz = bar == null? null : bar.baz(); if(baz != null){ baz.bloop(); } Anyhow, no I don't think replacing Java syntax with method calls and inner classes is more readable. That reminds me of how arithmetic is done on BigInteger.
I do use it, but I try to avoid it :)
Or you can just do this in Java 8... opt.ifPresent(consumer1.andThen(consumer2)); 
That doesn't work if your consumers are plain lambdas or method references, which in practice they almost always are. You'd have to cast them explicitly to Consumer which IMO defeats their purpose.
Use regular http (not websockets) and json. One day when someone replaces your Java client with a web client or mobile app, they will be happy use chose that route. RMI has certain benefits but they are mostly for when you need blazing performance or want to retrofit some Java API to work with a remote backend or need inter-process communication or have some sort of enterprise Java stack that works nicely with RMI. For a basic client-server architecture, RMI is usually not the right choice.
What kind of use cases do you have where you need multiple consumers for an optional within the same block? 
Oracle did neither design or build this ecosystem, they merely bought it. Now they are trying to grab as much money as possible to make up from the losses they are going to inflict on themselves by being a terrible company. 
&gt; Oracle did neither design or build this ecosystem, they merely bought it. Now they are trying to grab as much money as possible to make up from the losses they are going to inflict on themselves by being a terrible company. Sun didn't design or build this ecosystem, they merely paid their employees to do it. Sun's employees didn't build and design this ecosystem, they merely did what they bosses told them, for money. ... Let's be serious here. Oracle *is* Sun now. They didn't fly by and bomb Sun and take their hard-drives, they brought in the teams, as well.
Glad to see this project continue to grow and gain traction. Having a wide variety of {young, growing, mature} tools and solutions is one of the best things about the Java ecosystem. 
I couldn't agree more. These questions are worthless at screening competent engineers. They might help you find somebody who could pass a java certification test, but not somebody who could actually get anything done in the real world. 
My point is that OP is asking about **Java applets** which are a completely different ecosystem than Chrome (or Firefox) extensions - they can absolutely not be compared.
I just want to make some clarifications so newbies are not confused by this. The days where a large, "thick", native, stand-alone program are not gone, just less common. There seems to be a particular use case for them that has no better solution for the time being. The "single page javascript" apps running in a browser are still stand alone programs. They're just sent incrementally over the internet and run on a javascript execution and rendering engine. It's just a small change in how we deliver and run apps. The client-server architecture did not change.
Speculative acronym, common android widget library. Essentially means android-like widget library and sandboxed runtime standardised by w3c so that it can be implemented by any browser vendor. I have zero evidence this will ever happen, entirely speculative. Effectively because HTML5/DOM/JS/WebGL/Web-Workers/Web Components are not good enough. Web assembly is a performant runtime and quantum leap forward but still isn't a platform without ultra efficient low level bindings in addition to easy to use and easy to scale components. 
Apache Thrift. Write an ibterface language and build clients/servers in all the possible languages 
Document/Specialize your loggers
http has the advantage of working through firewalls, and you can take advantage of caching too if you want it. Plus the tooling is great, and you can use a browser to test and debug. 
This is programming help and as such should be posted in /r/javahelp as is indicated in many places on the subreddit. **Post removed:** Programming help
Thanks for sharing!
&gt; If you know how to code, that should be obvious to you: the intelligence is in the implementation, not the signature (that any young programmer would be able to replicate, as demonstrated by the first judge of the case). Well you must also think art is in the paint chemicals, not in the brush strokes laid down on the canvas. And to say "that any young programmer would be able to replicate the signature" goes directly against the point you're making. It means the implementation is trivial, as long as you have an API to copy from. This makes the API the hard part, and the implementation the trivial part. Not to mention the API is informed from the possible implementation of it (in terms of performance, underlying system capabilities and so on) as much as the users of an API. An API already suggests its implementation. So if you copy an API your work is more than half done, it's like doing a test with a cheat sheet. If you think making a set of foundational APIs *from scratch* (you know, rather than "replicating" them) is easy, I can only guess you never found yourself in a situation to work on such a project. Or you'd never say designing them requires no intelligence. And purely empirically... if the APIs were the easy part, junior programmers would be designing the APIs and giving them to senior programmers to implement. Think about how much sense that makes.
Cool! I'm looking forward to it. Nice job.
If both are non-null, this ends up calling `getBar()` three times and `getBaz()` twice. This can work, but is problematic if the calls are expensive, and fatal if they have side effects. (Heaven forbid!)
The package your game uses is `com.jmr`, however that site appears to sell server parts. Do you have any relation to this company at all?
No, it's currently my initials. I'm working on a portfolio site on the side and will be updating the packages when that's finished.
If you already own the domain name for your portfolio then you should use that right now rather than waiting until it is finished. It associates your project with you rather than a random company you have no control or part of. It also helps because the longer your stuff is on the internet, the better potential for it to be found. If you do not have one, then you should use `com.github.yourusername` in the interim since your project is hosted on GitHub. 
Would this work with https://github.com/godaddy/godaddy-logger ?
Thank you for such great feedback! I'll hit these one by one: **1.** I was always curious as to why values of the power of 2 were used for chunk sizes, this makes sense now! I'll definitely be switching over to using some of the different ideas that you talk about. **2.** Didn't even think about this as being something that'd hog memory, but it makes complete sense. I'll definitely be working on switching to 1D arrays. **3.** Yes, I tend to use it a lot, I just have to go through and add it to the places that I haven't yet. **4.** Yes I understand how synchronization works. I came across the error and knew the problem, but was short on time so I just left a note. **5.** There are only *the number of blocks in the game* block instances at anytime and because this doesn't, and won't, take up too much memory, I think I'd rather keep it in a more readable format and allow the addition of more properties to be easier in the future. When Blocks are rendered, the only information used is the block ID (for the time being). I will consider the block properties suggestion but I'm worried about there being more complex properties in the future. **6.** This was actually similar to what I was doing in the beginning of development, but items and blocks both have IDs and both work off of the same used numbers. In other words, they are kept in separate arrays, but need to be unique between each other. So no item will have the same ID as a block. Because of this, it is not safe to say that the ID of a block or item matches the ordinal value of the enum. **7.** Yes I was aware that calling the "values" method is very consuming. I'll probably do something similar to what you suggest with defining a static array that is only defined at the start. *EDIT: This was changed and committed to master.* **8.** True, I guess it would cut down on duplicated code, I just had two separate methods for ease of understanding. **9.** Yes, this probably wouldn't be a bad idea either. I don't see a heavy change like that happening in the future, but better safe then sorry! Once again, thank you for all of the suggestions! I'll add these to the README
&gt; If you do not have one, then you should use com.github.yourusername I would discourage this. There's lots of `net.sourceforge.me` and `com.googlecode.me` projects out there. I *love* GitHub, but people loved SourceForge and GoogleCode before that. Domains are cheap! Start building your rep :)
Agreed. I've went ahead and purchased a domain and cheap hosting where I'll keep my personal website at. I have to finish designing it before anything's up though. I've changed the package naming as well to reflect this.
Ok cool. I'm a Java developer myself for around 6 years. Yet I'm only experienced in coding business stuff. Business Services, REST APIs, Databases and this kind of stuff for trading companies. I just can't get my head around how to program a game. How you structure the on-going logic in the game etc. Any advice how to gain knowledge in this field?
Try /r/forhire /r/Java is not the place to post such offers
This site is garbage for android, I gave up at the second code piece. The code goes out of the screen, you want to scroll to the site: TADAA WELCOME TO ANOTHER SITE! It's so godamn annoying.
Then you'd better let them know: © IntercoolerJS.org 2013-2015 on their web site. 
Primarily, this question is better suited for /r/learnjava or for /r/javahelp. I would not suggest using codecademy for Java because the course mainly focuses on syntax, but does not teach enough about *concepts*. I would recommend: * **University of Helsinki MOOC** [**Object Oriented Programming with Java**](http://mooc.fi/english.html) - text based with exercises that need be completed and submitted before being able to proceed. (Uses Netbeans as IDE) * **Java for Complete Beginners** by John Purcell (probably the best and easiest entry into Java) - video based (Uses Eclipse as IDE) - the three links below lead to the same course hosted on different servers. I would use the Udemy link because it has an active community where you can ask questions and get answers. * [CaveOfProgramming link](http://courses.caveofprogramming.com/course/java-for-complete-beginners/) - John Purcell's site * [Udemy Link](https://www.udemy.com/java-tutorial) * [YouTube Series](https://www.youtube.com/playlist?list=PL9DF6E4B45C36D411) * **Derek Banas'** [**Java Youtube playlist**](https://www.youtube.com/playlist?list=PLE7E8B7F4856C9B19) with the accompanying site [Newthinktank](http://newthinktank.com) All of them are excellent and free. ---- &gt; Also if you know any good resources for game development in Java then that would be great as well. Start with plain Java and learn the fundamentals (Python is quite different), then practice and then move on to game development.
you are sounding like a stereotypical architecture astronaut. 
....maybe browse through the shared code section over at [java-gaming](http://www.java-gaming.org)?
Applets in web browsers are pretty much dead. However, you should be able to use the appletviewer command that comes with your JDK to run them and test them out that way, which will load and run them without needing a browser.
I'm not a JEE fan. Frankly, what IS JEE?
There are tons of tutorials online going over the basic architecture of a game. With the knowledge that I assume you have from your other experience, you've already gotten past the hardest part for most; learning and understanding Java fluently. All you need to learn is the theory and architecture behind a game. This overall isn't too hard to wrap your head around and, in some games, will follow similar design patterns to MVC which (should be) used in almost every business application. I'd recommend taking a look at [LibGDX](https://libgdx.badlogicgames.com/) as it lays out a great foundation for building games. It essentially takes out all of the low-level OpenGL programming and gives you wrappers that encapsulates the functionality so that you don't have to deal with it. It also offers some more features that you can take a look at on their website. Overall the library makes it a lot easier to jump in and start programming your game.
When I started this trek myself a few years ago, I found the udacity course on Java to be very helpful. My only complaints are the IDE they recommend you use - perfectly fine for the course, but please do yourself a favor and adopt a good IDE for java afterwards (if not during). [Intro to Java Programming](https://www.udacity.com/course/intro-to-java-programming--cs046)
We are considering various options to deploy the technology: 1) A standalone JS script that could be included by the web site owner in a page to automatically replace &lt;applet&gt; and &lt;object&gt; tags with the CheerpJ enabled applet 2) Browser-specific addons to let any user access legacy java applets
I wouldn't use healing as the opposite of damage, you will reach a stage where you want to have extra information on last damage, or double healing or something, and you will end up just making 2 methods again.
I wonder which runtime library this uses.
That's a good point actually. I could definitely see things like this being added in future. Thanks for pointing that out!
If you are interested in Minecraft there are always people wanting different mods made, or plugins for their servers. checkout spigotmc forums or bukkit.org 
&gt; Use single dimensional arrays [CHUNK_SIZE * CHUNK_SIZE] rather than multi-dimensional arrays ([CHUNK_SIZE][CHUNKSIZE]). Single dimensional arrays are much faster due to being much more friendly to CPU caches. Instead of allocating 51 objects for the multi-dimensional array there would now just be a single object. Due to this, during garbage collection sweeps there would be less objects to consider. I was a little surprised to hear this, and tried to test it out with some benchmarks. I'm not seeing any serious speed difference here. Do you have any more information about flattened arrays and performance in Java?
Nice work from what I read by browsing through the code. I see you have some problems with race conditions, but at least you tried to make your game multithreaded (many devs don't even bother). Will check this out later and run it when I have the time ...
It says it converts Java bytecode to JavaScript, so it probably just uses the official rt.jar. At least that's how the doppio JVM does it. I wonder what CheerpJ does differently. http://doppiojvm.org/ https://github.com/plasma-umass/doppio
Yes I'm aware of the race conditions, I just have to go through and track them down. In the meantime, I've commented out the threading portion of most things. Let me know what you think when you get the chance to take an in-depth look!
Wow! Nice reply. It really is so much easier to get into now than back when I started.
`System.currentTimeMillis()` is the system's wall clock, which means that a time adjustment (to synchronize your clock) will completely throw off your program time and thus make your benchmark invalid (while the benchmark runs you can change your system clock so that you have a faster and possibly even negative run-time). You want to use `nanoTime()` instead since that is monotonic and not affected by this. Also, you are testing an array which only has a size of `4`, with 4 dimensions that only goes up to 256 individual entries. Virtually regardless of whether you use a single dimensional or multi-dimensional array, all of those arrays will easily fit into memory (since the flat array has a base minimum size of 1KiB which is next to nothing when it comes to modern CPUs). The array size is so small that any difference in speed will barely be noticable. Also, when it comes to finding the max value in the flat version, instead of having 4 loops you can just have one.
I used it for some toy projects but I remember it being harder to migrate to newer Jersey since they go deeper into HK2
Fair on the time. Although, I was running multiple samples and seeing small variations. I know milliseconds of wall time isn't a great measure, but the variance it should introduce was smaller than any differences I was seeing. I switched it to `nanoTime()`. Is there a specific entry size that you believe should trigger this? I moved it up to an array with 10K entries (10 on each of 4 dimensions). If I make both of these changes, the flat array performance falls further behind the multi-dimensional array performance (56.76s for flat vs 46.92s for multi-dimensional). Finally, I'm aware that it would be possible to find the max value without using multiple loops in the flat version (and either version could find it inline by recording max as we generate values), but the thing I really wanted to test is "is it faster to do `[r*W+c]` or `[r][c]`?". Even so, I made all of these changes. The results are that the flat version that uses only a single loop to find the max value manages to clock 46.44s on my CPU. So, if I can often avoid doing the `[r*W+c]` style access, yes, flat arrays are better (by a tiny margin). If I'm going to be doing a lot of `[r*W+c]` style access, multi-dimensional arrays still seem to be performing better (by a lot). I suspect the reason that `[r*W+c]` is slower than `[r][c]` is that the math to compute the index isn't even close to free when we're in tight loops like this. Edit: Further reading for the curious: http://stackoverflow.com/questions/2512082/java-multi-dimensional-array-vs-one-dimensional Some of these benchmarks find that the flat arrays a much faster for random access, but this is almost certainly a factor in random number generation which is a very slow operation. There are a few more benchmarks putting flat arrays as marginally faster though. I don't think it's worth changing how your code reads for this kind of maybe performance gain, but if you really need to save out some extra cycles for your program, maybe this is a place to look.
* Stay off Reddit during work hours * Seriously, you have shit to do * Just... log out, turn off the browser * Gowan, beat it * Why are you still here? Shoo! * AARRRGH GO AWAY GO AWAY GO AWAAAAAY * ...could you at least close all of those /r/gonewild tabs? 
* difference between finally, finalize, and final. * difference between JDK and JRE * basic explanation of how object inheritance works (I guess this isn't really java specific). * explain two ways to cause a program to end
8. Stop reading 'X advices to become superprofessional' articles!
Difference between equals and == , hashmap and hashtable 
Blogs posts on productivity are useless because they don't: * define what productivity is * measure what productivity is * survey actual productive developers * show that the things listed make the readers productive
&gt; The example given on the main page is exactly how you should not use a bloom filter. Can you elaborate, it's a pretty common example. Bloom filters are used often for blacklists where the list size may be large but the memory footprint is desired to be low. Another common example would be adding a lot of known bad passwords to the filter, sending it to another party, and then allowing them to do client-side checking of their password security. &gt; Not sure what the advantage of this implementation is over the more feature complete, better documented (and presumably better tested) Guava version. Guava is a higher level library for working with data structures and inter-operating with multiple hashing functions. The goal of this library is to be easy to use and not require the user to understand some of the implementation specific details of bloom filters, like what hashing function to use, how to make derived hashing functions, etc. I specifically wanted to step away from using cryptographic hashing functions, since they are typically much slower and for many purposes the need for cryptographic hashing functions in a bloom filter is limited.
What's finalize? Never heard of it before haha!
It's a method on Object, I'll just quote the javadoc for it, it's pretty simple! &gt; Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. By the way, I work for this company now and they still ask this question, as long as you either get a couple of them right and don't make stuff up they accept the answer as correct. They just want to screen for people who are lying!
I guess most junior programmers never heard of hashtables. When was it?
Is that real? I mean, these are high-school questions.
The problem with the example is that bloom filters can have false positives, so using it to check if something is blacklisted could indicate as blacklisted a key that was never added to the filter. You would need some second-tier object (like a HashSet) to store the actual keys to determine if something was blacklisted or not. The bloom filter would save you that second, more expensive search for the cases where the filter does NOT contain the key. 
&gt; What is dependency injection This is the odd one out. All of the rest are basic questions you'll have to know for the Oracle Certified Associate exam. Dependency injection is more advanced.
IIRC, we used it in some jdbc object cleanup code. Very niche. I'd be surprised to hear it in a junior dev interview.
These are some really easy questions.. I was getting worried that I didn't know much. And the most part are from Silicon Valley start ups and such. More respectable coming from Europe.
something.set(dependency) or calling a constructor are technically dependency injection. 
come on man ive had junior devs flop at these!
1. Write a function which takes an int and returns that int as a Roman numeral (String). The integer can be in the range of 1-3000. 2. Write a function which takes a string that contains a set of brackets and parentheses. Determine if the string passes a certain criteria. For example, ({}) is valid, ({()}) is valid, (({{}})) is valid but something like ({)} would not be valid. I was also asked some generic database design questions about how I would design a database and the tables within given some information in addition to the typical inheritance, access modifiers, OOP questions. This was for an entry-level Java position.
A big reason not to use finalizers is that classes using them require at least 2 GC cycles to actually be collected. It's best just to call the cleanup code manually, or perhaps making the class autocloseable. 
http://ideone.com
The try block is where I try to answer the question. If I fail, you'll help me in the catch block by filling in the information I missed. Regardless, we will finally end this interview. 
We are heavily spring based and get to some more advanced pieces to determine the end of someone's understanding, but those "more advanced" questions aren't typically used to actually say yes/no (unless the interviewee claims to know and clearly lies)
tbh i'd just throw you out the moment you fucked up. EDIT: Come on guys I was eluding to the fact I wouldn't 'catch' his mistake at all but let it get 'thrown' up. There goes all my internet points! 
People love asking whether or not a String is mutable
I interviewed for a Software Engineering position (not quite a junior Java developer) and I was asked about OOP in general as well as some Java trivia like "*what is the difference between final, finally, and finalize?*"
Try this: &lt;http://paste.debian.net/hidden/df99d0f1/&gt;. This is a pseudo random accessing of single and multi-dimensional arrays using a precomposed index table. You can increase the values of some constants provided they are a power of 2. `BASE_LENGTH` cannot exceed 128 (256 would exceed the max array size). Likely when it comes to a game such as this, access is likely to be mostly random and may potentially want to use cached indices when it comes to block access (such as checking only the blocks which are on a given edge). Although it might not be too bad with a two dimensional game, going to three dimensions will increase the amount of jumping required (and a single dimension would likely perform much better in these cases). Unlike the Stack Overflow algorithm (which is unknown), this one calculates the indices that the code should access before running the actual benchmark. My result is: _openjdk version "1.8.0_40-internal"_ _OpenJDK Runtime Environment (build 1.8.0_40-internal-b04)_ _JamVM (build 2.0.0, inline-threaded interpreter with stack-caching)_ A single-core Motorolla 7447A at 1.67GHz, 512K L2 cache. &gt; Single: ffe00000 ns=[229256010, 237957863, 237992243, 245543873, 249460687, 288743856, 518415649, 527604805] &gt; Multi : ffe00000 ns=[811730703, 853719399, 870386262, 891362637, 904634968, 968121723, 1189907962, 1928728481] _openjdk version "1.8.0_40-internal"_ _OpenJDK Runtime Environment (build 1.8.0_40-internal-b04)_ _OpenJDK 64-Bit Server VM (build 25.40-b08, mixed mode)_ A dual-core AMD E-350D at 1.6GHz, 512K L2 cache. &gt; Single: ffe00000 ns=[26330999, 26395679, 26397576, 26438379, 26471717, 26503443, 31009955, 72636029] &gt; Multi : ffe00000 ns=[128692267, 128842804, 129281495, 129559509, 130134336, 131050639, 143498766, 181175579] 
You're hired!
Those valid examples on #2 must be /r/gonewild, /r/gonewildcurvy, and /r/ssbbwgonewild. Not sure about the invalid example. 
Hey there! I'm the author! Thanks for the feedback! I actually did poll the amazingly productive Java team at my start-up, Stormpath. All of the advice is 100% theirs, and only represents tips and tricks that nudged the efficiency/productivity needle for them. As far as defining productivity, I suppose I'm using that in this context to mean working smarter and more efficiently, which I think is clear in the post itself. I'd love to hear back if you don't think it is! They're also totally suggestions based on our internal experience. That experience leads me to believe they'll help others, but I'm hoping our community, and anyone reading, will offer feedback and let us know if we're nudging the needle for them too! Cheers!
Totally does! (I'm the author!) It seemed like a fun twist on a old concept!
Please read the sidebar (as one should every time posting in a new sub), and its "related sub" section. 
Read this reply: https://www.reddit.com/r/java/comments/4rhnoq/im_interested_in_learning_java/d516sif -&gt; /r/javahelp and /r/learnprogramming
This seems like phishing site. Convert AWT application to javascript? You wish ...
Accenture, I bet
You also can analyze HTTP Server logs, i think it store each request in the own logs.
What other people have said, but you get brownie points for mentioning that you can now have default methods in your interfaces. It shows you read up on new language features.
You would be surprised how many graduates couldn't answer these questions. I've interviewed graduates who didn't understand how a for loop worked. These is a reason FIZZ BUZZ is used as a filter by some companies...
Implement Conway's game of life. In C#. But the position is for Java? Well do it in Java and that's bonus points.
You can't maintain state in any interface
Somthing like: He: I see from your résumé you are familiar with Java and Spring? Me: Jeah, I used it for my final year project in school. He: Interesting. Well, since we also see a few Java projects on your Github project we just gonna assume you know the basics. Honestly, I rarely had one of this actual "tests" to determine your skill and the guys that interview you are very seldom assholes.
What's next? Won't be open source anymore? 
If you haven't yet, give Kotlin a quick look, I've not had time to get too far into it yet, but the bits of playing around with it I have done I really like it. Granted if you're looking at a language for employment it'll probably be a hard sell for a while, though I hear it's starting to gain ground in Android development (And Android studio is built on IntelliJ, so that's nice)
TLDR; Oracle was devoting resources to build a more proprietary framework without community involvement. Someone convinced marketing that this was a bad idea and would flop so now we are back to full Oracle support of Java EE. Good News!
Could you theoretically grab it's char array with reflection and change the values? 
Don't give then ideas. I can actually see a world where .net is open and java isn't 
Did Microsoft and Oracle agree on exchanging roles? 
&gt; And Android studio is built on Intellij I thought Android studio is Intellij 
The only thing corporations understand is money. As soon as it looked like the proprietary API would do more harm than good to their bottom line they retreated. This is not unique to Oracle and should serve as a cautionary tale. There's always a group of middle managers that want to make their mark on the corporate landscape. This is why we can't take Oracle for granted and make sure they understand where the path of least resistance and more profitably is located.
I'm still quite skeptical. EE needs more than just press releases full of empty promises. 
This will never happen because Java SE is open source and for enterprise space, we have Spring. (Java EE's market share is far less)
Hey, we are actually looking for java se developer, just spring boot.. and grails legacy application. Berlin 
The truth is that the Java EE specs (and RIs) have often had times of total silence, even during the sun days. That's why I wasn't worried Oracle would completely abandon Java EE. For the specs it doesn't matter much, but I wish there were some organizational changes in the JCP that reflect the unhappiness of the community over oracles engagement in the Specs. For the implementation projects (Glassfish etc.) the silence of Oracle is total poison. Who in their right mind uses a product with which you cannot be sure if a security issue will be fixed or a pull request will be looked at in the next months or even years.
Informative, and I pretty much agree with the approach. 
Afaik Google does some tailoring.
In my experience with them, as a participant at an event and not a potential employee, they acted so arrogant I got a distaste for them almost immediatly.
I've used kotlin extensively and really like it, but it doesn't in any way solve the issues badmoon is talking about. 
Maybe they had a meeting with the grand lizard.
??
That's not an answer. What do you think a Java SE job entails? What do you think that "an SE job" does that "an EE job doesn't and vice versa?
Depends on what you consider Java SE I suppose but there are many companies and applications using the Spring Framework and various other frameworks besides JSF.
If in the very rare event Oracle kills OpenJDK **and** a fork is not started, there is potential for GNU Java to be revived.
Thats a really great question! I just tried it and so far i can change the first character of the string! However chaging the rest is tricky if not impossible and i've hit a roadblock... The char array is actually a pointer to a memory location and i'm having trouble getting the pointer via reflection... Here is my code so far: public class ImmutableStrings { unsafe static void ChangeWord(string word) { Type strType = word.GetType(); WriteLine("Type: "+strType.ToString()); BindingFlags bindFlags = BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Static; FieldInfo field = strType.GetField("m_firstChar", bindFlags); char firstChar = (char) field.GetValue(word); WriteLine("First char: "+firstChar); // Set first character to the letter 'G' field.SetValue(word, 'G'); WriteLine(word); } public static void Main(){ Console.WriteLine("Insira uma palavra:"); string word = ReadLine(); ChangeWord(word); } }
One possible solution is to try and inject a method using Reflection.Emit()...
&gt; From the original description it sounds pretty clear that OP doesn't want anything to do with JavaEE To me it's not clear that he really knows what he is looking for which is why I am asking **him** to answer this question. 
what benefit does memoization bring to this problem? 
Microsoft would likely only welcome them with open arms if they were to switch to .NET from Java.
is there no next char? I haven't tried doing it but I remember seeing in the debugger a chars array that was private... 
Nothing prevents a fork of an open source project. A company can choose to close future versions of a product, but they will have to compete with an open source version.
Of course. Heck, maybe they would even resurrect J# on .NET Core. Wouldn't that be a hoot?! Or disenfranchised customers could just stick with OpenJDK as an interim solution, but if Oracle tried to go fully proprietary at some point, they could seriously screw that up too, FOSS or not. 
Too true. It's just a question of whether the community in question can truly provide for its care and feeding without the help of its commercial sponsor(s). Also, there is the matter of how the community would continue to innovate with it since it can only be called "Java" so long as it complies with Oracle's own proprietary test suite. I suppose "Project JTopia" or whatever would be born out of that, but adoption and mass market appeal require confidence, and this is where Oracle could either excel in bringing the community together, or in disintegrating it.
Developer productivity is a very subjective term. Without defining what it means to be productive, productivity can not be measured. Without measuring productivity, then it is impossible to say what improves productivity and who is actually productive. Therefore, "productivity" blog posts such as this can not make any real claims of productivity. Title the post "Stuff we like" and then it will make more sense.
Did you look all the way in the back? Around the corner? In the old trunk under the bed?
Last time I checked, there was a trashing noise in the trunk, so I'm not gonna go check there again.
Actually nevermind, i'm trying to do this is C# -.- sorry, completely forgot that this was a java question. In java i believe it's possible yes.
Ahah that is true! Anyway, just for the record, in C# it isn´t possible with reflection. It´s only possible using unsafe code: unsafe static void ChangeImmutableString(string word, char substituteChar) { fixed (char* fstr = word) { int count = word.Length; while (count-- &gt; 0) { fstr[count] = fstr[count] = substituteChar; } } }
I downloaded v8, the 64 bit one.
Here's a brief list of things they should probably be familiar with: - Wrapper classes for primitives (e.g. `Integer`, `Float`) - Collections classes (`Arrays`, `Collection`, `List`, `Set`, `Map`, and their respective implementations) - Streams (`InputStream`, `OutputStream`, and their basic implementations) - Possibly the `Reader` and `Writer` classes + their various implementations - File classes (`File`, maybe `nio` stuff too) - `Runnable` - Maybe stuff like `Number`, `BigDecimal`, etc. - Maybe Java 8 stuff like `Collections`, `Optional`, `Function`, `Consumer`, etc. That should cover most of the basic stuff. I'll add to this list if I think of anything else.
You could also try installing the 32-bit one. Although when it comes to Java, the bitness only matters when it comes to native libraries.
&gt; Spring applications are dependent on Java EE as well. It feels like the content of this sub breaks down into... 1. Java EE people yelling at Spring people 2. Java EE people yelling at Oracle 3. Kotlin devs yelling at everyone to use Kotlin ... so I probably shouldn't be contributing to category #1. However, the parent quote comes up in every other thread, and it's just completely false. Yes, Spring has loads of functionality for "playing nice" with Java EE in a mixed setting. However, Spring is in no way shape or form "dependent on" Java EE. You don't *need* to use a single Java EE spec to do just about anything you'd want to do with Spring. It's actually pretty rare to see any specs used other than `javax.servlet.*`, `javax.persistence.*`, and *maybe* `javax.jms.*`. And those three have loads of alternatives (e.g. Undertow/Netty, MyBatis/JDBI/jOOQ, AMQP). The only things in the Spring portfolio that are dependent on Java EE are the things written as add-on helpers for Java EE. Aside from that, Spring is a Java EE *replacement*... not a superset wrapper.
I was asking OP to run the test. I'd prefer hard benchmark numbers. This guy already has a nice set of data so a ramdisk set on top of it would be great. 
After the Glassfish debacle, my company moved to Spring Boot, React, Docker, and Kubernetes. We haven't looked back.
https://www.reddit.com/r/buildapc/comments/4r1ai9/build_complete_i76700k_vs_i53570k44gz_real_world/d4ycb1p I already did that, useless, for some reason, need more investigation. Years ago when I was trying I think Dataram Ramdisk, it actually slowed the build, and it was because I formatted it as FAT32, even though synthetic benchmarks were off the charts. Only NTFS formatted ramdisk was faster than NTFS SSD - but that was probably SATA2. 
I dont think the answer is definitely no, but there is certainly more work in the JavaEE and Spring areas. I think if you know swing or JavaFX you could probably find a job somewhere that needs those skills.
Great, coloured console output. But we still don't have a less verbose config option using attributes. (I realise this requires a new pom schema, which we probably won't get until maven 4)
I suppose using just a date is bad? The major and minor version of my software will probably always be `1.8`. This means my versions are in the form of `1.8.20170707`.
I wonder if Oracle would have had to beg customers to use their proprietary and likely incompatible framework or pay them to switch.
For consumer products this works fine. For libraries, semantic versioning is good enough, and the release is useless marketing oil.
Than how will you know what the update `1.8.20170523` introduced in addition to `1.8.20170313`? Do you know if it was just a bug fix? Or did it add something new? Does not applying this update break things? Am I reciving support for `1.8.20170123`, or do I have to update? Can you answer those questions from the top of your head? For those reasons and more, the Explicit Versioning exists. If the major and minor version numbers will always be `1.8`, why not update to `2.0.0.0` and add clarity to the updated? This way, not only you but also your users will know what they should be expecting when deciding weither to update or not. After all, if you launch daily updates, if they have nothing critical to worry about, why would they spend time (and money) updating to a newer version, so long as you are still offering support for the version they have?
I fail to see the difference between release.breaking.feature.fix and breaking.feature.fix other than adding a release to SemVer.
not really, because unless they can afford to, you're probably not going to recive support for anything except the last `release` version. Sure, it might help with the marketing, but now you'll know for sure that the library with the version 4.5.6.32 is being supported because there is no version 5.x.x.x launched.
How did so many within oracle think a proprietary solution could succeed today? They must be completely insulated behind a wall of delusion and financial panic. 
1. `major` does not equals `breaking`. It could (and does) on SOME projects, but not for too many projects. how you know that they mean that on EVERY project using Explicit Versioning. 2. `release` reffers to recommended version to use. For example, if the version `3.x` is up, you're most likely not going to get any support for any `2.x` version, or, if you're lucky, you'll get a limited ammount of support. I'm pretty sure there should be another point, but at this hour of the day, I can't really think of any reason. I might come back to this, later, if I remember.
The 'common' class (often imported and abbreviated as 'c') which contains the out method. c.out is a good way to sanitize potentially dirty data in JSP files. There is a similar method in the apache library for string utilities. org.apache.commons.lang.StringEscapeUtils Good to know those exist to thwart CSRF stuff. Web dev stuff...
But isn't the changelog there to explain that the change is, instead of it's type? As for the JVM part, I think I get it... the project's rules don't allow for it. But that doesen't means that for other projects you shouldn't try to use Explicit Versioning, whenever possible...
Does nio here stands for non-blocking IO or New IO ?
I have begun [writing a Wiki](https://github.com/jmrapp1/TerraLegion/wiki) that goes over how the project actually functions! It should help out everyone understand the architecture of the code and be able to jump in faster.
Have you read SemVer.org, because you are misrepresenting it. It is very strict about what constitutes a major version bump: any backwards incompatible change MUST involve a major version bump.
It is officially **New I/O**.
GNU's java hit a wall trying to complete the GNU Classpath libraries. 100% bug-for-bug compatibility is very hard. OpenJDK has the same license as GNU Classpath/GCJ. Even if the project is revived, they will probably rebase on top of OpenJDK.
Know your data structures (edited: type of maps, sets, lists, etc), and when to use one or another.
From our codebase: Count | Import --------|-------- 2796 | java.util.List; 2559 | org.junit.Test; 1854 | java.util.ArrayList; 1687 | org.junit.Before; 1629 | org.junit.Assert.assertEquals; 1245 | javax.servlet.http.HttpServletRequest; 1073 | java.util.Map; 948 | org.junit.Assert.assertTrue; 828 | java.util.Calendar; 816 | org.slf4j.Logger; 809 | org.slf4j.LoggerFactory; 701 | java.util.Locale; 686 | java.io.Serializable; 681 | org.springframework.beans.factory.annotation.Autowired; Or to summarize: Java collections, JUnit, servlets, Spring DI and Spring MVC. 
All over the place. I pretty much never touch EE.
My top two classes: [StringUtils](https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/StringUtils.html) from [commons-lang](https://commons.apache.org/proper/commons-lang/). [FileUtils](https://commons.apache.org/proper/commons-io/javadocs/api-2.5/org/apache/commons/io/FileUtils.html) from [commons-io](https://commons.apache.org/proper/commons-io/). (Or [IOUtils](https://commons.apache.org/proper/commons-io/javadocs/api-release/org/apache/commons/io/IOUtils.html) if you're dealing with I/O streams instead) Very simple and common things, but the above classes make your code a lot shorter and clearer.
Of course it would just draw its graphics to a canvas element. You'd just have to implement the Java graphics API accordingly. I don't think that would be an insane amount of effort. Edit: Some examples of what can be done with LLVM/emscripten/asm.js: https://github.com/kripken/emscripten/wiki/Porting-Examples-and-Demos
[If you're still the #1 (and #2) database](http://db-engines.com/en/ranking), despite the excessive price compared to others, that way of thinking doesn't seem too far-fetched
Why do people keep trying to reinvent semver with extra or ridiculous changes?
You're making the argument that companies must have a linear hierarchy to their product lines. 1.x.y.z - a basic/value product 2.x.y.z - a mid-range product 3.x.y.z - a luxury/flagship product First of all, what if the company offers a second basic/value product line? Should its release number be 4? Second of all, this year the company offers 3.0.0.0, and next year the company releases a breaking update, 3.1.0.0. Is 3.0.0.0 still supported? For the love of God, stick to goddamn SemVer, and make an effort to keep your dependencies up to date. If it's too difficult to keep your dependencies up to date (updating a backwards-incompatible dependency means having to update too much code), then this is a code smell signaling that you have a monolith which needs to be broken up into smaller, more manageable components. Leave marketing to the marketers.
No Oauth2 with JWT. 
I would add `java.time` or at least `Date` with `Calendar`
The thing is, Java applets already are fairly restricted that way. They run in a sandbox where they can't access the local file system and can't communicate with third party servers. They can only communicate with their own hosting server via HTTP, which is basically the same thing as AJAX. I'm not sure why you'd ever use JDBC inside a Java applet, but I guess you could technically use an embedded derby or h2 database on a virtual file system in the browser's localStorage. However, I'd argue that persistence is generally better handled server-side.
you can add date and timestamp as metadata through SemVer
The problem with the "7 habits" title is that there are so many similar articles out there, each listing 7 or (more often) 10 interesting things. Following the link, you'll find lots and lots of ads. If you're lucky, that is. These articles are honeypots trying to attract as many readers with as little effort as possible, so I wouldn't be surprised to catch a virus by visiting such a site.
I guess my answer is a bit late, but better late than never :). Thanks for your feedback! I'll try to include a "What is it all about" section next time. It's just a bit difficult to add it to the existing articles without ruining the narrative.
You forgot: 4: Intellij users yelling at Eclipse users 
I like the cover. Makes it easy to find on a messy desk. 
I never understood how to apply SemVer to client applications. There’s a new button in the application — which number do I increment? Did I change the API? Does a GUI application even *have* an API? How do I change a GUI in a non-backwards compatible way? The scheme proposed in the linked article makes a lot more sense to me, in case of a client application. For libraries, SemVer seems to be quite appropriate.
From what I heard it's not *many*. It's a few people at the top, and because of Oracle being so hierarchical, the many just have to comply. No inside knowledge, but this is what I've heard. 
Currently yes, but at one point the syntax included versions using the "@" operator, as in "moduleName @ 1.2.3". &gt; It is the responsibility of build tools and container applications to configure module paths so as to avoid version conflicts Thing is, from what I've read in early drafts of the module system, the idea was that loading different versions of modules wouldn't *cause a conflict* in the first place. Every piece of code would see the module version they require. This is how OSGi operates, and how Node.JS' NPM operates (see the highlighted answer: http://stackoverflow.com/questions/16774896/dependencies-versions-conflicts-on-node-js). This effect can't be easily replicated by build tools. And container applications still would have a lot of work to do to replicate it (custom class loaders and so on). Which brings us back to a situation where the provided solution by Java is simply not good enough on its own to use as a solution for real-world modularity in apps.
For a graphical UI, I'd say UI changes were features or bug fix, unless you change the complete way you the application. For a command line app, adding an option would be minor. Changing or removing an option would be major. Also think about any backwards incompatible config or state files, or network protocol, or similar.
It depends on how you are setting up your REST services. By just using standard HTTP headers, it becomes difficult to communicate descriptive errors to the client. For example in case of bad request you may want to provide information on why the request was bad. If I go the HTTP headers way I will have to use custom headers and custom codes to provide that additional information. With a response body I have an opportunity to provide additional information in a descriptive and structured manner which I can standardize across all errors. Hence this becomes a design decision. Whichever way you prefer, if you plan to provide additional information you will have to implement it, be it any language or framework. If you use Spring Boot, by default you get a good structured way of error communication via the response body. If you wish to not use it, it can be turned off by a simple configuration. Hope this helps.
Be sure you don't log passwords :)
Academic tool replacing Ant. Build definitions in Java. "Fast" means "fast compared to Apache Ant", which is like winning a race against a snail. From their publication: "We have developed pluto as a Java API1 and used it to realize builders for Latex, Bibtex, Java, and 23 other builders that we migrated from an existing Ant build script developed by others for the Spoofax language workbench" The paper compares to "GNU make", "shake" and ant, MSBuild, Ninja, SCons, Gradle, and CloudMake, vesta, bazel, sbt, tup. Not to Maven, pants, buildr, buck, leiningen, scons, rake, waf, and so on. Parallel builds seem to be only a planned feature, and no word on long-term caching (caching more than the last version) or cache sharing. Also I saw no mention of fine-grained rebuilds (e.g. rebuild and retest only the one java-class that changed). Not sure if their effort was worth it, compared to forking any of the existing tools and adding whatever clever feature they need to that. In particular Java to define builds does not seem likely to win over users of other buildsystems.
I actually played with it a few days ago but that creates a lot of magic. I mean what is magic ? Once you understand what it does, it's not magic anymore but I still felt quite overwhelmed by Jhipster. It would be great if we could just let the generator, generate the boilerplate auth with thymeleaf views and not angular at all. ( Don't get me wrong, I like angular but I don't need it in every project )
Strings! The inner `char[]` field in `String` got swapped for `byte[]` and will only hold 50 % of data if the string in question is ASCII-only. Also good, good, gooooood improvements for `String` concatenation. It is true that I haven't yet seen a benchmark of a realistic application, but the possible performance impact of these changes is huge.
Good keynote ! Thanks for sharing 
I also stumbled over this improvement but assumed it was rather neglectable. Would be interesting to see the real impact in first real-world application benchmarks. What are the reasons/experiences for you to look forward to this particular improvement?
I think Java really began to change substantially with the introduction of the generics based on type-erasure in 1.5. I'm still quite uncomfortable with this design and feel that in comparison Lambdas and the Jigsaw module system fit much better in the existing Java design-
It's very easy to clean everything and replace with your templating library. Takes a lot less time than configuring everything yourself.
Nice presentation, but can I get a text only version? The font looks awfully tiny on mobile, and the effects don't let me resize (what is this? A website for ants?)
50% less memory used by Strings for most applications. This should also improve cache performance. I actually was just looking at this because an application I work on holds a large number of strings in memory and they are never outside of the ASCII encoding, this should reduce the memory consumption quite a bit.
Worst. UX. Ever.
My advice: look at Kotlin (JVM programming language with common edges with C# and great interoperability with Java) and JOOQ (amazing ORM with an API that looks like good old SQL). Intellij Idea is my favorite IDE but I haven't tried Eclipse in years. Spring boot and even Ratpack are good starting points for the kind of task you described.
Well, I guess that depends on your engineering practices. Different solutions have different pros and cons, and each individual will pick one solution or another depending on the pros that they like and the cons that they can tolerate. For instance, personally, I like having consistency, which means I don't like having multiple versions of the same library in my classpath. Because I like working that way, then a module system defined the way Jigsaw defines it is beneficial. But that's mostly because my head spins when I have multiple versions of the same thing. Other people can handle multiple simultaneous versions very well, and therefore they like the possibility of choosing and picking the best of each of them. For those people, a module system like Jigsaw is probably insufficient... I get that. But then again, if you want something like that, you already have OSGi and NodeJS, as you pointed out, so why producing another thing that does the same? I think a benefit of defining Jigsaw this way is that it gives you a range of possibilities, if the way it's done doesn't suit you, there are alternatives.
Are you on mobile?
Sorry for your bad experience. Need to have a look on this. What device are you using? 
Know that work is going to get a lot easier and nicer for you.
&gt; I would consider skipping java to move to Kotlin. Can we all just put down the Kotlin kool-aid? Kotlin is nice for individual developers but it's never going to gain ground with larger teams. Sorry to burst your bubble... 
Definitely go with Intellij, it's the equivalent of Visual Studio (probably better), with all of Resharper's functionality (Intellij came before Resharper). Intellij understands Maven and other build systems well, so you can have the same build script you use outside the IDE act essentially as the IDE's project properties file which is pretty useful. LINQ is basically in Java, there just is just not syntax primitives to support Java's version (the [Stream API](http://www.oracle.com/technetwork/articles/java/ma14-java-se-8-streams-2177646.html)). Language wise, there's no value types in Java (maybe in Java 10, [escape analysis](https://en.wikipedia.org/wiki/Escape_analysis) is implemented in the Hotspot JVM), enums in Java are more like classes, and there's lack of some other little features you seem to be able to find in other more updated OO or imperative languages like C# (null-coalescing operator, class properties, async/await). Kotlin does not have any where near as a great documentation or search results, but it will make a C# programmer feel much more at home (it even has primary constructors). Luckily you can intermix Kotlin and Java code with no problems, they can call each other without any extra work IIRC (don't do it much myself).
My company is currently rewriting a big chunk of our Node codebase in Java. Most of the team members were .NET developers before the Node switch. So, some practical observations: * IntelliJ is the easiest IDE to transition to from VS. Similar look-and-feel and the built-in code analysis is great if you're used to having ReSharper to lean on. Lots of plugins, too. * Be prepared to deal with some annoyances with the language. You're going to miss LINQ, properties, async/await, and run-time generics (a JVM limitation). * Check out Project Lombok if you hate writing boilerplate getters and setters and for other cool annotation-driven features. * Spring Boot and Spring Data JPA + Hibernate is fairly similar to something like a WebAPI/MVC + Unity + EF stack. Wiring is done through annotations, and it should look instantly familiar. \* JUnit, Mockito and Powermock should cover just about all of your testing needs. Very little friction for us transitioning from Jasmine (Node) and MSTest + Moq.
If you can convince them to get IntelliJ go for it. Such a fantastic IDE it's hard to explain fully. Yes eclipse is more familiar to begin with but IntelliJ is just so freaking smart and makes coding/debugging much less stressful
Just create your own Ascii class to store your strings. You do not need new JDK to fix your issue. 
I hate eclipse.. IntelliJ is much much better
Probably because semver is rather broken.
Bye bye auto-properties and var and at least you sort of have LINQ with lambdas. Java has an enormous infrastructure that isn't provided by Oracle/Sun itself, but rather 3rd parties. With C#, the infrastructure is more Microsoft-based (Visual Studio, Azure, etc).
When dealing with web services (REST/SOAP), a good tool to consider for integration testing is WireMock 
https://en.wikipedia.org/wiki/Spring_Framework#Data_access_framework https://www.reddit.com/r/java/comments/44dv36/net_to_java/ https://www.reddit.com/r/java/comments/48qy6a/transitioning_from_c_to_java/ 
Since you're starting essentially fresh, look into Retrofit and RxJava, they can make parallel calling multiple REST endpoints a pleasant breeze.
School assignment? No thanks. 
The APIs are one of the few places where it doesen't affects THAT much, but still, if you want to still update 1.x, how would the users know?
Shitty, automatically generated article that basically says nothing. Don't bother posting such stuff in the future. **Post removed:** Autogenerated spam
If you're going to go the REST/microservice way make sure that you have * a common naming policy of properties of payloads / query parameters * a policy for common structural properties (f.e. for results of paginationable requests) of payloads * a documentation repository by service and endpoints - even if it's just a list of links to your (documented) source code (navigable in rthe browser) * an explicit separate log of all internal requests made, including tracking across separate services - if you include a request ID across all your requests, this allows you to easily debug a call across multiple microservices In general REST has been better to work with than SOAP, primarily because REST is loosely coupled in comparison to SOAP.
If this is for a homework assignment then requesting assistance is very risky and may cause you to get kicked out of the course or even expelled. Also, any freelancer would write in their own specific style. If the instructor has seen your previous code and is an experienced programmer, it would not be that hard to tell if someone else wrote the code even if the syntax and code style matches. 
Then you lose all the intrinsic optimizations for strings built into the VM
Calling async/await a "little feature" is a slight oversimplification.
Why are you moving when nobody except you knows the language and there hasn't been done any research on things as simple as IDEs and libraries yet?
No worries there. I'm actually quite good with rest services, which should really be the same in any language, and the logical framework for what we are building has already been designed with many of the exact same ideas you mention. Thanks! 
http://pastebin.com/6KFi7eYJ Just change the database url, password, driver, username and create a table where you have username field and password field. 
I work at a very large company where 2/3's of the teams used java and the rest c#. A decision was made at the top to make the swap to Java because more people within the company currently use it. My team is but 25 people in a company of thousands and we didn't really get a say in the matter. We have an external java dev who is strong in our interest points who will be doing our code reviews and helping us get set up. I came here because I want the most current POV on things, whereas with my work you frequently find things that could be done better, but isn't, because the teams aren't up to speed with the newest ideas and tech. A real problem tbh. 
Well, 3+ bytes sequences are already handled in a nasty way - see all the codePoint methods in [`Character`](http://docs.oracle.com/javase/8/docs/api/java/lang/Character.html). The problem will be with the "normal" 2-byte characters. If the String will hold non-ASCII data, memory storage will be the same as is now (every char takes 2 bytes), but a little more encoding work is needed while working with such Strings. See more here: https://www.youtube.com/watch?v=wIyeOaitmWM
In terms of making the language switch, you'll have little trouble. You'll miss a few conveniences/features that C# has and you'll have to get used to different syntax and conventions. Here are some suggestions/advice, I didn't entirely limit myself to Java stuff but I'm opinionated and don't mind sharing my opinions. ### Developer Tools There are two mainstream IDEs, Eclipse and IntelliJ. They are pretty feature-compatible but some people do have a strong preference for one over the other, so let that be a "developer option". Also, I strongly encourage you to use code quality tools like Checkstyle, PMD, and FindBugs. They'll help you write better code. As a side note, consider using SonarQube to help you track code quality/metrics. ### Testing and Code Coverage For straight-up unit testing you'll probably pick JUnit. It's by far the most popular, though TestNG has its fans. Spock is a good choice too. I personally consider the use of mocking tools like Mockito to be dangerous, as they make it all too easy to tie test code to implementation code. And then you stop refactoring, because your supposedly hidden implementation details are being twiddled by mocks. Keep your unit testing and integration testing separate! There's a [good article here](http://zeroturnaround.com/rebellabs/the-correct-way-to-use-integration-tests-in-your-build-process/). You might consider FitNesse/Cucumber for acceptance tests, if you're into that sort of thing. For code coverage tools [have a look at this comparison table](https://confluence.atlassian.com/display/CLOVER/Comparison+of+code+coverage+tools). ### Database / Persistence As already mentioned, the Java ecosystem is large and diverse, and for any problem/need there are typically two or three top projects. The most popular Java database integration library is Hibernate, but I suggest you also check out jOOQ. (And Google for comparisons/discussions.) If you have big data needs, take a look at Spring YARN. ### Architecture A very common architecture is Spring Boot with Spring MVC, with deployment on either Tomcat or tcServer (the "pro" version). Tack on Spring Security to protect things, and Spring Integration to talk to things. The [Spring Guides](https://spring.io/guides) are good "how do I..." resources. There is some excellent Spring advice [in this article](https://spring.io/blog/2015/11/29/how-not-to-hate-spring-in-2016). Especially the bits about layers and separation of concerns. And for heaven's sake please don't pollute your business logic classes with framework code. Someone else mentioned microservices, and I'll echo that since you are building web services. ### Build and Deploy, CI, and Infrastructure Make sure your build process is automated and platform-independent. Developers should be able to deploy to localhost regardless of whether they're running Windows, OS X, or Linux. I'm assuming/hoping you'll be deploying on a Linux-based infrastructure.... Use either Gradle or Maven for your build scripts. I prefer Gradle; it's more concise and readable, and since Gradle scripts can easily utilize Java/Groovy code it's relatively easy to customize your build. You may end up needing a "deploy.sh" script which does setup/configuration of the OS environment before/after application deployment. Treat these kinds of scripts with care; again, developers need to be able to deploy locally from the IDE. Jenkins is the most popular CI server by far, but I've heard good things about Bamboo. Nexus seems to be pretty much the default repository for hosting dependencies. For source control you may as well use Git, just about everyone else does because it really is very good at what it does. ### Miscellany I already mentioned adopting code quality tools but I'll go ahead and repeat that because they're really valuable. In addition to that, the Apache Commons and Google Guava libraries should be at your fingertips. Apache Foundation has a bunch of other libraries/tools as well. It probably goes without saying, but since you're starting from scratch there's probably no real reason not to use the latest release of everything. Use SLF4j (Simple Logging Facade 4 Java) with, probably, log4j or logback for your logging. GSON or Jackson for your JSON needs. 
Whichever IDE you decide to use, make sure everyone gets the Findbugs plugin. It's a static analysis tool that may help when you don't know how to do something in a Java way. More important is that the builds do not succeed when Findbugs finds issues at a set confidence level. The other things I can think of are * Use a minimum compliance level of Java EE 6 * JSF 2.2 is a competitor to SpringMVC but you can use Facelets with Spring When using REST, you can annotate your methods with @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML}) and allow the client to request in which format it wants to receive the Response (first is default). We did this when we were transitioning to JSON from XML, and it allowed backwards compatibility for the requestors.
You can, but this makes it easier for the customers to know without having to search for what versions are supported and what versions aren't.
You should take a look at kotlin, https://kotlinlang.org/ https://github.com/mythz/kotlin-linq-examples 
Personally, the movement of foreground as well as background made me a bit queasy. I would have preferred a simpler presentation, or at least move the entire frame in the same direction...
&gt; Concatenation intrinsics They are used only for string constants. You can the same thing yourself with something like static functions and constants of type Ascii. It would be slightly more verbose, but also faster than String in Java 9. &gt; interning/constant pool/constant folding, deduplication Also can be done in the library. class AsciiInterner { static Ascii intern(Ascii ascii) { ... } } static final Ascii foo = AsciiInterner.intern(new Ascii("foo"));
And deduplication?
You can use all the same tools, libraries, and techniques with Scala as well. It's just that people tend to quickly abandon all those when looking to do things using the abstractions and features Scala offers.
If you have to use SOAP, I find Apache CXF a pretty solid implementation. Also there are some good tools for generating boilerplate for SOAP via xjc
Perhaps I haven't asked my question well but I don't think failing to define Java SE was the mistake. I'm really wanting to know if I can get a Java job without knowing about enterprise application servers, EJBs, servlets and other things associated with "Java EE". That's what I meant. I thought that was clear by saying not EE.
In my case, I'm using Ruby, so they would just use `bundle update` and if they specified in their gem file that they only use 1.x versions, they will get the latest 1.x version. Otherwise, how would users know what the latest version of any major version is anyway? They would have to look somewhere... they can't just guess right? Perhaps... perhaps this is what release notes are for! 
jOOQ really should be standardized like JPA was. It is one of those killer Java features.
There are multiple reasons to consider SEMVER flawed. They usually revolve around the fact it doesn't take into consideration language and platform ( source or binary based dependencies play a part here ). Given this is r/java, chances are we're using Maven, which means dealing with `-SNAPSHOT` releases. Semver encourages ( or, dictates ) using .0 version numbers which is fundamentally flawed when using ranges. Take for example `[1.0.0,2.0.0)` - a non-inclusive upper bound ( we don't want to use any breaking changes ), however `2.0.0-SNAPSHOT` is LESS THAN `2.0.0` so is included in the range - thus breaking the contract we want to maintain. One of the other issues is that runtime environments are not considered - if `1.2.3` switches to a major dependency version that it uses, but doesn't expose - so is 100% source compatible, 100% semantically compatible in it's behaviour, but requires a runtime change to include the new major version of a transitive dependency - should that be a major version change or not? Consumers can _compile_ against it perfectly fine, their _unit tests_ should continue to work fine as well ( in theory ) so they shouldn't require transitive dependency ( in a perfect world ) - but even if they did, is that a _semantic_ change, or something more? Another flawed interpretation can arise in Java with say `public static final String SOME_CONSTANT = "...";` - if you change the _value_ of the constant - is that a major change or not? The semantic behaviour has not (necessarily) changed for consumers _building_ against the new version, but since Java will inline at the javac level static Strings into consuming classes, the change of constant won't be used in the consumer unless they rebuild. The answer on that case is YES, it should be a major breaking change, because those public constants form part of the public API, however - the API itself is the NAME of the constant, not it's value - except in the case of javac and inlining. This leads to the main issue I, and others have with SEMVER is that it only deals with "the public API", not it's implementation (if your API is in a separate jar file, as it should be - the main jar has no public API ). The "semantic" part of things is also only in relation to the version number, nothing is mentioned about the semantics of the code/dependencies contained within. SEMVER is good, it's just hugely ambiguous, and leaves A LOT left out.
Just call `AsciiInterner.intern`, you will have your strings deduplicated.
no problem, have a nice day ;)
Oh I see. The autonavigation was more aimed for non-attended demos. I disabled the autonavigation and added a hint about using `spacebar` for navigation.
I disabled autonavigation and added a hint to use `spacebar` for navigation.
&gt; I would have preferred a simpler presentation ... Here is a link where you can view this presentation animation-free (only fade transitions): https://bentolor.github.io/java9-in-action/?transition=fade&amp;parallaxBackgroundHorizontal=0&amp;parallaxBackgroundVertical=0#/2/3
Indeed, it's not that easy as it sounds. Forking "Java EE" is difficult, since "Java EE" is the spec. You'd more be forking Mojarra, and Jersey and the entirety of GlassFish. But who's going to do this forking? The other parties who already have Java EE servers like IBM or Red Hat or Tomitribe? And which of those is going to be the new RI? And will they all agree again? It could be solved eventually, but there's a LOT more going on then just a simple fork and continue. The 2 bigger and 1 smaller most known vendor here do have agreed on a new profile called the microprofile, but that's only JAX-RS, CDI, and JSON-P, they'd be crazy if it not also included Bean Validation and Security, but for now it doesn't. But that's only a tiny (well, micro :P) fragment of Java EE. If IBM was really dedicated to Java EE they could put resources into maintaining the (mostly Apache) dependencies their Liberty server uses. They did this before with OpenJPA, but walked away from that, switching to EclipseLink, from from Oracle now walked away. Payara would most be in the position to maintain the Java EE RI, since they've also forked GlassFish and maintain that. But... Payara wouldn't have the resources to maintain the components like Mojarra and Jersey. One of the few components that JBoss doesn't own itself is JSF (Mojarra), so Red Hat could theoretically provide some resources for that. But... Red Hat kinda walked away from JSF with dropping RichFaces, so I'm not sure how eager they would be to provide resources for it. Then another option is that Payara grows its business and is able to hire current or former committers of Mojarra, Jersey, EclipseLink, etc. That would have to happen relatively soon-ish then, before everyone scatters to the wind. I could go on, there are many more complications in "forking Java EE".
Spring changed hands 4 or 5 times or so. Now it's owned by Dell. Who knows what Dell's plans are. You may have to look back eventually.
1. Prototypical inheritance is incompatible with the values of any large scale application-oriented language. It makes type checking and static analysis very hard, and I don't see a way how it could be implemented properly in a static language. 2. Java, like most other large scale development-oritented languages, heavily emphasizes the declaration of contracts and tries to expose as many errors as it can at compile time. 3. For utility methods, you create utility classes with static methods. If you use them a lot, you may want to statically import some methods, although that should only be done where it makes sense (e.g. you shouldn't statically import `pow`, but it's common to import testing utilities in tests). 4. Javascript has bad concurrency primitives (or rather, pretty much none at all). Java's concurrency library is one of the best, if not *the* best (the only contestants that I know of are .NET and Erlang) concurrency library. Concurrency is *never* simple. Javascript is single-threaded, and its whole async model came to be because a bunch of crazy people decided to use a language that was supposed to make the monkey move to do something much more. With Java, you shouldn't really be afraid of blocking unless it becomes a bottleneck. You should write code that will be easy to refactor once you actually hit that bottleneck, but for that you need to understand what is considered safe and what isn't. There is a great book called "Java Concurrency in Practice" which will introduce you to the problems of concurrency and how to tackle them using what Java gives you. As a beginner though, you shouldn't really touch concurrency, and only dive into it once you understand the dangers and complexities of it. 5. &gt;Finally, and this is a must have - it must be testable. If it doesn't have a good testing library, chuck it. Another fallacy that comes from the world of dynamic languages is that you should test 2+2=4. Java has a great ecosystem of testing libraries, but you shouldn't go overboard with testing because a lot of JS tests are only there as a replacement for the safety net that is a proper type system. There's a reason why pretty much all modern enterprise languages take inspiration from Java. Scala is a hard language with many bits taken from both Java and hardcore functional languages, Kotlin is pretty much what Java would probably look like if it weren't for backwards compatibility and C# is Microsoft's fast moving Java clone (as a language C# is very nice, but the ecosystem is meh).
If the JVM is a requirement, stick with Java for a while before you consider moving to another JVM language (probably Scala). While Java is a rather dated language and has a ton of problems, it is far easier to learn and understand than Scala. 
Even the creator of Spring (Rod Johnson) was not a fan of xml configuration but did it because it was fashionable at the time. Spring has had Java config as an alternative for years now so I think its a bit disingenuous to compare it to Spring with xml.
&gt;Kotlin has great marketing, and if the only thing you care about is slightly nicer syntax than Java, this is the language to pick. Assuming you have actually used Kotlin - this is borderline dishonest. It's a vast improvement over Java and syntax is only a small part of it. Citing tooling support and Android as points in favor of Scala is blatantly partisan. Kotlin is ideal for Android and the IDE support is top notch.
Main point of the article: [a link to a published paper on linguistic anti-patterns.](https://www.researchgate.net/publication/276314133_Linguistic_antipatterns_what_they_are_and_how_developers_perceive_them) The 17 Anti-Patterns Discussed in the Paper: * **“Get” - more than accessor** — A getter that performs actions other than returning the corresponding attribute without documenting it. Example: method getImageData which, no matter the attribute value, every time returns a new object. * **“Is” returns more than a boolean** — The name of a method is a predicate suggesting a true/false value in return. However the return type is not Boolean but rather a more complex type thus allowing a wider range of values without documenting them. Example: isValid with return type int. * **“Set” method returns** — A set method having a return type different than void and not documenting the return type/values with an appropriate comment. * **Expecting but not getting a single instance** — The name of a method indicates that a single object is returned but the return type is a collection. Example: method getExpansion returning List. * **Not implemented condition** — The comments of a method suggest a conditional behavior that is not implemented in the code. When the implementation is default this should be documented. * **Validation method does not confirm** — A validation method (e.g., name starting with “validate”, “check”, “ensure”) does not confirm the validation, i.e., the method neither provides a return value informing whether the validation was successful, nor documents how to proceed to understand. * **“Get” method does not return** — The name suggests that the method returns something (e.g., name starts with “get” or “return”) but the return type is void. The documentation should explain where the resulting data is stored and how to obtain it. * **Not answered question** — The name of a method is in the form of predicate whereas the return type is not Boolean. Example: method isValid with return type void. * **Transform method does not return** — The name of a method suggests the transformation of an object but there is no return value and it is not clear from the documentation where the result is stored. Example: method javaToNative with return type void. * **Expecting but not getting a collection** — The name of a method suggests that a collection should be returned but a single object or nothing is returned. Example:method getStats with return type Boolean. * **Method name and return type are opposite** — The intent of the method suggested by its name is in contradiction with what it returns. Example: method disable with return type ControlEnableState. The inconsistency comes from “disable” and “enable” having opposite meanings. * **Method signature and comment are opposite** — The documentation of a method is in contradiction with its declaration. Example: method isNavigateForwardEnabled is in contradiction with its comment documenting “a back navigation”, as “forward” and “back” are antonyms. * **Says one but contains many** — The name of an attribute suggests a single instance, while its type suggests that the attribute stores a collection of objects. Example: attribute target of type Vector. It is unclear whether a change affects one or multiple instances in the collection. * **Name suggests boolean but type does not** — The name of an attribute suggests that its value is true or false, but its declaring type is not Boolean. Example: attributeisReached of type int[] where the declared type and values are not documented. * **Says many but contains one** — The name of an attribute suggests multiple instances, but its type suggests a single one. Example: attribute stats of type Boolean. Documenting such inconsistencies avoids additional comprehension effort to understand the purpose of the attribute. * **Attribute name and type are opposite** — The name of an attribute is in contradiction with its type as they contain antonyms. Example: attribute start of type MAssociationEnd. The use of antonyms can induce wrong assumptions. * **Attribute signature and comment are opposite** — The declaration of an attribute is in contradiction with its documentation. Example: attribute INCLUDE_NAME_DEFAULT whose comment documents an “exclude pattern”. Whether the pattern is included or excluded is thus unclear Also included: [a link to a survey on these naming anti-patterns.](http://www.surveygizmo.com/s3/2816220/lousy-naming-choices-and-how-often-they-come-up)
&gt; Says one but contains many oneToMany exception?
on unix*: http://www.tcpdump.org/ https://sites.google.com/site/jimmyxu101/testing/use-tcpdump-to-monitor-http-traffic βetamax: https://github.com/betamaxteam/betamax
Kotlin is a language with no reason to exists other than to get people to use JetBrain's products and their only real success is the astroturfing campaign here on reddit.
i made a tl;dr for you guys: fuck oracle
&gt; “Set” method returns — A set method having a return type different than void **and not documenting the return type/values with an appropriate comment.** Seems like, according to the author, as long as you document it, that's valid. 
Ah, missed that part when skimming. Thanks!
Yeah, not so simple. And by the time that all got sorted out, the leading edge (and perhaps the bulk of) the community would have moved on to a new FOSS solution; perhaps not even using any flavor of Java anymore. 
Oh, great, I must have missed that. Thank you. I'll take another look.
I've never read Head First Design Patterns so I can't comment but if you're interested you can check [this set of videos out](https://www.youtube.com/playlist?list=PLF206E906175C7E07). It covers all the design patterns by the GoF and its done in Java. 
Hfdp helped me tremendously when I was starting out. It taught me what programming to an interface actually meant. Loose coupling, polymorphism, design in general are all covered well. Best of all it's readable and digestible. Can't say the same for GoF personally. I've struggled to read it. 
Most design pattern books are reference books, but the HFDP book is a tutorial meant to be read back to front. If you want to learn design patterns it's a great book, but you'll have to commit time to reading it back to front (honestly I think this is true of most books, but with HFDP you can't pretend to get value from it with it sitting on your shelf like reference books).
Great book. The Head First books are usually pretty good anyway but I found this one great for explaining abstract concepts.
I cringe at the pile of spaghetti you're leaving for your successor.
https://en.wikipedia.org/wiki/Design_Patterns#Patterns_by_Type is a good reference here, it's basically just the list of patterns from GoF
It's a little unfair. I remember that they started with OOP fundamentals which is a very good starting. Also sometimes there is no book to read that will teach you that design patterns aren't goal but way of simplifying that may fail, better than your own mistakes of committing too complex code. I read similar advices many times and they were quite pointless. How you can avoid design patterns when you don't even know them? They are too abstract in the beginning.
Hfdp for me was excellent because of the conversational tone if the book. There was complexity in the examples, sure. But the explanations were always informal, like I'd talk to a colleague, rather than how I would expect it to be taught at uni by a stuffy old lecturer.
Jeff Atwood ranted that a book about design patterns concentrated on design patterns?
That's a [fluent interface](https://en.wikipedia.org/wiki/Fluent_interface), and it's only occasionally appropriate. Remember especially to document whether the instance is mutable.
What I can't understand is why everyone believes Oracle is abandoning Java EE. It was a tinfoil-hat level of rumor, yet everyone universally agrees Oracle is out to get us. It can't be healthy for the Java community to be so hostile to the very people who are providing their platform. And I don't see how Oracle deserves this. Criticism is healthy, but as someone who focused more on working with Java rather than following the various Java community trends, this seems like outright lunacy.
J2ee indeed doesn't matter anymore. It's 10 years old! Just like J2SE 1.3 doesn't matter anymore. Now Java EE, THAT greatly matters ;)
Since you specifically asked in r/java, here is a github repo which is very active in updating design patters in java. [Github Repo](https://github.com/iluwatar/java-design-patterns)
Not directly for Java, but this is the best design patterns book, hands down: http://gameprogrammingpatterns.com/ And it's free.
Agreed, nothing wrong with that at all.
I got it on my first job also. Seemed a good taste of design patterns, though you don't really get it until you use them.
Changing a class dynamically would very much complicate the JVM. It is very possible that some kinds of optimizations could no longer be assumed because fields and methods could essentially just disappear. When a field/method is removed, for speed there would have to be a kind of atomic reference counting whenever a method is entered and exited (so if many threads are calling the same method they could essentially block each other due to an atomic update). Otherwise, there would have to be a stop the world field/method remover that fails if a method is currently being executed. This could be mitigated (at a cost of weakness) if field and methods that can be removed would have had to been previously added. On modern JVMs, if a method needs to be replaced then `invokedynamic` and method handles should be used instead (older versions could use interfaces in a more limited fashion). If new code has to be created dynamically, then a class could be initialized as byte code, reflected in, and then have a method handle which points to a method in the newly reflected class. Since Java 6 there is 'JavaCompiler' so you can very easily dynamically compile new Java code at run-time, store the classes in internal memory with a custom file manager, load the class file into a class loader, then perform what I have stated previously. 
Hah the ol' factory with only 1 implementation pattern
I don't know if this has much to do with lightbend's focus on java as much as the whole lightbend stack standardizing on java 8. Such an API would not have been possible as long as Akka supported Java 6 like it did until recently.
They need to rethink demanding that everyone have three years of experience in fifteen different technologies. There needs to be a programmer's union and a robust apprenticeship program. 
They stopped their development efforts. That's not a rumor, you can see that in the version control system, and mailing lists. And not they admitted that they worked on a competing product instead. That's not a rumor, it was an official statement. That's why. It also does not help that they fired their Java evangelists, but that alone would have been rumor material. Just read the linked article. It is not hostile to state the facts. And Oracle has prevented Java from becoming truly open-source driven, so the community cannot just fix and improve Oracle without going through Oracle. There is no other way than complaining about Oracle right now to get the Oracle CEOs attention.
True I may have misspoke a bit with that statement, it does however seem like they are putting alot more effort into cleaning up and standardizing their java side of the ecosystem as of late and its been much appreciated.
The page load speed difference astonishes.
FYI, someone maintains the DCEVM patch over there: http://dcevm.github.io/ I think that originally, JEP 159 was basically about integrating the original DCEVM patch.
I'm not sure how to take your last statement, seems very vague. As a language C# has surpassed Java in what aspect? Features, user base, over-all usefulness? These things seem rather subjective and your point seems very biased towards your opinion.
Everything except for debugging, repository exploring, etc. Perspectives are a terrible idea.
&gt; Now as a language has far surpassed Java. As a language. In the sense of features and expressiveness. Java clearly wins user base and ecosystem, but that is not the language itself. Note that I was responding the "Java clone" claim. It was a Java clone 15 years ago. Past 5 years Java is playing catch-up.
ReactiveX is a stream library based on the Observables Pattern. This is a FRP library based on signaling events with a design derived from [Scala.React](https://infoscience.epfl.ch/record/176887/files/DeprecatingObservers2012.pdf). EDIT: Here is an example of a modern alternative to Scala.React being used to implement UI's in the [browser](https://vimeo.com/98477272).
This is pretty cool. TIL how to debug SSL without a mitm cert!
OP is right. Useless contributions to a million node.js, 5-line, "libraries" are worth more than knowing when to use Dijkstra or Bellman-Ford.
You are absolutely right!
&gt; My company is currently rewriting a big chunk of our Node codebase in Java. Uber?
The second article followup promised at the end of this post is now live http://techbeacon.com/hiring-part-2-dos-donts-how-fix-technical-interview
Yeah, I'm not entirely sure on reasoning for the rebranding of their licence. But it has always been that you buy a licence and you get all upgrades for a year, the only difference seems to be that you can have a payment plan, cancel before the year is up and you lose the licence. No one seemed to care before, but call it a subscription and it's pitchforks out.
CLion is a separate product because of the work involved with doing C++ right, it's not a simple language and required a tremendous amount of work to implement, I expect that eventually it will be included as a plugin for IntelliJ, but $149/yr for the full JetBrains package is worth its weight in gold for me as I use IntelliJ, DataGrip, ReSharper and PyCharm extensively (I used to pay more than that for just ReSharper and IntelliJ).
According to their own FAQ, you ARE allowed to use a Personal license for commercial development. https://sales.jetbrains.com/hc/en-gb/articles/207241015-Can-I-use-my-personal-license-for-commercial-development- It would be very stupid of them to restrict things in the way you described. Frankly, I think I'd have to see proof before I believed they're doing such a thing.
My guess would be that the licenses was locked due to frequent use at multiple locations, which might look like sharing outside of the license agreement. I would hope a JetBrains rep would be able to apply an exception to his account if that were the case.
Really? Well, I hope you report them. Threats of physical violence break the law too. Also, it would be best if you outted all of them here by reposting the content of their PMs in their entirety. Let's see who these shysters are. Edit: You deleted your comments?! You're either a coward or full of it. 
Awesome. Upgrade went smoothly. No complaints so far.
Yes, it can be done without using arrays (lists).
I went from Netbeans to IntelliJ. Join us. 
Yes, it is possible. You simply need a loop and three plain variables (no lists, no arrays, no data structures) - that's all. ---- Still, this post should be in **/r/javahelp** (as is outlined in the sidebar and in the multiple hints on the subreddit) because it is about help with Java programming. Make sure to read the [**posting rules**](https://redd.it/48eykt) there before posting. Your post as it currently stands would be against those rules. ---- You will neither get a full solution here, nor over at **/r/javahelp** - the effort must be on *your* side. ---- **Post removed:** programming help 
Been using it in beta for awhile now with no real issues. Glad they went GA.
Just int time! Thank you.
Hmmm, STS should really consider switching to using long For their time fields. Otherwise they will run into the 2038 problem.
Clearly he's doing it himself and has no interest in hiring other developers, it's not even mentioned as an advantage or hinderance. He's thinking like a craftsman, not a businessman. If he ever makes if far enough to look into hiring others to write code for his project, he'll be in for a rude awakening. 
The IDE itself ships with a plugin which adds a keymap identical to Eclipse, and also have pre-built code styles from Eclipse. And some other utilities like importing and exporting an Eclipse project. As for Spring, AFAIK it's the latter.
Are they still eclipse based? 
Please, use a *proper* tutorial. These ultra-basic pseudo courses don't really teach anything of value and generally are a waste of time. The best tutorials for Java are (all free): * **University of Helsinki MOOC** [**Object Oriented Programming with Java**](http://mooc.fi/english.html) - text based with exercises that need be completed and submitted before being able to proceed. (Uses Netbeans as IDE) * **Java for Complete Beginners** by John Purcell (probably the best and easiest entry into Java) - video based (Uses Eclipse as IDE) - the three links below lead to the same course hosted on different servers. I would use the Udemy link because it has an active community where you can ask questions and get answers. * [CaveOfProgramming link](http://courses.caveofprogramming.com/course/java-for-complete-beginners/) - John Purcell's site * [Udemy Link](https://www.udemy.com/java-tutorial) * [YouTube Series](https://www.youtube.com/playlist?list=PL9DF6E4B45C36D411) * **Derek Banas'** [**Java Youtube playlist**](https://www.youtube.com/playlist?list=PLE7E8B7F4856C9B19) with the accompanying site [Newthinktank](http://newthinktank.com) ---- Also, this post id better suited for /r/javahelp or for /r/learnjava as it is more related to programming in Java and learning Java respectively. **Post removed**: Should go in /r/javahelp or in /r/learnjava
Hi, I work on SODA at Oracle. No special library is required for JSON in Oracle... you'd use SODA if you want a NoSQL type interface, but Oracle SQL itself has great support for JSON: https://docs.oracle.com/database/121/ADXDB/json.htm#ADXDB6246
Are you serious? I've taken a few programming courses in university and still am going through school, but there's a part of me that really wants to go into the workforce and start applying the stuff I learned in 101. I honestly don't feel like I learn best unless I start applying the language.
There are still big corners of fun still going on if you know where to find them.... The Community sessions over weekend (NetBeans Day, Java for kids) have really taken off in last 2 years.
I can really get used to code ligatures.
Merging variables and watches in the debugger is really a good idea.
I think Lightbend strategy is to move in the direction of "enterprise" development. This means Java. Look at the new Lagom project, for example.
Yes, I spoke in the NetBeans community day too and like I said even with the decline there are still great people to meet and a few decent places... But the trend of decline since leaving Moscone is continuing. The general sessions used to be fun and impressive, now they feel tedious and overbearing with marketing. Even most of the sessions are not at the same quality level since they focus on what Oracle thinks is interesting. So you go to a session that is jam packed (because it's the only one that's interesting) and then most other sessions barely have any attendance. A few years ago I was at a JavaFX session where it was just me and one other guy (whose an Oracle employee). Now that was an extreme case and most unpopular sessions still did have a dozen or so people in them but it shows the disconnect between Oracle and the community that just isn't showing up for the conference or the sessions.
With the amount of time you spend staring at your IDE, it makes sense to make it as visually appealing as possible. 
From a JavaBeans point of view, having a setter method that returns a value breaks the spec a bit, in that introspection tools may no longer be able to see your "invalid" setter. A compromise we've done in some situation (where we do want chaining) is have equivalent methods that can chain: instead of setX we have withX and that returns the object as well as setting the value.
They only do patches for minor releases. I'm downloading the 400+MB right now myself.
The real question is: Can we set an animated .gif as the background? *^(I just want to watch the world burn)*
I have no idea.
Perhaps you should do a github code analysis or something. Would be a nice blog post. Create statistics about how often each JPA annotation is referenced... Of course, that isn't 100% authoritative as it's only covering github projects, not "real" enterprise software. But it might still give some insight on the order of magnitudes
Already had one hard crash on OS-X. :-/
To be honest I actually feel like I am even worse than the average student because everyone in my current engineering program are younger kids who have programmed and done stuff on their own time (personal projects) and know two or three other programming which they learned how to apply. Most of my experience mostly just comes from academic classroom work (here's an example - make a code. Here's a project - code it) and I feel like I need hand holding for the most part. Everyone says that the best way to code is to have your own personal project where your own interest drives your own motivation, but even I struggle in finding my own "creative" project because I don't even know if most of the ideas I have are feasible.
I did the same thing yet got the update, weird. 
&gt;With minimal XML and a few POJOs (Plain Old Java Objects), Really, I mean really??? Spring introduced some great stuff, but the XML was NOT minimal! Not even compared to the terrible EJB2 XML nonsense, but certainly not in an absolute sense. I've seen Spring projects that had more XML "config" than actual code. &gt;A major enhancement has been the ability to configure Spring in a completely declarative way with annotations relying on little to no XML at all. Funny, the article is ranting against Java EE, but this "major enhancement" was started in Java EE long before Spring saw the light.
Yes, it is abses in the latest Eclipse, Neon.
make it a screenshot of code from another file so that you can work on 2 files at once!
You may just be on to somethings... Continually compile the code to an image for a background. Or the JavaDoc page for the currently selected type.
DataGrip is purely a SQL development tool.
people gotta have their waifus visible at all time
From the point of view of past JavaOne talks, YouTube is a big improvement. Past JavaOne talks were hosted elsewhere, and there were several problems. They even disappeared at one point. The archive of past talks had to be "rescued" and re-published on YouTube, which is much more stable. The situation with YouTube and GEMA is indeed unfortunate. I don't know what's happening with this. One issue is that speakers often include copyrighted movie clips or still images in their presentation. This is fun, but it makes the presentation video a target for being taken down or blocked.
Here is an example of use in this old program of mine: FindTextInDocuments --help 'FindTextInDocuments' searches for text in documents (using GUI). Usage: 'FindTextInDocuments [--icon [Path]FileName.png] \ [--threads 1..100] \ [--timeout 1..360] \ [--include-dot-dirs] \ [--search-directories [-]dir1 [-]dir2...] \ [--document-extensions [-].ext1 [-].ext2...]'. Notes: ·Option '--icon': Use 'FileName.png' to render Window's icon (optional). ·Option '--threads': Number of threads used in searches (Value: 1..100). ·Option '--timeout': Time limit, in seconds, for searches (Value: 1..360). ·Option '--include-dot-dirs': Include dot subdirectories (.Name) in searches. ·Option '--search-directories': Directories (recursively) searched to find documents. ·Option '--document-extensions': Extensions of documents to be searched. ·When looking for documents 'FindTextInDocuments' will follow symbolic links. No links to parent directories allowed in directories to search. ·Note that '--search-directories Directory Directory/SubDirectory' is redundant because 'Directory/SubDirectory' is included in 'Directory'. ·Directories, specified in '--search-directories' option, will appear unselected in GUI if preceded by '-' i.e.: '--search-directories $HOME/Dir1 -$HOME/Dir2'. ·Extensions, specified in '--document-extensions' option, will appear unselected in GUI if preceded by '-' i.e.: '--document-extensions .ext1 -.ext2'. ·Invoking 'FindTextInDocuments', without parameters, is equivalent to: 'FindTextInDocuments --threads 12 --timeout 180 --search-directories $HOME \ --document-extensions .epub .mobi .lit .txt .htm .html .odt .rtf .abw .pdf'. The [relevant block](http://pastebin.com/sVELrstQ) uses about half the lines than the previous version.
I have not checked what's out there. I just wrote what I needed. Here is the constructor detail from its Javadoc: Constructor Detail ArgsParser public ArgsParser(java.lang.String[] args, java.lang.String[] allowedStandAloneOptions, java.lang.String[] allowedOptionValueOptions, java.lang.String[] allowedOptionValueOrValuesOptions) throws org.common.libraries.etc.InitCheckException Parses array 'args' and stores the extracted data so that it can be later queried through this class' methods. Parameters: args - Arguments to parse. Empty arguments will generate warning messages (see warning messages methods below). allowedStandAloneOptions - May be 'null'. Options that have a meaning on their own. Examples: --help, --start, -verbose... Duplicated options will generate warning messages (see warning messages methods below). allowedOptionValueOptions - May be 'null'. Options that should be followed by a corresponding value. Can be issued multiple times: '-name John -name Peter...'. Some options may be followed by several values: '-names John Peter...' (see 'allowedOptionValueOrValuesOptions' below). Options without a matching value will generate warning messages (see warning messages methods below). allowedOptionValueOrValuesOptions - May be 'null'. Must be 'null' if 'allowedOptionValueOptions' is 'null'. Should be a sub-set of 'allowedOptionValueOptions'. Options in this list may be followed by one or more values: '--directories /etc /temp /home...'. Throws: org.common.libraries.etc.InitCheckException - Thrown if the arguments passed to this constructor do not follow certain rules. InitCheckException's message will contain a list of the causes for the exception: Array 'args' has value 'null'. 'allowedOptionValueOptions's option is also in 'allowedStandAloneOptions'. 'allowedOptionValueOptions' == 'null' and 'optionValueOrValuesOptions' != 'null'. 'optionValueOrValuesOptions's option is not in 'allowedOptionValueOptions'. 
also [jewelcli](https://github.com/lexicalscope/jewelcli)
also Tomitribe's [Crest](https://tomitribe.io/projects/crest)
Hey, good job writing your own arg parser. I'm all for trying to implement something once yourself to see how something works. For production code though, I would go for popular libraries that have been battle tested. It would just cost me too much time to write all the test cases to ensure adequate coverage. One feature I really like in other libraries is the ability to tie the argument description with the argument definition, and they actually take care of printing out the usage for you.
also [airline](https://github.com/airlift/airline)
Devoxx US is the new JavaOne.
I didn't like it nor found it helpful. Unfortunately I haven't found any of Fowler's books very useful, but read all of them early in my career. [Pattern-Oriented Software Architecture, Volume 1](https://www.amazon.com/Pattern-Oriented-Software-Architecture-System-Patterns/dp/0471958697) has, for me, been the most influential design book. Being 20 years old you do have to modernize the patterns slightly, but the concepts are pure gold. 
Can't say I recommend Fowler's books.