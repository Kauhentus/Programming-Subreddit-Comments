The integrated feedback mechanism is really sleek (and, since OSS PDF readers such as Evince handles hyperlinks, one does not even need to resort to Adobe Reader)
Maybe they've changed it, but I'd like the webpage to display previous submissions by other people. I'd think that many bugs are submitted multiple times.
I don't think they do. The discussion and suggestion pages certainly could be tied together better.
I would think that the odds of this happening are close to nil. IMO you're better off using a method on Seq or Iterable if possible, or writing a recursive method if not. Check out just how ugly break/continue can be, and note that Scala already has true closures: http://gafter.blogspot.com/2006/10/iterative-control-abstraction-user.html http://www.javac.info/closures-v05.html (grep UnmatchedNonlocalTransfer)
break and continue? go back to VB :P
Why would you want to? You can define them as a library if you really feel the need. Edit: though I suppose you run into the issue that the standard collections don't support them.
Previous submissions now display at the bottom of the form.
There's a new update to the PDF available as of today (2008-02-20).
This is so obvious that it doesn't even deserve a blog post. Even still, client's don't care about how nice your code is - they just want something that works. If you're your own client, then its in your best interest to make sure that your code is "good," but otherwise, it's not really necessary. Clients will be happier if you get the job done, and done quickly.
Sounds like they didn't write a regression test when the bug was initially fixed. That is sloppy by the standards of most software, but near-unforgivable for a compiler, where subtle regressions can have major consequences.
I remember when a friend showed my Haskell's [QuickCheck](http://haskell.org/haskellwiki/Introduction_to_QuickCheck). It's one of these features for which I'd love to learn Haskell. And now I found a Scala "port".
It would be cuter if there was some explanation of what this actually is without having to pour through the source code.
Yeah, but no video, no presentation, only the source code. Not very useful.
via: http://www.jroller.com/gatorjug/entry/scala_and_the_sweet_web Sunday September 14, 2008 Scala and the Sweet Web Development Framework Zemian gave a presentation on Scala at last Wednesday‘s GatorJUG meeting. Zemian is a Java systems architect by day, developing web applications with SpringMVC and Hibernate. About a year ago, he discovered Scala, another language which also runs on the Java virtual machine and can use Java libraries, but which is more expressive, more concise, and easier to use. Since then, he has developed his own Scala web application framework, called Sweet.
Looks interesting, but would be useful to have a comparison between this and the existing Scala web framework [liftweb](http://liftweb.net/).
Dude, 5 sentences and a hyperlink? If you want to get voted up, try putting a little effort into it.
Comment moderation enabled, and 7 hours later it's not been approved, so I'll post it here: I think you might enjoy Scala more if you take a look at *why* it doesn’t seem optimised for the cases you wish it was. E.g., generally casting is unsafe, so it’s not particularly optimised for. You might like the book “Programming in Scala”, which is soon to be published, but is available now as a PrePrint PDF, for some dollars. Incidentally, 65.toChar gives ‘A’, which might help with the code you posted. I agree that the language could be simpler, and that the documentation could be much better, but there is simply more to learn in Scala than there is in C# or Erlang, so it’s bound to take longer. About super programmers on steroids - I like Scala and it seems to like me, and I’m just a programmer on coffee, no steroids around.
WTF, no RSS?
Not much meat in the article, but it's nice to see people who are apparently not hardcore language lawyers seeing direct benefit.
One of the great things about Scala's pattern matching is that a bunch of case statements are automagically an instance of PartialFunction, so you can do this: val f: PartialFunction[String,Unit] = { case "abc" =&gt; println("got abc") // Anything else will throw a MatchError } val s = "&lt;some string&gt;" // some String value if (f.isDefinedAt(s)) makeUseOf(s) else error("unsupported value" + s) Better yet, you can chain them: val g: PartialFunction[String, Unit] = { case "xyz" =&gt; println("xyz") } val h = f orElse g h("abc") &gt; abc h("xyz") &gt; xyz h("what") MatchError!
I'd like to see an answer to Jorge's question, but I lack the brainpower to take a crack at it myself.
The comparison is pretty relevant, as Scala's interesting semantics for super calls in a class that mixes in multiple traits make them a good, type-safe alternative to AOP in a lot of cases. Unfortunately, apart from bare metal Java reflection, Scala lacks delegate support, so this means that your "advice" traits must share an "interface" with your "advised" implementations--it's not as easy to reuse the same behaviour in multiple unrelated components the way you can with aspects. Let's say you want to wrap a logging aspect around your components, but you want to centralize the logging logic. With traits you need to do something like this: trait LoggingComponent { self: Component =&gt; def componentBusinessLogic = { LoggingAspect.logEntering( classOf[self],"componentBusinessLogic") super.componentBusinessLogic() LoggingAspect.logExiting( classOf[self],"componentBusinessLogic") } } Whereas the usual AOP approach is to specify the components and/or methods to be advised declaratively, and let the AOP interceptor have its dirty, reflection-driven, non-type-safe way with your code. AOP is more declarative and not nearly as verbose, but it's slower and more heavyweight. To my mind the ideal scenario would use delegates, in which the compiler could generate forwarding methods for you. 
Scala is hot!! I love ML and Java and in Scala I can get the best of both worlds.
I was wishing for a "real world" evaluation of Scala a long time ago, something that goes deeper than Hello World and the factorial function :)
Ted is doing good stuff here, but it would be good if he introduced constants for one and zero, like this: case object Zero extends Number(0) case object One extends Number(1)
Sweet. I was planning to start a project on Android in Java, but I might just use Scala instead.
Also note that the PDF version has been updated (presumably with the final copy) too.
Needs more Slava comments.
If you're going to play around with tail recursive functions in Scala, there are a few things to keep in mind: 1. The JVM doesn't support efficient tail calls, so the Scala compiler has to translate them into traditional loops, which it will do automatically, but: 2. The recursive function must either be final (i.e. it cannot be overridden) or an inner function; 3. Many of the algorithms that we might naïvely think of as tail-recursive are not. While Lisp-style syntax makes it easy to visually spot tail calls, Scala, like most other ALGOL-style languages, supports infix operations that can make it look like a given call is a tail call when it isn't.
I think it would be *nice* if Scala moved toward increasing independence, but in the short (and medium) term Java interop is not only a killer feature but a huge reason for many organizations to choose Scala (or Clojure) over just about any other FPL.
 Scala’s == compiles down to Java’s .equals, except where the resulting bytecode is comparing primitives. Java’s .equals has Object as its type, therefore RichString.equals(String) is quite valid, though if RichString is sanely implemented, that will always return false (note the symmetry clause in Java’s equals contract). The specific reason you might accidentally compare a RichString to a String is that you invoked an implicit conversion. If the type of == was changed so that a T could only be compared to a T or subtype of T, then the compiler would be better-placed to convert the RichString back to String. Sadly, Scala is unlikely to make large backward-incompatible changes now, so this change won’t happen; or if it does the old behaviour will still be accessible via command-line switches. 
No. Reddit should have a multi tag system, possibly with a hierarchy in the tags, but it should be possible to tag a story with both programming and scala, or with obama and us and politics, or with netsec, us, politics and programming if a story has all these elements. The set of tags should not be fixed. This would be closer to the slashdot tag system. One could even have the possibility of tagging other people's stories - there are a lot of stories on the main reddit that should have been classified. 
Lest anyone think that encoding natural numbers as nested generic types is pure wankery, keep in mind that in this case it's used to ensure that quantities in units that have different exponents cannot accidentally be combined using scalar operations.
Uh, make that 96 cores, of which 88 were usable by the application.
Jorge is doing good work here, showing people who aren't already FP nerds how they can see immediate and tangible benefit.
I was marked as spam on his blog, so here's my comment Static and dynamic have to do with "static analysis" of the structure of code regardless of the runtime or "dynamic" behavior of code at runtime. The Groovy example is dynamic metaprogramming because metaclasses get manipulated at runtime, and so whether there's a "myNewMethod" on String depends on when you try to call it in the dynamic execution of the program. Before the monkeypatch happens the method doesn't exist for any caller, after it happens it exist for all callers. The Scala example you give is more an example of static behavior, not dynamic behavior. In particular, the choice of implicit is made statically (at compile time) based on static types not dynamic (runtime) types. To put it another way, whether there's a "myNewMethod" on String depends on where the call is made in static source code, not when it's made in the dynamic execution of the program. In Java terms it's like the static dispatch of method overloading rather than the dynamic dispatch of method overriding. But the general point stands: using Scala's implicits you can do some things at compile time that give the feeling of dynamic metaprogramming.
The jetlang version is still twice as fast.
How do you reach this conclusion? The benchmark I've seen (http://sujitpal.blogspot.com/2009/01/more-java-actor-frameworks-compared.html) shows Jetlang is only ~20% faster than Scala Actors, once the Scala code was updated to not do extra String concatenations and to use 2.7.3.
Eyeballing the 2.7.3 graph on that page (and paying attention to recv, which is the one that actually runs threaded, versus react which is an event loop).
Scala's recieve based actors do tie an actor to a thread, but both Jetlang and Scala react based actors are backed by thread pools. Scala's react actors are based on the work stealing queues in Doug Lea's fork/join library. BTW, Jetlang also has a way to tie to single thread, but the benchmarks don't show that version. 
In Clojure that's: (ns example-ehcache (:use clojure.xml)) (parse "http://localhost:8080/ehcache/rest/sampleCache2/2") Edit: ignore the &lt;&gt; it's a markdown bug.
I agree it would've been nice to get a lot more detail about actors, but it was a 700-page book already. An entire book on actors would be extremely welcome; I would buy the *hell* out of it.
...is by no means new, but it's good that JetBrains is putting more effort into documenting and popularizing it now.
It's an extremely good sign that software engineers are swooping in and kicking the crap out of Scala. I think the push/pull between the theorists and the practicalists (not pragmatists--thanks Tony ;) will result in an even greater language.
I don't understand why some people need search and replace so much. The only things I ever need to replace are class and method names, and refactoring takes care of that. If you have lots of code that is easily matched by a search pattern, then I submit to you that you are doing something wrong.
Read the followup posts though... All but one of his complaints are really about the Eclipse plugin; the other is rectified by a single import.
Oh great, a link to a paragraph describing a talk that hasn't happened yet.
For one thing, they built [kestrel](http://github.com/robey/kestrel/tree/master) in Scala.
Fantastic ...er brilliant!
I think you mean "awesome".
No, I do mean brilliant, as I now live in Melbourne...
via: http://www.scala-lang.org/node/1008
In order to understand my comment, do a word count on "awesome" in the linked post. Then note that this is a surprisingly low "awesome" count for David Pollak. :-)
It's cool news, but I'm still somewhat flabbergasted at the notion that 5000 messages per minute is a lot. 
Disclosure: Posting a link to my own blog!
Disclosure: Once again pimping my own blog.
We have an announcement regarding the book that is hopefully coming soon. 
David's [comment](http://blogtrader.net/dcaoyuan/entry/scala_corner_case_3_object#comment-1235758154655) below the post explains this behaviour, but yes, for someone like me who is trying to learn Scala this can be confusing. scala&gt; case class Symbol() defined class Symbol scala&gt; case class VarSymbol(name: String) extends Symbol defined class VarSymbol scala&gt; object NoSymbol extends Symbol defined module NoSymbol scala&gt; NoSymbol == VarSymbol("I'm a var") res0: Boolean = true scala&gt; VarSymbol("I'm a var") == NoSymbol res1: Boolean = false 
The first time I started learning Scala, I gave up when I reached the chapter on variance. But then on a second try I did get it. It was worth the effort. I find myself like Scala now that I have started to understand it a bit.
Variance is definitely a stumbling block for many, so Martin's idea of having type-checked simplified views of APIs is an excellent one! \* edit: I just remembered that reading the bit about the Liskov Substitution Principle in the variance chapter was responsible for a big leap in my understanding!
I recommend reading the comments if you want to read this article. The article doesn't mean quite what you think it does if you don't have context for what it's in response to.
Shouldn't this be posted under "WTF"?
A week late for an April fools joke, fail!
I'm going.
I wish you had told me that before I registered.
This is a good example of why I like to refer to Scala as "Java minus the ugly crap".
Let's see if I get this straight: in a talk given alongside two persons who have authored or coauthored books on functional programming languages, no one seems to have been completely certain that factorial 0 = 1 factorial n = n * factorial (n - 1) wasn't tail recursive?
See also [tail recursion in Scala](http://www.reddit.com/r/scala/comments/8eytp/tail_recursion_in_scala/).
The point?
This is all demonstrated very nicely in Programming in Scala, where one of the chapters has you make a new rationals class. Very nice, but, when you want to create a new rational, you still have to do something like: val r = new Rational(22, 7) //ugly! You can not do something like this: val r = 22/7 //good luck with that Since you can't play around with the AST like you can in common lisp or metalua, or ... there are some real limits to what you can add to the language. It feels a little artificial and unsatisfying to me.
Sorry; that's not tail recursion, since my comment is after the recursive call.
So, let me see if I understand: the trampoline approach he outlined in the even2/odd2 example still depends on scala's ability to at least optimize direct tail calls, right? (So basically it's a way to be able to do mutual recursion without overflowing even though the JVM doesn't directly support it?) Put another way, if Scala didn't at least optimize direct tail-calls, that example he gave wouldn't work, right?
But there's an ambiguity on 22/7... what should be the result? integer , real, rational? Let's define 'div' to be the rational division. Now, you only need an implicit conversion from integers to rationals implicit def intToRatl(x:Int):Rational=new Rational(x,1) and now val r= 22 div 7 works as you expect. Is not perfect, but you can go a long way without need to access the AST...
Besides a few minor conveniences, the Scala code seems nearly identical to the Java code. Which is fine, and demonstrates that Scala is nice to Java programmers, but I think it would be cool to see an implementation that takes advantage of Scala's functional aspects. I've actually never seen a really good, clean implementation of the sieve of Eratosthenes in a functional language. Anyone implement a functional version of the sieve in Scala?
This is a clean prime sieve, but not the sieve of Eratoshenes in spite of the article title: http://en.literateprograms.org/Sieve_of_Eratosthenes_(Scala) This is modeled after a very similar Haskell version in Haskell: http://www.haskell.org/haskellwiki/Prime_numbers For far more than you ever wanted to know about prime sieves and functional languages see http://lambda-the-ultimate.org/node/3127 
"Functional language" seems to be a phrase everybody redefines arbitrarily without explaining their definition. http://www.drmaciver.com/2009/05/a-problem-of-language/
Note carefully: db4o might be great (haven't used it) but it's only available under the GPL (not LGPL) or a commercial license. And because there's no API/SPI boundary like you'd have with an RDBMS accessed over JDBC, you'd have a hard time persuading a judge that your product was not a derived work.
I think that you'd have a very hard time convincing a judge that a program is a derived work of db4o just because it includes a db4o .jar file. Theodore Tso presented a pretty devastating argument against that theory on the Linux kernel mailing list a few years ago: http://lkml.org/lkml/2003/12/6/74 
I'm not talking about getting infected across an API, I'm saying that there *is no API* in any meaningful sense because you're linking directly to db4o classes, your product will not work at all without having them in the classpath, and there's no other db4o-like product that uses a substantially similar API.
It's possible to write an entirely new database that happens to expose the same API as db4o. Place the .jar file for the new implementation in your classpath and you're good to go. How can linking to a library create a derivative work when it's always possible to simply replace the library with an alternative implementation? Suppose two independent implementations of a library API exist. Is a program which depends on that API a derivative work of both of them? Even if one implementation was written later than the program itself? 
IANAL&amp;TINLA, but... It's certainly possible for someone to implement an API-compatible implementation, but as long as: * no such alternative implementation exists; * you ship a GPL'd implementation with your application; * your application won't run without it; You're on very shaky ground. You're on less shaky ground if you're distributing a non-GPL'd implementation with your product *and* the API you're using was reverse-engineered, rather than trivially extracted, from the original GPL'd product.
Also http://www.reddit.com/r/programming/comments/8lqtq/new_oreilly_programming_scala_book_available/
But when an operator ends with `:`, it starts getting strange and I'm not sure whether that this solution qualifies as Done Right(TM).
I implemented all three in Haskell: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5490, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5491, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5495 . Compile with -O2 -fvia-c -optc-O3 -optc-mfpmath=sse -optc-march=pentium4 -optc-ffast-math -fexcess-precision -funbox-strict-fields . All three run in 3.7s. Their C++ version with same compiler options runs in 2.7s on my machine. So, the price of abstraction in Haskell is 0.0%.
I'm considering weaning my team off Java and onto Scala gradually. We have a nice Java stack - Freemarker, Spring, Ibatis. Terracotta will probably enter the mix shortly. There are some obvious service layer modules that would benefit from Scala. Some of our Java code is becoming unwieldy. Some of our back end threading code sucks (even with 1.5 concurrency); there's a lot of XML munging code based on JDOM which would be a candidate for rewrite; and, there are quite a few places where FP would just be a better way of doing things. Whether we'd eventually move lock-stock to Scala, I'm not sure. The interoperability is a major plus, as it gives us this flexibility. Have you done a similar transition? Any gotchas or regrets, or has it been a net benefit?
Excellent question and I would be very interested to hear case studies on migrations/ports to Scala frameworks from medium/large scale J2EE stacks. 
If you're on LinkedIn there's a [pretty good discussion](http://www.linkedin.com/groupAnswers?discussionID=3621779&amp;viewQuestionAndAnswers=&amp;gid=746917) going on on a similar topic.
Anyone use the Apache Commons math project?
It really is an excellent book.
Comprehensively written.
The whole point about the Scala type system is that the inferences let you write code that resembles dynamically-typed languages, yet still yields you static type safety. The complaint about "magic conversions" doesn't really apply, since you have to manually import implicit defs into your scope. That's the kind of issue that could be resolved with an intelligent IDE, for example, color-coding places where implicit defs are performing conversions.
I'm still learning scala, so forgive this if it's a newb question, but: I don't get it. How would one mix in the trait? And, what invokes the apply method? His example is a little terse: val lock: Lock = ... lock { // access the resource protected by this lock }
The `Lock` trait would need to be mixed with some class the actually implements the `lock` and `unlock` methods. If this is `MyLock` you would do `val lock: Lock = new MyLock`. The `lock { block }` is basically sugar for `lock.apply(block)`. scala&gt; trait Foo { | def apply[T](block: =&gt; T): T = { | block | } | } defined trait Foo scala&gt; class Bar extends Foo defined class Bar scala&gt; val b = new Bar b: Bar = Bar@552379 scala&gt; b { 1 + 1 } res1: Int = 2 scala&gt; b { println("Hello World!") } Hello World! scala&gt; b.apply(1 + 1) res4: Int = 2 scala&gt; b.apply(println("Hello World!")) Hello World! 
I see. Thanks for the explanation!
Programming meme to word ratio is pretty high.
&gt; Install eclipse (I'm sorry Netbeans fans but I can't bring myself to work in an ugly IDE) from eclipse.org. On OSX at least, Netbeans is prettier than Eclipse. Eclipse is the land of gray. Disclaimer: Intellij fanatic.
Heh, he changed his tune: http://faler.wordpress.com/2009/04/29/why-im-giving-scala-a-rest-for-now/
How does this plugin compare to the eclipse plugin? I think the 2.8 eclipse plugin is quite good - especially at detecting compilation errors - but the completion seems a bit broken right at the minute - it won't code complete against any java classes in the scala editor. Also, if you write: val x:SomeType = something The completion thinks x is Object. If however you type Sometype x = something The scala completion then suddenly sees it as the proper Sometype with appropriate completion. Weird. So I was wondering how the netbeans plugin is shaping up. 
This is a good review. Author raises good points; be sure to read James Iry's response (it's the second comment).
I found one scala cheat sheet here: http://www.geekontheloose.com/programming/scala-cheatsheet.html but it's a little talky. Anybody know of a better one?
Ah, better: http://anyall.org/scalacheat/
People from untyped backgrounds are often confused by the multiplicity of None, Nothing, Null, null, Nil, () and perhaps it's unfortunate that they're all in the default namespace but they all have a very distinct purpose. :)
++. I've enjoyed the exchange with James Iry, and I think it's been a productive discussion.
sbt is a pile of awesome shoved into a small box, er jar. No xml build files, downloads dependencies automatically, trigger builds, and has an amazingly helpful developer running the show.
Up voted. I came to Scala from the non-java world (C, Python) and am not too familiar with Maven, Ant etc. With sbt I am able to focus on Scala rather than learning other heavyweight tools. Plus, I find sbt to be really fast and responsive. Also, the documentation is very good for such a young project. 
The scala migrations 0.9.0 [announcement](http://www.nabble.com/-scala---ANNOUNCE--Scala-Migrations-0.9.0-p24773431.html) on the mailing list.
"The package is based off Ruby on Rails Migrations and in fact shares the exact same schema_migrations table to manage the list of installed migrations." It's interesting why not to use Rails' Migrations?
Because Rails is one more thing to deploy and worry about. If I can do everything in scala, that is a win.
This is a great find
I'm sorry, Java (language), I'm leaving you. I've met someone else. Her name is scala Scala. I just didn't know where our relationship was going anymore... but Scala -- she has a five-year plan, you know? I need that kind of certainty, and she can give that to me.
&gt; she has a five-year plan, you know? I need that kind of certainty, and she can give that to me. And it seems like a good plan to me :) 
[And we had a son. He'd be about your age now.](http://xkcd.com/57/)
Looking good. :)
&gt; Scala does not support nested annotations I am eagerly waiting for scala 2.8 that supports this. 
I got bitten by this a few days back. Anyone knows if scala 2.8s default and named arguments allow this? 
I know this is a stupid question, but what are some ways to append to an existing list and use the Scala List types. Not a custom one. 
Not sure if this is the best way but you could concatenate two lists: scala&gt; l res3: List[Int] = List(1, 2, 3) scala&gt; l ::: (4 :: Nil) res4: List[Int] = List(1, 2, 3, 4) In general if you need to do a lot of additions to the end of the list (say A) its best to create a new list (B) adding the elements at the beginning reverse B and concatenate to A. So if you have a list (1, 2, 3) and generate elements 4, 5, 6 ... you can generate a list (B) (6, 5, 4), reverse it and then do (1, 2, 3) ::: (4, 5, 6) Also, if you find yourself doing this a lot, maybe some other data structure should be considered (if performance is not acceptable). 
Not a stupid question at all.. We usually prefer to prepend instead of append as prepend is in constant time and append isn't when dealing with a linked list. Therefore the suggested way to append is usually to reverse and prepend. Although reverse is not in constant time, it has been heavily optimized or that is what I have read.. :) Better yet, the even better way is to refactor so your code so you are prepending instead of appending.. hth
Let me ask another way. Lets say I am loading data from a database. I don't know the syntax from memory, but lets say I want to load a list with the values from the database and end up with a list. for results { list.add(val) } What is the scala way to do this.
You still prepend to the list. RDBMs doesn't guarantee any ordering on the results (unless you specify ORDER BY, but then, you can use ORDER BY xxx DESC ) 
I believe that pattern matching against case classes doesn't currently use extractors; extractors are a way to generalize and customize pattern matching, so you can apply it to non-case classes, and also match using something other than the class parameters a.k.a. primary constructor (which answers your other question). For your first example the code that's generated is conceptually similar to this, although the actual code might be different. if (aBah instanceof Bah &amp;&amp; ((Bah)aBah).s.equals("foo")) { ... } else if (aBah instanceof Bah &amp;&amp; ((Bah)aBah)s.equals("goat")) { ... } else { ... } For extractors, this: case class Foo(d: Double) val f: Foo = ... f match { case Bar(a,j) =&gt; do1(a,j) } Looks for the following extractor method: object Bar { def unapply(f: Foo): Option[Tuple2[String, Int]] = ... } If the first unapply returns Some(("a",1)) (note, that's a Tuple2 literal in a Some, not just extra parens) that case matches and the values "a" and 1 are bound to the variables a and j which are usable on the RHS of that case. Note that Foo and Bar don't have to be related in any way except that at least one of Bar's extractors takes a Foo as an argument. If you don't have [Programming in Scala](http://www.artima.com/shop/programming_in_scala) it's well worth buying; it covers this topic pretty well.
Thanks - I do have programming in scala, which was why the assertion (made by several folk on scala-users) confused me - PiS states that extractors (as you say) can be used for pattern matching _non_ case classes. The language spec is a little more ambiguous; it seems that a recent update might have switched all pattern matching over to using extractors. 
Yep, it's not bad.
A warning for some, it's a bit dated (as in lift 0.3.0, current is 1.1)
Actually, since then I have found that the Apress book *The Definitive Guide to Lift* is open-source and available online. Click on master.pdf at the bottom of [this page](http://groups.google.com/group/the-lift-book) or use [this (very nearly) direct link](http://the-lift-book.googlegroups.com/web/master.pdf).
I've been flitting between Eclipse, Netbeans and Intellij IDEA trial for the last few days. Nothing seems to work very well. What are others using? I may just give up and use Vim.
Intellij 8's scala plugin works fairly well, it doesn't show some compile errors and the debugger is a bit spotty in jumping to the right line for things, but it does have autocomplete and feels about 70% of the way there. It's good enough for day to day use.
Great addition. I'd recommend Pragmatic Programmer's Programming Scala or this new one from O'Reilly. Either would be good. Don't start with Odersky's Scala tome - it's dense to the point of being boring for Scala newbies. Start with more engaging entry level works first.
What? Boring? Wow, I thought the Odersky book was amazingly insightful and filled with really interesting glimpses into the Scala's design and OO design in general.
"for Scala newbies" was the rest of the that description. I would agree with you, once one has grown their Scala legs.
Excellent presentation, I like that the reasons for going with Scala for some of the Twitter backend work are very rational (and shouldn't have stirred so much controversy in the Ruby community when the move was announced). Also, I posted the video to proggit to reach a wider audience: http://www.reddit.com/r/programming/comments/9onnh/alex_payne_at_c42_why_scala_video/
via: http://www.scala-lang.org/node/3485 Swarm - Concurrency with Scala Continuations
This may be how Scala enters the big time. Lift is great, but another web framework isn't exciting and won't bring in the TDD folks. Sure, you may have to code in Java, but you can get away with writing your tests in Scala.
&gt; Scala is (still) not enterprise ready Actually, I think that's good. Once stuff stats being enterprise ready it usually becomes bloated, uninteresting and the developments gets formalized and very slow.
"Scitter"? Really?
Showing them functional programming compared to imperative is a good idea (I did this and it worked quite well).
IDE integration isnt necessarily scala's strong point right now :) I would show a basic example of a cool DSL (using implicits etc) and a nice example of using Mixin to do something the java guys can only dream of-Eg mixing into a map a trait which overrides the add/remove to print logging messages.
I'd probably show XML processing and generating. It won over my coworkers because java xpath tends to be ugly and groovy xml processing is just poorly done. We didn't set out on comparing all three, but we did end up with implementations of a few xml processing tasks in all three and it was pretty clear in the end that Scala won.
someone recently showed me a scala version of a java class that used constructor-based dependency injection. instead of constructing the object by passing it various 'helper' classes that determined how it worked, they used traits to mix in the functions that made up the object's behavior. as someone that's still pretty new to scala, i thought that was pretty cool because it showed how to do a typical java thing, the scala way. would this be considered a feature of multiple inheritance, functional programming, or both?
I was thinking, this guy is crazy for putting this up. What about file I/O, sockets, etc? Then I printed out his SecurityManager class and it was GoogleAppEngine which is pretty bullet proof, I guess. Kind of cool that Google App Engine security lets one do this kind of applications without too much worry. 
Couple of months ago I was given the same task (albeit 75 minutes), this is what I came up with: http://www.slideshare.net/SanderMak/scala-functional-programming-for-the-imperative-mind
Very cool stuff. I really wish I could start doing my professional code in scala. 
For me, the best part about reading this style guide was discovering the pipeline operator. That was a really nice bonus.
Is there a technical reason for the two-space indentation? Or is that just a preference, like RoR's lower_case_and_underscores_convention?
Like he said, lots of nesting.
Should have read that more closely :) Thanks!
that's kinda weak. basically there are things that are new to him. and it hurts his wittle head. puchi woo.
I'd be very interested to learn why Ruby did not suffice (any more?) for the author. Unfortunately, the author does not allow comments on his Blog. David, if you read this, you mention a number of Scala's fortes. Which are the most important ones that you missed in Ruby (apart from "A high performance language", which Ruby is not of course)? Onno
Here is some talk about it on the [Lift site group](http://groups.google.com/group/liftweb/browse_thread/thread/9d3d2ba81c0030ae/87df4fd58dd414fa?lnk=gst&amp;q=ruby+rails#) 
Donning asbestos underwear... I am a strong proponent of static typing. Ruby does not give this to me. The Ruby community is not a welcoming place. Matz does not care about the people who pay me money (enterprise customers) and this is painful. Ruby has not evolved since 1.8.x. It's still stuck in 2001. In Ruby, everything is mutable... the data, the classes, everything... this leads to lots of bugs. When metaprogramming is used sparingly (as in Smalltalk and Lisp), it's a powerful tool, but in Ruby, metaprogramming is viewed as a floor wax and a dessert topping. This leads to instability. Ruby provides no tools for an architect to enforce an architecture... as a solo programmer, this matters not at all. In a team of 3 or 4 where everyone has a mind meld, this matters little. When trying to manage 4 teams of 10 people, this is nearly intractable. Ruby's syntax is a flexible abortion. Sure, it leads to nifty DSLs, but it's very complex and very convoluted (that's why you need a hand parser to parse Ruby.) In 2006, there was no language spec and nothing that defined the language other than the runtime. Yeah, Charles Nutter Supergenius was able to clone the language, but if Charlie hadn't come along, we'd still be in MRI hell... and as much as I thought Charlie was a god when I met him at RubyConf 2006, I wasn't going to bet my career on his vision and Tim Bray's backing. 
Nice. I was just talking the other day with a coworker about how the major reason we use ORM is to handle SQL dialects for us, so we don't have to re-develop the query layer for every DB. However, we don't like all the other baggage - this seems like it would be one part of a solution for breaking the persistence layer into its constituents.
Still can't seem to get it to work (the weaving option does not exist in the preferences and I cannot see where to choose a Scala project to open). Looking at some comments on the plugin, it seems like it has a long way to go to be stable. I'm sticking with the NetBeans plugin for now, but even that isn't all that great (broken auto-complete, commenting/uncommenting a line without otherwise changing it sometimes resolves exceptions). but this is an area that I hope improves soon. Solid IDE support is vital to improving Scala adoption.
Nice work!
I would recommend the Intellij Plugin, it has worked very well for me. It's free now too that Intellij has been open sourced.
@michaels0620 Try with a plain Eclipse installation. I had problems using the Scala plugin for example togehter with the Google Plugins. 
I prefer the retro twitter clients.
They should really announce these on scala-list or even on the main page of scala-lang instead of hiding the announcement in scala-internals. For better or worse, there are _a lot_ of people using the nightly builds of Scala 2.8 because they have to in order to get decent IDE support with Eclipse and NB. It would be very nice to know when there is a build that may be more stable than most nightlies. It would also be nice to have more documentation about the upcoming changes in 2.8 besides [this](http://www.scala-lang.org/node/1564) terse, 8 months old bulleted list of new features.
Daniel Sobral's rewrite (http://www.bestinclass.dk/index.php/2009/12/clojure-vs-ruby-scala-transient-newsgroups/#comment-1228) is pretty nice ... I wish Lau would include the timings of them as well.
Hmm, this code doesn't work against 2.8.0 RC5. The functional version hangs, and the imperative version blows a stack overflow error. Oops.
&gt; What? You've got a simple solution? It doesn't work with our IDE, which we must use because we're doing complicated stuff. It's a cargo cult. It's complicated because, well, it's got to be complicated. If it isn't complicated, then something is wrong. Wow, I couldn't agree more. Scala is nice but when I see people coming from Java bringing all the complicated craziness along, it is just sad.
&gt;When you start a project and you've got to write out an eight-line mvn command with archetypes and URIs and version numbers. Fuck that. That is such a straw man argument. Most IDEs provide GUIs for maven project creation but besides that even maven standalone makes it so you don't have to type out the command line arguments. &gt;[mvn archetype:generate](http://maven.apache.org/plugins/maven-archetype-plugin/usage.html) This provides you with a little command line powered wizard to create projects. I have to work with maven everyday at work and there are a lot things to complain about but using archetypes is one of the brighter areas.
Declarative dependency management is awesome, and the whole global culture of publishing library artifacts in a way that's amenable to automatic resolution, which exists because of Maven, is also great. That Maven itself leaves much to be desired is hardly a new sentiment. For my next Scala project I'll probably try SBT first.
&gt; the whole global culture of publishing library artifacts in a way that's amenable to automatic resolution, which exists because of Maven Come to think of it, CPAN got there first.
The imperative version shouldn't give any stack overflows -- I find that very curious. But it doesn't matter much, because it is broken. The mutable map update is not being done atomically. But I only wrote it out of curiosity, and didn't spend any time testing it. The functional version works fine here. It must be run as a script -- if you encapsulate it on an object in REPL or an object extending Application to run it, the threading won't be properly initialized. It can be modified to run as an application, but as I tried to preserve the original code as much as possible, its basic layout would need to be changed. It can also hung up if you get an exception inside the actor. In particular, file2String should be protected with try/catch. If an actor throws an exception, it will shutdown, and the joining will never complete. This can happen if the files being read use a different encoding than what was specified. 
Have you seen Buildr? http://buildr.apache.org/ 
Sadly, most of the posts come as "trollish"/Clojure-fanboy. He doesn't seems to know enough Scala to make a useful comparation.
Scala itself is not complicated and, once functional programming is groked, actually becomes rather elegant. Where it falls down completely, however, is its type system description language. When your type declarations look like emoticons (T :&lt; U), you're just asking for trouble. And since these kinds of type signatures are quite prevalent in the collections classes, which is something new users work with quite a lot, they have a very strong ability to scare those same new users. 
Couldn't agree more. The scala toolchain needs to scale down as well as up; I think scala in general needs to get better at accommodating those moving from the dynamic languages world as well as those coming from java. Ideally if there was a single starting place offering clear, canonical advice on best practises from the scala community for stuff like: * Publishing one's libraries so that others can install and depend on them easily (there is sbaz, but nobody appears to be using it; then there are various different tools, conventions and places for publishing libraries in maven-style repositories; it also gets more complicated when you need to make available builds for different scala and jvm versions) * Depending on other people's scala libraries (especially when you need a particular scala and jvm version, or need to build the dependency yourself) * How to installing scala and java libraries locally (jars in the system-wide classpath? jars copied between project-specific lib folders? publish artefacts to a local repository? which should live where and be in which format and managed by which tool?) * Which build system(s) are the best to use, and some background on any java toolchain and build system conventions which you need to know about to get up and running with them and scala * What version numbering conventions to use Would make it MUCH MUCH easier for those of us from dynamic languages background to get up to speed with scala. If only some of these answers were as simple as (for example) "use rubygems" for Ruby; or where there needs to be complexity, for someone to have documented sensible default choices in a way that doesn't assume a lot of existing java toolchain knowledge. So far sbt does seem like the closest to this philosophy, but there are still quite a few gaps for the newbie, and you end up having to know a fair bit about maven etc too to work with third-party code, build third-party libraries etc. And the binary compatibility issues between different scala versions complicate lots of things.
I agree that is really hard on new users, who are likely coming from java land and are getting hammered with implicits, case classes, functional programming, clojures, anonymous functions, match/case/extractors, operators as methods, etc.. I could go on for quite a while... The emoticons don't help learning the language at all. BTW: It's T &lt;: U (not T :&lt; U) which is the same as Java's &lt;T extends U&gt;. ;&gt; I have made that same mistake about 100x. &amp; It gets worse when considering Contra (-) and Co (+) variance annotations which further confuses everybody. I still don't know how to properly combine a &gt;: &lt;: and +/- into one type bound and have to look it up in the Scala library code every time, or trial and error it. Yuck! Though I don't (normally) write classes that use &lt;: &gt;: + -, I only have to use them. The addition of contra &amp; co variance annotations at the implementation site (in the library) is a win over Java ensuring type safety and preventing user errors. I think that new users would be helped a lot by a good tutorial of how to use the collection classes so that they don't have to understand the magic there to get started, especially for the upcoming 2.8 release which makes collections much more complicated to understand with all the builders and so forth. Also java-interop for the collections classes needs to be enhanced significantly, clojure is a lot better in this regard.
Here is the mailing list [topic](http://old.nabble.com/Possible-Collision-Issue-with-Product.hashCode-to27026790.html) at Scala-debate I opened.
Here is a [followup](http://scalide.blogspot.com/2010/01/follow-up-to-producthashcode-collisions.html)
Apparently Odersky has heard the cries and agrees something should be done: http://stackoverflow.com/questions/1722726/is-the-scala-2-8-collections-library-a-case-of-the-longest-suicide-note-in-histo Good to know.
At work: we already switched to Ruby. At home: Clojure's better.
&gt;Lack of mature IDE support. Scala is still quite much behind Java in its IDE support, although the situation is improving slowly. Many Java developers are used to the excellent IDEs that Java has, so some might not want to make the switch to Scala until its IDEs are closer to the quality of Java IDEs. &gt; &gt;At this moment, IDEA's support is acceptable enough for me to begin using Scala in non-critical projects (it has some basic refactoring, navigation and code completion), but there are still lots of rough edges that would need to be improved (the biggest issues are some performance problems and the lack of Extract Method and Inline Method refactorings). This comment is spot on. I was excited about Scala until I tried the eclipse plugin. Code formatting and refactoring didn't work. It would mark errors on lines that the Scala compiler would accept. It would do that for code as simple as a HelloWorld app. I know there are alot of developers that are happy with the command line and a text pad but I really enjoy all the features of modern IDEs so alas I scrapped my Scala dreams... for now. 
Needing an IDE tells you that your code is ravioli. For this reason I have come to consider editing in "vi" as good discipline.
&gt;Needing an IDE tells you that your code is ravioli. Or you are working in a large code base with a team of other programmers. Code formatting is useful to make sure you are adhearing to the defined style standards. Type a blob of code Ctrl-Shift-F blamo code is in the proper format. Being able to click any class, method or property that is used in a section of code and press F3 and jump to the definition even when it is siting in other files. Clicking on the name of a class and pressing Ctrl-T and seeing the entire type hierarchy for that class type. Being able to locate a class file in your code base AND in any included jars by using Ctrl-Shift-T and typing the name of the class. You don't even need to know the full name of the class it suggests as you type and you can use regular expressions if you only know part of the class name. I guess I am saying IDEs are useful when you are dealing with large code bases with a team larger than one. They help you find information quickly and better understand the system.
IDEs let you navigate a myriad of entangled objects and a bushy type hierarchy. It's bad if you need either. As the codebase gets big it should break into components and layers, without cross-boundary sharing. Code formatters are great! And you can call them from vi.
Why do you say Clojure is better?
Scala was designed by someone who knew Java/JVM very well, with the intent of being a language exploring mechanisms for composable scalability. But outside that intent, especially in the library, it doesn't seem to be a *deeply considered* language. I could list out many individual things in Clojure that are better, but what's more important is that the whole is very deeply considered indeed. Everything interlocks with everything, and there are good reasons for all of it.
&gt;As the codebase gets big it should break into components and layers Even if I accept that a codebase broken into layers and components no longer sees benefits from an IDE's navigation features, most of us do not get to pick the design of the codebases we work on. We inherit it on the first day of the job. And getting buy in to do a complete redesign of the current codebase is really hard to do. The most you will win is bugfixes and small rewrites. From what I hear this is how it is for most people in the industry and given that you don't get to dictate that the code you work in is not ravioli why not use a modern IDE to make your life easier?
Um, if I need to rummage in garbage, of course I will use rubber gloves. I've used IDEs before on codebases exactly like the one you describe. I just don't like to have to - it's a huge indication the codebase is unmanageable, verging on a danger to the business.
Which Clojure book do you recommend? I assume you've read Odersky's book on Scala, which discusses the deep consideration behind the various features :) 
Scala is currently fine for hotshot startups where all of the developers are A-tier. In an average enterprise where you have a mixture of skill levels, it's important that there's a decent safety net to help people stay productive while on the learning curve. That safety net is not currently present; this is why decent IDE support is so necessary.
Cool, thanks for taking the time to provide a detailed response.
I like deeply considered point of views :) 
I don't *need* an IDE - it's just nicer. I don't need a silk shirt either, but I'm not going to start wearing a hair shirt to prove it.
It's only nicer if you need it. Otherwise, the slow memory hog nature of a full featured IDE gets to be more annoying than its features are helpful. Something like gedit or vi opens in a snap and you're just coding, right away.
"It is only nicer if you need it" - this is just not true, it is a religious statement really. Don't tell me what I need and don't need, thanks. It is just that there's a certain cadre of programmers who think they "keep it real" by using crap tools. vim in particular is an abortion - taking an editor intended to be small and simple and appending a bunch of shite to it. Its for people who hate unix. It is vi, not emacs, embrace this. Fact is, most IDEs bring useful stuff like detecting errors immediately, code completion, and refactoring. You might be able to get this stuff in vim by calling out to god knows what, or using flymake and similar in emacs, but by that point you're not actually using an editor anymore. You're using an IDE. Which works out the box. PS I have 3.5gb RAM left over after starting eclipse - it uses memory, but it doesn't hog it. I can understand this being a concern if you are using a 5yo computer, or a netbook tho. I also only start an IDE on a monday morning, and leave it open all the rest of the time. Restart time is irrelevant unless you're writing trivial code - sysadmin scripts and such. Editors (especially vi) are useful for editing on servers (vis ssh), editing sh scripts and cfg files, and in general random quick stuff. For that you want flexibility, agnosticism as to the file type, and rapid startup time. However, for extensive work on non-trivial projects in one or two languages I want a tool that understands what I'm working on as much as possible. I don't *need* an IDE like you assume - I could certainly write code in vi and not find out about errors until build time, and spend half my time looking up method names in javadoc &amp; scaladoc. If I wanted to project some "macho" image and was working on trivial stuff, maybe I'd do just that. But not otherwise.
Scala was designed with libraries as a focal point. A whole point of being scalable are libraries. Standard library is extremely good and there is ScalaZ. An Yes, Lift kicks ass.
lol. I'd like you to tell me the largest LOC project you've worked on? 
I got your sarcasm. 1 Upvote from me. 
Needing a car tells you that you run slowly. Not needing an IDE tells you that you can not use IDE to speed up your development process
I'm glad I'm not the only person who ran into show-stopping issues trying to write 'hello world' with the Eclipse Scala plugin.
There's a lot of good stuff in here to learn a lot of the corners of Scala.
Apparently the ideas are kind of like a "want to know more?" expansion thing. As in Foo[] is generic, and then you just click expand it away to see that Foo[A &lt;: B with C]. I wonder if it could be solved with more examples.
Pretty sweet feature request here as well: http://youtrack.jetbrains.net/issue/SCL-1724
Works pretty well for what I need. The only annoyance is having to remember to call add after each element, however I cannot find a way around that and still preserve ordinal ordering.
I really wish more blog posts were like this. Informative, good explanations of pros and cons without any flames and seemingly with no obvious technical errors. And not too wordy. 
A transcript is available in the "speaker notes" feature. Go to the bottom, under Actions, and select Speaker Notes
love it 
Took em long enough ;)
Discussion at /r/programming: http://www.reddit.com/r/programming/comments/ax3tt/following_twitter_foursquare_moves_to_scala/
i'll agree to that one!
Netbeans and Eclipse both have working plugins for Scala. You get some pretty decent autocompletion and type inference. They aren't perfect, but it's definitely better then going for something general like vim or emacs. 
I had heard that these were barely operable at the moment, but I might be mistaken. I've been using TextMate with the [Scala bundle](http://harnly.net/2007/blog/geek/macosx/textmate-bundle-for-scala/), but it's only on OS X.
 I will give what I use, but in no case it's what I would advice for someone who is starting Scala/Lift. I use Scala 2.8 nightly, with Eclipse plugin nightly, with Maven and Maven/Scala plugin, with Lift 280 unofficial port compiled by myself every days. I use eclipse because I know it quite well, I like most of the look and feel, I know how to repair it when it crashes - what happen rather often. But that is almost no help for you. Based on the question, I understand that you don't wan't to use emacs/vim or a light editor and that you don't know any of the 3 main Java IDE, or you would just go with it - learning well vim/emacs or an IDE is quite a big investment, not the one you want to do every three mornings. And each one has it's own look&amp;feel, its idoms. So, in the end, I would just let you test the 3 main IDE (Netbeans, Eclipse, IntelliJ) and see what is the one you feel the best. What is generally reported is: - IntelliJ is the best IDE, with the best Scala (both 2.7 and 2.8) support. - NetBean last version is really good, the Scala support is quite good, but only for Scala 2.8 - Eclipse is a monster of plugin integration and dependencies, the result may be good, but sometimes, given how the moon and Uranus are aligned, things break. The Scala plugin comes from a long path, but still as a long path to go - I'm talking about the 2.8, just forget about the existence of 2.7 one. All in all, it works most of the time. And more importantly for me, it's the only one that seems to feet my mind and habits. So, now that IntelliJ is free, perhaps you could start with it. Hope it helps, 
I wouldn't say they're barely operable. The netbeans one (the only of the 2 I've tried) works fine for me. I really don't get the textmate hype. Even a broken plugin (which it's not) in netbeans is better than textmate. Netbeans has live templates, too, but it also has autocompletion. Another neat feature is even when you don't explicitly state the type you can hover over the variable name and netbeans can infer it, just like scala does.
I use Eclipse with the Scala Eclipse plugin which is, I would say, semi mature. It's not bad but there's a few kinks that they still have to fix. Code completion is nowhere close to Java but it's better than Notepad. Two things I would like to mention is that I'm not sure about Lift support (haven't tried it yet, definitely will) and that the Specs library has not been compiled to 2.8 yet which means you can't use it.
Actually, I know java quite well for years (started with VisualAge for Java &amp; JBuilder) and I use Eclipse in my day to day work. Give a try to Scala is a potential occasion to try another IDE (may its Scala support be helpful) thanks for your advices ...
Right now hands down Intellij works the best. Hopefully the eclipse plugin will catch up ( I used eclipse for several years before switching to Intellij) I do scala development in Intellij everyday and it works good enough. One suggestion that I have though would be to set up sbt &amp;/or maven to build your project (Intellij can read the maven files &amp; sbt has a much better incremental compiler than Intellij).
I'll definitely check this out. Personally, I'm partial to Eclipse, but I'm not married to it.
I had a lot of problems with Eclipse Scala 2.8 -- to the point where the editor had random StackOverflow errors while I was editing code. This forced me to switch to NetBeans, which is more lightweight, but has inferior Scala support (namely NetBeans was reporting errors where there weren't any). Enventually I switched back to ant and vim, and am pretty happy with it now ! 
I dunno if I would recommend Eclipse- I thought 2.7 plugin was bad and was all excited about the "new and improved" 2.8. But the new plugin seems far worse-Fewer bugs, but it randomly hangs for a bit frequently.
Sorry for the previous entry (without the link), was posting for the very first time.
&gt; The drawback is that there is no way to disable these checks That's only half true. `assume` gets blanked out if you disable assertions. If you check the source for `Predef.scala`, you'll see it's marked with `@elidable(ASSERTION)`. The same is not true of `require`, presumably because argument checks are a matter of security, not just development.
No. The JVM doesn't have immutable objects, only immutable (`final`) references to them. If you want your collection to take arbitrary objects, you can't ensure those objects are immutable.
Thanks duyn! I fixed the article and mentioned you as the person who pointed it out.
I can't read the article (seems to not be responding), but theoretically you could require that all items have the [Immutable](http://www.scala-lang.org/archives/beta-api/scala/Immutable.html) trait. This isn't checked for correctness at compile-time in any way (and is obviously not consistently applied throughout even the Scala API), but requiring the classes which are contained to mix in Immutable is at least a _strong_ hint that they should have those semantics. Not an ideal solution (or arguably a solution at all) of course.
I was able to get the Scala plugin for Eclipse working only after a new install of Eclipse. It leaves a lot to be desired right now, but I hear it's getting better.
Specs is actually available for scala 2.8. You can find it here:http://www.scala-tools.org/repo-releases/org/scala-tools/testing/specs_2.8.0.Beta1/1.6.3. Eric.
Brilliant! I was trying to figure out how to do this last week for an app I'll be working on soon. It took me two evenings to get a hello world going! But now I won't have that trouble again and I can even dump eclipse for SBT. Thanks!
Here's a nice presentation by [Dustin Whitney](http://twitter.com/dustinwhitney) of the [New York Scala Entusiasts Meetup Group](http://www.meetup.com/New-York-Scala-Enthusiasts/) on Akka: http://www.vimeo.com/9529440
It's early days for Scala still, so perhaps such a book was premature. Give it a year or two and there will be a market to sustain such a book. In the meantime, it's great that he is still working on the book for free on github.
I admire Robert Fischer's ability to “professionally blog.” He delivers no useful content, but he does it with inspiring attention to page hits and comment controversy. Yes, Scala is a multiparadigm language. Yes, Perl is one too. Yes, they both share features from Common Lisp. That’s not really worth my or your time. But he cleverly used the confrontational tone to make the blatant non-issue into a controversial issue. He cleverly used Blogosphere’s beloved “Scala” and “Perl” tags in a single article. He nagged about a minor syntax issue like it was life-or-death as only a true master-of-functional-programming-who-blogs-more-than-he-actually-programs can. Bob is my hero – truly, a Dilbert’s Wally in flesh. A guy without any real code to show – but who [“realigns the tone of existing projects” and whose “technical leadership focuses on pragmatic communication”](http://smokejumperit.com/) like there’s no tomorrow. Wally – sorry, Robert – do you think you could write some posts on how to professionally sell bull and call it “technical accomplishments?” Many of us CompSci majors would like to get in on this money for nothing scheme. Unless, of course, you’re not comfortable writing about things you actually do know a little about. 
Scala is very strongly typed. Perl is just about the most loosely typed language there is. Strong/Loose typing is just about the most fundamental distinction between various families of programming languages I can think of. Maybe the author hasn't actually worked with Scala enough to realize how much type inference the compiler does. He probably just looked at the syntax a bit and thought, "this must be a loosely typed language! How else can you do duck typing, monkey patching, etc in a non loosely typed language?".
Although the personal attack is a little gratuitous, I agree with you: Robert's post is an EPIC TROLL. Now, let me go back to my next blog post: "Ocaml: OO, functional or just PHP++?" 
It's hard to tell sometimes if a post is a joke or off in complete-crazy-land. BEAM replaced JAM. Not JVM. JAM was written 1989-1990 in C. Erlang never ran on the JVM until some recent third-party effort to write an Erlang implementation on top of it. BEAM itself existed a full decade before Terracotta Inc. was founded. Heck, Erlang had HiPE before Scala was conceived. Distributed Erlang -- note that this wasn't the first version of Erlang -- was first used in a product in 1995, around the same time that Java 1.0 first appeared. The first version of Scala didn't appear on the scene until 2003; Scala had nothing to do with Erlang's design. If this post is a joke -- whoops. If this post is serious -- the author is making everything up.
&gt; If this post is serious -- the author is making everything up. It is utter bullshit.
I went through commits 347 - 673 in the old CVS archives of the Erlang project, there's no mention of scala or JVM there.
Yeah it's crap. The original Erlang implementation is known to be in Prolog, hence the syntax of Erlang (to some extent anyway).
&gt; It's hard to tell sometimes if a post is a joke or off in complete-crazy-land. Well, the "serious bzns" tag might be a hint.
I built this [website for recipes](http://estful.com) in Scala. I also use it for my work, deciphering large datasets.
That site is pretty cool, is made with Lift?
No, I just made Servlets with embedded html: def doPost(...) = &lt;html&gt;...&lt;/html&gt;. For a database I use Amazon's SimpleDB and S3, which was a whole lot more work than it needed to be for the traffic I get. :) I should give Lift a go. I'm not opposed to frameworks, I just enjoy working with Servlets. And Scala's xml literals means no need for something like JSP.
I've been working on a space fleet sim as a hobby project. My first attempt at a game and as good an excuse as any to learn Scala. Work is primarily a Java shop, but most tools I make, I make by myself for a limited number of users so I can choose whatever technology I want. I've just started on a small Scala desktop application that will need to read in SAS datasets. Where I work is almost exclusively Java (primary Java web apps), but because I build tools by myself for small groups of users I have a free hand in deciding what to use.
surfing porn
Mostly just playing around for now.
Learning programming concepts and how they can interact. And hobby projects.
Is your game open source? I've been wanting to build one of those for ages too.
I've got two Scala projects on the go at work but I'm not sure I should say much about what they are.
I'm using scala for a query analyzer in apache solr as a plugin. the interoperability with java works great. I just implement the java interfaces in Scala and Solr can use it fine. 
electric power network analysis and visualisation
Driving Selenium RC tests with our own web testing framework (DSL) on top of JUnit.
I've been doing project euler, and I've been playing around with the idea of building an irc client. For now I only have a "bot" sitting idle in a channel, anwering to ping messages.
Well, good luck on your way!
Seems like the website is down, so I have no idea what this looks like, but it's good that there is something lighter weight than lift. Edit: Available again, looks nice.
Just writing a Texas Hold 'em poker hand evaluator in order to learn Scala and try some algorithms for hand evaluation. I'd like to have Scala as a work environment, although I'm inclined to use version 2.8 and it may not be stable enough for heavy-duty applications.
I don't want to be negative, but, is there anything really here? This looks like a basic template engine, nothing particularly scala-esque about it, and there are certainly a lot of these things about. If this is just for fun, that's great ... but is there really anything of substance here?
At work: we rewrote some poorly-performing bits of a Ruby web services API in Scala, with scala and jruby deployed within the same servlet container. Side-project: I'm doing some music theory experiments in scala. Still waiting for 2.8 to be finalised though - I want the new collections stuff! hurry up and make it stable! :) 
I'm not aware of many well maintained scala web frameworks. lift isn't to everyones taste, so I'd consider this significant if it becomes maintained and polished.
Is there anything particularly functional about it? It looks like another templating system, that just happened to be scala underneath.
I agree... doesn't seem very scala-esque. No blend of OO and Functional. It seems they want to *eventually* have well supported scala.
I did introduce it at my last job, where we used it basically like java but with less code. It generally took me 3 iterations to kind of figure out new tools and ad-hoc frameworks, and things started to slide together pretty nicely. I also have a couple of hobby projects: like a [markdown parser](http://tristanhunt.com/projects/knockoff). I'm also experimenting with a literate-programming system, though that's more in the "let's see what happens" stage. I'm currently altering my markdown parser to work more like a Haskell project that's more of a document-conversion tool. Even reading about Haskell has been enlightening when it comes to the functional features of Scala. I'd recommend learning it to anyone. I'd be very curious to see if anyone's had experience making Scala APIs that can hit languages across the JVM spectrum - the ones in my mind are Java, Ruby, and Clojure, but Groovy would be cool too. My sense is that if it can be used in Java, it can be used across the board pretty easily.
This sentence no verb?
Simply the best learn-to-program environment I've ever seen.
[The Staircase Book](http://www.artima.com/shop/programming_in_scala) is pretty much where it's at. O'Reilly's [Programming Scala](http://programming-scala.labs.oreilly.com/) is available freely online, but I don't know if it goes in as much detail as Programming in Scala.
thanks!
[Programming in Scala](http://www.amazon.com/Programming-Scala-Comprehensive-Step-step/dp/0981531601/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1269220325&amp;sr=1-1), co-written by Scala's creator, is the most detailed and authoritative book on the language. Highly recommended. I also bought Pollak's [Beginning Scala](http://www.amazon.com/Beginning-Scala-David-Pollak/dp/1430219890). It's a much slimmer book that tries - and, in my opinion, succeeds - to be a crash course in Scala's best features. It's important to note that Scala 2.8 final is expected soon (2.8 beta pre-release is already available), so you might wish to wait for updated editions of Scala books. Scala 2.8 brings some important improvements and breaks the backward compatibility in some minor ways.
Glad to see someone got around to doing this.
i like this concise book, scala by example http://www.scala-lang.org/node/198 additionally, the research papers: Scalable Programming Abstractions for XML Services, ScalableComponent and the other ones listed on the scala-lang.org were really helpful.
No, I'm not.
http://stackoverflow.com/questions/1854246/what-is-the-best-book-for-learning-scala-for-an-experienced-programmer http://groups.google.com/group/javaposse/browse_thread/thread/92fa0d16e8ecfc6 The 4 books that are out are all worth reading. I've read most of Subramaniam's Pragmatic book, it's a very gentle intro to the language. The Wampler /Payne Oreilly book is similar to Flanagan's java and JS books, and the Oreilly Erlang book, i.e. gives you a decent percentage of what you need to know in a dense presentation format. I remember the Pollak Apress book as worth reading as well, preview on [goog books](http://books.google.com/books?id=CSqKcTMJB1IC&amp;printsec=frontcover&amp;dq=site:books.google.com+pollack+scala&amp;source=bl&amp;ots=LAyNiKFhqs&amp;sig=umt0wrRKLAYRY7lbrq5sOA94c6Q&amp;hl=en&amp;ei=iC6qS4jBBY7SNYfOobkB&amp;sa=X&amp;oi=book_result&amp;ct=result&amp;resnum=1&amp;ved=0CAkQ6AEwAA)
I read the one from Martin Odersky: http://www.amazon.co.uk/Programming-Scala-Comprehensive-Step-Step/dp/0981531601/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1269246979&amp;sr=8-1 and the one from Dean Wampler. The Wampler one is shorter and a bit more critical of Scala, but in my opinion the Odersky one is better for starters.
Actually the O'Reilly book is extremely tiresome IMHO. But I use it anyway because it's online and free. The amount of crossreferences they keep writing about makes you dizzy though, but just ignore them.
I enjoyed Beginning Scala, mostly because it talks you through scala as someone who is familiar with java, but not with functional concepts. 
Not sure whether I am impressed or disturbed.
Programming in Scala is a surprisingly good read; Odersky has a sense of humor, making the book all the more compelling.
IMHO, The reason this is not that disturbing is it's all statically type checked. They've not only created a basic DSL, they've created a statically typed basic!
Yes and no-since variables there are just symbols, you will discover a variable isn't declared at runtime.
Ugh; I just bought 'Programming Scala', but don't have any Java background. I was hoping for (I realize now) something like the Ruby pickaxe book, all-in-one; explanation and reference. I guess I need to get a Java book to learn the collections API. Does the Odersky book have those? Maybe I'll exchange this, even though Odersky's is 2 years behind. &lt;/free-associating&gt;
to be fair, the DSL is named "baysick"... that gives you a pretty good idea of what to expect :)
There is a contention in Scala's type inference between "doing something useful" and "not requiring explicit type annotation." Ultimately, the type inferencer doesn't do much at all.
I was pretty happy with the sequence in books I read. I started with the on-line O'Reilly "Programming Scala" book by Wampler/Payne. This provides a fairly light intro, but if you're a good programmer you'll wonder how all of Scala's wonders are accomplished. The next to read is the Odersky book, "Programming in Scala". This will give you the blow-by-blow of how the language is built. This book is essential if you're an above average programmer and want to understand what's going on. Some of it will probably go over your head, but in the whole it's very readable. Then I read "Beginning Scala" by Pollack. This is not a book that should be read by beginners, it leaves out too much, so there is too much "magic" for you to misunderstand. But after the other two, it's a fine read.
Thats a great example of using scala for a DSL. It reads so much better than the Java version.
repost of http://www.reddit.com/r/programming/comments/bjb11/is_the_scala_28_collections_library_a_case_of_the/
this would be a really useful feature since the scala is one of the best ways to implementing a DSL
Let the foolishness commence!
Good one... I almost read the whole thing in amazement till the paragraph about Oracle. Hint: Check the date
Admittedly, I almost fell for it.
Oops, SimpleDateFormat isn't thread-safe...
Can someone explain me why this news is so hot?
It's nice code to read, it does something useful, it gives a name to something I use all the time but never knew had a name (transducer pipeline). An enjoyable read all around.
Is IDEA that much better than other GUIs?
Why don't you just try it? You got 3 responses saying yes. The community edition is free.
Personally, I like netbeans. Although I had to fiddle with some XML files to get things to build with 2.7, with Scala 2.8 and netbeans 6.8 everything has been seemless. I was also able to get a self contained netbeans &amp; scala environment running entirely off my USB stick. Convenient for when I want to do some hobby programming on my work machine during lunch.
yes, and it's support of 2.8 is better than 2.7
Any word on performance compared to the 2.7 or the previous beta release? I noticed a mention about compiler speed increasing, but nothing about whether there were any run-time speed increases.
my CE9 (comm. edition) experience, 5 days worth on my MB pro (4g RAM), has been positive. Another (experienced java/C++/IDEA 8, new to scala, guy) with scala plugin, similar MBP: freezes need heap bumped up to 1 Gig. (I've also seen people pretty happily coding scala with emacs, vim and textmate plugins, as long as the syntax highlites worked) http://dir.gmane.org/gmane.comp.lang.scala.tools http://www.jetbrains.net/devnet/community/idea/scala 
I'd really like it if the simple cases of the `for` loop were optimized; in some cases, while is an order of magnitude faster.
The @specialized annotation should help, it replaces objects with primitive types when possible, with some microbenchmarks reporting a 40 times speedup: http://lamp.epfl.ch/~dragos/files/scala-spec.pdf
That font makes my eyes bleed. 
Ive used lift for some simple stuff and it seems like the way to go. Documentation is pretty terrible but people on the mailing list are very helpful. I believe the 2.8 version isnt anywhere near ready, however.
Indeed, it [isn't](http://scala-programming-language.1934581.n4.nabble.com/scala-Lift-will-be-sitting-out-RC1-td2004646.html#a2004646)
I have to say I dislike Lift. Ok, it's not the worst kid on the block, but it's just too tempting to leak lots of presentation XML into the middle layer (components, navigation, lifecycle). I don't quite see how that's better than leaking the opposite (like most other template systems for Java), or even better, not leaking at all (like Wicket). By the way, you can use any java framework with scala, you still get most benefits of having your code in scala. 
the Scala section is incomplete, anybody knows how to contribute?
Lift is great but the documentation is horrible.
You have to really police yourself on keeping the presentation out of snippets as much as possible, that's true. But you have to police yourself about lots of things.
I like a lot of stuff about Lift, Box[T] and how they do Ajax for example. That said, I like Play! more because of the simplicity.
&gt;Scala is strongly statically typed. I know the dynamic &gt;language folks claim that static typing is a crutch for not &gt;doing unit testing I don't get this. I would sooner say the level of inane unit testing required in dynamic languages is a crutch for not having strong static typing.
I'm getting old... give me back BASIC.
Why use something named Cascal when you can use a library named [Scromium](http://github.com/cliffmoon/scromium) which probably has the best FAQ ever written? &gt; And that will allow you to give a Fuck and get a Fuck as long as that implicit object is in scope. (later on) Fuck" should { "do some shit" in { cassandra.keyspace("fuck_shit") { ks =&gt; ... 
Oh good, some lift documentation. Is there something about Scala that makes it hard to document? It seems the types and function signatures can be combined in so many different ways with implicits, etc that things can get a bit complicated.
 import java.lang.Integer val c = new Comparator[Integer] { def compare(x: Integer, y: Integer) = x compareTo y }
Many thanks.
BTW, I'd suggest you create a class that is a trait such as trait Comparable[T &lt;: Number[T]] { def &lt; (x: T): Boolean; //... etc for &lt;=, &gt;= and &gt; but not ==, // which is part of AnyRef, but you can override == when needed } class MyInteger extends Number[MyInteger] with Comparable[MyInteger] { def &lt; (x: MyInteger): Boolean = ...; } This may seem to be verbose b/c you're making a delegate of some more primitive class type, but what you are doing in the long term is tying the fact that something is Comparable to another as a mixed in trait. You get to have the trait without making a new anonymous class each time you need to use the trait.
Sorry if this is a repeat, but I wanted to remind everyone that the CUFP call for proposals is still open.
In case Comparator wasn't just an arbitrary example, did you know that trait Ordering[T] extends Comparator[T] So you can use a scala Ordering for a Comparator. The stdlib makes lots of useful Ordering instances available too, many of them via implicits, so it's relatively rare that you'd have to make one yourself.
Thanks. You were right suspecting that Comparator was picked as an arbitrary example for the sake of argument. Anyway good to know about Ordering[T].
Don't use Java collections in Scala - you should use the Scala collections. The Odersky book covers them, but not for the upcoming 2.8. Your best bet is probably to read the Odersky book and then read the whitepaper on the changes for 2.8.
Why would you need a Java book to learn the Scala collections API? 
The Netbeans plugin for 2.8 is *super* and free. But compilation is much slower than Java.
eat your heart out Java
Make sure you read comment #4 by Erik Engbrecht before drawing any JVM vs Mono comparisons. Using the Sun's Java gave a runtime of 1.5 seconds vs 83 seconds with icedtea. 
Did the .NET port get updated? Last time I checked it was at version 1.x and that is pretty old.
See the article [PHP to Scala, Scala to JavaScript](http://www.scala-lang.org/node/6394), too.
Speaking as someone that used eclipse for several years programming java and who tried for a long to use it to develop Scala, I would strongly suggest using the Scala plugin for Intellij Idea. I know it kind of sucks switching IDEs but for us at work (I run a startup and we code exclusively in Scala, we're over 50K LOC) it's worked great. Unfortunately, not yet java in eclipse level great but close enough that we can code Scala much more productively than java in IDE. A problem with Idea freaking out has been the rare exception rather than the rule as it is in the Scala IDE for Eclipse. Idea is free now and has an eclipse keymapping included, which i use because my brain is wired for eclipse keyboard shortcuts. One caveat you have to chose an appropriate plugin release depending on if you are doing 2.8 or 2.7 Scala. Also for getting continuous compilation going with it I would recommend running sbt in a side window. Sbt can generate Idea project files or maven files for you as well which Idea can use for its module (project in eclipse-speak) and project (workspace) structure. If you are really interested in hacking further I can do writeup on how I use a combination of plugins to run sbt in the console window in Idea and get clickable error messages that pop up in real time as you code. Good luck, sorry for not directly answering your question, I am not an eclipse hater by any means, just a pragmatist, and right now for us, developing Scala in Idea is a joy versus Eclipse which, again subjective opinion here, is a pain.
Salute. I hear you.
The scala plugin obeys the java editor preferences (at least such things as "spaces for tabs", indentation, etc.).
No. In Scala default parameters can be arbitrary expressions, and they are resolved at the callee, not the call site.
[Miles Sabin](http://www.scala-lang.org/node/2119) is the main guy behind the Scala Eclipse plugin. He is actively looking for contributors so have a look [here](https://www.assembla.com/wiki/show/scala-ide/Getting_Involved).
How about Scala &amp; Guice? Sounds better to me.
Hmmm, 4th page... Long way to go ;).
Hrm...what can we do to make scala popular? Get rid of inheritance and only use traits! I think it would simplify the insanely complicated type system... Ohhhh... you meant without changing the language. 
Making it visible and popular are two different things. We could make it visible by putting up massive billboards, that wont necessarily make it popular. I have been using Scala now for two months on a very specific project that was just horrible to implement in Java, but I wanted it to be Java interoperable. I use Eclipse (I have not found a better editor) and problems like the entire project not building because there is one error in a class, every time I get an error I have to clean and rebuild the project just to make sure it is the right error. The only reason why I don't recommend everyone to use Scala to every person I meet (programmer or not) is because of tool support.
Seconded! A better IDE would help. With the richness of the type system, I'm sure you could get all kinds of amazing refactoring going.
Try IntelliJ Idea with Scala plugin... Way better than Eclipse!
Already above assembly, haskell and f# :)
he's talking about popular not better :)
keep writing kick ass code in it! :)
A central package management system. Maven has the repo file structure setup well but it's really hard to find packages. I have to google for the maven package name(and version) AND the maven repo. Then copy and paste the Maven XML snippet to the pom file. I haven't used SBT too much yet but it looks like I would still have to look for the package name and the maven repo that has it. I think Ruby Gems is the best package management system. Just do gem install package-name or gem uninstall package-name. All ruby gems are in http://rubygems.org/ so there is an easy reference.
When 2.8 comes out, IDE integration needs to become the focus for a while. Statically-typed languages need good tool support because they can have it much more easily than dynamically typed languages. Java has it. C# has it. I see Scala as a competitor to C# (it actually feels like a language mid way between C# and F#).
Why can't these open source project learn some things from big corporate industry. Java has had 1-2-3 major versions over the last 10 years. 1.4, 1.5, and 1.6. Some people are still on 1.4. As a developer, it doesn't make sense to upgrade or make major changes every couple of months when you have systems out there that have 5-10 year lifecycles. Quit trying to fix shit...all the time.
I think relatively few people would argue that Java's lack of progress is a good thing. Granted, Scala's lack of binary compatibility is a bad thing, but it's a tough problem when you have compile-time mixins.
Scala: putting the C++ back into Java.
Tell more? Is it a web startup? Do you use the lift framework?
Of the 7 similarities presented, 1 is a restatement of the thesis ("Scala and Clojure are more alike than different") and 2 actually point to differences ("Clojure more Lisp style, but with objects" and "Scala more C style, but with functions"). 
I agree that it is not a good thing as measured in developer productivity. But it is also a fact that it is the most widespread enterprise language and therefore these choices have been successful for adoption.
The more programmers who use it to build sites with, the more popular it'll be. Right now I think having to know server administration is a huge bottleneck. I'd like to learn Scala / Lift but I don't know anything about server admin.
Note that it's not [*Indrajit* Raychaudhuri](http://www.google.ca/search?q="Indrajit+Raychaudhuri"+scala), the prolific contributor to Lift, it's [*Nilanjan* Raychaudhuri](http://nilanjan-braincasting.blogspot.com/).
Its not as much Maven for Scala as Maven *in* Scala (I beleive sbt supports Java as well now). I do think its considerably easier to use, however.
public view of the responses at http://spreadsheets.google.com/ccc?key=0AoQaKTzyxVl_dEtVclNLLUxuQzUtVXhSZDRfNWRFZlE&amp;hl=en#gid=0 for comparison: state of clojure summer 2010 http://muckandbrass.com/web/display/~cemerick/2010/06/07/Results+from+the+State+of+Clojure,+Summer+2010+Survey raw: http://spreadsheets.google.com/ccc?key=0AqULylOQcEq1dDVXY0ZfWlNfdXl0TW43S3dJcTFvU1E&amp;hl=en#gid=0 
How is it compared to Netbeans?
Some people I've talked to about it slammed on the brakes when they read about the binary incompatibility between releases. That *has* to stop for the language to get widespread traction. 
I'm using the IDEA Scala plugin, and it's really good for showing you syntax errors. On-the-fly type resolution, not so much. In other words, it won't alert you if you're sending an Apple into an OrangeConsumer.
Love the idea and am personally very interested.
Another RC should be released by Monday due to this bug: http://lampsvn.epfl.ch/trac/scala/ticket/3560
A nitpick: instead of `Class.forName("pkg.bluh")` you can do `classOf[bluh]` (assuming `pkg` is imported, of course).
Fixed.
found via [this](http://stackoverflow.com/questions/3035807/what-can-i-do-with-virtual-classes) stack overflow post. It's a common enough pattern that it's worth knowing about, though I am not sure it merits an actual language feature. Though, [design patterns](http://stackoverflow.com/questions/327955/does-functional-programming-replace-gof-design-patterns) can be seen as "patching up shortcomings in a language" it doesn't necessarily mean that the language itself should be patched, (the talk of the compiler plugin.)
Thanks. I actually think that's a very fair commentary. I like that it doesn't bash Scala for having these features that go against the original idea of Java, simply points out that they're there. The title may be technically true, one is not 'better' than the other, they simply have different intended purposes/audiences--though it is somewhat inflammatory. Do I agree that Scala should be confined to a programmer-oriented scripting language? I don't know--I happen to like its expressiveness and being able to do things in a functional way, but I do have my reservations about it getting write-only like Perl or C++ if its features are not used carefully. And because of the care that I think is required, the argument in this article did remind me why Java is programmer-unfriendly to begin with. 
I think that the last paragraph: &gt; Java is deliberately not programmer-orientated. That's the point of using it — it was designed to restrict the kind of trouble programmers can get themselves into. If you're stuck with the JVM, I guess the question is: how much rope do you want to give your programmers? pretty much nails the waterfall model of thinking, that the programmers are nothing but low-level technicians whose sole job is to transform the architectural and functional specifications (written by software architects, not programmers) into code. Anything else is beyond their capabilities and the environment and tools should be built accordingly. If I'd have to work in an environment like that, I'd sell all my programming books for a good set of tools and would become a carpenter instead.
&gt; but I do have my reservations about it getting write-only like Perl or C++ if its features are not used carefully. I think you and me are in the same camp on this issue. I find Scala interesting and it's functional aspects interesting, but I have serious reservations: * Complex type system - Many people find Java's generics too complex, but Scala's is much more complex. * Too implicit - Implicit behaviour is handy if you are writing code, but it can be a nightmare when trying to read and understand code. Considering that code is read many more times than it is written, the programming language should support readable code over clever implicit behaviour. * Too flexible syntax - What a piece of code means and its structure depends on too many things which are declared elsewhere. I can't see how this can't lead to really obscure compile error messages, especially when combined with all the implicit stuff. In a nutshell, I much prefer Python's and Fantom's design philosophy over Scala's, Perl's and C++'s. 
All of these aspects can be solved with good documentation and coding standards. Java code can be just as unreadable without these as well.
&gt; All of these aspects can be solved with good documentation Now you've two problems. Now good documentation has to be written to make up for the fact that your code and language doesn't encourage readability. I know what the real world chances are of good documentation being available and maintained. Although it might sound cynical, the source code really is the best documentation of the system and what it does and how it works. &gt; Java code can be just as unreadable without these as well. I would have to disagree with you on that one. You can make Java unreadable, but it is harder to do so compared to, say Perl. 
Yes, "Scala as a better Java" is not good. What about "Scala, a way better Java" or "Scala, like Java but for grownups"?
I have read horrible, absolutely horrible Java code. One thing that code can never replace is good documentation. Standards are there to make sure that the code is readable, the strict adherence to these standards is one reason why Java is readable; for instance, Java bean naming patterns (get,set,fire).
To be fair, a lot of people are "low-level technicians". During my degree I met some incredibly bright people who were genuinely interested in programming, the science behind it and doing interesting new things with computers. I also met several people who saw "doing computers" as the endpoint; who were quite happy to be given a spec and code to it, and who should absolutely be kept away from design and given as little rope to hang themselves with as possible. Horses for courses and all. Languages that "hackers" like - Scala, Python, Ruby, Lisp, Haskell - make us much more productive, and keep our interest. I couldn't say if we're the majority in the development world, but I know that presenting people who are simply looking to clock in a 9-5 and go home with anything more complex than Java is asking for trouble. I'd like to have faith, but part of my job at the moment is maintaining a 15,000 line long *single* Perl script where "version control" meant appending \_old to a method, and comments are non-existent :/.
Enjoyed reading it, but ultimately thought that the end result was less easily understood than the original example. Especially when the object was brought in to avoid creating instances of loggers everywhere. I'd much rather prefer to have an abstract trait that relied on: def getLogger : Logger = Logger.getLogger(getClass()) So that the default behavior is to use an instance variable but then the class mixing in the logging trait could override that method and use a companion object logger.
How about "Scala is to Java what apples are to monkeys" ? Like, totally not the same thing.
A key thing with Scala, is that some parts are really only meant to be consumed by lower-grade developers. The type system is complex (and Turing complete). That means it is possible for smart library designers to create extremely powerful and expressive libraries for others to consume, using features of the language that others should not use. The upshot is that vanilla users of Scala have a really nice experience: libraries feel like part of the language, and when well constructed, the compiler stops you from doing the wrong thing surprisingly well (if, so far, somewhat cryptically in terms of error messages). That vanilla users shouldn't use some features of the language is not unique to Scala, nor a bad thing. C++ did a lot of damage in this regard, but throwing in tons of things, that people didn't know how to use safely. Scala is hugely more elegant than C++ in this way, and it's pretty easy to avoid the parts of the language that you shouldn't use. If you persist anyway, but aren't up to the task, then you're probably creating garbage in any language you use.
And Miles has updated the Eclipse plugin to RC6: http://www.scala-ide.org/2010/06/the-scala-ide-for-eclipse-for-scala-2-8-0-rc6-available-now/ edit: s/updating/updated/
Nice that they show the differences between RC5 and RC6.
In the example to reassign to a "var" you have: val foo = 5 val foo = 6 Do you mean: var foo = 5 foo = 6 ? 
Could someone please clarify on slide 14 point 3?
Is there going to be a tutorial or a document demonstrating these new features?
Yes. `foo?` would not be a legal identifier, however `foo_?` is. Further `foo_:` is right associative when called infix (following the rule that identifiers that end with a colon are right associative). Lift frequently uses the `booleanMethod_?` paradigm for, well, methods that return a boolean. for example: `def inStatefulScope_? : Boolean` rather than `def isInStatefulScope : Boolean` My guess as to why this is that it is a side-effect in the language spec of having to get the parser to recognize both `unary_!(x : X)` ... and setter `someVar_=(x : X)` methods.
Thanks a lot!
I have to say, Lift is pretty awesome. With JRebel and Lift I find I'm ridiculously productive. Hobby projects I had sitting on the shelf that I never had enough time for suddenly make headway, and I'm thinking to myself, "I can't believe I just finished all that work!?". The type system is occasionally a bit too clever for its own good but the more I work with it, the easier it gets. The only Scala language features that I am still a bit puzzled by are implicits and I would stay away from them unless you absolutely have to use them. The rules for when they are in scope and are applied and/or not applied are very tricky.
Bug: It does not say "Hello World".
Good point. You can say it yourself when you see it working though.
Thanks for this, but unfortunately outdated now. With Scala 2.8.0 around the corner and Lift 2.0 out, it'd be nice if this was updated for the new versions (which won't be much different I suppose, but setting up a decent 2.8.0.RCx build environment has been nightmarish for me).
I never get why people ask questions like this. Learning a language seems to be fairly straightforward: 1. Buy a book, or find some tutorials. (Scala makes this easy, since there aren't a lot of Scala books but the ones available are pretty good.) 2. Start writing some programs in the language. And an optional but highly recommended step: browse the source code of open source projects written in that language.
Pre-release version of Scala is pre-release quality. And that surprises blogger. Oh no!
That's not exactly what he's saying. Broken backwards compatibility will remain whether it's a RC or a final release.
And busted binary compatibility is basically unfixable with traits and how they are currently implemented. edit more detail: The jvm doesn't understand that an interface can have code or support multiple inheritance so the code from the trait ends up in the class that extends it. This leads to some very hairy situations such as when you extend a trait from a library then swap in a newer version of the library-jar sometime later, whilst you are still running with you code which was compiled against the old version, and hence has the old library code in it still. 
Well that was a badly written flame, lots of hand waving, little actual meaningful complaints.
But then what else would they post to r/whateverProgrammingLanguageTheyHeardAboutYesterday? I think it's mainly that many people are under the belief that coding is some magic skill that, given the right incantation, is easy as pie, rather than the time-intensive skill that must be learned slowly and deliberately.
The counterstrike: scala-fresh project http://groups.google.com/group/scala-fresh/browse_thread/thread/10986d9fc6864962# http://groups.google.com/group/scala-fresh http://github.com/paulp/scala/tree/fresh_scala 
Did anyone catch [Martin's response](http://codemonkeyism.com/scala-unfit-development/#comment-305659)? &gt; ... I am about to take a leave from university and found a startup to do commercial Scala support. I am taking some of the key Scala developers with me.
http://www.youtube.com/watch?v=76RrdwElnTU 
I really like Scala, but then I watch a video like this, and think to myself "Do I even *know* Scala?"
I want this...can we get a working link? :-)
http://dibblego.wordpress.com/2008/01/16/scalaoption-cheat-sheet/ 
Ok, now that I read it, I loved it! This is the kind of thing we need lots of. Little tutorials saying "OK this is one way to do it, but here is the more concise, functional way". Kudos to the author. 
It always seems to be *other people* that are too stupid to understand Scala. I've yet to see a statement like "**I** can't understand scala" from one of these naysayers. Funny that.
Indeed. One of my pet peeves. "Oh, I totally get it, but my coworkers won't" They always present themselves as the champion of the mythical "average programmer" who apparently is too dumb to try to learn a new language (one has to wonder how they learn Java ... osmosis I guess) 
Not really, but I found [this](http://stackoverflow.com/questions/190110/real-world-examples-of-scala-applications).
Thanks!
"20-200kLOC" != large. 
http://www.scala-lang.org/node/1658
well, that post is a little dated (2008) have a look at the Scala in the [enterprise section of the Scala homepage](http://www.scala-lang.org/node/1658), which should actually be updated to include the likes of Office Depot, Hot Potato,...
Glad to see this is getting some discussion, I filed a bug report a few weeks ago on this precise issue. EDIT: Oops, err, actually, looks like i'm indirectly cited in the article. The internet is a weird place...
Great, thanks!
I think it was announced on the scala mailing list; I don't remember him stating it publicly at ScalaDays…
[This](http://codemonkeyism.com/scala-unfit-development/#comment-305659) is what you're looking for.
&gt;ScalaSolutions: A company to provide support, consulting, training, and enterprise tools for the open source Scala programming language. [found this on some Swiss venture capital site](http://www.venturekick.ch/index.cfm?CFID=16625456&amp;CFTOKEN=86102651&amp;page=119858&amp;profil_id=1629)
Very interesting, thank you. The new company is called ScalaSolutions and is "a company to provide support, consulting, training, and enterprise tools for the open source Scala programming language". 
Sorry, forgot the [PDF] warning in the title.
[I posted it to LtU too](http://lambda-the-ultimate.org/node/4045) if that's the way your bread is buttered.
Interesting but I didn't find MetaOCaml very compelling... 
Here's a [tutorial](http://www.tylerlesmann.com/2009/dec/04/integrating-scala-android-ant/) on doing it with ant.
It seems the attacks are coming from bloggers who have an a priori negative opinion (Yegge, Robert Fisher.) You don't hear many negative opinions from programmers who have actually used Scala. 
I guess that depends on how you view Scala. If you see it as a better JVM language, maybe Oracle is kind of scary. If you see it as a language that happens to run on the JVM, then although a lot of cool stuff would be lost, Scala could survive with its own implementation or in a different VM. I hope that Oracle realizes that it would be a very bad move to go after Scala, Clojure and the cool language ecosystem that's forming on the JVM.
The Oracle legal action includes Dalvik VM. If they force Google to drop it it will affect Scala development as well as Java. Some royalties on Google side are more likely solution.
If Oracle doesn't kill Dalvik VM. I was preparing to start on a Scala project targeting Android this September. Today the client sent an update "to brush up on C++" in case the platform changes.
My guess would be, that the whole Oracle-Situation won't affect the Java ecosystem a lot, much less the Scala ecosystem. (So I guess I see Scala as a better JVM language.)
no, there's no money in that
Oracle gives patent protection to anyone using the GPLed Hotspot JVM. In addition, apache harmony is GPLed. I think using those are safe.
You say complicated, I say rich :)
No. Scala is just software that runs on their JVM, which enables people to develop applications that could run on their hardware or utilize their database and drive their sales.
TL;DR: a DSL in Scala for defining a FSM for semantically processing events. Technique is applicable, with work, to other languages. I likes it.
I don't think Oracle will kill Dalvik. They may have to buy a pricey license from Oracle, but that's about it...
Really interesting article. It would seem to have a fair bit of applicability for games programming. I have been futzing around with a hobby game in Scala, and message passing and using observers seem to be a significant part of it.
[This](http://lampwww.epfl.ch/~odersky/whatsnew/collections-api/collections.html) article going over the new collections that was linked in the original article is excellent. Highly suggest any Scala coder read it.
Nice work! I was looking for a typeful, scala take on the kind of approach taken by the ruby sequel library ( http://sequel.rubyforge.org/ ) Started on something similar myself a while back ( http://github.com/mjwillson/sqala ), but never really finished it off. This looks much much further along. Will give it a try next time I have an excuse :)
Doing the backend for a side project website Im working on. Full version will involve reading from an api, interfacing with a db, interfacing with a local memcached, running an rpc service, and running an autocompletition service (some sort of simple prefix trie).
Any particular framework you use, would recommend? I'm asking this because I have started recently learning Scala and weren't quite sure in what domain (under what environment) people are using it most commonly.
I'm writing a compiler.
framework for what? For backend stuff, twitter has a LOT of open-sourced scala projects (see http://twitter.com/about/opensource). Use sbt as your compiler, its awesome.
ha, me too, just as an experiment though :)
I'm currently writing a custom backup solution for data stored on different services of certain kinds in Scala. (Sorry, can't be more specific as it's commercial) I'm using maven (wasn't all that happy with sbt), guice, specs and parts of akka.
a distributed algorithm for the vehicle routing problem (my master thesis in CS) http://github.com/tulsidas/RAR-RARV 
Straight up web application development along with the Lift framework. The comet support has allowed us to do some pretty neat things from a user experience perspective.
Me too.
Open Source network/server kind of thing. More to come...
Reminds me of [Worse is Better](http://www.jwz.org/doc/worse-is-better.html). 
Well put, and a great analogy. :)
This blog post makes two statements about Haskell and both are wrong.
Looks interesting, querying looks more like Ruby's AREL than Sequel (to me at least). Not sure if I'm a fan of that yet. I've been using Circumflex ORM with some success: http://circumflex.ru/orm.html So far that feels like a cross between DataMapper and Sequel but with a little less flexibility (but hey it's not Ruby).
The back-end portion (customization) of a Mail template system. Using Circumflex ORM and Scalate.
You might also find [this treatise](http://ocaml.janestreet.com/?q=node/78) on OCaml's option type helpful.
Wow this looks very nice! Thank you very much for this effort. Would there be a way to get theses drawings individually as pngs or jpgs? If you would permit I would love to add them to the collections document. I'd of course put in an attribution to you and any tools that you have used for this. Thanks -- Martin
If you want to try it with more monads: import scala.util.continuations._ trait BMonad[M[_]] { def unit[A](value:A) : M[A] def bind[A,B](v:M[A], k:A=&gt;M[B]) : M[B] } class BMonadInterface[M[_]](m: BMonad[M]) { def runMonad[C](ctx: =&gt; Any @ cpsParam[M[Any], M[Any]]) : M[C] = { val tmp : M[Any] = reset { val x : Any = ctx m.unit(x) } tmp.asInstanceOf[M[C]] } def get[A](value:M[A]) = shift { k:(A=&gt;M[Any]) =&gt; m.bind(value, k) } class CPSMonadValue[A](monad:M[A]) { def value = get[A](monad) } implicit def monad2cpsmonadvalue[A](x:M[A]) : CPSMonadValue[A] = new CPSMonadValue(x) } object BOption extends BMonadInterface[Option]( new BMonad[Option] { def unit[A](value:A) = Some(value) def bind[A,B](v:Option[A], k:A=&gt;Option[B]) = v.flatMap(k) }) { def runOption[C](ctx: =&gt; Any @cpsParam[Option[Any], Option[Any]]) : Option[C] = runMonad(ctx) } object BList extends BMonadInterface[List]( new BMonad[List] { def unit[A](value:A) = List(value) def bind[A,B](v:List[A], k:A=&gt;List[B]) = v.flatMap(k) }) { def runList[C](ctx: =&gt; Any @cpsParam[List[Any], List[Any]]) : List[C] = runMonad(ctx) def guard[A](b:Boolean) = shift { k:(Unit =&gt; List[Any]) =&gt; if (b) { k() } else { List() } } } Testing the option Monad: object TestBOption { import BOption._ def test1 = runOption[Int] { val x = get(None) x } def test2 = runOption[Int] { val x = Some(1).value x } def test3 = runOption[Int] { val x = Some(1) val y = Some(2) x.value + y.value } def test_fn(x:Option[Int], y:Option[Int], z:Option[Int]) = runOption[Int] { x.value * x.value + y.value * y.value + z.value * z.value } def test4 = test_fn(Some(1), Some(2), Some(3)) def test5 = test_fn(Some(1), None, Some(3)) } and the List Monad object TestBList { import BList._ def test1 = runList[Int] { val l1 = List(1,2,3) val l2 = List(4,5,6) l1.value + l2.value } def test2 = runList[Int] { val l1 = List(1,2,3) val l2 = List(4,5,6) val x = l1.value + l2.value guard(x % 2 != 0) // filter out all even results x } } 
Looks interesting, are there any real-world canonical use cases for this stuff?
Although I have since gone back to Eclipse, jEdit + sbt proved to be a pretty potent combination.
Great post. As a sidenote, who else thinks that the "early definition" syntax is all sorts of nasty? Id never seen it before now.
Any who are this language lawyers? Is it important for the language designers/implementers to talk a little bit more with the actual application developers? 
The type system seems pretty complex at first, certainly its specification does! But, although the theory seems dense, in practice it just works. It stays out of your way more than Java's. So much so that I don't think the type system is responsible for scala's fairly steep learning curve. I found a lot to learn in other areas. Little things sometimes tripped me up e.g. the distinction between a method and a function or the consequences of the uniform module system (which has been somewhat tamed in 2.8). And, although it contradicts conventional wisdom, I would rate the advanced OO features as more difficult to understand than the functional features. (I am from an OO more than a functional background.) I have gradually learnt the type system without much trouble. I wonder whether a less powerful (static) scheme could be devised that is not actually harder to use in practice. 
Is he talking about Hindley-Milner? Personally, I'm fine with "the compiler is able to derive the types from how you are using values and functions". Almost nobody needs to think beyond this to survive in type inferencing languages. This is based on experiences with Haskell; Scala might be more difficult.
He is probably not referring to H-M type inference. Unfortunately scala can't use it. I understand this is because of the presence of class inheritance in the language. So scala's type inference is not quite that powerful. But inference isn't the only way that scala's type system keeps out of your way. In scala (more than, say, java) generic types are compatible where you intuitively expect them to be. Explicit support for contravariance and covariance helps. 
I think we talk quite a lot. But the main point is that over the last two years there have been no additions to the type system, except some refinements to inference which are "under the covers". Instead everyone on the language designer/implementor team was busy in writing better tools and libraries and generally stabilizing things. So the main reason you have seen no news about the type system was that there were no news. 
Boy James, if you find Scala's type system complicated, wait until you learn about Java generics! 
Type constructor inference was big news, to a few of us at least.
Scala, like many new languages, began life as a research project. One of the goals of research is to make something better. The problem is that when things become *better*, they tend to be *different*, or at least change somewhat. "Actual application developers" tend not to like change; in essence, they want something *better*, but also *the same* -- a paradox.
When the first compilers for programming languages were created, the compilation sequences for "if", "for", "while", function calls and the like were for well known sequences of goto statements interspersed with other code. In effect, high level programming languages gave programmers a small collection of control patterns that allowed them to ignore goto statements. When Object Oriented languages were created, "Design Patterns" were gathered and documented which are well known ways in which objects are put together to perform some group of tasks. Now that Scala has an explicit type system in place, programmers are gathering up *Type Patterns*. Right now, these type patterns are not well documented nor understood as a form of Design Patterns, however, as more code is translated from Object Oriented languages and the benefits of Functional Programming are folded in to those projects, you're going to see these type patterns start to be formulated. Think of these as a form of currying on steroids. Right now this type system is very much abstract, in an intermediate representation and one can use it as one pleases, but because very few patterns are known, this is confusing. Once they are known, these patterns will eventually become like for loops in imperative languages, that is there will either be syntax candy or well known conventions to describe them and most of them will become "hidden away" as it were.
This is the most exciting book since.... the last Scala book! Seriously, I've been waiting for this seemingly forever. Very exciting.
I agree it is big news. But for most people it's still under the covers. Inference just works a little smoother than before.
I'm also looking forward to Steps in Scala: http://www.amazon.ca/Steps-Scala-Introduction-Object-Functional-Programming/dp/0521747589/
Uh, java's generics aren't complicated, they just don't work right...
Haha. I shall assume you weren't on the JSR14 advisory, nor do you understand generics. Trust me, this is in your favour :)
I know you can't have multiple wildcards and that was annoying. I guess I should rephrase, I don't think the syntax is complicated compared to the Scala syntax, but the shortcomings and why most likely are... 
I genuinely have moments where I envy that degree of naivety.
Interestingly, in my career I have programmed Java for the better part of six years, versus one in Scala. While I was certainly able to use Java generics, I never fully grokked their usefulness, especially when the verbosity of your code would go way up. I was able to hit the ground running with Scala generics almost immediately and was able to use them effectively. I think the type inference system of Scala certainly plays a part here, but nevertheless I feel that Scala's type system in general is much easier to work with. 
I think you're on to something. For me at least, it's very hard to remember something in the 'abstract', vs learning both the how and *why* at the same time. You could say that I didn't quite 'get' Object Oriented design until I read GoF and went "OH! I DID THAT! AND THAT'S WHY I DID IT LIKE THAT" along with "so *thats* the right way for solving THAT ONE PROBLEM". You may be correct that when a set of idiomatic patterns emerge for typing, it'll become a lot clearer to all of us that are struggling to understand the nuances of Scala's typing system. 
Not to take the puff out of it, but I find it more interesting that there are people who believe otherwise. Such wilful ignorance and incompetence is a fascinating phenomenon that deserves more research. I mean, *even James Gosling displays this*. This is an awesome display of the human condition. Sometimes I wish I'd complete my psychology degree.
Scala noob here: I *want* to like this book, but I've abandoned the OReilly book for now and picked up the PragProg Scala book. The OReilly book, for me, is a giant headache since the first 5 chapters are written like "Here's some sample functionality with a contrived, worthless example, and we'll cover this in great detail in a few hundred pages. Here's some more some sample functionality with a contrived, worthless example, and we'll cover this in great detail in a few hundred pages. Here's some more some sample functionality with a contrived, worthless example, and we'll cover this in great detail in a few hundred pages." I gave up after around chapter 5. I'll probably hit this again after reading the PragProg book first. Bleh, I'm getting old...
Have you tried "Programming in Scala" by odersky + others? Im about halfway through and find it a good intro so far.
I'm something of a Scala partisan, but PinS is really a great programming book. My theory is that it's because its authors are a combination of a theoretician, a pragmatist and someone to act as an interpreter between them. 
I'm just picking it up in very small pieces when I get the spare time, so getting drowned in detail just isn't all that helpful to me currently. The PragProg book showed a basic, working, real-world example right off the bat. If I can make more time and decide to stick with Scala, I'll certainly go back to the O'Reilly book eventually, just for now the other book is better off for someone just dabbling so far.
OK slide deck. I like it when people don't just recite what's on each slide but use them as jumping points. However, it doesn't really translate well into having the slides without audio. It did remind me, though, that I need to get up to speed with Clojure as well. 
This. I tried the Pragmatic book at first when I was curious about Scala but for whatever reason it didn't really resonate with me. PinS, though, clicked in the same way that Aaron Hillegass's books on Mac programming did. Very good writing and a solid breakdown of the language.
I've been professionally writing C# code for 6 years (and really liked the language actually). We targeted both .net and mono. For my new gig we are switching to scala. It is _really_ pretty and quick to write - the eclipse plug-in is also good. Just a completely awesome language - we laugh about how nice it is. The only thing I don't like: Since it is based on the JVM for mixing native calls you still have to use JNI. JNI is horrible compared to dllinvoke.
Curious: What kinds native calls are you making, for what purpose? I'm wondering why your team is using a virtual machine based development environment when your project needs to make native calls; instead of using plain old C or a more modern language that doesn't require a VM. I'm not knocking virtual machines (the JVM has been my home since the 1990s), just curious at the thought process/decisions, upsides/downsides you all discussed.
I think C# the language is pretty great. However, this statement: &gt; C# is cross-platform enough now that it's probably okay to use on Linux and Mac. I can't agree with. The JVM is leaps and bounds ahead of Mono on a number of levels, JIT and GC performance especially. This is a big deal if you plan on writing highly scalable server side apps. 
It's possible I'm misreading this benchmark, but it looks like Scala has slightly better performance characteristics in exchange for slightly higher memory consumption - http://shootout.alioth.debian.org/u32/benchmark.php?test=all&amp;lang=scala&amp;lang2=csharp It doesn't really look like a leaps and bounds sort of situation to me, especially with the new GC in Mono 2.8. 
I imagine OpenGL is the biggest one. A lot of students learn Java and are still in their "I wanna be a gamedev" stage, so they use OpenGL on Java and end up trying to make millions of native calls per second. Recently, a prominent Java indie game developer [complained about the OpenGL speed on Java](http://www.reddit.com/r/Minecraft/comments/djlsz/notchs_answers_to_your_questions/)(in question 4). Personally, most of my native calls from a VM are to the Windows API, for window management and hotkey handling scripts. They're not exactly performance critical though.
&gt; Curious: What kinds native calls are you making, for what purpose? Calls (ioctls essentially) into the drivers for a custom bit of hardware. &gt; I'm wondering why your team is using a virtual machine based development environment when your project needs to make native calls; instead of using plain old C or a more modern language that doesn't require a VM. For biggish projects I've found that doing some low level code in C or C++ is common. Then on top of that you have 90% of the code in a more modern language (so developers can use actors for threading, have closures and GC). All of these higher level languages are VM based.
I wouldn't say all are VM based: Ruby, Erlang, Python, Groovy's GO, are all very modern languages that are not VM-based and can interoperate directly (correct me if Im wrong here developers) with native libraries (.dll/.so) Thanks for the answers though. I'm truly just interested in the conversation, not trying to be contrarian.
Punkgeek sounds like part of an existing development team, not a student. I guess one way I'm coming at it is that the VM is great for managing memory, doing JIT compiling, and (if you're careful) cross-platform independence. But if you are doing a lot of calls into a native library, Windows API, does the VM even make sense over a natively compiled language? If so, what are the arguments for using the VM in this manner?
The common wisdom is that the JVM would be leaps ahead of the mono project. It would be natural given that the JVM has been around much longer, has been extremely widely accepted and used by almost every major company, and has millions of person-hours in development and testing. I'd be very interested if someone familiar with Mono could argue the opposite.
python and erlang are both VM based (though they use custom VMs). (They compile to a pcode and then (sometimes) into native instructions + they have GC = both the key traits of a VM in this context). I don't know about Ruby or Go. Python's mechanism for calling into C code is very similar to the dllimport of C#
I don't know about vs. the JVM, but at the long gig I just finished we used both .net and mono to run our large corpus of C# code. The performance for both IO and computation intensive tasks was always within a few % when comparing the microsoft VM and mono. For some instruction mixes there was a slight difference but not by much. Since the microsoft .net VM has been evolving faster than then near stagnant Java VM I bet a comparison between a recent mono and the JVM would not show much difference.
Yes, the VM makes sense for all the reasons you mentioned. Memory management being the big one. Also, VMs generally run higher level languages than C/C++, which are the only languages that you can easily access the Windows API without having to write wrapper code.
Ruby, Erlang and Python all run on VMs.
It may be better to ask the question another way: What tools are available to Scala developers that C# developers don't have? For example: * Scala has great support for Actors, especially with Akka * Terracotta * Multiple return values / multiple assignment * Scala embraces functional development more than C# (although F# works very well in combination with C#) * Very many options for web applications with Scala (Lift, Play, plus all of the "old" ways of doing things). C# has some advantages as well: * Better tooling (at least with Visual Studio) * IKVM allows for the use of most JVM libs * No apparent concerns over type erasure * LINQ I'm sure there are many more valid points for either ecosystem. 
I'd strongly recommend [JNA](https://jna.dev.java.net/) for native stuff.
[JOGL](http://jogamp.org/) is one of the best Java -&gt; C libraries I use on a daily basis. I need it to work on Windows and Mac, it crosses across beautifully and is very fast for the huge datasets we're using in visualisation.
Awesome! Thank you so much! In fact that led me to this: http://code.google.com/p/scala-native-access/
Downvotes for questions, really scala community? Pretty lame [reddiquette](http://www.reddit.com/help/reddiquette) fellas. Maybe a subreddit with only 1000 members should be a bit more polite. 
Yeah, I should have been a bit more careful in my usage in my assumptions/terminology. Interpreted languages, of course, live in some form of VM. The point I was trying to make, and maybe it's a moot point, is that I've always thought calling C code from Ruby, Python was more straight forward than calling it from the JVM. 
&gt;Since the microsoft .net VM has been evolving faster than then near stagnant Java VM I bet a comparison between a recent mono and the JVM would not show much difference. Woah woah, you're confusing *languages* with VMs. While the java Language has certainly stagnated, the VM has anything but. Escape analysis and a state of the art GC are all brand new features that the CLR does definitely not have, much less Mono. 
Scala works quite well on Android. You can use [ProGuard](http://proguard.sourceforge.net/) to trim the classes you're not using. Here's some [documentation](http://www.tylerlesmann.com/2009/dec/04/integrating-scala-android-ant/) on editing the Android SDK's ant rules to build scala and use ProGuard.
I wanted to make a quick web JSON API, and [Scalatra](http://github.com/scalatra/scalatra) + [GSON](http://code.google.com/p/google-gson/) were the tools I used. They worked excellently together.
Quite timely! I just started working with Scalatra last week. Scalate is really awesome, and I generally like micro-frameworks. It's going well.
Huh? This started making markedly less sense once we got to Kittens and Aqua Man, and it was already kind of confusing. 
We use a lot of Scala for our Android app at Bump (http://bu.mp). It works very well, especially for services (as opposed to activities). As redhatcat said, Proguard is a must for Scala + Android: http://lamp.epfl.ch/~michelou/android/library-code-shrinking.html
As long as we're talking books, can anyone suggest a book that doesn't assume your background is in Java or Ruby? I'm most familiar with Python, JavaScript and PHP, which aren't that much different from Ruby, but certainly are different than Java.
There's 4 books out now, plus the Apress Lift one you can read online. There's 3 in the pipeline (2 Manning, one by Loverdos), plus Lift book from Manning http://manning.com/ http://stackoverflow.com/questions/tagged/scala+types http://www.slideshare.net/djspiewak/high-wizardry-in-the-land-of-scala http://apocalisp.wordpress.com/2010/06/08/type-level-programming-in-scala/ --------------------------------------------- This is my bookmark list for scala types, most are mentioned in above blogpost: http://debasishg.blogspot.com http://apocalisp.wordpress.com http://james-iry.blogspot.com http://daily-scala.blogspot.com http://dcsobral.blogspot.com http://michid.wordpress.com http://codecommit.com http://suereth.blogspot.com http://jim-mcbeath.blogspot.com http://www.scala-notes.org/ http://blog.tmorris.net/
Very helpful, thanks!
Try [Tony Morris](http://blog.tmorris.net/)'s Scala exercises . Also, I would recommend learn Haskell, for me it was the best way to learn advanced typing stuff. 
Great! Thanks a lot for the list!
I have absolutely no idea what any of this means, so I think i'll comment.
this is old
emacs + scala-mode + yasnippet + sbt
Emacs + scala-mode + ensime + yasnippet + sbt here! Emacs doesn't seem to offer integrated debugging, but debugging is for sissies anyway.
IntelliJ Idea with scala plugin. Everything just seems to work
are....you being sarcastic? I don't think it's possible to debug tough threading issues without a debugger. I mean, how the hell can you even replicate race conditions and whatnot...
I use: 1) The Eclipse plugin -- and yes, it's still got a bit to go before it's a completely workable enviroment. I do believe Scala *needs* to have a workable Eclipse plugin to get wider adoption from Java devs. 2) ENSIME (for Emacs) + sbt -- awesome, a very productive environment.
Seconded. Now that IDEA is free for Java, Scala, Clojure it's hard not to recommend that. Although, I do use Vim for almost everything else so I do tend to drop back to it on occasion.
wow, didn't know ENSIME, thanks!
Seriously? Debuggers usually interfere with threading and make working things appear broken and broken - working. The best tool to debug threading code is using your brain to write damn simple code. If something is not glaringly obvious, you are doing it wrong.
He or she is probably joking: [this video about ensime](http://www.youtube.com/watch?v=v7-G6vD42z8) features its debugging capabilities. Edit: Oh wow, I totally missed the reply next to me.
I use netbeans primarily, but it only works on the nightly builds, and I haven't managed to get scalatest working on it yet. 
this info should be in the scaladoc. it is highly important when using collections
&gt;Debuggers usually interfere with threading and make working things appear broken and broken - working. If you're retarded with your breakpoints, than yes. &gt;The best tool to debug threading code is using your brain to write damn simple code. Oh. That must be why no high level programs have tough multi threaded bugs. Maybe the guys writing the JVM should hire you! You can fix their issues! 
I use vim + sbt, but Ive been tempted towards the dark side by how awesome ENSIME looks.
IntelliJ IDEA + Scala plugin + sbt (for continuous compilation/testing)
The VIM plugin for IDEA helps quite a bit. Not a full-featured VIM but enough to make it not such a shock to switch between the two.
After a long time using eclipse, I've switched to IntelliJ IDEA with Scala plugin. 
vim, sbt, git, bash.
I have been meaning to use it. Thanks for the tip. I'll definitely check it out.
shouldn't this bee in the wtf section? ;-)
Kate, git, jetty, and sbt.
Cool! I've been doing system maintenance scripts in scala lately, rather than python or PHP. It's a great way to practice.
Would be interesting to see this technique compared and contrasted with OCaml's as well.
I haven't had a problem with Eclipse 3.5 + Scala 2.8 but if you are looking for something else, sbt + jedit wasn't bad either.
Is there any other typical way of learning Scala other than reading *Programming in Scala*? That book is heavy on teaching functional programming, so I wonder how someone would learn Scala without being exposed to FP. Looking at the comments, it seems this article is mostly for showing Java (or similar) developers what Scala and FP is all about. 
I think there is a big push nowadays for FP because it is more easily distributable (automatically, that is) since there's no locking and data sharing (everything is basically immutable, copy-on-write). The problem is that programmers are usually trained in Imperative Programming and it's difficult to change the whole frame of mind for FP (at least for me). So lots of academic work on languages (Scala does have an academic background) seems to be in making FP easier to use. If you want something like how scala is nice to write imperative code, you could take a look at [Scala for Java programmers](http://www.codecommit.com/blog/scala/roundup-scala-for-java-refugees)
Try working through these 99 Problems in Scala (http://aperiodic.net/phil/scala/s-99/) if you want an interactive, challenging approach. Also, there's the colored-pencil book, that's more of a gentle introduction than Odersky's tome: http://pragprog.com/titles/vsscala/programming-scala (argh, bad link, bad!) 
I use vim, sbt, git, bash. I do some tricky things in my vimrc as well as take advantage of slime.vim (http://www.github.com/retiman/homekeeper/dotfiles/vimrc). Previously I was using Maven with a guy who was using IDEA; he says the Scala plugin sucks. Using maven is also not so cool. Now that I'm using sbt, slime.vim + sbt console-project isn't too horrible. I haven't found a good way to do debugging yet, but I've been meaning to try out either jswat or buckle down and use jdb one of these days.
How are you using slime in vim? I'm not really familiar with it...do you just use it for brining up scala repl to test things out? I have a large project with a lot of dependencies, so I'm not sure using REPL really buys me anything. 
&gt; I think there is a big push nowadays for FP because it is more easily distributable (automatically, that is) since there's no locking and data sharing (everything is basically immutable, copy-on-write). The problem is that programmers are usually trained in Imperative Programming and it's difficult to change the whole frame of mind for FP (at least for me). And the JVM's lack of tail call elimination which means most idiomatic functional code is prone to stack overflows, requiring elaborate workarounds that undermine interoperability. 
Scala gives Java developers a natural route into itself. So, you'll see a lot of focus on them. As long as you understand some basic concepts like package, object, and class, you're starting conceptually from a similar point most Java developers are. To learn Scala, I started with small work tasks that didn't have a high profile, so not as much time pressure. I wrote the tasks how I would in Java and then read articles, blogs, and Programming in Scala. As I found functional techniques to replace imperative blocks of code, I'd replace my original code. Now that I'm getting a little more comfortable with functional techniques, I'm starting to abstract out the code to fit more general cases. Be prepared for some frustration along the way. It's very much like learning a foreign language. You know how to express yourself in your native tongue so the tendency is to revert back to it. Keep going. It becomes easier.
There's a little script called slime.vim that works with screen. You can send code to a Scala repl (or Clojure, or Ruby, or whatevers). Here's where I found it: http://technotales.wordpress.com/2007/10/03/like-slime-for-vim/ It's not perfect, but obviously editing stuff in vim is better than typing things in the repl itself. The last time I used Scala for a really large project, I didn't know about slime.vim, so I just toughed it out. Sometimes I would get adventurous with either Netbeans or IDEA to try and debug, but it was a crapshoot. Quite frankly, I didn't like the Scala support in any of the major IDEs (including Eclipse); they were all filled with bugs that rendered them unusable (this was around August of this year). I have heard (but never seen) people having some sort of success with jswat for debugging, but I've never seen a decent tutorial.
No matter what Oracle does, Scala could just target the 1.6 vm and/or OpenJDK indefinitely, at least until Parrot or the LLVM JIT mature.
still no fix for [#1133](http://lampsvn.epfl.ch/trac/scala/ticket/1133), makes pattern matching quite useless in a lot of cases.
You are clearly a moron, at least with regards to concurrent programming. I hope I never have to work with you. "No high level programs have tough multi threaded bugs" is *hilariously* wrong.
that was sarcasm. 
I ran into it very quickly when writing a RestHelper#serve PF. The strange thing is that it's the only place that I've ran into it even though I've used pattern matching much more extensively in other contexts.
Nice demo. FWIW, I posted my 10-line F# version [here](http://fsharpnews.blogspot.com/2010/11/visualizing-complete-graph.html). I think the problem with the original cited from this post is that he was using C#/F# to control AutoCAD rather than just rendering it directly. Obviously the Scala isn't doing that so comparing it with my F# seems fairer. 
Apologies for submitting my own question on SO, but i was curious what the reddit scala community thought as well. That and the way that conversations take place on Reddit differs significantly from SO.
For what very, very little experience I've had with Scala, I have to admit that my ignorance of Java and its libraries has been a major hurdle to me.
Totally, you have a big headstart knowing Java. The rest of the stuff that goes along with it, especially - web servers, build systems, etc.
Full disclosure - I wrote this article. I'm sharing here on Scala reddit as I hope that more news about Scala is (generally) good news. :-) Feedback always appreciated.
"Using the trait we pimp the specific type constructor with the map function" I knew this guy was tha pimp. I like the name Debashish "the Almighty" Ghosh better, though.
&gt; Structural subtyping Interesting. Can anyone compare and contrast this with OCaml's? 
That's great news ... I was hoping that they would decide to update the book! Just hope that it will be out _before_ Scala 2.9. :-)
Well, are you really interested? Or do you just need someone replying to you to tell him he is stupid and your $language is the best? If it is the second case, I would be honored to be the one receiving your "well-founded critcism"
According to the website, it's already out.
I can neither find an announcement of a release of Scala 2.9 nor of the 2nd edition of the Book at the website ...
At the link you can download the pdf of the book right now.
2.9 involves both language features and productionization of the language and dev environment by Prof. Odersky's startup (while still targeting only JDK 6) http://www.scalasolutions.com/products/stableversion a couple video: http://days2010.scala-lang.org/node/138/170 http://days2010.scala-lang.org/node/138/137 --------------------- parallel collections , http://www.scala-lang.org/node/7285 http://infoscience.epfl.ch/record/150346/files/onl0000031-chafi.pdf http://scala-programming-language.1934581.n4.nabble.com/Beyond-2-8-A-Roadmap-td2319863.html http://infoscience.epfl.ch/record/150347/files/gpce63-rompf.pdf 
Given the amount of shared knowledge, knowing Java is a big help. I would not say that it is a requirement though.
ePub format would be nice. 
I bought the older edition 3 months ago! Gah!!
URL has changed: http://hseeberger.wordpress.com/2010/11/25/introduction-to-category-theory-in-scala/
&gt; Scala embraces functional development more than C# How so? 
&gt; Escape analysis and a state of the art GC are all brand new features that the CLR does definitely not have Escape analysis was a failure. G1 is good but what about tail call elimination and value types? 
Do you mean global type inference, versus local type inference? Because Scala's local type inference is pretty solid.
Some people call it global type inference, yes.
You're fairly experienced in Programming Languages, Jon, but I would think that if you'd read Benjamin Pierce's book, [Types and Programming Languages](http://www.cis.upenn.edu/~bcpierce/tapl/) you would be familiar with at least the basic problems that width and depth subtyping present for HM style inference. Martin Odersky said: &gt; The reason Scala does not have Hindley/Milner type inference is that it is very difficult to combine with features such as overloading (the ad-hoc variant, not type classes), record selection, and subtyping As for OCaml, its typing mechanism is interesting, and one that can be fully inferred also by Haskell's type system (I assume you've seen Oleg Kiselyov's work in that area), albeit with uglier syntax and no aliasing. As for why Scala does not use this, primarily the sort of type information used by the JVM is not really sufficient to do OCaml style inference. I have no experience with F# and I'm not sure how it differs, but it's possible that F# has made some progress in this area. I have heard numerous reports that F#'s type inference can become quite brittle after you've written quite a bit of code, however, and that it becomes necessary eventually to annotate your code or at least restructure it to make it more convenient for the inferencer. This would suggest at least that F# has not solved this problem completely. Eventually global type inference in the presence of all the ambiguities that are introduced by various scala features is, while probably not impossible for most common expressions, extremely difficult to get right. Seeing as, for documentation purposes, a classes interface should probably document its types somewhere anyway (as an example: a change in Scala version causes a type error - this would be disastrous with no signatures as the old type couldn't even be discovered), Odersky et al decided it would be better just to have local expression inference and leave the global inference out. It's not a question of possibility, just of practicality. Although inference in the case of Scala with all its features that introduce ambiguities in the typing rules may well be near-impossible to produce in a way that satisfies developers.
&gt; It's not a question of possibility, just of practicality Actually I remember reading that global type inference is *undecidable* in the presence of subtyping. I'm on my phone now so I don't feel like googling it up at the moment.
&gt; &gt; The reason Scala does not have Hindley/Milner type inference is that it is very difficult to combine with features such as overloading (the ad-hoc variant, not type classes), record selection, and subtyping IIRC, Martin's quote that I saw here on Reddit simply said "subtypes". &gt; As for OCaml, its typing mechanism is interesting, and one that can be fully inferred also by Haskell's type system (I assume you've seen Oleg Kiselyov's work in that area), albeit with uglier syntax and no aliasing. What do you mean by "fully inferred"? IIRC, Haskell cannot infer sum types as OCaml does. For example, you cannot translate the OCaml: `a into Haskell without defining a new type. Perhaps you mean that subtype relationships can be implicit? &gt; I have no experience with F# and I'm not sure how it differs, but it's possible that F# has made some progress in this area. I have heard numerous reports that F#'s type inference can become quite brittle after you've written quite a bit of code, however, and that it becomes necessary eventually to annotate your code or at least restructure it to make it more convenient for the inferencer. This would suggest at least that F# has not solved this problem completely. F# basically infers types whenever HM does and requires type annotations whenever it cannot. The only exception I can think of is operator overloading where arithmetic operators are defaulted to `int` when they are found to be ambiguous at top-level functions. Standard ML also does that, albeit with ad-hoc polymorphism over `int` and `float` rather than F#'s extensible overloading. This does require design guidelines. The most common example is folds: Seq.fold (fun x -&gt; x.Foo()) empty xs that appear in a context where the type of `xs` has been inferred. These are conventionally rewritten: xs |&gt; Seq.fold (fun x -&gt; x.Foo()) empty to make the type of `x` available before the invocation of its `Foo` method. You might regard that as an incomplete solution to type inference with subtypes. It is certainly fragile because it does not compose: code can compile only because the environment it is in has given enough type information and moving that code to another environment that lacks that information will cause it to stop compiling. However, the important point is surely that is works well in practice and, in particular, works better than Scala's current solution. &gt; Eventually global type inference in the presence of all the ambiguities that are introduced by various scala features is, while probably not impossible for most common expressions, extremely difficult to get right. &gt; ... &gt; It's not a question of possibility, just of practicality. Although inference in the case of Scala with all its features that introduce ambiguities in the typing rules may well be near-impossible to produce in a way that satisfies developers. Sounds more like a question of pragmatic vs academic to me. So the reasoning is that a complete (academic) solution is not yet known so no (pragmatic) solution will be provided in the meantime. 
&gt; Actually I remember reading that global type inference is undecidable in the presence of subtyping. I'm on my phone now so I don't feel like googling it up at the moment. Fair enough but my question is why does Scala give up and provide nothing when other languages like OCaml and F# already showed that pragmatic compromises can be reached? 
&gt;Escape analysis was a failure. Citation? I had heard they didn't get the expected gains from it, but haven't heard it was dubbed a 'failure'. Regardless, I have two responses to that: one, if anything, that is a testament to how efficient generational copying collectors are. However, I'm guessing they haven't looked at the gains combined with G1, with something that walks the heap every collection, keeping more objects on the stack is very beneficial to GC performance. Second, they were looking at java performance. I'm interested in hybrid languages, so for things like Scala, I imagine you have a *lot* more garbage generated per method that has no need to be on the Heap. We should find even greater gains for next gen languages. &gt;G1 is good but what about tail call elimination and value types? Value types? Nice but necessary? I'm not sure... Tail call elimination? Honest question, how often do you write performance sensitive code that is not tail recursive but would benefit from tail call elimination? 
&gt; one, if anything, that is a testament to how efficient generational copying collectors are. However, I'm guessing they haven't looked at the gains combined with G1, with something that walks the heap every collection, keeping more objects on the stack is very beneficial to GC performance. Exactly. That is a stronger argument for value types than escape analysis. EA just unboxes locally held values onto the stack when possible. Value types let you unbox structures *anywhere* including on the heap. Hash tables are the best example of value types giving huge performance gains: a generic hash table populated with values of value types (ints, floats, complex numbers, low-dimensional vectors) on .NET [can be 17&amp;#215; faster than the JVM thanks to value types](http://fsharpnews.blogspot.com/2010/05/java-vs-f.html)! &gt; Value types? Nice but necessary? I'm not sure... Escape analysis and G1 were also nice but not necessary. &gt; Tail call elimination? Honest question, how often do you write performance sensitive code that is not tail recursive but would benefit from tail call elimination? I only write code in languages with full support for TCO so I just write the efficient version that relies upon TCO first. Examples are state machines and asynchronous code written in CPS. I am using the technique heavily at the moment actually. Even when C# 5 gets async it will still be much slower because it uses a trampoline in order to avoid having to emit .NET tail calls. 
Because Scala gets actually used in the real world instead of living in their own little happy world like OCaml (which denied getting a good GC donated to replace/improve their existing one) or F# where Microsoft will drop support in a few years like with IronRuby and IronPython. Really, Jon get clean and do something useful with your time instead of this programming language Jihad.
He participates in these jihads to draw attention to his F# consultancy. Still, I think this is an interesting topic to discuss.
I think that Scala does reach a pragmatic compromise: Local type inference.
O'Caml does structural subtyping via row variables. This isn't really "subtyping" as people normally use the term. In particular, there is no subsumption. In practice, O'Caml's approach is less useful than it might seem. Large types are inferred, type errors can be quite confusing, et cetera. You end up needing explicit type signatures and a heavy dose of type synonyms to keep these problems in check anyway. Scala, on the other hand, offers nominal subtyping and subsumption — as Scala aims to be interoperable with Java, there's really no other option. Inference for such a system is significantly more difficult. I won't comment on F# as I'm unfamiliar with the approach it takes.
&gt; O'Caml does structural subtyping via row variables. This isn't really "subtyping" as people normally use the term. In particular, there is no subsumption. Good point. &gt; I won't comment on F# as I'm unfamiliar with the approach it takes. I think F# does type inference over ML code and gives up when it hits methods from unknown classes/interfaces, requiring annotations. So my question is why does Scala give up and do nothing when it could do that? 
&gt; The payoff of these techniques is a small (less than 250 lines of code), easy-to-implement parsing library... [570 lines of Haskell code in `Parser.hs` on their site and 440 lines of Scala](http://ucombinator.org/projects/parsing/) with a trivial example. Would be interesting to compare the performance to that of a real parser as well... EDIT: I did the comparison with a completely naive hand-rolled imperative parser written in F# and their "Yacc is dead" parser is 5-6&amp;#215; slower. 
Nice Introduction to Higher Order Functions in Scala. Hands on + examples
&gt; So my question is why does Scala give up and do nothing when it could do that? It may simply be that they've not gotten there yet. Scala's type system is still undergoing changes and committing to a particular inference strategy may not be appropriate at this time. Or, it may be that inference of the sort you're describing doesn't interact well with certain features (e.g. implicit resolution). Or maybe they don't want to encourage programmers to change programs so that inference can work more effectively as you seem to indicate can be necessary with F#. That left-to-right inference approach may simply not be to their taste; it certainly isn't to mine. Furthermore, I'd be careful about assuming that what F# does is immediately applicable to Scala. Type systems are notorious for small changes causing a number of interactions with existing features. It's likely better to assume Scala can't easily do that and to ask why. I'm not close enough to Scala to have any real insight into what the problems might be. It's likely that only people deeply familiar with Scala's type system can give you any sort of satisfactory answer, so I'd ask them directly if you're really interested. You can probably count these people on one hand.
This is probably the best video scala tutorial I have seen. Excellent presentation, ill be sure to save this to show others when needed.
No doubt you'll correct my imprecise summation, but it's my understanding that OCaml's type system has a "split brain" between the OO side and the ADT side that F# has largely, well, inherited. The unification of these formerly incompatible type systems is something that Scala has at least mainstreamed, if not pioneered. Unfortunately it also removes any hope of H-M, and severely disadvantages any future attempt at global type inference, at least barring some theoretical breakthrough.
My project is still using ant, so I'm not sure it's worth porting to SBT just to try it out in Alpha state. But if anyone has experience with it, let me know how stable it is.
didn't try codefollow yet, but looks very interesting. At least will watch it. But: it's definitely worth switching from ant to sbt just for the sake of using sbt. I did this with projects in development too (after testing with some new dummy projects) and must say, it was great idea to do so. Especially automatic incremental compilation and testing + loading the REPL automatically having all your libs in classpath really rocks. 
&gt; No doubt you'll correct my imprecise summation, but it's my understanding that OCaml's type system has a "split brain" between the OO side and the ADT side Yes. You cannot destructure an object using pattern matching in OCaml, for example. OOP was literally retrofitted onto the language as an afterthought, an academic exercise. &gt; that F# has largely, well, inherited. I cannot agree with that. F# does OOP completely differently to OCaml and, in particular, was always required to be OOP from the ground up because the CLR is. So tuples, records and union types all compile down to classes in F# and, consequently, you are allowed to augment them with additional overrides (e.g. to change the way comparison works) and new methods and interfaces. That alone is some form of unification between the paradigms. So F# does not have the "split brain" you describe. &gt; The unification of these formerly incompatible type systems is something that Scala has at least mainstreamed, if not pioneered. That is what Martin Odersky's propaganda would have us believe but I, for one, don't buy it. To me, Scala looks like OOP with a bit of FP bolted on. For example, a core feature of FP is first-class functions but methods are second class functions in Scala. Another core FP feature (since Scheme mandated it in the 1970s) is tail call elimination. Without it you cannot reliably express many basic functional idioms like continuation passing style and untying the recursive knot. Type inference is arguably another of these defacto standard features of statically-typed FP. From my point of view, Scala is no more functional than C# 3 was. I certainly don't see any of this pioneering unification of the paradigms. Odersky's "grand unified theory" does not even look particularly useful to me (unless you've tied yourself to the JVM and are looking for an escape route) and the lack of type inference is a big reason why. &gt; Unfortunately it also removes any hope of H-M, and severely disadvantages any future attempt at global type inference, at least barring some theoretical breakthrough. That's just it. I don't understand why that would be the case. Surely Scala could do type inference and bail when you step outside ML, as F# does. After all, you guys wouldn't be trying to fudge around the issue by inventing terminology like "global type inference" otherwise... 
I tried CodeFellow as I've been a Vim user for 12 years. I then saw ENSIME for Emacs, and switched away from Vim. It's that good. If you want to try it, there is an excellent Vim emulation mode for Emacs, so you'll hit the ground running. I think it's worth an attempt.
well, CodeFellow seems to have a lot of the features that ENSIME had. Was it a stability issue, or did ENSIME just have more stuff, or what? 
It was mainly that it "just worked." Running "M-x ensime-config-gen" and answering a couple of questions and having completion/formatting/docs was refreshing. CodeFellow may have improved since I switched. I still think it's worth it to give it a shot.
Oh well, I don't see where the problem putting Scala on Android and App Engine would be... I already wrote some Android App in Scala and it is really quite ok. Not to mention that Scala is the only tolerable language that can be used to program for Android, it does not rely so much on on reflection which is a good thing on Dalvik.
I hadn't heard of it, so I gave it a try. The description is quite compelling. Unfortunately it is pretty tedious to use. It doesn't seem to work well with 2.8.1, for example. Also on a mac there are more challenge; it might work better on Linux. Such a great idea, such a disappointment. I am compelled now to try ENSIME though.
I know it is working but there is a big difference in what is possible compared to what is supported. When it is supported you will get support out of the box and will not have to deal with special custom buildscripts or tools and the documentation for it is there.
&gt;If you put Scala as a first class citizen on Android and &gt;AppEngine. Error: Expected token 'THEN' on line 1.
Its like one of those movies where you have to figure out the ending :-) I forgot to delete that sentence when .. i had to change diapers (on my baby)
Quite a few prominent Scala nerds are already Googlers. Off the top of my head: * Lex Spoon * Josh Suereth * Burak Emir
/second that. I hope Scala completely displaces Java on the JVM at some point. Hate Java, love the JVM, love Scala. Clojure is looking good too, but Scala's been around longer and is more mature. And for anyone not aware, Scala &amp; Lift are already running on GAE: * http://lift-example.appspot.com/ * http://www.scala-lang.org/node/1826
Introduction to Lambda Expressions in Scala, along with some explanations on how to write functions in a concise way, using the underscore
Lambdas in Scala
Lambdas
Nice introduction to lambda expressions in Scala
These are great articles. They're simple enough for straight up newbs and very good refreshers for someone like me, who could use more detail on the why/how. 
As I commented on the scala-stm list, this is a really great website for an open source library. And with heavyweights like Dan Spiewak and Nathan Bronson involved, the code should be great too.
No, it's just the first step. :)
I've heard that Lift was revolutionary but what I've heard was not supported with any compelling evidence. Now I followed the links from this post and looks like it really is - despite the fact that I'm not a web developer at all and I can't fully appreciate it.
This is great. The solutions presented really show the elegance of Scala, and I've learned a lot by reading through just the first few.
Snow simulation using Akka
Asynchronous Game of life based on Akka - customized for Christmas
&gt;Some people say the Scala syntax is more complicated than Java, but in fact the language spec for Scala is significantly smaller (191 pages) than the language spec for Java (684 pages). Yeah, and the brainfuck spec is one page. Spec size isn't related to complexity. I've been trying to learn a bit of Scala lately and while I do like the language. I find the syntax to be a lot like Perl in that there are multiple ways to do something with varying degrees of syntactic sugar.
"If you believe, as I do, that a given programmer can produce roughly the same number of lines of code per day independent of the language used, you can see how this reduction of lines of code can translate into a substantial increase in productivity and a faster time-to-market." I do not believe this at all. I think a gifted coder will take more time making less lines of code...
Yes, you are correct. However, I spend a lot more time *thinking* about a program than I do actually typing out lines of code, and less LOC means I can fit more functionality in my head at one time. I think that's the big advantage of Scala. 
Link?
Here's the link: http://www.dataists.com/2010/12/ranking-the-popularity-of-programming-langauges/
background: http://klangism.tumblr.com/post/2497057136/all-actors-in-scala-compared
If you're looking for a list of big companies using scala in production, see [Scala in the Enterprise](http://www.scala-lang.org/node/1658) at the official Scala website.
Perfect, thanks.
(Disclaimer: I really like purely functional data structures) I think the article would be better if the claims were backed by some kind of hard numbers: &gt; many versions of a data structure can be kept simultaneously with relatively modest memory requirements. What is modest? What use cases are terrible, what are good? &gt; purely functional data structures are composed of many tiny parts, making them ideal for incremental garbage collection, leading to lower latencies. How much lower? In which workloads does this start becoming apparent?
That's interesting, I hadn't heard of the PHP to Scala conversion tool. That would be fun to experiment with.
This is actually pretty awesome. I've been looking for examples of intervention code in Scala.
The name alone makes me hope that the book does NOT come out.
I've been using it for a couple of months. In my experience, it is almost as stable as the scala plugin for the previous eclipse release. It is definitely worth giving it a try.
Does it have the occasional hangs that would take down the current 'stable' version of the plug-in? I hate that sooo much. 
names aside - Greg has the monad explanation knack: [Video Talk on the subject](http://channel9.msdn.com/Blogs/Charles/C9-Lectures-Greg-Meredith-Monadic-Design-Patterns-for-the-Web-Introduction-to-Monads)
I recommend using the WIP-branch of the scala plugin, IMHO it's more stable than the helios branch and works both with 3.5 and 3.6 update uri: http://download.scala-ide.org/nightly-update-wip-exp-backport-2.8.1.final
Will the book be available under a Creative Commons licence?
I've had a long period of good results from IDEA for about a year, FWIW. Would be interested to hear your opinions on where you feel the Eclipse one is better. 
Which wasn't too stable for me. I was a big eclipse fan, but after the having problems with big java projects (and the occasional crash which would wreck my workspace for hours) and continually having problems with Scala, I'm a full time Vim user. 
just tried it, seems very smooth. I have idea 10 and been wondering the differences in use. Eclipse, after first usage, seems to be running faster, probably cause IDEA loads a lot of plugins I don't use. Will look into eclipse more. 
Does anyone else think Scala support in Idea 10 has regressed? - I get false compile error markups. It may be because i use SBT in a compile loop in the background and abuse Idea as a text editor.
Enjoyable. Not sure about this sentence though: "...one of these concatenative languages like Io..." I've watched or read InfoQ interviews multiple times, but this is the first time I observed and used the "Full Page Transcript" button.
Yeah, this guy really gets it. I love that he answerd with this: &gt;The interesting thing about that is Scala doesn’t really adopt any specific concurrency model in the way that say Erlang does. Rather it’s like Java in the sense that whatever library you have, you can use. In that sense it doesn’t do anything for you, even though you may be mislead into thinking that it does because it comes with an actor library and other frameworks are implementing the actor libraries. But perhaps the most interesting thing that it does to make concurrency programming easier is the general support for domain specific languages, the features of the language that will let you define abstractions in this. &gt;In a domain of concurrency it could actually be very valuable for building concurrency models that are intuitive when you read the code as opposed to "I’m reading this syntax in this language and I have to map it to constructs in my concurrency model." I think that the most important thing is that first it leverages the power of the JVM and CLR for letting you do concurrency either at the multithreading level or at a higher level of abstraction. That also gives you the ability to write domain-specific languages or easily intuitively represent a concurrency model that you’re working with. That's easily the best answer I've heard yet on why Scala is good for multicore. Too many people try a hand wavy explanation of "it's more functional so I think it'll be better on multicore." It doesn't work like that. You still need something to resolve immutable data structures like STM, and I don't think we've established that STM is the silver bullet. Writing a highly concurrent system in Scala I can say that being able to clearly and easily express simple blocks of code with a DSL like syntax to help with locking and concurrency is what made Scala the right choice. 
I'm sure it must be something I'm doing wrong, but I've played around with the Scala plugin for Eclipse lately, both the Galileo version and the Helios version, and it's just barely usable. When I start typing code, my CPU fan spins up and editor delay is just unbearable, it's like I'm working remotely over a modem connection. Every time I save it compiles, which is slower than molasses. Eventually I start getting GC errors ("GC overhead limit exceeded") and Eclipse asks to be restarted. I really can't work like that. Is there some setting that will make the plugin usable? Edit: Switched to the [WIP-branch](http://www.reddit.com/r/scala/comments/exhxv/anyone_using_the_experimental_scala_plugin_for/c1bqtq8) and it really is significantly better!
I keep meaning to give it a spin, but I've never downloaded IDEA so I cannot compare it. Mostly this is simply due to inertia as I use Eclipse for everything at work. I can say that the Eclipse plug in has made great strides in the last year or so but there is still a ways to go. The autocomplete seems fairly broken to me, often throwing up a lot of generic results (case, match, if, +) rather than things specific to the class in question.
The WIP-branch is actually quite useable. Completion is far from perfect, and there's almost always false positive red markings in the editor, but except for those things it's really swell.
&gt; I was writing some validation code to validate and parse data entered by a user. The validation function should return an object of some type, but it should return a string representing an error message in case of failure (in case the input in invalid). Too bad the Option type isn’t sufficient for this. Enter scala.Either. To me, this just feels plain wrong. If a function cannot complete the task it is given, why not just use exceptions? That's what they are for.
Without addressing its usefulness in this article, I can point out one place that I have found this to be useful. When passing a hash (or other collections) of any kind into a function and expecting it to process the items in that collection and return a processed collection. Function signature is: def myFunc(arg:HashMap[String,TypeA]):HashMap[String,Option[TypeB]] if you just want a succesful element or null. Or if you want insight into the failures def myFunc2(arg:HashMap[String,TypeA]):HashMap[String,Either[Exception,TypeB]] So you get back a collection that is type and null safe and haven't interfered with the flow of execution when only part of the job could be completed.
Great talk, thank you for posting. It's the first time I've heard an interview from "The Man" regarding Scala. I am hoping listening to this will finally break my habit of pronouncing Scala as *Scale - ah*.
Yeah - i wish the uppity Europeans didn't decide to pronounce it that way.
&gt;So that turned out to be much, much harder than I imagined. But in fact, in the end result the Scala collection libraries are actually unique, nobody, no other language has a library like that, where you say you have a rich set of collection types, a rich set of collection operations, in particular bulk operations, that take function parameters like Map, Filter, Flat Map, these sort of things and you have the uniform return type principle which says that every operation can be applied on a collection and yields the value of the same collection as a result. So if you apply a map to a set, you get a set, if you apply a map to a sequence, you get a sequence. isn't that like fmap in haskell?
So they implemented a poor man's type classes (from haskell), and sell it as "no other language has it" ? 
Yep, pretty much.
Yeah. By "unique", I guess he's really alluding to the the next section. He mentions a more interesting feature of the Scala collection API where the returned container type can vary based on the type of the function given to map.
http://www.scalanlp.org/ — ScalaNLP is a collection of libraries for Natural Language Processing, Machine Learning, and Statistics. http://code.google.com/p/scalalab/ — The ScalaLab project aims to provide an efficient scientific programming environment for the Java Virtual Machine. The scripting language is based on the Scala programming language enhanced with high level scientific operators and with an integrated environment that provides a Matlab-like working style. http://code.google.com/p/gapt/ — Gapt is a proof theory framework. https://github.com/scalala/Scalala — (subproject of ScalaNLP) Scalala is a high performance numeric linear algebra library for Scala, with rich Matlab-like operators on vectors and matrices; a library of numerical routines; support for plotting. https://github.com/psnively/mittelos#readme — An implementation of Event Calculus reasoning in Scala. http://code.google.com/p/factorie/ — FACTORIE is a toolkit for deployable probabilistic modeling, implemented as a software library in Scala. It provides its users with a succinct language for creating relational factor graphs, estimating parameters and performing inference. https://github.com/andrewmilkowski/s-hansei — A Scala port of HANSEI, originally in OCaml (Embedded domain-specific language HANSEI for probabilistic models and (nested) inference).
With 47 hours to go it is @ $10,963. Only $1537 away from goal. 
Wow, it is now up to $11,293. Nice.
*shameless plug* We're working on a high performance parallel language for mesh-based computation that consists of a subset of scala. The project is not ready for public consumption yet, but there's some details here: http://liszt.stanford.edu/ The Scala developers are definitely interested in scientific computing and the possibilities it has in that field.
Plus, the EPFL/Stanford team working on "Popular Parallel Programming" have just won a massive 5M euro grant!
https://github.com/urso/scala_prob - probabilistic programming DSL in spirit of hansei alternative (s-hansei alternative). Using the support libraries, one can do probabilstic programming using for-comprehension in scala too. 
Puts PyPy to shame.
I wish there was an implementation of this available, though I do question the bytecode transform approach as something that would easily fit in with existing code. Still think the idea is neat though. Has there been any other effort to duplicate the results of PIcoThreads?
this one too http://www.scala-lang.org/node/1209
There's a youtube link to me using it in the readme. It has a ways to go, but if you're like me and hate using Eclipse because it's so bloated and crashes constantly, this might be useful. 
Vim??? Really?
works for punch cards too
You don't like Vim? 
That's pretty cool.
This guy's premise is totally backwards. He goes on to say how in large projects, there are practically DSLs, components that not everyone knows, etc. Basically that the learning curve of jumping into a large project is extremely high. So to me that seems like a great reason to use Scala. If no one is expecting a new programmer to the project to hit the ground running, what does it matter if he's less than an expert in the language and has to experiment a bit. Granted, Scala can be taken to the extreme where all but an expert can easily understand it, but assuming most of the code is &lt;= Ordeksy's level 2 stuff, any smart Java programmer should be able to figure it out. If you know that your project is large enough that no single team member is going to understand all of it, why not get a productivity boost to those that are willing to try out Scala? 
First time I had a look at Lift, but for me it seems a bad decision to have framework instructions in the HTML `class` attribute; they should have made a `lift` attribute or something.
The class attribute thing is a new addition and is a way to implement designer-friendly HTML templates. And it is purely optional. There is another way to call your code from HTML - using custom tags that are mapped to snippet classes. Pick your poison.
Nice illustration with Actors. As an alternative with STM: [scala-stm/philosophers](http://nbronson.github.com/scala-stm/philosophers.html) It is the simplest Philosophers implementation i have seen - and fast - I get 10k dinners in ~4 usec 
As said, it is my first look over lift; I like the simplicity within the templates, but I disagree on using the class attribute for anything else than denoting CSS classes used. :)
Then don't do it. In fact, what you propose was the standard until Lift 2.2. Now you have the choice.
Is it possible to define polymorphic Functions in Scala like in Haskell?
 "For a comparison, check out the equivalent in Java using semaphores." They are not equivalent at all. The Scala code is a single lock solution. "The Scala version is far less code and much easier to comprehend" Less code? Unless you take into account the space occupied by the comments in the Java version, your solution has much more code.
(if gist goes away, changeset and some background http://lampsvn.epfl.ch/trac/scala/changeset/23993 http://groups.google.com/group/scala-language/browse_thread/thread/93645910e3b2fcee 
Cementing itself as the most confusing language ever? Joking. It's an ambiguous title.
Very Nice - is this going to be in Scala 2.9? If so does it depend on JDK 7 for InvokeDynamic?
Don't worry, people have said this about every major change in software engineering since computers were invented and there will always be people in industry who refuse to modernize. Just be glad they are your competition! 
A small criticism on tone: I found it hard to take your arguments seriously when you summarized you're opponents arguments as "blah blah blah".
Sounds good, but is there a "Scala non for non-Java programmers" ? I feel that most books pretty much assume you're familiar with the Java toolchain and libraries.
My impression is that Programming Scala is well suited for non-Java programmers.
I don't get how private[this] is not generally useful... it seems very useful for factoring helper methods out of larger methods in a class.
I'm absolutely able to reproduce that locally. It sends Eclipse into fits.
Cay Horstmann did a fine job with Core Java. One of the most frustrating things about Scala's present documentation-sphere is lack of really good (non-hacker) authoritative examples to teach proper form (if you don't scoff at such a notion). Hopefully he'll get this one right too.
Scala does this even more effectively, in fewer lines: echo 2.2250738585072012e-308 | scala Profit! :)
Answer to Q7 is misleading: Counter in NOT a companion object for class Object, and it is why its private field is not accessible. To be a companion object, the object name must be the same as the class, and it have to be in the same namespace and compilation unit. Classes have access to their companion object private fields, but not to private[this] scala&gt; object Namespace { | object Foo { private val x = 42 } | class Foo { import Foo._ ; val foo = x } | } defined module Namespace scala&gt; (new Namespace.Foo).foo res1: Int = 42 scala&gt; object Namespace2 { | object Foo { private[this] val x = 42 } | class Foo { import Foo._ ; val foo = x } | } &lt;console&gt;:7: error: not found: value x class Foo { import Foo._ ; val foo = x } 
Now we have the kitchen sink AND the taps!
I think they are most promising to work with XML and JSON. Most probably I won't them otherwise.
If you just want it as a string: val s = Source.fromFile("/demo.dat").mkString println(s)
"full language virtualization" - sounds promising 
The title of the article suggests that this is a file for whose contents it would be impractical to load entirely into RAM... then this suggestion, though concise, would not be suitable. The example in the article would process an arbitrarily large file.
Yea, though the author could have made it more clear in the post. Also, that site could use more ads.
Thanks, I see I need to continue to work on my Scala-fu :-)
Exactly. After 3 months I have the same conclussion. Unluckly now the Eclipse plugin is too buggy...
Scala Solutions seems to be making a new or improved plugin for Eclipse. Odersky said it was right around the corner. There was also some commits to Scala trunk that fixed some bugs I've seen in both Netbeans and Eclipse.
I crossposted this to [r/programming](http://www.reddit.com/r/programming/comments/fisaf/david_pollak_string_is_never_having_to_say/), because frankly, it's more needed there.
My biggest fear with scala are the people that just have to use every new feature that they find out about no matter whether they have a use case for it. This would be the equivalent of a java programmer who's java code is full of unnecessary reflection.
This wouldn't exactly convince the skeptical.
It's an interesting way to look at it; how much rope a language extends to developers to hang themselves with. Scala's tooling may still be too immature for "Enterprise" developers, who often feel more comfortable with IDE sneeze-guards. 
This blog entry could be boiled down to 1 sentence. "I saw some bad scala and it wasn't really worse than bad java". As someone who would like to use scala in the enterprise, this anecdote does not provide me any useful evidence to convince my superiors.
As a much-maligned "Enterprise Java Developer" who has been working (mainly for fun and personal enrichment) in Scala, I'd like to offer the following: * Really big Java shops have generally grown hyperconservative in what they'll allow. There's a big push to standardize toolkits, APIs, and frameworks. * A large part of this is, unfortunately, due to the large number of foreign, young, temporary, and/or contract workers. There's pervasive notion that: "if we can just get them all using the same tools and APIs, they'll all code the same". * As we all know, developers are not fungible resources. A good one can be 10x as productive as a poor one. [citation needed], but you still follow me. Unfortunately, most department managers only barely realize that, particularly if wage differential is involved. * If I go to my department head and push for new tech/toolkit/api X, I have to be able to prove that it won't mess anything up, will require zero retraining of the young/temp/foreign/contract workers. Also, I have to make sure it doesn't hurt any relationships with established vendors. And, finally, whatever I offer has to ultimately show MASSIVE performance or dev time gains or fix thousands of known problems. As such, getting new technology introduced is usually a huge effort in and of itself. * Up to this point, the only way I'm able to move my dept forward is to take over failed projects and implement them using the toolkits of my choice. * Having done that, my God, I cannot imagine making the Scala push * Moreover, I've got guys the next room over who can't write an 'equals()' statement (nor do they understand WHY you'd need to do so). How in the hell you think they'd take to Option, flatMap, case guards, or tail calls? And I say this as a booster of Scala!
and, oh yeah, jenkins http://synesso.posterous.com/sbt-plugin-updates
This article is from 2009. Do people still think it's true (if it was ever true) in 2011? I'd tend to think so.
Sure, why not? Any language which is suitable for production work but has not yet crossed the chasm would probably fit.
Why would you ever do this? You can write servlets using JRuby. Why introduce Scala?
I agree with you.. it's the sad reality. The near future of scala will be in startup's and smaller companies that can be more agile in their choice of frameworks and languages.
Totally useful and clear; thanks.
Scalacheck is a game-changer.
background: http://scala-programming-language.1934581.n4.nabble.com/Thesis-ScalaFlow-Continuation-Based-DataFlow-Concurrency-in-Scala-td2994324.html
J. Irii strikes hard and without warning, rarely requiring a second edit to take down his prey.
A class is a "kind of" type. Aha ha ha... :-)
http://twitter.com/odersky and http://twitter.com/hseeberger
An interesting post, I'm not sure if I agree with all of his points, to me (as an amateur, still learning as I go Scala developer) I don't find the syntax too complicated. It's a bit of a climb, but it's not a massive jump from Java.
Does anyone know if Caoyuan Deng is still working on the Netbeans plugin? He did an interview fairly recently but I have noticed any activity lately on the plugin site.
I have not found an example of something simple to do with Java but hard with Scala. Hundreds the other way. To me, the real news is the Odersky's comment to this post: Martin Posted February 21, 2011 at 4:17 pm | Permalink This is Martin, the language designer. I am sorry that your tool experience was so frustrating. I just wanted to say that my company Scala Solutions has taken the over development of the Eclipse IDE for Scala. We should have a first beta out together with the release of Scala 2.9, in a couple of weeks. I have personally spent quite a lot of time improving the interface with the compiler. I have now switched for all of my development work to our as yet unreleased version of the Scala plugin for Eclipse. That’s after 20 years of emacs. And I am not looking back. The new Eclipse IDE is not yet as feature complete as Java’s, but we have made great progress in terms of stability and responsiveness in large projects. Regarding fsc, failing after 30 minutes looks very mysterious to me — I ever have seen that one reported by anyone else. A firewall problem, maybe? 
I didn't see this comment, it's great to see Martin speaking to the community (and its detractors) and writing his message in such a considered and sensible manner. Personally I don't use either of the IDEs, I just use good old vim instead - but for a language to gain true potential I do agree that the IDE integration needs to be rock solid, so it's good to see that (it appears) this area is being actively looked into
I love it when the argument boils down to someone whining about IDE support.
I heard a recent interview with Odersky where he said that he had four full-time people working on the Eclipse IDE plug-in improvements. Hopefully this will be a solved problem soon; in the meantime I've been enjoying using emacs in conjunction with the ensime plug-in. 
Which is just wrong. Sometimes a level of over-generalization is reached where I can't really desribe it in other terms than just "false" ...
The blog post author shouldn't confuse the language with the tooling.
This guy is a Scala troll. "excessive functional and academic aspects"? Martin uses Emacs, therefore there cannot be good tools for Scala? Nonsense.
Awesome, have bookmarked, these should keep me busy for a while!
I've wondered the same. But I guess if you're using all 22, you're doing something wrong. :)
Came here to say this. Personally I think if you need more than a few objects in a tuple you're doing it wrong. 
It is ugly but it is due to a fundamental limit of the type system. A tuple is basically a Sequence with a different type for each position. I you want to allow all possible tuples then you'd have to allow: * Generic classes with a variable number of type arguments * Classes with a variable number of fields (each named/typed differently) I can imagine that it's a bit difficult to do this without seriously making things more complicated. I did personally run into this limit, and it wasn't due to my sloppy programming (I can show the code if anyone disagrees with that).
I've often wanted to write code with variable number of type arguments. If it were enabled, I think it would open up a lot of coding possibilities. My completely uninformed opinion is that the effort would be worthwhile. EDIT: even if it's just done as a macro that expands the template code out to 22 Tuple classes, for example, that would be worthwhile.
I have seen some sort of macro system for scala. I believe it was a plugin for sbt. However I can't find it anymore. Does anyone know what I am talking about?
For me, using a a tuple bigger than 3-4 is already ugly. Do you really need to enclose 23 objects with 23 different types ? How will you remember what position corresponds to what ? A case class can be more useful (especially with the named arguments in scala 2.8). If you really need it, you can still use [heterogeneous lists](http://apocalisp.wordpress.com/2010/07/06/type-level-programming-in-scala-part-6a-heterogeneous-list%C2%A0basics/).
I can believe it, but no, I don't know anything about it
I don't like the way the unary_ prefix is reserved for a couple of operators rather than being a general rule. I'm not sure what the reasoning is as it would seem to me, naively, to just add a a small compilation cost during operator resolution. Perhaps, by allowing it generally, it would be impossible to resolve the operators for some expressions. 
How is it ugly? How in the world do you ever have to actually deal with the way the tuple classes are actually defined?
I agree, but then why the tuples didn't end at say 8 if using tuples bigger than 4 are ugly or as another commenter said is wrong?
Thanks for the reply. It is great to know that I am not the only one that thinks this is ugly! :)
This. Op: I suppose you'd have a similar issue with the Function1... classes, right? I'm curious why it matters to you though, in practice I never see the Tuple2..etc classes. So why does their underlying implementation matter? You're not using Tuple2[Int,String] in your type signatures, are you?
If you're going beyond Tuple5 or so, your code is already ugly. Use case classes instead. And if you need Tuple23 (which I'm pretty sure you don't), just write it.
It does go against the 0-1-n rule, which makes it inelegant, even if that's tangential to its use in practice. 
Let me rephrase. I am not saying that it's good to have Tuple5+ in a codebase or not. I am pointing to the fact that having 22 Tuple classes is not beautiful. That the arbitrary number 22 does not make sense. That why up to Tuple22 and not Tuple16 or Tuple32?
It's arbitrary either way. They just figured that nobody would reasonably want more than 22. Arguing from "beauty" smacks of rationalism. What are the actual consequences of being "not beautiful" in a library? If you don't like these types, don't use them.
Okay I think this discussion is entering an infinite loop. I am just referring you to logophobia's answer: http://www.reddit.com/r/scala/comments/fsig3/i_have_been_playing_with_scala_lately_and_this/c1ials1
It's a consequence of the compilation constraints. We could think of auto-generating these classes, but then we'd need an infrastructure that allows us to add auto-generated classes to existing packages (i.e. the scala package). That's not always easy to do, for instance if you are in Eclipse. I agree the present scheme is not exactly beautiful, but it works in practice. We have not yet seen any legitimate code that needed to go beyond 22 tuple elements. If you need long tuple-like things a better type would be HList. 
&gt; I did personally run into this limit, and it wasn't due to my sloppy programming (I can show the code if anyone disagrees with that) I'd be interested in seeing your use case.
Ok, this use case is not about using a tuple as a datastructure, but using pattern matching + a large tuple to initialize a lot of variables. I am currently working on a program that takes a lot of parameters through the command line. It parses the options with a function like this (simplified): def parseOptions(args : List[String], currentOptions : Map[Symbol, String]) : Either[String, Map[Symbol, String]] = { args match { case "--start-server" :: tail =&gt; parseOptions(tail, currentOptions ++ Map('server -&gt; "true")) case "--process-file" :: file :: tail =&gt; parseOptions(tail, currentOptions ++ Map('server -&gt; "false", 'file -&gt; file)) case "--port" :: port :: tail =&gt; parseOptions(tail, currentOptions ++ Map('port -&gt; port)) case "--path" :: path :: tail =&gt; parseOptions(tail, currentOptions ++ Map('path -&gt; path)) case "--filter" :: filter :: tail =&gt; parseOptions(tail, currentOptions ++ Map('filter -&gt; filter)) case "--constraints" :: constraints :: tail =&gt; parseOptions(tail, currentOptions ++ Map('constraints -&gt; constraints)) case "--lagrange" :: lagr :: tail =&gt; parseOptions(tail, currentOptions ++ Map('lagrange -&gt; lagr)) case List() =&gt; Right(currentOptions) case _ =&gt; Left("Couldn't parse command line options: \n" + usage) }} Which gives me a map with my parsed options. In the main function of the program I use this map to initialize all the parameters I need so I can start various solver components or servers. Something like this: val (exhaustive, compareTo, timeout, splitOn) = (options('exhaustive).toBoolean, if(options('compareto) == "") Left("No file given to compare with") else Right(options('compareto)), options('timeout).toInt, if(options('spliton) == "") None else Some(options('spliton))) After adding a few parameters I eventually hit the 22 limit. I refactored it to something that didn't use multiple assignment (just val a = ..\n val b = ..). Now that I really look at it, I realize that this probably isn't a valid use case. Multiple assignment syntax works well for 2-10 variables, but after that it's probably not very easy to read.
Wow! Thanks for the reply Martin! And yes I just wanted to be sure that I am not the only one that thinks the current scheme, as you say, "is not exactly beautiful". But anyway, so far learning and playing with Scala has been so pleasant. What made me very interested in it was the fact that it's possible to write type-safe JPA-criteria-like queries with Scala/Lift. Should make maintenance of projects with frequently changing DB schemata less error prone.
I agree that it's inelegant and it's (somewhat) unfortunate that this even can be visible to a user of the language. The thing about Scala is, as Martin Odersky frequently points out, the language is designed in such a way to allow these kinds of features to be implemented in the library level instead of the language level. Tuples aren't a perfect example of this since the syntatic sugar that keeps you from having to use those ugly TupleN types is clearly a language level construct. However, the existence of the TupleN types and the corresponding arbitrary size limit are visible and ugly to you only because they're implemented in the Scala standard libraries whereas that type of feature would be implemented purely behind the curtain in other languages. I agree with what you're saying (they're ugly) though I think it has no actual impact on the quality of Scala itself. This reply isn't really meant to contend with what you're saying, just expressing some of my thoughts/understanding on the matter.
This. @jbrechtel: Yes, this.
This is a pretty cool paper, and the idea isn't just Scala-centric. I translated this example to Python using generators: https://gist.github.com/845877
That's quite generous ("troll"). He's a clueless idiot, with a chronically exaggerated self-perception of himself and his abilities. His constant displays of idiocy are not exclusive to Scala topics, so I also don't think the "Scala" prefix is necessary. There are a small number of people on the internet that you can always safely ignore knowing that you didn't lose anything. This guy is one of those. Not intending to disparage primarily (though of course, I did), but for those who might care about efficiency of time and learning paths, ignore this guy and you lose nothing. Promise.
Can someone elaborate as to what the issues with the current implementation are? I see [this thread on Stack Overflow](http://stackoverflow.com/questions/5057322/scala-memory-leak-using-pull-parser) about memory leaks. Is this the problem or is it something else? I've had success using it, however, I have only been working with very small files.
So, the Scala compiler does not automatically optimize tail recursive functions? I would rather this be automatic rather than having to specify an annotation for it to occur. This is how F# is done...
More information here: http://github.com/djspiewak/anti-xml
Duh, I don't know how I missed the main page. Thanks!
&gt; ...true professionals learn to do hard things... Your reference to the IntelliJ IDEA Scala plugin was valuable (assuming it is true: I haven't tried it myself) but trying to pretend that complaining about buggy tooling is unprofessional is hugely counterproductive. You are effectively telling your customers that, if they were real professionals, they would rewrite your product after you did a crap job. 
I think you totally missed the point and that at purpose. I don't have anything against your love for OCaml and F#, but could you please spare others your crusade? In my humble opinion academic languages like OCaml and F# have their purpose, but in the real world people prefer general-purpose languages with good IDE support like Scala.
You are making a bad situation worse by repeating his mistake. 
* not-null by default unless explicitly declared nullable * optional checked/declared exceptions on a per-method basis * no erasure (JVM's fault, but still)
I'd add Hindley–Milner type inference.
FWIW, Odersky has basically stated that with current technology you can't do both Java interoperability and Hindley-Milner inferencing. It would be nice, though
Remove XML literals.
Actually, some Haskell guys have built an implementation of the .NET type system and dispatch rules _in_ Haskell. So this statement sadly doesn't hold up upon reflection. Now, said implementation is far from natural, but it does provide a proof of concept. That said, I think Hindley-Milner is definitely a local optimum. I am very glad that Odersky is seeking another point in the design space, if only from a programming language genetic diversity perspective.
I'd want higher kinded existentials to work as advertised. I have a large body of code hung up on this bug, and the related bugs that have been merged into it: http://lampsvn.epfl.ch/trac/scala/ticket/2308 Worse, to me, if you perform the mental gymnastics to work around the compiler bugs that keep code like this from compiling, the result compiles, but them bomb out at runtime because the compiler leaves abstract methods in the classes it generates. https://github.com/ekmett/magpie/commit/9c7a6b0ddd1fa9a7dd1af079ace2699a4ab41f0a#undefined What bothers me is that these broken higher kinded existential members actually were slipped into the 2.8 containers API in some places, e.g. http://www.scala-lang.org/api/current/scala/collection/mutable/Publisher.html so you can't even pretend they don't exist.
For some reason I thought it was because compilation times would go (even further) through the roof. I haven't seen any mention of it being called impossible. Do you have a link?
And, seriously? A downvote on a comment to a story that will have 3 threads if it's lucky? Come on.
AFAIK Hindley-Mildner doesn't work with subtyping. Basically, it can infer a type, but can't guarantee that the real type isn't a super- or subtype of the type inferred. I seem to remember Odersky mentioning this in an interview, but I can't find it at the moment.
Add JSON literals
* proper tail recursion (JVM again)
 - Fix pattern matching, once and for all - Fix XML, once and for all - Make case classes more flexible.
So how do they handle interop betwenn the .NET part and the Haskell part? I. e. implementing/subclassing classes, calling functions, currying, etc?
http://programming-scala.labs.oreilly.com/ch02.html#InferringTypes (also, staircase, page 328 on my First edition, versn 5 http://scala-programming-language.1934581.n4.nabble.com/scala-Does-scala-use-Hindley-Milner-type-inference-td1997689.html http://www.codecommit.com/blog/scala/universal-type-inference-is-a-bad-thing http://www.codecommit.com/blog/scala/is-scala-not-functional-enough http://www.codecommit.com/blog/scala/what-is-hindley-milner-and-why-is-it-cool http://thought-tracker.blogspot.com/2008/02/type-inference-in-f-scala-pointers.html http://matt.might.net/articles/best-programming-languages/ http://james-iry.blogspot.com/2010/05/types-la-chart.html http://staticallytyped.wordpress.com/2010/04/17/solution-in-scala-to-the-previous-post/ http://www.reddit.com/r/scala/comments/ectzr/why_no_type_inference_in_scala/ http://stackoverflow.com/questions/4304003/what-does-no-global-type-inference-mean-regarding-scala 
What's wrong with pattern matching?
HM doesn't do subtypes but variants that do have been commonplace for over a decade. Look at OCaml, for example. Not just the object system either, polymorphic variants also expose sub-/super-type relationships. F# also has both type inference and subtypes.
For me and everyone I know, Scala's lack of type inference is the main show stopper. I am also personally very concerned about the lack of TCO but the people I know have not expressed anywhere near as much concern over that. When I last seriously looked at Scala back in 2007, the buggy compiler and IDE plugin were a major concern but a couple of people have told me that the IntelliJ IDEA plugin for Scala is decent now. EDIT: As John Nowak notes below there are conflicts between the advanced parts of Scala's type system and type inference. I would gladly sacrifice those advanced features for type inference because I believe they are of comparatively little use. 
You are confusing two related problems. When a programs can be fitted into the Hindley-Milner type system you obviously can do Damas-Milner type inference. When a program uses other features (like overloading) then you cannot do Damas-Milner type inference. However, that does not force you to sacrifice type inference everywhere as Scala has done. F# applies Damas-Milner when possible and requires type annotations elsewhere. There is nothing to stop Scala from doing the same. 
On Daniel's blog post "Is Scala Not Functional Enough" Martin replies and says "As to combining Hindley/Milner and subtyping: In principle it’s possible, but in practice it does not work so well. The problem is not so much that you end up too often with Any, but that inferred types become impractically large. " I wonder what impractically large means there.
**Inference** Well, I wouldn't call a missing minor improvement in type inference a "show stopper". Yes, it would be nice, and there is a reason why the spec refrains from saying anything which could prevent the type inference from improving. I'm sure if you wrote a patch improving type inference people would at least look at it. But from my personal experience I have never hit a reasonable example where inference failed. Do you have a specific example where you would like to see better type inference? **Tail calls** I wonder why you keep singling out Scala. Clojure, Groovy, JRuby, ... every language is missing tail calls on the Hotspot JVM. Do you know why? Because not an individual language is missing it, but the VM lacks support for it. And it is not like people say "that's not important" but almost everyone is quite annoyed that Sun/Oracle still can't get their act together.
Still too many bugs in it. You can't be sure that it does what you expect it to do. (0: Any) match { case List(_*) =&gt; "List" } // This shouldn't return "List" ...
&gt; But from my personal experience I have never hit a reasonable example where inference failed. Last I looked, Scala's type inference failed on the factorial function. &gt; ...every language is missing tail calls on the Hotspot JVM. That is incorrect. [Kawa](http://www.gnu.org/software/kawa/) is an obvious counter example on the JVM and, of course, lack of tail call elimination in C didn't stop people from developing FP implementations that compile to C and implement tail call elimination decades before Scala even existed. This is a solved problem. 
Yikes! Glad I haven't ran into that one yet.
http://code.haskell.org/Salsa/Docs/Thesis.pdf is the thesis in question. Basically .NET methods get created as labels, with # and &gt;&gt;=# operations serving as dereferencing (a la C#'s .) to obtain an IO action with the right type signature to retain type safety. Subclassing is handled properly for label dispatch through multiparameter type classes representing subclass relationships, implicit type coercions, overloading, etc. and IIRC a preprocessor is available to convert a .NET type into the Haskell typeclass constraints and labels needed to use it. e.g. to encode: using System; using System:Windows:Forms; class Program { static void Main(string[ ] args) { Form f = new Form(); f.Text = "Saucy Salsa Sample"; Button b = new Button (); b.Left = 10; b.Top = 10; b.Text = "E&amp;xit"; b.Click += delegate(object s, EventArgs e) { f.Close(); } f.Controls.Add(b); Application.Run(f); } } you would use module Main where import Salsa import Salsa.System.Windows.Forms main :: IO () main = withCLR $ do f &lt;- new Form_ () set f [Text := "Saucy Salsa Sample"] b &lt;- new Button_ () set b [ Left :== 10 , Top :== 10 , Text := "E&amp;xit" , Click :+&gt; delegate EventHandler ( ! f # Close ()) ] get f Controls_ &gt;&gt;=# Add (b) Application_ # _Run (f) which is perhaps a bit noisier, but at least demonstrative that it can be shoehorned in. ;)
**Inference** &gt; Last I looked, Scala's type inference failed on the factorial function. Well, writing the factorial function ... that's what developers actually do 95% of their time when programming. Right? **Tail calls** Maybe I should have been a bit more precise and actually said "languages which actually care about interoperability with the host platform and other languages running on it". Sure, if you don't give a sh*t and throw the feature over board that the emitted bytecode should at least half-way resemble the written source code, then yes, the possibilities are of course endless. Please tell me then: If it is unnecessary that a platform provides tail calls because all languages can just easily do it themselves then why does the CLR come with support for tail calls?
&gt; Well, writing the factorial function ... that's what developers actually do 95% of their time when programming. Right? What function do developers spend 95% of their time writing? &gt; Please tell me then: If it is unnecessary that a platform provides tail calls because all languages can just easily do it themselves then why does the CLR come with support for tail calls? What features are necessary? 
Downvoted? Seriously? For people trying to put together a user's group, these are pretty handy.
Note that OCaml already combined HM with subtyping. 
Great Post. Fun thinking about it. Here is my solution: import scala.actors.Future import scala.actors.Futures._ def given[T](xs: Future[_]*)(f: =&gt; T): Future[T] = future { f } You can use it like that: scala&gt; lazy val a = future { Thread.sleep(5000); 6 } a: scala.actors.Future[Int] = &lt;lazy&gt; scala&gt; lazy val b = future { Thread.sleep(5000); 7 } b: scala.actors.Future[Int] = &lt;lazy&gt; scala&gt; lazy val c = given(a,b) { a() * b() } c: scala.actors.Future[Int] = &lt;lazy&gt; scala&gt; { | val t0 = System.currentTimeMillis | val result = c() | println("computing '" + result + "' took " + (System.currentTimeMillis - t0) + "ms") | } computing '42' took 5008ms 
"map" seems misleading, but I suppose I could warm up to it the same way I warmed up to Javascript's condition &amp;&amp; codeToExecute
Yes you can, but that seems to be not really idiomatic and of little interest if you want to do something with codeToExecute returned value. That's because codeToExecute HAVE to be of Boolean Type, and so, apart for the evil case with only side effects in it, you are really limited. An other interesting method, not show in the post, and which composed well (with interesting return types) is to use for comprehension: val myOptionnalRes : Option[RES] = for { someUser &lt;- optionnalUser //say Option[User] someInt &lt;- optionnalInt //say Option[Int] } yield { //here, we do have an user and an a int computeSomethingUsefullWith(someInt, someUser) //of type RES } And of course, for option there is the really good reference: http://blog.tmorris.net/scalaoption-cheat-sheet/ edit: code format
I'm not sure what goes on at these events, but I hope they post some videos up like the NEScala event thing that happened a few weeks ago
I don't think you need to worry. Last years presentations can be found [here](http://days2010.scala-lang.org/node/136).
&gt; Yes you can, but that seems to be not really idiomatic and of little interest if you want to do something with codeToExecute returned value. That's because codeToExecute HAVE to be of Boolean Type, and so, apart for the evil case with only side effects in it, you are really limited. He is talking about JavaScript. There `codeToExecute` does not have to have the boolean type.
This is an irrelevant statement. The sort of structural subtyping in OCaml is very different from the F-bounded polymorphism available in Scala.
&gt; This is a solved problem. It's not necessarily a solved problem in the context of the JVM. It's not obvious to me that the degree of Java interop offered by Clojure and Scala can be maintained with the trampolining approach of Kawa. Even if it can be, you still take a performance hit. &gt; Last I looked, Scala's type inference failed on the factorial function. So? Most Haskell developers put signatures on all top level functions and the compiler warns you if you don't (if you have -Wall on as you should). No one seems to complain about this. I can't say I spend more than 0.1% of my total programming and design time writing such things down. If anything, it saves time because it makes reading other people's code easier and it allows the compiler to give better type error messages. Having to write such signatures would not influence my choice of language whatsoever. And again, it's not as if it failed because it's bad. It "failed" because many of the type system features in Scala greatly complicate type inference -- it's undecidable in the general case. Rather than infer non-prinicipal types or other potentially confusing things, Scala requires signatures on function parameters. This seems like a reasonable compromise to me. I'd challenge you to do better given the features in Scala.
You say this as though it's easy. Inferring HM types in a language like Scala would mean inferring non-prinicipal types. It would also mean you'd lose things like subsumption in cases that would certainly require complex description regarding when you had "enough" type information in order to do it. Yes, F# infers more types. But it infers non-principal types according to an informal algorithmic description of the type system. Sure, Scala *could* do that with some effort, but it's not at all clear to me that it would be a good thing. I'd rather write more signatures and know that the system is always filling in the blanks with principal types and in a predictable manner. (I'm not suggesting Scala necessarily does this... but it should.)
For me, It gives MatchError in scala 2.8
Why do people take that referenced article by Cedric Beust seriously? It's complete bullshit -- argumentum ad ignorantiam -- is this not obvious or something?
&gt; You say this as though it's easy. I don't see why it has to be hard. In the simplest case, try to compile programs that fall in the intersection of Scala and SML using Damas-Milner and, if that fails, resort to using the Scala compiler and requiring type annotations. &gt; Inferring HM types in a language like Scala would mean inferring non-prinicipal types. Why? Can you not just bail when the inferred type might not be principal, requiring an annotation? &gt; But it infers non-principal types according to an informal algorithmic description of the type system. Can you give examples of what you mean? All I can think of is ad-hoc polymorphism resorting to `int` when it just saw `+`. &gt; I'd rather write more signatures and know that the system is always filling in the blanks with principal types and in a predictable manner. Yes. 
Odersky just said "subtyping", not "F-bounded polymorphism".
Right... but he wasn't talking about polymorphic variants or structurally-typed records. He was talking about subtyping with subsumption in the context of Scala. It's nice that OCaml has a (very) vaguely related feature, but it has no relevance to what Odersky is saying. The way you said it made it sound as if OCaml already solved the same problem.
&gt; Why? Can you not just bail when the inferred type might not be principal, requiring an annotation? This is the hard part. Knowing when the type the system has inferred is principal or not is very difficult. In the general case, it's probably impossible in the context of Scala. You'd have to carefully define a type system that infers HM types only when those types are also principal types. I have no idea how you'd go about doing this. &gt; Can you give examples of what you mean? All I can think of is ad-hoc polymorphism resorting to int when it just saw +. Sure. Here's an example that uses neither subtyping nor overloading. You'll notice that `f` has type `Foo[T] -&gt; Int` and `g` has type `Foo[T] -&gt; T`. Neither type is more general than the other, hence there is no principal type for this function (despite its simplicity): object scala { abstract class Foo[T] case class InFoo(i: Int) extends Foo[Int] def f[T](t: Foo[T]): Int = t match { case InFoo(i) =&gt; i } def g[T](t: Foo[T]): T = t match { case InFoo(i) =&gt; i } } If you tried typing this with Damas-Milner, you'd end up with the first type (`Foo[T] -&gt; Int`) even though it's not the "best" type for the function (as there isn't one).
Um... I don't think that's how the top menu works. 
&gt; He was talking about subtyping with subsumption in the context of Scala. He didn't mention "subsumption" either. &gt; It's nice that OCaml has a (very) vaguely related feature, but it has no relevance to what Odersky is saying. The, by the same logic, Odersky's statements also have no relevance to combining HM and subtyping because they also address only a specific case (assuming you retrospectively correct Odersky's generalization for him). I don't believe that either. 
&gt; It's not necessarily a solved problem in the context of the JVM. It's not obvious to me that the degree of Java interop offered by Clojure and Scala can be maintained with the trampolining approach of Kawa. Even if it can be, you still take a performance hit. There are certainly trade-offs but the statement "every language is missing tail calls on the Hotspot JVM" is not true. &gt; No one seems to complain about this. I have complained about that before. I even quantified the amount of code devoted to type annotations in major OCaml, SML and Haskell open source projects. &gt; I can't say I spend more than 0.1% of my total programming and design time writing such things down. Cluttered source code degrades readability and maintainability. I see type annotations as a source of clutter. &gt; it saves time because it makes reading other people's code easier I beg to differ. &gt; ...it allows the compiler to give better type error messages Only in the presence of advanced type systems. &gt; And again, it's not as if it failed because it's bad. It "failed" because many of the type system features in Scala greatly complicate type inference -- it's undecidable in the general case. Rather than infer non-prinicipal types or other potentially confusing things, Scala requires signatures on function parameters. This seems like a reasonable compromise to me. I'd challenge you to do better given the features in Scala. Exactly. I don't value the extra features of Scala's type system so I would not take them as a given. I think Scala is well into diminishing returns, an extremum among type systems of purely academic interest. Adding esoteric features at the expense of type inference is cutting your nose off to spite your face. 
&gt; He didn't mention "subsumption" either. Yes. Fine. However, Odersky's not stupid nor is he ill-informed. I'm sure he's well aware of how to do structurally-typed records. This is *very* basic stuff. Odersky was *clearly* talking about nominal subtyping and subsumption and I'm sure you know that. That is, after all, what people typically mean when talking about subtyping; it's what popular languages like Java do, it's what F&lt;: is all about, et cetera. OCaml does not do nominal subtyping. If you want to distinguish between nominal and structural subtyping, great. You *should* do this when making claims about subtyping in OCaml in the context of Scala. However, you didn't; that's misleading. Someone not terribly informed would read your comment and likely get the wrong impression that OCaml's system was somehow related to Scala's and that they had somehow solved the same problem. You must see that.
&gt; There are certainly trade-offs but the statement "every language is missing tail calls on the Hotspot JVM" is not true. Sure, and you were right to correct him on that. It's not a "solved problem" either though. Functional languages on the JVM would still benefit tremendously from tail call elimination. If I were implementing a functional language for the JVM, I'd be very reluctant to take the performance and operability hit necessary to do it via trampolines. The way to make it a truly "solved problem" on the JVM would be for the JVM to solve it by providing tail call elimination. &gt; I see type annotations as a source of clutter. That's your problem! &gt; Only in the presence of advanced type systems. This is not true. Type annotations allow type errors to be reported sooner and closer to the actual source of error in simple HM-style systems. I could easily give numerous examples of this. This is especially true in languages like Standard ML or Haskell where polymorphic signatures actually enforce polymorphism. (OCaml's type system, unfortunately, is not well-designed and fails to handle this.) &gt; I think Scala is well into diminishing returns, an extremum among type systems of purely academic interest. I don't think things like bounded polymorphism are of purely academic interest, but I do share your view that Scala's tradeoffs aren't the ones I personally would have chosen. That said, you'd be better off arguing against the fundamental design decisions you disagree with rather than the necessary outcome of those decisions. In other words, Scala's approach to inference is, in my opinion, the right choice given the rest of the system. If you want to debate the design tradeoffs of particular features that require more type signatures, go for it. Of course, that's not as easy.
You might have better luck asking on stackoverflow. Map works for what you want to do: user.map(_.getusername).getOrElse("Unknown User") 
No that was pretty much what I was looking for. For some reason I was thinking map had a Unit return type in this instance which would be kind of silly
&gt; The way to make it a truly "solved problem" on the JVM would be for the JVM to solve it by providing tail call elimination. If you must run on the JVM then you could still target OpenJDK and use Arnold Schwaighofer's implementation of TCO. &gt; This is not true. Type annotations allow type errors to be reported sooner and closer to the actual source of error in simple HM-style systems. I could easily give numerous examples of this. This is especially true in languages like Standard ML or Haskell where polymorphic signatures actually enforce polymorphism. (OCaml's type system, unfortunately, is not well-designed and fails to handle this.) Type annotations in SML are of marginal benefit and, I think, that benefit is outweighed by the degradation in readability. Obviously that is not true in Haskell but I see that as a design flaw. &gt; That said, you'd be better off arguing against the fundamental design decisions you disagree with rather than the necessary outcome of those decisions. In other words, Scala's approach to inference is, in my opinion, the right choice given the rest of the system. If you want to debate the design tradeoffs of particular features that require more type signatures, go for it. Of course, that's not as easy. I was trying to argue against the fundamental design decisions that have cost Scala type inference. I haven't seen anything to indicate that Scala's design decisions are at all preferable, largely because I find objects to be of limited use. 
How does it work?
you may have been thinking Option.foreach
The function you've discovered is the most fundamental function for the Option datatype. All other functions on option can be implemented in terms of this one. It's commonly called fold. def fold[A, B](a: Option[A], some: A =&gt; B, none: =&gt; B) = a match { case Some(a) =&gt; some(a) case None =&gt; none } Using the standard library alone, this is often expressed by chaining map and getOrElse. @dibblego has some [great posts](http://www.google.ch/search?sourceid=chrome&amp;ie=UTF-8&amp;q=tony+morris+option#sclient=psy&amp;hl=en&amp;q=option+site:blog.tmorris.net&amp;aq=f&amp;aqi=&amp;aql=&amp;oq=&amp;pbx=1&amp;fp=eadbe4ab0dad9d18) that explore this concept. It turns out that any this idea applies not just to Option, but to everything else too: Boolean, List, Either, TupleN, FunctionN can all be completely characterized with a suitable fold function. Runar touches on this concept in his recent talk [FP for Beginners](http://apocalisp.wordpress.com/2011/01/10/functional-programming-for-beginners) 
I have no idea how it works. The menu where I can select a subreddit is fucked up, too. It doesn't show all my selected subreddits but just a random selection of them. When I want to go to a specific one I sometimes have to type it in manually as it doesn't show up at the moment.
To expand a little: All algebraic datatypes can be expressed this way, in fact. It’s called [Church encoding](http://en.wikipedia.org/wiki/Church_encoding).
&gt; If you must run on the JVM then you could still target OpenJDK and use Arnold Schwaighofer's implementation of TCO. Sure, but you still take a performance hit for a portable implementation. Besides, [according to the OpenJDK project](http://openjdk.java.net/projects/mlvm/subprojects.html), it isn't ready for prime time anyway. &gt; Type annotations in SML are of marginal benefit and, I think, that benefit is outweighed by the degradation in readability. Obviously that is not true in Haskell but I see that as a design flaw. Except in very rare cases of ambiguity related to type classes or the monomorphism restriction, Haskell 98 requires no type signatures. Of course, type classes are there specifically to help solve problems with cluttered code via overloading; the end result is almost certainly less code overall. SML usually results in far more required signatures due to module signatures... unless you don't want any control over what you export. Haskell 98 can control module exports without a separate module signature. &gt; I was trying to argue against the fundamental design decisions that have cost Scala type inference. Heh, not that I've ever seen. Or at least not to that end. You were just saying that there's [no problem adding type inference in the presence of the current type system's features](http://www.reddit.com/r/scala/comments/fy4vk/if_you_could_reimplementchange_any_part_of_scala/c1jkdvq) before I corrected you. Oh well.
&gt; This is the hard part. Knowing when the type the system has inferred is principal or not is very difficult. In the general case, it's probably impossible in the context of Scala. You'd have to carefully define a type system that infers HM types only when those types are also principal types. I have no idea how you'd go about doing this. Or you make the programmer annotate the code as being ML/non-ML. &gt; &gt; &gt; Yes, F# infers more types. But it infers non-principal types according to an informal algorithmic description of the type system. &gt; &gt; Can you give examples of what you mean? All I can think of is ad-hoc polymorphism resorting to int when it just saw +. &gt; Sure. Here's an example that uses neither subtyping nor overloading. You'll notice that f has type Foo[T] -&gt; Int and g has type Foo[T] -&gt; T. Neither type is more general than the other, hence there is no principal type for this function (despite its simplicity): My Scala-fu isn't up to understanding your example. If `g` returns the `int` argument `i` of `InFoo` then surely it must return an `int` and not a `T`? However, for your example to make sense in this context we need a translation to F# where it infers a non-principal type but I do not see how F# can express this. 
&gt; Sure, but you still take a performance hit for a portable implementation. I'm not sure what performance hit you're referring to. Without TCO by the compiler the programmer will have to translate programs like state machines to using trampolines by hand, which is far more tedious and just as slow. If they don't bother then they'll just run very quickly into a stack overflow. &gt; Besides, according to the OpenJDK project, it isn't ready for prime time anyway. According to most of the reviews I've read, neither is Scala. &gt; Except in very rare cases of ambiguity related to type classes or the monomorphism restriction, Haskell 98 requires no type signatures. Of course, type classes are there specifically to help solve problems with cluttered code via overloading; the end result is almost certainly less code overall. &gt; SML usually results in far more required signatures due to module signatures... unless you don't want any control over what you export. Haskell 98 can control module exports without a separate module signature. Strawman argument. Real Haskell code has far more type annotations than real SML code not because they are required in theory but because they are required in practice to keep error messages comprehensible. &gt; Heh, not that I've ever seen. Or at least not to that end. You were just saying that there's no problem adding type inference in the presence of the current type system's features before I corrected you. Oh well. Are Scala's current type system's features required for Java interop? 
&gt; I'm not sure what performance hit you're referring to. Without TCO by the compiler the programmer will have to translate programs like state machines to using trampolines by hand, which is far more tedious and just as slow. If they don't bother then they'll just run very quickly into a stack overflow. Sure, but if the compiler translates *all* tail calls (as is required by languages like Scheme), you'll suffer a hit for cases where it isn't necessarily needed by the programmer. &gt; According to most of the reviews I've read, neither is Scala. Agreed completely. I had it explode on me just trying to write that example I posted elsewhere in this thread due to a failed assertion in the type checker. Pretty nasty. We've avoided its use at work for exactly these sorts of reasons. It really doesn't inspire confidence when you see those sort of failures in version 2.8.1 of a compiler. &gt; Strawman argument. Real Haskell code has far more type annotations than real SML code not because they are required in theory but because they are required in practice to keep error messages comprehensible. This really just depends on how you use it. If you use Haskell like it's ML, with just basic equality, ordering, and numeric constraints added in (SML already has equality), then you end up with basically the same error messages. Not to get into particular implementations, but it's actually probably easier to get by with few signatures in GHC due to the high quality of the error reporting. It's miles ahead of SML/NJ. MLton and OCaml seem to fall somewhere in the middle. &gt; Are Scala's current type system's features required for Java interop? Many are, yes. You can call Java directly with full type safety (or very close to it), hence you basically need a superset of Java's type system. There's no way to do inference for Java alone, and Scala adds a bunch of extensions on top of that.
&gt; Or you make the programmer annotate the code as being ML/non-ML. Maybe, but I'm skeptical that you could smoothly integrate something like that. It seems difficult to me and, due to the heavy use of existing Java libraries, likely not very useful anyway. &gt; My Scala-fu isn't up to understanding your example. If g returns the int argument i of InFoo then surely it must return an int and not a T? The thing to recognize here is that `T` *is* `Int` within the scope of that particular pattern match. When you pattern match in Scala, the compiler introduces a local type equality based on the types used in the case class declarations. There are just GADTs as you'd see in GHC (likely barring some details with respect to Scala that I don't know). The equivalent would be: {-# LANGUAGE GADTs #-} data Foo a where InFoo :: Int -&gt; Foo Int f :: Foo a -&gt; a f (InFoo i) = i g :: Foo a -&gt; Int g (InFoo i) = i As for F#, it does indeed likely not have a way to express this.
&gt; Odersky's not stupid nor is he ill-informed. I have had two discussions with Odersky before. In the first, Odersky stated on his Scala list that "OCaml gives you only monomorphic methods in classes". I didn't believe him so [I posted his quote to the OCaml list](https://groups.google.com/group/fa.caml/msg/8355f689c762a296?hl=en) asking for verification and [Jacques Garrigue explained that Odersky was wrong and that OCaml has had polymorphic methods in classes for 14 years](https://groups.google.com/group/fa.caml/msg/9be90506be7a752a?hl=en). In the second, [Odersky stated that ML was more verbose and convoluted than Scala at solving a specific problem and that functional programmers "didn't get" the importance of subclasses](http://scala-programming-language.1934581.n4.nabble.com/scala-usefulness-of-OOP-tp2000320p2000335.html). I replied with several concise OCaml solutions. Odersky failed to provide any Scala solutions. &gt; Odersky was clearly talking about nominal subtyping and subsumption and I'm sure you know that. All I know is what he actually wrote. &gt; However, you didn't; that's misleading. Someone not terribly informed would read your comment and likely get the wrong impression that OCaml's system was somehow related to Scala's and that they had somehow solved the same problem. You must see that. Why would someone assume that I was talking about Scala when it is not even capable of this? 
&gt; Maybe, but I'm skeptical that you could smoothly integrate something like that. It seems difficult to me and, due to the heavy use of existing Java libraries, likely not very useful anyway. That is similar to what F# does. Any constructs that might undermine inference cause it to bail and demand annotations. It is still very useful though because all the dense algorithmics go in the ML code, and the objects and explicit type annotations are just used for interop. And it is simple enough for noobs. &gt; There are just GADTs... Ah, ok. &gt; As for F#, it does indeed likely not have a way to express this. Then I don't understand. Wasn't this example supposed to be showing F# inferring non-principal types?! 
&gt; Sure, but if the compiler translates all tail calls (as is required by languages like Scheme), you'll suffer a hit for cases where it isn't necessarily needed by the programmer. Ok but how many non-looping calls in tail position are performance critical? &gt; This really just depends on how you use it. If you use Haskell like it's ML, with just basic equality, ordering, and numeric constraints added in (SML already has equality), then you end up with basically the same error messages. IO? &gt; Many are, yes. You can call Java directly with full type safety (or very close to it), hence you basically need a superset of Java's type system. There's no way to do inference for Java alone, and Scala adds a bunch of extensions on top of that. Is there any intrinsic complexity beyond what F# faced? 
&gt; Why would someone assume that I was talking about Scala when it is not even capable of this? So you're saying your statement only makes sense to people that already understand this aspect of OCaml? Then why even say it? I'm talking about people that don't know OCaml.
&gt; Then I don't understand. Wasn't this example supposed to be showing F# inferring non-principal types?! No, I misread. I thought you were asking for an example of why HM cannot be used to simply try to infer a principal type in Scala while falling back if it fails. For F#, an example is as follows: let f g x = g (g x) F# will infer the following type: val f : ('a -&gt; 'a) -&gt; 'a -&gt; 'a However, this works too: let f (g : obj -&gt; string) (x : obj) : string = g (g x) Neither `('a -&gt; 'a) -&gt; 'a -&gt; 'a` nor `(obj -&gt; string) -&gt; obj -&gt; string` is more general than the other, hence F# is happily inferring a non-principal type. Note that there is actually a principal type for this function: val f&lt;'a, 'b when 'b :&gt; 'a&gt; : ('a -&gt; 'b) -&gt; 'a -&gt; 'b Unfortunately, F# won't actually let you write this type signature. As such, not only does it infer a non-principal type, but there's also no way to help the system get the principal type. Scala can handle this example properly: def f[A, B &lt;: A] (g : A =&gt; B) (x : A) : B = { g(g(x)) } I should also point out that, while trying to test this, the F# interpreter harassed me quite a bit about needing to add type signatures due to the value restriction. For example, something as simple as `f (fun x -&gt; "hello")` was rejected. O'Caml has no problem typing the same expression. (If I got anything wrong above, someone please let me know. This is my first time using F# and, barring my previous example, my first using Scala as well.)
&gt; IO? What about it? IO doesn't require any type constraints. It's straight HM types all the way. &gt; Is there any intrinsic complexity beyond what F# faced? I'm not familiar enough with either Scala or F# to say much more than I already have. I don't believe Scala requires the explicit upcasting that F# sometimes requires at least.
&gt; &gt; Why would someone assume that I was talking about Scala when it is not even capable of this? &gt; So you're saying your statement only makes sense to people that already understand this aspect of OCaml? How did you get from my statement about Scala to your conclusion about OCaml? &gt; Then why even say it? I gave OCaml as an example of a language that does HM+subtypes because people might want to play with it and observe the phenomenon Odersky was referring to when he wrote "inferred types become impractically large". 
&gt; What about it? IO doesn't require any type constraints. It's straight HM types all the way. IO requires monads in Haskell so it isn't straight HM and, ISTR, GHC demanding type annotations around IO. In fact, not just IO but mutation too. Even my random number helper function won't compile without type annotations. &gt; I'm not familiar enough with either Scala or F# to say much more than I already have. I don't believe Scala requires the explicit upcasting that F# sometimes requires at least. Perhaps there is the potential for an F#-like language on the JVM but, until the JVM gets TCO, it seems like a waste of time. My guess is that the JVM will die before this happens anyway. Hopefully something better will rise up and take its place. 
&gt; IO requires monads in Haskell so it isn't straight HM Only because the operations over monads are generic. You can easily use IO-specific versions if you want: return :: a -&gt; IO a bind :: IO a -&gt; (a -&gt; IO b) -&gt; IO b &gt; and, ISTR, GHC demanding type annotations around IO. You remember incorrectly. Do you have an example? &gt; Even my random number helper function won't compile without type annotations. Only because you don't have to specify Random.int32 or Random.nativeint when you generate the number. Compared to O'Caml, the following is pretty clutter-free: take 10 $ randoms $ mkStdGen 0 :: [Int] [2092838931,-2143208520,2034827062,-1587933427,- 1272503422,316817438,2007066819,538180758 140827264,-182934444] You could, of course, write a non-generic version if you wanted and use that everywhere: &gt; let randomInt = randomIO :: IO Int &gt; x &lt;- randomInt &gt; y &lt;- randomInt &gt; (x, y) (1160947312,-1702915267) These aren't even issues of keeping error messages comprehensible. They're just overloading ambiguities little different than you have to deal with in F#. If anything, I think Haskell requires fewer signatures than F# due to automatic constraint propagation. For example, F# can't even handle extremely basic stuff like this: &gt; let f x = x == x error FS0332: Could not resolve the ambiguity inherent in the use of the operator '( == )' at or near this program point. Consider using type annotations to resolve the ambiguity. Yet Haskell is fine: &gt; let f x = x == x f :: Eq a =&gt; a -&gt; Bool
&gt; I gave OCaml as an example of a language that does HM+subtypes because people might want to play with it I don't believe you and I doubt anyone else does either. If that's what you meant, you could've said that while also clarifying that it is *not* nominal subtyping as in Scala. This is, after all, the Scala subreddit. Instead, what you wrote just made it sound as if O'Caml can infer subtypes and Scala can't. While that's narrowly true, it is, again, irrelevant. You might as well say that O'Caml can infer parametric polymorphism in a thread about Agda. Yes, it's true, but it's not helping anyone. If you actually want to educate or point people towards things that might interest them, you're doing a crap job. That's all I'm saying on this...
&gt; Compared to O'Caml, the following is pretty clutter-free: &gt; import System.Random &gt; take 10 $ randoms $ mkStdGen 0 :: [Int] **EDIT:** FTFY. Not really: Array.init 10 (fun _ -&gt; Random.int max_int) &gt; Only because the operations over monads are generic. You can easily use IO-specific versions if you want: &gt; You could, of course, write a non-generic version if you wanted and use that everywhere: Ok, so you have to remove all overloading and specialize the monads. &gt; F# can't even handle extremely basic stuff like this... Your F# code is wrong. Should have been: &gt; let f x = x=x;; val f : 'a -&gt; bool when 'a : equality which works fine, of course. 
First off, don't quote me while modifying what I wrote. That's pretty obnoxious. The O'Caml code is also not equivalent; it works via side-effects. The Haskell version initializes a new random number generator and creates a random number in isolation. Repeated evaluations will give you the same result. If you don't care about that, Haskell can be shorter still: replicateM 10 randomIO Keep in mind that, again, the Haskell version is generic and the O'Caml version is not. You only need the signature if you're writing generic code that's not even possible in O'Caml. If the type is locally known, you don't need it. For example, no signature needed: replicateM 10 randomIO &gt;&gt;= return . map (+ 1.0) Regardless, the Random stuff is probably a worst-case for Haskell 98, and the end result is still comparable if not shorter than O'Caml while offering greater generic capability. I may've overstated things slightly before but I still don't see this as any sort of major issue worth complaining about. &gt; Ok, so you have to remove all overloading and specialize the monads. They're specialized automatically when you're doing IO. Random number generation is a rather special case in Haskell due to the interface provided in Haskell 98. You don't run into the same issues with IO. For example: main = do name &lt;- getLine putStrLn ("Hello, " ++ name ++ "!") &gt; Your F# code is wrong Quite a lousy error message then. In Haskell, I'd at least be able to see the constraint that was ambiguous so I'd know I was on the wrong track. Of course, F# inherits that brain-dead approach to overloading from C#. If you want a different example, F# can't handle this basic expression: &gt; List.map id error FS0030: Value restriction. The value 'it' has been inferred to have generic type val it : ('_a list -&gt; '_a list) Either make the arguments to 'it' explicit or, if you do not intend for it to be generic, add a type annotation. This has all gone on way too long. Enough from me.
&gt; First off, don't quote me while modifying what I wrote. That's pretty obnoxious. Did you seriously expect me to let you draw a fake comparison between my complete OCaml code and your incomplete Haskell code? &gt; If you don't care about that, Haskell can be shorter still: &gt; replicateM 10 randomIO Please write complete working Haskell code: import System.Random import Control.Monad replicateM 10 randomIO Your code is clearly even longer when complete. &gt; the Haskell version is generic and the O'Caml version is not Which is a bad thing. So, in practice, you write `.int` in OCaml and `:: IO [Int]` in Haskell. &gt; You only need the signature if you're writing generic code that's not even possible in O'Caml. If the type is locally known, you don't need it. For example, no signature needed: A risk Haskell programmers don't take in practice because it leads to unmaintainable code. So this is just another non-advantage of purely academic interest. Similar phenomena appear in both OCaml and F#. In OCaml, the `Marshal` module returns polymorphic values of a specific concrete type so you annotate with that type *immediately* to avoid confusing error messages and bugs later in the code. In F#, interop can often lead to dynamically typed values so you unbox them and, again, annotate the type immediately. In both cases, the *only* reason you annotate immediately is to keep your code maintainable. The ability to write bad code is **not** an advantage of the language. &gt; Regardless, the Random stuff is probably a worst-case for Haskell 98, and the end result is still comparable if not shorter than O'Caml while offering greater generic capability. The partial code is shorter but the complete code is longer and the "greater generic capability" offers no practical benefit. In reality, this is just another example of Haskell making it hard to solve easy problems: another academic curiosity and a complete waste of time. I see no merit in trying to pretend otherwise. &gt; Random number generation is a rather special case in Haskell due to the interface provided in Haskell 98. You don't run into the same issues with IO. For example: &gt; main = do &gt; name &lt;- getLine &gt; putStrLn ("Hello, " ++ name ++ "!") Only if you avoid the generic functions like `read` and `print` for the ML-like `getLine` and `putStrLn` ones. Which is what real Haskell code seems to do precisely because this was another failed experiment that has been baked into the stdlib. &gt; Quite a lousy error message then. Compared to GHCi's `parse error`? No. &gt; Of course, F# inherits that brain-dead approach to overloading from C#. Pragmatic vs languishing in academic obscurity. 
&gt; I don't believe you and I doubt anyone else does either. If that's what you meant, you could've said that while also clarifying that it is not nominal subtyping as in Scala. This is, after all, the Scala subreddit. Again, structural vs nominal is completely irrelevant in the context of Odersky's statement about inferring subtypes in general. &gt; what you wrote just made it sound as if O'Caml can infer subtypes and Scala can't Which is true. &gt; You might as well say that O'Caml can infer parametric polymorphism in a thread about Agda. Yes, it's true, but it's not helping anyone. A strawman argument. I responded to a statement about HM+subtypes with a relevant fact. &gt; That's all I'm saying on this... Probably for the best. 
Are there any slides anywhere for this?
There are some screen shots of TalkingPuffin at TalkingPuffin.org, but this talk didn’t use slides. The source code is on github.
I'm in two minds about IDEs They're great for managing wieldy projects (unparalleled refactoring/search facilities being a major bonus) and there are a lot of features like in built debuggers and so on But the flipside is they're absolutely fucking huge bloaty clouds of woe that will gobble up most of your memory for breakfast, especially when you're just using them on small projects or one off scripts. I use a 2007 edition Macbook with 2GB of RAM, the time it takes IntelliJ to load is an absolute joke and working with it is like running though a vat of treacle, slowly, cumbersome and generally very sticky. The same thing can be said about Eclipse and Netbeans. This isn't really the fault of the IDE developers - I should be upgrading my laptop soon to meet the demands of todays applications, but the whole experience leaves a bitter taste in my mouth (and eating too much treacle will make you sick) So I've stuck with Vim for most things, nice and lightweight, fairly quick but it does have its pitfalls at the same time. I wish there was a middleground. Some of the features of the IDE but stripped down enough to be fast like VIM but more usable 
This is the major drawback for Scala right now. Looks like the Scala team had overtaken the development of Eclipse IDE for scala so hopefully there is a bit of light at the end of the tunnel. 
Intellij is great for Scala - but until they fix this bug: http://youtrack.jetbrains.net/issue/SCL-2753 ... I'd stick to 10.0.0.1 and not the most recent version. (For non-trivial projects, at least)
Anyone knows if it is possible to do joint compilation of Java + Scala + Groovy in a single module in IDEA?
Oh, dear.
a comment in that blog post point out that changing heap size won't help with PermGen problems and helpfully gives the proper JVM flag for that: -XX:+CMSClassUnloadingEnabled -XX:MaxPermSize=256m sbt is not simple but I've been using it for years and greatly prefer it over Ant and Maven for scala projects.
There appears to be a recent trend to use reddit-&gt;scala to create a lot of FUD, i don't know what is the value of submitting this link, for example. There is other similar ones (e.g. "After X years I'm finally giving up with Scala"), interestingly coming from people actually using other languages like Clojure. It starts to get on the nerves.
SBT could definitely benefit from a real homepage with information about how to use it. A Google Code project site with a GitHub repo for the code that has downloads for with what seem to be much more recent versions only confuses new users like this guy. What you want is the latest stable download from the Google Code site. 0.7.4 Then following the steps at: http://code.google.com/p/simple-build-tool/wiki/Setup
The reviewer insists on using the bleeding edge of SBT and then feaks out. The current version is 0.7.4 it is rock solid and definitely the simplest distributed build system i have used.
I Didn't even knew it existed. Maybe it needs to get a minimum amount of people that uses it to take off...
Because the Maven repository pattern exists and lets you keep all your individual projects decoupled from whatever happens to be in your Scala installation today.
I suppose it's the same with Ruby. You can use scala for a full blown application or for scripting. For scripting maybe it's more useful something like sbaz
Congratulations!
I recently contacted the main author(Michael Pradel) and got a copy of the roles library developed in conjunction with this paper. Original code and a couple of related papers are [here](http://mp.binaervarianz.de/scala_roles/). Code updated to work with scala 2.8 is [here](https://github.com/tupshin/Scala-Roles).
LIKE A BOSS
Excellent. This also means we are closer to better functioning Eclipse support. From what I remember of from an interview with Martin, a new version of the Eclipse plugin would be available when 2.9 was and that it would be much improved.
It's already here: https://www.assembla.com/wiki/show/scala-ide/Features
Thanks. I am surprised it wasn't on the scala-ide downloads page even though it is an experimental release. Downloading now...
Any impressions of it? I currently use nightly-update-wip-exp-backport-2.8.1.final (groan) and it doesn't even do code completion.
nightly does code completion for me. Also, Odersky said the revamped Eclipse plugin for 2.9 will most likely be released on Monday. [source]( https://groups.google.com/d/msg/scala-language/QFAgsM6rzyk/7xGYSCk6-74J)
Sorry, but I use IntelliJ most of the time, and I'm very happy with the support there.
Does this mean 'Programming in Scala 3rd edition' will be coming out with reference to the 2.9 features?
Just having a little play with the REPL now. Loving the :type command and the REPL seems a lot more responsive with autocompletion too I think the deprecation of the 'exit' command is a bit silly though. They should have just taken it out and forced you to use :quit instead of a silly deprecation message 
Great, thanks!
Very useful, but needs an rss/atom feed.
Functioning auto complete, HooRAH. None of my for loops of the form &gt;for (i &lt;- 1 until 40) { } seem to be working though. EDIT: Changing them to for (i &lt;- 2 *to* 40) { } made it work.
Does it work because of the different number of because of to vs. until?
Changing it to "to" is what did it.
This talk was pretty interesting, but it's all Riak; there's basically nothing about Scala other then to say that they're using Scala at Yammer for the "hard parts" of their applications.
nice stuff, but god I fucking hate that thing. I wasted a lot of time analysing the properties of the sierpinsky gasket for my math professor, time I will never get back
I agree that the whole Google Code thing is a bit of a mess, but on a whole I think he's being a little naive/unfair. SBT uses Scala 2.7.7 in its internals but you can specify what version you want to use for building your applications
nice!
This looks deceptively simple. I'm still reading for the catch. Great documentation!
Autocomplete is still just as broken as always for me. You're using wip_experiment and not wip-exp-backport right?
Correct, I'm using win_experiment
I'm quite surprised to hear this. I had a phone interview with The Guardian a few months ago, needless to say I screwed it up but that was my fault entirely (I'm useless with phone interviews) but from what they were telling me, using Scala was just an experimental thing for new small scale stuff. I'm pleased to see they've decided to change their entire codebase to Scala, what I'm interested in though is how realistic is that aim. The interview with InfoQ suggests they're converting 100,000 lines of Java over to Scala - which from a developers perspective is great news. Not sure that upper management will see it that way though!
100,000 lines of code either isn't really a monster codebase (actually, it's pretty easily maintainable by a single dev), but that's neither here nor there. I've been steadily looking into making a conversion of an inherited PHP codebase (gah!), and moving it to Scala. For my boss (who's seen a revolving door of developers stepping into projects and rewriting them), he's a little wary. Scala has to be a 'slam dunk' (his words).
I've been using it for about a week. Much better than the old scala IDE. No crashes!
Is there a 'scala in industry' site somewhere, available as ammunition against sceptical management? [cufp](http://cufp.org/) is great but focuses on their conference. I was thinking more of something that says **global corp use scala! So do mega inc!** [Edit] Duh, I suppose that would be http://www.scala-lang.org/node/1658 . And it's a better list than mine :-)
A setting like "#primary { color: #EEEEEE;}" would improve readability. Edit: Sorry if someone here didn't like it, but apparently the author did. I just basically wanted to read the article.
Nice. Another got example of how scalable/versatile Scala is. As you're using Scala rather than an extra templating engine, you'll get syntax highlighting for free; anything templating logic in your template is statically typed. Completely useless for generating anything which isn't xhtml, such as JSON. But even then, you can revert back to just """, or even wrap a triple-quote string in a method which allows you have scala literals within a string. (but you'd lose free syntax highlighting etc.) 
langpop.com
langpop.com
These seem much more realistic.
Wish I could go. Ticket price is awesome, but I just don't know if I can afford the travel expenses. :(
Just when I thought I was getting scala down I read this and have no clue wtf is going on :(
No, please don't do that.
I wish they'd just put the second edition online ... I'd be a bit surprised if doing so had a serious impact on sales, and the 2.8 coverage in the second edition is key.
Yeah it's a bit odd that they're releasing a book which ( i think? ) was written for Scala 2.7 when the latest version is 2.8 and 2.9 is in its ascendancy To be fair though, I paid £43 for a copy of the 2nd edition about a month ago so I'd be pretty pissed if they released that for free today!
Even so, releasing the first edition is a good gesture. It's a good book and even if it doesn't cover 2.8, it can teach you a lot about Scala.
I bought both the first and the second edition ... and I wouldn't care if they released it online for free. Having it printed is a benefit in itself which I'm willing to pay for.
This right here is the money shot for continuations: while (conn.isOpen) { conn.writeLine(conn.readLine) } 
null? in scala? blasphemy
How well does it work with Vim...I see it has 'integration'.... anyone?
I'm using SBT, which is great because of * IntelliJ IDEA integration * continuous code compilation (it auto-recompiles any files you modify, zero locking issues) * great build script design (it's a valid scala class!) * great extensibility * excellent dependency management (just drop the sbt jar in your project, run it and it can even auto-get the scala compiler jars for you!) * etc.
Weird, not showing up in /r/scala.
Ouch, that's devious. And an unfortunate trade-off for Scala's flexible syntax.
As the person who commented that post explained, it's not really a flaw, but a feature. &gt; I think that's a feature of scala, having the namespace and syntax of defs and vals the same, so you can start with a val, and without changing any of the client code, transform it into a function that calculates what you need. Or maybe, like your case, start with a def and decide it can be optimized by calculating it only once, turning it into a val.
This is covered in [Programming in Scala](http://www.artima.com/pins1ed/composition-and-inheritance.html#10.2) &gt;The two pairs of definitions are completely equivalent from a client's point of view. The only difference is that field accesses might be slightly faster than method invocations, because the field values are pre-computed when the class is initialized, instead of being computed on each method call. On the other hand, the fields require extra memory space in each Element object. So it depends on the usage profile of a class whether an attribute is better represented as a field or method, and that usage profile might change over time. The point is that clients of the Element class should not be affected when its internal implementation changes. So like SeriousWorm &amp; the comment on that site said, it can be a useful feature.
It's almost impossible to tell without more context, but your error is indicating that next.neighbors is defined as type List[String], but entries.distinct() is returning something different. Is entries.distinct() a method, and if so, is it defined with an explicit type? If so, what is it?
It seems that *distinct* was introduced in Scala 2.8. You should really upgrade. Also, consider whether it would be more natural to copy into a Set instead of a List - Sets by their nature don't contain duplicates.
In 2.7.7, I the method you want is "removeDuplicates".
Thanks. I thought it might be a version issue, but this is part of an assignment and the class, for clarity, doesn't update its version in the middle of the academic year.
Can't upgrade, no stable package usable in Ubuntu yet.
Just download the tar.gz, unpack it, put it somewhere in $PATH and run it from there.
IIRC, "Perky 'Canada' has Own Government, Laws"
"in the middle"? 2.7.7 was ages ago already ...
But it was after September, and before May.
great blog entry!
Shouldn't this be posted in r/marketing instead? Sure seems like they are over-selling the language feature "type safety".
First I thought another troll article, but actually it seems the author likes what he saw.
This is huge. Maybe the most important merger in a post Sun-world.
Care to elaborate on 'overselling' ? Also, you really think the announcement of a new company that provides commercial support+development for Scala and Akka by their respective creators doesn't deserve to be posted in the rather low traffic Scala subreddit?
Wasn't trying to offend, the r/marketing thing was a joke. Of course r/scala is the place to post scala related stuff. And of course anyone who subscribes to r/scala is allowed their input, right? RE: Overselling How is this a really a "stack"? It's basically just Akka (which I'll have to look at, never heard of it but it sounds interesting). It's like saying "Tomcat" is a stack, and hey, it too supports modules written in Java, Scala, and any other JVM-based language. Don't get me wrong, I'm not against these guys making money by packaging their open-source stuff as a "stack" and marketing a subscription to for enterprises. I'm just saying this post is more about marketing than it is about technology. I also found the name "TypeSafe" a bit odd, promoting a language feature as a main selling point. Regardless, just comments off the top of my head, not meant to be flame-bait. If they spark a fun conversation, cool, if not, no prob. 
Wow, way to set me up. Start with a snarky comment then come back with a reasonable reply. Geez. Thanks a lot. :)
Ha. Sorry. Yeah maybe the original sounded dickish. Have a good weekend. 
Intro to actors in Scala. Interleaves code, result of running, and explanations. Uses the play "Waiting for Godot" to draw parallels to actor mechanisms. Sequel at http://dearjunior.blogspot.com/2011/05/vladimir-galore-lots-of-threaded-scala.html
Why wasn't this called 2.9.1 ? Seems like it just makes life more difficult for the maven people. 
Already using it and loving it. Anyone know if there's going to be a Scala 2.9-compatible lift 2.3, or is that only going to be the Lift 2.4 series? In other words, I suppose, should I be planning to stick to Scala 2.8.1 for Lift 2.3 development?
Based on some version numbering schemes I've seen around, I would *expect* that what was originally released as Scala 2.9.0 could be considered as being version 2.9.0.0, but there's normally no reason to express that fourth place. I'd then expect that 2.9.0.1 is intended as essentially a re-cut of the 2.9.0 release with only critical bugs fixed and complete interface compatibility, which should entirely supersede 2.9.0.0 such that nobody would have a reason to stay on that original release. I'd also hope that referring to version "2.9.0" in Maven would automatically end up referring to the re-cut, with no extra pain for users. That said, I'm not actually intimately familiar with Scala's version numbering, so take this with a grain of salt!
Caveat! I'm a developer who spent a solid 15 years writing in imperative and object-oriented languages. I can move from C to PHP to Java to Python to Perl with comparative ease (with the occasional "oh shit you can't do that in XXX language" moment). I'll confess that functional languages have quite a few concepts that will bedevil even the most talented imperative/oo developers. Sure, I can (and frequently do) write Scala that is indistinguishable from my Java. Is this a personal/professional failing? Absolutely so. It's also what I'm most comfortable in. For somebody who's spent a year of two developing in Scala (or Haskell, or any of the more functional languages), something like foldLeft or flatMap is a piece of cake. For me, it required a pretty considerable investment (about a week) in trying to build out various hello world/example apps, working my way up from various list and tree structures until I was happy with my level of mastery. While I'll immediately agree with gerard_ that any sufficiently smart developer can tackle most anything (Win32 threads might kick a lot of devs asses, however), you need to ask yourself if you don't mind somebody learning on the job, and ask yourself how long you're willing to give her/him to do it. 
The thing is that I do not hire. I have a gig coming up in august, which I want to be prepared for. Because it is quite an opportunity for me to get out of the automation nightmare I have been working on for two years. When I read manuals, I usually imprint knowledge by collecting a list of questions for myself, with which I may later repeat the important and tricky stuff. I have done so with Scala too, but an outside perspective would be really wonderful as a crash course. Even as I find my current knowledge of concepts in func. programming quite adequate for the job, it is always good to impress the employer with some extra skills or just by not fucking up where others do.
I don't want to be unpleasant, and I appreciate your work. But I can't help but think DI is in general a bad idea (values come from "nowhere", it breaks code navigation and refactoring, you have no fine control on the scope of a binding). Scala has incredible scoping mechanisms builtin already (basically first-class modules and functors) and I think this is sufficient to simulate every DI use case.
When we are hiring scala developers we look for those that know languages other than Java/C#. Knowing those is fine, but you should know something that stretches the brain in other directions as well. If a developer knows Ruby, advanced Javascript, Python or Haskell it shows they can pick up new concepts. If you are looking for scala specifics, that depends. You might need someone that knows Akka, or someone that understands some scala patterns like for comprehensions or good use of traits. Personally, I really love option and would ask questions about that.
What new features of 2.9 do you enjoy? (Besides .par, which I am looking forward to trying out)
I've got a project I'm using a lot of Java in, too, so the improved interoperability is nice. But yeah, mostly parallel collections. To be honest, I don't really have a good reason to use them right now—I just feel warm and fuzzy playing around with them!
FizzBuzz
Nice link.... http://blog.dhananjaynene.com/2011/05/why-java-folks-should-look-forward-to-scala/?utm_source=feedburner&amp;utm_medium=feed&amp;utm_campaign=Feed%3A+var%2Flog%2Fmind+%28%2Fvar%2Flog%2Fmind%29&amp;utm_content=Google+Reader WTF?
I agree with most of you points, In fact this project is not a DI but a Service Locator, I renamed the project: http://github.com/aloiscochard/sindi Due to the way Sindi is build you don't loose FP and type system power of Scala, This IoC container give you the functionality to have a global repository for all your module binding configuration.
Link seems to be pointing on some audio processing software...
Odd. It goes to a playlist for me, in which the first entry is: http://www.youtube.com/watch?v=TD5ETsyNZj0&amp;list=PL86C44DA20A52A35D
This is so NOT the slick way. See the comments: myOpt.map(_.toString.reverse.mkString("-")).getOrElse("unknown") Ugh.
Neat. It would be wonderful to have an LLVM compiler for scala. But mainly for new projects I would imagine - all my existing scala code is so intimately tied to the java API and java libraries that it would be no easy task to port any of it to a native platform shorn of JDK and java libs. But, it would certainly be good to be able to dick about on iOS with something like this. I wonder how it would be integrated with the various objective C apis?
&gt; A notable difference between the primitive sizes we have chosen and the other targets for Scala is that we define characters to be 32 bits. We have made this choice so that each Unicode code point can be represented by a single character value. This may also ease interoperability with C libraries on systems where wchar t is 32 bits. The total effect of this change is not yet well understood. **Please** Could people who obviously never even touched an Unicode book stop jumping to silly assumptions without any thought? Understanding Unicode is a significant investment and very hard to do right, especially when people don't even plan to invest some effort.
Disclosure: I'm the author of the linked paper What's inaccurate in what I wrote? I have indeed read portions of the Unicode standard and feel I have a fairly good understanding of it. It believe it is well known that incorrect handling of surrogate pairs in Java programs (i.e. the programmer assumes that Character &lt;=&gt; code point) has caused bugs. To quote the Unicode standard: &gt; UTF-32 has a one-to-one relationship between encoded character and code unit; it is a fixed-width character encoding form. This makes UTF-32 an ideal form for APIs that pass single character values. [...] &gt; Preferred Usage. UTF-32 may be a preferred encoding form where memory or disk storage space for characters is not a particular concern, but where fixed-width, single code unit access to characters is desired. UTF-32 is also a preferred encoding form for processing characters on most Unix platforms. 
The whole notion of code points is totally broken, because 99,9% of the developers have no idea what it really means and how it affects their application. If you provide public APIs working with codepoints, you're doing it wrong. (Yes, most programming languages do it wrong.) Working with codepoints basically means offloading the library designer's work to the individual developer, who doesn't even know what he's supposed to do. The whole notion of "String" as a glorified "Array[Char]" wrapper is so painfully wrong, born out of language designers who have neither time nor interest doing it right. I don't want to speak bad about language designers, it is just the problem that the combination of "deep compiler knowledge" + "typesystem expert" + "good taste" + "experience building APIs" + "good coder" + "knows relevant standards" occurs extremely seldom in the human population. Sorry, I'm just a bit frustrated that we live in the 21st century and we still fail at doing anything sensible with things like Text, Date&amp;Time, Numbers. We really need a String API which deals with grapheme clusters correctly (and not jokes like java.text). This means saying goodby to things like O(1) indexed access or a known fixed length for "characters". This means storing locale information for every String somewhere (or assuming some standard). This means specifying not only the internal storage format (UTF-8) to which everything is converted, but also a normalization format. If someone doesn't want to do this work, he/she should at least stop naming it "String". But thanks for your incredibly useful work with Scala LLVM! (I know that most things regarding Unicode are not your fault, but yuo have to track the things Java/the JVM does.)
I pretty much agree with you on all these points. I think most programmers think one character = one glyph on the screen. Making characters 32-bit doesn't solve this but at least you can't corrupt a string any more by breaking a pair or something like that. On the other hand I think that String as a sequence of code points is correct because at some times and for some applications this is exactly what is needed. I do agree that often this is the wrong level of abstraction for many applications. The most basic problem I think of is that conversion between upper and lower case cannot be done at the code-point level. It would be great to have some higher level abstraction for text but I'm not sure what that should look like. For what it's worth I'm using ICU behind the scenes for strings in Scala+LLVM so it could be possible to build a good abstraction on top of that.
Yes, mabye you are right and "String" is just too much polluted with that meaning already ... (Is "Text" better?) What I personally found interesting was that in Perl 6, you can choose at the top of the file if you want to work with Strings on the "byte", "codepoint" or "grapheme" level. That seems to be a good solution for dynamic languages. Python 3 (while the Unicode support isn't that good) at least separated the meaning, by having "bytes" (used for pass-through, where the semantic content is not interesting) and and string where they support (a bit of) Unicode. Using ICU doesn't guarantee success (see PHP6), but a great choice otherwise. Just wondering, is there anything where you could need help? I see that you have to rewrite quite some amount of Java classes in Scala ... Thanks for all your work! *PS:* Could you elaborate a bit more about what is the exact scope of your project? Being able to run existing Scala source code unchanged on the LLVM? Being able to run Scala's .class files on the LLVM? Having a similar API/the same API? Porting just the language to another runtime? Scala as a close-to-hardware replacement for C++/D/Go?
"According to Google's tests (PDF), C++ offers the fastest runtime of the four languages" No shit. And Scala runs on the JVM so I don't know why that is relevant. 
What's your plan regarding garbage collection? While I think using mmtk could save some work, I could imagine that it would make more sense to have some more idiomatic Scala approach instead of following the JVMS religiously. (Just like Scala fixes Java-the-language, could the Scala LLVM memory model fix some of the Java memory model flaws?) It would be really nice if Scala-LLVM could evolve to a testbed for future features, especially those who need VM support. The whole concurrency-stuff comes to my kind (co-routines, cheaper threads, ...) and tail call optimization.
Another Reddit post: http://www.reddit.com/r/programming/comments/hqkwk/google_paper_comparing_performance_of_c_java/
I can confirm that it does indeed go to a Youtube playlist containing all the five parts of Alexandre talk.
I'm guessing it's due to boxing. As far as I know, Scala does not yet specialize Seq for primitive types yet, so when you bigArray.sorted maybe have to unbox and box for each comparison. Whereas arrays on the JVM are treated differently and shouldn't have to deal with boxing. See [Martin's comment](http://www.scala-lang.org/node/7285#comment-29974) regarding the future of specialization on Scala collections. One way to confirm/disprove this is to run the code in a profiler (jvisualvm and hprof probably come with your JDK), and see if it spends significant time in boxing methods. You should also run both methods many times initially to warm up the JVM first. It is a little unfair that you call linearSearch2 last, so it potentially has a more warmed up JVM to work with. Of course you're right, it's hard to compare since you're comparing apples to oranges: in linearSearch you use Seq#sorted (which calls java.util.Arrays.sort underneath), whereas in linearSearch2 you use Sorting.quickSort, which is implemented separately in the Scala library. 
The objective is to build an implementation of Scala for another runtime environment; one that gets compiled to native code (like C++, D and Go that you mentioned). My goal is not necessarily to run existing Scala source code. I don't want to reproduce the Java APIs that would be required for that. Besides possible legal issues, it's just too much and isn't the best job. I might consider building a source code translation tool at some point like is being done with the .Net backend. I would like to see Scala grow a standard library that can be used to write programs portable between backends. For garbage collection I will probably write a simplistic mark-sweep collector in C at first. If I adopt the collectors in MMTK it would probably be by building the capability to write the collector in scala and porting the source of MMTK to scala. I will also try to implement a foreign function interface pretty soon to eliminate the awkward dance between scala and C that I have right now. The website for the project is http://greedy.github.com/scala/ which has some more information like links to a google group for the project and information on contributing. If you, or anyone else, has the time and interest it'd be great if you would contribute. Even something like providing a scala program you'd like to be able to run natively using LLVM would be helpful. One of my goals is for Scala+LLVM to be a platform for experimenting with language implementation approaches, so it would really make a lot of sense for it to be a testbed for future language features. Though any such feature would have to have a way to implement it on the JVM as well. Tail call optimization should be easy to implement since LLVM has built-in support for it. The only reason it's not done now is because of the way exceptions are being handled.
Ok, sounds cool! So there would be a chance to have some decent libraries (String, File, Date&amp;Time, URL, ...) instead of the broken things Java ships with? Do you have a list of Java classes which are minimally required to rewrite to get a decent portion of the standard library running? BTW, is this serious work where you look for people to contribute or is this just to get the university degree and move on? 
Array[T] isn't a collection class, it is just Java's T[]. It should be a bit better in 2.9 though.
This article is exactly what I needed right now. Thanks for sharing. Also, in section 6.2 &gt; support precise precise garbage collection
try **.**profile
Try `echo $PATH`. See if the folder you're looking for is in there. Next, as far as bash goes, try putting it the path in your ~/.bashrc. Aaannd.... what happens when you try to execute it directly? As in, open a terminal, and `./Applications/scala-2.9.0.1/bin/scala - that works with no problem, right? And, are you saying your user name has a space in it? Put the value in quotes. 
OS X uses a slightly different system for setting shell vars. You need to navigate to ~/.MacOSX/ and edit the file environment.plist. From here you can also a SCALA_HOME var. Save the file after you make the changes and then logout and login.
make sure you also add the `bin` folder to your `PATH` variable: $ more ~/.bash_profile export SCALA_HOME=/Users/xxx/Documents/devel/scala-2.9.0.final export PATH=$PATH:~/bin:${SCALA_HOME}/bin ...
In my .bash_profile, I have these lines: export SCALA_HOME=/opt/scala export PATH=$SCALA_HOME/bin:$PATH /opt/scala is actually a symlink to /opt/scala-2.9.0.1 You only need to edit ~/.MacOSX/environment.plist if you need those variables visible from GUI apps. Do you really have an Applications directory in your home directory? 
Try Homebrew http://mxcl.github.com/homebrew/ You can install with "sudo brew scala"
Woot, this worked, thanks. I just used scala-2.9.0.1 instead of scala. Not sure what a symlink is... No my Applications folder is not in my home directory, I've just never edited the path variable before and am clueless.
Wish I could have been there. Oh well, at least there will be videos.
Bookmarked.
That would be awesome. When I learned about Erlang and the actor model, I was disappointed that it wasn't more like the Oz concept of dataflow. 
(Ir?)relevant: [Ozma](http://www.youtube.com/watch?v=g7OszilM5Y4) &lt;--- Beware Noisy
also an awesome Melvins album.
How does it compare with Akka dataflow ?
I don't know Akka dataflow. However, as far as I understand, these are apples and pears, because Ozma provides a compiler backend to generate class files for the Mozart virtual machine/ runtime instead of the JVM. Other than Akka which is (apart from STM weaving?) really a library and doesn't change the language, Ozma adds new primitives (thread) to the language and re-defines others, so you get the dataflow functionality with a "normal" val or var, you don't have clutter on the user-side. I'm not sure about the reasoning of the project, though. The argumentation is that Oz has little adoption because of its syntax, and that's why using Scala syntax would draw attention to a larger audience. For me, personally, loosing the JVM and switching tool support for some Emacs integration is a bigger concession than having "more familiar" syntax. Not sure if Ozma brings static typing to Oz which might be one of the most interesting gains? I think it's a really interesting project because it's kind of a hybrid thing, and it tries something new with the scala compiler, emitting byte codes for another runtime. I think it proves that the modularity of nsc, its plug-in interface etc., were really a smart construction. 
Neep—was this supposed to be a link to [an article](http://thegreylensmansview.blogspot.com/2011/06/making-scala-scalable.html)?
Yeah. Not sure what happened... Tnx
This link work :] That in title shows me this - http://imgur.com/qn65G
I'm guessing this wasn't supposed to be a self post... 
The funny thing is if you follow the link, it goes to the correct video, so it looks like reddit's video-scraper is guessing wrong.
Glorious! 
Wow, I guess I can't reddit very well. [This](http://www.earldouglas.com/asynchronous-io-with-scala-continuations) is the intended link.
With type aware optimizations such as deforestation, Scala code could be faster for the an algorithm expressed the same way than in C++.
A symbolic link is similar to a shortcut. you create a symbolic link with ln -s file linkame in his case it would be ln -s /opt/scala-2.9.0.1 /opt/scala the you can access the file /opt/scala points through /opt/scala .
I'm currently learning Scala and blogging as I learn new stuff. I would love to hear some more experienced community members comments on my post. Is it accurate and if not, what am I missing?
Neat! Here, have a Generic Quicksort in [Hungarian Folk Dance](http://www.youtube.com/watch?v=ywWBy6J5gz8).
So... what languages are more scalable?
I thought everyone already decided that Google paper kinda sucked? The java version wasn't heavily optimized and the scala Pro version apparently used a different (asymptotically) faster algorithm.
P.S. It's called subcut as in "subcutaneous injection". I'm reading in Programming in Scala (2ed) that this kind of framework is not necessary because of the power of scala. Is that true?
Anyone have any experience using this?
I'm reading it too, and wonder what you mean by this not being necessary because of the power of Scala? I'm not a fan of dependency injection frameworks because I think they overly complicate things, but surely dependency injection is necessary for unit testing?
There's just something about using a library from a user named "dickwall" that is not very reassuring.
I think what he means is that a DI framework like Spring is a workaround for Java not having partial function application, so if you have that language feature who needs the framework?
Dick Wall is an ex-googler who runs the Java Posse podcast. I know you were joking, but he is quite well known and respected.
Can you explain how dependency injection replaces partial function application?
The cake pattern displayed dependency injection without a framework, but it is overly complex. I think this framework attempts to make it easier.
Say you're writing a spring application, and you have a data access object. It has some instance members that get injected, like a datasource or a IbatisSqlConfig or something, plumbing stuff, apart from those it has no state. It has some methods, like List listAll(), Foo retrieveFoo(), void updateFoo(Foo foo), that kind of thing. So you could get rid of the Dao object and just have 3 functions, add the state from the object into your parameter lists, and on startup you could apply the parameters that represent your plumbing and use the resulting functions to do your data access. 
via: http://lambda-the-ultimate.org/node/4292
Not popular enough yet since they picked the wrong logo. :)
you also write less code with groovy and the non-groovy developer next to you understands what you've been doing. that is not the case for scala.
He wanted a static language, so groovy didn't apply, for him.
It's not a crime to elevate the standard for computer programming.