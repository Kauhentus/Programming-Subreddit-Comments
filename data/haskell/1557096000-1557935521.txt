stack still installs ghc _somewhere_ on your computer, and configures everything so that its installation files can be found.
&gt; I would love to hear any feedback regarding for example the use of randomized inputs Quick thoughts Imo using a single small random sample is bad practice. * You can't reproduce results. * You don't get fair comparison between runs. I think the better solution is to use a static seed, a stable pseudo random generator and provide a way for users to provide a seed if they want to do in depth benchmarking. If you benchmark small samples also consider having benchmarks for more than one sample. Either the actual data makes a significant difference and having multiple samples makes sense, or it doesn't but then why not use static data. * Use env to minimize gc performance distorting results.
I thought this was only true if you run your program with `stack exec -- ./program`. Is my understanding wrong?
I am worried about that as well. I've just worked through a pretty bad phase in my life. I was just sliding through my CS course, programming only the bare necessary that my anxiety allowed me to. Now I'm better, and I see that I don't know much about "real" (as you've stated) programming. Haskell is making me reconnect with my passion for coding, and now I want to code for real. As I have said, I am open to any suggestions. I would love to hear what you would recommend for me, a beginner in actual, concrete programming. Judging by your comment, I think you know what I mean! Cheers!
Probably create your own unless there’s a `instance Foldable (Node n)` that does what you want.
I'm trying to use cabal's v2- commands. I have a project which builds a library, and another containing an executable which makes use of that library. How do I use `cabal new-install`
A real project is hard to point at. Though you might check GitHub, GitLab, etc. for open-source / free software projects using Haskell that you can contribute to.
That’s kind of the goal of my library [hfnn](https://github.com/quickdudley/hfnn). I wouldn’t call it an acceptable replacement for tensorflow yet but it lets me code a GAN without too much trouble.
A lookup-heavy workload also seems sensible. My own Trie implementation (unoptimized) performed notably better when I stopped forcing the structure of the tree, but that lack of amortization of the workload is actually not always preferred.
Foldable wouldn't help, would it? All Foldable gives you access to is a sequence of all the nodes in a structure. You don't want that here, because you care about the nodes' locations.
With \`MonadComprehensions\` you can do: &amp;#x200B; runListT \[(g x, y) | (x,\_,y) &lt;- ListT fM\] :: Monad m =&gt; m \[(D,C)\] &amp;#x200B; But to skip \`ListT\` completely requires a bit more thought. Since the \`(A, B, C)\` is essentially "two layers deep" you need more than just a single \`&lt;-\` (unless you use ListT to collapse those layers), and you can't just use two \`&lt;-\` either because the right hand side of each is of a different monad. I think what you really want to do here is to make use of the fact that Functors compose automatically (unlike Monads): fmap (\\(x, \_, y) -&gt; (g x, y)) &lt;$&gt; fM :: Monad m =&gt; m \[(D, C)\]
I'm still getting used to cabal v2-* commands myself. You might try using a "normal" cabal install to put your library in your user-global package-db. Alternatively, I think stack has some documented workflows specifically for a multi-package project, which sounds to me like you are a small example of.
I promised a co-worker that I'd finish up this short post about how to actually *use* DataKinds with data that isn't available until program runtime. I've found that most "dependent types in Haskell" tutorials don't quite cover how to get all the way to something useable in a real program. I hope this helps someone!
If you want to add another path-finding algorithm I suggest D*- lite. In the case where the graph doesn’t change it’s basically A* apart from working from the destination backwards; but it can handle changes to the grid while the actor is in motion without fully recalculating the route.
This is neat, I came across this precise issue last week and a co-worker knew the `case` trick. Thanks for writing this up in detail!
Yes, the _most general_ type of `ex1` is `forall x . ExprF x`. The `Var` constructor has no interaction with the parameter of `ExprF` and so leaves it totally unconstrained. That means we can _unify_ this type with the more specific type `Two`. The same logic absolutely applies for `ex2`. The most general type of `ex2` is `forall x . ExprF (ExprF x)` and it merely unifies with the more concrete and specific type `Two`. A member of type `Two` which inhabits no more general type as well is `Add (Add () ()) (Mult () ())` or something like that.
Not sure if this is good enough, but I've been using LSTM models in my side project backprop-learn [https://github.com/mstksg/backprop-learn/blob/master/src/Backprop/Learn/Model/Neural/LSTM.hs](https://github.com/mstksg/backprop-learn/blob/master/src/Backprop/Learn/Model/Neural/LSTM.hs) which is built based on the principles in this blog post [https://blog.jle.im/entry/purely-functional-typed-models-1.html](https://blog.jle.im/entry/purely-functional-typed-models-1.html)
Recovering types via singletons is something I've wanted to do surprisingly often. It has all sorts of neat applications. I've twice written a JSON processing pipeline that used them to achieve type-safe/type-directed "plugins." Unfortunately, they come with a good deal of boilerplate as is, a lot of which you can auto generate, but also when you are recovering the type information. As I understand it, there is no way around this since the compiler needs to know exactly what it is pattern matching on to recover the type correctly. But it has shown me how useful real dependent types could be, so I'm looking forward to the day that lands. With regards to information sources, I've found [this series of articles](https://blog.jle.im/entry/introduction-to-singletons-1.html) to be very useful.
People are willing to help provided you are willing to ask a question about a specific problem with your Haskell code. No one is going to lay out the steps for you, or write code for you, but people will be more than happy to help you fix what you have.
Short and sweet :) [a possible way](https://github.com/ghc-proposals/ghc-proposals/pull/218) of writing it in the future extractPair iso = ( iso @(via Const) @(via Identity) id , iso @(via Identity) @(via Const) id )
You can write a cabal.project file within B to tell cabal where to find the A dependency. Then `cabal v2-install B` from within B's directory should just work.
If you enable {-# Language PatternSynonyms #-} at the top of your code pattern Neg :: Int Pattern Neg &lt;- (compare 0 -&gt; GT) pattern Zero :: Int pattern Zero &lt;- (compare 0 -&gt; EQ) where Zero = 0 pattern Pos :: Int pattern Pos &lt;- (compare 0 -&gt; LT) and then indicate to GHC, "matching on `Neg`, `Zero`, `Pos` is exhaustive" {-# Complete Neg, Zero, Pos #-} Now this is valid: case x+y+z of Pos -&gt; do sth Neg -&gt; do oth Zero -&gt; do mth
[https://hackage.haskell.org/package/zlib](https://hackage.haskell.org/package/zlib)
[https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-List.html#v:unfoldr](https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-List.html#v:unfoldr) getList node = unfoldr (parent *&gt; ((,) &lt;$&gt; action &lt;*&gt; state)) node (Uses `Applicative Maybe` instance.)
All very good points, thank you! But what are you referring to with "small random" sample? You mean that even the one I called "large" (300 strings of length 300) is too small ? Or the smallest (3 x 3) is too small?
You mean, allocate once and lookup many times?
I don't think I can use Control.Applicative cause I have to submit the homework to an in cloud checker
1. What about the case where "nested" `do` is inner one? How would a developer mark end of inner do? 2. Isn't `{}` syntax working already for `do` as an alternative to indentation? Can those styles be mixed?
Ok, what field do I use for this?
Types with `Category` instances but without `Functor` of functor-like ones are interesting.
According to [the docs](https://cabal.readthedocs.io/en/latest/nix-local-build.html#developing-multiple-packages) you use `packages:` for this: packages: A/ B/
What I normally do is `stack build --profile` to build in profiling mode and execute the program with `stack exec prog -- +RTS -slog.txt -hr` or something like that to generate hot spot analysis. You can pass any profiling flag while executing when built in profiling mode.
To one of your question, you can use `stack clean` and `stack clean --full` or nuke the local `.stack-work` folder.
If you really want to be obnoxious, why not write *everything* in point-free style (aside from a few basic combinators you might find neccessary)?
You might like that `(-&gt;) a` is a `Monad` (and hence an `Applicative`): tuples = filter (even . fst) $ zip &lt;*&gt; scanl1 (+) $ numbers first_and_last_different = (/=) . head &lt;*&gt; last Oh, and `head_length` is just ``(length xs + 2) `div` 3``.
You can always use the more general form of `(++)` and `map`, `(&lt;&gt;)` and `fmap` respectively. Try running [`hlint`](http://hackage.haskell.org/package/hlint) over your code for more hints. It sometimes provides suggestions of the caliber you're requesting.
Thanks for the tip I'll definitely check it out. And I guess I could have written some fictions a bot more generally.
In the context of benchmarking I would say if you get results which differ by more than 2-5% in consecutive runs just because of the randomness it qualifies as a small random sample. The basic idea is you want to avoid that if someone is * running benchmarks * making changes * running benchmarks with changes will conclude the changes were positive/negative when in truth the difference was only caused by random inputs. But what the cutoff is for tries depends on the data structure/implementation so I can't say that from the top of my head. The vector benchmarks are an ok template, but don't use `env` yet.
&gt; You might like that (-&gt;) a is a Monad (and hence an Applicative) You're right, I love what you're doing with it. I'll have to go over `(-&gt;)` as a `Monad` again though, because it is hurting my brain. &gt;Oh, and `head_length` is just `(length xs + 2) \`div\` 3` That's genius, why didn't I think of that? I don't really like `takeWhile` as an infix operator, it doesn't make sense to me. I think I'll keep flip there. Thanks a lot for your input!
Some other more general tips which: Try benchmarking functions with INLINE/NOINLINE. If one variant is too large to get inlined but the other isn't you might see a major performance difference which likely wouldn't be present in production code. Alternatively easy to check by looking at the core output. For data structures it's also good to benchmark input sizes that fit: * L1 cache * L2/L3 cache * Definitely will hit memory. Most of the time you can trade space use for CPU use and the other way around. If you only benchmark eg. sizes that naturally have a lot of cache misses you might penalize use cases with few elements without noticing. If one implementation is obviously better than that might not matter much but it's something worth to keep in mind.
Because I'm not good enough at it I suppose. Also the limitation that we're not allowed to use helper functions makes it difficult. I do want to fully understand all of my solutions.
Please don't capitalize "data" nor "type"; in Haskell, the keyword "data" and the typeclass "Data" are different things, and also the keyword "type" and the type "Type" are different things.
For `swap`, perhaps you can do something with `zip [0..] xs`? Like: swap i j xs = map (\(ix, el) -&gt; bool (bool el (xs !! i) (ix == j)) (xs !! j) (ix == i)) ps where ps = zip [0..] xs Idk, the `bool` function (from `Data.Bool`) would work better in this case if the arguments were switched so the condition came first, but whatever.
Opinion: Point-free is okay as an exercise, but it often just hurts readability for no reason. Example: first_and_last_different = (/=) . head &lt;*&gt; last first_and_last_different' xs = head xs /= last xs The second version should be immediately clear to anyone with basic knowledge of Haskell, while the first requires a lot more mental gymnastics. The same applies to your two versions of `larger`. Some would perhaps argue that point-free is more 'idiomatically' Haskell, which is cargo-cult nonsense. Also, be careful with 'polymorphic is better'. Polymorphism can hurt readability, since concrete types are generally easier to understand than lots of type class constraints, and performance, since GHC is not very good at automatically specialising polymorphic functions.
You can play with http://hackage.haskell.org/package/pointfree to find the squinty versions, but you're right of course not to submit code you don't understand.
&gt;I'll have to go over `(-&gt;) a` as a `Monad` again though, because it is hurting my brain. Personally, I really like using this as an `Applicative`. If you have something like the following, where `f`, `g`, `h` are one-parameter functions: myFunc = combine &lt;$&gt; f &lt;*&gt; g &lt;*&gt; h Then it's equivalent to this: myFunc x = combine (f x) (g x) (h x) This can be very useful sometimes. For example: palindrome = (==) &lt;$&gt; id &lt;*&gt; reverse -- same as \x -&gt; (id x) == (reverse x) In other words, 'something is a `palindrome` if the `id` and the `reverse` are `==`'. This particular instance is called the 'Reader monad', as it can be considered as letting multiple functions 'read' from a single source. As the name suggests, this can also be used as a monad, though it's more verbose: palindrome = do forward &lt;- id backward &lt;- reverse return $ forward == backward Also, just plain `f &lt;*&gt; g` is the same as `\x -&gt; x`f`(g x)`. It's a bit less useful though.
That perspective on `(-&gt;) a` as an Applicative is really helpful, thanks for that. I tried implementing `Functor'` and `Applicative'` for `(-&gt;) a` by myself and that was very helpful for understanding how it works as well: class Functor' f where fmap' :: (a -&gt; b) -&gt; f a -&gt; f b class Functor' f =&gt; Applicative' f where pure' :: a -&gt; f a (&lt;&lt;*&gt;&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b instance Functor' ((-&gt;) a) where fmap' f g = f . g instance Applicative' ((-&gt;) a) where pure' = const (&lt;&lt;*&gt;&gt;) f g a = f a $ g a
The true fun of the `(-&gt;) a` monad is the fact that the `(&lt;*&gt;)` function is the S combinator `\f g x -&gt; f x (g x)`. Between `(&lt;*&gt;)` and `const` (the K combinator) you've got a turing-complete language. It's not even terribly hard to write a compiler for lambda calculus that compiles into SK combinator calculus, and this might be a fun exercise if you're looking for something more interesting to do.
No argument there. I think there's a certain elegance in the point-free implementation of `first_and_last_different`, but on balance the straight forward implementation is just better. Aside from `euclid` and `factors`, everything else I wrote in point-free style is definitely horrid.
err, yeah, it works without that?
What I would like to accomplish is have stack recompile all the libraries that are included, to see if that changes something, so `stack clean` only cleans the object files from my own code, I'll have to check whether removing `.stack-work` actually does what I want.
Yes, that's how I compile my program, and when I execute it with `stack exec -- prog +RTS -hr`, it makes a segmentation fault. It does not with other profiling schemes. That's why I decided to try to compile with the `-debug` flag too, but then I have the problem with the linker. This is tough!
That's an interesting idea, I'll definitely try and play around with that.
I agree that the `Array` API is somewhat minimal: most of its useful functions come from `Foldable` and `Traversable`. If you’re creating `Array` types from normal Haskell lists, you probably want [`Data.Vector`](http://hackage.haskell.org/package/vector-0.12.0.3/docs/Data-Vector.html), which is implemented in terms of `Array` but is significantly more ergonomic and closely optimized. About the only time I would use `Array` directly would be if I had multidimensional arrays that for some reason I couldn’t express with [`grid`](http://hackage.haskell.org/package/grid-7.8.12).
That's fair. I was interfacing with a "third party", so I had to create an \`Array\` at the end of the day. Specifically, I was solving the [exercism.io](https://exercism.io) exercise "binary search", and they specify that they take in an \`Array\`, not a \`Vector\`.
Command is a type, not a data constructor. Your Haskell code is littered with you using uppercase names in pattern matches to match a variable, which does not work. You must use a lowercase name to match a variable, not an uppercase name.
Thank you. I didn't know about someNatVal and values could be converted to type level. I need to work out some examples to really wrap my head around it, and what it enables me to do. But the answer seem to be in this passage from your post.. &gt; it allows an arbitrary vector to be injected into a type-safe bubble, as long as the expression in the bubble can handle a sized vector of any length, and as long as the type of the result doesn’t leak the length of the vector in its type. The length can appear at the term-level, of course: Others might find this SO thread/comment interesting [1] [1] https://stackoverflow.com/a/30762622
RemindMe! 141 days "Check [mercury.co](https://mercury.co) positions for international hiring"
I don't usually get my brain exploded before lunch, but here we are.
I feel sure you should be able to get `fix` in there.
&gt; I'd like to avoid Python as much as possible... Lol! Why?
I realized yesterday that the [`UnliftedFFITypes` extension has no documentation](https://gitlab.haskell.org/ghc/ghc/issues/16629), so I made a little playground to confirm that it worked the way I thought it did. I sprinkled some comments in the C file and added some brief high-level commentary as a readme. Hopefully, this can be a useful resource for anyone else who's curious about how to do this kind of thing.
&gt; The Clean language used this same strategy in the open. There's no need for past tense, the last release of the [Clean *programming* language](https://clean.cs.ru.nl/Clean) happened past October I think. What may actually kill it is that googling for "Clean language" now brings up pages and pages of something completely different.
I can force it in in a few places, but it doesn't feel right: take 51 $ fix $ ((0, 0):) . map (\(n, m) -&gt; (n+2, m+n+2))
Happy to oblige. :)
That's not true, Haskell is a typed language and the SK(I)-calculus is only TC if the functions don't carry types since you won't be able to type the Y-combinator or something of equivalent power which is needed to achieve TCness. However, introducing `fix` will make it TC. It's still interesting though and I'd like to second that project idea, it will be fun.
Or pointfree.io
I'm interested on developing something similar, care to share any useful resource? I'm a Haskell beginner.
It's part of base, and the I though most of those operators were in Prelude since AMP went through. In any case, you can write it more long-hand, there's no magic in those operators: getList node = unfoldr coalg node where coalg node = case parent node of Nothing -&gt; Nothing Just p -&gt; case (action node, state node) of (Nothing, _) -&gt; Nothing (_, Nothing) -&gt; Nothing (Just a, Just s) -&gt; Just ((a, s), p) (Might be an off-by one there, but I'm sure you can address it easily enough.)
... because *that's* **never** going to be confusing.
 [(n, sum [1..n]) | n &lt;- [0..100], even n] I feel like this would be more efficient as a scan instead of a comprehension. Since sum \[1..n+2\] = sum \[1..n\] + (n+1) + (n+2), and the smaller sum will be useful in the previous element.
The C foldr will have problems with infinite lists, unlike the Haskell version. The C foldl will behave like Haskell's foldl', which is almost certainly a good thing, being strict in the accumulator is generally better than thunk allocation, unless you are implementing foldl in terms of foldr. foldl f s l = foldr (\h -&gt; ((`f` h) .)) id l s
This was great! If I could suggest a small edit, in math, `a | b` usually means that a divides b, not the other way around. If you could flip your definition, it might be less confusing to some readers.
Oh dear, you’re absolutely right. I’d rather not flip the variable order from Lens or the other relations. Anyone know a common notation for divisibility that is flipped?
nice one:)
is this what youre looking for? https://hackage.haskell.org/package/contiguous-0.3.3.0/docs/Data-Primitive-Contiguous.html#v:unsafeFromListN
&gt;\-- Using a section instead of a prefix call Very interesting but why do you say this is a section ? \-- Using a section instead of a prefix call
 numbers :: Num n =&gt; [n] numbers = 1 : map (+1) numbers This one can be written with [iterate](https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#v:iterate). I also prefer [succ](https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#v:succ) to `(+1)` so here you go. numbers :: Enum n =&gt; [n] numbers = iterate succ 1
There is an existing notation for the 'divides' relation, though I rarely see it used in the wild. I'm actually not sure how to type it, I don't know whether it's in Unicode - it is three dots stacked vertically on top of each other, a bit like a colon, of the same height as the '|' divides symbol. I've used it in TeX before, and I do recall on tex.stackexhange there were some questions about producing a symbol for it.
`(a ◇)` and `(◇ b)` for some operator `◇` are called left and right *operator sections*, syntactic sugar for `\b -&gt; a ◇ b` (or `(◇) a`) and `\a -&gt; a ◇ b` respectively. I’m saying that `(.) concat` is just a call to the operator `(.)` in prefix form (cf. `fmap concat`), while `(concat .)` is an operator section (cf. `(concat &lt;$&gt;)`).
Almost...for this function you still have to give it the length of the list (i.e. `unsafeFromListN (length list) list`). It would be nice to just have the function `fromList list`.
You're not "doing it wrong" if you define your own function, it's called functional programming. The argument order of `array` and `listArray` makes defining things like fromList xs = listArray (0, length xs - 1) fromListN n = listArray (0, n - 1) rather easy. From a performance point of view, the `fromList` function is not to be recommended though, since not only will need to traverse the list twice, but in doing so you will force the whole thing to be manifested as a consequence. If you would be able to use something like `fromListN`, the list could in theory be constructed lazily. To throw in my two cents, I don't know why people always steer newcomers away from the `array` package early on. There's only a handful of functions to learn, and using the `accumArray` function is somewhat similar to programming with nested for loops, with which you might be familiar when starting out. Hopefully I understood you correctly. If you wanted a function of type `(Int, Int) -&gt; Array Int a`, that wouldn't make sense of course, you would need a mutable array then.
You're correct. I was thinking of compiling into an SK(I) AST, but to translate that into `(&lt;*&gt;)` and `const` to run it in Haskell you need the Y-combinator as well.
On `sqrt` not being polymorphic, when I type `:t sqrt` in `ghci` (version 8.6.3) I get `Prelude&gt; :t sqrt` `sqrt :: Floating a =&gt; a -&gt; a` Am I missing something or is that not polymorphic somehow?
While not sure, I think changing the compile flags does force a recompile of most packages.
Well... Let's say I have my own reasons. ;) Like 13k lines of reasons. I don't wanna jump back and forth from Haskel to Python and then back to Haskell to finish of the processing.
I might also help to share the project, so others can experiment. Also, I think the flags \`-O2 -g -debug\` do not make sense in combination? Optimise with debug symbols?
I'm totally willing to define it myself (that's what I did), but it seems like something that might be common enough to warrant inclusion in the library itself. Your point about needing to manifest the entire list is a good one, though. That's definitely something you would need to consider before using it. For my situation the list/array was never going to be that big, though.
Sorry, I am an idiot. I was mixing up Fractional and Floating. No clue what I was thinking. Thanks for pointing that out.
Things work find for me: tommd@ovdak test/A% tree . . ├── A.cabal ├── CHANGELOG.md ├── LICENSE ├── Setup.hs ├── dist-newstyle │ └── cache │ └── config └── src └── A.hs 3 directories, 6 files tommd@ovdak test/A% cabal new-install --lib Resolving dependencies... Up to date cabal new-install --lib 2.93s user 0.44s system 94% cpu 3.547 total tommd@ovdak test/A% cd ../B tommd@ovdak test/B% tree . . ├── B.cabal ├── CHANGELOG.md ├── LICENSE ├── Setup.hs └── src └── Main.hs 1 directory, 5 files tommd@ovdak test/B% cabal new-build exe:B Up to date Or if you prefer: s/C/Webpage.hs ~/d/c/c/s/C/S/API.hs X tommd@ovdak /tmp/test% cat cabal.project packages: B, A tommd@ovdak /tmp/test% ls A B cabal.project tommd@ovdak /tmp/test% cabal new-build exe:B Resolving dependencies... Build profile: -w ghc-8.6.4 -O1 In order, the following will be built (use -v for more details): - A-0.1.0.0 (lib) (first run) - B-0.1.0.0 (exe:B) (first run) Configuring library for A-0.1.0.0.. Preprocessing library for A-0.1.0.0.. Building library for A-0.1.0.0.. [1 of 1] Compiling A ( src/A.hs, /private/tmp/test/dist-newstyle/build/x86_64-osx/ghc-8.6.4/A-0.1.0.0/build/A.o ) ld: warning: directory not found for option '-L/opt/local/lib' Configuring executable 'B' for B-0.1.0.0.. Preprocessing executable 'B' for B-0.1.0.0.. Building executable 'B' for B-0.1.0.0.. [1 of 1] Compiling Main ( src/Main.hs, /private/tmp/test/dist-newstyle/build/x86_64-osx/ghc-8.6.4/B-0.1.0.0/x/B/bu ild/B/B-tmp/Main.o ) Linking /private/tmp/test/dist-newstyle/build/x86_64-osx/ghc-8.6.4/B-0.1.0.0/x/B/build/B/B ... ld: warning: directory not found for option '-L/opt/local/lib' cabal new-build exe:B 4.25s user 1.25s system 90% cpu 6.045 total
Could try writing f . g as fmap f g (or for longer compositions, a balanced binary tree of fmaps :) )
(+1) is also \`succ\` from Prelude.
To make the 'boring `tuples`\-function in the first assignment more interesting, you can use the `Alternative` and `Monad` instances for lists: import Control.Monad (guard) tuples :: Integral n =&gt; [(n, n)] tuples = [(n, sum [1..n]) | n &lt;- [0..100], even n] tuples' :: Integral n =&gt; [(n, n)] tuples' = do n &lt;- [0..100] guard (even n) return (n, sum [1..n]) -- or even: tuples'' :: Integral n =&gt; [(n, n)] tuples'' = do n &lt;- [0..100] guard (even n) return (n, quicksum n) where quicksum n = n * (n + 1) `div` 2
This gets quite frustrating with complicated pattern synonyms. /u/WhistlePayer already explained well but I wanted to show the simplest example data An :: Type -&gt; Type where Mk :: An Int The inferred pattern signature of pattern Make = Mk is pattern Make :: () =&gt; (int ~ Int) =&gt; An int pattern Make = Mk Because it doesn't assume an `Int` (notice lower case `An int`) then we know `int ~ Int` from :: An int -&gt; int from Make = 10 :: Int However if we change it to "obvious" `:: An Int` it fails pattern Make :: An Int pattern Make = Mk
I agree! I'd love to see more examples/tutorials with them.
I got this with a fold: ``` swap2 :: Int -&gt; Int -&gt; [a] -&gt; [a] swap2 i j xs = foldl (\b a -&gt; b ++ [switch a]) [] (zip [0..] xs) where switch a1 = if fst a1 == j then xs !! i else if fst a1 == i then xs !! j else snd a1 ``` i'm sure that if statement can abstracgted to just do a switch on one param.
Yes, that looks right.
Yes, it does work without `stack exec`! In more detail, here's *exactly* the process I went through: 1. Create a `stack` project which uses `hint`. 2. Do `stack install --local-bin-path bin`. It should be possible to successfully run `stack exec .\bin\my-program.exe`, but just plain `.\bin\my-program` should give an error, since there is no global GHC installation. 3. `cd bin` and run `stack exec --no-ghc-package-path -- cabal sandbox init`, then `stack exec --no-ghc-package-path -- cabal install &lt;the-required-dependency&gt;`. Note that these calls have to be wrapped in `stack exec`, since — as I said already — there is no global GHC installation. 4. Replace the existing call to the `hint` interpreter with `unsafeRunInterpreterWithArgs ["-package-db .\\cabal-sandbox\\x86_64-windows-ghc-8.2.2-packages.conf.d"]`. 5. Rerun `stack install --local-bin-path bin`. Now it should be possible to run just plain `.\bin\my-program`, even without GHC installed. Now that it's working without requiring GHC installed, I need to find a way to distribute it (as I already outlined in my [previous comment](https://www.reddit.com/r/haskell/comments/bcoahc/using_dependencies_with_hint/em0k5ng/)).
What do you think of `numbers = scanl (+) 1 $ repeat 1`
[1..]
Vector is not implemented in terms of Array? It does not have array as a dependency and has quite a unique and specific implementation.
https://gitlab.haskell.org/ghc/ghc/issues/15608 - looks like this bug, try using newer ghc
how about don't be an ass?
What's the best way to call Python from Haskell? I could swear I saw some example code using \`\[python| ...|\]\` quasiquotes, similar to \`inline-r\`, to pass data between Haskell and an inline Python script not all that long ago, but I can't seem to find it anywhere now.
Up next on confusing Haskell things: How many different meanings can you overload an apostrophe with?
Perhaps were you thinking of https://docs.rs/inline-python/0.3.0/inline_python/, with the `python!` macro in Rust?
Let me see if i got this straight, ive been grappling with this too. Using readme.md as the reference. Forgive the formatting, mobile. Layer 1: The layer which gets called from main. The example given is ‘AnimalMock’. Its a newtype around all the effects that you plan to include. Running the monad with ‘runAnimalMock’ determines how all the effects are combined or started. Layer 2: Many mid level utilities that provide certain effects. We dont need all the effects for every one of these layer 2 utilities. Keeping the monad as a variable lets us reuse the utilities for mock implementations, the real deal, the real deal which has been enhanced with a new effect, etc.—all of which are different layer 1 implementations. Layer 3: pure functions called from the layer 2 utilities. Functions consuming data which were effectfully gained. Providing synthesized logic for layer 2 to combine with other layer three results. Having written that all it now makes sense. I think i got it right. Thanks for providing the example! Incidentally, Ive used reflex frp a lot. I now realize that they use that pattern too.
Unicode thinks the bar (`∣`) is "divides": https://www.compart.com/en/unicode/U+2223 But is has stacked triple dots (`⋮`) as a "vertical ellipsis": https://www.compart.com/en/unicode/U+22EE
Yep, your understanding is correct! This is basically the core of your architecture. With Layer 1 you specify the type responsible for keeping the environment and combination of all basic/fundamental effects (MonadReader, MonadError, MonadIO, etc.). Within Layer 2 you extend the interface with your application-speficic effects, like _sending an email_, _talk to database_, _integration with some AWS service_, _metrics and monitoring_, etc. And in Layer 2 you implement instances of those interfaces for your application monad. And Layer 3 combines different functions. Like you might want to get all users from the database who satisfy some specific condition and send email to every one. As you mentioned, this approach works nicely with mocking. If we need to test such function from layer 3, we can just implement another mock monad and implement instance for `MonadEmail` which just does nothing or does some simple pure computations. So we can have automated tests for our pure functions from layer 3.
That's quite clever, I could just as well use a map though, right?
I guess I should clarify, we show and explain our solutions to the tutors live. I won't be causing anyone any pain.
Didn't see anything about FP (or haskell) in this post or Microsoft's release, any more info?
I don't see functional programming mentioned anywhere in the article. Did I miss something?
&gt; I'm totally willing to define it myself (that's what I did), but it seems like something that might be common enough to warrant inclusion in the library itself. This might be another case of missing "obvious" functions, like tshow :: Show a =&gt; a -&gt; Text tshow = T.pack . show It can be found in every neighbor's tool shed.
How is this relevant w.r.t. Haskell?
I would stay away from `(!!)` as much as possible when writing Haskell. In swap you're using it twice on the list! When your list is really big and you have to traverse it more than once you end up having to keep a lot of it (if not all) in memory. This can basically become a memory leak, which is hard to track. Lists in Haskell are only good if you're going to be "streaming" them. There are lots of helpful libraries to achieve just that, for example the [foldl](http://hackage.haskell.org/package/foldl) library. Here is one way I would implement swap (not checked, I'm on my phone): swap i j xs = case splitAt mini xs of (begin, x:rest) -&gt; case splitAt (maxi - mini - 1) rest of (mid, y:end) -&gt; begin ++ y:mid ++ x:end _ -&gt; error "Helpful error message" _ -&gt; error "Other helpful error message" where mini = min i j maxi = max i j I hope I didn't make any typos. If you're not allowed to import `splitAt`, it's not too difficult to implement. This function will only traverse the list which works better with laziness. I would feel more comfortable using my version of the function over yours when calling `swap 2 10000000000` for example. If you want something with more unknown Haskell patterns you can do it using pattern guards: swap i j xs | let mini = min i j , let maxi = max i j , (begin, x:rest) &lt;- splitAt mini xs , (mid, y:end) &lt;- splitAt (maxi - mini - 1) rest = begin ++ y:mid ++ x:end | otherwise = error "..." where mini = min i j maxi = max i j
Everything Galois does is based on FP. Mostly Haskell, but also Agda and other stuff.
It's [galois](https://galois.com). AFAIK everything they have done until now is based on FP; mostly Haskell, but also Agda and some other stuff. That said, the [MS blog](https://blogs.microsoft.com/on-the-issues/2019/05/06/protecting-democratic-elections-through-secure-verifiable-voting/) says the SDK will only become available on Github "this summer", so until then we can't know for sure unless someone from Galois tells us.
I think we have suffered too much fragmentation in the library ecosystem pretending. I think realistically GHC is the only compiler the community can maintain. All those macros spread all over the place in libraries only make the code less maintainable. I'd prefer to have cleaner code assuming that realistically it is only going to run on GHC.
u/overactor thanks for sharing this, it's great fun! I am impressed that your instructor allows you to do this kind of stuff. Sounds like a great course.
Instead of the space race, we should be looking forward to the upcoming "FP race" between US and Russia..
Nesting case expressions like that is really ingenious, I have to say I like the pattern guards version better though. It just a lot clearer to me. I didn't know about pattern guards, they seem like a nice alternative for view patterns.
[From the linked article](https://www.vice.com/en_us/article/yw84q7/darpa-is-building-a-dollar10-million-open-source-secure-voting-system): &gt; “That receipt does not permit you to prove anything about how you voted, but does permit you to prove that the system accurately captured your intent and your vote is in the final tally,” Ah. Squaring the circle. Easy. Extraordinary claims require extraordinary evidence. I'm glad that even if they happen to be able to do the impossible these things are still going to be unconstitutional in my country [as it would require specialist knowledge to ascertain their integrity](https://www.bundesverfassungsgericht.de/SharedDocs/Pressemitteilungen/EN/2009/bvg09-019.html).
Reacting to the README, an `Array#` can never be a thunk.
Yes. You are right. The jhc compiler only support Parsec2 side of un-supporting Parsec3. It means there is a big gap between GHC and the other Haskell compiler.
[Here](https://www.reddit.com/r/haskell/comments/b229js/darpa_and_galois_building_a_10_million_open/eipsmza/) is an earlier discussion of this same claim; it seems to be related to [zero-knowledge proofs](https://en.wikipedia.org/wiki/Zero-knowledge_proof).
**Zero-knowledge proof** In cryptography, a zero-knowledge proof or zero-knowledge protocol is a method by which one party (the prover) can prove to another party (the verifier) that they know a value x, without conveying any information apart from the fact that they know the value x. The essence of zero-knowledge proofs is that it is trivial to prove that one possesses knowledge of certain information by simply revealing it; the challenge is to prove such possession without revealing the information itself or any additional information.If proving a statement requires that the prover possess some secret information, then the verifier will not be able to prove the statement to anyone else without possessing the secret information. The statement being proved must include the assertion that the prover has such knowledge, but not the knowledge itself. Otherwise, the statement would not be proved in zero-knowledge because it provides the verifier with additional information about the statement by the end of the protocol. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/haskell/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Wow, loads of good projects happening this year. Best of luck to everyone!
Nice, I didn’t even know this existed. Always nice to see more resources on the FFI.
[removed]
Instead of randomly generated tests, you could consider constructing a benchmark "by hand". For example, in Henglein and Hinze's paper on generic discrimination / tries, they benchmark their implementation with words from the bible. The task is to sort the 824337 words of average length 6.3. (Sorting this should take a second or two.) Of course, this should not replace the random testing, but really complement it.
Duplicate of https://www.reddit.com/r/haskell/comments/blgtf3/gsoc_2019_projects_announced/
Not at all impossible. It does require some difficult cryptography, but it is possible. Here is a good video explaining the concept: https://www.youtube.com/watch?v=BYRTvoZ3Rho
I don't understand how Reddit works. I searched for that thread before submitting a new one but couldn't see it even after scrolling for a while.
Yes. That name collision is unfortunate for the programming language.
What Lalaithion said. For example, try changing: ifEval varMap True Command = do evalCommand varMap Commands To: ifEval varMap True command = do evalCommand varMap command Fixing errors like this will lead to more, different errors - this is not because you made the problem worse, it's because GHC doesn't discover all errors at once. Once you fix these, it'll be able to discover more errors. For example, from line 43: evalCommand varMap Print exp = ... Needs some parentheses: evalCommand varMap (Print exp) = ... To tell GHC that `Print exp` is a single argument being unpacked with pattern matching, rather than being two different arguments.
Is this kind of voting also the same problem `blockchain`/`cryptocurrency` try to solve?
 \&gt;It does require some difficult cryptography so it is impossible. Since you need an expert that make a program that you use
I did not understand it and i am not a stupid person. Hence this is too little for an explanation.
I thought these kinds of macros were mainly used to ensure compatibility across multiple versions of GHC, not across multiple compilers.
I think with Stackage and Nix there are new possibilities to easily distribute package sets that are known to build with a given compiler, e.g. like `lts-13.0` there could be also `ajhc-13.0` (or `uhc-13.0`) that includes the subset of Stackage which is known to compile together and with ajhc. Sure, that package set will be small, but without such an effort it's hard to really know what non-GHC Haskell is like. Plus, having such a package set, even if it can only include a few dozen of the couple thousand on Stackage, would be a potential motivator for alternative compiler hackers.
Well. I certainly hope they have an expert making the election system!
No, in a blockchain all info is visible. That is certainly something you do not want for a voting system!
You’re right; the `Array` type in the definition of `Vector` comes from the `primitive` package, not from the array type under discussion here. I’ve amended my comment to reflect this: thanks for noticing this.
No, with blockchains the previous block is publicly known, we merely verify its integrity. &amp;#x200B; Cryptocurrencies in general try to solve non-centralized consensus, though they do tend to use asymmetric sign-encrypt strategies to prove ownership of a wallet, but that already existed.
The thread I created was flagged as spam by a bot and was therefore invisible for a while. I've now deleted it since this thread has more votes, thanks for submitting it!
certainly in a manual votation system you have to give a lot fo trust to many experts. &amp;#x200B; But all that does not matter. Since the advent of mass media, it is simpler and less risky to invest in oiling the media than in breaking the votation system.
I think the paragraph from the readme that you're referring to is: &gt; Keep in mind that this can only ever be done with `ArrayArray#`, not `Array#`. Functions written in C have no way of dealing with thunks, and values in `Array#` can be thunks. Crucially, the values in `ArrayArray#` cannot be thunks since types of kind TYPE 'UnliftedRep are never thunks. I agree that `Array#` cannot be a thunk, but the values in it can be thunks. I put this paragraph in there because I'm fairly confident that there's nothing meaningful in the FFI that can be done with an array of lifted boxed values (although there is certainly useful work that can be done with an array of unlifted boxed values). Maybe someone could concoct a way to pass over the elements, only considering the ones that have already been forced and skipping over ones that haven't. That could conceivably be done, but to what end?
I don't have a Twitter account, but yes. AJHC development should concentrate on the use cases that GHC has pretty much abandoned: cross compilation, Android, and embedded. The more language extensions are supported the better, of course, but that should be a secondary consideration.
45 never agreed to honor the outcome of the 2016 election. Tech was never the problem.
GALOIS IS ALIVE?!?!
I'm working on getting a stripped-down version of this example [into the GHC manual](https://gitlab.haskell.org/ghc/ghc/merge_requests/900). Hopefully, this will help make this information more discoverable.
Give it a try. See if it works. If it does, does it give you the results you expected (i.e., can you explain correctly how it works?). If it doesn't work, how, and why, did it fail?
Thanks. But Ajhc is not compatible with GHC. There is a big gap between them. Example: Ajhc can't support many of hackages.
Not only is `(&lt;*&gt;) = S` but also `pure = K` :-)
Thanks. And supporting Stackage is bit project for me. At first step, I may just Ajhc is installable on Cabal.
I'm completely the opposite. I think the ecosystem is stagnating around a single implementation (which, BTW, don't implement any version of the Haskell Report). I want multiple **Haskell** implementations available with practical uses, even if their practical uses and available extensions do not overlap. I don't know if it will be Ajhc, UHC, or something else, but a language as cool as Haskell deserves not to wither into an implementation-defined compiler-cult.
I'm fully aware of that. That's why I'm saying that AJHC shouldn't try to support all GHC language extensions, and should focus on things GHC doesn't do well. There's no reason to use a new compiler that's almost as good as GHC for every use case. To attract users, the compiler must be *better* than GHC in at least a narrow niche.
&gt;Do you mean we should have many choices such as GHC/jhc/UHC?
Yep that worked and what you said about the errors is true. There are more now, I will try to fix them and if I am not able to do so I will post again. Thanks for the help, greatly appreciated!
How about: `numbers = fix $ (1:) . map (+1)`
Sorry, too legible, I meant: `numbers = fix $ (1:) . (succ&lt;$&gt;)`
I think the video is okay. But, I agree that it doesn't provide sufficient details for you to implement an E2E system yourself. You often get Numberphile videos that only contain proof-by-hand-waving, but that's because they are mostly supposed to tickle your interest and point you at real educational resources. https://en.wikipedia.org/wiki/End-to-end_auditable_voting_systems is also a good survey with more details, and links to details of ThreeBallot and PunchScan implementations that give you enough information that you could run a small election with E2E properties yourself without even involving a computer at all; the math is simple enough to do with pen-and-paper, though you will need a reliable source of randomness. The https://en.wikipedia.org/wiki/Zero-knowledge_proof article is also helpful. Starting from the cave example, suppose instead of 2 entrances there were 2^128 entrances that all met up at a single column, speaking the magic words would temporarily lower the column, so you could go from any entrance to any other. Then, even one successful trail would give Victor a 99.9999% (actually, much more) confidence that Peggy knew the magic word, while being utterly unconvincing to anyone other than Victor (for the same reasons given in the article). E2E Voting is somewhat tied to ZKP, since that's how *you* can verify your vote as cast-as-intended, but you *can't* convince someone else of that (in order to sell your vote). The final step of making sure votes as counted-as-cast is just rampant transparency, any (or every) single individual interested in auditing the results can do that. But once your can guarantee all votes are cast-as-intended and counted-as-cast, you get the guarantee that all votes were counter-as-intended. There are still some possible attack vectors; in particular if you can identity voters that won't do the cast-as-intended verification (and no one else can), then you figure out a way to change how their vote was cast (for example, in the software on the touchscreen they use). There could also be implementation problems, but since verification/auditing is part of the normal process those problems will actually be detected much more often than with the current system.
That's the stuff
I think we should have at least two implementations that have some practical uses. I think at least one of them should be open-source. More implementations than that *could* be good, and an overlap of practical applications *would* be good. But, going all the way to the other end of the spectrum to where we basically have a Haskell implementation for every niche (or even every developer!) would not, I think, be good or stable.
Very informative, thanks! Why are the parentheses needed ? Why is the `where Zero = 0` there ?
Isn't GHC better at optimizing point free function though? Or am I completely misled?
Yes, that's indeed circle^2 . The sentence is a contradiction, despite the arguments you got in reply. It's all not guaranteeably integral.
I agree, but I think it's not necessary to think in such rigid terms about this: ghc itself is not a monolith: it's internals are exposed as various libraries that other projects can use, it has a powerful plugins system allowing syntax or the type system to be extended, and it has had e.g. an LLVM backend successfully integrated. I think the best way forward is to continue this trend of making GHC more modular and flexible. Wrt evolution of the language itself I believe having more people come together with good processes for consensus and decision making (there has been a lot of great work there, with ghc) is much better than, say multiple projects that fork, say (how much richer would Haskell be if purescript were a natural evolution of the ghc project, or eta wasn't off doing it's own thing in the corner?) It seems clear that the idea that we can have regular releases of some Report or language spec that compiler writers can implement is a fantasy.
It isn't used by my comment but I make pattern synonyms bidirectional whenever possible. It means we can use `Zero` as a pattern and as an expression foo Zero = Zero `Pos` and `Neg` on the other hand only make sense as *uni*directional patterns &gt; parentheses The parentheses `(compare 0 -&gt; LT)` are [`-XViewPatterns`](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-ViewPatterns). The whole example can be written using view patterns {-# Language ViewPatterns #-} -- test 100 == 1 -- test (-100) == -1 test :: Int -&gt; Int test (compare 0 -&gt; GT) = -1 test (compare 0 -&gt; EQ) = 0 test (compare 0 -&gt; LT) = 1 [`-XPatternSynonyms`](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pattern-synonyms) just make it clearer by giving names to `(compare 0 -&gt; GT)`
I wrote `Zero` as an *explicitly* bidirectional pattern synonym pattern Zero :: Int pattern Zero &lt;- (compare 0 -&gt; EQ) where Zero = 0 when I could have written it as a *simply* bidirectional pattern synonym, why did I do that? pattern Zero :: Int pattern Zero = 0 I *think* that.. since the expression `compare 0` is the same in all view patterns pattern Neg &lt;- (compare 0 -&gt; GT) pattern Zero &lt;- (compare 0 -&gt; EQ) pattern Pos &lt;- (compare 0 -&gt; LT) that \case Neg -&gt; neg Zero -&gt; zero Pos -&gt; pos is compiled to a single test \n -&gt; case 0 `compare` n of GT -&gt; neg EQ -&gt; zero LT -&gt; pos
You can make a nice swap function using functions from the lens-library. Something like this: import Control.Lens swap i j xs = xs &amp; ix i .~ (xs !! j) &amp; ix j .~ (xs !! i) the `ix i .~ (xs !! j)` sets (.~) the value at index i (ix i) the the value at index j (xs !! j) and then the same for j and i. I think there is also possible to make a better and more fancy version. Something in the same vein as : [function screenshot](https://i.gyazo.com/3d8b68200069f40bafe93d3251d496c6.png) The "closest" I come is this: swapFancy i j = ipartsOf (each . ifiltered (\ind _ -&gt; ind == i || ind == j)) %~ reverse but it does not compile, and the advanced lens types are too hard for me. Maybe some lens guru can help
This is a really good article! I'm guessing that Galois' proposal, though, has more to do with implementing their own language [Cryptol](https://cryptol.net) to secure election data than it does with Haskell specifically.
There's this gist https://gist.github.com/notogawa/2bf5374424e3e51d3ced which may give you some ideas?
There's this gist https://gist.github.com/notogawa/2bf5374424e3e51d3ced which may give you some ideas?
Thanks a lot downvoters. I guess I am going with TypeScript then :(.
Quite the assertion. Almost like saying light cannot be both a wave and a particle, since "Light is a particle and light is a wave" is a contradiction. Turns out, just like [light is both a wave and a particle](https://en.wikipedia.org/wiki/Wave%E2%80%93particle_duality); [Zero-Knowledge Proofs](https://en.wikipedia.org/wiki/Zero-knowledge_proof) can provide an [E2E Voting](https://en.wikipedia.org/wiki/End-to-end_auditable_voting_systems) system where you can confirm that your vote is cast-as-intended (and counted-as-cast), but you can't sell your vote because you can't prove how you voted.
**Wave–particle duality** Wave–particle duality is the concept in quantum mechanics that every particle or quantum entity may be partly described in terms not only of particles, but also of waves. It expresses the inability of the classical concepts "particle" or "wave" to fully describe the behaviour of quantum-scale objects. As Albert Einstein wrote: It seems as though we must use sometimes the one theory and sometimes the other, while at times we may use either. We are faced with a new kind of difficulty. *** **Zero-knowledge proof** In cryptography, a zero-knowledge proof or zero-knowledge protocol is a method by which one party (the prover) can prove to another party (the verifier) that they know a value x, without conveying any information apart from the fact that they know the value x. The essence of zero-knowledge proofs is that it is trivial to prove that one possesses knowledge of certain information by simply revealing it; the challenge is to prove such possession without revealing the information itself or any additional information.If proving a statement requires that the prover possess some secret information, then the verifier will not be able to prove the statement to anyone else without possessing the secret information. The statement being proved must include the assertion that the prover has such knowledge, but not the knowledge itself. Otherwise, the statement would not be proved in zero-knowledge because it provides the verifier with additional information about the statement by the end of the protocol. *** **End-to-end auditable voting systems** End-to-end auditable or end-to-end voter verifiable (E2E) systems are voting systems with stringent integrity properties and strong tamper resistance. E2E systems often employ cryptographic methods to craft receipts that allow voters to verify that their votes were counted as cast, without revealing which candidates were voted for. As such, these systems are sometimes referred to as receipt-based systems. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/haskell/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
&gt; the idea that we can have regular releases of some Report or language spec that compiler writers can implement is a fantasy If we can't do it, it's our failure. Scheme, C, and C++ all do it.
I have no idea why you got downvoted, your question doesn't seem out of place to me. Unfortunately GUI isn't Haskell's strong point, see [State of the Haskell ecosystem](https://github.com/Gabriel439/post-rfc/blob/master/sotu.md#standalone-gui-applications) for more information.
If you have a type constructor named `Z'`, how to you lift it to the kind level? ;)
I don’t think such a gui library exists in the haskell ecosystem. The built in browser part specifically.
There is a library called `webviewhs` which meets _some_ of your requirements? It's a binding to the C webview library, which essentially lets you show a browser window and communicate with it using JS, so that box is ticked; And it's also cross platform at least among major platforms. I found it's documentation adequate enough to make some simple examples work, however it's not on Hackage and it depends on `jmacro` which is not in any of the recent `stack` resolvers. It's github page is here: https://github.com/lettier/webviewhs
Actually it's a possibility that your troubles caused not by library used, but by optimisation tuning. I spent a LOT of time trying to figure out why mine LSTM implementation failed to train with ADAM until i found nice values like (solution where in correct b1, b2 params) let adam = Adam { b1 = 0.9, b2 = 0.999, sEps = 0.00000001, cVal = 5, rgc = 0.00001, sSize = 0.001, b1\_t = 0.9, b2\_t = 0.999, bSize = 10 }
I can get you a working GHCJS with deployment scripts if you try out https://haskell-miso.org (based on latest 8.6). Join our slack as well, many other users there can help as well.
Befor you try/use Typescript maybe look at Elm. To me (Haskell newbe) it looks close enough like Haskell. There is an electron app on github that i found on github: https://github.com/dillonkearns/elm-electron-starter
Purescript + electron sounds like it would work for you much better, especially with the must have of injecting JS &amp; communicating with it.
[https://github.com/restaumatic/purescript-specular](https://github.com/restaumatic/purescript-specular)
Clojurescript,!
The scheme ecosystem is also very fragmented. Having a single production quality compiler is a big benefit of haskell IMO.
This sounds quite a bit like [Threepenny](https://github.com/HeinrichApfelmus/threepenny-gui). You can either have the UI served to a browser or (in recent versions) package the application with Electron. Also, it includes a JavaScript FFI.
Sorry you got downvoted :( Your question wasn’t bad. Come back soon!
ClojureScript isn't really in any way a Haskell GUI library.
I found Elm to be very restrictive and frustrating coming from Haskell -- it's a very opinionated language. If you give Elm a try but find the barriers to abstraction to be too much (IIRC it lacks anything like typeclasses), maybe try Purescript.
Uh, sorry, I just misread the README, the sentence is about the contents of the array and not the array itself, of course. But actually, aren't there lots of potentially interesting FFI functions on structures containing thunks? A simple one would be permuting an array, but usisng FFI just for copying arrays in certain patterns also makes a lot of sense. I actually wrote a foreign primops array package just for efficient insertion/deletion at indices for boxed arrays, because GHC boxed array primops lose significant performance because of mandatory initialization. There should be other use cases as well. For example, nested unlifted arrays are a really good way for implementing tries, and trie insertion/deletion operations also don't need to look at stored boxed values at all.
Neither are most of these solutions people are mentioning; I dunno
We should not forget UHC and [https://github.com/IntelLabs/flrc ](https://github.com/IntelLabs/flrc)!
Yes. I really hope a flavor of GHC compiler without original GHC CPS runtime...
Unfortunately, Haskell became Adacore side of such languages... [https://www.adacore.com/](https://www.adacore.com/)
Ew, gross!!!
I agree you. &amp;#x200B; At first step, I may support Stack to compile Ajhc. At second step, I wish to support [https://www.haskell.org/onlinereport/haskell2010/](https://www.haskell.org/onlinereport/haskell2010/). &amp;#x200B; ... But it needs much human resource... I think we just pay the resource a little by little.
What do you want to apply Ajhc to, if you continue its development?
I would like to use it for embedded application: [https://www.youtube.com/watch?v=C9JsJXWyajQ](https://www.youtube.com/watch?v=C9JsJXWyajQ) [https://www.youtube.com/watch?v=E30ZvEVExI0](https://www.youtube.com/watch?v=E30ZvEVExI0)
I think the issue is that you are using `Show` for something that it wasn't designed for, so it can't easily be used to do this. `Show` is really only usable for debugging; it is not a general-purpose pretty-printer system. There are some libraries that do have pretty-printer typeclasses, and if you're doing something in production, then you might be able to leverage some of those. However, if this is just a toy project, and you have issues with how your debugging output is looking, the easiest way would be just to use a different function for `String` and a different function for any other `Show`. Alternatively, if it's just for debugging, you can manually detect for quotes in the output string and remove them.
Writing user interfaces in functional (and *reactive*) manner is how I stumbled across Haskell; so I'd encourage you to persist with your search. :-) Check out FRP, in this order (of ease of use): Elm, PureScript, Miso, Reflex, Obelisk.
That's the exact experience I had. I started with Elm, but the creator has *very specific* ideas (catering to JS programmers more than Haskellers) as to evolution of his language, so that enabled me to swiftly move on to the Haskell ecosystem (starting from PureScript ending up with Reflex).
Right, a fold just lets you deal with indices and discard them in one go, because the type can change from tuple to int. As someone else wrote, it's better without (!!) as well.
I'm the author of [FLTKHS](http://hackage.haskell.org/package/fltkhs) which is Linux/Windows and [WebkitFLKHS](https://github.com/deech/webkitfltkhs) which allows a webview. The latter hasn't been maintained for a bit but if you want to help me get it current I'm happy to work with you.
&gt; My question is how to write a function like pa for any Show type? and print them out without any double quotes? I don't think you can because the implementation depends on the type (maybe I just don't know enough language-extensions though). Here's a quick'n'dirty work around: class Show' a where show' :: a -&gt; String instance Show a =&gt; Show' a where show' = show instance {-# OVERLAPS #-} Show' String where show' = id Now you can write `pa :: Show' a =&gt; [[a]] -&gt; IO ()`.
As excited as I am to see this, it'd be really so much cooler if this was applying Haskell to actual problems that are really happening, instead of fighting boogeymen.
\`haskell-gi\` fits your case pretty well if I understand it. Getting it running on Windows involves some hoop jumping, but not more than anything else on Windows that needs the FFI.
Yes please! Having a working JHC would allow me to restart my work on HOS, my functional Haskell kernel (see [http://github.com/tathougies/hos](http://github.com/tathougies/hos)). Currently, it's just too much work to develop further -- compilation times are excessive, and there's some bug involving monadic code. If these were fixed, it'd be great!
How about ncurses? The kids are raving about it
Wow, your great product!!! It's the best motivation to maintain {A,}jhc! Hey, do you read this comment!? &gt; #John [http://repetae.net/computer/jhc/](http://repetae.net/computer/jhc/)
I've not used it, but there's this: https://hackage.haskell.org/package/pyfi Doesn't look like it has a quasiquoter though.
&gt; not use GHCJS at all (I tried making it work for a long time without success). If you want GHCJS, you need Nix, resistance is futile. Nix makes it very easy.
I was looking at that one, but I need a GUI library which has this functionality as a widget - so I can have 3/4 these webview components in my window. From looking at the parent project, I don't think it supports isolation (sandbox) - it looks to me that the main window is meant to run web FE as a GUI, not rendering arbitrary pages (I cannot use iframe or similar because those pages I want to render do not allow it).
I appreciate the offer, but I am very bitter about GHCJS. I wasted few full work days trying to make it work in my spare time and I don't find prospect of wasting any more time with this halfbroken project appealing. Few hazy points from what I remember from the horror experience: - with Stack it was broken, I found out support for it is in a process of being dropped - with their installer there were many undocumented requirements which I kept hitting (e.g. many GB on main partition without ability to move nix directory elsewhere, even usage of symlink was prohibited) - tried it in docker which had even more roadblocks (container cannot be hosted on ntfs partition, spent a lot of time seting up loop fs with ext on ntfs just to hit another bunch of errors; I even had a guy trying to help to setup his docker scripts) GHCJS compared to JavaScript, Java or C++ is just extremely fragile environment riddled with unwritten requirements...
Oh, thank you, that might be a viable course of action, I will definitely check it out. That reminded me I might take a look at PureScript as well. It doesn't have support for IntelliJ IDEA (not sure if Elm does), but at least it's better than TypeScript.
You have to trust that the compiled program stack deployed on both all of the voting machines and in the online verification system is the same that is auditable as open source.
Does it hide warnings? A co-worker I told this about was trying it but warnings seemed hidden for some reason.
You actually don't. The mathematical properties are separable from any specific implementation. If you can do the verifications, it don't matter that your software is different from theirs. Or, that there's any software involved at all (E2E can be done with pen-and-paper). If individuals can be identified that will not do the cast-as-intended verification, you could change their votes, which might involve software or might not.
Have you considered using reflex-dom without ghcjs? When used with ghc it can either run as a local server providing a web page or as a single application which starts its own browser. You can use jsaddle to communicate with JavaScript as well, so you can have all the power of a browser but without having to use JavaScript of ghcjs
"I don't know the thing, therefore this thing is impossible"
With pen and paper the summing / counting happens by delegates of all parties. With software/machines the result is "spit out". You can have a separate subsystem feigning the verification and a separate that does the counting / outputs the results.
It also has no native support for a number of important web technologies (cookies, localstorage, websockets), and in the latest version, the FFI isn't powerful enough to add native-like support.
Hey, leave ncurses alone! **mvwaddchnstr** is a perfectly good, descriptive name!
Are you sure it supports webview-like component? I only found a handful of basic widgets (button, input, radio group, select). I essentially need unrestricted `iframe` (or similar; it has to allow showing pages without `X-Frame-Options`).
I browsed docs, but while I did see `frame`, there was nothing special mentioned. And since they state "A program written with Threepenny is essentially a small web server that displays the user interface as a web page to **any** browser that connects to it.", I don't think it supports webview which is essentially a hacked version of `ifame` which allows any page and also support injection of JS and communication with it. I should probably update my OP to make it more clear.
I recently used Brick (another TUI library) and was quite happy about it. But unfortunately for this project I have to go with full GUI and proper webview based on some major browser. Reason is, I don't have control over the pages I want to render, so I can't use text-based webview (if it even exists), since I assume it won't handle JS-heavy pages with many active elements very well (also size might be an issue, I want to show 3 or 4 pages at once; maybe with some clever cropping, but I am no sure how well CSS is supported in those text browsers).
This is precisely what I was about to start writing before looking in the comments. Good to know that I'm not way off-base!
But if any individual can verify the result independently using the open-source code, then any interested party can check for accuracy. Then, if the official count was lying, it will be discovered, and in fact proven. This doesn't make the system perfect. It's still possible to leave out votes entirely, which has happened. Batches of votes are accidentally lost in every election. If no one in that batch goes to check that their vote ended up on the official web site, this won't be noticed. And still nothing prevents extra votes from being added (and posted on the web site, so anyone verifying the count will believe they are real). But the counting of a vote is, in fact, secure if it's verified.
It's pretty darn easy to get working with `nix`, working with GHCJS has overall been a pretty darn smooth experience.
Yeah, very easy if you have at least several gigs of free space on root. If you do not (like me), you can have terabytes of free space on other drives, but you are still out of luck. I suffered long time trying to make it work (confusing error messages, being it broken until I deleted some magical directory, symlinks to work around fixed directory limitation [which I still don't understand why is necessary, I find it archaic and not well thought out], docker, loop fs because nix in docker can't handle ntfs and so on).
Since there appears to be a whole kitchen sink of different array types around, is there some rule of thumb governing when to use which? Do I need any of that if I use the `vector` package? Or if I yolo it with `malloc`? Why have I never even heard of this extension?
&gt; Good to know that I'm not way off-base! Not sure about that, it feels very hacky ;) But hey, it does the job and it's probably what we get for trying to exploit `Show` to do pretty printing.
To be fair, it's a fairly janky requirement, having one part of a "subclass" behave differently to every other. I think the code reflects that very well :)
Thanks for writing this, this is a common issue resulting in annoying boilerplate. Didn't know about the `barbie` package either. One suggestion: For someone trying to grok a new concept, in this case barbie types (heh), it might not be helpful if the code examples are "clever" in more than one dimension, without at least some build-up. For example, you use lambda-case and prisms and lens folds in a way that indicates that some golfing was involved and not all of it necessarily relevant to the primary topic of the post. I think in such cases you could consider a dumb version, followed by "this can also be written like this:".
Good video! Still don't get how this homomorphic encryption idea works though. Do you have any good resources on it?
It's apparently possible to allow symlinks by setting `NIX_IGNORE_SYMLINK_STORE` to 1 -- see [https://nixos.org/nix/manual/#sec-common-env](https://nixos.org/nix/manual/#sec-common-env).
And what if one doesn't (yet) want to use nix? Why can't they just provide binary packages for Win, Mac, Debian, Redhat? Then potential users don't have to commit days to compiling a whole operating system from scratch (which requires sudo access to place it in the root directory) just to use it. It's not a great first impression for people who might just want to try it out quickly to see if it meets their needs.
The basic idea is to perform computations on encrypted data without a decryption step, so that a third party could hold your encrypted data and you could use that third party's computation resources, without compromising your privacy. This is the kind of context you get in cloud computing and with cryptocurrencies that tend to do computation on other people's machines. Consider e.g. [ROT13](https://en.wikipedia.org/wiki/ROT13) (rotating the alphabet by 13 steps). When you've encrypted a text with ROT13, there are some operations that you can still perform on the string without decrypting it, like `reverse`. You could ask a third party to reverse the string without decrypting it. When you decrypt it, you'll get the reversed string. Viola! Obviously, `ROT13` is not secure from modern cryptanalysis, but its simple properties make it easy to use in explanation. The research behind homomorphic encryption is primarily: applying this idea to secure encryption methods, and to other types of operations (arithmetic, etc).
**ROT13** ROT13 ("rotate by 13 places", sometimes hyphenated ROT-13) is a simple letter substitution cipher that replaces a letter with the 13th letter after it, in the alphabet. ROT13 is a special case of the Caesar cipher which was developed in ancient Rome. Because there are 26 letters (2×13) in the basic Latin alphabet, ROT13 is its own inverse; that is, to undo ROT13, the same algorithm is applied, so the same action can be used for encoding and decoding. The algorithm provides virtually no cryptographic security, and is often cited as a canonical example of weak encryption.ROT13 is used in online forums as a means of hiding spoilers, punchlines, puzzle solutions, and offensive materials from the casual glance. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/haskell/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Have some fun with the babes: http://ceoq.l5dusnkq.org/touq282h/
Have some fun with the babes: http://ceoq.l5dusnkq.org/touq282h/
&gt; When you decrypt it, you'll get the reversed string Thanks for the explanation, but I'm pretty sure this is not the case for most encryption algorithms? I mean, they don't work on the individual character level but on on a whole string.
You don't need the entire NixOS to start using nix. Nix by itself is a package manager that you can run use besides apt/brew/...
[https://github.com/grin-tech/grin-tech.github.io/blob/master/index.md](https://github.com/grin-tech/grin-tech.github.io/blob/master/index.md)
Have some fun with the babes: http://ceoq.l5dusnkq.org/touq282h/
Oh!
Have some fun with the babes: http://ceoq.l5dusnkq.org/touq282h/
I chose a simple encryption for a simple explanation, yes. In the real case, you have to develop specialized encryptions or modifications of existing ones, and then have special ways to perform the operations (like "addition"), and with hard limits on which ones or how often, to avoid leaking information. I chatted with some researchers in 2010 who were working on this at the research centre I worked at, and they didn't really have anything useful to show for it yet. Since then there's been a lot of development, but it strikes me as a difficult area of research.
Umm, but it doesn't have GC support... [https://grin-tech.github.io/](https://grin-tech.github.io/)
I've written a guide on how to use GHCJS with ease. It's wordy because I'm going a bit more in detail on certain things, but short version is: If you are on windows, use WSL and HVR's PPA. It is just a matter of adding ppa repo, installing GHC and GHCJS and adding them to path. No containers, nix's, stacks or what not (just WSL). If you don't like working from bash on windows then make a \`Makefile\` so that you can execute build commands without going to the bash console (I have example Makefile at the end of the guide). If you are on Debian / Ubuntu based linux then just add HVR's PPAs and be done with it, again, no long compilations, no mess with stack, nix or containers. All the hard work is already done for you. Here's the guide: [https://github.com/lambdaheart/Haskell-Guide/blob/master/DevelopmentEnvironment.md](https://github.com/lambdaheart/Haskell-Guide/blob/master/DevelopmentEnvironment.md) And here are HVR's PPAs: [https://launchpad.net/\~hvr/+archive/ubuntu/ghc](https://launchpad.net/~hvr/+archive/ubuntu/ghc) [https://launchpad.net/\~hvr/+archive/ubuntu/ghc-wsl](https://launchpad.net/~hvr/+archive/ubuntu/ghc-wsl) [https://launchpad.net/\~hvr/+archive/ubuntu/ghcjs](https://launchpad.net/~hvr/+archive/ubuntu/ghcjs)
You can create a newtype for strings, and a Show instance for that newtype which doesn't print the quotes (though this does not satisfy the "social contract" for Show instances, in practice this happens a lot). Then you can be explicit that you don't want the quotes by explicitely wrapping your strings in the newtype. newtype NoQuotes = NoQuotes String instance Show NoQuotes where show (NoQuotes str) = str main = do print 123 print "normal string" print (NoQuotes "look ma, no quotes!")
I'd suggest not worrying too much about early downvotes. You wrote this comment only an hour after posting your question and that's far too soon for voting to settle down. My experience here and on Hacker News shows that early downvotes (who knows the motivation of the people who give them?) are generally corrected by later readers into a net-upvoted story or comment. At the time of writing your question has net 51 upvotes and 91% upvoted, so you received a total of only five(ish) downvotes! (On the other hand, one thing that I will *always* downvote is complaints about being downvoted.)
Is there any 'get started' example you know of that you can link to?
Stackalized JHC: https://github.com/csabahruska/jhc-components
Thanks. I think it mean we don't need more fork such as Ajhc.
Is there any pdf available?
I still can't get it to even compile on Windows with stack. Numerous issues on github were closed without reopening. So it's either me and the other guys are the only persons in the world having problems to run it or nobody is using it at all.
The GRIN Compiler is a backend only deliberately. There is no need for a new Haskell frontend. But there are lots of opportunities to explore on the backend design space. GRIN targets whole program optimization. And it uses GHC as a Haskell frontend to maximize the impact.
I think I like this better than the hacky \`Show'\` thing u/unfixpoint suggested, even though my first thought was something similar to that. It's less hacky and still pretty easy to use. However, I do agree that using an actual pretty-printing library should be the way to go.
Unfortunately no. I used to add the reflex-dom git-repo as an extra-dep, but I've just seen that there is a release on hackage, so you maybe able to start a new stack with project with reflex-dom without that awkward hack. The trick is to realize that the `mainWidget` top-level function from `reflex-dom-core` produces a result of `JSM ()`. `JSM` is introduced by the `jsaddle` library, and represents some javascript. There are different ways to run it, the most obvious is using GHCJS to turn it to actual javascript. However, one can use `jsaddle-warp` to run it as a local server or something like `jsaddle-webkitgtk` to run it as a gtk app which is a fullscreen web browser. This is actually fairy easy to get running once you've gone through it once. `jsaddle` is a great idea, even if the documentation can be a bit confusing to begin with. I vaguely remember there being someway to setup live code reloading with `jsaddle-warp`, but my memory is failing me at the moment. If this isn't clear, I can try and put some more words together if it would be useful for people.
That looks promising. A bit old visuals, but the hello world program seems like the library could be easy to use. Not sure about Windows and the webkit widget though: &gt; [widget] has been tested only on Linux since that is my primary platform. OSX may work, Windows certainly will not. Unfortunately Windows support is quite high on my priority list, I would like to make a final product accessible to ordinary users which, sadly, still overwhelmingly use Windows :/. Another problem might be security concerns, since as you wrote, the webkit widget hasn't been updated for a long time and my use case is accessing few sites on the internet which have ads (and are also JS heavy, so not even sure if they would work).
Oh, didn't know reflex can be used without ghcjs. The problem with many these browser based UIs is, that they usually don't support the "webview" which is essentially an `iframe` without limitations (so it can access any page, even if that page isn't allowed to be used in frames/iframes/embed). Special access to the browser part is required (I think Chrome internally has some component, but only extensions can use it).
Last time (over half a year back I think), it wasn't possible to have nix directory anywhere else except `/` and symlink didn't work either. (I don't think I was installing nix os, I believe it was "just" nix.) Did they lift this limitation? If so, could you maybe share a link to guide or something how to change the path?
Thank you very much, I will have to try it :).
It is way cleaner than my quick-fix, but essentially there's no difference between this and just using `putStrLn` instead of `print . NoQuotes`.
Thank you for the tip, I'll take a look. I am using IntelliJ IDEA for writing Haskell (not perfect, but for a hobbyist it's good enough), I am not sure if the plugin supports non-stack projects, I'll have to test that.
You should dig into J Carette, A Sabry [Computing with semirings and weak rig groupoids](http://www.cas.mcmaster.ca/~carette/publications/esop2.pdf), in Proceedings of ESOP 2016, p. 123-148. Agda code in [https://github.com/JacquesCarette/pi-dual/tree/master/Univalence](https://github.com/JacquesCarette/pi-dual/tree/master/Univalence). A lot of the algebra you develop is there too. If you hunt around in my repos, you'll also find things about lenses, exploring some of the same things you mention here.
&gt; At the time of writing your question has net 51 upvotes and 91% upvoted, so you received a total of only five(ish) downvotes! When I went to bed I think saw something like 75% downvotes (showing 0). &gt; I'd suggest not worrying too much about early downvotes. Well, I was basing on my epxerience from other subreddits where hitting 0 usually means the thread is dead and no one will see it = so no (constructive useful) responses. I am glad it didn't happen here, got a lot of useful comments. I don't really care that much about karma. &gt; (On the other hand, one thing that I will always downvote is complaints about being downvoted.) Yeah, I can see your point, not sure if I agree with it. (BTW I didn't downvote you, I don't believe downvotes are meant for disagreement.)
Look at `brick`
You're right, permutations should be fine. I've updated the readme in the repo to reflect this. I'm not sold on the trie example since I don't think you actually need to FFI to build an efficient trie. The primops that GHC provides should be sufficient. Well, the same is true for permutation, but it seems more likely to me that a foreign call would need to perform as a small part of some larger operation. Of course, this is just speculation though.
I’d be curious to know what you think progress would look like. Ther
When I wrote this, I managed to skim past the bit where you said you couldn't embed the pages in a iframe - this would be the ideal solution. Just out of curiosity, what are you trying to do which requires interacting with multiple pages that can't be in iframes? No worries if you can say, I just can't think of such a problem off the top of my head. &amp;#x200B; And yeah, I find it strange that there is such little emphasis put on the fact that reflex-dom can create desktop apps. The GUI story in Haskell is pretty weak at the moment: people are working hard and their efforts are greatly appreciated but there is still much to do. Although using web tools for GUIs isn't ideal, still feels the best way of making a user facing application in Haskell
The array types from \`vector\` have slicing built in. You should typically use these. The \`primitive\` library offers something similar but (1) there's no slicing (2) there are way fewer functions for working on the types and (3) there's no stream fusion. You've never heard of \`UnliftedFFITypes\` because you've never wanted to pass a \`ByteArray#\` to a foreign function. Also because this extension is undocumented. I'm not even sure what it's original motivation was.
Yeah my experience has been completely different, I've found that the maintainers respond thoroughly and professionally to requests for help and that reported issues with builds nearly always end up with a patch to fix the issue or an update to the documentation with a workaround. The only time I've seen them close anything without a solution is when they couldn't reproduce the issue, which is perfectly understandable.
&gt; I was basing on my epxerience from other subreddits where hitting 0 usually means the thread is dead and no one will see it = so no (constructive useful) responses. I see. Luckily I don't think that tends to happen here.
You mean maintainers of haskell-gi itself? Yeah, they are nice guys, but not much help - looks like they don't have any Windows machines/devs, so the only help they can provide is knowledge sharing and reviewing PRs with fixes you make. I don't have enough time &amp; knowledge to fix haskell-gi, unfortunately. Besides, looks like the problem is somewhere in environment stack setups not in haskell-gi itself. Once i've managed to run a hello world app, but couldn't reproduce it after. See https://github.com/commercialhaskell/stack/issues/3619 https://github.com/commercialhaskell/stack/issues/3154 https://github.com/commercialhaskell/stack/issues/3810 Personally i'm stuck [here](https://github.com/commercialhaskell/stack/issues/3619#issuecomment-348691068). I don't what other hoops i can jump and google doesn't know neither - only mine and the other guy posts/issues in search results. So i wouldn't recommend haskell-gi/gi-gtk as crossplatform GUI - you would have to fix stack/msys/haskell-gi/gi-gtk/windows/whatever else first.
I mean, I've been using it on Windows exclusively for years without issue. So while I hear you, and understand that you wouldn't recommend the package, I am hesitant to call that a platform issue - sounds more like some environmental edgecase.
if you say so
Yes, the README has a long list of impressive applications people have made with it to give you an idea: [https://github.com/jtdaugherty/brick#featured-projects](https://github.com/jtdaugherty/brick#featured-projects)
Reminds me of [this](https://mitchellwrosen.github.io/haskell-papers/) I made a while ago.
Do you have *any* idea of how much manpower goes into the C++ standardization effort? There are probably more people on the C++ standardization committee than there are people who have ever worked (in any significant capacity) on the GHC compiler. The C standard is basically stagnant (and many people apparently prefer it that way), so that's totally irrelevant to this discussion. Scheme is a very small language -- and the lack of an advanced type system makes it a *lot* easier to specify.
Do you think reinstalling stack will fix this?
Oh wow. Thank you for the reference. Yeah, this is definitely the same thing from a slightly different perspective and 2 levels more of sophistication. I just yesterday had started wondering about the connection to HOTT and whether I could reflect singleton style SNat and Eq proofs over to Iso. Smells unlikely that I can do it honestly.
Have you seen https://github.com/reflex-frp/reflex-platform/#setup ? https://github.com/obsidiansystems/obelisk/ builds on top of it in a more opinionated way
You can use stack, you just don't have to install ghcjs (and build) through stack. Although you will probably have to do some configuration for IntelliJ to be able to work with GHCJS which is within WSL if you are on windows.
An advantage is that he can put the NoQuotes into polymorphic data structures. I think the idea was to have something polymorphic. Though maybe what they really want is a Show' which behaves exactly like Show except for strings?
Could, depends on what else is on your path really. Stack tries hard to sandbox but it isn't perfect. Probably your issue is more with stacks msys environment than stack itself, but that's just the most likely culprit, not the only possible culprit. Another thing I've run into is a mismatch between a system msys install and stacks msys install - setting the package path and xdg environment variables to point to stacks msys installation instead of the system level install, and installing packages via 'stack exec pacman' helps sort that out.
Thing is I'm using msys from stack exclusively. Have you followed a guide to set it all up?
No, you can't, or it wouldn't be *verifying* anything. Have you actually read **any** of the literature?
Thanks for sharing! I admit this repo is somewhat lacking, as it was originally a study plan for a friend gone awry and since transformed into a repository of generally great papers. If you see any that are missing, feel free to open a PR and I'll merge it ASAP.
How about a way to compile Haskell code on a Raspberry Pi is a reasonable period of time? How about a .Net FFI? How about a binary release of GHC JS? How about a predictable, if not stable ABI? How about versioned symbols so I can provide binary compatibility with old binaries using my library but have newly compiled program automatically use the newer symbols? There's tons of things the GHC team either not interested in at all, or barely interested in. I want to be able to *choose* the **Haskell** implementation that best fixes my need, rather than writing in whatever language GHC implements this release. (Which, again, isn't *any* version of **Haskell**.) FWIW, I don't want to throw away or even do without the innovations in the GHC source code, but I want to be able to fork GHC (ala Eta) and continue being a **Haskell** compiler without having to pull in every new GHC change. &gt; there’s no large body of users clamouring for it People that want Ajhc (75% of twitter respondants), want a standard, even if they don't know it. Because the they want a documented common subset that Ajhc and GHC both implement -- why can't that common subset be a new Haskell Report (or a little more)?
&gt; Do you have any idea of how much manpower goes into the C++ standardization effort? The Haskell Report is significantly smaller than the C++ standard, and has significantly fewer involved parties. You'd have to scale the work down by several orders of magnitude before even starding a comparison. &gt; The C standard is basically stagnant C11 and C18 where both released this decade, and both since the last **Haskell Report**. I know C++ is wanting to change faster than C, but I'm fine wither *any* pace as long as the standard continues to exist and compilers *continue to implement it*.
&gt; ... and print them out without any double quotes? piece of cake! pa::(Show a)=&gt;[[a]]-&gt;IO() pa x = mapM_ (putStrLn . filter (/= '"') . show) x
I don’t see why you would care about that. Nix uses content addressable (hash based) storage. So “sandboxing” nix is pointless/redundant.
The only reason it doesn't work on Windows is because I didn't have the patience to go through the WebKit Windows install process. The bindings themselves shouldn't be hard to update. Default FLTK doesn't look good so I made a [themes package](https://github.com/deech/fltkhs-themes) which does a little better. I also specifically did a lot of work to make sure FLTKHS itself was as easy as possible to use on Windows. IMO its Windows install and deployment process is still the smoothest of the Haskell native GUI offerings. Either way do what's best for your project but if you need the help just hit me up. Good luck!
&gt; The Haskell Report is significantly smaller than the C++ standard Sure *now* it is, but it's pretty damn far from which GHC supports via its various extensions. There are quite a few extensions that should probably be considered stable enough for standardization, but AFAIUI the people who have taken a serious look at it say that they are actually very hard to standardize without referring to implementation details of GHC itself. (Look, I'd actually *love* to have Haskell standardized. I just think it's in any way realistic given the current manpower. Nor is it even necessarily a good tradeoff *if* there is overlap between those who work on GHC and those who would be working on the standard.)
&gt; but AFAIUI the people who have taken a serious look at it say that they are actually very hard to standardize without referring to implementation details of GHC itself. Sure, I guess it would be nicer to not refer to a specific implementation, but I think specifying a specific implementation is better than not having a spec. I'm also comfortable with revising the spec to be more permissive to implementors in the future. (Even C has done this; making a feature optional in C11 that was required [though little used] in C99.)
it will not work if string contains double quotes inside. &amp;#x200B; pa \["dog\\" cat"\] =&gt; dog\\ cat
I'm so happy someone is using chronos!
&gt;newtype NoQuotes = NoQuotes String instance Show NoQuotes where show (NoQuotes str) = str main = do print 123 print "normal string" print (NoQuotes "look ma, no quotes!") Nice answer:) It is always surprised what Haskell can do
Just found my weekend plans. Thanks for sharing!
Previous discussion on this library: [https://www.reddit.com/r/haskell/comments/9iskza/ann\_blog\_post\_colog\_composable\_contravariant/](https://www.reddit.com/r/haskell/comments/9iskza/ann_blog_post_colog_composable_contravariant/)
I went with the steps on the project wiki for Windows use, with the exception of not using system msys install as discussed.
Well, i did the same. Seems like only reinstall will maybe help.
Thanks for sharing. I know you asked for a PR but I’m at work atm and I feel like I will forget after. What about adding [that one](https://www.microsoft.com/en-us/research/wp-content/uploads/2005/01/2005-ppopp-composable.pdf) ?
[removed]
:GhcidQuickfixStart takes ghcid's arguments 👍️ Maybe, it is useful. Like `:GhcidQuickfixStart "--command='ghci --some-no-warn-flag'"`. (but sorry, I don't know the real ghci option `--some-no-warn-flag`.)
Ah, the STM paper. Feel free to throw it on the pile :)
Oh, if I knew sooner there's actually tutorial by Edward himself for `bounds` library...
Valuable addendum to this, just in case someone finds this and is not aware: `print` is defined as `print x = putStrLn (show x)` (See [here](https://hackage.haskell.org/package/base-4.12.0.0/docs/src/System.IO.html#print)) If you open GHCI and type `show "A STRING"` you get `"\"A STRING\""`
I am so glad that Alexis Williams is going to be doing more work on cabal. Of all the projects last summer, hers is the one that's had the biggest impact in my day-to-day work.
But voter confidence is a real problem. I'm not sure if this technology can help (it might be too difficult to understand). When people are not confident the vote has been fair democracies fall apart. And there are real reasons to be concerned, including widespread voter suppression laws (a big subject, but some of these entail casting provisional ballots which a person has little confidence will be counted; likewise arbitrary voter roll purges that affect absentee ballots in the same way), voting machines with no paper trail or known to be hackable, as well as just straight up criminal voter hijinks such as the ballot harvesting case in NC last year
Why does 'The Call by Need Lambda Calculus' appear under 'Type Systems'? It's about operational semantics, not types.
Is there a "best" package for RNG? I want to sample from an exponential distribution and it seems like there are a few options out there.
Thank you so much! It really makes me feel good to know that people are actually finding my work helpful. 😅
Pedantry aside, if you feel the burning urge to change it, I am accepting PR's. You can find the motivation [here](https://www.reddit.com/r/haskell/comments/bm5vku/a_list_of_foundational_haskell_papers/emu9aqv/).
If you're interested in implementation there's quite a few more papers.
The public could give half of a dead rats ass about zero knowledge proofs. If we want to actually fix voter suppression, make driver's licenses automatically issue voter registration with proof of residency, and implement nationwide mandatory absentee ballots, and/or implement mandatory paid leave to cover people getting to a booth and actually voting - which we STILL NEED, even with magic tech boxes instead of paper ballots. Fixing voter confidence is just a completely orthogonal issue. That's more to do with the absolute stranglehold that our two parties have on any political discourse, in that they choke discussion of policy to death while playing at contests of personality and completely ignoring the base. Nobody votes because it's generally winner take all, only two people can win, they're both assholes, and neither side of the aisle has said anything really new in about 30 years. That's your voter confidence issue, not that some faceless anarchist burnt your ballot, and tech cannot solve for that.
Well.. he's on our [team page]([https://galois.com/team/evariste-galois/](https://galois.com/team/evariste-galois/). If that makes him alive to you then great!
I was recently thinking about (in Scheme, initially) how it's seemingly so difficult to define the function square without referring to the passed argument, ala concatenative programming. Then, I asked for the point free code online to see if Haskell could help me out: (*) &gt;&gt;= id I'm completely baffled. Even :t just gives: Num b =&gt; b -&gt; b can someone please explain? I understand (a little) bind, such as how it takes a value wrapped in a monad **m a**, feeds that through a function like **(\\a -&gt; m b)** and return the **m b**. I'm just confused as to how that's being applied here to achieve a squaring function. Is the monad functions under currying, with "function" being the **m** and the **a** being the integer? If I try and understand it it in the sense of the kind of sequencing that happens in a **do** block: do (*) &lt;- 5 ... ? that's, sadly, how my thought process goes. Thanks :)
Is there something similar for programming languages in general? I’m on the Cornell PL Discussion Group mailing list. Something in GitHub repo form would be convenient.
[https://steshaw.org/plt/](https://steshaw.org/plt/) but those are mostly books, videos from conferences like OPLSS ([https://www.cs.uoregon.edu/research/summerschool/summer18/topics.php](https://www.cs.uoregon.edu/research/summerschool/summer18/topics.php)), not papers Be aware - those can strip you off from free time for months/year(s) or alter your career path :)
Oooh! Nice! (But you know what, this already-useful list can be rendered an order of magnitude *more* useful if one were to add a BibTeX file, allowing for importing it straight into a reference manager!)
This is the best tl;dr I could make, [original](https://www.apnews.com/7e78189c21ce4a7cb7cb73432705c3ca) reduced by 88%. (I'm a bot) ***** &gt; Two of the three top U.S elections vendors have expressed interest in potentially incorporating the open-source software into their voting systems. &gt; Three little-known U.S. companies control about 90 percent of the market for election equipment, but have long faced criticism for poor security, antiquated technology and insufficient transparency around their proprietary, black-box voting systems. &gt; One election official who has been in informal conversations with the ElectionGuard project leaders is Dean Logan, who runs elections for Los Angeles County, the nation&amp;#039;s most populous, and is building an open-source voting system for it. ***** [**Extended Summary**](http://np.reddit.com/r/autotldr/comments/bmg18u/microsoft_offers_software_tools_to_secure/) | [FAQ](http://np.reddit.com/r/autotldr/comments/31b9fm/faq_autotldr_bot/ "Version 2.02, ~398668 tl;drs so far.") | [Feedback](http://np.reddit.com/message/compose?to=%23autotldr "PM's and comments are monitored, constructive feedback is welcome.") | *Top* *keywords*: **vote**^#1 **election**^#2 **system**^#3 **ElectionGuard**^#4 **Microsoft**^#5
Russia can't do space race. Not enough money even in pre crisis budget. Those rockets bankrupted USSR.... China can do space race. Russia already compromises USA elections so "FP race" wouldn't be a new thing either ;)
Lack of security is a thing. Foreign interference in elections electronic systems is a thing. Voters inability to vote is a thing. 2 million fraudulent votes is not. Everybody and their grandma understand that only software fit four the purpose can assure democratic elections. No need to make it political... unless nazi or communist or extre populist, but then you are not democratic oriented in the first place.
Thanks, I have seen those. I thought there might be something that just uses stack or something that I wasn't aware of as I don't want to learn nix right now.
Thanks for the explanation. This seems interesting. I'll see if I can get something to work.
First of all, the pointfree version you came up with is not really idiomatic. A much simpler version would be the partially applied exponentiation operator: `(^2) :: Num a =&gt; a -&gt; a`. What you have here instead, is an application of the monad instance of Haskell functions, which is just the `Reader` monad without the newtype wrapper. It is sometimes called "environment functor". instance Monad ((-&gt;) r) That is, any function `r -&gt; b` is a monad, the `m` being somewhat "hidden" via `r -&gt; b ~ (-&gt;) r b ~ (r -&gt;) b ~ m b`. In practice, this isn't terribly useful. Some libraries like `lens` make use of it, but *most* of the times it's just used for shits and giggles. You may use it in cases where you have a function that takes several other functions as arguments, and all of these functions again take the same argument. What I mean is this: &gt; fun f g h = do { x &lt;- f; y &lt;- g; z &lt;- h; return (x, y, z) } &gt; :t fun fun :: Monad m =&gt; m a -&gt; m b -&gt; m c -&gt; m (a, b, c) &gt; :t fun (*2) (*3) (*4) fun (*2) (*3) (*4) :: Num a =&gt; a -&gt; (a, a, a) Here, `fun` takes actually four arguments, but since all it does with the fourth argument is to apply it over and over again, we can shorten it using the monad instance. So we have &gt; fun (*2) (*3) (*4) 10 (20,30,40) But back to your example. You would express it in do notation like this: square = do f &lt;- (*) f Okay, what's going on here? In `f &lt;- (*)`, or more generally `b &lt;- mb`, you bind the result of a monadic computation of type `m b` to a name. The `m b` is the multiplication operator `Num b =&gt; b -&gt; b -&gt; b ~ Num n =&gt; n -&gt; (n -&gt; n) ~ Num n =&gt; (-&gt;) n (n -&gt; n)`. So `m ~ Num n =&gt; (n -&gt;)` and `(n -&gt; n)` is the result of your monadic "computation" `(*)`. You can simplify this somewhat by substituting the `Num` constraint by something "smaller" like `Semigroup`. If you have `Semigroup g =&gt; g`, you only know that you have some type `g` for which an (associative) operation `(&lt;&gt;) :: g -&gt; g -&gt; g` is defined. You have no "neutral element" like in `Monoid m`, where you can pull a new value of type `m` out of thin air. What I'm getting at is this: &gt; :t do { f &lt;- (&lt;&gt;); f } do { f &lt;- (&lt;&gt;); f } :: Semigroup b =&gt; b -&gt; b If I substitute `(*)` with `(&lt;&gt;)`, I have a function of type `Semogroup b =&gt; b -&gt; b`. Just from looking at this type, I can see what this function does. When I pass in the `b`, it can only make one assumption about it: It can be applied to `(&lt;&gt;)` somehow. But what is the second value to use with `(&lt;&gt;)`? There is none, and it can't construct a new one either. So the only thing left is to spit out a `b &lt;&gt; b`: &gt; fun = do {f &lt;- (&lt;&gt;); f} &gt; fun ['b'] "bb" &gt; import Data.Monoid &gt; getProduct (fun 2) 4 This got way longer than intended, hopefully you can make sense of it somewhat.
Does anybody see on their [Linux](https://www.haskell.org/platform/linux.html) page from where to download source tarball ? I only see the mention of it, there is no obvious (to me) link to download source tarball.
Not sure how helpful this will be, but it has to do with (-&gt;) being our instance of the monad in your case, so, looking at the type signatures and replacing m with ((-&gt;) r) we get: (*) :: Num a =&gt; a -&gt; a -&gt; a id :: b -&gt; b (&gt;&gt;=) :: Monad m =&gt; m x -&gt; (x -&gt; m y) -&gt; m y (&gt;&gt;=) :: ((-&gt;) r) x -&gt; (x -&gt; ((-&gt;) r) y) -&gt; ((-&gt;) r) y rewritten in infix and getting rid of unnecessary parentheses and copying the definition of instance Monad ((-&gt;) r) in GHC.Base: (&gt;&gt;=) :: (r -&gt; x) -&gt; (x -&gt; r -&gt; y) -&gt; r -&gt; y f &gt;&gt;= k = \ r -&gt; k (f r) r in your case we can see: (*) &gt;&gt;= id = \b -&gt; id ((*) b) b (*) &gt;&gt;= id = \b -&gt; id (*b) b (*) &gt;&gt;= id = \b -&gt; (*b) b we partially apply bind with (*) we get: r ~ a x ~ (a -&gt; a) (&gt;&gt;=) (*) :: Num a =&gt; ((a -&gt; a) -&gt; a -&gt; y) -&gt; a -&gt; y Seen another way, if we partially apply bind the other way with id (by flipping it) we get: flip (&gt;&gt;=) id :: Monad m -&gt; m (m b) -&gt; m b which happens to be join: join :: Monad m =&gt; m (m b) -&gt; m b and if we consider again that (-&gt;) is our monad: join :: (a -&gt; a -&gt; b) -&gt; a -&gt; b join f = \a -&gt; f a a so it's taking a binary function and returning a unary function by duplicating its argument.
Can we get a mod to add this and the other post to the sidebar?
The `mwc-random` package aims to be fast and general. The distribution you want is [here](https://hackage.haskell.org/package/mwc-random-0.14.0.0/docs/System-Random-MWC-Distributions.html). There is also the `random` package, which I found to be very slow, unfortunately.
Thanks for your advice!
sorry to hear the last guy didn't last long
[removed]
[removed]
This is a fairly standard approach to this problem Haskell. Some other languages, for example Idris, support more than one instances for a given type. It is a very delicate situation, both versions have their advantages and disadvantages, but this simple trick can achieve quite a lot in the Haskell world (if you feel adventurous, check out the DerivingVia language extension!)
[removed]
As an experienced developer but a new Haskeller (so new programmer again in a way) what if anything can I do or should be focusing on to change this situation? I am not currently interested in any type of web type technologies such as using React or Purescript with electron since I prefer a native solution and want to avoid bundling a browser for my application. The quote &gt; that most Haskell programmers interested in applications programming have collectively decided to concentrate their efforts on improving Haskell web applications instead of standalone GUI applications. Honestly, that's probably the right decision in the long run. Really surprised me. Desktop applications are not going anywhere anytime soon and just see the mess and backslash caused by electron apps. Don’t take me wrong they work reasonably well and are cross platform but not a serious contender to a native app. Atom, VSCode all these free awesome editors but still people use Sublime because is fast, way faster than any electron app. Looking at Rust which has the same issue the community is actively trying to [change](https://areweguiyet.com/newsfeed/2019-01-13_rust2019.html) it which will only help it became even more popular, why is the Haskell community not doing the same? How can we expect more people to take up the language if they can’t create a UI using an awesome Haskell made UI framework geared for native apps? Although I am new to the ecosystem i feel passionate enough about Haskell to want to try to change this situation. Are my efforts futile? Is this the wrong language to create native desktop apps with GUI? Should I just use a different language and keep Haskell for cli server apps? This is my first comment ever on the Haskell subreddit and want to hear the community’s feedback. If there are any efforts towards this goal please let me know, I would love to contribute once I can properly use Haskell.
[removed]
There's something perversely wonderful about this. What is it being used for, if anyone knows?
\`cabal.project\` certainly seems to be the key. Your second example (ie. develop a multi-package project) works perfectly for me, and in hindsight I should have [RTFM](https://www.haskell.org/cabal/users-guide/nix-local-build.html). The first looks to be the solution for the general case of installing a library from source, though I haven't tried it (yet).
Nicely written. Looks like wire is a good place to work 🙂
Very, very tempting.
 main :: IO () main = putStrLn "5 + 1 = 6"
That's super short. Nice!
I just started playing around with Haskell I did not even know you could do this?
🙂 If you want more details, PM me here – or anywhere else where it's convenient for you ([yom@artyom.me](mailto:yom@artyom.me), or @lightgreen on Wire/Telegram, or @availablegreen on Twitter).
Well, the original snippet is odd because the end behaviour is statically apparent, hence why u/Syrak can optimize/simplify it to write it down with no mutability or conditionals.
I probably should have picked a better example, or expanded on it a bit. I can see what you mean, mutability is uneccary within my code. Thanks for pointing these things out, I am a bit of a noob and the feedback really helps.
I think you can just leave your email address without formatting, mr Ём@Артём
Don’t use Cabal hooks, if you can’t avoid it. In this case, most `npm` libraries are ”pure JavaScript”; install them on your development machine and bundle as is in `data-files`. `build-type: Simple` (pun intended). But if you need to depend on native Node modules, rethink what you are doing :)
Or if you want the exact imperative translation to Haskell: `import Data.IORef` `main :: IO ()` `main = do` `ref &lt;- newIORef 5` `modifyIORef ref (+ 1)` `x &lt;- readIORef ref` `putStrLn $ "5 + 1 = " ++ show x`
I’m not affiliated with Tweag, but I have a use case for something like that (I almost wrote a pipe communicator with node.js repl; which is quite simple actually). I’d like to test JS module against reference implementation (obviously in Haskell). Use QuickCheck and other niceties of Haskell.
Or, if you want the exact imperative translation to Haskell: import Data.IORef import Control.Monad main :: IO () main = do ref &lt;- newIORef 5 x &lt;- readIORef ref when (x == 5) $ do modifyIORef ref (+ 1) y &lt;- readIORef ref putStrLn $ "5 + 1 = " ++ show y
Is it \[this\]([https://www.haskell.org/ghc/download\_ghc\_8\_6\_5.html#linux\_x86\_64](https://www.haskell.org/ghc/download_ghc_8_6_5.html#linux_x86_64))? 5 hours later, so maybe it wasn't posted when you asked. Not sure.
Is there some implementation overlap between the `inline-*` packages, or is it just a standard of convenience the packages aim for? It would be nice if there was a place to go to if you want to learn how to implement your own `inline-X`. Is there?
Thanks for the reply, although that's not it. I'm not talking about GHC source tarball, but rather Haskell Platform source tarball.
Last time (2017?) I checked `inline-r` source was quite simple to follow. The difficulties aren't really on Haskell side, you rather need to read *Embedding **X** in another application*; e.g. - https://docs.python.org/3/extending/embedding.html - https://www.lua.org/pil/24.html - ... You'll also need to do marshalling from **X**'s data structures (some `C` structs probably) to Haskell's. And in R example, there are ways to have cheap marshalling of primitive data, e.g. something like Vector of Doubles; which are common for R use case; the OP post also mentions `ByteString` and `JSVal`. I'd say, that as a task not much different than writing a parser `FromJSON` parser; depending on **X**'s API documentation though. QuasiQuoter is a bit more tricky, as you'll need to *parse* **X**; in this JS case Tweag seems to do just lexing; anyway, whatever works :) So TL;DR if you can embed language **X** into C-program, you'll be able to embed it into Haskell too. And actually the OP mentions most if not all parts. OTOH, to make a complete package, it takes quite a lot of time.
The sophistication was super useful in knowing what to prove, and where to look for reasonable conjectures. Not useful for getting people to understand and see that there is pragmatic value here -- which is what blog posts like yours do very well. We've also started doing some of the "full" explanation to HoTT -- see [From Reversible Programs to Univalent Universes and Back](https://arxiv.org/abs/1708.02710). But the combinatorics explode really fast, so while the approach works for small types, we'd need something else to keep going.
Looks more like a devops than a full time haskell programming job to me. Or the job description is a bit confusing. You should clear that up if you are willing to hire a full time software engineer. Also, artyom, the guy who did the template haskell talk last year? :)
Indeed, QuickChecking a piece of JS code against a Haskell reference implementation is a nice use case. We wrote inline-js as the Haskell/Node interop layer for the asterius hs-to-wasm compiler project, for stuff like TH or tests, and we thought the inline-js part is stabilized enough for an announcement, and it can be useful for lots of other projects.
Nice pun. Making it a Cabal hook makes a single `cabal new-build` or `stack build` command works out of the box, instead of an extra `npm install` though.
It depends. Single `npm install` on a developer machine before `sdist`. Or N `npm install`s on users machines. Also, I recommend only using `cabal v2-build` for *Haskell* parts, maybe as a part of bigger build process. Orchestrated by `make`, `shake`, `nix` or whatever. `Cabal` hooks are **terrible** something-I-won't-even-call-a-build-system.
Other than not working well with cross compiling (which Moritz Angermann reminded me about), what other factors make you hate Cabal hooks?
This is the first issue to use the new Bootstrap-based design. Check it out and let me know what you think!
`a { font-size: 1.2em }` Just my humble opinion.
There's an FP Complete [blog post](https://www.fpcomplete.com/blog/2015/05/inline-c) on `inline-c`, and several `inline-java`/`inline-r` related Tweag blog posts ([0](https://www.tweag.io/posts/2016-10-17-inline-java.html), [1](https://www.tweag.io/posts/2017-08-17-inline-code.html), [2](https://www.tweag.io/posts/2017-09-15-inline-java-tutorial.html), [3](https://www.tweag.io/posts/2017-09-22-inline-java-ghc-plugin.html), [4](https://www.tweag.io/posts/2015-09-08-programming-r-at-native-speed-in-haskell.html), [5](https://www.tweag.io/posts/2017-07-10-haskell-r-best-both-worlds.html)). In general, `inline-*` is just a naming convention, but there do exist some common patterns in such packages: managing references on different heaps, TH tricks, etc.
The *not working well with cross compiling* is a symptom of bigger problem, that `build-type: Custom` isn't declarative; it could do potentially anything. In cross-compilation you are forced to think more about things which accidentally happen to work. E.g. in this case, do you need to `npm install` on host or target machine? With declarative "bundled JS files" approach: you don't care (assuming it's only JS, without native dependencies). Another thing is that `npm install` isn't really integrated into `cabal v2-build` or `stack build`. E.g. rebuild triggers; so if you change `package.json` like dependency definitions, would the packages be reinstalled? or would you `npm install` on every `cabal v2-build`? You'll also need to check that `npm` is installed on target machine (which in CI won't be actually used for anything). As far as I understand, you don't need `npm` to *use* `inline-js`, do you? I.e. a very little developer convinience for (IMHO) huge user downsides.
Here is a slightly more involved example. To print the sum of the even numbers between 0 and 10 in C: #include &lt;stdio.h&gt; int main (int argc, char **argv) { int i; int sum=0; for (i=0; i&lt;=10; i++) { if (i % 2 == 0) { sum += i; } } printf("%d\n", sum); } vs Haskell: main = print . sum . filter even $ [0..10]
Yep, this is more of a devops job than a full time Haskell programming job: &gt;You can expect to spend 20% of your time working with Haskell — investigating and fixing bugs, hunting down memory leaks, and contributing to our custom tools. (NB: In fact our codebase is simple enough that we feel comfortable saying "if you don't know Haskell, we'll teach you" – the amount of Haskell *expertise* we require is not particularly significant. That means that all of us spend at least as much time on non-Haskell stuff – reading specs, designing features, managing infrastructure, etc – as we do on Haskell stuff.) &gt;Also, artyom, the guy who did the template haskell talk last year? :) Totally me.
God damn Haskell is so damn seductive. That is awesome actually!
I am trying to decide between learning Haskell, Rust, or Both at the moment, but when I see these things that Haskell can do, I am just in awe.
Sorry for the late response, I was having fun playing around with your code. :)
Very cool :D
 main() { (0..=10).filter(|x| x%2 == 0).reduce(|a,c| a+c).collect() } Rust's version :) Both are fantastic languages. I'd pick rust first, quite honestly, just from it's larger ecosystem and easier access to beginner resources, but Haskell is my first love
Let's take one of the best languages ever made and then allow you to use the worst language ever made inside of it!
Don't use the random package. It isn't even statistically good
JS isn't that bad. It's not INTERCAL or Malbolge.
*"Finally, there are no linux generic builds provided, and instead we recommend use of the ghcup tool (*[*https://github.com/haskell/ghcup/*](https://github.com/haskell/ghcup/)*) in combination with the stack install script. We feel this gives a smoother and better experience than the existing install process, being less invasive (not requiring root) and more flexible (by running ghc's own configure script it can better detect differences in configuration between distros)."* ([Source](https://mail.haskell.org/pipermail/haskell-cafe/2018-December/130371.html))
main = putStrLn ("5 + 1 = " ++ show (5 + 1))
Absolutely!
Damn that is some sexy syntax. The thing though is that when I was looking for examples for Rust and Haskell, I could not seem to find as many for Rust and for me that is essential, so I can take apart that example and make something new from it. It might just be the way I am searching though.
You can build Reflex to run natively, and it can start a webkit view that it will control. It's extremely fast (way faster than GHCJS).
Do you know of some sites that would help me with this?
A one liner, nice. Thank you boss! :D
You're talking about two languages that were INTENTIONALLY designed to be horrible and no one uses except as a joke or a challenge. So, sure, JS isn't as bad as those two, but it wasn't intentionally designed to be bad and it is a backbone language for web development.
The v2 commands don't work with the nix integration which iirc tweag uses.
Huh?
Here's a repo from one of the channels I'm in: https://github.com/dpndnt/library
Here's another take, using a `where` clause, an `if`/`then`/`else` and a `let`/`in`. Note that an `if` in Haskell always needs an `else` (because it always needs to have some value) and `mempty` in this case is the IO action that does nothing (although it's actually something more general and can be used with other things, not just IO, hence the weird name). main = if x == 5 then let x' = x + 1 in print ("5 + 1 = " ++ show x') else mempty where x = 5
Great list. It would be nice to have full paper title with year and authors list so it will be possible to find paper in case of link rot (and to see more details before opening the link).
Thanks for the note. The tag is in place now with the latest commit in the repo. As noted below, we really don't see a reason to continue to provide the source tarball since moving to ghcup as the recommended generic linux installer. The website should be cleaned up to no longer have that link. There's nothing the generic linux installer did that ghcup doesn't do somewhat better (except, I suppose, package things up such that no additional downloads need be made).
[Rosetta Code](http://rosettacode.org/wiki/Rosetta_Code) For Example: 100 Doors in [Rust](http://rosettacode.org/wiki/100_doors#Rust) vs [Haskell](http://rosettacode.org/wiki/100_doors#Haskell)
Thanks. Cleaning up website to remove outdated text sounds good. I will checkout `ghcup`.
I haven't heard of `ghcup`, so I will check it out. I'm on FreeBSD, that's why I was hoping for source tarball to be available like previous times. Thank you.
JS is better than PHP
I tried to look this up and only found a [thread](https://www.reddit.com/r/haskell/comments/7ma9rd/in_your_professional_experience_how_suitable_is/) from a year ago. The link to the *rant* that supposedly clarifies things is gone, but the discussion is interesting nonetheless. It's a shame that the issues are not apparent from browsing the API docs on hackage.
Paging /u/cartazio - It has been 5 years since Edward uploaded the last version (not revision). Three years since you and I e-mailed about just switching random to `tf-random` but it was argued the new random would be out any day. I know maintaining is tiresome - are you wanting to shed the package? It would be good if the community had something statistically good, light weight dependency wise, and fast under the `random` package name.
Definitely. But Javascript is objectively *not* the worst language ever, from a language design standpoint.
THANK YOU for putting the geographical location in the title. This is essential to know and I'm not sure why lots of people tend to bury this info in job postings. Looks interesting. _Please do_ overthrow skype/slack with open source things &amp; end-to-end encryption.
It has, by far, the highest product of stupidity and usage of the languages.
Maybe barely. They're both absolutely terrible languages.
 removeOneElem :: [a] -&gt; [[a]] removeOneElem [] = [] removeOneElem (x:xs) = xs : map (x:) (removeOneElem xs) --- &gt; removeOneElem [1,2,3,4] [[2,3,4],[1,3,4],[1,2,4],[1,2,3]] &gt; removeOneElem [[1,2,3,4],[5,6,7,8],[9,0,1,2]] [[[5,6,7,8],[9,0,1,2]],[[1,2,3,4],[9,0,1,2]],[[1,2,3,4],[5,6,7,8]]] Use that instead of tail, and fix up the type errors, and you should be fine.
Your extra paren appears to be borking the email embed.
From a cultural impact stance, it has some good arguments in its favor to be the worst language.
Hm, must be Reddit's design shenanigans – it works just fine in the new interface. Fixed.
In a shocking turn of events that surprised nobody at all: Reddit interfaces aren't consistent, or terribly high functioning
&gt; Just out of curiosity, what are you trying to do which requires interacting with multiple pages that can't be in iframes? No worries if you can say, I just can't think of such a problem off the top of my head. I would like to implement a tool for easier posting to multiple different social networks, e.g. Twitter, Gab, Minds. I don't want to rely on their limited and often unreliable APIs (for example it's common Twitter fails to post a tweet) and also there is an issue where different social networks have different limitations on for example post length, how is post length calculated, what media are allowed and so on. I would like to create a tool where you could write a post and you could see the text being propagated to all those showed social networks, having a real preview (often an issue with these multi-network apps) of what actually gets posted and then the user would either tweak and manually post on each social network, or after confirming everything looks fine clicked on one button in the GUI which would trigger a posting action in all those webviews. Maybe a stupid idea, but I thought it could a fun (hopefully) little project :). &gt; And yeah, I find it strange that there is such little emphasis put on the fact that reflex-dom can create desktop apps. The GUI story in Haskell is pretty weak at the moment: people are working hard and their efforts are greatly appreciated but there is still much to do. Good easy to use GUI libraries are hard, complex and very time-consuming to create. I can understand why we don't have much of them. I read some people argue FP is a bad fit for UI, that OOP is much better, but I believe it can be done well even in FP. For example JavaScript FE world is closing to pure FP with each year. If I understand the terms correctly, combinations of some libraries, like React + Redux + Redux-Saga + Redux-Form, (when well used) form essentially an FRP UI application. &gt; Although using web tools for GUIs isn't ideal, still feels the best way of making a user facing application in Haskell Sure, not ideal, but as a JavaScript dev by day, I gradually shifted from a position of "performance purist" to being more pragmatic. In my opinion it is better we have a lot of a bit heavier applications, than having only one or two applications which can run on a dishwasher. While it's more wasteful when measured from the point of an environment, users are (I believe) happier because of the selection and developers are happier because of the languages/libraries selection and also overall easier/more enjoyable development.
The symlink wasn't meant to sandbox it, I merely don't have enough free space on my system/home partition. I didn't expect ~100GB partition on SSD would not be enough for Linux, but all those packages and dev things add up very quickly. For example using Haskell with Stack: `.cabal` has 3GB, `.stack` almost 15GB and I am not doing any serious Haskell development, just few hours a week playing with tiny simple toy projects. I won't make the same mistake with a new PC :). BTW Someone here posted how to make nix work even with a symlink (special env variable), so I might give it another shot.
Ah ok that's a fair point, in that case yeah glad someone could help you out with that.
Those screenshots there don't look bad at all. Honestly, if it would work, I would not care about visuals as long as it is reasonably usable for an average user (intuitive, following UI conventions like for example tab switching between widgets). &gt; Good luck! Thanks, I will need it 😁.
Well, you Solution is only half right. If you read again, I must return a list of all possible deletions on both, rows and columns. But thank you for that, I might get a solution from this.
I am porting (rewriting) an insurance and banking product; backend was written in PHP and frontend in JS. BOTH do calculations that actually determine what people should pay, transfer etc. I am discovering the most insane bugs... For instance, many off-by-one-cent amounts. What a horror show. And this is not the only product I did in the past years; many MANY of the 'new and hip' fintech / insurtech companies did their backends in tech that really is not suitable for it (ofcourse you *can* but you need to be far more careful than with more suitable languages, like Haskell, Ocaml, F#). The previous system I rewrote before this one was an actual card transaction system (you know, something *all* their customer card transactions go via...) built with PHP. Another nightmare!
The ecosystem however... I mean, if you would have explained NPM to me 20 years ago, I would have laughed in your face...
&gt; you Solution is only half right. I wasn't giving a solution, just hints at parts. &gt; I must return a list of all possible deletions on both, rows and columns I gave an example of using `removeOneElem` to remove one column from a single row. I gave an example of using `removeOneElem` to remove one row from a single matrix. You should be able to combine them to get the results you want, and I welcome further questions.
You're welcome. I'm also in agreement with the some others in this thread in that Haskell is currently not very good at the kind of thing you're trying to do. Unless it's providing some concrete benefit I would recommend looking elsewhere, eg. [Free Pascal](https://www.freepascal.org/) is great.
I'm not really concerned about speed tbh (or even _that_ concerned about correctness). It's just for a silly side-project/proof of concept. Thanks for the recommendation. I will check out `mwc-random`
Oh, dear god. Let us have a moment of silence for u/terserterseness
[removed]
[removed]
`import Text.Printf; main = printf "5 + 1 = %d\n" (5 + 1)`
I'll have a look into this. Thanks a lot
[removed]
Is Depeche Mode techno?
[removed]
Too many words. Looking for hypnotic effect to aid flow state. Right now I use Bach, but looking for something else.
Right. I’m not sure though how that answers my question. :)
Generally I prefer to code in silence, but if I'm really in the mood for techno I listen to this : http://radio.lclhst.net/
Drink the Sea (album) by Glitch Mob Certain Deadmau5 songs are good. The Interstellar soundtrack The Mr. Robot sound track.
Tempting indeed; although I qualify technically (and speak German as well) and would like to live in Berlin (I live in NL), I am more looking for a hands on tech lead/cto position with a Haskell shop. If anything like that would ever open up there ;)
I sometimes start Drone Zone on SomaFM, works the best for me, especially when coding late at night. During day some good soulful house from Pressure Radio
Solar fields is great https://youtu.be/yQjove0nzss
I have made a [youtube playlist](https://www.youtube.com/playlist?list=PLaCTw5-DLRXuiWQMgD3lcU_A9ycOCO8YL) specifically for my coding / art sessions. It features a lot of really good flow-y techno (although the Axiom Verge OST and Rise of the Obsidian Interstellar are kind of intense, I might skip those if you're looking for more peaceful stuff).
Juno Reactor
&gt;and speak German as well Just wanted to clarify (for other people reading the comments): we absolutely don't require German, and a significant chunk of people at Wire, including me, haven't really bothered learning German. &gt;I am more looking for a hands on tech lead/cto position with a Haskell shop Yeah, we don't have that just yet. Can you send me your CV anyway, though? There's a possibility we might have a tech lead–like position in the future.
&gt; we absolutely don't require German It is just because I am Dutch : I did not really do anything for it ;) I will send over my resume, sure, thanks for checking!
Awesome (and awesomely detailed!) job description. If only advertisement was driving what I do, I would most definitely apply!
While it's not techno, I absolutely love to listen to [this classic](https://www.youtube.com/watch?v=dQw4w9WgXcQ) when coding.
Mostly into mixes. Individual track kind of defeat the whole idea behind techno IMO. Lately I got more interested in downtempo/deep over straight up techno/tekno. I keep a list of mixes i like here: [https://soundcloud.com/cies010/likes](https://soundcloud.com/cies010/likes) I has like several weeks worth of music, from very mellow 90bpm stuff and up. Enjoy!
❤️ ^(Seriously, that description took a kinda long time to write)
My friend makes funky vaporwave as [FM Skyline](https://fmskyline.bandcamp.com/). Not sure if that's the sort of "hypnotic/flow" you're looking for.
Some long time ago I realised that a great many of game OSTs (especially RTS and TBS ones) were composed specifically for deep immersion into "repetitive-yet-creative" multi-hour game sessions, which is quite close to coding. A few of my favourites are below: * C&amp;C Tiberian Sun - [https://www.youtube.com/watch?v=IBp0Pu3NeOo&amp;list=PLamnoxId\_aK2qxsln0OiDh9s3Pa1vgfvb](https://www.youtube.com/watch?v=IBp0Pu3NeOo&amp;list=PLamnoxId_aK2qxsln0OiDh9s3Pa1vgfvb) * Emperor (Ordos &amp; Harkonnen): * [https://www.youtube.com/watch?v=NOmX6HmGp0U&amp;list=PLC310CFE6BA0A6281](https://www.youtube.com/watch?v=NOmX6HmGp0U&amp;list=PLC310CFE6BA0A6281) * [https://www.youtube.com/watch?v=WkL4jTLG9EU&amp;list=PLEE2FD4BF340574A1](https://www.youtube.com/watch?v=WkL4jTLG9EU&amp;list=PLEE2FD4BF340574A1) * Paradise Cracked - [https://www.youtube.com/watch?v=YF9kyMVz1S4&amp;list=PLJFKIKXmiXfmCfysLPnKJVMZCSZUBtWco](https://www.youtube.com/watch?v=YF9kyMVz1S4&amp;list=PLJFKIKXmiXfmCfysLPnKJVMZCSZUBtWco) * Selection of tracks of VHS Glitch like [https://www.youtube.com/watch?v=wRve8Gsby5o](https://www.youtube.com/watch?v=wRve8Gsby5o) * Road Rash II - [https://www.youtube.com/watch?v=jVbb4ygChjo](https://www.youtube.com/watch?v=jVbb4ygChjo)
Hi, I'm a bot. I combined your YouTube videos into a shareable highlight reel link: https://app.hivevideo.io/view/ffee6f ^^You ^^can ^^play ^^through ^^the ^^whole ^^playlist ^^(with ^^timestamps ^^if ^^they ^^were ^^in ^^the ^^links), ^^or ^^select ^^each ^^video. ^^Reply ^^with ^^the ^^single ^^word ^^'ignore' ^^and ^^I ^^won't ^^reply ^^to ^^your ^^comments. ***** [Contact](https://np.reddit.com/user/multiplevideosbot/)
Can you explain the reason behind not providing the "full builds" (as opposed to "core builds")? Personally, I thought that the full builds were in fact the best thing about the Haskell Platform (at least on non-linux platforms, where some of the "standard" libraries were hard or next-to-impossible to build - though my experiences are probably outdated).
&gt; http://radio.lclhst.net/ Thanks :)
The Algorithm: https://intothealgorithm.bandcamp.com/ Progressive Dark Synthwave Post Avant-Garde Neo-Glitch Metal
Haskell does not seem like that hard of a language. It looks kind of fun to be honest. Do you mean it always needs to return some value? Maybe mempty is like return 0 in c++.
Thank you!!
I'm from Scandinavia, so have to mention Swedish techno first. (Maybe that's better for programming Agda though?) [Drumcode](https://www.discogs.com/label/237-Drumcode) label has very programming friendly name, if nothing else. [Adam Beyer's BBC Essential Mix from 2002](https://www.youtube.com/watch?v=-l0KORbUIGw). It feels that Netherlands is strong Haskell, so is their techno. Recently I listened few times to [Charlotte de Witte @ Time Warp 2019](https://youtu.be/C-BTk5TPd9I?t=5557). (the track at cue is [Eats Everything - Space Raiders (Charlotte de Witte Remix)](https://www.youtube.com/watch?v=uTvL1G7yw3w); sadly it's not *Eats Everything - Space Leaks*) One of my all time favourites is [Dave Clarke's World Service](https://www.youtube.com/watch?v=-F3eqBtclE4) from 2001. [Second CD](https://www.youtube.com/watch?v=9KlzTWcDz3U) is great electro set, if you like electro too. Laurent Garnier is another legend, [his recent mix](https://www.youtube.com/watch?v=xT-3DzRjscw). Because this year's ICFP is in a Berlin, let me mention [Rødhåd](https://www.youtube.com/watch?v=WiOG0Ov12wY). The boiler room concept is weird, but reminds this: https://pbs.twimg.com/profile_images/700338266604593153/UXezu_zY_400x400.jpg [The Exhibitionist Mix by Jeff Mills](https://www.youtube.com/watch?v=vtw2-kL32YM) is an art piece. First time you have to watch the perfomance, not so good for coding. On the second listening try to keep up coding as fast as Jeff mixes new tracks. More recent [TR-909 Workout](Jeff Mills Exhibitionist Mix 3 TR-909 Workout) is superb live drum machine *programming*. Slovenian Umek sounds like nothing else, [his BBC Essential Mix](https://www.youtube.com/watch?v=HRB76vaDvkQ). Or Russian [Nina Kraviz](https://www.youtube.com/watch?v=JnUB1e9R_G4). I'm lazy, posting radio mixes, but that is what you asked for: "background music". One could debate what's techno and what's not for probably as long as about "what's functional programming". I think the above is techno at its purest ;)
If we’re using the `(-&gt;) x` monad instance, I’d prefer to write this as `join (*)`, since `join :: (Monad m) =&gt; m (m a) -&gt; m a` with `m ~ (-&gt;) a` gives `(a -&gt; a -&gt; a) -&gt; a -&gt; a`—take a function of two parameters, and one argument, and pass that argument for both parameters of the function. (Moreover, this is essentially the CPS version of `dup` in a concatenative language.) If you’re familiar with `Reader`, this is equivalent, just without the `newtype` wrapper—so you could also use `liftA2 (*) id id` or `(*) &lt;$&gt; id &lt;*&gt; id`, where `id` functions as `ask`, fetching the “environment”.
It's not all Techno. [Ken Ashcorp](https://play.google.com/music/r/m/Ahld2hhi7zl2syrtlbqvn5sweqq?t=Ken_Ashcorp) [VG Tributes](https://play.google.com/music/r/m/Txajfcgd34gqqvyio3sv2a6vegq?t=No_Mercy_feat_BlackGryph0n__LittleJayneyCakes_-_The_Living_Tombstone) [Pegboard Nerds](https://play.google.com/music/r/m/Bvw4yaleimjitxjecpkqpb4maei?t=Pink_Cloud_The_Remixes_-_Pegboard_Nerds) [Tristam](https://play.google.com/music/r/m/Tjffhu67sf4g5nql7knqcugi3ay?t=The_Vine_-_Tristam) [Lindsey Stirling](https://play.google.com/music/r/m/Tnwfpr3msb5wymmilz632jtqiby?t=Shatter_Me_Featuring_Lzzy_Hale_-_Lindsey_Stirling) [Avicii](https://play.google.com/music/r/m/Atrxtalf4tqdl5f2tdq4zv7oriy?t=Avicii) -- RIP o7 [Anamanaguchi](https://play.google.com/music/m/B4ojpmt44nkmy23k32ecfnovtoy?t=Endless_Fantasy_-_Anamanaguchi)
What's in Section 3 that you understand that's not in Section 2? ;P If you want an interactive conversation, I recommend the Haskell IRC or Discord, both are linked from the sidebar.
This is also a really obvious use case for Data.Function.on, if you want to be point-free but also fairly easy to read.
I sincerely believe one should always, as an exercise, completely overdo it with a particular style. It gives you a much better idea of where exactly you think “too much” behind.
If you’re keen to make Euclid generic, check the type definition of sqrt.
Thank you! can I ask, as I'd rather understand as much as I can at each step before pressing on: what is **r** referring to and what is **-&gt;** ? Literally the **-&gt;** which appears in function signatures? If so, is it to be thought of as "carrying" arguments between functions? Thanks again. I can see it taking some time for me to grok this but I'm sure going to try.
Synth not techno but been listening to this album: https://www.youtube.com/watch?v=DY1s9SmrQRE
This was discussed in the 8.6.3 announcement. &gt; Second, only core builds are provided, not "full" builds. This release is the first one where cabal-install warns on legacy commands and asks users to either use the v1-prefix for them or the v2/new prefix to move to the new-build system. As such, providing additional global packages outside of the core set now makes even less sense than in the past, where we had been already discouraging it for some time. In short, on the one hand pervasive sandboxing (and nix-style sandboxing with new-build) means that globally installed packages are less good/useful on the one hand, and on the other, significant improvements have been made to try to ensure that most standard libraries are easy to build directly on most platforms. (i.e. for the past three years or so, `network` has built on Windows just fine with the standard platform install instructions).
If you like Bach, have you listened to Glenn Gould's Goldberg variations? Are you a fan of minimalism? Steve Reich's Music for 18 Musicians is great for coding. Finally, for something techno-adjacent, try lane8's house mixtapes.
I recently discovered this: https://www.youtube.com/watch?v=ypknY6nIDe0 Currently listening to it while writing C.
[removed]
Acid Pauli mixes are great https://soundcloud.com/acidpauli/stille-einfugen
[removed]
nightcore
[removed]
[removed]
[removed]
[removed]
[removed]
I honestly prefer the old design, but great contents as always for Haskell Weekly.
Anything by Eric Prydz
Are you allowed to use libraries? Because this is a matrix problem. Take a look at Data.Matrix ([https://hackage.haskell.org/package/matrix-0.2.2/docs/Data-Matrix.html](https://hackage.haskell.org/package/matrix-0.2.2/docs/Data-Matrix.html)). The \`minorMatrix\` function looks useful.
\`\`\` import Data.List (transpose) &amp;#x200B; removeOneElem :: \[a\] -&gt; \[\[a\]\] removeOneElem (x:xs) = xs : map (x:) (removeOneElem xs) removeOneElem \[\] = \[\] &amp;#x200B; removeOneRow :: \[\[a\]\] -&gt; \[\[\[a\]\]\] removeOneRow = removeOneElem &amp;#x200B; removeOneColumn :: \[\[a\]\] -&gt; \[\[\[a\]\]\] removeOneColumn = transpose . (map removeOneElem) &amp;#x200B; main = print $ removeOneRow \[\[1,2,3,4\],\[5,6,7,8\],\[9,10,11,12\]\] &gt;&gt;= removeOneColumn \`\`\` \`removeOneElem\` should be pretty easy for you to understand. Returns a list of lists each with one element removed from the original list. &amp;#x200B; \`removeOneRow\` is just \`removeOneRow\` specialised to take an input of a lists of lists. &amp;#x200B; \`removeOneColumn\` is a bit more complex, but you should realise that removing columns is removing elements, so you should try starting with \`removeOneElem\`. Unfortunately instead of doing this to each row in sequence you kinda want to do combine the parallel results, and this is where transpose helps. Try doing it on paper and you'll get the gist. After you've got these building blocks just put them together. Bind (\`&gt;&gt;=\`) in the case of lists just does \`map\` and then \`concat\`s, the results, which is what you want. I know this might seem like a lot but I'm not sure how to explain it better, you're just going to have to get an intuition for how to compose these things, but reading the definitions and applying them with pen and paper helps, although it's initially time consuming. It's the only way forward though I think.
The Social Network soundtrack.
Use vector unless you can explain why you shouldn’t.
Unlifted ffi types are so you can write your own c minus minus code and call it from Haskell. Means you can do terrible amazing things in userland if you really step around carefully. It’s not meant for c code. It’s meant for c— code that touches rts /stack /heap for craziness:) I wrote / gave a talk about it 5-6 years ago that’s on my bit bucket https://bitbucket.org/carter/who-ya-gonna-call-talk-may-2013-ny-haskell/src/master/ The code examples should still be valid. Though there’s def been some changes in the past few years
[https://www.youtube.com/watch?v=t7BCyF3xiY0&amp;list=PLI87x69w0N7EG4Ing9rnwoT6W5Nywuabh](https://www.youtube.com/watch?v=t7BCyF3xiY0&amp;list=PLI87x69w0N7EG4Ing9rnwoT6W5Nywuabh)
Pretty Lights. Except Samso. I can't work while listening to that song: I enjoy the content fluid changes in that song too much for it to not take my attention. Any light trance or chillout style electronic music works. I'm assuming by "techno" you mean EDM. I would say actual techno is not a good choice for concentrating. It's too fast and distracting.
Yeah, it's totally fun, but it gets a bit mind stretching when you dive in a bit deeper. Haskell's if/then is more like C's ?: operator. So the equivalent is something like the following, where we can imagine a C where void can be used as a value: ``` void donothing() { return void; } void printx(int x) { printf("%d", x); return void; } void main () { return x == 5? printx(x) : donothing(); } ``` Although even then, the execution of the printx or donothing is delayed until main's value is required, because of lazy evaluation. So, even though main in C is also returning void (represented in Haskell as ()), the Haskell version is really returning an IO action that returns void (IO () in Haskell).
Aphex Twin or synthwave mixes on youtube
Bach is sooooooooooo choice my friend. Richie Hawtin Decks EFX &amp; 909 https://youtu.be/hbtQX8ZDyN4 Rhythm and Sound: https://youtu.be/Damfih85wW8 https://youtu.be/zwTeomRilOk Intrusion RA mix I have coded endless hours to https://soundcloud.com/resident-advisor/ra153-intrusion Tim Hecker https://youtu.be/qse2KT65ZcE Aphex Twin SAW2 https://youtu.be/gP0eIYkvKHM 36 https://youtu.be/TRnWcJ8toFc Harold Budd https://youtu.be/ZCp2zGoNo9Y
The Field: https://youtu.be/8o3TSCA5yYo
Not sure if you're looking for techno techno, or just electronic music, [how about some downtempo psybient?](https://open.spotify.com/user/edesjardins/playlist/4RM0lLZg9drq0scsIInkkh?si=nGf4MPyaRla604VtdqZl8Q), dub techno [https://fingersinthenoise.bandcamp.com/album/best-of-album-2xlp](https://fingersinthenoise.bandcamp.com/album/best-of-album-2xlp)
Spirallianz, Midi Miliz and Extrawelt. Lots of subtle complex details if you really listen, easy listening if code is in focus. Perfect!
Haven't used this one much with Haskell, but I'm recently putting this on shuffle/repeat: https://www.youtube.com/playlist?list=PLuqZTQ_5gsppMEJWlJoH327iOkKLtcNHX I think the words space and ambient already puts me in a decent mind set.
Haven't used this one much with Haskell, but I'm recently putting this on shuffle/repeat: https://www.youtube.com/playlist?list=PLuqZTQ_5gsppMEJWlJoH327iOkKLtcNHX I think the words space and ambient already puts me in a decent mind set.
So it is more like a ternary operator, wow. I did not realize that at all actually. Actually the more people tell me about the way Haskell approaches things the more I am intrigued.
The types may look scary at first, but if you specialize to `IO`, everything is simple again. `Gen (PrimState IO) ~ GenIO`. There is a minimal example under *Type Helpers*. Your generator comes either from `withSystemRandom` or from `createSystemRandom`, you just need to plug it into your pdf. I don't see a convenience function that returns a vector for a non-uniform distribution, but you could just use a `for_` loop or yolo it with `mapM` I guess.
Neovaii
Daft Punk Alive 2007 is the only album that does it for me.
** (-&gt;) ** is indeed Haskell's function type, e.g., the one on the function signatures above or in data/newtype types like: newtype Predicate a = Predicate {getPredicate :: a **-&gt;** Bool} It's a higher-kinded type parameterised by two types, if you input the following on ghci: :k (-&gt;) you get: (-&gt;) :: * -&gt; * -&gt; * The first parameter is the function's argument or input, the second parameter is the function's result or output. foo :: Int -&gt; Bool foo = even -- these are the same, just written infix above and prefix below bar :: (-&gt;) Int Bool bar = even Types parameterised by **one** type can be instances of Monad if they implement (&gt;&gt;=), that's why we fix the argument type leaving only the return type arbitrary; **r** is just the name I used for the argument type to make sure it didn't clash with any signature before. And yes, one of the main uses of the reader monad (i.e., the monad instance for (-&gt;)) is to pass implicit configuration/data through functions, which may read that data but cannot change it (hence the name reader monad). I genuinely have no idea which resources are the best to read about it, but a quick search should bring you a bunch of results to see if you find any good explanation. You may find interesting: * [https://wiki.haskell.org/All_About_Monads#The_Reader_monad](All about monads) * [https://eli.thegreenplace.net/2018/haskell-functions-as-functors-applicatives-and-monads/](Haskell functions as functors, applicatives, and monads) If I'm being honest though, I wouldn't worry too much about it at this point, you can always revisit this topic once you become more familiar with other areas. I'm not a Haskell/FP expert by any means (come from a Java background and wouldn't say I know that much in Haskell other than recursion/corecursion) and although I find these things insightful, potentially useful, etc. I'm much more interested in doing practical stuff, such as getting Kafka working so I can build a processor consuming/producing messages, most of my time than going down these deep rabbit holes.
If you are also into progressive/deep house, all the Anjunadeep mixes are great for coding.
Infected Mushroom Daft Punk Tron Legacy: Reconfigured OST Blue Stahli Roter Sand Or scroll through my playlist, but it's not 100% techno/electro: https://open.spotify.com/user/1121905787/playlist/07WKQ3F2LNiqUKvdsXleYn?si=7nfr7ksdQCO9eGDclLj0Ng
I find rominimal to be quite good. Check artists like Priku, Petre Inspirescu on soundcloud, youtube (Verzila channel is awesome, has lots of underground stuff to explore) etc. Here's a Spotify playlist someone made with some tracks https://open.spotify.com/user/alisarviii/playlist/2EDGhaYJAp3kumzHEtoChc?si=gQGSvFH_T5SlDsFJzGwhMw.
Melbourne deepcast https://soundcloud.com/melbourne-deepcast/mdc212-peach Instrinsic Audio Sessions https://soundcloud.com/intrinsic-audio-sessions/thomas-carmody-ias-podcast
 [https://www.youtube.com/watch?v=XqZsoesa55w](https://www.youtube.com/watch?v=XqZsoesa55w)
I don't think so, but I will use it if i'm unable to solve this
Thanks a lot. that missing \`transpose\` kept me from solving this :) This Solution is so easy, how do I learn to think like this? I'm usually programming in Python and as soon as I got a Problem like this I want to use a for loop :s
I'm trying to install Haskell on Fedora Workstation 30, but `sudo dnf install haskell-platfrom` [As Haskell's on website says](https://www.haskell.org/platform/linux.html#linux-fedora), but throws this error: `Error: Problem: conflicting requests - nothing provides ghc = 8.2.2 needed by haskell-platform-2018.8.2.2-15.fc30.x86_64` Thing is that the repos have ghc in the version 8.4.4-74, according to `dnf provides ghc`
Haskell has great introductory books like 'Programming in Haskell' and 'Haskell programming from first principles', [online courses](https://github.com/data61/fp-course), and chat rooms very friendly to/specifically created for beginners. It is possible Rust has more and better resources, but I don't see Haskell lacking at all.
If you have little/no experience with functional programming, I would strongly recommend going for the full-immersion experience and learn Haskell.
Yay!
I think yo are looking more towards generes like downtempo and IDM, instead of techno [Connect.Ohm - 9980](https://www.youtube.com/watch?v=mmxBoFzdqVI) [C418 - One](https://www.youtube.com/watch?v=wYNAZz86DVo) [Mike Oldfield - The Songs Of Distant Earth](https://www.youtube.com/playlist?list=OLAK5uy_m5EDNhJKHSZckJa6BUSIaeFgkO28OZ_v0) [José Manuel Guerra - Beyond The Sky](https://www.youtube.com/playlist?list=OLAK5uy_lkRSLi9pGRkTKPBZKtDdL1MuvMBVaBHNQ) [Jean-Michel Jarre - Les Chants Magnetiques](https://youtu.be/wyzXZ_NFVrg) [Daft Punk - TRON Legacy sondtack](https://www.youtube.com/playlist?list=PLI22HcuDE4_ATtCyenaJvZzD5Lv7ZAQV6)
&gt; Progressive Dark Synthwave Post Avant-Garde Neo-Glitch Metal niche^3 , checks out with the choice of programming language ;)
"A Hardware Accelerator for Tracing Garbage Collection" - Martin Maas, Krste Asanovic, John Kubiatowicz - https://ieeexplore.ieee.org/document/8695831 very interesting!
If you're into classical music and looking for techno, I think you'd really enjoy GAS. [GAS - Nah Und Fern](https://youtu.be/hPSYdqvcH88) It's not strictly techno; not sure what to call it but "Modern Classical", "Techno", "Ambient" are labels used to characterize this music. It feels like classical music slowed down 100 fold and crossed with sounds of a distant techno party emanating from the basement of a club at the end of your street. Another artist I think you'd like is Jan Jelinek (and his aliases: Gramm, Farben). Start with [Loop Finding Jazz Records](https://youtu.be/6hIgBEXuQD8). The title is a bit misleading, it feels nothing like jazz, but the samples from which it was built were sourced from jazz records. Also not really techno, but some beautifully textured ambient/electronic music that is impossible to categorize.
YES I second that
Also for hard real-time systems?
Why is `mock` in quickcheck-state-machine supposedly a hack? According to the [README](https://github.com/advancedtelematic/quickcheck-state-machine), &gt; mock is a hack to make it possible for responses to have multiple reference, and an experiment which maybe one day will let us create mocked APIs. See issue [#236](https://github.com/advancedtelematic/quickcheck-state-machine/issues/236) for further details. But mock seems fairly fundamental to me. How I would explain it: The tests work by generating a list of commands to run. It's important to do that without running any of the code to be tested - that code might not be pure, so `--seed` wouldn't work to reliably generate the same list of commands. The first command is generated from the initial model, but subsequent commands need to be generated from the model as updated by the previous commands. We have a transition function to update the model given a response. That means we need a pure way to get a response given a command, and that's what the mock function is for. This makes sense to me, and [the code](https://github.com/advancedtelematic/quickcheck-state-machine/blob/231cf632b435efa7caaaa3bb769ed9c371f0868a/src/Test/StateMachine/Sequential.hs#L156) looks like that's what's going on, too. But I don't understand the description in the README. It doesn't feel like a hack, and I don't really know what "make it possible to for responses to have multiple reference" refers to. (A possible interpretation might be, if each response constructor had exactly one argument which was a Reference, then we wouldn't need `mock`? But I don't see how that would be true without template haskell or something, which seems hackier to me than `mock`.) Am I missing something?
Whilst this is really cool, can someone help me understand the relevance to FP? This will just help speed up the adoption of all high-level languages, including Python, JavaScript, etc, no?
[removed]
Well, yes, but functional languages require garbage collection due to the presence of closures, so this is a useful development towards functional programming. It is true though that this probably isn’t going to push anyone from those other more popular languages to Haskell.
Nothing is better than practice. Just because a solution seems simple and elegant doesn't mean creating it was easy. What these solutions don't show is the experience underpinning them, gained by struggling with the same problems you're doing now. One piece of advice I can give you which I find very useful not just in functional programming, but programming in general, is to think about what the data looks like and what you want it to look like, and to look for small transformations that I know how to do that makes those two things look a little more alike. For example, if I start by figuring out how to create a list of matrices with one row removed then I'm closer to the goal, and I can probably use part of that solution to also remove columns.
I'm trying this `mwc-random` package now and running into a bunch of papers cuts. It doesn't have instances for some common types like `Char`, and it doesn't seem to properly support newtype deriving, either (I get some error about "Could not match representation blah blah"). So yeah, I don't know about the randomness quality of the `random` package, but it's certainly a lot more user-friendly.
Nice
&gt; functional languages require garbage collection due to the presence of closures Rust has non-garbage collected closures. C++ too, I think? Note that this is a statement about closures and GC, not a statement about Rust and FP, I know that not everybody agrees that Rust is a functional programming language and I do not wish to start that debate again :)
Only &lt;3 for SomaFM
Either out of pure contingency or not, it is a step towards direct hardware support for FP, a separation of computational concerns that a language like Haskell can benefit. Things are even better as it resembles an authentic opening, who knows what will come up.
Have you checked out Julia? Being a thin layer over a lisp / Llvm JIT, you can write some pretty nice looking functional code and it's made for data science.
Fast and general probably shouldn't be set equal to easy to use. It's maybe a little low-level, true. What are you trying to do? If you want random `Char`s, what character set should they represent? Should they include things like system bell? If you want to autogenerate text, maybe a testing library like `hedgehog` or [fakedata](https://hackage.haskell.org/package/fakedata) would be more up your alley? In any case, you can just implement `uniform` for the `Variate` class. The "could not match representation blah blah" error can result from `-XDerivingVia`? What did you try to do?
The paper itself https://people.eecs.berkeley.edu/~krste/papers/maas-isca18-hwgc.pdf
I just tried `newtype MyType = MyType Int deriving (Generic,Variate)` and GHC complains. It works with most other library classes, like `ToJSON` and `FromJSON` from `aeson`, as well as `Random` from the `random` package.
Somewhat tangential questions: Is there any way to get relocatable builds? I develop a graphical interpreter frontend called [HyperHaskell][1], and I would love to include a default GHC binary and a few libraries in the binary distribution of the application. Ideally, they would simply be included in the app directory. This is just to provide a default, people can switch to any other desired stack / cabal / GHC setup for each worksheet. [1]: https://github.com/HeinrichApfelmus/hyper-haskell
&gt; require garbage collection due to the presence of closures While GC is certainly a simple way to approach things, you could have Rust semantics or C++ semantics. I'm trying to work on a core + operational semantics for GC-optional memory-safe FP. --- Most application-level programming should be using a GC anyway. Even very conservative programmers like ESR have some around to this. If you *know* you reference graph is actually a tree or something simpler, then manual management is reasonable and can over overhead; but, in general GCs provide much more than they cost. Systems-level programmers tend to mistrust them, but I think we have some selective GC in the Linux kernel already. Embedded generally doesn't want to pay the overhead, and while both soft- and hard-real-time GCs exist, they are neither well-known or widely deployed and trusted. FP is still used in embedded, but often it is used to generate C subsets rather than as the running language / RTS. Until we can provide FP without GC, or produce hard-real-time GCs, there are environments we just won't be in.
A little surprised we don't have one using CakeML with this level of formality. I wonder if the type system is lacking?
Completely opposite. Unless the underlying definitions are written in a very peculiar style , won’t trigger any inlinging based simplifications predictably
I wonder if it's relevant to the Haskell GC though. Doesn't our GC do exotic stuff like perform simple reductions as it's traversing the heap?
`deriving Variate` implies `-XGeneralizedNewtypeDeriving`, which in turn boils down to using `Data.Coerce.coerce`. The nota bene in the error message might lead you to [this](https://ryanglscott.github.io/2018/03/04/how-quantifiedconstraints-can-let-us-put-join-back-in-monad/). To make a long story short, the issue is somewhat subtle. You can make it work by implementing it manually, which is trivial: instance Variate MyType where uniform = fmap MyType . uniform uniformR (MyType lo, MyType hi) = fmap MyType . uniformR (lo, hi) This is a little annoying, true.
Sure, I was able to implement it manually, but in a real-world context where I have dozens of newtypes, that's just a huge pain. Generic and newtype deriving is one of the major reasons Haskell is so pleasant to use - the amount of busywork it saves is unreal!
(I am an absolute noob); this sounds like it cpuld be circumvented in strictly evaluated (/eagerly eval.) Segments? Which in general have better performance due to simpler optimizations...
love me some machine girl
You can find out more in this video [https://www.youtube.com/watch?v=7\_ig6r2C-d4](https://www.youtube.com/watch?v=7_ig6r2C-d4)
I know and love Julia! But it's far from functional. No ADT, no purity, no immutability, a type system far from reaching Haskell's expressiveness. Also I know it's not technically part of the requirements to be functional, but ML syntax is a must
OS package managers are usually painfully out of date wrt developer tooling. I suggest you use [https://www.haskell.org/ghcup/](https://www.haskell.org/ghcup/)
Speaking of Essential Mixes from the early 2000's... The [Valentino Kanzyani 2003 Essential Mix](https://youtu.be/VFOIj9_WZMw?t=5315) has an absolutely *ridiculous* 30-minute ending.
I listen to boatloads of 'chillhop'. I've got a playlist with about 2000 songs I continually add to and play on shuffle. My favorite producers are: Philanthrope, leavv, jhfly, kupla, aso, there's a bunch more.
This was really cool! I'll definitely be playing around with this soon, I feel like this is a problem that everybody everywhere has and that this solution turns out very well. One question: regarding your definition of getOptions with default values, i.e. ``` getOptions = withDefaults defaultOpts &lt;$&gt; fold [envOpts, jsonOptsCustom &lt;$&gt; readConfigFile] ``` is there any (technical) reason you didn't define your defaults as another "layer" to fold over? That's fine if you wrote it like this just for personal preference, but I'd imagine that with some minor type changes to the underlying functions you could write it as: ``` getOptions = fold [envOpts, jsonOptsCustom &lt;$&gt; readConfigFile, withDefaults defaultOpts] ``` which seems to unify it a bit more into a single fold vs "do a fold over these resolvers, then apply defaults over it".
Glad you liked it! The reason that withDefaults is separate is because it uses Identity as the functor whereas the others use Maybe (so you can't put it in the same list). You can of course convert Identity to Maybe, but then you lose the type-level guarantee that every field is full 😄
It says that there is an unofficial copr repo for that. Maybe will try that because im not a fan of out of repo install
Paula Temple is my favourite currently, it's dark and pretty hard IMO: [https://www.youtube.com/watch?v=44HNe1BFIaw](https://www.youtube.com/watch?v=44HNe1BFIaw)
If your project is growing along the dimension you described, then indeed the `Variate` class is in the way. For the trivial wrapper types you can at least define something along the lines of -- One of many newtypes. newtype MyType = MyType { getMyType :: Int } instance Variate MyType where uniform = uniformDefault MyType uniformR = uniformRDefault MyType getMyType uniformDefault :: (Variate a, PrimMonad m) =&gt; (a -&gt; b) -&gt; Gen (PrimState m) -&gt; m b uniformDefault wrap g = do x &lt;- uniform g return . wrap $ x uniformRDefault :: (Variate a, PrimMonad m) =&gt; (a -&gt; b) -&gt; (t -&gt; a) -&gt; (t, t) -&gt; Gen (PrimState m) -&gt; m b uniformRDefault wrap unwrap (lo, hi) g = do x &lt;- uniformR (unwrap lo, unwrap hi) g For a less trivial type, the newtype stuff wouldn't work anyway and you would have to define the instance yourself. Furthermore, what you are used to from `aeson` only works because the problem fits into a shape amenable to autoderiving. For random values, even trivial examples like the typical data Person = Person { age :: Int name :: String } are already out of scope of this approach.
&gt;Please do overthrow skype/slack with open source things &amp; end-to-end encryption. Hear hear. But I'm disappointed that they are not using Haskell in the frontend! (nevermind the choice against Nix). :-(
ghc-8.4.4-74 doesn't satisfy ghc = 8.2.2. Seems like the dependencies for haskell-platform are too tight or weren't updated. You might notify the person(s) responsible for that package, presumably through your distribution's support process.
So, just for clarity, I'm a hardware guy who bumps in Haskell on the rare occasion, but like lurking here. I've been on the RISC-V hardware front for a little while, very fun stuff, but I have really no expertise in formal methods at all. One of the the important points for the formal model that's outlined on github is simplicity for the sake of non-formal methods folks like me. Haskell has some good reach, Sail was made for this kind of stuff, and Kami was as well (though as a hardware guy Kami looks like a mess to me, granted I haven't had much exposure). In particular, Nikhil's code (both here and in general) is super clear and easy to follow, even for a not so great Haskell person (granted, I know RISC-V stuff well, so it seriously lowers a barrier). When I've got something running on an FPGA and I want to check for compliance, I want something I can just run, not to have to get another graduate degree. This question of accesibility I suspect is a big reason Haskell was selected by 3 of the 5 implementers. Nothing against CakeML, but for folks who probably sit in C or Verilog all day like me, it's a much easier ask and seems to really have no serious downsides.
We started development in 2013 – Haskell on the frontend was rather risky back then. (Riskier than Haskell on the backend.)
&gt; Rust has non-garbage collected closures. And they're very limited, as you cannot return a closure capturing local context without copying that local context, for example. Basically, IMO you cannot tap into the full power of the lambda calculus (where variable capture is absolutely central) unless you have GC.
I'm guessing that not doing that will not cause much of a difference. The GHC garbage collector does those things because it speeds up the process of doing garbage collection (less memory pressure), not because pre-computing makes the program itself run faster.
&gt;Hey, do you read this comment!? What do you mean?
Migel Migs. Some examples [https://www.youtube.com/watch?v=V0NSz6DZqyQ&amp;t=70s](https://www.youtube.com/watch?v=V0NSz6DZqyQ&amp;t=70s) [https://www.youtube.com/watch?v=crttZpJ0MMw](https://www.youtube.com/watch?v=crttZpJ0MMw) masterpiece [https://www.youtube.com/watch?v=ZXyGaiqvTyM](https://www.youtube.com/watch?v=ZXyGaiqvTyM) anything of JaBig. for example: [https://www.youtube.com/watch?v=XKhpOaQV1gU](https://www.youtube.com/watch?v=XKhpOaQV1gU)
Re: Video games * You can totally make a 60fps game in Haskell. AAA cinematic games, maybe not. But plenty of other types of games are viable despite GC. * This new hardware would have to be present for a game to benefit. Would this become widespread enough that people's gaming computers have them?
You weren't lying - that was actually quite straightforward. Thanks again for the help!
&gt; functional languages require garbage collection due to the presence of closures To say a bit more about this, the usual solution to the [funarg problem](https://en.m.wikipedia.org/wiki/Funarg_problem) for FP languages is heap-allocated closures. Which means they have to manage heap allocations somehow, which usually means garbage collection.
Speaking of GC, what is the status of the low-latency GC? [https://www.youtube.com/watch?v=7\_ig6r2C-d4](https://www.youtube.com/watch?v=7_ig6r2C-d4)
&gt;&lt;redacted&gt; print . &lt;redacted&gt; removeOneElem . &lt;redacted&gt; $ &lt;redacted&gt; (&lt;redacted&gt; . removeOneElem) \[\[1,2,3,4\],\[5,6,7,8\],\[9,0,1,2\]\] A full solution was given elsewhere, so I'm removing the redactions: traverse_ print . concatMap removeOneElem . getZipList $ traverse (ZipList . removeOneElem) [[1,2,3,4],[5,6,7,8],[9,0,1,2]]
Are there any examples of Monoids/Applicatives such that the monoid instance is different from the one derived via `(Monoid a, Applicative f) =&gt; Monoid (Ap f a)` and is still useful and lawful?
Lists (i.e. `[]`) immediately come to mind.
One of my faves: https://eleventigers.bandcamp.com/album/clouds-are-mountains
Oof! I don't know of a nice way to get relocatable builds. One big advantage of ghcup over the traditional platform installers is precisely that it allows that, sort of, by just bundling the ghc bindists directly. And when installing from bindists, you \_can\_ pick the location relatively easily. &amp;#x200B; The sort of ugly answer is that I think you can build all the packages in an inplace-db (as described here: [https://gitlab.haskell.org/ghc/ghc/wikis/debugging/installing-packages-inplace](https://gitlab.haskell.org/ghc/ghc/wikis/debugging/installing-packages-inplace)) then copy the whole db around. But its a bit of a delicate operation. &amp;#x200B; I tend to think it would be better to wrap either ghcup on linux and osx or chocolatey on windows, and just build the libraries locally. I do agree it is less convenient though. &amp;#x200B; But someone like /u/angerman might be able to give much more concrete and better advice here.
Some soundcloud links for (actual) techno: &amp;#x200B; [https://soundcloud.com/geoffroymugwump/geoffroy-mugwump-podcast-for-signal-hills-italy](https://soundcloud.com/geoffroymugwump/geoffroy-mugwump-podcast-for-signal-hills-italy) [https://soundcloud.com/erraticnyc/erratic-podcast-127-anastasia-kristensen](https://soundcloud.com/erraticnyc/erratic-podcast-127-anastasia-kristensen) [https://soundcloud.com/luna6/invite](https://soundcloud.com/luna6/invite) [https://soundcloud.com/factmag/fact-mix-470-ben-klock-nov-14](https://soundcloud.com/factmag/fact-mix-470-ben-klock-nov-14)
[By fortune it has been already issued, and the pdated package is on the testing repo](https://bugzilla.redhat.com/show_bug.cgi?id=1707504)
CakeML is extremely non-trivial as far as proof authoring goes (like, "UNIX cat clone requires 200+ lines of specification code for a 12 line program", never mind modelling MMUs.) The language otherwise appears to be a very regular ML derivative, aside from its powerful verified implementation. But if you're not going to be writing proofs, I don't see why you would bother with Cake over a number of other alternatives, such as Sail. I even [wrote my own RISC-V 32bit M-mode clone in Sail](https://github.com/thoughtpolice/rv32-sail/), and the language barely took me a day or two to handle, after reading some docs and a little extra code. If anything, you're much better off, IMO, doing formal proofs and verification of actual hardware specifications, i.e. RTL you can load onto an FPGA or fab somewhere. That is because hardware has very limited agility once it is in the field, and requires extensive development time, tipping the cost-benefit ratio a bit. Plus, if you have a verified RTL implementation, you can "just" simulate it with a tool like Verilator to get an executable program, anyway. This is the approach the Kami implementation is taking, by embedding the RTL in Coq -- but even then, it's still extremely non-trivial. From what I can tell, the Kami version is still very far from a "full specification" that provides proofs for all working subsystems. Many people in the hardware space instead are gravitating towards model checking approaches with SAT/SMT tooling, because they can scale very well for hardware problems, and have a significantly better power-to-weight ratio.
I think a Sequence is the right data structure for arbitrary indexed deletes import Data.Foldable (toList) import qualified Data.Sequence as Seq type Mat a = [[a]] cross_out :: Mat a -&gt; [Mat a] cross_out [] = [] cross_out mat = map (map toList . toList) $ go $ Seq.fromList $ map Seq.fromList $ mat where h = length mat w = length $ head mat go m = (\i j -&gt; Seq.deleteAt i $ Seq.deleteAt j &lt;$&gt; m) &lt;$&gt; [0..h-1] &lt;*&gt; [0..w-1] The only odd parts here are the use of the list applicative, by which ie `(,) &lt;$&gt; [0..2] &lt;*&gt; [3..4] == [(0,3),(0,4),(1,3),(1,4),(2,3),(2,4)]`, and the use of fmap to map over a sequence, which imo is just because the containers package is too cute by half to not include `map` and `toList` functions.
Works nice with `scanl1`
Just got around to trying this out, worked perfectly!! Note though that you might want to add that OSX users have to run ``` sudo launchctl stop org.nixos.nix-daemon sudo launchctl start org.nixos.nix-daemon ``` after `cachix use all-hies` for it to take effect (or at least I had to).
Seems to be reported at https://github.com/cachix/cachix/issues/188 I guess a note in the Readme wouldn't hurt. Thanks for letting me know :)
May I suggest something other than techno? I prefer underground hiphop, especially the instrumentals. Mostly boombap and lofi. Some producers I like are J Dilla, Nujabes, Madlib and Kno.
Not sure i follow? If you use \`Rc&lt;T&gt;\` you don't need to copy the underlying value? Although it isn't as ergonomic(having to clone() to bump the reference count).
Here's a less simple, more literal translation of your code: main = let x = 5 in if x == 5 then putStrLn ("5 + 1 = " ++ show (x + 1)) else pure () An even more literal translation, to the point of being unidiomatic, is: main = do x &lt;- newIORef 5 if (x == 5) then do modifyIORef x (+1) putStrLn . ("5 + 1 = " ++) . show =&lt;&lt; readIORef x
 main = do x &lt;- newIORef 5 if (x == 5) then do modifyIORef x (+1) putStrLn . ("5 + 1 = " ++) . show =&lt;&lt; readIORef x This one especially fascinates me. Is Haskell usually this cool?
The various ML derived languages tend to have it as a built in syntax rather than a function, like it is in Haskell. Most pure languages need some sort of escape hatch to deal with mutable variables, and this is one of the ways Haskell does it.
&gt; This new hardware would have to be present for a game to benefit. Would this become widespread enough that people's gaming computers have them? If it's relatively inexpensive to add and offers better performance and faster game development, it'll show up in consoles sooner rather than later.
&gt; Looks more like a devops than a full time haskell programming job to me. You make devops and Haskell sound mutually exclusive! :) I am a full-time devops engineer and all of my toolling is written in Haskell. Even talking to AWS APIs is done with `amazonka` and [`stratosphere`](https://github.com/freckle/stratosphere). Sometimes small scripts are best left to other languages like bash or Python, but anything significant or nontrivial is written in Haskell.
So ML related languages tend to have syntax that allows them to mutate syntax. Correct?
I have not seen anything too great when looking at resources for Rust. Haskell seems to be the winner in this area. Resources are important for me when choosing to learn something, because if there isn't a nice way to learn what's the point. :) I 'm really thinking I just need to learn Haskell.
ML and its derivatives have special syntax for mutating *values*. Haskell has no compiler syntax for this -- mutation in Haskell is achieved entirely (as far as I know) with 100% in-language definitions But: They tend to, yes. Most algorithms can be written in the same time complexity with or without mutability, but in a few cases, writing them without mutation can be asymptotically slower. So there is a practical need for mutation in a few cases. In general, it is stylistically preferable to avoid mutation when possible.
What do you mean by compiler syntax exactly? Maybe in those situations if it really mattered you could use a language alongside it, so you have the best of both worlds. Because some languages are more suited for some tasks than others, it may not be wise to use one language for whatever you are working on. Instead it may be better to use more than one language together to get the best of all worlds. Right? Got it, avoid TMNT at all costs. HA ha!
Yes! I also own a book on Gould (quite an interesting person). I like listening to Arabella Steinbacher on YT (playlist), etc. I have an entire classical and edm playlist that I've made on YT and I loop it when working :)
Does it get easier after monad transformers?
"Compiler syntax" means the compiler has some parsing mechanism specifically for that part of the language. Ex: for loops, function definition, literal arrays. One easy example of something that's *not* this type of syntax is C++ output: cout &lt;&lt; "string"; The &lt;&lt; operator isn't defined by the compiler -- it's an overloaded bitshift operator.
[https://gitlab.haskell.org/ghc/ghc/merge\_requests/298](https://gitlab.haskell.org/ghc/ghc/merge_requests/298) is where it began being discussed, and you can see it gave rise to a whole bunch of MRs.
The comment is for John Meacham who is the author of jhc. [http://repetae.net/](http://repetae.net/)
If you have issue solving basic task consider quitting CS
I thought it might be cool to write a basic example for comparison. Here is a function that generates every possible ordered roll of **n** dice, each with **d** sides. I have to be honest, I started writing the imperative version in C++, then lost the file and gave up and rewrote it in Python because C++ is, shall we say, not my best language. **Python (imperative style)** def rolls(n, d): if n == 0: return [] elif n == 1: result = [] item = [] for x in range(d): result.append([x + 1]) return result else: # Assumes n &gt; 1 result = [] for item in rolls(n - 1, d): for roll in rolls(1, d): result.append(roll + item) return result **Python (functional style)** def rolls(n, d): return reduce( lambda acc, lst: [ func(item) for func in [ (lambda prev: lambda item: [item] + prev)(prev) for prev in acc ] for item in lst ], [[x + 1 for x in range(d)]] * n, [[]] ) **Haskell** rolls n d = sequence $ replicate n [1 .. d]
Calling these use cases neglected feels a bit harsh. But I guess I could do a better job. Having ajhc--while great--wouldn't automatically make cross compilation (and I assume you are referring to cross compilation wrt to android and embedded as well) trivial. &amp;#x200B; In many cases a consumer would expect that packages from hackage just work. These pretty much evolve with what ever GHC is capable of doing. Thus having any additional haskell compiler that only supports a subset of ghc haskell would likely need some form of overlay first that provided patches to packages to amend them for compatibility with such a haskell compiler. &amp;#x200B; For cross compilation, we have to accept that our tooling so far does not really accommodate cross compilation. cabal for example doesn't really have a notion of cross compilation. You can make it be somewhat agnostic to cross compilation by providing the right \`--with-PROG\` flags (the program database turns out to be rather good feature). Using \`Configure\` as a build-type also helps as it defers the work of cross compilation feature detection to autoconf. All that said though cabal in itself does not really know it's using a cross compiler at that point.
/u/apfelmus you can build relocatable binary distributions. Not absolutely perfect (as they will depend on some form of system dependencies (libc, gmp)). But unzip and run does work. I've written about this a while ago on [medium.com/@zw3rk](https://medium.com/@zw3rk/relocatable-ghc-cross-compiler-binary-distributions-f55080b837b1). In essence: if you use \`hadrian\` to build your ghc, the binary distribution is just the tarball of the \`\_build/stage1/{bin,lib}\`. This used to work for cross compilers as well, but there used to be an issue with \`hadrian\` and cross compilation iirc. It should still work for regular compilers. &amp;#x200B; This of course horribly breaks down as soon as some library uses the \`Paths\_\` module that \`cabal\` provides as that hardcodes the absolute paths to package resources. We really need a better solution for this, if someone has a great idea and wants to discuss this, please shoot me a message on irc/mail/... &amp;#x200B; Finally, /u/apfelmus or anyone else, if you want to discuss this particular topic (cross compilation, relocatability, ...) in person, find me at zuriHac!
Reference counting can't deal with cycles, and closures typically create cycles. So you're going to leak memory: it's not a general solution. (In Rust, cycles are typically created via mutation; in Haskell, via recursive values.)
So, just for my own understanding: If I download the binary distribution of GHC from https://www.haskell.org/ghc/download.html , then I still have to run ./configure --prefix="${inst_location}" in order to specify the installation prefix. In contrast, if I were to build GHC from source using hadrian, then this step would not be necessary, and I could run the `ghc` binary directly from a `$myprefix/bin` directory, provided that a corresponding `$myprefix/lib` directory exists. Is that correct?
I see, so it's not possible to prebuild the libraries and distribute them in binary form? Instead, the app needs to install them in a (custom) location, for instance when the user first starts the app.
Yeah, Solar Fields is great (not Techno though). I'm a big fan of everything that sorts from the [Ultimae](http://www.ultimae.com/) label: Carbon Based Lifeforms, Aes Dana, Miktek, Sync24, Connect.Ohm, ...).
'study focus', 'electronic music focus' on brain.fm
Are these open to international applicants? And what sort of salary range is on offer?
Extrawelt, for example songs like [Neuland](https://www.youtube.com/watch?v=rkY96VwNRiA) or [Swallow the Leader](https://www.youtube.com/watch?v=kHSnj9YG1q0)
Yes.
The article says that the chip "addresses" the problem of stop-the-world garbage collection. Does this mean that it would be possible to run Haskell without stop-the-world garbage collection?
Sounds like you don't understand the difference between a list and a linked list
Thanks. That really clears up my question.
It all depends on your use case. If iteration is your main goal, lists are great. If you want fast random access, then people are using other structures. The beginning tutorials use lists because they're easy and unless you're at a performance bottleneck they work just fine.
The question is actually slightly subtle, since laziness means a data structure isn't materialised into memory until it is required. So you can use linked lists as a handy source-code representation of a linear sequence of computations, but with the resulting object-code being a tight loop running in constant space. This depends on a set of optimisations in the compiler and common libraries (eg "stream fusion" is one term to search for if you want more details). So perhaps a more nuanced opinion would be that lists are still absolutely part of Haskell source code, but you aren't limited to data structures that have grotesquely inappropriate scale or performance characteristics where it matters. As just one example among many, the [vector package](http://hackage.haskell.org/package/vector) provides high performance O(1) arrays, both immutable and mutable, and is very widely used in production code.
For me, the big reason why Haskell "doesn't really use linked lists" is fusion. If you write something like `sum [1..100]` there will be no linked list created in memory. Instead, it will be written as a tight loop. This optimisation is actually based on a pretty sound algebraic theory (although it does rely on a fair amount of heuristics). This eliminates a huge amount of pointer-chasing, which is (in my limited experience) the main source of inefficiency when using linked lists instead of arrays as your main iteration structure.
From my experience I'd say that no, lists are not going anywhere. Yes, there are various cases where I may reach for a different data structure, like arrays using [vector](https://hackage.haskell.org/package/vector), but it has to be a particular situation, e.g., lots of operations which aren't as efficient with linked lists on a huge number of elements. Many other scenarios where we're working with multiple elements, either interacting with other programs, like sending a batch of messages to Kafka, executing many commands against redis; or pure computations like zipping, filtering, etc. are usually done with lists. My company only uses Haskell for a couple apps though, the vast majority is written in Java, so I cannot say if things are different for companies that mostly/¿exclusively? use Haskell and other FP languages.
Hijacking this a bit; haskell is not mentioned in the list of languages on winipedia that support mumtiple dispatch, but, if I understand multiple dispatch correctly, doesn't the use of currying in haskell automatically lead to support for MD?
This was sort of my instinct, but I don't have the Haskell chops to back it up. Thanks! One thing the other gentleman mentioned is that lists are more of a "control structure" in idiomatic Haskell than a persistent data structure. Kind of goes along with what you said.
Currying covers one use of multiple dispatch (having default argument values), but multiple dispatch is also used for pattern matching on types. I would say typeclasses are closer to covering that usage, but it's coming at it from a little different angle.
I've been doing Haskell for close to ten years and two professionally, and we use lists constantly. The statement that "everyone has moved on" is pretty false IMO, though there are some true things that are somewhat related: - We have moved on (ish) from [String] to better options like Text - You do need to be aware of the tradeoffs and know when to reach for an alternate structure like Conduit - We try to be as generic as we can, coding to an interface like Foldable or Semigroup, not actually [a] most of the time - We try to use NonEmpty of that's our intent Hope this helps
Yep, wel also have a bunch of internal tooling written in Haskell (though mostly it just works and supporting it won't be a significant part of the job duties).
I work on lots of Haskell code professionally. In addition to agreeing with what I've read here in the comments I present you with one of my projects: % ag '\[.*\]' | wc -l 3489 % ag ByteString | wc -l 1912 % ag Text | wc -l 4192 The above doesn't represent the ratio of lists to other types - I used `[]` for values as well as types after all and construct some maps with `[]` too (OverloadedLists) - but the point is lists are certainly used.
I agree fully with the latter
MPTCs (particularly overlapping ones) are multiple-dispatch. MPTCs (and any replacement technique that I can think of off the top of my head) are not part of Haskell 2010 (IIRC). However, GHC does have support for them.
Very good introduction; I skipped until halfway though.
What's a "strat"? It says it is a strat role but I'm not sure what that means.
at first I thought the article was warning people with latex allergies
&gt; Instead, it will be written as a tight loop. This optimisation is actually based on a pretty sound algebraic theory I've read just today that the clang compiler supposedly can recognize series expansions (`100*(100 + 1) / 2`) and make this O(1). Now this would be really cool if we had that.
I loved the first part, but I think that too little time is spent on introducing the monadic and later arrow concepts. I think you will lose the non-Haskell audience at that point. However explaining both the concepts and going into more depth of how they can be used might be too much for one post... Great attempt, but it unfortunately perfectly falls victim to the monad tutorial fallacy.
Multiparametric typeclasses are your closest thing to multiple dispatch.
Intermediate lazy lists in haskell are a source of memory leaks and stack overflows. They are a fine way to represent streams of data, but anything that has unpredictable lifetime might accumulate. For this reason, it is better to avoid lazy lists in long-running programs. For short chunks of data it is preferable to use arrays. For long chunks of data [iteratees](https://en.wikipedia.org/wiki/Iteratee) are the solution of choice for things like web-servers.
Thanks!
life got a little crazy, its on the queue, and i figured out a sane migration path! :)
That's right. Because lists are lazy, when you iterate through a list, it's computing the list as you go, so it's not necessarily all in memory at once. So folding over a list ends up being much like an imperative loop.
Just curious, what is the business domain?
Yes. And thank you. I'll try them out and probably bug you for more. The problem I have with hip hop is I get so into it I'm not doing my work. I'll give these a shot though.
I wouldn't say that Haskell is "moving away" from lists. Perhaps there's a percieved departure due to less of an emphasis on lists (i.e. `Foldable` and `Traversable` becoming more prominent), but there are still quite a few functions which privilege lists for historical reasons. I enjoy this departure from privileging lists. It means we can treat it more appropriately as a data structure more often than simply reaching for it because it's the only thing there.
Wow did you come up with this yourself? I actually love anything to do with dice, so you have won me over with this one. Hello Haskell, here I come. I think I might be gone for a while, because I want to play around with this. I am probably going to spend some time playing around with this Python code too. :) What do you feel your strongest language is?
So the main function itself too right? I did not actually know this was overloaded.
I work at Freckle, formerly Front Row. We do online education for K-12; tools for Teachers, Administrators, and of course the Students. I like it (for a lot of reasons, but including) because it's not finance or crypto, and I get to see Haskell shine solving "normal" product problems.
A clarification might be in order with respect to the discussion of categories. When we use, for instance, `Kleisli IO`, we normally don't think in terms of "construct[ing] a category", because the category is already there -- namely, `Kleisli IO`, the category with Haskell types (all of them) as objects, and `a -&gt; IO b` functions as arrows. From that point of view, a diagram such as the one near the end of the article... arrow1 arrow2 arrow3 String -----&gt; String -----&gt; [String] -----&gt; () ... is read as showing some arrows in a category, and not necessarily a whole category. (Note that I dropped `IO` from the diagram. That is because the `IO` in `Kleisli IO` isn't actually "part" of the objects of that category -- the objects correspond to `a` and `b` in `a -&gt; IO b`.) Granted, we can make up a category from any subset of arrows from some parent category, as long as we also include all identities for the involved objects. Typically, though, such categories don't lend themselves well to being expressed in terms of the `Category` class from the base libraries, because `Category` is for categories which have all Haskell types as objects. A category class that allows restricting the objects requires [heavier machinery](http://hackage.haskell.org/package/constrained-categories-0.3.1.1/docs/Control-Category-Constrained.html).
Amelie Lens vinyl only home session https://youtu.be/RcVnqFxWMDM
Monad tutorial fallacy? I've never heard that term -- what do you mean by that?
Ah, thank you for those clarifications. I'll fix the article.
No problem. One more, somewhat related, point I forgot to mention: when you talk about the simplest category, `A = id` doesn't really work because `A` is an object and `id` is an arrow. We do have a category that has `A` as its only object, (specialised) `id :: A -&gt; A`, the identity of `A`, as its only arrow, and (specialised) `(.) :: (A -&gt; A) -&gt; (A -&gt; A) -&gt; (A -&gt; A)` as composition, though it doesn't fit the ordinary `Category` class for the reason I mentioned above.
Oops, that was just a mistake on my part. Should have caught that. Also, I updated the whole post with more precise terminology and I fixed &amp; explained the final diagram. Thanks for all this.
Is that really important? How much time in real project are you writing a standard serie without recognizing it as such and directly writing the expended form by yourself? I know that inlining of some expression can lead to such optimization opportunities, but I'll be really surprised if this is happening a lot. And due to the specificity of arithmetic on "real" computer number, that's not easy to do it correctly, you need to take into account possible overflow, or cancellation. I'm not saying that it won't be cool, I'm just wondering if the performance gain will be worth the increased complexity of the compiler + the compilation time needed for this optimization phase. This ticket discuss a similar matter on the recent changes in constant folding (a similar but simpler operation). [https://gitlab.haskell.org/ghc/ghc/issues/9136](https://gitlab.haskell.org/ghc/ghc/issues/9136)
(GHC) Haskell allows libraries to do fancy optimizations. So if you use lists as streams/iterators/generators/whatever and use library combinators like map/fold/etc to do it they compile into efficient loops. So you could see them as something like java's streams but with zero overhead over handwritten loops! If you use them as random access arrays in a hot loop their performance is hilariously awful.
Yeah the way I phrased that is likely overselling the benefits of such a transformation. And of course there are issues that should have higher priority. For the particular sum example: Prelude&gt; sum [1,3..100] 2500 Prelude&gt; sum [1,3..100] :: Double 2601.0
wait, why does this occur?
Please fix your formatting. Reddit doesn't like the triple backtick syntax.
Okay, so my conception that multiple dispatch is just multivariate polymorphism at runtime (mostly in the context of free functions) is horribly wrong! 😂 Care to point me to a good introduction? The wiki page is really not great and not very formal, imo.
There is an open \[issue\]([https://gitlab.haskell.org/ghc/ghc/issues/13552](https://gitlab.haskell.org/ghc/ghc/issues/13552)) about this, and the behavior is \[documented\]([http://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Float.html](http://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Float.html)) as well. &amp;#x200B; Let's just say I was not amused when I first encountered this...
It works with the new theme.
`whnf` benchmark strategy evaluates only to weak head normal form, in this case the result would be 0 : &lt;some thunk&gt; and that's fast to compute. Change to `nf` (read `criterion` manual, Also, I'd rather do more simple benchmark, as I think you don't even trigger quadratic `++` behavior. bad 0 = [0] bad n = bad (n - 1) ++ [n] vs better = toList . go where go 0 = singleton 0 go n = go (n - 1) `append` singleton n --- And if you want a solution, you could look at this benchmark: https://hackage.haskell.org/package/dlist-nonempty-0.1.1/src/bench/Main.hs (don't look too soon! :)
I worked in the Quantitative Strategies teams at GS and CS respectively, and both teams referred to themselves as Strats for short. Typically it means working with Quantitative Analysts ("quants"), traders and other business users, and workng on Front Office IT systems - model integration, trade capture, risk systems etc.
So in Julia, all mathematical operators (which are functions) are implemented for all numeric primitives--and BigInt and BigFloat, which of course, are not primitives. For a different example, all collection types in Julia implement a length function. That means, somewhere in the code, there are functions like length(a::Array) = ... length(d::Dict) = ... length(s::Set) = ... I haven't bothered to check how these operations are implemented on these types, but I guess there's a counter in a struct somewhere. Say I want a linked list, because Julia doesn't have one. I can implement my own length function: struct Linked{T} head::T # T is a generic here. tail::Union{Linked,Nothing} end length(l::Linked) = l.tail == nothing ? 1 : 1 + length(l.tail) This isn't how you'd actually do this because no TCO in Julia. I'd implement the iteration protocol for my list (again, using multiple dispatch), and use a loop to calculate the length, but you could do it this way so long as you weren't bothered about performance or stack overflow. Multiple dispatch is essentially a method for implementing the same function on different signatures, including signatures that differ in number of arguments as well as type of arguments. Does that make sense? So, it can be a bit like currying (uh, kinda), but it's also a bit like implementing the same method on a bunch of different classes in classical OO, only the method is bound to the types of all the arguments, rather than only the first argument. Just another approach to polymorphism. I like it, but I also like type classes, algebraic data types and pattern matching, which Julia doesn't have.
I've coded in Haskell for the better part of a decade. During that time I've used and/or implemented data structures from vectors, array, finger trees, everything in Okasaki, a good part of the stuff in the research literature, and things more exotic. I've seen absolutely dreadful code written using lists as if they were arrays, iterating through them by going through the integers up to length and accessing elements by indexing. And worse. Still: Whenever I encounter a new problem I want to solve in Haskell my first thought is about how I can efficiently solve it using lists. Thanks to lazyiness, list fusion, and related optimizations, astonishingly often it is possible to do so and end up with code that is more general, more reusable, more concise, and higher performance than the hacks that people who don't understand Haskell and just write C or PHP or Fortran in Haskell come up with. And sometimes you, or at least I, just can't. Then it is when you start thinking about other tools. But not before.
I'm trying to call Haskell's demand analyzer as a library (from within haskell). I can't seem to get this right. Any help?
Thanks for letting me know. I've switched it to indentation-based formatting.
Coincidentally, I was just going over that same chapter. In my case, I got an order of magnitude improvement when switching to DList. benchmarking concat list time 4.950 ms (4.887 ms .. 5.009 ms) 0.999 R² (0.997 R² .. 0.999 R²) mean 4.945 ms (4.898 ms .. 5.008 ms) std dev 166.6 μs (125.2 μs .. 255.1 μs) variance introduced by outliers: 16% (moderately inflated) benchmarking concat dlist time 126.1 μs (123.5 μs .. 130.1 μs) 0.995 R² (0.993 R² .. 0.997 R²) mean 130.6 μs (128.0 μs .. 134.0 μs) std dev 9.910 μs (7.483 μs .. 13.24 μs) variance introduced by outliers: 71% (severely inflated)
Haskell moving away from lists would be like structured programing moving away from loops. Lists are a fundamental building block in Haskell. People use other data structures when appropriate, but lists will always be prevalent.
That was it, thanks! I was thrown off for a minute by the 0 : &lt;some thunk&gt; in your answer. If I'm not mistaken, it would actually be 123456 : &lt;some thunk&gt;
This is why I always push back on the guy! Like, Haskell without lists? Is that even Turing complete?
Haskell can exist without them. Lists are only privileged by their syntax sugar. If they weren't in `base` someone would just write a package and we'd all use that. ``` data List a = Nil | Cons a (List a) (:) :: a -&gt; List a -&gt; List a (:) = Cons myList = 1:2:3:Nil ``` The convenience of sugar may lead to using them in inappropriate places, but the data structure itself has fundamental properties that are useful no matter where it is defined.
You can define infix data constructors, `:` doesn't need to be a separate function there: data List a = Nil | a : List a
`whnf` wouldn't force that. It would force the list constructor (cons) so were the 123456 a computation then `whnf` would yeild: &lt;some thunk&gt; : &lt;some other thunk&gt;
Yes. I defined it as a function since OP said they were only mildly familiar with Haskell :) Though I actually like that PureScript only lets you define operators for named functions/constructors.
I'm only sorta familiar with difference lists, but I'm surprised to see that `[n] ++ xs` is the thing it tests against. Isn't that already reasonably fast for ordinary lists? I thought `xs ++ [n]` is the thing difference lists were especially good at replacing.
It has always been possible to run a GCed language without stopping the world; you can avoid STW pauses at the cost of speed, usually, for example, using an incremental collector such as [Baker's incremental copying collector](https://www.cs.purdue.edu/homes/hosking/690M/p280-baker.pdf). However, you don't see many implementations of these incremental algorithms because usually the pause reduction is not worth the 10% or so performance decrease caused (Baker uses read barriers, where each pointer has to be checked and possibly replaced before it can be dereferenced). An accelerator like this would likely reclaim some performance as it can run in parallel to the CPU.
Anyone have recommendations for a tutorial about GADTs?
It's very much this, yes.
However, there’s more subtle case where I wish you’d change your story. FP is not about lists. FP is about functions. My programs totally do have some deconstruction of lists, usually by pattern matching—but they are mostly written in terms of higher order functions. That is, I’m more likely writing some composition of folds and functions on monoids, then attaching that to some library functions that emit or consume lists. There are lists, but it feels really different from, say, R4RS Scheme. Others have talked about how there won’t be cache-busting pointer chases; that’s true, but I’m trying to talk about the programmer’s mental model. It isn’t imperative array updates, but it definitely isn’t lists.
Definitely open to international applicants; having right to work in the country in question tends to make things faster but isn't a requirement. Salary is highly dependent on the candidate's abilities, and can be discussed with HR early on during the application process.
I suggest the [GHC user guide](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#generalised-algebraic-data-types-gadts). I know you didn't ask for an explanation but I guess I feel like writing so... GADTs aren't too terribly complex. There's nuance, but the basic concept is simple. You get new syntax for declaring data constructors. Unlike regular data declarations, these constructors can have different types! # Syntax Sure, we can take a data type translate to GADT syntax mechanically: data NonEmptyList a = One a | Cons a (NonEmptyList a) -- ~~~&gt; data NonEmptyList a where One :: a -&gt; NonEmptyList a Cons :: a -&gt; NonEmptyList a -&gt; NonEmptyList a Simple... but boring and actually more verbose. # More Powerful Types As mentioned, a GADT is really about the constructor playing some role in determining the type. Let's take a trivial example: data SomeType a where Val :: Int -&gt; SomeType Int Truth :: Bool -&gt; SomeType Bool Nullary :: SomeType Word Poly :: a -&gt; SomeType a Look hard at the above. Notice the type of each constructor, even fully applied with all it's fields, is potentially different. I've made a sum type that can contain Int and Bool, but the type tag (`a ~ Int`, `a ~ Bool` etc) matching the field is all just my choosing. I ended with two odd ones just for demonstration, `Nullary` doesn't have a field and is typed differently from the other values while `Poly` can hold anything at all and the type system tracks what `Poly` holds by the type field of SomeType (those `a`'s are the same type). Now if we have a function `f :: SomeType Int -&gt; String` which constructors do we need to match? Just `Val`? f :: SomeType Int -&gt; String f (Val i) = show i GHC, with `-Wall`, will tell us we missed a case: f (Poly i) = show i While the `Poly` constructor can wrap any type, the signature of `f` guarantees this is an `Int`. Similarly, we didn't get a warning abouot `Nullary` or `Truth` since those wouldn't be type correct. As an aside, we could add another constructor to our `SomeType` declaration: UselessPoly :: b -&gt; SomeType a And now we wouldn't know anything at all about `b` ever, making defining a function hard. We still know the argument to `f` is `SomeType Int` but that doesn't say anything about the type of `b`. We'd have to say `f (UselessPoly _) = "heck if I know"` or similar. # The classic GADT Example GADTs are particularly powerful when paired with data kinds (-XDataKinds) and kind signatures (-XKindSignatures). For example, What if we wanted to have empty and non-empty lists that used the same constructors but had type level distinctions? data ListState = LNonEmpty | LEmpty data SomeList (state::ListState) a where Nil :: SomeList LEmpty a Cons :: a -&gt; SomeList st a -&gt; SomeList LNonEmpty a type NonEmptyList a = SomeList LNonEmpty a Then we can write functions that are safe such as: head :: NonEmptyList a -&gt; a head (Cons a _) = a Which is total, any attempt to call `head Nil` would be caught at compile time.
[This is the origin of the term](https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/)
That's fair. Saying that this article falls victim to that is a bit misguided though, in my opinion. I'm not trying to "explain monads", nor did I even try to make any metaphors about them or capture them in full. I just talked about one specific aspect about them -- the idea that they can represent abstractions over binding and composure.
This behavior is specified by the [Haskell report](https://www.haskell.org/onlinereport/basic.html): “For `Float` and `Double`, the semantics of the `enumFrom` family is given by the rules for `Int` above, except that the list terminates when the elements become greater than e₃+i/2 for positive increment i, or when they become less than e₃+i/2 for negative i.” 101 is not greater than 100+2/2, so it’s included in the list. Presumably you adjusted e₃ to 100 rather than 99 in an effort to avoid floating point rounding issues related to exact comparisons with 99. Presumably the specification adjusted the bound to e₃+i/2 rather than e₃ in an effort to avoid floating point rounding issues related to exact comparisons with e₃. Unfortunately, these two adjustments interfere destructively. This is probably a design error in the specification in that the programmer probably wasn’t expecting the language to make that adjustment for them (especially not in different ways depending on type), but the specification is unlikely to change now, so as a programmer I guess you should just avoid making an additional adjustment yourself.
The main function is special, but only because the compiler calls it first by convention. It's otherwise a normal function. As an aside, Haskell does have a main function, as do many curly brace languages. I've just realized that Python *doesn't*. It does this instead: if __name__ == '__main__': # "main function" code goes here
I like that the “Alternatives” section is just a series of ads for various streaming packages.
So for Python we have an if statement in place of the main function?
Yep! Even if you write a function called "main," Python won't execute it automatically.
Right! That is good to know as I play around with Python sometimes.
I was messing around with some probability calculation earlier this week. [Here's the code this snippet came from if you're interested.](https://pastebin.com/QiYvcUqP) Python is probably my strongest language, since I write it for work. I learned a lot about programming from Haskell, even though I can't write it every day. I 100% could not understand the functional Python I wrote if I didn't write Haskell. Fun fact, the functional Python is a direct translation of the Haskell.
Actually messing around with others code is my favorite thing to do as I don't always enjoy learning from a book. Plus learning through play/doing is a much better approach to learning something in my opinion. So Haskell has really helped you to be better with functional Python, that is great. What do you mean exactly by a direct translation?
Python doesn't have a definition of Haskell's sequence that I know of. Most of the functional Python's code is spent defining sequence (for the list type, meaning sequence is actually the Cartesian product in this context). You could refactor it like this: def sequence(x) return reduce( lambda acc, lst: [ func(item) for func in [ (lambda prev: lambda item: [item] + prev)(prev) for prev in acc ] for item in lst ], x, [[]] ) def rolls(n, d): return sequence([list(range(1, d+1))] * n) Written like this, is's much easier to see how this is equivalent to the Haskell code.
&gt; Rust will force you to write a bunch of code handling memory and sharing, while those things are totally automatic in Haskell. &gt; You don't have to worry about memory &amp; pointers In Haskell like you do in Rust. As long as your program performs fine with lots of pointer indirections, heap allocations, and doesn't swamp the GC (through laziness / space leaks), sure. You still might be able to fix performance issues without having to worry about pointers--the right strictness annotations in the right places can do wonders and unboxing still doesn't necessarily mean dealing with pointers. But, if you do have to mess with them, GHC doesn't have a lifetime checker to help you out. &gt; Haskell is more suited for creating compilers than Rust is &gt; Haskell has an incredible ecosystem for language development. Rust has most tools you’d reach for but not as many options. &gt; The difference in performance from a compiler built in Haskell vs Rust is probably not big enough to care about I expect all this to be true. The Haskell LLVM bindings are great, as is Megaparsec, and type system can sometimes help you out. &gt; It takes less time generally to write code in Haskell than it does in Rust I think it depends on the code. I can spend just as much time fighting type errors in Haskell as I can fighting ownership problems in Rust; I also don't know the Rust ecosystem as well, so it definitely takes me longer for virtually everything. I think an experienced Rustacean might find themselves slower in Haskell, for quite a while. &gt; Haskell has stronger type inference than Rust, meaning that you very seldom have to use type annotations if you don't want to. True-ish. It's idiomatic Haskell to put a type annotation on every top-level definition, these days. Also, if you start playing around with the type-related GHC extensions, inference gets less and less complete. (Though, it is always better that Rust's.) &gt; There are more beginner friendly resources for learning Haskell than there is For Rust Yes, there are more, but you really only need the first one that works for you. I thought the Rust book was quite enough, and I started going to the stdlib (and various crates) reference as soon as I'd gotten through all that. &gt; Functional programming languages like Haskell are preferred for writing compilers opposed to languages like Rust By whom? I think there are plenty of people that would disagree. I've never finished a toy compiler (I'm working on one again), but I'd definitely choose Haskell. &gt; The way you think about doing things will change more with learning Haskell than with Rust Yes. But, it will be in different ways. I recommend learning both, though if you only have time for one, Haskell will probably stretch your mind in more ways. &gt; Haskell is more popular amongst mathematicians than Rust is I think that's mostly a syntax thing. Although, you'll still find plenty of Mathematicians that swear by Fortran or Matlab, so I'm not sure it's the *best* metric. ;)
This is an amazing description and a very nice job you've got there. And I literally hurt subscribered to /r/haskell moments ago. Kudos for putting up such a succinct post.
It does when you use the llvm backend.
Yeah definitely when you write it like this it is easy to connect the dots, so to say.
No. Yes. Yes, there is growing body of performant immutable data structures. Haskellers just like any developers weight pros and cons and choose best candidates. No. Linked lists aren't being abandoned. Simply are used for tasks they are good for instead of being only choice and thus lest bad choice.
I don't think I implied that FP is all about lists—just that, pragmatically speaking, lists are the main way for dealing with sequence iterate in FP, which, turns out, is a pretty important thing to be able to do in programming!
Haskell is used in crypto?
`[n] ++ xs` is the same as `n:xs`. So this benchmark is flawed. The point of difference lists is to make repeatedly appending to the end of a list efficient, and to avoid the quadratic complexity. Appending once is still fine.
You might be right that 'this article falls victim to the monad tutorial fallacy' is a misguided simplification. At first I thought the point of the article was "look, monads and arrows are cool and you should care about them because they allow a mathematically clean way to represent sequential compuutation" but in re-reading it I don' t think I had that right. I really like the article, and I think there are some great parts and definitions in there. For instance, I love the definition of "monads essentially allow you to change what ° and (x) mean in (f ° g)(x)". The main issue I think that this article has in its current form, is that the information density, the pace at which new concepts are introduced to the reader, is not constant, but ramps up exponentially. This makes it near impossible for people who are not yet well-versed with haskell, monads and arrows to follow along all the way to the conclusion.
Wouldn't `grep "foo ::"` still work even without the linebreaks?
Relatedly, I benchmarked cons-then-reverse vs dlist and found that if I deepseq, or just take head, the list at the end that both have the same time and space more or less. https://github.com/chrisdone/sandbox/blob/master/diff-list-vs-regular-list.hs https://github.com/chrisdone/sandbox/blob/master/diff-list-vs-regular-list-weigh.hs
Yeah, I struggled writing it a little bit without getting entrenched in the concepts. It wasn't supposed to be anywhere near as long as it was, but I felt that making it any shorter would be cutting out content (and making it any longer would be hard to keep cohesive).
Mind explaining the R² measure? Unless it's the R² I'm familiar with, the coefficient of determination, a measure of best fit.
Are there any Newrelic type APM tools available for Haskell apps in prod?
Thanks. And by the way, Haskero implements a Language Server Protocol too :)
[http://www.serpentine.com/criterion/tutorial.html#linear-regression](http://www.serpentine.com/criterion/tutorial.html#linear-regression) &amp;#x200B; The benchmarking library runs multiple samples, and on each sample a different amount of iterations (i.e., applications of the function being benchmarked) is applied. &amp;#x200B; Thus, the execution time for each sample is being fitted about the number of iterations for that sample, and the expected behaviour is linear.
cryptocurrency
Which ones?
cardano
It’d be good to know what‘s the minimum computer science knowledge a candidate is expected to have. I know a little, but it’s all self taught and probably missing chunks, and I won’t know what I’m missing to look for it.
Ah nice! I was aware that Tezos was in OCaml but didn't know Cardano was in Haskell
Give `gtk2hs` a go. [http://book.realworldhaskell.org/read/gui-programming-with-gtk-hs.html](http://book.realworldhaskell.org/read/gui-programming-with-gtk-hs.html) To get an overview take a look at [https://wiki.haskell.org/Applications\_and\_libraries/GUI\_libraries](https://wiki.haskell.org/Applications_and_libraries/GUI_libraries)
This week I had a problem with `Prelude&gt; :t 1.0:[div 1 1]` `1.0:[div 1 1] :: (Integral a, Fractional a) =&gt; [a]` `Prelude&gt; :t [1]:[1,1]` `[1]:[1,1] :: (Num [t], Num t) =&gt; [[t]]` At first I was confused, but then I understood better what is happening. I wanted to ask, is there a way to define a type for the previous expressions to work?
Use gtk-gi if you want actually up to date bindings. Gtk2hs is old. Also self plug, but you can use https://github.com/mr/reactive-banana-gi-gtk for reactive programming. I'd label this as experimental, but if you're interested in FRP with GTK, this can help with minimal overhead.
Don't do GUI programming in Haskell if it's just for fun, cause it isn't fun. I recommend looking at a Haskell-inspired language that compiles to Javascript. [Elm](https://elm-lang.org/) is a good one.
You're very welcome. I look forward to reading more things you write :-).
In the old theme, I can see how many new comments are associated with a post since the last time I visited (at least with RES). Is there any replacement for this in the new theme (with or without browser extensions)? I'd switch if I could get that one feature.
No reason you can't to use Haskell here. [https://haskell-miso.org](https://haskell-miso.org) is fun. All the best in your studies!
&gt; Multiple dispatch is essentially a method for implementing the same function on different signatures, including signatures that differ in number of arguments as well as type of arguments. Which is why both of your examples were single dispatch. ;) That's where the behavior only varies based on a single argument (generally it's run-time type). Single dispatch can be handled through type classes as a special case of ad-hoc overloading. Between techniques like the Visitor pattern and higher-order functions, it turns out multiple dispatch isn't *usually* that helpful in the compiler. Still, it would be nice for the 2020 report to bring in MPTCs and give Haskell proper multiple dispatch. (Although, you'll still have to tuple / uncurry arguments manually to make sure all the argument lists match in size.)
The final result of `getLine &gt;&gt;= putStrLn` is `IO ()` which, as you said, is just a recipe. It doesn't do any side effects. The `&gt;&gt;=` operator takes a recipe for `a` (`IO a`) and a function that knows how to turn that `a` into a recipe for `b` (`a -&gt; IO b`), and combines those two to make a recipe for `b` (`IO b`). So it doesn't do any side-effects by itself, it only combines recipes.
Calling the `IO` monad 'purely functional' is a bit misleading. basically, `IO` is parameterized by the primitive state token `realWorld#`, where `realWorld#` represents 'the state of the universe'. Whenever you call a function that performs IO, the return type gives you the new state of the universe. this means that the interface for IO is 'pure', but its behavior at run-time is impure. (ghc can't actually track the state of the universe, obviously.)
Thanks for your well written response. So basically the &gt;&gt;= function creates a new recipe out of 2 existing ones. At the end of the day, IO monadic functions remain pure. That's the part I was confused with, not anymore.
It also can't duplicate the state of the universe for passing to two different threads. It seemed important to mention that limitation of GHC. :)
&gt;Calling the IO monad 'purely functional' is a bit misleading I assume by "I/O system," it referred to the functions related to IO monad. They could have been more specific. Nevertheless, the functions are all pure, which makes the statement true, based on my assumption. The side-effects are all in the runtime system, where the actions are executed. Correct me if I'm wrong.
&gt; Now, if the "getLine" isn't causing side-effects (for getting the input string), does the bind function (&gt;&gt;=) cause the action to be executed (causing side-effects)? No, `&gt;&gt;=` doesn't cause any side effects either, it just creates a new IO action that combines the two parts. The side effects happen when the interpreter actually executes this IO action (i.e. when you return it from `main`). Consider this: you can evaluate `getLine &gt;&gt;= putStrLn`, and then throw away the result, like so: main = getLine &gt;&gt;= putStrLn `seq` return () This constructs an IO action `getLine &gt;&gt;= putStrLn`, and then throws it away and returns `()` instead. If you run this program it won't do anything.
Thanks for the clarification, greatly appreciated!
You are technically correct but it's not very useful. It's similar to arguing that C is pure because when you write the code it's not actually being executed.
I still use the old theme ;)
[Threepenny GUI][1] has the advantage of being easy to install. (Disclaimer: I'm the author.) [1]: https://wiki.haskell.org/Threepenny-gui
Http links get broken over time, how about hosting papers directly in the repo plus provide some ipfs links?
&gt; this classic Lovely.
Do you know if this is supported yet? I can never seem to get this to work :(
I would recommend Reflex Platform. It is a second order functional reactive library with no bindings to some C++ library that allows you to do both, browser and desktop app
The way I think of it is that an IO String is basically a no-argument function that returns a string. It's the equivalent of `String MyFunction() { ... }` in java. `&gt;&gt;=` takes in one of these no-argument functions and a function that takes in a normal value and returns another no-argument function, and returns a no argument function that runs both arguments. The result is something like Void CombinedFunction() { String val1 = Arg1Func(); Function f2 = Arg2Func(val1);
This is front-end, not necessarily application GUI
Though cycles can be difficult to make in some languages (for example eager and pure languages).
If you want to make a game Gloss is a relatively small package that's easy to install. There's definitely a learning curve, but there are many tutorials to help and if all else fails hackage has your back.
Another one: http://hackage.haskell.org/package/fltkhs https://www.reddit.com/r/haskell/comments/32c9tq/announcement_fltkhs_bindings_to_the_fltk_gui/
&gt; It's the equivalent of `String MyFunction() { ... }` in java. While that is spot on, it is worth emphasising that neither the Java `MyFunction` nor, say, `getLine` are functions in the sense we give to the word in Haskell parlance.
You can easily make cycles involving closures in Swift, even in the pure subset of the language, by capturing a `self` reference :\^) It's actually a common problem that people need to be aware of and deal with regularly, since Swift uses automatic RC.
&gt; this means that the interface for IO is 'pure', but its behavior at run-time is impure. That is a good summary. It is ultimately a matter of perspective: that we keep referential transparency while dealing with `IO` values is about as important as the fact that `IO` values give us a way to do impure things.
Sure, but Swift isn’t pure! iiuc
My point was that cycles are possible in strict and pure language. As evidenced by what commonly causes cycles to arise in Swift, which does _not_ rely on mutation/impurity.
gtk2hs is not the way to go for new projects. The bindings generated from [https://github.com/haskell-gi/haskell-gi](https://github.com/haskell-gi/haskell-gi) are much better (and use gir). You should edit y: our comment to reflect this. This is even mentioned in one of the first lines of the readme here [https://github.com/gtk2hs/gtk2hs](https://github.com/gtk2hs/gtk2hs), but you should update your comment to reflect this.
Sure, I edited my response, fyi last year at our university we did use `gtk2hs` for a small group project. 😶
I think it would be more appropriate to say: "Because the only thing these functions (the primitive functions of the type `a -&gt; IO b`) do is influence the outside world (or receive input from there), we are no longer talking about *side* effects, but just about effects. Pure functions disallow side effects, but happily express (explicit) effects." What it means to run such an effect then, that is what is hidden in the runtime system, but I think that is actually orthogonal to the concept of purity. Other examples exist as well, such as using an STArray to implement efficient sorting. The fact that internally mutable datastructures are used there will not change how pure the function is.
Oof, even windows reinstall didn't help. Still stuck at ``` Failed to load shared library 'libcairo-gobject-2.dll' referenced by the typelib: 'libcairo-gobject-2.dll': The specified procedure could not be found. Could not resolve symbol "cairo_gobject_context_get_type" in namespace "cairo" ```
Universities are often behind the times on software choices. Like any organization, once they've picked something, changing it takes work.
I wrote a [detailed overview](https://www.reddit.com/r/haskell/comments/a6bvr2/graphics_in_haskell/ebxti0v/) of this topic a while ago. I'll copy it in here: I struggled with this for a while - there are many old GUI packages, and many of them don't work or can't be installed on Windows (which I use). However, the major packages tend to work (although it tends to be easiest to install them using `stack`, not `cabal`): * The [`threepenny-gui`](http://hackage.haskell.org/package/threepenny-gui) library is best if you just want a simple way to make GUIs. However, it doesn't really do *desktop* GUIs as such: it displays your GUI as a webpage running on `localhost`. (However, it does have [Electron integration](https://github.com/HeinrichApfelmus/threepenny-gui/blob/master/doc/electron.md), which can be used to make a desktop application.) * If you want a simple way to make a desktop GUI, [`fltkhs`](http://hackage.haskell.org/package/fltkhs) \- which binds to the FLTK library - is a good bet, as it's the easiest to install of all the Haskell desktop GUI libraries (even on Windows!). Unfortunately, the FLTK library doesn't create the prettiest GUIs in the world (e.g. see the [GitHub page](https://github.com/deech/fltkhs/tree/master/images)). If you care about such things, the author has also released the [`fltkhs-themes`](https://hackage.haskell.org/package/fltkhs-themes-0.1.0.1/docs/Graphics-UI-FLTK-Theme-Light.html) library, which provides a set of widgets with a much nicer style - see [the GitHub page](https://github.com/deech/fltkhs-themes-demo) for a showcase. * The standard way to make GUIs in Haskell today seems to be using the GTK library. (This is what Leksah uses.) There are two widely-used libraries available: [`gtk3`](http://hackage.haskell.org/package/gtk3) and [`gi-gtk`](http://hackage.haskell.org/package/gi-gtk]). Although the latter seems to be recommended these days, I have found it to be almost impossible to install on Windows (at least, I haven't succeeded yet), and I haven't found any problems with `gtk3` yet. And by the way - if you're on Windows, don't be fooled by the dense [Haskell Wiki installation page](https://wiki.haskell.org/Gtk2Hs/Installation)! If you're using `stack`, then you can install GTK on Windows by going through the [GTK+ Download page](https://www.gtk.org/download/windows.php), but ignoring the instructions to install MSYS2 and prepending `stack exec --` to each command, so e.g. `stack exec -- pacman -S mingw-w64-x86_64-gtk3`; after this, you should be able to use `gtk3`! (It should be easier on other platforms - simply follow the [appropriate download page for the OS](https://www.gtk.org/download/index.php), and then you should be able to use `gtk3`. * If you just want to draw stuff on a window, then have a look at [`gloss`](http://gloss.ouroborus.net/) (a very simple yet useful interface to OpenGL) and [`sdl2`](http://hackage.haskell.org/package/sdl2) (which gives bindings to the SDL library).
 {-# OVERLAPPABLE #-} instance (Applicative f, Num a) =&gt; Num (f a) where ... Can make the later work. Just pointwise-lift everything. GHCi, version 8.4.4: http://www.haskell.org/ghc/ &gt; :set -XFlexibleInstances &gt; :{ | instance (Applicative f, Num a) =&gt; Num (f a) where | (+) = liftA2 (+) | (-) = liftA2 (-) | (*) = liftA2 (*) | negate = fmap negate | abs = fmap abs | signum = fmap signum | fromInteger = pure . fromInteger | :} &gt; :t [1]:[1,1] [1]:[1,1] :: Num a =&gt; [[a]] &gt; [1]:[1,1] [[1],[1],[1]] --- For the former, I don't think the laws of both `Integral` and `Fractional` can be followed at the same time. In particular, `to Integer` from `Integral` implies that your type would need to be a subset of the Integers, but `fromRational` mildly implies that your type would need to be a superset of the Rationals. Still, you could provide an instance for `()` that would be accepted by GHC for either or both. GHCi, version 8.4.4: http://www.haskell.org/ghc/ &gt; :{ | instance Num () where | (+) _ _ = () | (*) _ _ = () | negate _ = () | abs _ = () | signum _ = () | fromInteger _ = () | instance Real () where | toRational _ = 1 | instance Integral () where | quotRem _ _ = ((),()) | toInteger _ = 1 | instance Fractional () where | recip _ = () | fromRational _ = () | :} &gt; :t 1.0:[div 1 1] 1.0:[div 1 1] :: (Fractional a, Integral a) =&gt; [a] &gt; 1.0:[div 1 1] [(),()]
Your intuition regarding getLine isn't really accurate. It's not "pure". It can't be pure, it explicitly pulls in information external to the Haskell runtime. IO can be thought of as a reference to the computational context of the world outside of the Haskell runtime. Think of it like a door to the outside world. return 'generates' a refference to the world and puts in the scope of a functions execution, so anything that needs to reach from that door to put information in your function, or anything that needs to come out of your function ando go into the world is 'allowed' to do so. In the context of GHC, 9 times in 10, this probably means an FFI call or two is taking place and values are being exchanged with C function calls. &gt;&gt;= takes an existing reference to the world and passes it, and a 'pure' value to another function that is meant to operate in IO. It makes sure that you're using the same door between both the left and right functions, e.g., they inhabit the same world. It's the state monad - the value being passed around as state is just a 'magic' identifier that doesn't really do anything, and you get to do a bunch of other things because the type system says you can. The whole deal is literally just to make sure stuff gets called in a deterministic order with respect to other linked computations.
There are basically two approaches. The boring one is to make bindings for existing C/C++ libraries. There are already bindings for some of them in various states of completion and maturity. However, direct use of such bindings tends to force a rather imperative style of GUI code. The more interesting approach is a functional GUI library. I'm not sure there's even consensus on what exactly that means, but functional reactive programming (FRP) has been popular and is used for several attempts.
Very interesting! Thanks for the explanation and the examples.
I was literally trying to understand this today due to the NonDet effect from freer-simple.
As far as I know, "getLine" simply defines a recipe for pulling information from the outside world, which we call an "IO action." "getLine" doesn't pull the information from the external source as you're saying, the runtime system reads the action and executes them, the functions do not perform any side-effect. The recipe is the same every time the function is called, making it referentially transparent. No wonder why you can't just flatten it and fetch the string from the IO monad! If the functions weren't pure, we could just do whatever we did similar to other languages, that is - imperative programming. Everywhere in Haskell's documentation, I've read that the functions such as "getLine" are pure, since the side-effects occur OUTSIDE the function calls - in the runtime system. Based on my knowledge, none of the side-effects are performed until the "main" function returns the IO monad. IO monad is indeed a backdoor to the outside world, but only operations are defined through it, not executed. Correct me if I'm wrong.
Thanks for the explanation. I was confused due to some stackoverflow answers claiming that functions like "getLine" and "putStrLn" aren't pure.
There are two issues with lists: (1) sometimes they take up more memory than is necessary (2) sometimes the operations take more time than is necessary &amp;#x200B; But only sometimes -- sometimes a list is the best option. When I first started writing Haskell 15 years ago I used lists for lots of things. I still do, but I used to, too. But now I sometimes use \`Text\`, \`ByteString\`, \`Vector\`, \`Seq\`, and other data structures instead of a list. I am not moving \*away\* from lists, I am just incorporating additional data structures that are easily accessible these days when it seems like a good match. We've moved from "lists!" to "lists and!"
I'm not quite sure what you mean by the Conduit point. If you need to interleave *effects* with "list processing", you'd need to do something like Conduit, Pipes or even io-streams. The use cases for plain lists and Conduit (at the like) seem to be non-overlapping to me.
Can't find "cron-daemon" anywhere. Managed to run with \` stack build --file-watch --exec 'webshow -d ./webshow' \`.
At runtime, they are interacting with the console and whatnot. They aren't pure. However, they don't do anything until you run them, just like any other function. In particular, haskell generally blurs the line between a value and a no-argument function that returns a value. That's the point of laziness. When you evaluate 2+2, it doesn't return 4. It returns a thunk (ie a no-argument function) that will return 4 when you evaluate it. If you take that value and add 3 to it, well, you get a thunk/no argument function that will evaluate the 2+2 thunk and then add 3 to the result. If you eventually print it to the console in main, the runtime actually runs all of those thunks and prints out the returned value. In practice, you end up limiting laziness in some cases, since producing a thunk that will add 2+2 is a lot more expensive than simply adding 2+2. I don't know the details of how the compiler/run time handles specific cases, but managing the laziness properly is apparently one of the main issues that people run into when trying optimize haskell code.
Any good learning resourses? I've watched Derek Banas video and read most of Learn You A Haskell but It feels like I get stuck when reading and don't understand some parts.
I don't know how you judge the purity of a function but these functions are just tossing around IO Monads, not posing any side-effect. They are referentially transparent. All these properties should make them "pure." What happens in the runtime happens outside the functions. &gt; At runtime, they are interacting with the console and whatnot Assuming that with "they," you meant the functions. The functions never interact with the outside world as far as I know. The runtime system does, and it's done only when the main function returns the IO monad. I don't see how you imagine the functions being "run." It's the IO monad which represents the action and based on its content, the actions are carried out. This in no sense is "running" the functions.
To an extent, I feel like you are splitting hairs. When you write `main = putStrLn "Hello World"`, the result is that hello world is printed to the console. Sure, this only happens if you actually call it from main, but the same is true in many procedural languages. Say you have a c-esque program like void greet() { print("hello world"); } int main(int argc, const char* argv[]) { greet(); } This is functional equivalent to the haskell program greet = do putStrLn "hello world" main = do greet In both cases, `greet` is essentially a no-argument function that prints to the console and doesn't return anything, and main is a no argument function that just calls greet. Both are impure, since they result in printing to the console. Trying to draw a distinction between the haskell version and the c version seems sort of pointless. I guess you can try to argue that putStrLn on its own is a pure function that returns an "io value" (ie a potentially impure no-argument function). However, getLine is an io value, which means that it is an impure no-argument function.
Did you read the definition of IO monad (in sources) used in haskell platform?
=). Lazy lists are a streaming interface just like any other. They are a lot nicer to use, but they have nontrivial automatic behavior and this can bite. Manual streaming is messier, but a lot more predictable. For this reason it is better to not use lists in some situations, and this is recognized in the community. What about it looks like ads ?
Now you can see our differences here. In the haskell program, "greet" does return something - "IO ()" which is an instance of the IO monad. So does "main." The functions DO NOT print to the console, but just returns the definition of the recipe for printing to the console. That recipe reaches the runtime system, which performs it, not the function. The function instructs the runtime system to execute the actions, but it doesn't perform any action itself. It's referentially transparent. There isn't a single line of imperative code in the Haskell program. So, if the runtime refuses to perform the actions, nothing happens, the functions are powerless. In the C-esque program, those functions aren't returning anything, but performing actions themselves. That's pure imperative code! In short, I do agree that "greet" in the Haskell program is a no-argument function, but couldn't agree about the return value, as "do" is basically a syntactical sugar for &gt;&gt;= in this case. This results in a type signature of "greet :: IO ()." I need help understanding this: Can't a pure function take 0 argument? Do the functions lose referential transparency when they return the IO Monad?
Not yet. The [PR](https://github.com/haskell/haskell-ide-engine/pull/1126) which implements it is a big structural change to HIE which needs more refinement before merging.
Reading the post title I expected a new programming language “Show”
In haskell, a pure function that takes 0 arguments is just a value. In theory, the only distinction is when the computation takes place, and haskell's laziness means that that distinction doesn't really exist. Also, if an IO String is a recipe that will result in a string when the runtime executes it, how is that not a no-argument impure function? Creating the recipe doesn't cause side effects, just like defining an impure function doesn't cause side effects. However, when you execute either, you get side effects. Overall, I think you are worrying too much about theory. I mean, at a practical level, nothing is referentially transparent. Think about a badly written recursive fibonacci function (where the recursive step is `fib x = fib (x-1) + fib (x-2)`). If you replace a call to `fib 100` with the 100th fibonacci number, that's a pretty significant change, even though they would result in the same value (assuming the fib call ever returned). Similarly, if you see a function with the type `Int -&gt; Int`, is it pure? Honestly, you have no clue. It should be, certainly, but it could also use unsafePerformIO to do whatever it wants. And if you want to go the other way, there is no such thing as an impure function. There is only functions that implicitly take in and return a "RealWorld" value. That's a pretty pointless definition, but it sort of works if you tilt your head at the right angle. In practice, if you see an IO String, you aren't going to be able to get access to an actual string without side effects (potentially, at least). That's the important thing. Technically speaking, some of the things you are dealing with will be impure functions, and some of the things you are dealing with will be pure functions that themselves take in and return impure functions. I simply don't think that labelling each individual bit as pure or impure is a useful exercise.
I don't know about your use of these libraries but you can check for a DAG with \`Data.Graph\` using \`stronglyConnComp\` and then check if any of the strongly connected components are of case \`CyclicSCC\`. As for a proof of why this works correctly, sorry I don't remember, I've used it about a year before. It definitely worked for me in practice.
It does seem like `fgl` and `Data.Graph` do a topological sort if the input is a DAG, and something else otherwise. The documentation should mention this. At a glance, I didn't find a function that decides whether a graph is acyclic (in either library), so you may have to write that yourself. (Aside: The empty list would not be a suitable representation of "input is not a DAG", as it is a valid topological ordering of the empty graph. In this sense, the type of `topsort` already indicates that something is fishy.)
&gt;Also, if an IO String is a recipe that will result in a string when the runtime executes it, how is that not a no-argument impure function? Creating the recipe doesn't cause side effects, just like defining an impure function doesn't cause side effects. However, when you execute either, you get side effects. Execution of a function like `putStrLn` doesn't cause side-effects, only an IO monad is returned by such a function, that's all the function does. The monad is passed through the `main` function to the runtime system. The runtime system executes the actions defined in the IO monad, causing side-effects like printing to the screen, taking input, etc. The side-effects do not take place anywhere except the RTS. &gt; In the case of greet, it doesn't return the IO (), it is the IO (). It's also a no-argument impure function that doesn't return a value. If `greet` equals `IO ()` then how is it impure? It's not causing side-effects, it just equals a value. It's referentially transparent, is it not? Just explain me how a value such as `IO ()` leads to impurity. &gt; If you replace a call to fib 100 with the 100th fibonacci number, that's a pretty significant change, even though they would result in the same value (assuming the fib call ever returned). Replacing `fib 100` with the 100th fibonacci number would make no difference in a practical sense, as the `fib` function is referentially transparent. Computation is done only when the result in unknown, but if you know the result, caching it is only going to be beneficial. Referential transparency is vital - be it practical or theoretical. &gt; Similarly, if you see a function with the type Int -&gt; Int, is it pure? Honestly, you have no clue. It should be, certainly, but it could also use unsafePerformIO to do whatever it wants. Right. &gt; Also, very minor nitpick: do in those functions isn't syntactic sugar for &gt;&gt;=, it's just a noop. If there were multiple lines after the do, then &gt;&gt;= or &gt;&gt; would get involved. I mostly just added it so that main wouldn't literally be main = greet. In haskell, these two definitions are the same, but they aren't in other languages. My bad, I'm correcting it.
[removed]
&gt; Keep the story going. Sign up for an extra free read. :-(
Since some other replies still claim that `getLine` has effects, I wanted to clarify: * The `putStrLn` *expression* has no side-effects. Period. * The resulting *recipe* does have side-effects. I think it's correct to say that `getLine &gt;&gt;= putStrLn` is pure, because it is by definition a Haskell expression, not a recipe. An important thing that is often missed is that execution of recipes and evaluation of expressions get *interleaved* when a program is run. In the above example, only the first action in the recipe is known up front. `putStrLn` is hidden under a lambda, so some pure evaluation has to be done in order to get the rest of the recipe. I think this interleaving is why people still think that IO expressions have effects.
 class (Category p, Category q) =&gt; FunctorOf (p :: k -&gt; k -&gt; Type) (q :: l -&gt; l -&gt; Type) (f :: k -&gt; l) where
One thing I like about Haskell is that its development is done in almost the opposite way to other languages. So most languages develop over time by adding to the language syntax as new ideas and trends are invented. On the other hand, Haskell comes from mathematics so its design is based in basic computational theory, and so we're actually still ***discovering*** what we can do with it. So rather than updating the basic syntax all the time, advanced research is mostly done in libraries that are developed to use the language in new and intriguing ways that no-one realised was possible before.
I generally use another navigator when that happens.
I believe it is more preferable to give the first chapters as a sample chapter instead of the middle. I dunno why Apress will display chapter 17
I actually like when there are (also?) some "proper chapters" in a preview, so you can see what's the level of the bulk of the content. First chapters are often introductions, and it's hard to judge how deep the rest of a book is, based on them only.
This generalized `Functor` class is in categories: https://hackage.haskell.org/package/categories-1.0.7/docs/Control-Categorical-Functor.html :)
This is the latest hobby project of mine. It uses Reflex, which means 100% Haskell in both frontend and backend, with the common package shared between the two. Frontend uses the reflex library, via obelisk. I've never had this much fun writing web apps. FRP makes it a piece of cake, once you get past the initial learning curve.
I bought myself a copy and have been skimming it. One thing I noticed is this must be one of the last books to recommend the Haskell Platform despite explaining the use of Stack in subsequent chapters &gt; At this point you are probably feeling the need to try Haskell on your own computer. The first step for this is, of course, to have a working Haskell installation on your system. Haskell developers worried in the past about how to get people ready fast and easily. &gt; &gt; So, they created the Haskell Platform, a distribution containing the GHC compiler, the Cabal build and library system, and a comprehensive set of libraries. To get the Haskell Platform, go to http://www.haskell.org/platform/. Then, follow the steps corresponding to the operating system you will be using. The book does a good job at being impartial about "Cabal and Stack" and in a respective subsection *very briefly* describes the differences as &gt; A fair question to ask is what the differences between them are. In general, Stack is focused on having reproducible builds, whereas Cabal encompasses many more usage scenarios. and then goes on to briefly describe Hackage and Stackage and concludes by punting on a verdict which tool you should use &gt; If you are in doubt of which tool to use, don’t worry and start with any. As I discussed above, both share the same package description format, so changing from one to the other is fairly easy. Later chapters walk you through performing the same tasks with either tool and even mention Cabal's modern `new-*` commands.
:shrug:, the Conduit part of that is a bit beside the point, I was just saying &gt; You need to be aware of trade-offs and know when to use {whatever list-like thing offers proper behavior for your scenario} Others have said mutable arrays, or `Vector`, I happened to use `Conduit`, because we often change code like: traverse_ f someList To someSource |. mapM_ f When we realize processing a stream makes more sense than processing a over a list in whatever case. Of course, whether this makes sense is entirely dependent on specific circumstances.
Just a tangent question: why are the QuickCheck style generators defined using \`split\` rather than by threading the seed, i.e. \`newtype Gen a = Gen (StdGen -&gt; (a, StdGen))\`? This would avoid the issue with monad laws (since it would be just a state monad).
Footnote 2 :) In short: to avoid being too strict.
I wrote this function quite some time ago to find cycles. Perhaps it'll help. I think I used containers instead of fgl. -- Given a map of names to their dependencies return either a list of names -- that are part of cycles or a list of names that specify the (reverse) order -- in which the names should be processed findCycles :: M.Map T.Text (S.Set T.Text) -&gt; Either [T.Text] [T.Text] findCycles m = let (dg, vertToNode, _) = G.graphFromEdges $ map (\(a,b)-&gt;(a,a,b)) $ M.toList (M.map S.toList m) nodeName = (\(a,_,_)-&gt;a) . vertToNode (lb, ub) = A.bounds dg -- For each node, find it's successors and determine if it has a path back recDeps = [nodeName x | x &lt;- [lb..ub] , y &lt;- dg A.! x , G.path dg y x] in if not (null recDeps) then Left recDeps else Right . map nodeName . G.topSort $ dg
This is wild stuff
There are functions on the same page to check for SCCs, can't you use that instead?
I didn't mean to call anybody out, but I stand by the word neglected. It's nobody's fault. Simple facts are that: * GHC development is driven by what the GHC users demand, and that's a good thing, * the GHC user base will use GHC for what it's already good at, because they have a job to do, * they will demand further improvements to those features of GHC they use, and * they will complain if a development irrelevant to their needs breaks their code or causes a noticeable compilation or runtime slowdown. It's just a consequence of GHC's failing to avoid success, I guess, that now it's stuck in a rut. No big architectural change is allowed unless it can prove that the existing production code will continue to work as before. That's a heavy burden that a fresh compiler wouldn't need to carry.
So Haskell is like mathematics, you are always discovering, opposed to creating new ideas. Do you know how awesome what you are saying is? That is like pandoras box, but in a good way.
Nice post. I don't like the name `unsafeDependent` for an operation that is perfectly fine except that it results in sub-optimal shrinking. This function is not going to break type safety, result in invalid states, or even throw exceptions.
It may, however, result in non-termination (`iSuchThatWRONG`). I guess I was using "unsafe" as a shorthand for "warning, this probably won't work quite the way you expect it to". But sure, fair enough, I don't insist on the name :)
A reasonable technique, though I find not great for reliability, even if it improves performance.
One of the things I would like to see in haskell is a better and more elegant treating of the more general functor. &amp;#x200B; I think it is also a syntactic challenge, i really don't like: class FunctorOf (p :: k -&gt; k -&gt; Type) (q :: l -&gt; l -&gt; Type) f where map :: p a b -&gt; q (f a) (f b) &amp;#x200B; i would rather have something like: class FunctorOf ((-&gt;_1) :: k -&gt; k -&gt; Type) ((-&gt;_2) :: l -&gt; l -&gt; Type) f where map :: a (-&gt;_1) b -&gt; (f a) (-&gt;_2) (f b) So there's a syntactic difference between my "main" variables and the mostly static ones.
Yep, there is no shortage of them. (I’m not the author of the post.)
I would argue that the problem with `iSuchThatWRONG` stems from `repeatUntil`. The monad interface makes every generated intermediary value matter and tries to shrink them all. And a computation that first checks `p 0` and finds it false, then tries `p 2` is lexicographically smaller than one that checks `p 1` and returns. Also, I noticed that the `iSuchThat` functions use `dependent`. Is this the same as `unsafeDependent`?
&gt; Although `Gen` is a monad, `Manual` is not (indeed, it’s not even a functor). `Manual` can be tweaked into a `Profunctor`, and thus `Functor` (but is it useful? I want functors) data Manual i o = Manual (Gen o) (i -&gt; [o]) instance Profunctor Manual where dimap :: (i' -&gt; i) -&gt; (o -&gt; o') -&gt; (Manual i o -&gt; Manual i' o') dimap input output (Manual gen shrink) = Manual (output &lt;$&gt; gen) (dimap input (output &lt;$&gt;) shrink) After trying a bit it doesn't seem to be [`Strong`](https://hackage.haskell.org/package/profunctors-5.4/docs/Data-Profunctor.html#t:Strong) profunctors, is maybe a [`Choice`](https://hackage.haskell.org/package/profunctors-5.4/docs/Data-Profunctor.html#t:Choice) but er, this doesn't feel lawful instance Choice Manual where left' :: Manual i i' -&gt; Manual (Either i o) (Either i' o) left' (Manual gen shrink) = Manual (Left &lt;$&gt; gen) $ \case Left i -&gt; [] Right o -&gt; [Right o] `mPair` looks almost, but not quite like [`ProductProfunctor`](http://hackage.haskell.org/package/product-profunctors-0.10.0.0/docs/Data-Profunctor-Product.html#t:ProductProfunctor)'s mPair :: Manual a a -&gt; Manual a' a' -&gt; Manual (a, a') (a, a') (***!) :: Manual i o -&gt; Manual i' o' -&gt; Manual (i, i') (o, o')
You've got two different `groupBy`'s in mind. λ&gt; import qualified Data.List as List λ&gt; List.groupBy (&lt;=) [1,2,2,3,1,2,0,4,5,2] [[1,2,2,3,1,2],[0,4,5,2]] λ&gt; import qualified Data.List.GroupBy as GroupBy λ&gt; GroupBy.groupBy (&lt;=) [1,2,2,3,1,2,0,4,5,2] [[1,2,2,3],[1,2],[0,4,5],[2]]
For curious people, data Tree a = Node { root :: a , subtrees :: [Tree a] } is the [`Cofree` comonad](https://hackage.haskell.org/package/free-4.12.4/docs/Control-Comonad-Cofree.html) of lists type Tree = Cofree [] data Cofree f a = a :&lt; f (Cofree f a)
Pretty sure this book is free for students &amp;#x200B; [https://link.springer.com/book/10.1007/978-1-4842-4480-7](https://link.springer.com/book/10.1007/978-1-4842-4480-7)
registry, what a nifty library! I use a similar idea in generic-random to derive QuickCheck `Arbitrary` instances, parameterizing the generic derivation by a "registry" of generators to be used instead of existing `Arbitrary` instances for chosen fields. (See [the section on custom generators in the tutorial/manual](https://hackage.haskell.org/package/generic-random-1.2.0.0/docs/Generic-Random-Tutorial.html) for example usage.) registry appears to rely on type reflection (i.e., `Typeable`), at least internally. What happens if you register a function but forget to register generators for its arguments? (in generic-random you either get the bad `Arbitrary` instance or an instance resolution error if none exists) I think there's still an interesting way of taking advantage of the type-directedness of type classes for data generation not with newtypes, but with "indexed classes", which are just the same type classes with one extra parameter to distinguish and support multiple instances for the same type. (See for example this haskell-café discussion: https://mail.haskell.org/pipermail/haskell-cafe/2017-May/127147.html) -- Encode values of type a with "resolver" r class ToJSON r a where toJSON :: a -&gt; Value For example, for `ByteString` the resolver could determine different encodings: data Base64 data Escaped instance ToJSON Base64 ByteString where toJSON = toBase64String :: ByteString -&gt; Value instance ToJSON Escaped ByteString where toJSON = toEscapedString :: ByteString -&gt; Value Of course, with that change, generic deriving, in its current form in aeson for example, doesn't work out-of-the-box anymore because it cannot decide what instance to pick for each field, but that's the whole point of it, to not have the library make arbitrary choices silently for you. But once you've associated a resolver to every type, and chosen a particular generic deriving strategy, the library should be able to write the corresponding boilerplate. With that approach, people can create "registries" or "namespaces" of instances which are isolated from each other but are all compatible with the main library providing the typeclass and whatever associated utilities.
Important is also why Data.List.GroupBy exists: “This module provides an alternative definition for groupBy which does not require a transitive equivalence predicate.”
The book looks interesting! Just a nitpick: There's an extra list item in the list of benefits on the apress page.
OK, makes sense (and sorry for not reading it carefully before posting)
When we filter, we don't want to re-run the generator after we happen to shrink a value to a new value that doesn't satisfy the predicate; this is what happens naturally in the monad interface -- which is not what we want to use here. See also [https://github.com/hedgehogqa/haskell-hedgehog/issues/281](https://github.com/hedgehogqa/haskell-hedgehog/issues/281) for a detailed discussion. &amp;#x200B; No, `dependent` is not the same; the types make it clear at that point that you should manually have thought about the shrink trees (`Gen (Tree a)`).
No worries :)
Thank you both very much. That would explain the issue.
Having \`Manual\` be a functor would indeed be tremendously useful. In fact, in his Lambda Jam talk ([https://www.youtube.com/watch?v=AIv\_9T0xKEo](https://www.youtube.com/watch?v=AIv_9T0xKEo)), Jacob mentions that as one of the motivations that led to the definition in terms of trees :)
Thanks!
You're talking about brackets, but you didn't type any brackets. I'm guessing the brackets are Oxford brackets ("⟦ ⟧"), and that you are reading a text on denotational semantics?
 import Test.QuickCheck import Data.Bifunctor.Joker import Data.Bifunctor.Product import Data.Profunctor data Manual i o = M { arb :: Gen o, shr :: i -&gt; [o] } type Manual' = Product (Joker Gen) (Star []) toManual' :: Manual i o -&gt; Manual' i o toManual' (M g s) = Pair (Joker g) (Star s) fromManual' :: Manual' i o -&gt; Manual i o fromManual' (Pair (Joker g) (Star s)) = M g s -- Choice Joker exists -- Strong Joker doesn't -- Choice: say we have -- -- p :: Prism' s a -- a :: Manual a a -- -- Then we can construct s :: Manual s s -- -- That makes sense, kind of ex :: Manual Int Int ex = M arbitrary shrink ex' :: Manual (Either Char Int) (Either Char Int) ex' = fromManual' $ right' $ toManual' ex -- Let's try -- -- &gt;&gt;&gt; shr ex' (Right 3) -- [Right 0,Right 2] -- -- looks good. -- -- But what about 'Left': -- -- &gt;&gt;&gt; shr ex' (Left 'x') -- [Left 'x'] -- -- Oh, that's crap crap. No use. -- Strong, similarly -- -- if we had -- -- l :: Lens' s a -- a :: Manual a a -- -- we'd be able to get Manual s s -- -- but we cannot get Gen (c, a) from Gen a (via `second'`) -- So there are no Strong for a reason.
Thank you for the pointer!
You can break down the problem in the following three steps: - Convert a record to a heterogeneous list (with generics or TH) (`toHList`) - Process an element of the hlist given by its field name s (`handle`) - Fold the fully processed hlist (`done`) --- Using this implementation of heterogeneous lists (i.e., as nested pairs): data a :+ b = a :+ b newtype Field (s :: Symbol) a = Field a The types of the main three functions are as follows (informally): toHList :: Example -&gt; (Field "foo" Int :+ Field "bar" String :+ ()) -- Specializing the types to this example record for concreteness: -- data Example = Example { foo :: Int, bar :: String } deriving Generic handle :: forall (s :: Symbol). (a -&gt; b) -&gt; (... :+ Field s a :+ ...) -&gt; (... :+ Field s (Done b) :+ ...) -- where newtype Done a = Done a is just there to avoid processing a field twice accidentally -- here, we assume the results have the same type, and we just put them in a list done :: (Field s1 (Done b) :+ Field s2 (Done b) :+ ...) -&gt; [b] Example pipeline: process :: Example -&gt; [Int] process = done . handle @"foo" (\i -&gt; i) -- Int -&gt; Int . handle @"bar" (\s -&gt; length s) -- String -&gt; Int . toHList Full example: https://gist.github.com/Lysxia/c8911619d7ffd7628e68c115c16aa058
That makes some sense. No shade, I was just a bit surprised by the mention of Conduit. (As I would have by mention of pipes, etc.)
***To add more detail:*** You will lead teams who build resilient systems to handle million requests per day without downtime, working closely with a host of functional languages (they're flexible)! They need someone to develop and execute a mid &amp; long-term technical vision and architectural direction in creating highly scalable solutions. This position offers sponsorship and is based in Germany, so if you have a strong understanding of core priorities, KPI's and underlying system architecture...plus experience leading and building cross-functional engineering teams, then this could be really interesting!
Ah yes, you are right that the empty list wouldn't be valid either.
I read the first edition of this book and can recommend it. Good breath of coverage but if I had a small complaint it was that the examples felt a bit contrived in the first edition... Don’t know what has changed in second edition though.
What if you were to mentally substitute "notation" for "syntax" and "meaning" for "semantics"? Would that help? That is I could provide you with alternative function g that maps "0" to boolean false. Then in this example the syntax(notation) of our two languages would be the same but the semantics(meaning) would be different.
Perhaps with some fancy multi-line or whitespace chomping mode, but I don't have the flag(s) memorized.
If Mozart's tool was techno instead of classical instruments: * Mr. Bill * Circuit Bent * Billegal Beats (on soundcloud, a collab with Mr. Bill and many others) * Au5 - Goo Lagoon * Also, gotta say, the Halo and Destiny video game soundtracks. Not techno at all, but sooo great for working to.
How much of the job is Haskell?
I would [convert the native record to an extensible record](http://hackage.haskell.org/package/vinyl-generics); now you have a type-level list and a representation for your record with one field for each entry in the list. Next, I would use [CoRec](http://hackage.haskell.org/package/vinyl-0.11.0/docs/Data-Vinyl-CoRec.html) with the same type-level list in order to represent a sum type with one constructor for each type in the list.
The syntax is what it looks like in the source: https://www.fileformat.info/info/unicode/char/0030/index.htm additive_expr := multi_expr wsp '+' wsp multi_expr | multi_expr The semantics is the idea represented: https://en.wikipedia.org/wiki/0 -- the number; not the digit [[ additive_expr ]] := [[ multi_expr ]] + [[ multi_expr ]] || [[ multi_expr ]] The operational semantics are how the idea is represented at run-time: The 32-bit word 0x00000000 (or something like that). (I think) eval([[ additive_expr ]]) = %ll &lt;- eval([[ multi_expr ]]) %lr &lt;- eval([[ multi_expr ]]) add_i32 %ll, %lr or eval([[ multi_expr ]])
**0** 0 (zero) is both a number and the numerical digit used to represent that number in numerals. The number 0 fulfills a central role in mathematics as the additive identity of the integers, real numbers, and many other algebraic structures. As a digit, 0 is used as a placeholder in place value systems. Names for the number 0 in English include zero, nought (UK), naught (US) (), nil, or—in contexts where at least one adjacent digit distinguishes it from the letter "O"—oh or o (). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/haskell/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
I think we are getting confused on terminology. Function in haskell means something very different than function in C. For the rest of this post, I'll use procedure for the c definition of function. With these definitions, an IO blah is not a function. However, it is a 0 argument (potentially) impure procedure. It is also a value, because everything is a value in haskell. When you are working with IO in haskell, you are using a bunch of pure functions and smaller impure procedures to define a larger impure procedure. Main (ie the thing you actually run) is one of these larger impure procedures. So no, I wouldn't say that main is pure in any useful sense of the word. It is a 0 argument impure procedure. Sure, you used a bunch of pure functions in the definition, but those functions won't actually compute anything until the larger impure procedure is run. If you use a bunch of `unsafePerformIO`s to track when every bit of your code is actually evaluated, evaluation of the pure code will be interwoven with evaluation of the impure code. On the other hand, if you want to get technical, `putStrLn` is a pure function that returns an impure procedure. In a language where a two argument function is just a one argument function that itself returns a one argument function, this seems like a relatively thin line. However, fair enough, there definitely is a line there.
&gt;What happens if you register a function but forget to register generators for its arguments? You have compile-time checks (and runtime checks if you don't want compile-time checks) to verify that you can build a value from the registry. This doesn't do a full analysis (in particular cycles are not checked), but uses the following approximation: * the type of value you want to build must be the return type of one of the functions (or values) * all the input types of the registry must be included in all the output types &amp;#x200B; &gt;I think there's still an interesting way of taking advantage of the type-directedness of type classes for data generation not with newtypes, but with "indexed classes" &amp;#x200B; Interesting, this is reminiscent of [https://chrispenner.ca/posts/mock-effects-with-data-kinds](https://chrispenner.ca/posts/mock-effects-with-data-kinds).
 class FunctorOf (dom :: k -&gt; k -&gt; Type) (cod :: l -&gt; l -&gt; Type) f where map :: a `dom` b -&gt; f a `cod` f b
Your first stab is pretty close, just use `KnownSymbol` ``` givenAFieldFromFoo :: forall field a. (KnownSymbol field, HasField' field Foo a) =&gt; Foo -&gt; (Text, a) givenAFieldFromFoo foo = ("you used the " ++ symbolVal (Proxy @field) +++ " field", getField @field foo) ```
I'm literally unable to figure out what the first groupby is actually doing...
Author here, in case you have any question or comment :)
It compares everything in the group to the first element of the group. It's implemented in terms of `span`: groupBy _ [] = [] groupBy eq (x:xs) = (x:ys) : groupBy eq zs where (ys,zs) = span (eq x) xs There's a few problems with this, like the unexpected behaviour on `&lt;=`, and also it isn't a good consumer. There's [a blog post](https://doisinkidney.com/posts/2018-01-07-groupBy.html) explaining the motivation for the package.
A bit late to the comments, but if Purescript is an option, you should look at Concur (https://github.com/ajnsit/purescript-concur). It uses React as the view library so you can use any React widget. I also have a Haskell version of Concur, but it's GHCJS based, and I'm, like you, less enthusiastic about GHCJS.
ping /u/etorreborre !
&gt; Using our `interp`reter from above, there are two possible outcomes from evaluation: &gt; &gt; 1. `3 = 0 + 1 + 2` (corresponding to this sequence of memory effects: `‵recall; (‵set 1); (‵set 2)` &gt; 2. `4 = 1 + 1 + 2` (corresponding to this sequence of memory effects: `(‵set 1); ‵recall; (‵set 2)` I found it a bit distracting that the author omitted the other two non-interleaved possibilities before discussing the interleaved one. * `5 = 2 + 1 + 2` (corresponding to this sequence of memory effects: `(‵set 2) :‵recall; (‵set 1)` * `4 = 1 + 1 + 2` (corresponding to this sequence of memory effects: `(‵set 2) :(‵set 1); ‵recall` Also the additions are in the wrong order. (it should be `(1 + ?) + 2` instead of `(? + 1) + 2`. The point might be easier to make with `(‵recall ‵+ ‵recall) ‵+ (‵set 1)`
A bit more detail in your post would give r/Haskell readers a better sense of whether or not they'd care to click through. So, my suggestion: A discussion of a tool-development experience in Haskell: "During work it often comes up that I have to check whether a client accidentally leaked their secrets via their public code repositories. Often they do not have clients in the latest version of their code, but sometimes they do still have secrets somewhere in the history of their code. I figured I could write a little tool that could scan a git repository, both the current code and its history, to see if there were any secrets to be found." Includes a brief discussion of related tools, and efforts to recruit users.
About a year ago I applied to this company. Back then they said "most of our backends are built in Scala and Haskell". I never heard back, even after following up. Coincidentally, shortly after my application they quietly removed Haskell from the above sentence. It's been gone ever since.
I used to work there. In my team we did purely functional Scala, and shortly after I left they switched to Haskell. They definitely used it for a while and as far as I know they still do. But it's a company with several hundred developers and I suppose less than twenty write Haskell on a daily basis.
Is hedgehog's [TreeT](http://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog-Internal-Tree.html#t:TreeT) and instantiation of [CofreeT](https://hackage.haskell.org/package/free-5.1/docs/Control-Comonad-Trans-Cofree.html#t:CofreeT)? [NodeT](http://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog-Internal-Tree.html#t:NodeT) also looks very similar to [CofreeF](https://hackage.haskell.org/package/free-5.1/docs/Control-Comonad-Trans-Cofree.html#t:CofreeF).
I can confirm that a few of those services are using Haskell. I've been away from the project for a while so I don't know about the exact plans these days. However I should be at a meetup with my previous team tomorrow so send me a message if you want fresh news!
Can confirm, this works
 {-# LANGUAGE FlexibleContexts #-} {-# LANGUAGE FlexibleInstances #-} {-# LANGUAGE MonoLocalBinds #-} {-# LANGUAGE MultiParamTypeClasses #-} {-# LANGUAGE PolyKinds #-} import Prelude hiding (map) import Data.Kind (Type) import Data.Profunctor (Star (..)) class FunctorOf (p :: k -&gt; k -&gt; Type) (q :: l -&gt; l -&gt; Type) f where map :: p a b -&gt; q (f a) (f b) instance (Traversable t, Applicative f) =&gt; FunctorOf (Star f) (Star f) t where map (Star f) = Star (traverse f) traverse' :: FunctorOf (Star f) (Star f) t =&gt; (a -&gt; f b) -&gt; (t a -&gt; f (t b)) traverse' f = runStar (map (Star f))
The display logic would be great to add to [HyperHaskell][1]. [1]: https://github.com/HeinrichApfelmus/hyper-haskell
Eh. Imagine we're working in JavaScript for a second: const putLine = str =&gt; ({ $io: { type: 'putLine', string: str } }); export const main = putLine('hello'); I would say that the function `putLine` (as well as `main`) is pure by any sense of the word. It just returns a data structure. Now we might build an `interpret` function, which takes such a value and interpretes it: const interpret = ({ $io: ioRecipe }) =&gt; { switch (ioRecipe.type) { case 'putLine': console.log(ioRecipe.string); } }; This is the impure function. Same thing in Haskell. An `IO` action is just a value, a description of side effects that you'd like to happen, so pure. The GHC runtime is impure. But you can imagine feeding a Haskell `main` into something else, maybe a test function that gathers outputs into a log file instead. With something like a C procedure, you can't just feed the `main` function to something and "interpret" its side effects. The act of running `main` inherently performs the side effect. You'd need to compile the code first and turn it into an AST (at which point the AST representation of the procedure does become pure, but it's no longer "C code").
How on earth would you implement bind with your io recipe implementation? And what would something like do s &lt;- getLine putStrLn ("Hello " ++ s) look like? However, if putStrLn is implemented as const putLine = str =&gt; function () { console.log(str); } then bind and return (lets call it pure because return is a js keyword) are easy. They are function bind(m, f) { return function() { var intermediate = m(); return f(intermediate)(); } } function pure(v) { return function() { return v; } } Boom, instant, fully functional io monad. If you want an example of a very usable haskell-like that is built like this on top of js, check out purescript. Looking at purescript's [implementation of pure and bind](https://github.com/purescript/purescript-effect/blob/master/src/Effect.js) for the Eff monad (basically what it calls IO), yup, that's basically the same code. And the purescript [console.log](https://github.com/purescript/purescript-console/blob/master/src/Effect/Console.js) looks a great deal like my example putLine implementation. One of the key ideas behind functional programming is that first class functions and function composition are really versatile tools. Why wouldn't you use them to implement IO?
&gt; How on earth would you implement bind with your io recipe implementation? Something like this: const putLine = str =&gt; ({ $io: { type: 'putLine', string: str } }); const getLine = { $io: { type: 'getLine' } }; const bind = (action, continuation) =&gt; ({ $io: { type: 'bind', action, continuation }}); const interpret = ({ $io: ioRecipe }) =&gt; { switch (ioRecipe.type) { case 'putLine': console.log(ioRecipe.string); return null; case 'getLine': return prompt('Enter a line:'); case 'bind': return interpret(ioRecipe.continuation(interpret(ioRecipe.action))); } }; interpret( bind( getLine, putLine ) ); Basically just use a continuation that captures the rest of the chain, then when you run an action feed it to the rest of the chain. Pretty similar to how you'd write an interpreter for a free monad in Haskell. &gt; You'd probably have to write an entire intermediate language for your io monad, and you'd have to compile all of haskell into that language (since you have to be able to feed the results of monadic operations to pure functions -- getLine isn't very useful if you can't do something with the line you got). No? All you need is a sum type with a constructor for each type of IO action. EDIT: Slightly more interesting example: interpret( bind(getLine, firstName =&gt; bind(getLine, lastName =&gt; putLine(`Hello ${firstName} ${lastName}`) ) ) )
Yeah, I remembered after I posted that there are structures that do similar things. That said, that isn't how the actual io monad is implemented (in ghc, at least). If you look at the [actual source](http://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#line-1363) of ghc's prelude implementation, io is a wrapped `State# RealWorld -&gt; (# State# RealWorld, a #)` (judging from the implementation of `unIO`), and `bind` is bindIO (IO m) k = IO (\ s -&gt; case m s of (# new_s, a #) -&gt; unIO (k a) new_s) It creates a new `State RealWorld -&gt; (State RealWorld, a)` function (call it inner) where the body pulls out the inner `State RealWorld -&gt; (State RealWorld, a)` funtion from the first argument, gives it the realworld argument that inner got, and breaks the result into a new realworld and a value. It then gives the value to the function that was passed in as the second argument to bind, unwraps the resulting IO value, and passes in the new state. In JS (assuming that we ignore the wrapper, and pretending that js has syntactic support for tuples), it would be function bindIO(m, k) { return function(s) { var new_s, a = m(s); return k(a)(new_s) } } If you remove all of the realworld states (that haskell needs because of laziness), it looks like a great deal like my example and the purescript version. So as it turns out, an IO value is actually an impure haskell function. It's just implemented such that the type system and "realworld state" value ensures that those side effects happen in the right order. Technically speaking, your implementation would also be correct, in that it would produce the correct result. However, it would be very inefficient, and that's a problem in practice. Building IO up out of function composition is a significant optimization.
The code I gave was for illustrative purposes. I don't mean to suggest that this is the way you should write a runtime. Actual runtimes are much more hairy and complex. But *conceptually*, you can think of Haskell as 100% pure. From the perspective of a user of the language, an `IO` action is a value like any other, and you just feed it to some magic external function that can read and write to the real world.
Fair enough. You can if you want to. I just think that the `()-&gt; A` or `RealWorld -&gt; (RealWorld, A)` views of IO are simpler on top of being more accurate to the actual implementation. Frankly, I think that the fact that IO black magic boils down to function composition is pretty damn cool. And if OP was wondering why people call `getLine` impure, well, this is why.
Had breakfast with you at LambdaConf last year, had a blast learning from you!
Erm, not sure if I agree that operational semantics is directly connected with runtime representation. Instead, I'd say operational semantics describes operations on some abstract machine, usually using small step or big step semantics. For example, you could represent 32-bit ints using 64 bits (say you want everything word aligned on a 64-bit arch). Or you could use 32 bits and not have everything word-aligned. So the runtime representation has changed but the operational semantics hasn't because the arithmetic of 32-bit integers is the same in either case.
Suppose I am Magritte and I draw you a picture of a pipe. You look at the pipe and think, "Aha, now there is a fine pipe." But I say, "Ceci n'est pas une pipe (this is not a pipe)", it is only a picture of a pipe. The picture is the syntax. The pipe it represents is the semantics.
Awesome!!!
Can confirm this works!
On the first point, I agree. But, I would also say that while SECD or STG are fine abstract machines, so is JVM or CLR bytecode, LLVM assembly/bitcode, or even the x64 ISA with or with the Linux syscall interface. Different levels of abstraction and feature sets, but still valid abstract machines to talk about operational semantics in. (A non-abstract machine would be a particular chip or board or other physical manifestation.) On the second point, I would say that your operational semantics should change, at least a bit. For example, adding a truncation to 32 bits after the addition, and the re-extending to 64bits OR truncating both operands before the addition. Otherwise, your operational semantics may not correspond to your (denotational) semantics well, which would at least make them more difficult to formally verify. But, your point is certainly well-taken that the example operational sematics I gave were in no sense unique, even for the (denotational) sematics I also gave. (Also, the semantics I gave are certainly not unique for the syntax. You could use '+' in your language to mean multiplication or non-determinism or something more exotic. Haskell uses `f x` to mean application, catenative languages use `f x` to mean composition.)
* https://en.wikipedia.org/wiki/Map%E2%80%93territory_relation * https://www.radicalphilosophyarchive.com/article/the-map-is-the-territory * https://wiki.lesswrong.com/wiki/The_map_is_not_the_territory (Also, see the works of Douglas Hofstadter.) With implementation-defined languages, the syntax means exactly what the syntax does in the implementation. With specified languages, the syntax is explicitly given semantics, so you can discuss the ideas with a represenation (the syntax) with out worrying that the syntax (representation) you write for today's idea will be a different idea tomorrow (or with the next release of the implementation).
**Map–territory relation** The map–territory relation describes the relationship between an object and a representation of that object, as in the relation between a geographical territory and a map of it. Polish-American scientist and philosopher Alfred Korzybski remarked that "the map is not the territory" and that "the word is not the thing", encapsulating his view that an abstraction derived from something, or a reaction to it, is not the thing itself. Korzybski held that many people do confuse maps with territories, that is, confuse models of reality with reality itself. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/haskell/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
3/6 = 1/2 Yet 3 is not 1 and 6 is not 2. Both sides are represent by syntax trees. They are obviously not the same. But they denote the same value.
you're my hero
Syntax is the rules of how the language allows you to combine constructs, semantics is the meaning a certain combination conveys.
You may want to read the comments below for a bit more detail on your slightly inaccurate comment!
Never installed Haskell platform myself - I jus use ghcup nowadays. What’s the point of Haskell Platform?
I use it on Windows.
Windows - is that proprietary software!?
A question: I think the motivation example for the subsection on joining trees is wrong; the types provided are len :: Tree Int f :: Int -&gt; Tree [a] hence `fmap f len :: Tree (Tree \[a\])` and not `Tree (Tree Int)`. Moreoever, I don't quite get how could `f` be inhabited by some useful function (it has to produce trees of lists of `a` out of nothing --- parametricity and all that)?
Awesome work! I can't try it out at the moment though, I'm getting a bad gateway error unfortunately. &gt; To find secrets, I employed the following preliminary algorithm: &gt; &gt; - Find all branches &gt; - For each branch, do the following &gt; - Follow each commit's parents back to the root &gt; - From the initial commit forward, go through each commit &gt; - For each commit, go through its tree recursively to find blobs and save that it has been analysed by its hash While this is a neat graph traversal, it seems inexhaustive (not all commits are necessarily on a branch) and error-prone (due to the need to go forward/backward and go through the file tree). Would it not be faster and simpler to just iterate through _all_ git objects in the repo, and once you have hits, figure out what commits they appear in, and what the filepath of the objects is in the tree?
&gt;vast majority of Haskell functions are named 'a', take 'b' and return 'c'. Like no shit, take for example the type 'Q'. Using a and b as variable names is quite useful, since they are as general as they need to be. Which names to you use for types in templates? &gt;Secondly, the amount of abstraction in average Haskell program is terrific. True, but not necessarily bad. It keeps things useful. &gt;it's counter-intuitive and always gets in my way. Combined with the previous problem it makes reading Haskell code infeasible. In which way does get into your way? It's a bit difficult to get into, but then it looks extremely clean, since in my eyes it just makes sense. &gt;My third problem are the compiler errors. true and understandable &gt;The last problem is that Haskell doesn't seem to have a purpose. Literally any purpose. It is great for web, for system applications and even GUIs. &gt;It doesn't include decrypting what variable 'a' is Prolog variable names are normally similar to haskell's. Also, have you tried Agda?
Sounds very related to what https://www.categoricaldata.net/aql.html and https://statebox.org are doing.
&gt; Which names to you use for types in templates It depends. While it's true that usually it's 'T' and 'U', I look for other names when the role isn't all that obvious (for example ComparisonFunType) and generic. Totally randomly, let's take a look at C++'s map. Template takes four arguments, three of those have sensible names. &gt; It keeps things useful. Let's agree to disagree. &gt; It's a bit difficult to get into This is exactly the problem. C++ has a way smoother learning curve, which is still considered totally steep. &gt; great for web, for system applications Both need predictable response time. Which Haskell does not offer. &gt; have you tried Agda? Just because there are things that are way worse it doesn't mean that something is good.
Ah, well spotted. Yes, you are correct, that's a typo, fixed it. As for parametricity, I didn't intend to suggest \`f\` was polymorphic; changed the wording ("for some `a`") to make that clearer. Thanks!
I think the standard library is the best of any language I've used. I just did a quick check on Hoogle for the `Q` type, but in the standard library, `Q` is only a constructor for the `Queue` type, used in an internal library that you shouldn't be using anyway. Also, what functions are named "take b" or "return c"? I have no idea what you are talking about there.
&gt;have you tried Agda? Nah, it is quite nice. A theorem prover with a theory similar to Coq, but with haskell syntax. Also if Haskell isn't good for Web, why is it at least semicommonly used for backends?
&gt;\&gt; It keeps things useful. &gt; &gt;Let's agree to disagree. Sorry, but what kind of argument is that? Abstraction is what makes us able to write code more easily, otherwise we would still code in machine code. The more abstract the code is, the less place for bugs to hide in it, the less effort it takes to express intentions, and also it is easier to understand. And with a smart enough compiler, the performance hit is outweighed by the advantages. EDIT: I think what you refer to under "abstraction" might not be abstraction, but a different style of writing (e.g. "pointfree" style, heavy uses of operators, etc.). Abstraction - in and of itself - doesn't make a code more cryptic, neither is a cryptic code necessarily abstract. Take Perl, for example - not a very abstract language, but even the original author doesn't understand his own program from more than 3 months ago - exactly because of the many styles that are allowed. Haskell is not that bad, but it definitely has a similar problem on some level. &gt;\&gt; great for web, for system applications &gt; &gt;Both need predictable response time. Which Haskell does not offer. [CTRL-F "server" in this page](https://wiki.haskell.org/Haskell_in_industry)
Q is a TemplateHaskell thing which refers to something which can be converted to some Quasi-instanced type. I'm not sure how our intrepid OP came upon it as a new learner with Haskell, but it's not fantastically documented and that is definitely its own problem. The OP is also talking about the type of the functions (eg `take :: Int -&gt; [a] -&gt; [a]`). The fact that the `forall a.` is implicit doesn't really help but it's a fairly obvious intuition once you know it exists.
One question: did you provide types for all global definitions &amp; functions, when you used Haskell &amp; ML? My own Haskell experience involved excessive reliance on type inference, which quickly turns almost every error into a problem of type inconsistency, making it very hard to localize. Your statement "it's often very hard to pinpoint where the problem exactly is. ... it's hard for the compiler to guess what did the programmer actually mean." brought this to mind. I believe that some languages, like Scala, require this, and that it is considered good practice and Haskell and ML. But, it is *so* tempting to just try to write your code without thinking about types, and let the language figure it out for you. If you share my weakness for this temptation, it maybe your usage, not the language, that is the problem. I also use C++ more than Haskell; if you want to compare their errors, think about what kind of error messages you might get if you declared every variable, function, class member, etc. with "auto". So, if you resisted the temptation of excessive reliance on type inference, my congratulations. But, if you can't stand to think about the most general possible type when you create a function, and don't like the error messages that produces, then you might want to draft your code with overly specific types and then go back and fix them ... we used to do this in C++, when templates first came out, and neither the compiler error messages nor the debugger could clearly present problems in templated code.
Okay, I was wrong with types of functions, because due to classes it more or less works, I admit. And yes, I did mean 'Q' from TemplateHaskell. Just because it's an obscure feature it doesn't mean it's allowed to have horrible names - quite the contrary, the less popular features should have very descriptive names.
&gt; Sorry, but what kind of argument is that? This is what Haskell code looks like to me: https://en.wikipedia.org/wiki/APL_(programming_language)#Examples And yes, people who used APL also claimed it's readable after you get used to it.
Could you please post here a Haskell code example that you find hard to understand?
That is an option, but it makes writing in Haskell very tedious. Usually I write explicit types when functions seems complex and when I know that I might make a mistake. And I still think it's the language, because it's like 'You see that type inference? You want it? You want it, huh? Go fuck yourself.'. And C++'s 'auto' rarely causes too many problems, because usually the right-hand side is very well defined.
I think the reason they've given `Q` a "nasty" name is because you're not really meant to interact with it directly. It *should* all be done for you behind the scenes. Of course that's still no reason for bad coding conventions, but theoreticians will be theoreticians.
After certain time I always finally understand what's going on, but it's about time needed to process that. It makes no sense for me to look for a particularly magical piece of code, because it would turn into 'look what I found' contest, but the problem is that usually one line doesn't do one thing, it does a lot of things.
If your functions "seem complex" then there's a good chance each is doing more than it needs to do. A good selection of named, composable functions will do wonders for your code readability. In the best case it'll look practically like pseudocode. Particular helpers for this style of programming include: * Let-bindings, used sparingly * Infix functions that act like operators (eg. `'e' 'elem' "hello"`) * Do-notation in the rare instance where you need longer functions If you are very confident in the type of a top-level function, you can omit the type signature. But it's often helpful to provide it as a contract with yourself that the function produces what you'd expect. It also means that type errors will be constrained to that function rather than propagating to "use sites". Haskell's type inference is very good, by and large. The problem is when your brain and your code disagree about types - the errors given are not very helpful for actually *finding* code errors, a lot of the time.
About the monad thing. I have not used them for, say, the first two years of trying to program in Haskell. This was fine, because you rarely need them. When I was more accustomed to Haskell code, I started to realise patterns that could've been much more easily be written with monads. And then I did. I have met people who also complain against C++ templates, for being to complicated, unreadable, or whatever. But you have to agree that abstractions are there to make things easier, not harder. I am a bit surprised to see that you find Coq easier. For me it's almost the same language, if you look at how it is written. To give an example, I opened a random file of the CompCert C compiler, written in Coq, and it looks like this: [https://github.com/AbsInt/CompCert/blob/master/cfrontend/SimplExprspec.v](https://github.com/AbsInt/CompCert/blob/master/cfrontend/SimplExprspec.v) ... You still have to decipher what variable 'a' means... But figuring that out is not hard compared to the whole structure of a C compiler (which would be difficult in any language, I guess).
[You said yesterday](https://www.reddit.com/r/AskReddit/comments/bnp83z/the_world_now_runs_on_porn_logic_whats_the_first/en8yrkm/) &gt; I am gay and one of my teachers is freaking hot. &gt; &gt; Too bad he's married :/ &gt; &gt; On porn logic I would definitely ask whether there are other ways to pass the course. Not having to write and exam AND having an opportunity to play with his dick? Hell yeah! I can only assume you tried asking him about `unsafePerformIO` (or if you really want to go deep, [accursedUnutterablePerformIO](https://hackage.haskell.org/package/bytestring-0.10.8.1/docs/src/Data-ByteString-Internal.html#accursedUnutterablePerformIO)). It's a shame Haskell professors are so obsessed with purity.
I wanted to verify that it isn't the abstraction but a particular style of writing that's the main culprit here. But if you don't want to actually find out which one is the case, I cannot help. &gt;the problem is that usually one line doesn't do one thing, it does a lot of things. What's the problem with this line, which displays the title of all news that are less than a day old, and are from a trusted source? (Not sure if it is actually correct, just typed it here directly.) newsFeed = map title . filter ((&lt; 1) . postAge) . filter (\`notElem\` sourceBlackList . source) This is an example of a line that does many things, yet it should not be hard to understand (let me know if you have troubles with it, I'll go through it with you). Again, without concrete example, it is hard for me to help you understand the language, or to gauge if it's the coding style you have problems with, or abstraction, or something else.
How hard would it be to write something like GHC but with GRIN as a backend? Say I forked GHC today: how much do I have to throw away?
Hahahaahhhhaahhahaha. I am on my way to Debug.Trace.trace him and then Control.DeepSeq.force him to something that hasn't been evaluated yet.
For a starter, the order of function calls takes a while to parse - you have normal calls, you have function composition, you have custom-named infix operators and, although not here, you have the $ operator. It's just too much to read it quickly.
I'm more and more sure it's not abstraction that you have a problem with.
Quoting GHC, `compiler/simplCore/SimplUtils.hs`: &gt; the binding will be dead and discarded by the next use of OccurAnal D:
Oh. My. God.
It is work in progress: https://github.com/grin-tech/ghc-grin The compiler pipeline is: *GHC -&gt; STG -&gt; link whole program STG/Lambda -&gt; GRIN -&gt; LLVM*. GHC has ~400 primitive operations and all of them must be reimplemented with the same semantics. Also GHC runtime is built specifically for STG, this means it can not be reused for GRIN/LLVM because GRIN has specialised data layout and calling conventions. These are the hardest parts. The good new is that as a side effect, all GHC primop semantic will be documented and will be reimplemented in a simple interpreter and also in a code generator. The interpreter will be helpful for research purposes to observe the runtime behavior of real world haskell programs. (i.e. better profilers and debuggers, analysis tools, alternative graph reduction strategy experiments)
OK, got it!
You have been warned.
&gt; Awesome work! I can't try it out at the moment though, I'm getting a bad gateway error unfortunately. That should be fixed now. There are still some issues to work out. &gt; While this is a neat graph traversal, it seems inexhaustive That's a good point, I will keep it in mind. One of the things that makes this complicated is that you need to report the first commit where a blob occurs and none of the ones after that (but they'll still refer to the same blob).
&gt; The good news is that as a side product, all GHC primop semantic will be documented and will be reimplemented in a simple interpreter and also in a code generator. Related work (and partly thanks to /u/csabahruska's help): https://github.com/chrisdone/prana The GRIN work is primarily speed, mine is primarily about functionality and performance is a backseat consideration. My interpreter is written in GHC Haskell and will *re-use* primops from the host language (so to implement `+#` is literally eval x, eval y, call `x +# y`). Whereas from what I understand, the GRIN interpreter will actually re-implement those primops themselves from scratch. &gt; GHC has ~400 primitive operations and all of them must be reimplemented with the same semantics. My input on primops that I've ascertained so far: * I think the primops can be broken down into: * Atomic primops (Int#, Word#, Char#) (these can be automatically derived with TH or whatever in my case). In Csaba's case I think these will be easy to generate. * State transformation primops (writeByteArray#, etc.) that are I/O (these can also for the most part be derived with TH in my case), also probably easy to generate for Csaba too. * Complex operations (fork#, raise#, yield#, catch#) that probably require manual implementation for me because I want to do something interesting with them (e.g. fuzzing and strace-like UXes.), and likely Csaba too. * GHCi re-uses all GHC's host primops, but that's because it re-uses the same memory layout as regular GHC's runtime. You basically just have to implement FFI calls and evaluation, and can skip primops in GHCi's case, but at the cost of not being able to do more fun things with the memory layout. And it's written in C, making it less approachable to hack on. For example, memory and calls in my interpreter are all regular Haskell data structures, so I can re-define code while the program is running, like in Emacs, and if types/functions changed, it won't segfault, it'll just say "Type error when applying function ..." or whatnot, as in Emacs. &gt; The interpreter will be helpful for research purposes to observe the runtime behavior of real world haskell programs. (i.e. better profilers and debuggers, analysis tools, alternative graph reduction strategy experiments) I have similar goals for my project (in the [milestones](https://github.com/chrisdone/prana#milestones) section). I think in both cases, mine and yours, re-using the GHC frontend is a huge win and Haskell deserves more experimentation on the actual execution side. I think we can probably also share any knowledge gathered and amp each other up on the work. ;-) BTW, in the end I avoided patching GHC and instead just copy/paste the `Main.hs` from GHC and add my extra step in the pipeline for prana. This way I don't need the GHC source, and I can compile `ghc-prim`, `integer-gmp` and `base` using this compiler. Would that approach work for you?
Nice work!
$ is just function application with different bracketing. `head $ tail [1,2,3] == head (tail [1,2,3])` I usually think of it like `|` in shell scripts.
The patch is small: https://github.com/grin-tech/ghc-grin/blob/master/ghc-8.6.2.patch I prefer patching because I'll get tooling support for free (*stack and cabal*). I can compile large haskell projects with GHC/GRIN out of the box with stack.
I started to like FLTK (fltkhs) retro-look :)
I really like [Real World Haskell](http://book.realworldhaskell.org/), its a bit faster paced than Learn You a Haskell and has really good running examples. The HTML book is free too!
RWH made me understand transformers / mtl. That said, the book is a bit dated. Still good, but you might have to work a bit to get the examples compiling the the latest GHC versions.
&gt; On the second point, I would say that your operational semantics should change, at least a bit. For example, adding a truncation to 32 bits after the addition, and then re-extending to 64bits OR truncating both operands before the addition. Otherwise, your operational semantics may not correspond to your (denotational) semantics well, which would at least make them more difficult to formally verify I agree that if you're doing end-to-end verification then yes, the operational semantics would have to change. But in the typical case that I've seen, the operational semantics is only given in terms of an abstract machine (which in this case would have a 32-bit int data type) and doesn't describe the abstract machine -&gt; assembly mapping (which would change depending on representation).
Backend referenced: [https://github.com/grin-tech/grin](https://github.com/grin-tech/grin)
I like that copying over the stgbin is automatically in the same place as `.hi` files etc. My patch was also small, but the main reason I'm avoiding patching GHC at the moment is the development cycle (of rebuilding GHC) is a bit slower than rebuilding one `Main.hs`. But it looks like I could do what you're doing once my development has settled down, so that rather than using environment variables to say where library files are written, it'll go in standard GHC locations. I'll make a TODO item for that.
Thanks, I'll check it out!
AFAIK no, however, perhaps using boolean predicates and guard might be useful when something like this appears often enough
You could factor the common case into a function with a short name. Or replace the multiple definitions with one that uses case expression and a where clause to define the common case. This would eliminate the syntactic overhead almost completely.
Sorry, no, this still smells fishy. Answer the question: how much of the job is Haskell? This is relatively easy to quantify - X% of the codebase is in Haskell now, and Y% of new development is in Haskell. If you've got 5% of code in Haskell with 0% of new code being Haskell, then this shouldn't be here. If it's 50% Haskell with signfiicant Haskell dev, then it's fine to be here.
First of all APL/J/K are readable when you get used to them. Just like Haskell is. And that it usually takes you more time to understand 10 lines of Haskell, or, more extreme, 10 lines of APL vs 10 lines of c/c++/c#/java is because those latter 10 lines generally do far less than those former 10 lines. I personally like less lines (easier to mull over without scrolling/searching) and because of practice can read them fast.
I get your struggle but it sounds like you need more time with the language. I write Go on the job but find Haskell far easier to read.
It is possible to use \`clay\` on the front end with \`miso\` and do all your styling inline. There is a \`styleRaw\_\` attribute iirc that accomplishes this. Miso's virtual dom library is roughly analogous to Lucid (has a ToHtml instance as well).
Why can't I use the symbol `⟬` to define a value? For example `let a ⟬ b = 1` gives me a lexical error. Other bracket-like mathematical symbols also give me a lexical error. From [the Haskell Report](https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-160002.2), I thought all non-ascii Unicode symbols were legal.
I think it looks better now (less parenthesis and fun. applications), thank you :).
I work in payments/banking &amp; insurance and have the other relevant experience, so here as well. RemindMe! 142 days "Check mercury.co positions for international hiring"
With `ViewPatterns`: skip = \case T.VtyEvent (V.EvResize _ _) -&gt; () T.VtyEvent V.EvGainedFocus -&gt; () T.AppEvent RefreshThumbnail -&gt; () appEvent ... appEvent (skip -&gt; _) = drawThumbnailAndContinue st appEvent ...
Full type inference is one of those things that seems appealing, but can cause a lot of confusion when you're learning. If, for some reason, you decide to take a third try at Haskell, consider making yourself provide the same level of information in Haskell that you would (have to) provide in C++. Hopefully, you don't consider that tedious?
That looks great. I tried this: skipEvent = \case T.VtyEvent (V.EvResize _ _) -&gt; () T.VtyEvent V.EvGainedFocus -&gt; () T.AppEvent RefreshThumbnail -&gt; () appEvent :: St -&gt; T.BrickEvent WName CEvent -&gt; T.EventM WName (T.Next St) appEvent st (skipEvent -&gt; _) = drawThumbnail st &gt;&gt; M.continue st appEvent st (T.VtyEvent ev) = do st' &lt;- T.handleEventLensed st videoList L.handleListEvent ev when (getSelectedVideoIndex st /= getSelectedVideoIndex st') $ drawThumbnail st' processControls st' ev appEvent st _ = M.continue st But everything matches the first pattern with `drawThumbnail`. Any idea what I am doing wrong?
You seem to be trying to use a fancy parenthesis as an operator. Try with a different character: &amp;#x200B; (•) :: Int -&gt; Int -&gt; Int a • b = 1
To be completely honest, I think it causes confusion even when you're *not* learning. I'm taking a class in OCaml for the first time next semester and I suspect reading the code, the way I think about types, will be very difficult (because OCaml programmers do take advantage of OCaml's full type inference). In Haskell I always put types on top-level constructs and occasionally even on local bindings, because they make my code easier to read when I come back to maintain something in a week or more. People often say that types are Haskell's UML - implicit UMLs are useless. I prefer to think of the type inferencer as just a tool that the type checker uses to verify the *intermediate* values. Every major value of the program, that is function arguments are returns, are things that I should know the type of. And it doesn't hurt that intero + hoogle can just dump the inferred type of a function onto the page for me and I can just check if it's wrong myself.
Try matching to True with a default case False in skip. Maybe it just confuses everything with (). I'm not quite sure how partial view patterns work.
You're not doing any matching (`_`), so the first pattern always succeeds. If you did match on `()` you would get a runtime error for other cases because `skipEvent` is a partial function.
&gt;First of all, the standard library sucks. I don't think this is the case. It's large, functions are in general well-named, and it's well-documented with Haddock. Not only that but the functions are fully general, and even simple functions in the standard library can be used with your own complicated data types, completely unchanged. I don't think any imperative language's standard library can provide you with that. C++ templates or Java generics are the same idea, but not *every single function* in C++ and Java has been generalized with them. &gt; Other languages use simple to understand concepts that express straightforward ideas. Haskell does not. I don't agree with this. Just yesterday while introducing a (mathematician) friend to Haskell, we were discussing how you might represent lambda calculus terms. In about a minute, he came up with this: type Name = String data Term = Var Name | Lambda Name Term | Application Term Term which is not only clear and concise with what is being represented, but is actually *identical* to what an experienced Haskell programmer (namely Steven Diehl) did to represent the same data. I suspect if you ask three Java programmers how to represent this, you'll get three different answers, involving enums, inheritance, or a tagged union. A C++ programmer would probably jump straight to the tagged union, which I would argue is not simple to understand or straightforward, because you have to look at how it's used to understand the data it stores. In Haskell we can see immediately what is being stored from the data declaration alone. It's also only 4 lines, which I think qualifies as "straightforward." There's no noise. &amp;#x200B; &gt; Also the monad system hell. Although a smart way to introduce side-effects while maintaining the program purely-functional, it's counter-intuitive and always gets in my way. Do you have any examples of how it gets in your way? You never *need* monads, with the sole exception of to do IO. The idea the monads let you introduce impure side-effects into pure code is a misunderstanding. I can create a stateful computation without ever using the `State` monad, because the way the state monad works is pure and I can just use the underlying pure functions instead. I can therefore create a stateful computation without ever making a monad instance (or using one) or touching `do` blocks. But would I want to do that? Probably not, because the `State` monad exists to make this *easier* for me, not harder. This is arguably a topic for a whole post of it's own, but even the IO monad doesn't introduce impure side effects into pure code. It introduces a way of modeling an IO action, and all functions with IO in the type are just functions on these IO actions. The actual side effects can only result from *executing* IO actions, and unless you really, really know what you're doing, you can't/shouldn't do that. That's the runtime's job. &amp;#x200B; &gt; It's very subjective, but I'll take g++'s whole books of template failures caused by one 'const' too much over ghc's error reporting, simply because it's often very hard to pinpoint where the problem exactly is. Equally subjectively, I'd take Haskell's errors over g++'s, because Haskell tries to give me as much information about the error as it can and I know how to read them. On the other hand, I don't use C++ anywhere near as much as Haskell and I'm not as familiar with reading g++'s error messages. Part of it is practice and part of it is knowing what to look for. Also, do you put type signatures into your code? Taking advantage of Haskell's type inference is an appealing idea, but as I explained in a reply to another comment here, it results in less readable/understandable code. I prefer to think of the type inferencer as a tool that the type checker uses to verify the types of intermediate values, and write the types into the code myself, at least for top-level definitions. This not only helps the compiler find mismatches (because it will find them where *your* types mismatch, which will be close to the problem, as opposed to where the *inferred* types mismatch, which may be far less local) but also makes the errors easier to read because it will use the types you specify, rather than the fully-general principal type, which we usually aren't thinking about when we write code. &gt; This is probably caused by the fact that due to high amount of language features and focus on short notation, it's hard for the compiler to guess what did the programmer actually mean. Humans are bad at remembering lots of language features (until we get used to them) and are bad at reading short, concise notation quickly (until you get used to it), because there's a lot to unpack. Computers do not have this problem. In fact many of Haskell's language features are implemented in terms of other features, and the short notations pose no challenge for a computer which will read `a` just as well as `MyToasterFactoryProducer`. &amp;#x200B; &gt; Haskell doesn't seem to have a purpose. On one hand its robust environment suggests it was meant to be general-purpose, but I fail to find even one. You mean you fail to find a purpose for Haskell? Pick a purpose for C++. It's a purpose for Haskell too. Haskell is particularly good at writing things like interpreters and compilers, but that doesn't mean it's subpar at other things. At my university we'll soon be using bits of Haskell code in our infrastructure as micro-processes for some RabbitMQs that handle coordinating the grading of submissions to coding problems. Before looking at using Haskell for this, we were looking at using Ruby and Kotlin. Kotlin in particular is a language that is designed around being concise and readable, and yet our Haskell code to do the same things looks better and is more expressive. &amp;#x200B; &gt; performance difficult to rate Yes. This is, in my experience, the biggest problem with moving to higher level languages. Problems may become easier to solve, but it takes a long, long time to build an understanding of how those solutions perform. In imperative/OO languages, I completely agree, understanding the performance of a piece of code is much easier. That said I think this may be in part because we spend our whole lives thinking imperatively. I have to go grocery shopping, then get a haircut, then cook dinner. Each of those things is easier for my brain to judge the time they will take than saying "I need to do all my monday stuff." But understanding why this problem exists doesn't solve it, and on this point I agree with you. &amp;#x200B; &gt; And I haven't even mentioned the language extensions yet. I disagree with this for the same reason as the comment about monads. You don't have to use them, but they make your code cleaner. Just like learning any language, there are some things that you need to be aware of to be a proficient programmer, and at least knowing where to find out what a particular language extension does is one of those things for Haskell. As just one example: data NamedFunction a b = Func String (a -&gt; b) exampleFunction :: NamedFunction Int Bool exampleFunction = Func "isZero" $ \int -&gt; case int of 0 -&gt; True _ -&gt; False
I do not claim to be a Haskell warlock, I'm self-taught for about a year now; while I don't feel Haskell will replace my beloved C, C++, and assembly coding (I mostly do games on old consoles, don't judge), I do feel Haskell gave me a lot in terms of looking at problems from a different perspective; which is what you said in your second-to-last point, I do feel solving problems differently from a Haskell perspective helped me a lot to grow as a programmer. I actually found myself annoyed more than once by now when working with vectors/array in C++ that I couldn't just use `foldr/foldl` to solve a specific problem. Doing a "stupid ranged for-loop" over an array feels like a waste of code and convoluted to me :P So, I'd really try to stress that point about functional programming: grow in your own trade by learning the trade of others to gain insight. I'll probably never write a game in Haskell, but learning Haskell gave me a lot of insight into how different types work (which is where the *actual* magic happens in Haskell, I'd like to think).
 isRedrawEvent (T.VtyEvent (V.EvResize _)) = True isRedrawEvent (T.VtyEvent V.EvGainedFocus) = True isRedrawEvent RefreshThumbnail = True isRedrawEvent _ = False appEvent st (isRedrawEvent -&gt; True) = drawThumbnail st &gt;&gt; M.continue st appEvent st (T.VtyEvent ev) = do ... appEvent st _ = ... Alternatively, you could fold more logic into the view function, to the point that view pattern is unnecessary, and `appEvent` becomes a composition of two functions: one that *summarizes* the event into a *command* (`eventToCmd`), and one that *interprets* the command (`runCmd`): data Command = Redraw | Handle VtyEvent {- whatever it's called -} | Continue eventToCmd :: T.BrickEvent _ _ -&gt; Command eventToCmd (T.VtyEvent (V.EvResize _ _)) = Redraw eventToCmd (T.VtyEvent V.EvGainedFocus) = Redraw eventToCmd (T.AppEvent RefreshThumbnail) = Redraw eventToCmd (T.VtyEvent ev) = Handle ev eventToCmd _ = Continue runCmd :: St -&gt; Command -&gt; _ runCmd st Redraw = ... runCmd st (Handle ev) = ... runCmd st Continue = M.continue st appEvent :: St -&gt; T.BrickEvent _ _ -&gt; _ appEvent st ev = runCmd st (eventToCmd ev)
Well ghcup didn't used to exist. And getting a working ghc and cabal install binary as well as certain libraries with foreign bindings all working just from a raw ghc binary distro used to be much harder than it is -- especially on Windows and OS X. The platform served to tie all that together. These days the platform already directs people to use ghcup on linux and os x, because the situation has much improved in those regards. Hopefully in the nearish future the chocolatey install path for windows (which is already really nice) will be sufficiently polished that it replace specialized installers there too.
Syntax is something like "syntax trees" typically -- it consists of a description of a \_grammar\_ for a representation of a program. Semantics is some other domain you map the syntax into, typically \_smaller\_ than the syntax. I.e. 1 + 1 and 2 have different syntax but the same semantics. Common choices for semantics to "land" are objects in certain nice categories (categorical semantics), or directed complete partial orders (the heart of classical denotational semantics), or sequences of abstract machine instructions up to an equivalence relation (operational semantics).
That wasn't an answer to the question that was asked. OP has tried other symbols; Why won't brackets work?
Yeah, its made my Microsoft. Comes pre-installed on a lot of systems. I'm even often offered "bundle pricing" on it when just buying parts. I used to use it at work. IME, it's not worth the money, even if you were allowed to tinker with it.
Agreed. When you're learning, you don't realize you should always declare types at the top level. I think that ML/OCaML declarations may vary by community.
GHC build time is huge. That's why I serialize the STG to files. Then only the STG binary format is the only dependency between my system and GHC. And this format rarely changes.
If we index on objects and not the arrows class Category obj where type (--&gt;) :: Cat obj id :: forall (a :: obj). a --&gt; a (.) :: forall (a :: obj) (b :: obj) (c :: obj). b --&gt; c -&gt; a --&gt; b -&gt; a --&gt; c and now the source (domain) and target (codomain) of `f` is implicit class (Category dom, Category cod) =&gt; Functor (f :: dom -&gt; cod) where fmap :: (a --&gt; a') -&gt; (f a --&gt; f a') (Those two `--&gt;` are different, with [visible kind applications `#12045`](https://gitlab.haskell.org/ghc/ghc/issues/12045) and [type application for infix `#12363`](https://gitlab.haskell.org/ghc/ghc/issues/12363)): a --&gt; @dom a' f a --&gt; @cod f a'
&gt; and he apparently got it from @Iceland_jack. I work based on Edward Kmett's [*hask*](http://hackage.haskell.org/package/hask) ([self-contained code](https://gist.github.com/ekmett/b26363fc0f38777a637d)) but there are other encodings
There are problems with this approach, but I like it
&gt; Related work (and partly thanks to /u/csabahruska's help): https://github.com/chrisdone/prana Which has absolutely nothing to do with GRIN, is it?
Actually, in rust you can abbreviate the above to something like (0..=10).filter(|x| x%2 == 0).sum() But you still need to print the result and such of course
A few days ago I was thinking in a hard optimization problem: A procedure call a function that return a list, but it need to know his length too, so it has to traverse the returned list to count the number of elements. &amp;#x200B; How the calling function can tell the called this: &amp;#x200B; "please, if you traverse the list, mind please to also count the elements and return the result to me too"
Thanks for the suggestion. This is probably as good as it gets in Haskell.
 appEvent :: St -&gt; T.BrickEvent WName CEvent -&gt; T.EventM WName (T.Next St) appEvent st (T.VtyEvent ev) | V.EvResize _ _ &lt;- ev -&gt; redraw | V.EvGainedFocus &lt;- ev -&gt; redraw | RefreshThumbnail &lt;- ev -&gt; redraw | otherwise = do st' &lt;- T.handleEventLensed st videoList L.handleListEvent ev when (getSelectedVideoIndex st /= getSelectedVideoIndex st') $ drawThumbnail st' processControls st' ev where redraw = drawThumbnail st &gt;&gt; M.continue st appEvent st _ = M.continue st
I do a lot of web development, so there's a ton of IO in my programs. A lot of the code I write is taking some network request, doing database actions, rendering a response, and shooting it over the wire. You might think, "Oh, yeah, with so much IO, why bother tracking it in the type?" I've debugged a performance problem on a Ruby on Rails app where some `erb` view file was doing an N+1 query. There's no reason for that! A view is best modeled as a pure function from `ViewTemplateParams -&gt; Html` (for some suitable input type). I've seen Java apps become totally broken because someone swapped two seemingly equivalent lines (something like changing `foo() + bar()` to `bar() + foo()` due to side-effect order. I've seen PHP apps that were brought to their knees because some "should be pure" function ended up making dozens of HTTP requests, and it wasn't obvious *why* until you dug 4-5 levels deep in the call stack. Tracking IO in the type is cool, but what's *really* cool are the guarantees I get from a function that *doesn't have* IO in the type. `User -&gt; Int -&gt; Text` tells me everything the function needs. It can't require anything different. If I provide a `User` and an `Int`, I can know with 100% certainty that I'll get the same result back if I call it multiple times. I can call it and discard the value and know that nothing was affected or changed by doing so. The *lack* of IO in the type means I can rearrange with confidence, refactor with confidence, optimize with confidence, and dramatically cut down the search space of debugging issues. If I know that I've got a problem caused by too many HTTP requests, I can ignore all the pure code in my search for what's wrong. Another neat thing about pure functions is how easy they are to test. An `IO` function is almost guaranteed to be hard to test. A pure function is almost trivially easy to test, refactor, split apart into smaller chunks, and extensively test. --- You say you can't really extract IO. You can. It's a technique, but you can almost always purify a huge amount of your codebase. Most `IO` either "get"s or "set"s some external world value - you can replace any `get` with a function parameter, and you can replace `set`s with a datatype representation of what you need to do and write an IO interpreter for it. You can easily test these intermediate representations.
Ah, fair point I didn't read carefully. Now I'm curious why parenthesis would be expected to be a unicode operator.
Your problem is that you want to read it quickly. Those lines do a _lot_ compared to many other languages, and if it takes you a little while to sort that out, that's because Haskell is a dense language. When code is more compact, that doesn't mean that the underlying logic behind it is any easier to grasp, just that you can represent the entirety of the logic more efficiently, and so more quickly _get to_ that underlying logic.
[GHC's lexer](https://gitlab.haskell.org/ghc/ghc/blob/master/compiler/parser/Lexer.x#L2131) does not classify characters with one of the [general categories](https://en.wikipedia.org/wiki/Template:General_Category_(Unicode\)) "Punctuation, open", "Punctuation, close", "Punctuation, initial quote", or "Punctuation, final quote" as symbols. If you think this is inconsistent with the report, you can [open a ticket](https://gitlab.haskell.org/ghc/ghc/issues); at the very least this should be better documented.
`⟬` is [U+27EC - MATHEMATICAL LEFT WHITE TORTOISE SHELL BRACKET](https://unicodes.smpc.io/⟬), which is a different character than `(`, aka [U+0028 - LEFT PARENTHESIS](https://unicodes.smpc.io/(). The latter is one of the ascii symbol characters expressly disallowed for operators by the Haskell report.
Good idea, I’ll do that. Also, your formatting is messed up - for some reason r/haskell’s comment editor defaults to the Fancy Pants Editor even if you’ve got your profile set to use the Markdown Editor instead. Personally it drives me up the wall.
I read that part of the report too and interpreted "symbol" to be "operator" a la languages and mathematics. I now see it can also be interpreted as "any character" which is the common meaning of the term when discussing character sets.
not people who have worked longer in haskell but divide up your IO. it's meaningless when it's all encompassing for any-and-all effectful work you do, it's wonderful when it captures both the boolean-doing-io-or-not aspect and additionally the sum type what-kind-of-io-are-you-doing aspect. haskell is great for forcing your hand, because opt-in is way way way more likely to fail over an ever growing codebase than opt-out
Thanks for the heads up. The issue was actually the difference between old and new Reddit formatting. With old Reddit formatting, you had to escape any closing parenthesis in a URL. But apparently, this messes up new Reddit because it takes balancing of parentheses into account, meaning you have to escape both parentheses to make it work on both old and new.
what are these problems?
This made me think of traversals as the results of folds ```haskell {-# LANGUAGE LambdaCase #-} module RoseTree where import Data.Function (fix) import Data.Monoid (Endo(..)) -- | Rose trees data Tree a = Node a [Tree a] tree :: Monoid b =&gt; (a -&gt; b -&gt; b) -&gt; Tree a -&gt; b tree f = fix $ \g (Node a as) -&gt; f a (foldMap g as) -- | An infinite binary tree of distinct natural numbers nats :: Tree Int nats = go 0 where go n = Node n [go (2*n+1), go (2*n+2)] -- | Trim a tree beyond a maximum depth trim :: Int -&gt; Tree a -&gt; Tree a trim 0 (Node a _) = Node a [] trim n (Node a as) = Node a $ trim (n-1) &lt;$&gt; as -- | -- Do a breadth-first traversal of a rose tree -- -- &gt;&gt;&gt; take 10 $ bfs nats -- [0,1,2,3,4,5,6,7,8,9] -- -- Hangs when run on finite trees. -- -- &gt;&gt;&gt; import System.Timeout -- &gt;&gt;&gt; timeout 1000 . print . bfs $ trim 3 nats -- [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14Nothing -- bfs :: Tree a -&gt; [a] bfs = \t -&gt; let ~(xs:xss) = tree prepend t `appEndo` xss in xs where prepend :: a -&gt; Endo [[a]] -&gt; Endo [[a]] prepend a (Endo f) = Endo $ \(~(xs:xss)) -&gt; (a:xs) : f xss -- | -- Do a depth-first traversal of a rose tree. Works on finite and infinite -- trees. -- -- &gt;&gt;&gt; take 10 $ dfs nats -- [0,1,3,7,15,31,63,127,255,511] -- &gt;&gt;&gt; dfs $ trim 3 nats -- [0,1,3,7,8,4,9,10,2,5,11,12,6,13,14] -- dfs :: Tree a -&gt; [a] dfs = \t -&gt; tree cons t `appEndo` [] where cons :: a -&gt; Endo [a] -&gt; Endo [a] cons a (Endo f) = Endo $ (a:) . f -- | -- Do a simultaneous bfs and dfs -- -- &gt;&gt;&gt; let ~(xs,ys) = bdfs nats in (take 10 xs, take 10 ys) -- ([0,1,2,3,4,5,6,7,8,9],[0,1,3,7,15,31,63,127,255,511]) -- -- Uses the spine of the dfs to let the bfs handle finite trees. -- -- &gt;&gt;&gt; bdfs $ trim 3 nats -- ([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14],[0,1,3,7,8,4,9,10,2,5,11,12,6,13,14]) -- bdfs :: Tree a -&gt; ([a],[a]) bdfs = \t -&gt; let ~(~(xs:xss),ys) = tree prepend t `appEndo` (xss,[]) in (zipWith (const id) ys xs, ys) where prepend :: a -&gt; Endo ([[a]],[a]) -&gt; Endo ([[a]],[a]) prepend a (Endo f) = Endo $ \(~(~(xs:xss),ys)) -&gt; case f (xss,ys) of ~(xss,ys) -&gt; ((a:xs):xss, a:ys) -- | -- Do a breadth-first traversal of a rose tree -- -- &gt;&gt;&gt; take 10 $ bfs' nats -- [0,1,2,3,4,5,6,7,8,9] -- &gt;&gt;&gt; bfs' $ trim 3 nats -- [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14] -- bfs' :: Tree a -&gt; [a] bfs' = \t -&gt; concat $ tree prepend t `appEndo` [] where prepend :: a -&gt; Endo [[a]] -&gt; Endo [[a]] prepend a (Endo f) = Endo $ \case xs:xss -&gt; (a:xs) : f xss [] -&gt; [a] : f [] ```
See comments in [older version of *hask*](https://github.com/ekmett/hask/blob/master/old/src/Hask/Core.hs#L43-L51), but the question is if we are "object-directed" (object determines `--&gt;`) then `Type` determines `-&gt;` instance Category (Type :: Type) where type (--&gt;) = (-&gt;) id :: a -&gt; a id a = a (.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c) (f . g) a = f (g a) Now we cannot define `Kleisli m` as a category since it has the same kind as `-&gt;` ignoring levity and thus, the same objects instance Monad m ?? =&gt; Category (Type :: Type) where type (--&gt;) = Kleisli m ?? Also how do we talk about `m`? It is nowhere brought into scope.
In a previous life, I did a bunch of Haskell professionally. One of the biggest things we got out of the language was the ability to cut our tests off from outside influences completely. We had a bunch of mock services that behaved just like the real thing, but did so using pure data structures over a StateT. Attempting to perform any kind of untestable IO anywhere in the application would cause the compile to fail. The end result was that we had a ton of tests that looked and felt very much like integration tests, but still ran very swiftly and never intermittently failed. I wrote about the specific technique on [my incredibly inactive blog](http://andyfriesen.com/2015/06/17/testable-io-in-haskell.html).
Frankly it just takes discipline and thinking like this leads to making excuses. I can’t think of anything to say that’s going to make you “see the light.” Side effects have plagued me in my entire career, so I don’t mind exercising discipline in quarantining them. Whenever I hear someone say “practical” or “pragmatic,” that’s code for wanting to take shortcuts or make excuses. Unbounded side effects are impractical. A better question would be, why do we allow them to be _unrestricted_, because that’s the choice that leads to way more actual harm.
Personally, I find the IO restriction to be the thing I want \~\~most\~\~ fairly often. It's the beginning of better abstractions for me, when I can be sure that the callbacks I use/expose are somehow limited. It also makes me more disciplined as has me to the mutation (or other I/O) at the right place instead of deep within the guts of a could-be-pure computation. &amp;#x200B; (The feature I miss most about Haskell is HKT. There's been several problems I looked at in Rust or JS or Python and wanted to solve with a Free Monad or a Lens and while I \*could\* do that in those languages, it would be much more frought with bug potential down the road because I coudn't get the language to outlaw particular composition patterns.)
I'm not sure what this has to do with this post, or if this is quite what you're asking for, but the [foldl](https://hackage.haskell.org/package/foldl-1.4.5/docs/Control-Foldl.html) package makes it easy to combine multiple operations in a single pass over any `Foldable`.
Like others have said here, just knowing the presence of IO gives you a shortcut to finding where most of your bugs are. If you want a type system representation of how to restrict it to particular kinds of IO then you may want to move to Freer monads or mtl style classes. But seriously, I used to have the same opinion and realistically once you have command over monad operations the “overhead” of dealing with IO will largely disappear. And all that will remain is a friendly reminder of where all the parts of your code that are most likely to be screwed up live.
&gt;It's a technique, but you can almost always purify a huge amount of your codebase. As someone who is writing a [fairly large GTK program](https://github.com/bradrn/cabasa), do you have any resources/ideas on how to learn to do this?
&gt;Alejandro Serrano Mena I find this book especially valuable for intermediate learners like myself. Thanks for this great piece of work! &amp;#x200B; I have one question. I'm reading Chapter 6 and trying out the first example of K-means presented in pp.186-193. The code `kMeans initializeSimple 2 info 0.001` does not produce the results shown in the book or any results for that matter, even after ten minutes of running on my environment, which is GHC 8.6.3 on MacOS 10.14.5. I tried both the code from the book and the code from GitHub. Any advice would be appreciated.
Lots of people here will interrogate you here, but not me. I'll just say I'm sorry you had a bad first experience with Haskell. It has its warts and everyone here will acknowledge them if you name them calmly. There are many solutions to these problems, and quite frankly not all of them are good ideas. Haskell is an accretion of good and bad ideas, and sometimes your needs don't mesh well with those. It also has this horrible sickness; this idea that with just one more clever insight you can write the whole program as one beautiful point free statement. People throw so much of their energy into this sickness, convinced that somehow they'll emerge on the other side being able to look at a statement full of obscure 4 character combinators and make a Matrix pun. It's a lie, of course. And if you look a the folks who make those wild advances? They make their own language and run with it as sure as any Lisp programmer. They pick a fundamental abstraction (be it contravariance, folds, DerivingVia, Free Monads) and make a language out of it that is new. They go back later and find the puns if they need them. But I've felt acutely that sense you describe that Just One More Library Function Should Make It Better And Goddamnit I Was Sure I Remembered One What Was It Again? &amp;#x200B; You might find OCaml more to your liking. A lot of people who do like FP but don't want to work through so much of Haskell's workflows do end up going that route. And it's a pretty good route, I won't lie. I hope that one day you give Haskell another try. Hopefully with an open mind and without succumbing to that insidious urge to impress yourself.
People don’t like memes it seems &lt;.&lt;
In addition to what everyone has already said. Saying IO serves only for the reader to know where side effects are performed is a gross oversimplification. Wherever you’re using IO, it means your code is still pure and can be reasoned about locally.
I don't think I'll give Haskell another try. I conclude it's just not my thing and I prefer something else. In Python you also have this 'one library call could replace your whole program', but it just doesn't feel so forced upon you. Probably it's because of a more C-friendly syntax. Probably Haskell will be a lesson for me that too many possibilities lead to obscure, difficult code and when writing code in other languages, I should focus on making my code readable at constant speed and limiting the use of fancy features unless they're obviously needed.
for more granular type constraints i recommend this post: https://chrispenner.ca/posts/monadio-considered-harmful
Nothing to do with GRIN, but related in terms of alternative backends at the GHC STG part of the pipeline.
This is a really nice solution, I think simpler than the view patterns. I totally forgot one can pattern match in guards. 😳
[removed]
I don’t understand why you can’t achieve that with dependency injection in other languages
Having IO in the types gives you a lot more confidence that you've _actually_ achieved it. It tracks the "proper hygiene" that's only otherwise enforced though habit and inspection.
&gt; + proper hygiene Because all the code we ever see was written with the highest hygiene standards, right? /s
&gt; My point I guess is that formal verification through a type system is very helpful in a context where I can map out entities in my program in a way so that the type system can actually give me useful feedback. But the difficulty of IO isn't to recognise that I'm doing IO, it's how IO might break my program in unexpected and dynamic ways that I can't hand over to the compiler. But IO doesn't break your program in unexpected and dynamic ways even when you're doing IO, unless you're doing it in an undisciplined way. And having IO computations as first class values means you have a _lot_ more flexibility in designing control structures on the fly to enact precisely the discipline you want for any given task.
I mean, it’s the same amount of work... the difference is that Haskell has a compiler which forces you to do the work. But you can achieve the same thing in other languages by actually having a code review process.
&gt; I don't think I'll give Haskell another try. I conclude it's just not my thing and I prefer something else. Ok, then why did you write this whole tedious boring rant about how intellectually lazy you are and inflict it on this subreddit? Also, bye and good luck!
[removed]
It’s not hard to mod compilers in other languages to warn you about IO in functions which shouldn’t use IO.
Maybe someone can make Haskell more friendly for next students
Ok, have fun modding those compilers. I'll stick to the great compiler I already have for the language I already like.
Nah. Haskell is simple, and the things that made you mad are simple, not complicated. If you don't want to learn them its not because they're too complicated, because they're not. They're just not what you're used to. And if you don't want to learn things that aren't what you're used to, cool -- just don't go around bragging about it.
I think the best way is to just avoid writing any IO until the rest of the application is finished. Anywhere where your application really requires a value from input you can temporarily provide with precreated values for testing purposes and anywhere where you might want to do output you can just write a function to produce the output value without doing anything with it. You should be able to model your entire application this way without using GTK at all. Then the library just leaverages all that pure code in order to render stuff.
&gt; They're just not what you're used to. And if you don't want to learn things that aren't what you're used to, cool -- just don't go around bragging about it. I've already referred to this point - Prolog and Coq are by no means similar to what I already knew.
The N+1 query problem is a big one, where knowing a single line isn’t IO means you don’t run into the problem. For example, if you have users.map(&amp;:preferences).map(&amp;:darkMode) in Rails, will that fire N SQL queries? Well, it depends on if the preferences relation was preloaded. Now go audit all callers of your function to make sure they preloaded the right association tables. The Esqueleto (a haskell SQL library) way to represent this is as a (user, preferences) tuple, created by a join at some earlier point: let darkPrefs = map (\(u, prefs) -&gt; darkMode prefs) tuples Will never fire any SQL queries which is a very useful thing to know, *even if that line is in a function that otherwise does IO.* There are things I find easier to do with the Rails style for sure. It’s pretty convenient for deep associations. But I’ve also lived through the mess of tracking down N+1 queries in the profiler causing pages not to load. And I value being able to avoid that.
I’m not saying Haskell is a bad language — you don’t have to be so combat it is — I’m saying that there’s nothing special about its treatment of IO. Compilers already have support for idioms like “warn_unused_result” and “GUARDED_BY(mutex)” — it’s less than a weeks effort to create and extension which warns if IO functions are called in unannotated functions. The fact that nobody has created these extensions implies that these compiler checks are in general not terribly useful.
I hear this hypothesis a lot and I like to test it by reversing the logic: If you are 'doing it properly', then you shouldn't ever clash with Haskell's tough compiler rules, so there shouldn't be an issue.
Ok, thanks. That's certainly problematic. &amp;#x200B; If you generalise Functor but can't really use it, then I don't think we gain much.
I think that having a code review is, by definition, more expensive than having a compiler tell you you just broke the rules. I say "by definition" because someone's paid time is being used to review it, and then your time is being used to fix those problems they bring up. So you're taking about emulating a compiler just with really high latency, which doesn't seem great to me. Did I miss something?
It's more of a cultural thing than the utility I should think -- quarantining IO isn't part of the mindset for most PL communities. I think it's a really valuable way to go about designing a program and wouldn't want to do without it, whilst agreeing that it isn't the only way of course. Somehow, amazing as it might sound to some of us, the occasional bit of useful software was written in C :)
A beginner may not realise how broad the definition of IO is in Haskell. It's not just just about sending/receiving using a hard disk or network. It's about actions that may not result in the same result every time. Think getTime(), randomInt(), or i++. This is important to me because I want my tested code to run the same every time. If I observe that f(x) = 2 during test, then I know f(x) will be 2 in prod. *But doesn't IO need to go (almost) everywhere?* No. * I can get some IO bytes off the wire, * but then those bytes can be validated purely into a utf8 string * that string can be purely parsed into JSON. * that JSON can then be processed to get at desirable fields, and turned into a domain object purely. * Maybe now you do some more IO: Log something, persist something, fetch from another service etc. * purely calculate the desired action / response, based on what happened above. * Serialise the response purely. * Put the bytes back onto the wire in IO. So in the above steps, while the spine of the control flow is IO, I very much appreciate being able to dangle off a bunch of pure functions of it which handle my business logic.
I had a similar feeling until I read the [History of Haskell](http://haskell.cs.yale.edu/wp-content/uploads/2011/02/history.pdf) paper, they didn’t eliminate side-effects just because, it’s actually necessity for any lazy language, as side-effects rely on order of evaluation which is unspecified &amp; hard to predict when dealing with non-strict semantics. You can toy around with `unsafePerformIO` to unwrap values from the IO monad, but in most cases this will lead to odd bugs where certain IO computations are only performed once due to assumption of referential transparency or not at all due to laziness not evaluating expressions with unused return values.
I doubt this is what (s)he meant, but Snoyman’s [blogpost on the `ReaderT` pattern](https://www.fpcomplete.com/blog/2017/06/readert-design-pattern) has a section on regaining purity using `mtl`-style classes.
I've done that in other languages too, and it works great as long as you maintain discipline. The important advantage of the Haskell approach is that nobody is asked to maintain discipline. Adherence to the rules is fully compulsory. The type system demands it. This forced us to do a bunch of things that were very good in hindsight. For instance, we implemented a MySQL interpreter in pure Haskell (which was easier than we expected!) so that we could perform database actions in testable code. This quality becomes a super huge deal as your application ages and as your team grows.
Well, you still need code review - the compiler won't catch everything.
Despite my deep disagreement, I upvoted you for sincere, if IMO misguided, criticism. You shouldn’t have been downvoted so much. You are quite aggressive and ignorant, but not wilfully ignorant AFAICT, and not malicious. You also seem to be engaging in good faith, IMO.
See [Functional Architecture is Ports and Adapters](https://blog.ploeh.dk/2016/03/18/functional-architecture-is-ports-and-adapters/).
There’s nothing preventing you from achieving this in other languages. This is simply the Ports and Adapters architecture, which definitely came out of the OO sphere. Interestingly though, is that Haskell encourages you to program in this way, vs. having to always remember to be disciplined about it in other languages. https://blog.ploeh.dk/2016/03/18/functional-architecture-is-ports-and-adapters/
Yea but your argument sounded silly
Some domains are definitely more challenging to purify than others, and GUIs are definitely a challenging domain. Perhaps for this reason, that's a domain in which a lot of research has already been done, and so I am aware of three different approaches. 1. "Virtual DOM", in which you write a pure function from your application's state to a pure value describing the current state of your GUI, and the system diffs that desired GUI state with the current GUI state in order to obtain the IO commands which will move the GUI widgets to the desired state. [Here is a recent GTK library](https://owickstrom.github.io/gi-gtk-declarative/) which uses the Virtual DOM approach. 2. "Functional Reactive Programming", in which you combine and manipulate pure values which represent future events and future states. For example, one `Event (Int, Int)` value might represent all the mouse click events which will happen in the entire duration of your program, another `Behavior Bool` value might represent whether a particular dialog will be visible at every timestep of your program, and you can combine those into an `Event ()` value representing all the clicks onto a particular button inside that dialog which will happen for the entire duration of your program. This is later converted into IO actions and callbacks, of course, but the point is that you can program at a higher level, and let the system convert that pure description into an IO program. [Here is a blog post](post](https://apfelmus.nfshost.com/blog/2012/03/29-frp-three-principles-bidirectional-gui.html) about using FRP with GUIs, and [here is an FRP library for GTK](http://hackage.haskell.org/package/reactive-banana-gi-gtk). 3. "Formlets", in which you define your GUI as a giant widget producing a value, which is itself defined in terms of smaller widgets which produce smaller values. This works better for wizards and HTML forms than for interactive applications, and indeed, all the libraries I see on Hackage target HTML.
I am aware of most of these approaches already, but I'm not convinced of their usefulness at all: 1. I can easily see how virtual DOMs would be useful for highly dynamic applications, but for other usecases it seems to me to be less useful. Additionally, I have already looked at the specific library you linked to (`gi-gtk-declarative`), and it seems at first sight to be hard to use for any program larger than a toy: either you have to find a way to shoehorn it into the `gi-gtk-declarative-simple` structure, or you have to figure out how to plumb together the various internal bits yourself. The latter approach seems to be what [Komposition](https://github.com/owickstrom/komposition/) does, so it's definitely possible; however, I would note though that `gi-gtk-declarative` was originally created specifically for Komposition, so that may not be saying much. 2. I have tried FRP already, using `threepenny-gui`. In fact, the GTK application I mentioned was prototyped originally with `threepenny-gui` and FRP. It ended up as an unmaintainable nightmare of about 30 hyper-dense lines of FRP. By contrast, despite the 'un-Haskelly' nature of my current GUI, it 'feels' in some way much more structured and maintainable. Given this experience, I would rather not use FRP again. 3. I haven't heard of this approach before. Unfortunately though, from your description it sound like it can't be used to make desktop GUIs yet as there is a lack of libraries.
I am already aware of this approach. The problem I have is that all the GTK methods are in `IO` already, so it doesn't really help to add 'more pure' monads if you still need to fall back to `IO` regularly.
The problem is then: how exactly do I go about doing this? What you described is definitely the ideal, but how do I put this into practise? The closest I can see is using `gi-gtk-declarative`, but I've [already expressed some reservations with that approach](https://www.reddit.com/r/haskell/comments/bopyhh/the_practical_utility_of_restricting_side_effects/enm4r45/).
unsafePerformIO will become really popular when haskell does. haskell demands very little; it's mostly culture and self- selection
Really! Myself, I've had a positive experience with both [the Virtual DOM approach](https://github.com/gelisam/ludum-dare-35) and [the FRP approach](https://github.com/gelisam/ludum-dare-31). I must admit that both of those projects were small games, not GUI applications, so there is a chance those approaches don't work as well for GUIs. I guess I'll have to find out for myself; I am not discouraged by your experience and I definitely plan to use one of these approaches next time I want to write a GUI :) More specifically, I definitely agree that writing an application using these approaches requires the application to be structured in a completely different way than if you were using callbacks. I happen to like those more declarative structures better, especially FRP's, but I guess that's subjective.
Don't hindent and stylish-haskell do the same thing?
Pretty sure they overlap a bit, but thank you for making me realise that I don't actively use hindent. :) My favourite is still stylish-haskell
I really doubt it. unsafePerformIO is very difficult to use because of the assumptions that GHC makes about pure functions. GHC will reorder, omit, and sometimes coalesce function applications in a way that can totally break your code if it is not as pure as it claims to be. Most people learn this lesson the "easy" way when Debug.Trace.trace starts behaving in surprising ways.
The extension `{-# LANGUAGE PatternGuards #-}` got added to the language proper in Haskell 2010. It's quite handy. I didn't notice `AppEvent` vs `VtyEvent` at a glance. Edited, hopefully that works ok for you.
Sounds similar indeed. We will soon release our Haskell AQL (called CQL) implementation, do you have a description of the DSL?
Wow, thank you gelisam! This is *exactly* what I was looking for. I haven't spent a lot of time with Vinyl and those types are a bit hairy, but I just read through the Vinyl tutorial and it's making sense to me now. CoRec is the concept I was looking for but didn't know how to put a name to :)
Ah, thank you Rampion. My example was actually a bit unfortunate in that I picked simply extracting the names from the fields, but in reality I wanted to perform *any* kind of logic based on them, **and** to have the compiler know the exact case of fields to check. I actually did this for my first solution, and even had something like: givenAFieldFromFoo = case symbolVal (Proxy @field) of "f1" -&gt; doStuffWithF1 "f2" -&gt; doStuffWithF2 _ -&gt; shouldNeverHappen The thing I was trying to see if I could get rid of was that last part of the case statement, since in theory the compiler should know that it's not an option that should ever be crossed. Of course, I still think this is a solid solution, and my typeclass approach was my *attempt* to get compiler enforcement (in the end I don't think it does though), so I'd definitely prefer the `KnownSymbol` approach to the typeclass one
Thank you Syrak, this is cool stuff! I need to meditate on these types here, but I think this is the solution I'm going for. I'm curious though, do we get compiler enforcement if we don't handle all fields?
&gt; these problems What problems? That type variables are called `a` and `b`? &gt; It also has this horrible sickness; this idea that with just one more clever insight you can write the whole program as one beautiful point free statement. People throw so much of their energy into this sickness Actually, most testimonials of people using Haskell in industry that I'm aware of seem to suggest the opposite: write clear, simple, robust code and avoid unnecessary type level magic and clever bullshit. You are not giving an accurate description of the average Haskell developer IMO.
You might be thinking of PatternSynonyms . As it is skip is just a partial function. It might be nice if patterns were conposable in this way though
&gt; theoreticians will be theoreticians what?
It's neither obscure nor unpopular. It's just a quite advanced part of the ecosystem. That part that kind of assumes the user has reached sufficient expertise to not be confused by a type named `Q`.