your post is on it...
I don't want to have to go here to find stuff I used to find on programming.reddit.com!
Man that's cool. I bet they're understating when they say it incurs 'substantial' overhead.
&gt; I’m sure there’s a moral to this story. I’m just not sure what it is yet. Data.Foldable and friends—Control.Applicative, Data.Traversable, Data.Monoid—need more spotlight.
It is an error to call `forM_` when more than one such function is in scope. It must have been the case that he wasn't even importing `Control.Monad`. Although, modules can be re-exported, it could potentially be difficult to know where function a function originates.
I hope reddit allows aggregating subreddits. Then programming subreddit can aggregate this, and python, and scheme, and others. And Haskell can aggregate types.reddit, etc.
That was interesting
Yay, this quarter's weekly haskell news \o/
We don't need the weekly news to be posted...weekly. Reddit is not an RSS aggregator.
Note: read the whole thread, it is very informative.
Your comment's score tells a different story =-P
I was really hoping there would be some cats, and misspellings, but then [OMG](http://www.bolour.com/papers/images/monad-elevation.png). They can't even be made simple in diagrams. I give up.
Did someone say pictures of cats? http://arcanux.org/lambdacats.html
Hmmm, givers and takers. I have an idea for a new monad metaphore.
Yeah, I don't like the diagrams either. I posted it more for the textual explanation though.
seconded.
One thing that's sort of under-emphasized is the occasional unsafe IO operation like hGetContents, which uses unsafeInterleaveIO. Is there a good reason for this?
And they've [sucked for a long time](http://www.reddit.com/comments/l434/ask_reddit_erlang_haskell_ocaml_which_functional/cl4ie). 
Then do something about it? I'm currently learning haskell, so when i get to the stage of knowing enough to complain about things I might consider it a good exercise to improve the documentation.
I hate claims of a new paradigm. It's got to be earth shattering, industry toppling to make such statement. But any word with expansive impact is an easy target for the buzzword machine.
Missing or poor documentation is a big open sore to present to potential users and not easily healed by others. If a developer releases software with the claim that it will be useful, they should be obliged to write basic usage documentation and minimal examples. It just doesn't make sense otherwise. Often, the paltry documentation present is little more than dressing up the source code with HTML. A large part of proper documentation is HOW the software is intended to be used. Sometimes, a user can partially infer this from the source, more often the developer intent is hidden. You end up on IRC, communicating with the original developers or exchanging endless emails, hoping the developers aren't as stingy in direct communication as they were in preparing written documentation. I've seen it too many times where blog posts from a user become the 'official' documentation by default, but the blog leaves out many methods that are important and gives usage directions and examples as if these methods hadn't existed. So, maybe the blogger's simple examples work, but users who attempt more ambitious functionality are stuck broken, wondering where they went wrong. Look at the current Haskell HAppS situation for a great example of this. Also remember, after the original developers move on to other projects, they will begin to forget the design and implementation details carried around in their heads, and ultimately become like other users of their own project! So while the design and intended usage are still fresh in their minds, wouldn't it make sense to preserve this information for themselves and others? Why does someone else have to go back and figure this stuff out? 
I feel like articles like this should somewhere at the top note the language they're using. This is the [haskell] subreddit, but I hadn't noticed that before clicking over, and don't know Haskell, so at first it looked like Python (indents), and then like Lisp (/ etc etc), then like both. Then I said "What language is this?" and read the title bar, the page name, subname, the article section, and heading, skimmed the paragraphs, and finally noticed "haskell" as a tag, and later as the largest word in the tag cloud (though that's irrelevant - I don't see sidebars as part of an article's content, though this time they were). It's just a blog-usability note, especially in these times in which specific articles are aggregated into feeds of varying themes. The first sentence could simply have added this very relevant info for outside visitors ala: "Recently I began writing a tool *in Haskell* to scrape..." While I'm at it, I'd like to voice my annoyance at blogs that give absolutely no indication anywhere of the date of posts. This one does give that info, and prominently, but I've seen countless now where it's not in the titlebar, URL, article heading area, at the bottom, nor anywhere, and it makes things like computer, os, and peripheral reviews of unfamiliar things useless. I can't remember how often I've been trying to find something like cross-reviews of a motherboard, or some FOSS program, or of a kind of printer, and I keep realizing a page into a review that there's no date, and looking things up in Google, I find I'm reading about something from 4 years ago, which can't possibly be accurate anymore. I kind of wish there was a way to sort Google results by the pertinence of the content by date, though I realize that's asking an awful lot.
Erm... there's mention (and link) to TagSoup, a haskell library, and to Parsec, a fairly well known Haskell parser generator, plus the first code sample &gt; type TagParser = GenParser Tag kinda gives it away...
Not being a Haskell user, I didn't know what TagSoup, nor Parsec were. And actually, the TagSoup link suffers the same problem. On that page, not the title, nor page heading, nor the URL, nor the first, and only 2 paragraphs, nor the section links column, nor anything above the bottom of the page mentions that TagSoup is for Haskell. Even in the related links, wherein Haskell does make an appearance, it is second, with the first linking to something in Java. The only indication of what language TagSoup is written in/for is the tags at the very bottom of the page. And that type declaration does not, IMO, give it away. I don't know Haskell (and again - hadn't realized I'd clicked through to a Haskell subreddit link at first). This isn't me saying the page sucks - it seemed a pretty good little article, actually - nor that it needs to make any major changes. It just seems a little presumptuous that everyone showing up will know all about it. The contents of the net are global, and I'd just prefer a few seconds more thought to make pages clearer to people who may have arrived from slightly unusual routes, like me. As with probably many (most?) redditors, I get through tremendous amounts of info per day, and it's like hitting speed bumps when I hit something that seems like something I'd be curious to learn more about, but which doesn't fill in the few necessary details to see if I'm correct about that. Perhaps it also strikes a nerve with me, because as an American, I've noticed my nation's natural tendency to believe it's the only one on the planet, not only criticizing other cultures for their unique views on things (e.g. slightly different phrasings, word choices, and spellings in the UK), but also the presumption that everyone the world over should know, and do things our way (note our anger over the rest of the world's use of the metric system). Countering my innate, American, self-centered tendencies, I've lately taken to trying to make my own online postings answer the general questions immediately, so people can know if they want to read the rest, and to include some things to help the many people from foreign nations who've started 'reading me.' E.g. I'll throw the cm version of measurements in ()s after any foot, or inch measurement, or add a simple note after something local, as in "While picking up batteries at CVS the other day (that's a local convenience/drug store chain)..." Heck, I even put proper width, height, title, and alt info in my img tags to keep my images from popping text out from under the reader's eyes if the images load slowly, and for the blind using screen readers, so they can understand what the general idea of the embedded images are (or something like alt="" for images that aren't important enough to waste their time, as at least things like that hide them from screen readers, so they're not presented with something they can never identify, nor realize isn't important). I've started to notice a lot more lately that programming blogs completely leave out what language they're using anywhere on the page. I've made plenty of posts about languages myself, and always include right away a giveaway line, like "Recently I decided to see about implementing a window tiler in Python for the Gnome desktop environment." Right away, first sentence, anyone stumbling onto my page can yay, or nay the entire rest of it, knowing basically what the rest of the post will be about. That's all I'm asking for. It's good writing. Give the readers some clue as to where you'll be taking them. Note that I started my comment above with "I feel like articles like this should..." It was just a friendly suggestion. I wasn't commanding it be done. I'm American, but I can be civil :)
...huh?
Mirror w/o the word fuck in the url, pls. Libraries and places of work tend to block that.
That just hurts my brain...
I am currently reading SICP and watching the accompanying lectures, and I think I might be interested in learning Haskell because of most functional programming concepts it offers and a few things more (like algebraic data types). As I am currently minoring math (with major in CS) I think I would like to learn Haskell the proper way, really understanding the language and ideas behind it. I am willing to spend substantial effort (a la 10 years) to it. Can you give me few pointers? (No, no, not [pointers](http://xkcd.com/138/), please ;)) 
I'm no programmer, but I was able to get a basic idea of Haskell's syntax after only a few hours. I joined #haskell on irc.freenode.net and the people there were extremely helpful.
I got about halfway through the presentation the article author linked to, and it is pretty different. Basically, roll the web server, application framework, and database into the same layer, to give you better ways of managing state, redundancy, scalability, extensions, etc, etc. Easier than the ol' LAMP stack? That remains to be seen, I think.
10 years? In that case, consider a PhD in computer science, specifically language theory and (mathematically structured) functional programming :) Although, if that's not your thing, you should be able to learn Haskell in a few weeks. For starters let me heavily recommend the upcoming [Real-World Haskell](http://book.realworldhaskell.org/beta/) book. Hanging around in `#haskell` on FreeNode has also taught me more than you can imagine. Also, [Haskell Weekly News](http://www.haskell.org/haskellwiki/HWN) often has links to blogs of people who are starting out in Haskell and can provide some valuable insights.
Don't spend 10 years learning how to use a hammer. Spend them instead to learn how to become a carpenter. Haskell is cool and all, but certainly don't spend *all* of your time on it. There are other good languages to know as well. There are also lots of shitty language you should have experience working with. You can't appreciate how awesome a good language is until you've had to deal with shit like PHP, shell scripts, or Java. My point is, don't short yourself by focusing intensely on one subject. As for Haskell, a few points: * #haskell @ irc.freenode.net is the best resource available to anyone learning Haskell. * http://haskell.org/ is the second best resource. * Learn how to use the Haskell tools. Haskellers love their personal versions of your favorite tools written in Haskell: (GHC, Hoogle, Lambdabot, darcs, Cabal, etc) * Hackage is your friend. * Half of the language's documentation is in the form of research papers in PDF or PS format. * Simon Peyton Jones is amazing. * The language is still HIGHLY experimental. New features are added all the time (with or without decent documentation). * GHC implements everything you want. The other implementations are just there for show, because it is a spec-based language. * Monads are not hard. Polymorphic types are. * Polymorphic types are not hard, type extensions are. * Haskeller's will yell at you if you don't distinguish "lazy" and "non-strict". * Haskellers love Category Theory. You don't need it as a programmer. You don't need it as a mathematician. You don't need Category Theory. * Memory leaks aren't your fault. There's no way any human could identify those just by looking at the code. * At the end of the day, Haskell isn't magical. That is an illusion caused by the suck emitted by other languages. Hope that helps.
* Practice! Attack the [Project Euler](http://projecteuler.net/) problems with Haskell. When you solve a problem, study the other Haskell solutions. * Subscribe to [Planet Haskell](http://planet.haskell.org/).
If you can't "learn Haskell" (whatever that means to you) in 6 months, move on to something else.
Haskell really isn't that bad. You read about it, you write code in it, etc. Real World Haskell and The Haskell School of Expression are both great resources. Also, look around on the Haskell Wiki and in the Wikibooks Haskell book. It has some well-written explanations on some concepts. At the end of it all, you just need to buckle down and start writing hard code in it. See what works, what doesn't, then find out why.
&gt; Simon Peyton Jones is amazing. why? i know he helped write the implementation of haskell. still whats so captivating about the guy?
He is the Chuck Norris of pure function programming. Read his paper on Software [Transactional Memory](http://research.microsoft.com/~simonpj/papers/stm/beautiful.pdf). Then watch a few videos of him. He's just a very animated guy who really knows his field. What other professor of computer science do you know who uses the phrase "launching missiles" as a euphemism for a side effect in a program?
huh? Are you saying that anything that takes more than 6 months to learn isn't worth learning?
No. I'm saying that if it takes you more than 6 months to learn a programming language, you're not suited to program in that language.
If you have trouble after 6 months, read SICP and then come back. It's the functional constructs that are dragging you down. If you have done that, read "The Art of Prolog" and then come back. It's the logic of the type system that's dragging you down. If you've done both of those and still don't get it (the basics anyway... Don't kick yourself for not understanding the reverse future gradiant transmogrofication comonad for heaven's sake!) then you just aren't writing enough code, but rather, are reading too much Reddit.
&gt; whats so captivating about the guy? * His leadership and immense [technical contributions](http://research.microsoft.com/~simonpj/papers/papers.html) to the field, spanning academia and industry. * He's a great speaker and ambassador, with an infective enthusiasm for functional programming, and can engage diverse audiences ranging from experts to having no previous experience with FP. * He is [British](http://upload.wikimedia.org/wikipedia/commons/thumb/d/d0/Simon_Peyton_Jones_01.jpg/633px-Simon_Peyton_Jones_01.jpg) (though born (and named after a town in) South Africa), a graduate of the same college as Isaac Newton, and husband of a priest of the Church of England * He can inspire academic papers titled "[Sexy types in action](http://portal.acm.org/citation.cfm?id=997142)". * He gets funded by Microsoft to research and work on GHC. * When he's not advancing the state of functional programming, he can be seen doing anything from [snow skiing](http://research.microsoft.com/~simonpj/GIFs/spj-snow.jpg) to [kayaking and desert biking](http://haskell.org/haskellwiki/Simon_Has_Fun).
screen shot?
A bit old. Some code would have been nice.
Somewhat disingenuous article. Flying Frog/Dr. Harrop make their money on OCaml and F# and benefit to some extent by engendering a negative perception of Haskell. Which is a little silly, considering there is considerable migration between the two and most people who know one can at least make sense of the other most of the time. Also, I think it's a little predatory to land on Darcs like this. The largest and most successful Haskell project is of course GHC. As a compiler project, GHC is gigantic and I wouldn't expect every VCS to perform well enough to suit its team. You'll notice there is no comparison to Monotone, a C++-based distributed VCS based on a different interesting set of theories. No one damns Monotone because of the choice of language. Even if we were, it would be easy to point to Python, which is clearly slower than the languages in discussion, yet has a VCS implemented in it (Mercurial) which is almost as fast as Git and definitely in second place as far as speed goes. And let's not forget the ever-slow Subversion, also written in C. People reading this comment know that language can only help or hurt so much, algorithm selection has much more to do with performance. It's easy to point to a lack of large projects implemented in Haskell, but where are the large programs written in OCaml and F#? I've never heard of any of the programs below Darcs on this list. FFTW is a widely-depended on library precisely because it interfaces with C, not OCaml. Notice "OCaml" isn't even present as a term on their front page. They don't want to scare people away. Lots of sound software depends on FFTW, so pretty much anyone running Linux with the right combination of audio encoders has FFTW. Is that market penetration for OCaml? Darcs is fine for small projects, and the majority of projects are small projects. It's still the recommended VCS for new Haskell projects because it's the lingua franca of VCS for Haskell. David Roundy et. al. took a very mathematical, Dijkstra-inspired approach to designing their program, starting with theory and then moving to implementation. I can't think of very many times that this approach has been taken (TeX comes to mind) but when it is taken the long-term results tend to be excellent. When the theory isn't sound, you may not know for years, all the while depending on ill-conceived software. What's more important to get right than a VCS? Were early versions of TeX performant? What happened to Hoare's maxim about premature optimization? I'm not sure what Harrop means by "virginal," but what he seems to be trying to say is that Haskell is too immature to be used by pointing at usage statistics. I certainly can't blame Harrop &amp; company for not building commercial developer tools for Haskell. The demand isn't there yet. But the demand wasn't there for F# before F# happened either. If he's saying the language is too complex, well, maybe it is too much for the average programmer. I often feel overwhelmed by it when I look at what others are doing with it. But there was a time when I felt that way about Python. If he's saying it's too hard to optimize, well, it takes different skills, but the optimizations are being done. It's the tone I object to more than anything.
&gt; Flying Frog/Dr. Harrop make their money on OCaml and F# and benefit to some extent by engendering a negative perception of Haskell. &gt; It's the tone I object to more than anything. Harrop is a professional troll who believes that he benefits from creating controversy - he apparently believes strongly that "all publicity is good publicity". dons posted a [good rebuttal](http://www.haskell.org/pipermail/haskell-cafe/2008-August/046129.html) to the original version of Harrop's argument on haskell-cafe. Also, the situation with darcs seems to have been misunderstood to a large extent, due largely to a poorly-worded announcement by its creator. The recent thread about [contributing to darcs](http://www.haskell.org/pipermail/haskell-cafe/2008-August/045701.html) indicates that darcs isn't going anywhere, whether or not GHC continues to use it (and my understanding is that GHC's abandonment of darcs isn't certain, but I haven't been following that closely). 
You do know that such an arbitrary field as music is detrimental to the pure reputation of Haskell. Why, the circle of fifths isn't even a circle. (3/2)^n=2^m can never exist for whole n and m so repeated fifths never fall on an octave. Pythagoras knew that but the world wouldn't listen. Even Britney Spears is passable music when purity doesn't matter. Ugh!
It would be interesting to see the response of Haskell people to Lisp.
ooo! this is the kind of flamewar I can get into :)
If you love Lisp, then it's probably pretty likely that you respect but dislike Haskell, or any other language constrained by a Hindley-Milner style type-system. 
It's almost exactly the same, they just swap static&lt;--&gt;dynamic and macros &lt;--&gt; monads. lisper: Haskell's cool, but I have trouble with the static type system, monads can be tricky and I miss the power of macros. Hasky: Lisp's cool, but I have trouble with the dynamic type system, macros can be tricky and I miss the power of monads.
I dunno, I think type inferencing is roughly as difficult to understand as dynamic inferencing, it just ends up being a trade off of whether you spend your time figuring out what the hell is going wrong at compile time or at run time. As for Macros... I mean, I think they're pretty damn cool, I'm just not convinced that they add as much power as claimed. edit: Also, Monads should be available in almost any functional language, I'm pretty sure.
This discussion has actually come up on #haskell. Most Haskellers seem to have a great deal of respect for Lisp, if those discussions are any indication of the general state of things. I know I personally think Lisp is very cool. I just prefer Haskell.
From my perspective, you can classify macros into a number of different categories, like syntactic improvements/DSLs, control flow, and some others. But with Haskell's I/O and continuation monads + laziness, you can have whatever effect you like on control flow. Haskell's type system gives a lot of what you'd want to use a macro for to improve the syntax. For just writing a ton of code for you, I'm sure macros are more powerful, and there are bound to be other types I haven't identified in which macros are more powerful. But at the moment, I'm pretty happy with Haskell and not clear on how adding macros would improve the situation. Liskell is there and should add that power, but I just haven't really needed it yet. I do wish I knew what the whole SYB and Uniplate stuff was about though.
via: http://groups.google.com/group/fa.haskell/msg/00a014c69efe3e16
I think Brian Hurt summed it up perfectly: &gt; The biggest disadvantage of comparing Ocaml to Haskell would have to be causing a long, pointless flamewar. Offhand, I can't think of an upside. 
It is surprising how no one bothered to mention that O'Caml does not have SMP support, [by design][1]. [1]: http://caml.inria.fr/pub/ml-archives/caml-list/2002/11/64c14acb90cb14bedb2cacb73338fb15.en.html
Will the heroic Autobot Monad Transformers be able to join together to defeat the evil Decepticon Monad Transformers? Tune in to find out! ... sorry. TFA is pretty neat, if the implementations provided actually work. I always thought it was a little weird that you'd have to reimplement the lifted actions for all Transformed Monads. Will have to read the code more in depth later.
What would be nice is a concrete example of the changes to apply to a typical xmonad.hs - especially the replacement of the defaultGaps part.
I voted this up, just because of the twisted nature of the post.
This is quite strategic. CUDA is here, larrabee is around the corner. And AFAIK, Haskell architecture is well suited to CUDA style processing. It does not mean it is easy. But its Galois, right ?
I voted it up because it's pretty cool. If he were to automate this to the point where you could just write a function in Excel, then just generate and compile the wrapper.. well there's just all sorts of FP/Haskell goodness you could bring to the masses via Excel. 
I was expecting prank call...
It's good to know that yes, Haskell can do that.
We all said really long stuff, and nobody replied to anybody else except the OP :(
Pandoc has been used to convert the wxHaskell documentation from HTML to Mediawiki syntax, and is currently being used to convert Darcs Weekly News from ReStructured Text into HTML.
Isn't it pointless to compare times from two different machines?
 N=eval *$&lt; def r*a puts a*' 'if N==k=a.size b=*0...N a.map{|i|b-=[i,i-k,i-~k-=1]} b.map{|*j|r *a+j}end r
I voted it up because I might actually use this at my job!
This is a nice introduction to monads. I've read many by now, but I think this would be a good first introduction.
No need. You just swing. Nail will appear if it is really necessary.
Fascinating. What *is* it good for?
Interesting but it would be a lot nicer if the results had been tested to make sure they were correct. The world is full of broken parsers... 
One very interesting application: Wouter Swierstra's [Data types à la carte](http://www.cs.nott.ac.uk/~wss/Publications/DataTypesALaCarte.pdf)
I'd read many also, and none of them really did it for me. This was the one that finally did do it for me. After I read this, I understood monads. 
Thanks: I've grabbed that for later reading.
[The original Mark P. Jones paper that inspired these blog posts](http://web.cecs.pdx.edu/~mpj/pubs/springschool.html) also discusses an application; see section 5.1. The description there is highly abbreviated, but you can do web searches to get more details once you know the magic search terms. 
Isn't Haskell abstract enough without playing stupid word games? Fluffy is Functor, Misty is Monad. If you use the actual names, most beginner Haskellers still won't have any idea what they're good for.
But a monad is a Warm, Fuzzy Thing.
Functor sounds like a tool a doctor uses to remove tumors from the cancerous monads of their patients =-P
heh I did the same due to the release of the not-so-stable kde4 but let's not lie to ourselves, to say that xmonad looks ugly is even more that it deserves... it does not "look" at all, it has nothing really. actually I like that but it's not worth to compare it graphically against kde.
Implementing `Functor []` as an exercise requires irrelevant monkeying to hide the library implementation.
You can compare graphics, in the sense of kde having lots of crufty visual noise xmonad lacks. xmonad (and tiling window managing in general, I suppose) is an elegant solution to the problem of handling multiple programs with GUIs, something traditional window managers probably never will be.
xmonad: it's not even ugly!
exactly (yet, there's people who likes graphics and animations :P my kde was so turned off that it looked like xfce (another reason that motivated me for the migration))
I wouldn't mind XMonad with Compiz style effects for when I move windows and swap workspaces. Give newly focused windows a flaming border for a split second, with smoke. Close a window and it falls away before going supernova with a shockwave that knocks the other windows into their new positions. The keyboard driven WM actually frees the effects designer from the constraint of keeping window chrome usable during transitions. You could put much cooler effects on a mouseless window manager. I like graphics effects so long as they stay out of the way but I can't tolerate the mouse.
Haskell is lucky to have such an eloquent spokesman. Great article :)
I honestly couldn't figure out how to use this lib, or understand why it took so much code, and so started writing my own a month ago. http://github.com/mgsloan/sproto/tree/master. It's less than 500 lines, and nearly feature complete. Not consumption ready yet though.
Could someone explain why the first one results in a memory leak?
Remember that an important purpose of the IO monad is sequencing computations. The first attempt is equivalent to "go create a huge list **and then** when you have it in its entirety, write it to a file in this way." The refined incantation allows for lazy computation. GHC compiles the latter to a loop -- which you can verify with [ghc-core](http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ghc-core) -- to produce partial results on demand.
Thanks!
In short: Don't write Haskell like imperative languages, write it like Haskell.
You can do it imperatively too, if you do it right: main = do h &lt;- openFile filepath WriteMode forM_ [1..10000000] $ \i -&gt; do sub &lt;- randomIO hPutStrLn h $ show (sub :: Int) hClose h But why bother with Haskell if you're gonna do that?
I don't think there's anything wrong with using low-level Haskell to get more speed from the benchmarks. The Shootout isn't meant to be a real-world comparison, just a fun game.
You wouldn't know it from the way people treat the results.
via: http://groups.google.com/group/fa.haskell/browse_thread/thread/0aa147cb91f7b673# ANN: datapacker 1.0.1 
discussed here: http://groups.google.com/group/fa.haskell/browse_thread/thread/15d26ae4433d3e68# 
would be nice to have pdf without compiling it yourself from .tex or registering on that slidey website
Great post! Thanks for posting.
Seems like a rather confused post... "we use main = sort of like int void main but we declare our string here. Most of the other features are the same using for loops etc. On a whole the language is very descriptive, its like a XML version of c where you are trying to describe what you want to do, a very nice touch. Also the pattern matching has been amazing its like regX without all the messing about,"
A "verdict"? After less than a month of dabbling?
Wow, gst is really scraping the barrel.
"You shoot the gun, but nobody notices because no-one evaluates the target." best fits with ones for other languages, but "Couldn't match expected type 'Deer' against inferred type 'Foot'" is the funniest. Edit: Actually, maybe "You shoot yourself in the foot, but nothing happens unless you start walking." is better.
I think people take bottoms way to seriously when reasoning about Haskell. I don't think the monad laws were ever intended to apply to domain elements with bottoms in them.
Does anyone here have a good solution to the debugging issue raised in point 5. (dons?) There are some names in the comments, but I wonder, what is the _de facto_ debugger, the one the expert-Haskellers use?
ghci got debugging features in the latest release; see the [GHC manual](http://haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html). Section 3.5.6 is probably the most useful, see -fbreak-on-error.
I think writing tests to prove that your functions have the desired properties somewhat mitigates the need to debug in the traditional sense.
&gt;... &gt; foo = Bar { x = "hello } &gt; ... &gt; should not result in an error Unmatched `"`
Syntax not supported. 42 == (42) = True. WTF Haskell SUCKS3Z!!! Actually it is useful for something. http://thread.gmane.org/gmane.comp.lang.haskell.cafe/45586 I still can't figure out if the whole thing is a joke though.
A missed opportunity for symmetry: class Genome a where mutation :: MonadRandom m =&gt; a -&gt; m a recombination :: MonadRandom m =&gt; a -&gt; a -&gt; m (a,a) should have been: class Genome a where mutation :: MonadRandom m =&gt; a -&gt; m a recombination :: MonadRandom m =&gt; (a,a) -&gt; m (a,a) 
nice. I remember trying to build from the development tree (I guess 0.4?) and having difficulty with it.
Cool, I fiddled with something like this not too long ago, but got hung up trying to overcome the overhead of tossing all those dictionaries around. My implementation was also much uglier... Ah, the days of my youth before I fully understood the zen-like nature of type-classes...
I built it a week ago from cabal-install. There was a dependency I had to install from hackage manually (I forget what it was but it was only one), and after that cabal-install was able get the other dependencies and build it. Try with cabal-install and it will complain when it finds the missing package you need to get from hackage.
I installed everything from hackage manually, and it seemed to build fine, but no executable appeared. I probably should be using cabal-install now.
It's times like this I hate Debian-Ubuntu's Haskell packaging &gt;:|
FYI You don't need to get the missing package (alex) from hackage. The problem is that cabal install only notices missing libraries, not missing executables. Just cabal install alex. Then continue installing yi.
It is.
&gt; It's about functional programming in languages where every program is guaranteed to terminate. Doesn't this violate the halting problem? Or are these languages not Turing complete? Or maybe I'm just completely misguided.
They aren't Turing complete.
Then are they actually real-world useful?
Kind of. You should be able to write a compiler in one of those languages, for example. Some people have suggested that you could start with a terminating language and add a separate non-terminating layer. Then you could write a program that isn't supposed to terminate, like a server, but still use terminating functions for most of the program.
so the best thing about haskell laziness is ugly unsafeInterleaveIO hack.
[Direct link to the .pdf.tar.gz](http://hackage.haskell.org/packages/archive/CheatSheet/1.0/CheatSheet-1.0.tar.gz) for the lazy
LOLWUT? unsafeInterleaveIO is never meantioned in this article.
then implement readFile without it
From http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/System-IO.html readFile :: FilePath -&gt; IO String readFile name = openFile name ReadMode &gt;&gt;= hGetContents Both openFile and hGetContents are IO primitives, so readFile never calls unsafeInterleaveIO.
http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-IO.html#hGetContents take a look at lazyRead below. primitive or not, remember all the talk that haskell has to be pure to support laziness? that we can't use laziness with side-effects because we couldn't be sure when it will be run or even if it will be evaluated at all. why is it a bad idea? try to uppercase whole file: let f = "file.txt" in readFile f &gt;&gt;= return . map Data.Char.toUpper &gt;&gt;= writeFile f
Well that won't work because you can't read from a file and write to it at the same time. This line works for me. readFile "input.txt" &gt;&gt;= return . map Data.Char.toUpper &gt;&gt;= writeFile "output.txt"
I know it does. but this is just lazy IO biting your unsuspecting ass. it is really hard to tell what exactly is "the same time". I think that it was really weird idea to include that one ugly function in haskell library just so we can write once in a while that one liner to uppercase input. and I wouldn't be suprised if it can be done in one line with regular safeDontInterleaveIO and those funky Oleg's left folds. and let's be honest - there are a lot of times that you have to modify a file inplace/update it (config file, rss feed) and there's no easy way to do it with standard library (there is Strict package on hackage with necessarry functions) and it is so tricky that it has been asked many times on #haskell (I know I had my share of problems) e.g. why it works in ghci but not in ghc (answer: ghci prints results)
You sir, are fantastic. Utterly, completely, wonderfully fantastic.
I see two competing interests in writing haskell compilers. 1. Ease of mental model for the programmer. It needs to be easy to understand how to avoid massive memory, or cpu spikes. 2. Nifty tricks that are only possible in functional compilers.
Man I love infinite lists. This is my favorite: fibonacci = 1 : 1 : zipWith (+) fibonacci (tail fibonacci)
Those don't necessarily compete do they?
The problem is that the nifty tricks often require optimizations in specific situations, that tweak and change the final assembly code that gets generated. Basically the fancier the tricks, the harder it is for the mental model of the programmer to be correct. When I do [1..10], is that a linked list? An array? Thunks that calculate into values later? How about [1..]? Is that different? Now, I say all this as a haskell newbie, so it might be entirely wrong, but that's my impression of the language.
I believe Haskell lists are singly-linked lists with reference counting so as to have persistent data to try to offset memory usage.
is it fast enough? does my machine have enough ram to run it? if so - who cares (but the magicians themselves) what magic made it possible. if not - go and ask for help on #haskell. this is great mental model for computation.
Infinite loops in haskell: module Main where main :: IO () main = main Haskell is so elegant, even its infinite loops are shorter than Blub ;-)
Without excess boilerplate: main=main But does this really count as an infinite loop? $ ghc --make loop; time ./loop [1 of 1] Compiling Main ( loop.hs, loop.o ) Linking loop ... loop: &lt;&lt;loop&gt;&gt; real 0m0.003s user 0m0.000s sys 0m0.004s 
&gt; When I do [1..10], is that a linked list? Yes, Haskell lists are cons lists, similar to Lisp or a linked list in C. &gt; An array? No. &gt; Thunks that calculate into values later? Yes. &gt; How about [1..]? Is that different? It has a very similar representation in memory. Haskell actually has a very simple mental model. Every value is a thunk until it is forced by pattern matching. Pattern matching only evaluates enough of the thunk to determine which branch of the case expression to take. Also, in lazy Haskell implementations (which is basically all of them), thunks are shared so they need only be evaluated once.
Last time I compiled such a program, I didn't get such a helpful exception &gt;__&gt; But I guess it's easy enough to detect that it's good they added something to do so. Personally, I always thought it should be a compiler warning when you had "let &lt;var&gt; = &lt;same-var&gt;" But, yes, it still counts =-P
[1..10] and [1..] are both always linked lists, never arrays, always lazy. The compiler optimizations are designed to not change their semantics.
Thats a bender alright. Made me so happy when I figured that out for the first time.
that's too bad it needs regex-tdfa 0.94 as a dependency, whereas there is only the 0.95.1 version on archlinux's AUR ...
lol .. better wings on a bicycle :)
Does this application cause you to become a suicidal, drug-addicted, actor?
Interesting. _why's poignant guide for haskell, I suppose? Kinda silly.
Maybe `IORef`s of records would be better in the future? I can't see why they need a record full of references. I can empathize with the author's remarks about namespace damage and records, but: * GHC has an extension for this. * It is so wrong to use positional constructors? * You want generic update operations and chose to implement them by giving things the same _name_ as opposed to putting it all in a `typeclass`? Could you do this in any static language besides `C++`?
When you lot mention namespace damage, what do you mean? Do you mean the annoying need to put in data element name prefixes on common Data element names? If so, how can we use typeclasses to get around this? Regarding IORef, why not just thread the GameState through as a continuation? That's what I've been doing and it works a treat.
&gt; When you lot mention namespace damage... I expect that is what is happening in the author's code, but can't be sure. One can use `typeclass`es to to put objects in class of objects with certain extractors and updaters, maybe using fundeps. That allows one to establish the semantics of the extractors and updaters in one place and implement it in another. It is somewhat more long-winded, though -- and abandons the comfortable notion of attributes of objects and moves right back to functions on data. 
I'm pretty sure the original article is complaining about how record selectors are put into the global namespace. Typeclasses can allow more than one data type to have selectors (and updaters, with a bit of effort) with the same name.
mmm...using modern languages for game dev is really a PITA. A haskell community effort on a game project (a bit like blender did) would dispell a lot of reserve on functionnal programming. Game development is really conservative when it comes to languages and paradigms. As the same time, there are a lot of very good devs in the game industry. So prooving that Haskell can be efficient in this domain would do two things : gather interest from a lot of good coders and proove that haskell rocks even where c++ is supposed to be the only solution. This is interesting to do that with the game industry (opposed to, say, code proovers needed for space shuttles) because 1/games are visual 2/game industry is a multi-billion industry that everybody knows. With the sponsorship of some well known game dev (Sweeney I am looking at you), this could make a big (Haskell) splash (sometimes you really need side effects :P). Make it Google summer of code project and you're set. Yeah, I know easy to say...but still I am sure Simon Peyton-Jones could charm anyone to go for this.
&gt;One can use typeclasses to to put objects in class of objects with certain extractors and updaters, maybe using fundeps. Right, but you can't have a typeclass in a function signature unless you use existential types. And even then, it doesn't dynamically dispatch or anything. So what are typeclasses getting us here?
My experience differs from yours. I know quite a fex game dev, they are very good coders. Still they don't know haskell. It may be hard to believe but the aura of the haskell is not that big (I learned of haskell on reddit, without it I would still be ignorant of haskell). But game dev are exactly the kind of community member you want : intelligent, productive and math savvy. They would appreciate haskell if they knew about it. And they would invest in the community to expand a project as the one I described. But they won't do it from scratch (there are a lot of piece in the code pipeline, from importers to streaming managers). And As I said a game is a very visual and, call me an idealist, but if that helps more people turns away from c++, php, or perl, I would be a happy man. And tell me who is writing commercial games in Haskell. I would gladly work for/with them (did I say I was an idealist ?). 
&gt; Right, but you can't have a typeclass in a function signature unless you use existential types. Can you explain in more detail what you are saying here? I hesitate to provide a counter-example: isGreater :: (Ord a) =&gt; a -&gt; a -&gt; Bool isGreater x y = x &gt; y &gt; ...it doesn't dynamically dispatch or anything. So what are `typeclass`es getting us here? So maybe I'm not clear about what it is you actually want to accomplish. A more specific example would help. 
True. I was thinking of some specific problem I had a few weeks back. Let me try and dig up the old code to determine the problem I had.
Microsoft does have a research group that is doing something that focuses on Haskell. However, now that they ported OCaml to .NET with F#, I don't know if the focus of the Haskell-using group is to bring a second functional language to the .NET CLR.
Note there's an active .NET bridge, http://www.haskell.org/haskellwiki/Salsa
&gt;this code is probably not optimized or optimal I imagine there's an easier way to specify the transitions. That's the most glaring suboptimal aspect.
Now solve it in the type system. :D
Isn't this a Satisfiability problem? I'm not up on my complexity theory, but I thought that satisfying boolean formulas (like this) was NP-hard... The transitions are a bit nasty- but I think there is an inherent hardness to the problem itself that will make any solution slow...
I don't think he was talking about speed. It's an ugly way to specify the transitions when such a beautiful language is available.
IO/side-effects are not the only solution. Look at [FRP](http://www.haskell.org/frp). Specifically, Fran is the easiest to appreciate, IMO. I believe the future of reactive programming is functional reactive programming. 
it's true; I wasn't.
You wouldn't know it by the title, but this is an actors-like approach to concurrency (I think).
I am interested in learning about reactive programming, but Conal's paper on reactivity in functional programming is over my head right now. Does anyone have a more down-to-earth tutorial/explanation of it?
Same situation here.
Newcomers to Haskell always seem to be asking about how to not overflow the stack, but in the (fair amount of) software I've written in haskell, I don't recall seeing one, even when I had less of an idea what I'm doing. Is it really a big problem, or is it mostly a matter of people choosing "sum a big-ass list of things" as their first task in the language?
The nuance between the fold combinators and when you should use them is something I wasn't entirely aware of beyond a very high level differentiation between foldr and foldl
It has happened to me and even foldl' didn't help, I had to use strictness annotations all over the place in the function I was folding with, totally obscuring my code. Haskell is an amazing language, but laziness is on the whole a minus in my book. In for example Ocaml I can write straight-forward code and it will be fast and predictable, but in Haskell strictness annotations would detract from the straight-forward algorithm with considerations about what needs to be strict and why, which is often more complicated than the actual algorithm.
&gt; use strictness annotations all over the place in the function I was folding with a scatter-gun approach to strictness is rarely appropriate. Using strict data structures, however, is far more useful, imo.
Thanks, I'll take that advice next time. The data structure in question was a list of pairs, so I would need to create my own strict list and my own strict pair, unless they exist already and I have missed them. IIRC what I actually did in the end in my code was I created strict cons and pair functions and used them instead of (:) and (,). This was not too bad I guess, but it was nevertheless a distraction.
Very likely all you needed was a strict pair (given `foldl'` is whnf strict, so won't see through into accumulated pairs). See the [Data.Strict.Tuple](http://hackage.haskell.org/packages/archive/strict/0.3.2/doc/html/Data-Strict-Tuple.html) package, and the chapter that discusses precisely the strict pair issue in [RWH](http://book.realworldhaskell.org/read/profiling-and-optimization.html#id679016). The solution is simple and straight forward. Enjoy!
Upvoted for the Book of Mormon. That would explain why Haskell confuses me so.
So if I'm intreprting this correctly, the Book of Mormon + Bat Boy + a Kitchen Sink = Haskell. Makes sense to me.
I like Haskell but I sat down to make something which needed vector math... and gave up. Google for haskell vector class.
Syntax is a big problem for me when learning Haskell , it one of the reasons I chose Clojure instead
Haskell's syntax confuses the hell out of me. Thank $DEITY for emacs' syntax highlighting/suggestion.
Does anyone know why it takes half a gig (OS X) ?
Why is there so little mention of the Generalized List Comprehensions?
I assume it'll be included in Planet Haskell?
Weird that there wasn't any mention of comprehensive comprehensions in the other 6.10 release notes.
There's a lot of libraries with source shipped with it maybe ?
The linux binary tar.gz is ~50M...
On linux the package unpacked could be say 100 MB tops.
What are sparks?
I hope it makes it into the Prelude soon.
The 'jobs to be run' produced by `par`. They go into a spark pool, then run in a real thread once one is available. They're the prime mechanism for speculative parallelism at a fine grain.
Do you use them?
I've always wondered why modern CPUs don't directly support this sort of thing. Any pointers to a more detailed explanation of the implementation?
http://www.macs.hw.ac.uk/~dsg/gph/papers/ The current implementation just merges in things from Glasgow Parallel Haskell. So there you'll find details on strategies, sparks and so on.
So, say we have list of thousands of things to do. It is natural to fold `par` over them and then they can proceed in parallel -- but if we only have four CPUs this will not be terribly bright, right?
Exactly what thread sparks are for. You'll have your four cpus competing to execute the sparks from the spark pool. So speculate on that parallelism.
They do: multi-core CPUs. Designing a CPU which can support # of threads &gt; # of cores will require substantially higher gate count - it's easier/cheaper to just do that in software, plus it allows finer control of scheduling. I do expect future CPUs to have several cores (64+) and support threading in hardware. Already you have techniques like hyperthreading and pipelining which are pushing it closer to that goal. Some hardware synchronization primitives (s/l/mfence, mwait, monitor) are also available already.
Not per se (particularly because I'm not really using Haskell yet), but I work with a language that uses something very similar to them (KX System's Q if anyone cares), so I'm fairly interested in developments in Haskell regarding using lists for querying.
Cool, Data.Strict.Tuple looks nice. I wasn't aware of the strict library. It is a bit better than defining my own strict pair/cons functions. I actually needed strict cons as well because the state (or initial value/result if you prefer) that I was folding was a list of pairs. 
This sounds pretty similar to Erlang's scheduler implementation. The big issue there seems to be process-scheduler affinity (or, rather, the lack thereof). But, I guess in this case a spark is completely evaluated and a value returned, so that's not a concern? Or can a spark be partially evaluated and returned to the pool in some situations?
Note that there are also Haskell (`forkIO`) threads here. `par` is cheaper still (designed for teensy tiny subexpressions, that may get run in a new thread if resources are available). Erlang's threads are pretty much identical to Haskell threads, rather than Haskell's thread sparks. &gt; The expression (x ``par`` y) sparks the evaluation of x (to weak head normal form) and returns y. Sparks are queued for execution in FIFO order, but are not executed immediately. If the runtime detects that there is an idle CPU, then it may convert a spark into a real thread, and run the new thread on the idle CPU. So the key thing is that sparks are super cheap hints that the runtime might want to speculatively evaluate the expression. It may or may not actually do so in a new thread. The creation of these hints needs to be super cheap, to encourage fine grained parallelism hints.
I guess it's not too likely to go in the Prelude, just based on the frequency of changes made to the Prelude in the last decade or so. I hope it makes it into the standard libraries, though.
From GHC's download page: MacOS X (Intel) * GHC-6.10.1-i386.pkg (94M) This is an installer for Mac OS X 10.5 (Leopard). The package requires Xcode 3.0 to be already installed. You can find Xcode 3.0 on your Leopard installation DVD (or at http://developer.apple.com/. 
From [GHC Installer](http://img374.imageshack.us/img374/3541/picture1jl4.png): &gt;This will take 421 MB of space on your computer. .. I didn't really conjure up that comment out of thin air, there was a reason to it.
I hope the first two years in this list are typos. * 2009-11-15 GHC 6.10 support darcs 2.1.1 * 2009-11-30 build systems, libdarcs darcs 2.1.2 * 2009-01-15 performance and Windows darcs 2.2 * 2009-07-15 performance and transplant darcs 2.3 
I sometimes wonder if Wadler's true skill comes in taking things other people have come up with and explaining them clearly. There are at least three or four examples I can come up with off the top of my head where he took some interesting idea and presented it in an interesting new way, and suddenly whole layers of complexity just dropped off to expose the elegant (and creamy!) nougat center. It is truly a beautiful thing.
There are indeed, 2008-11-15 and 2008-11-30 respectively :-)
How is this better than ctags?
Off-topic curiosity: What are you using Q for?
Fascinating.
ctags doesn't support Haskell, AFAIK. htags supports only Haskell. Their applicabilities are disjoint.
Technically `do` notation does not make the expressions evaluate. But this is only a cheat sheet.
Woo! Demo online, http://johnmacfarlane.net:5001/Front Page
Buzzword explosion!
http://johnmacfarlane.net:5001/Front%20Page presumably
No axes are labeled. I can't make sense of this graph except that there is an upwards trend.
Looks like my school teachers were right on the notion that nobody will understand a graph's meaning without labels.
Hehe. True enough. kilobytes of text on the y axis, days since epoch on x. 
I don't know why I'd want to use a language where you could only draw in scribbles (kidding).
Is it still slow?
The description said "One line of haskell". What's that line?
 torus sr cr = revolve (const (sr,0) ^+^ cr *^ circle) 
We have a release planned for January with some performance enhancements from our first darcs hacking sprint (25 October). It may take a while before we catch up with the likes of git, but we are making progress and we intend to continue doing so!
Well, I'd say it's really a few, but still if you look at the code (get the reactive-fieldtrip package from hackage and take a look at Test.hs), it's really quite concise. :) The way things are going with Conal's brilliant abstractions, I hope that as things progress, we'll end up with full playable video games in about a page of elegant, purely functional Haskell code.
Ah.. I don't want to get stuff from hackage just to see some example code :| http://code.haskell.org/reactive-fieldtrip/src/
Hmm, cabal install reactive-fieldtrip Easy.
Excellent, I look forward to it. Thanks.
Yes, the word "execute" would be better there. Also, in the braces and semicolons example, there's a superfluous semicolon before the closing brace. (Which won't cause problems, but is unnecessary.)
yeah ... I can make that in 1 word in any language.. like C++. `torusRevolve();` Just needs the proper libraries installed and relevant function defined. Also, Haskell operators get on my nerves. You can't overload them, once an operator is defined as belonging to a class, all you can do is implement an instance of that entire class. No `v1 + v2` where v1 and v2 are n-dimensional vector. You gotta invent something like `^+^` or whatever.
Thanks for the insightful contributions! &gt; You can't overload them Umm... incorrect. That's the whole point of type classes... instance Num Vector where (+) = (^+^) No need for nerves.
That's what I mean.. you must make the type an instance of the class which defines the operator. And that means defining each function in the typeclass, otherwise the default implementation takes over, opening a whole can'o worms. In your example: you'll be able to do v1 - v2 also, even if you didn't intend for Vector datatype to allow subtraction because Num class defines a (-) too among other operators and functions. You either gotta define all those functions/operators or let the default implementation take over. On a higher level, if I want a non-numeric datatype to support a + operator, I end up declaring it as numeric. Say I have a datatype for 2 tables and I want + to add them element-wise. A table is not a Num, but *contains* numeric data, so the same semantics as a Num class will not apply. Is this correct or have I understood typeclasses totally wrong?
I can't quite make out the argument, but it seems to consist of a few parts. * worries about default implementations (they're optional though) * worries about type classes that are too large (define ones with less methods) * you want to use `(+)` for things that aren't numeric. That is, have some entirely different concept applying (which you can do, but you must hide the old definition under a qualified import). These all seem manageable. Or do you have an alternative design for ad hoc static overloading that you're thinking about?
Ok I'll be more precise: * default implementations are optional, but can I declare a datatype as an instance of a type class *without* implementing all the functions in that typeclass? Like if my typeclass Foo has two functions eat and sleep, with no default implementation, and if I make a datatype Bar, and want it to support "eat" function only, can I do that? * define a smaller typeclass: yes, can I define a typeclass which contains functions or operators already declared in another typeclass. E.g. can I make my own typeclass with just (+), and have the compiler choose the (+) from *my* typeclass instead of Num, for datatypes of my class, and choose (+) from Num for other datatypes? * qualified import: so that would mean I shadow the existing (+) right? That would lose ability to add numbers for example.. I am thinking C-style operator/function overloading based on the datatype of the arguments.
 * Yes. * Yes. * You'd have to add qualified. Note your really pushing against the purpose of type classes, which is to provide operator/function overloading, ad hoc, based on the type of the arguments.
Wow how come none of the literature made that clear? Pretty sure when I tried to define a type class containing (+) the compiler complained of 'already defined' .. A yes for #2 would just convince me to pick up Haskell again for day-to-day work instead of battling C++ or Matlab. &gt;purpose of type classes, which is to provide operator/function overloading, ad hoc, based on the type of the arguments. Exactly what I want. /off to try again EDIT: bummer. ghc is segfaulting on leopard. :-\ Can't find a fix.
&gt; ghc is segfaulting on leopard. You absolutely should report this! http://hackage.haskell.org/trac/ghc/newticket?type=bug
Never mind, got it working. Problem was on my end.
No, &lt;switch from the browser to my shell&gt; cabal install reactive-fieldtrip &lt;find the file Test.hs&gt; vim Test.hs vs. click the link
Well, I tried define a small type class with operator (+) and didn't worked: Ambiguous occurrence `+' It could refer to either `Main.+', defined at class.hs:7:4 or `P.+', imported from Prelude at class.hs:1:0-18 
 module Plus where import qualified Prelude as P class Plus a where (+) :: a -&gt; a -&gt; a instance Plus P.Int where (+) = (P.+) And, $ ghci Plus.hs GHCi, version 6.10.0.20081007: http://www.haskell.org/ghc/ :? for help Loading package ghc-prim ... linking ... done. Loading package integer ... linking ... done. Loading package base ... linking ... done. [1 of 1] Compiling Plus ( Plus.hs, interpreted ) Ok, modules loaded: Plus. Enjoy.
I think that's the encoder (recordmydesktop). On 1600x1200 it was entirely smooth.
The package sounds interesting, but the summary sounds like it was written by someone uploading it to hackage after staying up 2 days straight coding it o_o
Going by the code comments (misspelling version as versión, original as origina), the author speaks Spanish.
really cool, thanks!
You know, I really didn't think the "uglyMean" in Max's original blogpost was all that bad.
However, the realisation that this Fold datatype has good algebraic structure (in particular, that it's an applicative functor), and that the algebraic structure leads directly to the required optimisation, seems to suggest that there really is something to this approach.
I'm with you. `uglyMean` is a clever solution to the space-consumption problem of `naiveMean`. And since the naive/clear version is very simple, the clever version is still manageable. What's so cool about Max's approach is that he separated the cleverness of `uglyMean` from the specifics of the example, so that the cleverness could be applied to lots of examples while keeping the simple beauty. In particular, lots of fold-based functions can be composed, and the clever optimization applied while leaving the code simple &amp; clear.
I guess all the Functor stuff is still just too confusing to me.
It's nice, but with the last version of lambdabot I tried to use, it didn't work. Maybe if lambdabot and GOA are friendly again I'll give it a try.
Love the subtitle at the top of the front cover: "Code you can believe in"
I haven't had luck getting this to run on Leopard. It'll compile and run, but once I point my web browser to my localhost I get this: &gt;Server error: src/Main.hs:28:14-26: Missing field in record construction HAppS.Server.HTTP.Types.validator 
When's it going to show up in Safari?
Next few days.
It's a great book. I don't understand the Creative Commons Attribution-Noncommercial 3.0 License. Is this a dual licensing agreement with Oreilly/Safari?
Oh, I'm disappointed, I thought you meant [acid](http://doc.cat-v.org/plan_9/4th_edition/papers/acid).
Doesn't using isprime invalidate the point of a function to determine if a number is prime?
No, `isprime` is what is being defined there, via mutual recursion with `primelist`, which is also being defined. The final program as discussed looks something like this: isprime n = not . any (\p -&gt; mod n p == 0) . takeWhile (\p -&gt; p^2 &lt;= n) $ primelist primelist = 2 : [p | p &lt;- [3,5..], isprime p] (with apologies for the minor modification I made to improve readability) The list of primes (apart from 2) is determined by testing the odd numbers for primality which is done by a function that uses the list of prime numbers, but only the initial part of the list, up to the square root of the number in question. (Hence, to determine the next prime, it never needs more primes from the list than are already determined.)
I have a disease. When I see an expression, I have to get rid of the points (at least those that are easy!) isprime n = not . any ((==0) . (n `mod`)) . takeWhile ((&lt;= n) . (^2)) $ primelist primelist = 2 : [x | x &lt;- [3,5..], isprime x] 
That's not a disease. I'd also collapse not.any: primes = 2:[n | n &lt;- [3,5..], all ((/= 0).(n `mod`)) (takeWhile ((&lt;= n).(^2)) primes)] 
Congratulations for making it less readable.
*Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are - by definition - not smart enough to debug it.* *- Brian Kernighan* QFT
yes, but perhaps by programming at the peak of your cleverness, you can increase your cleverness threshold.
That may be possible. However you would increase your ability more quickly by reading clever code written by other people.
If everyone listened to you, it would never get off the ground.
That assumes that clever code is harder to debug. So if I replace my clever, modular architecture by a steaming, yet simple pile of dung it should get easier to debug. Theres a difference between compressing code via clever tricks and compressing code by noticing clear, high-level patterns.
Abstraction is not clever.
Unfortunately this prime definition isn't very efficient. But it is short!
This indeed was my purpose. I wanted him to read and understand my circular code, so that he may learn how to apply this technique in his work.
Point-ful and Points-free are pretty much equivalent, in that you can mostly automatically convert point-ful to points free. However, points-free lends itself better to refactoring, and is usually more concise. I also found points-free less readable at first, but after a few months of toying with it, I now find it *more* readable, simply because it is shorter and re-uses existing concepts/functions such as "const", "id", "flip" instead of reimplementing them. So its easier for me to read (liftA2 (/) sum genericLength) than it is to read: \seq -&gt; sum seq / genericLength seq.
Just be sure and attempt the exercises before consulting the list of solutions.
I forget where I got this definition. It looks like the same algorithm (except that it lets the sieve to filter out even numbers too) but I think the wording is better and it's short. primes = sieve [2..] where sieve (p:ns) = p:sieve(filter (not . multsof p) ns) multsof p n = (n `rem` p) == 0 
`(/) &lt;$&gt; sum &lt;*&gt; genericLength` is better still. :)
The sieve doesn't seem to have the equivalent of `takeWhile ((&lt;= n).(^2))`, so I think they are different algorithms.
So why are the successor versions empty?
COMPUTER HAS 4 PROCESSOR SIMULTANEOUS 4-CORE LAMBDA CUBE
How well does it work? Has anyone used it?
Can anyone point me to an easy-to-read explanation of the time cube concept, and why that guy thinks its so important. Does he think there's some worldwide conspiracy to make the rich richer or something?
[Wikipedia](http://en.wikipedia.org/wiki/Time_Cube)? If you're looking for a coherent explanation, it doesn't exist -- the ideas are too crazy ;)
The constraint stores referenced by the code are described [here](http://www.reddit.com/r/haskell/comments/77slt/constrained_monadic_computations)
Particularly while learning on a language's nursery slopes, which is clearly what's going on here.
I think liftA2 is actually more composable than that... (liftA2.liftA2) f x y = f (fmap.fmap) x ((&lt;*&gt;).(&lt;*&gt;)) y And its very useful to be able to compose lifts in order to penetrate more boxes.
Neat
JHC generates *extremely* fast code (when it worked it beat my C code in most of my little tests!), but is very buggy and incomplete (or at least it was at the time that I tried it). It also takes a very long time to compile things since it does aggressive whole program optimization.
[ASN.1](http://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One) compiler.
Awesome! Just what I wanted!
How does this work (from App/Views/Tutorial/Index.hs): page :: View XML page = &lt;div&gt; &lt;h2&gt;DANGER WILL ROBINSON&lt;/h2&gt; &lt;p&gt;Developers only at this point!&lt;/p&gt; &lt;p&gt;That said, we're looking for help. Interested? Check out the &lt;% anchorTag "/Develop" "Development" %&gt; section. Grab the code, look it over and tell us how you would improve it. &lt;/p&gt; &lt;/div&gt;
It is very likely to use a preprocessor step.
I'd be interested to see him take a lesson from haml and implement it as self-closing functions instead of tag soup. So much nicer to work with.
It's already available in electronic form - on Safari Online and from the O'Reilly website.
It seems like this would be a good application of the new [quasiquoting extension](http://www.haskell.org/haskellwiki/Quasiquotation) (rather than requiring a preprocessor) But yes, it uses [hsx](http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hsx).
Ironically, the internal representation of the XML is somewhat closer to that. It's just a Haskell datatype: data XML = Element Name Attributes Children | CDATA Bool String type Attributes = [Attribute] type Children = [XML]
any write ups on MACID?
un-versioned link, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mediawiki
Not that all of them compile...
Does it really generate that fast code? I tried it on some text-munging scripts, and the JHC runtimes were, if anything, consistently slower than GHC-compiled runtimes. Smaller binaries, though.
I'm currently playing with using Conal Elliott's Reactive library to write an unconventional make replacement, which watches for when files have changed and then tries to rebuild the project. Maybe it will be able to build GHC one day!
Congratulations, kowey!
Oh, Congratulations rather to Duncan, and also to Jason for taking the initiative to put this up on hackage so soon!
Now with machine-tags support (exif, geo location etc.) also -- http://hackage.haskell.org/cgi-bin/hackage-scripts/package/flickr 
That wasn't my experience, but I did more number crunching type things.
Cool. I've also done some thought experiments and tinkering with using Reactive to automatically run compilers, linkers, and apps, reactively to time-varying source code (e.g. edit &amp; save). I expect that making it really elegant will involve submerging the whole notion of a file system into the implementation of purely functional dynamic values (FRP behaviors). By the way, I spell my last name with two "t"s. 
Oops - I've fixed that.
Bad writing. It's all too easy to understand this rant as Scala sucks, hence static typing sucks. Proof in the comments.
Guido's review is a mixed bag. On the one hand, he says Scala's type system "contains such esoteric concepts as type erasures..." -- but even Java has type erasure these days. On the other hand, when examining the confusion over semicolons, he really did get to the bottom of things and pinpointed a genuinely confusing aspect of the language. 
&gt; Haskell is a pure functional language with a fast implementation that seems to have solved the I/O problem of functional languages well I'll take that.
He didn't say exactly that, but I see why his audience interpreted that this way. 
You can, It is an accomplishement to get this kind of implicit praise from another language designer.
Pretty cool, but ghosd &gt; xosd. ;-)
Nice. That's next on my list.
"Pure haskell implementation of SHA." Perhaps.
holy crap, I can have my own Large Hadron Collider via Cabal? Haskell really _does_ do everything.
[Screenshot](http://sourceforge.net/dbimage.php?id=194901)
This is neat - I tried it out just a couple nights ago. When I asked Lemmih what the future holds for lhc he didn't say - but look at the webpage. Its obvious he's been studying JHC more than just making it cabalized.
So. Haskell *accidentally* has support for variadic arguments?
Variadic arguments fall out of support for functions as arguments.
Yes! I've been wanting to use haskell for composition for a while. I can't wait to play around with this.
Lennart's LLVM bindings are pretty impressive. Hope they'll be open sourced!
Basically, yes. It's a consequence of typeclass polymorphism, and specifically with functional dependencies (to allow the final result type to determine the types of the parameters). The basic idea is that once you can have a function be polymorphic in its result, you can have cases for where the result is another function (to take another argument), perhaps with a similarly polymorphic result. Type inference, or programmer-supplied annotations then resolve the actual type, and number of parameters needed. It's a bit of a trick, but it works if you really need it.
Where is haskell going with cabal? I usually prefer the system package manager but I've installed a few things with cabal too. What are other people doing? Are you using pacman or cabal?
Does this mean it's going to be developed a bit more actively now? JHC was very fast for things it was good at, so it would be cool to get something that could be used a bit more reliably.
cabal is for developers, pacman is for users, or lightly interested developers.
You need typeclasses as well, for a function's output type to depend on context.
Yes.
I received an e-mail from Amazon informing me it shipped just moments before I saw this post.
Congratulations!
I just saw my shipping notification as well–congratulations! ...and let me add myself to the long list of grateful noobs working their way through the web edition. Hopefully I'll be able to reciprocate by putting some useful things in Hackage someday!
free online book. http://book.realworldhaskell.org/ and entertaining inline comments.
I think this is just a draft version.
Will there be an Eastern Economy Edition? It's too expensive for most of south Asia..
Hmm... I don't get his point about the packages. What if someone doesn't have the right package installed, how will he know which he needs to download unless the cabal file explicitly lists them? You could possibly have some tool to fill it in automatically, but I'm not sure I like the idea of my build system modifying my settings without any action on my part.
Is that a typical practice for other technical books? Are the books printed with cheaper inks or paper?
Yes. Indian students survive on it. Typically the books are greyscale to save on color ink costs, and are in paperback format. Though the bigger reason is that its manufactured within the country instead of imported.
Great news, good work! I'm reading my copy on Safari, but I could well put the book on my Christmas wishlist :)
Spot-on. If I'm writing a package, I want to know if I accidentally add a new dependency. It might be nice to get the choice of adding it right there, though. Something like, "Foo.Bar is a member of package quuux-1.0, which is hidden. Unhide quuux-1.0? [yes/no/ABORT]: "
I think they plan on updating the online version with the final text soon.
Perhaps I misunderstood you both, but isn't that exactly what Cabal does? src/Core.hs:8:17: Could not find module `Data.Map': it is a member of package containers-0.1.0.2, which is hidden ...and then you add containers to your project's cabal file.
I have access to a 12 CPU IA-64 machine, unfortunately there's no build of ghc for that architecture :-/
No recent one. It's been ported in the past. But I think DPH is looking for x86 or x86_64, in particular. sparc also good. 8 or 16 or more cores are needed.
I've bought books from Prentice Hall India before, who sell cheap versions of lots of CS textbooks. Half the normal price even with postage to the UK. No good if you're in a rush, it will take months to arrive. The quality can be pretty bad, up to and including the occasional unreadable sentence. 
Amazon UK estimates Dec 11th to send mine out. 
Reading the (real) Prelude (alongside "A Tour of the Haskell Prelude") is a great way to become familiar with clean, idiomatic Haskell 98, and should to be recommended to every beginner -- implementations should keep the Prelude easy to find and easy to read. The first thing I liked about Haskell was its foundational nature, thinking "wow, this is simple!", which would not have been the case if I'd dived in with the more modern idiom that flings around terms from Category theory etc., as displayed here. (I'm not knocking the people writing that page, as they obviously have different aims, but it wouldn't help clarity if the real Prelude began with definitions of Applicative etc :-)) The other side of the "modern way" is diving into with streaming mp3 servers or whatever; it's unfashionable and I'm looking forward to my copy of RWH but there's also a place for the books that leave IO to chapter 23, if they get round to it at all ;-) 
Congratulations! Even in the current climate this is a dream job.
hello, im an admin for two dual core intel pentium Ds @ 3.20 Ghz. Here is /proc/cpuinfo: http://hpaste.org/12440 I have ghc installed on it, though it is 6.6.1, but I can update it easily. The distro underneath is gentoo. The one problem is that it's on an internal network, so I would either have to ask for a guest VPN account, or we can setup some form of ssh tunnel. It's not really used at this point in time, so there's alot of idle cpu cycles. Let me know who I need to contact about it. 
I can lend my workstation that I only use to play WOW. (notebook is too convenient for everything else). It's a quad-core (intel Q6600) with 8GB memory, but it only has ghc 6.8.3 from ubuntu repo.
 Wow, that's an impressive hack. But if I ever saw something that obscure in a project I wanted to hack on, I'd run away fast. Just because you can do something like that doesn't mean you should. :)
This is what firefox gives me: XML Parsing Error: not well-formed Location: http://wholesalebanking.standardchartered.com/en/mediacentre/pressreleases/Pages/08102008B.aspx Line Number 10, Column 1677:&lt;meta name="keywords" content="stanchart, standard chartered, standard chartered bank, american express bank, wholesale banking, wholesale bank, financial institution, bank, investment bank, asia, africa, middle east, wholesale banking, Islamic banking, transaction banking, financial markets, corporate finance, principal finance, commercial bank, financial banking, asia investment, corporate banking, business banking, commercial lending, global markets, microfinance, Islamic financing, saadiq, sukuk, emerging markets, transaction banking, cash management, trade services, trade finance, securities services, liquidity management, clearing services, letters of credit, letter of credit, export services, invoice financing, receivable services, supply chain finance, straight2bank, ecommerce, electronic banking, electronic banking service, custody services, working capital, fund services, fund administration, funds allocation, corporate actions, asset management, financial asset management, securitization, clearing, financial markets, capital markets, global markets, asset group, risk management, financial risk management, foreign exchange, foreign exchange markets, global foreign exchange, fx, fixed income sales, interest rates, commodity derivatives, commodities, ecommerce, capital markets, debt capital markets, asset back securities, credit derivatives, convertible bonds, structured products, equity, equity derivatives, derivatives, ndf, OLT, syndications, fixed income trading, structuring, quant, structured trade finance, export finance, structure finance, acquisition finance, acquisition financing, mergers, acquisitions, mergers and acquisitions, M&amp;A, Harrison Lovegrove, oil &amp; gas industry, Pembroke, aircraft financing, project financing, project finance, financial advisory, debt solutions, financing, term financing, capital raising, shipping finance, renewable energy finance, renewable energy, Infrastructure finance, power financing, private equity, private equity funding, corporate private equity, real estate, infrastructure, alternative investments, real estate investment, infrastructure investment, distressed assets, distressed debt, standard chartered istithmar"/&gt; --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------^
In that case, I've got a couple 14-way Sparc servers that don't boot. Damn things barely turn on.
Okay? What did you hope to accomplish by letting us all know this?
expression problem. I'm sorry, I'm sorry - what is expression problem?
Well, I seem to have accomplished something - it's been fixed! ;-)
I don't see how a different turing-complete language is going to help a fundamentally hard problem, unless you're using the P = NP monad. Granted, the constant size is smaller, but the growth should be the same, yes?
Hmm? They wrote a solver. It's nice they used Haskell to do that. This has nothing to do with Turing. ---- What's really interesting to me is that the smarts are done in Haskell, which are integrated via a DLL into C++ and Java. That's a great model, and I'd like to see more about how they did it.
The integration interests me more, too. Not so much to know the details of the FFI mechanics, but how they managed the introduction of a solution with several different "full strength" languages. There is (too) often (too) much resistance to multi-language solutions in industry. One "system" language and one "scripting" is a combination that's often acceptable. I wonder how Haskell was presented.
Just because the formal description of a problem is N.P. complete, it doesn't mean that the set of instance you have to solve is. For a lot of "real world" problems linear programming, constraint propagation and even (crosses self and spits) an intelligent use of heuristics can go a long way to solving many of the instances.
At last, the killer app for functional programming: coping with EU bureaucracy! 
[Here's](http://www.i3s.unice.fr/maspeghi2004/final-version/e_ernst.pdf) a good definition: &gt; The expression problem has been deﬁned as follows by Torgersen: “Can your application be structured in such a way that both the data model and the set of virtual operations over it can be extended without the need to modify existing code, without the need for code repetition and without runtime type errors.” 
I know that, it was just a lousy Jeapardy! joke. but that guy, with all his ranting that changing union of types means rewriting code, forgets about the other hand of expression problem - that using typeclasses only it's harder to add new functions.
I predict a breakthrough for arbitrary size integers as a language feature in the near future in the field of software handling US$...
probably wouldn't make a good benchmark, Pentium D is old kit. You'd be surprised at how much better the core2 arch is.
[PDF]
I'd love to see support for the haml syntax. 
`:: PDF`
"highly Haskell optimizing" .. oops, typo. Sounds cool though! :-)
:: IO PDF
I'm thinking that HARM might not have been the best choice for a name.
It'll probably hurt more than it will help...
Does it get better performance than GHC? If so, it should definetely be in the Debian Shootout...
It probably does, if the program in question even compiles. It's not ready for production use.
lol.. the title is an oxymoron
I don't understand your comment.
Now if only we had an ARM target for GHC.
Just a joke which fell flat.. XMonad is traditionally more about utility and has a spartan look, so 'pimping' it is an oxymoron.
&gt; instance Functor ((:-&gt;#) t) where &gt; fmap h (DF d f) = DF d (h . f) Ok now haskell code has invented a new smiley: (:-&gt;#) ( a thick-eyebrowed drooling guy with a mischievous smile )
Thanks, I've recently done some prime number generating using Perl, and having these examples for comparison probably will help me understanding Haskell a bit better.
Haddock please.
nerd
&gt; All is not lost! Pierce (TAPL, paragraph 18.10) has taught us that inheritance can be encoded as open recursion. The trick is to make the reference to the self object explicit. In other words, Haskell becomes Python? Words fail. :) 
But why? And I really mean why did the author determine that a OO style inheritance mechanism was needed for customization? Which raises the next question. What are the common Haskell customization patterns or idioms?
&gt; What dawned on me today is that I can instead what I mean plainly The whole Functor? :-)
Accidentally, yes, the whole Functor.
What were the reasons for switching libraries anyway? I can't seem to find them anywhere... Anyway, looking at the editline manpage (don't have GHC 6.10, grr @ deb/ubuntu's packaging), what I like goes something like this: &gt; bind -k up em-inc-search-prev &gt; bind -k down em-inc-search-next That is, pushing up/down attempts to match what you've written so far against previous lines. This may also help: &gt; history unique 1
&gt; What were the reasons for switching libraries anyway? Licensing, I think.
Is there a git URL where this can be cloned from? 
Took me a good 5 minutes to understand what &gt;&gt;= does, and then I still don't get why. 
It's just like the list monad, except that the first element of the list is deemed especially important. Compare: *Main&gt; Pointed 3 [4] &gt;&gt;= \x -&gt; Pointed x [x*10,x*20] Pointed 3 [30,60,4,40,80] *Main&gt; [3, 4] &gt;&gt;= \x -&gt; [x, x*10, x*20] [3,30,60,4,40,80] The only difference, I guess, is that the list can never be empty. Which could maybe be useful sometimes? dunno
Neat. [Here's my take](http://stacklessexamples.googlecode.com/svn/trunk/examples/networking/wsgi/app_sessionless.py) on it in Stackless Python
git clone git://code.galois.com/HTTPbis.git Works for me.
What are the major differences/improvements over, e.g., the 3001.x version of the original HTTP library?
Yeah, you know it is a non-empty. It appears to just be isomorphic to the non-empty Stream monad. The distinction of the head element seems to be mostly done for emphasis. As it is modeling a pointed set, one should probably not presume anything about the order of the later elements in the stream past the 'selected' element. That would appear to be the distinction it is driving at.
Clever. I like the idea of using quickcheck to generate tests against a stateless server. You can leverage the testing ability of quickcheck/haskell, while still writing your application in a more mainstream language.
I'd like to see a more interesting example of the use of this microframework, ideally well commented like arnar does below. Continuation-based web frameworks are neat.
But the quantity is a bad thing! There are so many it is difficult to find what you want. In lots of areas, you will find several libraries claiming to do the same thing, but it is very difficult to choose between them. You really need to know: * Is the project still alive? * Does it have any documentation? * What are its limitations? Many packages don't begin to answer these questions. Many have no home page, no API docs, no tutorials etc. This means the only way to evaluate is to download it read the source code, then google for a relevant paper (which will probably be written far from the perspective of someone **using** the library, and might even use a language you've never heard of for implementation), and try out some code. You then find several hours or days down the road that it isn't suitable for your needs, and try the next one. This gets old pretty fast. I think hackage needs a filtering system. It is drowning in low quality packages (at least for the things I've searched for). Packages that don't meet the bar should be rejected or relegated to a 'second rate' division. The existence of *useful* documentation should be one of the primary criteria -- if a library is not documented so that people can evaluate and use it, it doesn't exist. 
&gt; But the quantity is a bad thing! Too many Haskell libraries! I thought I'd never see the day. This is precisely what the [Haskell Platform](http://haskell.org/haskellwiki/Haskell_Platform) project is for, to filter and provide some quality assurance. But first, we needed to make it easy to produce libraries in the first place. Looks like that is working. ---- BTW, why did I get downmodded? This is the freaking Haskell reddit, and the Platform is the proposed solution to quality control!
Sometimes I swear reddit is full of random downmod bots.
This strategy got a name: generate and test ;)
Yes. The core problem: we have, say, 1000 people who could write a Haskell library. We want to be as efficient as possible at taking that volunteer army and producing the libraries we all need. Generate and test is one way, though not maximally efficient. Or can we come up with a guided generator somehow? Previously, "hit lists" for new libraries haven't really worked -- volunteers just work on what they care about -- but perhaps we can refine it by having mentors or coaches to help direct people towards needed solutions? Making open source code production efficient is an interesting problem.
It's a Mythical Man Month type of problem. The library's success is largely from independent visionaries such as yourself. Haskell needs more of them and more from them. This leads to directly funding more of you guys, so you can quit your corporate jobs, and bang out more libraries, polish and merge the existing ones, and write more support documentation, so that mere mortals, without type compilers built into their minds, can use them.
As the email mentions, this is still highly experimental and nowhere near finished. If you want to derive Functor instances right now, you can use [Data.Derive](http://hackage.haskell.org/cgi-bin/hackage-scripts/package/derive).
Yeah, what was wrong with Derive?
Derive is a separate program, which takes extra work to invoke. If Functor deriving can be added to ghc it can hopefully also be included in a future Haskell standard.
&gt; Every statement in F# must either be bound to a value or evaluate to (). Lovely! Let's steal that idea.
So how would that change, say, the `&gt;&gt;=` desugaring? It would make: foo &gt;&gt;= \_ -&gt; bar illegal. I'm not sure it makes sense in a lazy language by default, but makes sense for some sequencing monads.
I think the sugestion is that the type of `(&gt;&gt;)` becomes `m () -&gt; m a -&gt; m a`. This makes sense, especially for do notation. If you want to ignore a return value you would have to be explicit about it: do putStr "stuff" -- no problem getLine -- type error _ &lt;- getLine -- ok, get a line and ignore it. On the other hand, some actions return stuff that is often okay to ignore, such as `ExitCode`s or `ThreadId`s. Perhaps there could be a `Ignorable` class? Or am I overengineering?
Ah, so perhaps a restricted `&gt;&gt;` for people who want that kind of checking. IO m !&gt;&gt; IO k = IO (m !&gt;&gt; \() -&gt; k) 
The point is that such checking should be the default, also in do notation; since ignoring return values is essentially never what you want, and hence a bug.
very useful! I'll likely contribute. tphyahoo. (happstutorial.com)
We should get all happs info into gitit, hosted on happs.org, in my opinion. All tutorials, key user examples, etc. I've posted to the happs list with [a plan](http://groups.google.com/group/HAppS/browse_thread/thread/5994b053ca8641f4).
Derive can generate instances using template haskell too. Any downside to that? Also, I'm unsure about putting more ad-hoc things into the standard if a library can do the job.
Just fixed two laziness-related bugs and uploaded version 0.2.1. getSwaps was too strict and isValid was too lazy.
Thanks! I didn't know about that.
dons, when talking about "the large Haskell community", are you refering to yourself? You **do** count for about 1000 people :)
I don't know, it doesn't seem particularly convoluted, actually.
I've been experimenting with adding direct support for literate haskell to pandoc. There's a note about it [here](http://groups.google.com/group/pandoc-discuss/browse_thread/thread/d8f327d307d4046b), and code that supports it in pandoc's SVN repository. The new code allows you to convert a markdownish literate haskell file (with bird-track code sections) to highlighted HTML with one simple command: pandoc -s myprog.lhs -o myprog.html LaTeX lhs is also supported. I'm still undecided about whether to include this code in a released version of pandoc; part of me says to keep pandoc simple and build external tools to do this work. But I'd be interested in feedback on this issue. 
So from the graph, once stream fusion is incorporated into core then we should switch to the obvious version. It's nice that stream fusion works on the naïve version of things. :)
Oh, thanks for doing this. I'm creating a haskell code cookbook website and an effective method of turning literate haskell into syntax-highlighted html has been a major issue for me.
Not using hscolour?
Isn't this also meant to be wrapping and *un*wrapping?
imap jabber irc 
No, but I've been toying with it. At the moment I'm using pygments, since I'm already well acquainted with its use, but the haskell output is unreasonably bloated. Ideally, the toolchain I use needs to do these things: * syntax highlighting * parse and create links for prelude imports (also interested in expanding it to hackage imports) * Process Markdown + bird-style literate haskell * Process LaTeX-style literate haskell If you know any tools that would help save me from reinventing the wheel too much let me know. While syntax highlighting and processing markdown-laden lhs are areas I have managed, if not entirely to my satisfaction, I've fallen short in finding tools that would help me process imports or LaTex-style lhs. I suppose I could build at least the imports tool from scratch, I'm hesitant to do so since I have a gut feeling that I'm just looking in the wrong places.
Cool. Would be nice to see some examples of using it, e.g. for test case generation.
I'd take the first approach, except I use symlinks to swap in and out various implementations `Ops`. No need to edit the `Person` module. I actually did this for the the 2007 ICFP contest to swap in and out different Bytestring possibilities. Although I didn't bother using `newtype`, so there was no compile time enforcement of my abstraction.
Submit things you need, vote up or down, comment. Then we can use this to * find things to work on * populate the 2009 summer of code * have fun Check out the [top rated topics this week](http://www.reddit.com/r/haskell_proposals/top/?t=week)
See Stefan's answer at the bottom, &gt; http://www.informatik.uni-freiburg.de/~wehr/download/Lennart.ml &gt; Using the techniques explained in the paper, you would arrive at the following Haskell program: &gt; http://www.informatik.uni-freiburg.de/~wehr/download/Lennart.hs
I noticed that the code uses `Unique` and `UniqSupply`, which look suspiciously like the types from the Ghc compiler. Perhaps these deserve to go into their own package.
Should be named "Connecting to SQL databases with Haskell" :P
See also the [Real World Haskell chapter on databases](http://book.realworldhaskell.org/read/using-databases.html).
That's a horrible name for a product.
That's some fugly Haskell code. But the fact that an encoding exists is encouraging. Perhaps a future Haskell could have a syntactically pleasant way to create MLish modules.
There is now (version 5 released)
I am announcing happstutorial 5 on hackage and in darcs. There are new chapters on various macid topics, utf8 gotchas, cookies, and various improvements all over. Please continue to report errors and inconsistencies as they come up. This version is "close to final". At least for my purposes, it has boilerplate that covers nearly all the important important use cases for a web 2.0 app. OK I missed a few -- eg, there's still no email confirmation with registration -- but there's a hell of a lot. So... don't use ruby for your next web 2.0 app -- use haskell! thomas. 
&gt; The exact reasons for the space leak are quite detailed, and I'm not going to attempt to cover them. Aww.
Yeah, I think we all understand the tail recursive mapM_ versus the result accumulating version. What's the problem?
Why can the compiler not see that the return value will never be used: sequence (x:xs) = do v &lt;- x; vs &lt;- sequence xs; return (v:vs) If we look at return expr &gt;&gt; return () will a thunk for `expr` be allocated? With enough inlining I expect the term `expr` disappears from the source code, and will not be allocated. Alternatively a reachability analysis would show that `expr` is unreadable in the entire command above, so it doesn't need to be allocated. The problem with sequence (replicate 10000000 (return 1)) &gt;&gt; return () seems to be that sequence cannot be inlined because it is recursive. But a reachability analysis seems like it would still show that the `v:vs` term in the definition of `sequence` is unreachable, and doesn't need to be allocated. However it appear that GHC doesn't implement my imaginary reachability analysis. I don't write compilers so I don't even know if the type of analysis I'm considering is even feasible. &gt; the tail recursive mapM_ BTW, `sequence_` uses a `foldr`, so it isn't tail recursive. Perhaps you don't understand this problem as well as you believe you do. sequence_ ms = foldr (&gt;&gt;) (return ()) ms
&gt; You could even write a rule ignore . mapM f == mapM_ f. Or you could write a rule `mapM f &gt;&gt; g == mapM_ f &gt;&gt; g`, and we don't have to change anything.
With some encouragement, the following might work, {-# RULES "mapM_" forall f e. (&gt;&gt;) (mapM f) e = (&gt;&gt;) (mapM_ f) e #-} 
why does sequence_ use foldr?
I assume it is so that the effects can be produced lazily from a lazy list. 
Am I fundamentally misunderstanding laziness? From what I understand, sequence_ either is or is not evaluated, and if it is, all elements will be evaluated... and because (&gt;&gt;) is supposed to be associative, foldr vs foldl shouldn't matter. So it seems to me that foldr (&gt;&gt;) should always have the same outcome as foldl (&gt;&gt;), except allocate larger thunks for no good reason.
It is possible that not all of the effects of a monad may be demanded. For example, only part of the output of the writer monad may ever be demanded: take 10 $ execWriter (sequence_ (repeat (tell "x"))) compare that with take 10 $ execWriter ((foldl (&gt;&gt;) (return ())) (repeat (tell "x"))) Edit: For fun, also try out take 10 $ execWriter (sequence (repeat (tell "x"))) Edit: removed the erroneous `flip` from the `foldl` operation.
What's the expected skill level of the target audience? It's not very friendly to beginners.
&gt; sequence_ either is or is not evaluated You are probably making the (common) error of confusing the sequencing of effects (execution) with evaluation of expressions. Monads sequence effects, but evaluation is always driven by data dependencies, even in the `IO` monad. do ... y &lt;- return [1,2..] ... will not evaluate the the expression `[1,2..]` at this point, even in the `IO` monad. Only when `y` is demanded will the expression `[1,2..]` be evaluated. That could be much later, or never.
&gt; either is or is not evaluated, and if it is, all elements will be evaluated... Yes, but in what order? Consider that you have an expression which lazily produces a very long list, e.g. [1..10^10] If you force that list one element at a time, processing each element as you go and then discarding it, then only a constant amount of memory is needed ---namely O(k) where k is a constant, the size of chunks of list produced by each forcing (k=1 for many well-behaved producers, including (..) ). If, however, you decide to read the list from the back then you need to force the entire list before you can start consuming any of it. Thus you'll require O(n) space where n is the length of the list. Additionally, you won't be able to discard the parts you've processed, since they're still reachable by the beginning of the list (which you're still working on processing). Remember, laziness is always incremental. Forcing an expression only forces it as little as necessary to render it to WHNF. If there are still thunks left over hidden under the head, that's fine. They'll only be forced later if required.
I attempt to answer this in http://www.happstutorial.com/tutorial/prerequisites: "Basic knowledge of haskell and html." I'm interested in what you think are the most beginning-unfriendly parts (whatever a "beginner" is) and if there are any concrete things I could do to improve. I considered turning this into a tutorial on haskell as well as HAppS but that turned out to be a rabbit hole I didn't want to go down.
Thanks, that helps a lot. Well, I haven't actually tried those bits of code or fiddled around with them much, but I think I understand better now. I don't think I've fully wrapped my head around what the usefulness of Writer and Reader monads could be. I think my problem was that I didn't understand how a fold could be lazily evaluated. I guess I had a rather superficial and magical view of folds, like they could not be divided into smaller parts. I guess I have also been guilty of assuming that a monad can't be evaluated lazily.
&gt; I think my problem was that I didn't understand how a fold could be lazily evaluated. I guess I had a rather superficial and magical view of folds, like they could not be divided into smaller parts. `concat` is probably the canonical example of a lazy fold: concat = foldr (++) [] &gt; concat ([1]:[2,3]:undefined) [1,2,3* Exception: Prelude.undefined
yeah, I knew about concat, but I couldn't quite figure out why it worked. I think for me to fully understand laziness, I'd have to start reading the GHC source.
I think that would be a bad idea. Just evaluate by hand. -- some case expression on the expression below is demanded concat [[1],[2,3]] foldr (++) [] [[1],[2,3]] -- definition of concat [1] ++ (foldr (++) [] [[2,3]]) -- definition of foldr 1 : ([] ++ (foldr (++) [] [[2,3]])) -- definition of (++) -- the above is in head normal form. Evaluation stops until more is requested Here is the same without using the special list notation. -- some case expression on the expression below is demanded concat ((1:[]):(2:3:[]):[]) foldr (++) [] ((1:[]):(2:3:[]):[]) -- definition of concat (1:[]) ++ (foldr (++) [] ((2:3:[]):[])) -- definition of foldr 1 : ([] ++ (foldr (++) [] ((2:3:[]):[]))) -- definition of (++) -- the above is in head normal form. Evaluation stops until more is requested The key point is that if the `f` in `foldr f z` manages to produce a constructor, then the recursive call to `foldr` can be suspended (we say that the constructor guards the recursive call). In the above case `f` is `(++)` and `(++)` produces the `(:)` constructor in some cases.
&gt; The code is going up on hackage, tonight, in all of its ugly glory. **YAY** Well done!
Oh no. Now we'll need ops on channel at all times...
As far as I can tell, it's mostly a lie. They want a strong C/C++/C#/Java developer first and then someone who doesn't flip the fuck out when they have to look at something that was programmed functionally. Strong functional programmers with less experience in C/... need not apply.
Need not apply where?
To those jobs suggesting that FP experience is valued. It's a turn of phrase, as in: "And the sign said long-haired, freaky people need not apply."
*So I took off my hat* *And said, "Imagine that,* *Me workin' for you!"*
&gt; And the sign said long-haired, freaky people need not apply. Need not apply where?
Sounds nice, but no documentation, no homepage, no description at all? That makes it fairly hard to use I'd say.
Functionnal programmers can learn C/Java/C# very fast (those are messy, unsafe but so simple, even primitive..). ( C++ is apart, it is messy and hard to learn.) my view is that the number of Strong functional programmers with less experience in C/... is not that big. Ask for a functional programmer and more often than not, you get someone who know the usual stuff (java/c) and know how to code cleanly.
The only problem with the logo on the t-shirts is that I get serious Half-Life flashbacks. Then again, that's maybe not such a bad thing.
http://relapse-software.net/haskell_5.png I don't know what's going on here, but I'm 100% behind it.
That was the first thing I thought when I saw those. Maybe they should just license the Half-Life logo or something.
[Be careful with the lambda.](http://www.ep.tc/problems/28/07.html) How about a rainbow instead?
I see a T-shirt—and not much else?
I really liked the slogan "Laziness without side effects"!
Why does it need a logo? Do other languages have logos?
I think it might be a vicious mutant lambda tearing a [Java Duke](http://images.google.com/images?q=java+duke&amp;ie=utf-8&amp;oe=UTF-8&amp;rls=com.ubuntu:en-US:unofficial&amp;client=firefox-a&amp;um=1&amp;sa=N&amp;tab=wi&amp;oi=property_suggestions&amp;resnum=0&amp;ct=property-revision&amp;cd=1) to peices.
of course http://en.wikipedia.org/wiki/Logo_(programming_language) 
If that thing typechecks, it's one hell of a category.
some have suggested that use of a lambda in circle pre-dates the existence of half-life http://haskell.org/pipermail/haskell-cafe/2008-December/051894.html
It already has a logo, http://haskell.org/sitewiki/images/8/86/Haskellwiki_logo_big.png personally, I like this one.
That wouldn't surprise me at all. My copy of Structure and Interpretation... has a lambda in a ovular star-like thing on the cover, and I believe this edition was published in '96. Half-Life came out in '98, I think, so even there it has it. Just saying Half-Life has most commonly associated with the symbol.
Oh, I'm not saying that Half-Life has a claim on it. I just get an urge to watch my back to make sure there aren't any headcrabs lurking around. I mean, every good Haskell programmer should have a crowbar anyhow.
[Of](http://python.org/images/python-logo.gif) [course](http://www.ruby-lang.org/images/logo.gif) [they](http://www.lua.org/images/lua.gif) [do](http://www.protenus.com/Portals/0/java%20logo.png).
[Here's my submission!](http://haskell.org/haskellwiki/Image:Haskell4.png)
AHH! It's the Captcha Monster! I'm human!!! Honest!!! Ahhh, I can't read you! Reload! Reload! Can I hear it verbally? Oh man, maybe I am a bot after all!
[**YEEAAAAHH!!**](http://haskell.org/sitewiki/images/8/85/NarleyYeeaaahh.jpg)
WOOO! NARHWHALS! The Unicorns of the Ocean!
awesome!
Kinda creepy.
for some reason this was hard to find via google. I think it should be more prominent. Very useful lib.
[I love this one](http://media.nokrev.com/junk/haskell-logos/logo1.png)
No.
Many software engineers don't understand the mathematical notation used to describe many of the concepts behind Haskell. Software engineers don't read mathematics papers. They don't even read many computer science papers. They haven't used mathematical notation since school, if then. A simple cheat-sheat with plain english descriptions of each symbol would go a long way in helping the designers of Haskell to communicate with the users of the most common languages like Java and C++. Until these two groups of people communicate efficiently, Haskell and some of it's core ideas, will remain obscure. Does anyone know of something like this that already exists? Otherwise, if I made the list of symbols, would someone want to work with me to create it?
too cluttered
There are cheat sheets already, * http://blog.codeslower.com/2008/10/The-Haskell-Cheatsheet * http://haskell.org/sitewiki/images/b/b2/QuickReference.pdf I'm curious about what exactly you want. A list of varsym functions, and what they mean? i.e. /= == &gt; &gt;= and on to: &gt;&gt;= &gt;&gt; etc?
Problem is that such a guide to grammar won't help. Most "Software Engineers" are so woefully under-trained and ill-prepared to full accept a complete paradigm shift. And such a shift is necessary to truly grok Haskell. Yes, I am inferring that this will terminally cripple wide-spread adoption of Haskell. The lazy programmer follows the path of least resistance, not that of most efficacy. Hence the popularity of Python, Ruby and, *shudder*, PHP.
Haskell has relatively little notation in the language. Most of the notation you see is from libraries, either standard or user defined. Are you asking for a cheatsheet covering all the libraries? It's a bit tricky. Do you define what a typeclass function like "&gt;&gt;=" means in general and risk being too abstract for a useful cheatsheet or do you define what it means for each standard library instance and risk having too much information for a useful cheatsheet. Also, why would such a cheatsheet cover only "mathematical looking" notation? The word "nub" is just as deeply mysterious as "&lt;*&gt;" until you learn it.
In parallel to Linus Torvalds' comment on C++ [[here]](http://lwn.net/Articles/249460/), Quite frankly, even if the choice of Haskell were to do *nothing* but keep the mon-mathematically minded programmers out, that in itself would be a huge reason to use Haskell.
Interesting post. Minor aside: &gt; So I’ve mentioned Haskell, and *eluded* to a scripting language, and of course we also have our shader language. If the author happens to read this, the word you want there is "allude".
I wasn't referring to the notation used in Haskell code. I was referring to the notation *used to describe many of the concepts behind Haskell* e.g. This [A Neighborhood of Infinity post](http://sigfpe.blogspot.com/2008/11/some-thoughts-on-reasoning-and-monads.html) uses a right-facing U. I know that has something to do with sets, but I think I need 2 hands to count the years since I last read about sets. [Monoids? In My Language?](http://www.rubinsteyn.com/monoids.html) is a great example of an article that, while aimed at non-Haskellers, likely needs a text book to decipher for me and many engineers -- definitely the ones I hope to convince to learn Haskell.
See [this reply to sigfpe](http://www.reddit.com/r/haskell/comments/7k3xx/the_single_most_influential_way_to_widen_the_use/c06vl0v) for a clarification.
You are right. They are woefully ill-prepared. However most of that preparation is still out of their reach. They need learning materials, such as the cheat-sheet that I am proposing, to prepare them.
Oh, but that's just straight out math, and doesn't have anything to do with Haskell really. sigfpe's a mathy guy. That stuff isn't in Haskell code, or documentation, or anywhere.
So that's really some specific mathy blog posts (which could describe their notation), not anything part of Haskell. You won't see that stuff in the GHC documentation.
i've been working on a crossword editor in clojure. he's right about the across/down symmetry - there's a lot of code that seems like it should be more general, but right now i have several functions that are duplicated save for which coordinate is being iterated over.
The most useful tutorial on using HXT I found so far.
To widen the use of Haskell my first suggestion is not to read Planet Haskell or blogs contained therein. Seriously. Every one of those blogs is awesome. Don't read them. See, the thing that really makes Haskell wonderful is the fact that it places so few restrictions on what you can do, freeing you up to do anything. The authors on Planet Haskell are, in their own ways, learning what *any*thing really means. Which means in turn that all the blog posts are about implementing cracked out ideas from higher-order mathematics. Are those ideas interesting? Without a doubt. Are they useful? Certainly, if you know how to use them. For the standard software engineer, I'm not sure any of that is helpful though. If you already understand what it means, then using catamorphisms and the like can really clean things up. But if you don't understand what it means, then no cheat sheet about notation and laws is going to help you. The beauty and elegance comes from the ideas that make it work behind the scenes, not from the notation. Once you have the idea, any language will do. It just so happens that Haskell makes it clear and clean to see the forest with the trees. I think it'd be great if more folks understood basic mathematics like set theory and universal algebra. I think it would make them into better programmers. But I also know it's not the easiest thing to sell folks on. Even in programming circles there's this idea that "math is hard". And when you tell people that not only should they learn it, but that they'll have to take initiative to do so, that seems to turn a lot of people off.
I agree. I think I may need to clarify what I am trying to achieve though. The people implementing libraries in Haskell based on ideas from higher order mathematics understand their solution to the problem in mathematics terms. Most software engineers do not understand how to communicate using mathematics terms. Many never learned how and those that did have fallen out of practice. Most of the engineers will never fully understand how the mathematics work. However they need to be able to simply get through the explanation of why it is important. That explanation can only be written by the math guys. Very often the articles describing a Haskell technique or library are trying to convince the reader that, if they use the technique proscribed, certain laws will hold for their code. The engineer will only ever be convinced to write code in a given way if he can understand the benefits obtained. In order to bridge the gap, both the math-wary engineers and the math-savvy Haskellers both need to take a small first step toward each other. Those steps could very easily be the math guys making a cheat-sheet for mathematics symbols and the engineers making a commitment to using it to decipher articles instead of burying their head in the sand, waving the Math-is-Hard flag of surrender. 
This is pretty big looking. How does this compare to Template Haskell exactly?
Ah, I see. For techniques like datastructures and libraries (e.g. [Okasaki's thesis](http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf), [Kiselyov et al.'s LogicT](http://okmij.org/ftp/Computation/monads.html#LogicT), [Coutts et al.'s ByteStrings](http://www.cse.unsw.edu.au/~dons/papers/CSL06.html)) that should be doable. And all of those papers/theses are excellently readable, IMO. I worry that some of the more radical thought experiments like Swierstra's use of [functors as datatypes](http://wadler.blogspot.com/2008/02/data-types-la-carte.html), Sheard's [two-level types](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.8983), Kmett's [category-extras](http://hackage.haskell.org/cgi-bin/hackage-scripts/package/category-extras), or [FRP](http://www.haskell.org/frp/) aren't as amenable. These things are more of a style than a technique, and style is a lot harder to teach--- as any art instructor knows too well. In particular the style is one of having a functional, category-theoretic, or type-theoretic hammer and deciding that programs look like nails. Without the hammer, or at least without knowing the salient parts of the hammer, I'm not sure any of these would look like a good idea. The Haskell community is much more familiar with the academic literature than are average programmers. Often blog posts are ephemeral thoughts that people have after reading papers, or radical thoughts while musing through something on the way to publication. Blogs have knowledge, but it's only a knowledge in context; academic articles are held to higher standards for explaining where someone is coming from. For engineers I think it'd be better to look towards the publications. Ideas like continuation-passing and fusion are firmly in the radical thought experiment realm, but the papers I cited bring them down to earth as a technique instead of a style. You can use those libraries with an understanding that they're awesome, even if you don't quite know why the black magic works. Swierstra, Sheard, and Kmett's work is amazing, but they're the sorts of ideas you use when building something from scratch, so they require changing the way you think about things.
No not really. I was led to understand that Template Haskell had some utility for pattern matching as well. I have no experience with it, nor do I really fully understand what meta-programming is.
Interesting - I didn't end up duplicating functions, so much, but having them accept a Direction parameter. Every cell would then refer to (for example in my previous javascript attempt) {v: cell_below, h: cell_right} Do you have a page about your clojure project, I'd be interested to read about it, and can link.
!!!
Is there anything Haskell's type system can't do?
I just want to know what the HXT stands for?
1280x800 wallpaper form: http://i43.tinypic.com/15ezh4k.png YEEAAAAHH!!
Brilliant - my favourite: unsafePerformDesecrationOfShrineOfReferentialTransparency
Yea, it's the best one IMHO.
So, time to drop pattern matching from Haskell's core? ;)
Will be interesting when they actually do it.
The first road is a kind of roadmap. I prefer it to be separated from a bigger detailed post, as long as the rest of the series doesn't take too much time to be published. (disclosure : I may be somewhere in that story)
&gt; ...we are not going to be using GHC to compile the main binary, because there will not _be_ a main binary. There will just be the Python VM calling Haskell code. Interesting.
unsafeEatBabiesAndPerhapsPerformIO
A turtle?
Looks like a combination of lambda and monadic bind operator. Nice.
I wound up inventing basically this exact same thing when trying to figure out how to build Boquist's GRIN (er.. Meacham's variants thereof) in Haskell monadically, because GRIN actions need to be able to do pattern matching.
Nah, you can generate a template haskell expression for the type, which is in the Q monad, which is an instance of MonadIO. ;)
Can we have this as the subreddit logo? EDIT: On a second thought, though this logo seems far-fetched, I think adopting narwhal as Haskell's mascot would be uber cool.
Haskell XML Toolbox
So it's totally, horribly broken? That's what you're trying to say?
unsafeWageWar unsafeWalkDuck unsafeWalkInto unsafeWhatever unsafeWhatsIt unsafeWhiteBoardMagic unsafeWithName unsafeWoodenStake unsafeWorshipSatan unsafeWouldYouLikeToPlayAGame
Haskell?
I have an intuition that this is a clone of a ruby idiom. If that is the case, would anyone care to share the equivalent ruby code? 
cool! why not provide a flag to generate output as a diff that can be piped to the patch command?
Gordon Freeman would definitely use Haskell.
 darcs-2.1.2\src\Ssh.hs:155:17: Use isPrefixOf, and then remove the (==) test Found: take 1 path == "~" Why not: (1 == length "~") &amp;&amp; ("~" `isPrefixOf` path) I prefer to look at the first. Why is the second better?
Because not all the transformations are safe as-is. For example, the 'turn if-then-else return () -&gt; when $' suggestion assumes you've imported Control.Monad (where 'when' is defined). The 'turn [foo] ++ [bar] -&gt; foo : bar' isn't always type-safe. And so on. You're supposed to make the changes manually since besides not working, a number of people disagree with making definitions more pointless, or using list comprehensions in place of some conditionals (I disagree with the latter).
No, not blogged about it, though I can happily share the source if you like. It's still in a fairly early stage, though usable enough for its basic purpose. I think the difference in our approaches is my basic data structure was `board = (Cell[][], Number[][]) where Cell = Black | Maybe Letter and Number = Maybe Int`. So then I had horizontal and vertical variants for collecting words, numbering squares, advancing the cursor, etc. (Of course, my cursor was a simply `x,y` pair rather than a zipper too). Some functions do take a direction parameter, but they delegate to other functions that are either horizontal or vertical. The really interesting thing is that the first time I wrote this program, back in '94 or so, I did it in QBasic and it took me all of a day. Most of it was that things like drawing to a screen and receiving a basic mouse click in x,y coordinates was trivial - I spent far too long learning Swing in the clojure iteration, and FXRuby in the ruby one.
even if I don't apply all hints blindly -- reviewing them first and then being able to apply a whole bunch of them would be quite helpful.
I came here to ask this same exact thing. Any ideas?
It's not. But maybe it's still leading us in the right direction: all we need is "~" `isPrefixOf` path 
I agree, probably the ugliest thing I've ever seen. Reminds me of the before time when the internet was ugly.
What sebfisch is saying (to the downmodders out there), is suppose he accepts the majority of suggestions by HLint, and only wants to exclude a few. Wouldn't it be easier to apply a large number of changes automatically, than to have to do the editing manually?
Yes, that would be easier, but it is not necessarily a reason to choose that route. One of the reasons to use lint programs at all is to learn to write lint-clean code so that you don't have to make those types of changes often.
There seems to be a conflict between keeping it simple, and keeping it generic. map is a very common function to begin teaching functional programming (and haskell) with, but with the other prelude, you would have to understand typeclasses and functors to understand it. Also, the error messages for functions using typeclasses are more difficult to understand. Maybe the best way to solve this would be to have a basic Prelude, and an AdvancedPrelude, and experienced users import AdvancedPrelude. Beginners then wouldn't have to worry about all the complexities, while other users would get the advantages of having more generic functions.
I'm surprised people don't target C more often through Haskell. The C ABI is the de-facto standard in the open source world -- you'd think we'd see libxmonad and so on.
I'm surprised people don't target C more often through Haskell. The C ABI is the de-facto standard in the open source world -- you'd think we'd see libxmonad and so on.
Because there's always a shorter solution: import Control.Monad import Text.Printf main = do xs &lt;- getNum [] printf "The sum is %d\n" (sum xs) printf "The product is %d\n" (product xs) mapM_ (\n -&gt; printf "%d factorial is %d\n" n (product [1..n])) xs getNum :: [Int] -&gt; IO [Int] getNum xs = do putStrLn "Give me a number (or 0 to stop):" n &lt;- readLn if n == 0 then return xs else getNum (xs ++ [n])
There aren't that many. I have 3 haskell books, they seem ok, but the stuff online is what you really need.
Could you elaborate a bit on the online material? The best one I've found so far is the [Write Yourself A Scheme in 48 Hours](http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours) one, but I'm not sure where to go next.
I've found [Haskell: The Craft of Functional Programming](http://www.amazon.com/Haskell-Functional-Programming-International-Computer/dp/0201342758/ref=pd_bbs_sr_1?ie=UTF8&amp;s=books&amp;qid=1229899180&amp;sr=8-1) to be great. RWH is naturally better for real-world examples though. That would be CoFP's main downfall.
"take 1" would assume its argument to have more than one elements. if "path == null", then your code would produce a run-time error. Not the case with "isPrefixOf".
Could you elaborate on what you didn't like about RWH? The full book list is [here](http://haskell.org/haskellwiki/Books_and_tutorials#Books).
Well, I found the "real world" stuff to be distracting—I mostly just want to learn the language. I don't want to have to truck through hundreds of "real world" examples to learn a few concepts! It's a fine book, just not the type I'm looking for right now. Anyway, I was a bit overwhelmed by the book list. I was hoping reddit would highlight one or two for me.
Ah! So you want an intro book. "Programming in Haskell" or CoFP are intro books about the language only.
Thanks, I'll take a look!
One thing with Haskell though is some concepts are so abstract it often helps to have concrete examples as to when they are useful. I am finding real world Haskell is (mostly) good at presenting this. It also gives how some code would be written with and without the concept being examined, which is very useful. More theoretical resources seem to instead only gives examples using the concept, and used very simple examples purpose built for demonstrating it. With that, I was often left thinking "so what?", as the advantage of using the given concept was never demonstrated. For example, in the IO chapter (I think), it had a section on writing predicate and info functions, wrapped in a type Info a. Even though the section didn't introduce any new language concepts, it taught a very practical technique for creating a mini query language, which I later found very useful in another program I was writing. In a way, you need the "real world" stuff to understand when the theoretical concepts are useful. 
It depends in part on why you didn't like RWH but [Bird](http://www.amazon.com/Introduction-Functional-Programming-using-Haskell/dp/0134843460) is a classic. It introduces lots of important ideas such as deriving programs from algebraic properties of functions. Read [The Haskell Road](http://homepages.cwi.nl/~jve/HR/) too.
&gt; pair p q = \v -&gt; p (fst v) # q (snd v) Where do fst and snd come from, if no pattern matching facilities exist beforehand? Furthermore, how would pattern matching be implemented for arbitrary algebraic data types?
I can recommend Programming in Haskell as well. Worth the purchase.
Your version is quadratic time (the xs ++ [n]). Here's a shorter version using the laziness of IO. Note that we read all the input at the very beginning: main = do s &lt;- getContents let xs = takeWhile (/= 0) $ map read $ lines s sequence_ [putStrLn "Give me a number (or 0 to stop):" | n &lt;- 0:xs] putStrLn $ "The sum is " ++ (show $ sum xs) putStrLn $ "The product is " ++ (show $ product xs) sequence_ [putStrLn $ (show n) ++ " factorial is " ++ (show $ product [1..n]) | n &lt;- xs] 
That makes sense. But why does the second have the `(1 == length "~")`?
May 2008 is new? edit: well, the title used to say new...
I learnt Haskell from my lecturer's slides and worksheets, combined with my previous experience with Lisp (ie: no books because I was taught). Now I know Haskell, I don't really understand why people recommend RWH as a first book for newcomers to fp, or even just newcomers to Haskell. Bird is a far better explanation of theory - theory that isn't really covered in much detail in RWH - for example fold is only a short section and then a question which requires understanding of the property of universality (which is referenced, but omitted, IIRC). Additionally, RWH introduces things in a way I dislike on a didactic level for beginners - subjects are transposed in the name of getting to the practical stuff quicker (the number of times concepts are introduced and then the reader is told to wait for an explanation in subsequent chapters...). Nothing wrong with any of these, so long as the reader understands the basics already.
To make them semantically closer
Perhaps the tool did not evaluate the string literal "~", which in this example would make the the first part (before "&amp;&amp;") of the suggested expression redundant. I take that "remove the (==) test" means the first part may be abandoned safely.
Wow, this is really great. I just converted my HTTP-using library [hS3](http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hS3) to the new version, and the performance is incredible. CPU usage is dramatically lower (from 15% to &lt;1%), and memory usage is nice and constant, instead of the exponential blowups that happened before. 
Yes, Bird is a wonderful book. I especially liked the fact that he proves all algebraic properties also for bottom; and the maximal subsegment sum example is simply a gem.
The best book to start on Haskell, I think, is http://www.haskell.org/soe/
I've seen people who dislike RWH enjoy http://learnyouahaskell.com/ -- perhaps give that a shot. And I suggest that rather sooner than later ditch the textbooks and start hacking! *edit:* ok, don't ditch the books, but still: hack!
Like I said, there's always a shorter version (though yours has the minor disadvantage that you can't call main twice in a ghci session) :) Good point about the quadratic time. Another solution would be to use (n:xs) and reverse the list before applying mapM_, making it O(n) (I think). I wish there was a big O analyzer for Haskell programs.
It only went up recently, and yes, it is new. Had you read it?
OP submitted in two different subreddits.
Here's some quick hints I've come up with; hint "Use null" = length x == 0 ==&gt; null x hint "Use null" = length x /= 0 ==&gt; not (null x) hint "Use unzip" = fmap snd x ==&gt; snd (unzip x) hint "Use unzip" = fmap fst x ==&gt; fst (unzip x) -- SIMPLE hint "don't use id" = id x ==&gt; x hint "use id" = (\x -&gt; x) ==&gt; id hint "use snd" = (\(_,y) -&gt; y) ==&gt; snd hint "use fst" = (\(x,_) -&gt; x) ==&gt; fst hint "use curry" = (\x y-&gt; f(x,y)) ==&gt; curry f hint "use uncurry" = (\(x,y) -&gt; f x y) ==&gt; uncurry f -- Arrows hint "use (***)" = (\(x,y) -&gt; (f x,g y)) ==&gt; (f *** g) hint "use second" = (\(x,y) -&gt; (x,g y)) ==&gt; second g hint "use first" = (\(x,y) -&gt; (f x,y)) ==&gt; first f hint "use second" = id *** g ==&gt; second g hint "use first" = f *** id ==&gt; first f hint "use (&amp;&amp;&amp;)" = (f x, g x) ==&gt; (f &amp;&amp;&amp; g) x hint "use (&amp;&amp;&amp;)" = (\x -&gt; (f x, g x)) ==&gt; (f &amp;&amp;&amp; g) -- Generalization hint "map -&gt; fmap" = map ==&gt; fmap hint "concat -&gt; join" = concat ==&gt; join -- Not just Maybe hint = Nothing ==&gt; mzero hint = Just x ==&gt; return x -- Monadify! hint "Use monads" = (if b then [x] else []) ==&gt; (if b then return x else mzero) hint "Use monads" = [] ==&gt; mzero hint "Use monads" = x ++ y ==&gt; (x `mplus` y) hint "Use monads" = (++) ==&gt; mplus 
&gt; I suggest that rather sooner than later ditch the textbooks and start hacking! I disagree. Theoretical understanding plays a particularly important part in using and understanding Haskell. It's one of the things a lot of people like about it. IMHO, you should **not** stop at an O'Reilly book. Read you a TAPL for great good!
WOW!
&gt;The LLVM bindings has two layers. You can either use the low level bindings that is just the same as the C bindings for the LLVM. This level is quite unsafe as there is very little type checking. The recommended way is a high level binding (somewhat less complete) which eliminates many errors by leveraging the Haskell type system. So... it doesn't really work? Or am I missing something?
To install it, I used cabal install --configure-option --with-llvm-prefix=$LLVM_DIR/Release llvm And remember to do a `cabal update` before.
Seems though that to write transformation passes you still need C++. But to fix that, we'll have to improve LLVM's C bindings first.
What do you mean by "it doesn't really work"? It's true that the types of the high level interface do not make guard against every possible mistake, so in that sense it doesn't really work. For instance, the types do not check that every basic block ends with a terminating instruction, or that the inputs to a phi node actually have control flow to it. That said, the Haskell bindings offer more type safety than any other bindings I've seen. 
There are other things missing from the C interface as well, like a complete set of passes that can be added to the pass manager.
Oh ok. "Unsafe" and "many errors" were in reference to my own mistakes, not the machine's.
haskell-mode for emacs does this &gt;&gt; http://mult.ifario.us/p/emacs-haskell-mode-unicode-cuteness
Vim has no trouble displaying λ; I assume you want it so that when you write (\x -&gt; x * x), vim automatically changes it to (λx → x * x)? Should the contents of the file change too? It would be easy to set up a keyboard shortcut for both symbols, more difficult but not impossible to have them automatically inserted.
Prettify the display, not the source code. The original file should be in full ASCII/ANSI.
The only problem with this in emacs and, I presume, anywhere else, is that it can muck up indentation which can of course have serious consequences. 
&gt; is that it can muck up indentation which can of course have serious consequences. Yes. Once I tried this, the indentation got fucked up and one thing lead to another. To cut a long story short, both my cats are now dead as a result.
Can you elaborate on that?
That's more likely to have been your use of unsafeInterleaveIOWithMurderOfPets.
Indentation might be wrong if someone opens the same file in a different editor and in the worst case it might not compile. 
I've just found [Leksah](http://leksah.org/) (they call this feature "source candy"), but it seems like it's not ready for prime time yet a.k.a. in beta state.
Well, when generating machine code you have many opportunities to make mistakes. That's the point. ;)
A blog post by one of the authors, with more info: http://www.serpentine.com/blog/2008/01/03/llvm-bindings-for-haskell/
&gt; a complete set of passes that can be added to the pass manager This doesn't seem to be very hard to add; I'll write a patch soon. BTW, thanks again for the great library!
It talks about the old version. To learn why this new release is so exciting, see [these slides](http://qconsf.com/sf2008/file?path=/qcon-sanfran-2008/slides//LennartAugustsson_strongly_typed.pdf).
Woah, that is cool. How often does this interfere with layout, and how so? Issues with the mandatory whitespace rules, or just problems with auto-indenting? edit: Ah, I you explain the issues below.
Wow! Good find! I'm not usually one for IDEs, but that looks really really nice. [edit] looks like it's a bit abandoned.. i got it to build after fixing one syntax error, but it doesn't actually work. Still, there's lots of good stuff in the code! I might use it as a base for a text editor. All the unfun code I don't really feel like writing haha.
Just set up a Compose key binding '-&gt;' to →, and (whatever you like, I like 'gl'; greek l) to λ? 
Example (`cp /usr/share/X11/locale/en_US.UTF-8/Compose ~/.XCompose; echo "export GTK_IM_MODULE=xim" &gt;&gt; ~/.Xsession; # then add this to top of ~/.XCompose`) # porges additions &lt;Multi_key&gt; &lt;less&gt; &lt;minus&gt; : "←" U2190 # left arrow &lt;Multi_key&gt; &lt;minus&gt; &lt;greater&gt; : "→" U2192 # right arrow #these are done so as not to clash with &lt;= and &gt;= &lt;Multi_key&gt; &lt;equal&gt; &lt;less&gt; : "⇐" U21D0 # left double arrow &lt;Multi_key&gt; &lt;equal&gt; &lt;greater&gt; : "⇒" U21D2 # right double arrow &lt;Multi_key&gt; &lt;g&gt; &lt;a&gt; : "α" U03b1 # alpha &lt;Multi_key&gt; &lt;g&gt; &lt;b&gt; : "β" U03b2 # beta &lt;Multi_key&gt; &lt;g&gt; &lt;g&gt; : "γ" U03b3 # gamma &lt;Multi_key&gt; &lt;g&gt; &lt;d&gt; : "δ" U03b4 # delta &lt;Multi_key&gt; &lt;g&gt; &lt;e&gt; &lt;p&gt; : "ε" U03b5 # epsilon &lt;Multi_key&gt; &lt;g&gt; &lt;z&gt; : "ζ" U03b6 # zeta &lt;Multi_key&gt; &lt;g&gt; &lt;e&gt; &lt;t&gt; : "η" U03b7 # eta &lt;Multi_key&gt; &lt;g&gt; &lt;t&gt; &lt;h&gt; : "θ" U03b8 # theta &lt;Multi_key&gt; &lt;g&gt; &lt;i&gt; : "ι" U03b9 # iota &lt;Multi_key&gt; &lt;g&gt; &lt;k&gt; : "κ" U03ba # koppa &lt;Multi_key&gt; &lt;g&gt; &lt;l&gt; : "λ" U03bb # lambda &lt;Multi_key&gt; &lt;g&gt; &lt;m&gt; : "μ" U03bb # mu &lt;Multi_key&gt; &lt;g&gt; &lt;n&gt; : "ν" U03bc # nu &lt;Multi_key&gt; &lt;g&gt; &lt;x&gt; : "ξ" U03bd # xi &lt;Multi_key&gt; &lt;g&gt; &lt;o&gt; &lt;i&gt; : "ο" U03be # omicron &lt;Multi_key&gt; &lt;g&gt; &lt;p&gt; &lt;i&gt; : "π" U03c0 # pi &lt;Multi_key&gt; &lt;g&gt; &lt;r&gt; : "ρ" U03c1 # rho &lt;Multi_key&gt; &lt;g&gt; &lt;s&gt; : "σ" U03c2 # sigma &lt;Multi_key&gt; &lt;g&gt; &lt;t&gt; &lt;a&gt; : "τ" U03c3 # tau &lt;Multi_key&gt; &lt;g&gt; &lt;u&gt; : "υ" U03c4 # upsilon &lt;Multi_key&gt; &lt;g&gt; &lt;p&gt; &lt;h&gt; : "φ" U03c5 # phi &lt;Multi_key&gt; &lt;g&gt; &lt;c&gt; : "χ" U03c6 # chi &lt;Multi_key&gt; &lt;g&gt; &lt;p&gt; &lt;s&gt; : "ψ" U03c7 # psi &lt;Multi_key&gt; &lt;g&gt; &lt;o&gt; &lt;m&gt; : "ω" U03c8 # omega 
In Emacs, anyway, the prettifying is of the display, not the source. So the issue with indentation is that you might be visually off one or two spaces (since all the three characters like the monad functions get turned into two-character items); it's really not much of an issue. You add a space, C-c C-l; or maybe you trust the auto-indent. (The auto-indenter is more reliable in Yi, but it doesn't have prettifying yet. Be a good little project for someone to do over the vacation.)
I should note that: &gt; (09:53:29) Saizan: there's [no] lambda symbol that currently works So you're stuck with \ :)
Yup. In retrospect I should've linked a get.hs using HTTP 3000 or lower, so I could provide a comparison with the old HTTP as well. I just sort of assumed everyone on the darcs list knew how slow the old HTTP was. :)
Yup. In retrospect I should've linked a get.hs using HTTP 3000 or lower, so I could provide a comparison with the old HTTP as well. I just sort of assumed everyone on the darcs list knew how slow the old HTTP was. :)
Some quick numbers I just ran, uploading a 1MB file to Amazon S3. Numbers below are user time. HTTP-3000 (String): 35.859s HTTP-4000 (LazyByteString): 0.072s 
Simpler: Open Gnome keyboard settings and add Greek as a secondary layout. Then enable "hold Alt Gr for secondary layout" and "scroll lock light shows secondary layout". Then you get: Press s: s appears Hold AltGr: scroll lock lights Press s: s (on Greek keyboard) appears Press shift-s: capital s (on Greek keyboard) appears Release AltGR: scroll lock light turns off
&gt; One thing with Haskell though is some concepts are so abstract it often helps to have concrete examples as to when they are useful. That's what works for me. I haven't been too crazy for the Haskel book s I've looked through or tried to read. RWH is appealing because I really need to have even basic running code that I can hack on, enough of a practical understanding to start writing simple apps I can use. Write Yourself A Scheme in 48 Hours is good for that, too. For the more theoretical, I'm liking Introduction to Functional Programming Systems Using Haskell. ISBN-10: 0521277248.
It doesn't have exact lexical information, so the output is pretty printed freshly, so won't necessarily match.
The first could be fixed, the second is a bug.
You are meant to manually look at it and rewrite it to "~" `isPrefixOf` path, having eliminated the 1 == length "~". The tool will do this automatically at some point in the future http://code.google.com/p/ndmitchell/issues/detail?id=109
I just submitted the second part.
Just tried xmonad and its very easy. I was surprised how quickly I learned the commands...... 
TAPL == http://www.cis.upenn.edu/~bcpierce/tapl/ ?
IMOH, This is the kind of things that will help move python code bases to haskell. In many case, rebuilding from scratch is out of the question. Gradually replacing python module by haskell lib looks like a much more safe solution.
This isn't a replacement for the built in pattern matching. It is a way of extending the built in patterns and manipulating them programmatically.
Great interview! As always, Don, John, and Bryan present Haskell and their work in a great manner! Kudos to them!
It takes too long to compile ghc from source, or it takes too long to compile other programs using ghc?
to compile ghc from source...i'm just awfully impatient
The article is confusing, but comments 5 and 6 clarify. All the use of showString is doing is changing an (inefficient) left fold into an (efficient) right fold.
No, it takes precisely as long as it should. Now, none of this 'upvote if' crap in /r/haskell, please!
The link is outdated. http://hackage.haskell.org/cgi-bin/hackage-scripts/package/wxcore-0.10.7 is even more recent and new.
I think something more constructive would be ... more constructive.
great !
The Emacs wiki has a page that discusses a bunch of different ways to do this: http://www.emacswiki.org/cgi-bin/wiki/PrettyLambda I have a file called pretty-symbols.el that does it decently, but I can't seem to find where I got it.
that link doesn't work. s/hwm/hwn/
**WHY?**
I don't get why they chose Gtk2hs instead of wxHaskell. That makes it pretty unusable on OS X or Windows (non-native look and feel, and setting up Gtk2hs on OS X is a pain in the ass). Eclipse with Haskell plugin is fine but somewhat heavyweight. The search for a Haskell IDE goes on..
Why not ?
I'm always puzzled over whether this connection is profound or trivial. It seems to be some kind of Yoneda Lemma. The problem is that the m in Cont m a = forall b. (a -&gt; m b) -&gt; m b is required to already be a monad, the continuation does not magically monadify it. The construction is similar to the continuation passing style a = forall b. (a -&gt; b) -&gt; b Should we say that CPS is the mother of all lambda-calculi? 
Is this considered linkjacking? I don't think the blogger offers much information beyond what's on Conrad Parker's [page](http://haskell.org/haskellwiki/User:ConradParker/InstantInsanity). edit: Ha, only now I notice "My name is Conrad Parker, and I live in Kyoto, Japan" and "I wrote an introductory tutorial...". The dangers of skimming...
neat... handy programmatic interfaces to twitter, i'll have to start up my evil genius idea device-- I have... *plans* for you...
From the example, it looks like setTwitterUser sets global variables. Yuck.
The link actually is to Conrad Parker's blog page.
kfish == conrad parker.
Well, that's an egg on my face. (I love that idiom)
Yes.
The problem with cabal install is that you have to install the world to install it.
Good job translating these to Haskell. However, it should be noted that these are really exercises in functional programming basics, not specific to Haskell. Namely they are exercises in using the Peano numerals and the list ADT.
What are you talking about? Assuming you have the compiler installed, which I don't think is unreasonable, the only additional libraries needed are HTML and zlib (1). If this is still too much work then install a binary copy and forget building it from scratch. (1) See the [cabal-install Hackage entry](http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install)
source is available, so feel free to improve :-)
Uh huh, and then HTTP wants network and parsec, and parsec wants mtl..
And what installation of GHC have you found that doesn't already include those libraries?
if you don't mind, i'd appreciate knowing why it's confusing; always like to improve my ability to explain. you're right tho, that is really all it's doing;; something i didn't really understand when i wrote the article.
Those are core libraries, your distro is broken if it doesn't ship with parsec and mtl packages. More importantly, request that your distro support cabal-install natively, as many distros now do. That's the best way to improve things for everyone.
In Debian/Ubuntu Parsec and MTL are not installed by default when the package ghc6 is installed. They are, however, available separately (the package names are libghc6-mtl-dev, libghc6-parsec-dev). I had some problems with one of my class assignments because of that - the university systems had GHC installed, but not the additional libraries.
I don't tweet.
Speed. I believe one person reported space-time improvements on the order of 30x. (This is not so much a tribute to ByteString's speed - I benchmarked it at slightly slower than curl and wget - as an example of why String can be very bad for performance.)
I recursively wgeted the book from their website (I didn't see a PDF version) for offline reading. I read a few chapters and bought the book yesterday. Great that this book is under creative commons license. Great that I can view it online and read it anytime. But nothing beats holding it in your hands and curling up on the couch to read it. Its worth being free and its worth being bought. Buy this book to show publishers that they have nothing to fear giving the book away online. There is still value in the physical form and there are people who will buy the book (like me).
You type commands in ghci, and then I tweet in my pants.
&gt; [Below is a detailed account of how we arrived at the policy that as many books as possible should be made available online and offline—and why we think it would be a good idea for all publishers to do the same.](http://mises.org/story/1473)
Eww...mail wrapped in a &lt;PRE&gt; tag without linebreaks...
DANG nice!
http://article.gmane.org/gmane.comp.lang.haskell.cafe/49646
There are several Haskell multicore extensions right? I guess when they grow up and are added to GHC Haskell will work fine. 
Which ones are you thinking of? Almost everything is actually in GHC now.
I have wanted something like this badly for a while now. Thanks to Sigbjorn!
I find this very helpful, and laziness trickier than it first appears.
How about http://netsuperbrain.com/blog/posts/introducing-reactive-events/ ?
Thanks for the suggestion, although I think you'll find I actually submitted that on reddit. :)
very cool. I'm wondering if there could be some tie in with ripplepay.com project. There has been a lot of chatter in the user group about finding some game that needs a distributed currency... hm.
Interesting and looks somewhat unsettling. However, the writing is awkward in places and seems to follow the maddening academic tradition of leaving the overall implications as an 'exercise for the reader'. Would someone who has a deep understanding of this please spill the beans on how big of a deal this really is!
I'm not an expert but I'll take a stab at it. I recommend getting a good understanding of how Haskell does [lazy evaluation](http://en.wikibooks.org/wiki/Haskell/Laziness#Thunks_and_Weak_head_normal_form). Consider: * **y = f x** * **x** is undefined. * if we never actually use **y**, it doesn't matter that **x** is undefined. * if we unnecessaryily force the computation of **y**, then we exclude the possibility of **x** being undefined. We've unnecessarily restricted the possible values of **x**. This can have real effects on programs. Consider: * A lazy version of **take** can work with infinite lists. * A strict version of **take** can't work with infinite lists. * A lazy version of **take** can work with a list that has undefined elements. * A strict version of **take** can't work with a list that has undefined elements. Strict evaluation can require a lot of extra memory and computation. Consider: * A list of 1,000 independent elements that are calculated as needed. * Each element takes 1 MB of RAM. * Each element takes 1 minute to calculate. * Not all elements will be needed. Strict evaluation will require 1 GB of RAM and 16 hours to calculate, even if only the head of the list is used. ---- Section 2.1 covers common issues that have a big impact. The upshot is that it's not really possible to pass around error codes using Either or Maybe and be lazy. Asynchronous exceptions sould like a good match for lazy evaluation because you don't really know when a thunk will be evaluated and an exception will be generated. *I'm not familiar with patterns of usage for async exceptions, so take this with a grain of salt.* Sections 2.2 deals with more subtle issues. 2.2.2 is a good example of why it's good to understand these issues. However, they are less commonly important; they will be mostly about polish. Until they aren't and the world becomes rage. Section 2.3 deals with hinting to the compiler, telling it that certain properties can be guaranteed and, as a result, that laziness is allowed. The example here shows an infinite list being split into several infinite lists. The *why* is a little out of my league, though.
Had this one sitting around for awhile, so it might be dusty. Suggestions are welcome.
I'd love some ideas for what to do with this. Clearly it helps mitigate risk and lowers the barrier to using Haskell in an existing Erlang environment. What's the killer use case?
Well, say if you want to write a scalable, fault tolerant web services application. You can implement the web facing, connection holding, front end grunt work to Erlang and OTP. Erlang is pretty good at that sort of thing. You can implement the complex backend work in haskell. With this package, the erlang nodes will be able to communicate with haskell nodes pretty seamlessly. Best of both worlds. 
Stuff where Erlang is slow but Haskell as a compiled language is fast, e.g. a 3D frontend for an Erlang MMOG?
*Twitch* So awesome, I think I might die.
Hmm, I've always wanted to write a Haskell-y MMO, but I've never really wanted to write all that networking stuff. Maybe this means I'll have an excuse to both learn erlang, write the mmo, and do the networking stuff in erlang, which I hear is a breeze.
If you already know Haskell learning Erlang shouldn't be too hard, the documentation on erlang.org (also included in the download package I believe though the webpage might have some more than that) is very good, detailed and updated regularly. I think it is sad that there are no good non-C++ 3D game engines out there and even most of the C++ ones don't have usable network support. Erlang would be an ideal match for the message passing required in any MMO game and the distributed servers you need if you want to support lots of players. However it would probably be a bit slow for a few of the key tasks in such a game like rendering on the client side and maybe physics on the server side (depending on how complicated you want to make them).
The real ticket, to be completely honest, is to find a set of people who are interested in making a game- and getting involved with them. I'm _incredibly_ interested in designing a good gaming library (in spite of my nonextant experience coding any sort of game at all). I mean- I suppose I'd really like something that is simply designed to handle all the nasty boring parts (for me anyway- like graphics munging and whatever) and comes with a set of prebuilt models/art/whatever, but allows me extensive control of just about everything. Perhaps I describe ulibraria, but I have some very grandiose ideas I've always wanted to try, but have simply lacked the expertise and coderpower to implement. 
Well, for the graphics parts have a look at Ogre3D, it is pretty well-documented,... The only real problem is how to integrate their C++ code with any language you would want to program in...
I build turbinado with cabal-install, and then use cabal2arch to roll a native package. Since all of turbinado's deps are already packaged for Arch Linux, users don't need to worry about resolving deps. So let's make **2009: the year distros start supporting the platform** I'm surprised neither cabal-install, nor the Haskell Platform effort are mentioned here. Both seem relevant (and the solution to a) dependency hell, and b) stability).
I think that in the case of haskell, it's too radical and changes too quickly for platforms to truly support it.
People want the new version of a library to be made standard and complain about dependencies changing too fast. Haskell is having a lot of valuable improvements made quickly, which is the sign of an immature platform. ---- I'd like to see a lot of these tools and projects integrate with other programs more smoothly. Using XML and [property lists](http://en.wikipedia.org/wiki/Property_list) would be a big help, particularly for command-line applications (e.g., darcs).
Couldn't agree more. I don't really care whether hackage or the [Haskell Platform](http://www.haskell.org/haskellwiki/Haskell_Platform) project achieves this goal, as long as it takes the pain out of installing libraries.
In the case of GHC 6.10.1's release, there was a high amount of success in keeping old code compatible - even through the base API changes, cabal install can now for the most part do the Right Thing. There was a rigorous amount of library (i.e. hackage) testing with the release candidates and betas, and GHC itself had 0 unexpected test failures at the time of release (i.e. so all known bugs are in the bug tracker.) IME however, this has not been the case in the past on a few occasions (ghc 6.8's release seemed to cause a lot more difficulties looking back on it) - but the tools now are robust enough to encourage active development I think, and I love it (I've had little trouble with ghc 6.10 and using old code, fwiw.)
How is GHC + libs any different to say, Python? 
What's wrong with: $ cabal install turbinado 
Bootstrapping cabal-install is grueling from the point of view of someone who just wants to try "another Rails clone." Get Apple and some major Linux distros to include it by default, and then we'll talk. 
Nothing, assuming cabal install works. However, this is not always the case, especially when working on windows. First annoyance: As mentioned by the author, cabal-install is not part of GHC by default, requiring you to manually build zlib, HTTP and cabal-install. And don't forget to not get the latest HTTP package, since cabal-install doesn't work with 4.x. Second annoyance: packages that assume you're working on linux (using sh or perl to execute commands) or even worse, refuse to build on windows because they require linux (lambdabot). Third annoyance: packages that require a C compiler. For instance, [this](http://netsuperbrain.com/blog/posts/freeglut-windows-hopengl-hglut/) is how you're supposed to install the OpenGL package on windows. As long as that page cannot be replaced with "cabal install GLUT" there is still work to be done.
Windows doesn't have a decent package system. I'm not sure what we can do about that. On other systems, you just get cabal-install, the binary, and off you go, or use native packages for everything. Windows users need to decide how to tackle this.
Major linux distros already do... Do you have any suggestions for how to get Apple to include it?
*Hey, haskell reddit downmodder .. why the downmod? This is the Haskell reddit...*
Does this mean that length of module names will no longer affect performance?
It's purely functional where weakly functional languages have never been supported.
Why can't distros support functional languages? I don't understand: Arch Linux supports Haskell very well (700 libraries packaged)...
Yes.
Oh, I was thinking supported in the sense that OSX ships with haskell.... In the 'distro' case, your prediction might very well be correct. :)
Get them to include GHC first. Naturally the main problems are with GHC, not cabal-install: * The compiler toolchain on OS X (confusingly called Xcode, even though that's really just the name of the IDE) is considered to be a separate package from the OS itself, and is installed and updated separately. * The Xcode maintainers refuse to support languages that don't actually see active use on OS X. For example, even though GCC has Ada and Fortran front-ends, these are disabled in Apple's branch. * Cabal-install builds from source, so it *requires* GHC to be present. Java *is* supported--poorly--only because it's so damn ubiquitous. The other languages with support on OS X are all interpreted, and about half of them have nice, neat interfaces with the Aqua GUI layer, so that they can be used to develop Mac apps. Haskell sort of has this, in the form of HOC, but that's not even remotely stable enough for Apple to look at. This is a hard problem. There are a lot of roadblocks here. It'll be up to the community to improve Haskell support for OS X before Apple would ever consider improving OS X support for Haskell.
there's always one (or eight, as the case may be)
concurrency across computers
So far only the native Sparc backend has been mentioned. Is hardware transactional memory supposed to be part of this work? I guess both would be a bit hard in three months. Also, measuring progress could be hard - there aren't that many (any?) Haskell benchmarks that are parallel and involve latency to main memory as mentioned in the opensparc announcement. Any thoughts on this? 
How many idlers?
Despite( or due to?) the simplicity, anyone with s background in theoretical mathematics can use these exercises to teach themselves some crucial exercises in Haskell. This is a great starting point after the C Programmer's guide to Haskell or any other introductory tutorial.
For the sake of accurate statistics: where's the ##java channel? It's currently about the same size as ##javascript, but it's not on the list.
&gt; all those billions and billions of lines of code written in Java, C, C++, &gt; C#, Fortran, Ruby, Python, Perl, etc. are basically garbage at this point. &gt; Some small fraction of them might be saved, but the vast majority ... &gt; will simply have to be junked and rewritten. If true, this will mean that people who know Java/C/C++/... **and** Haskell/Scala/... will be in great demand. 
please don't get too fanboi :) _/me looks at #python ¬¬_
Yes that's about field selectors, as in: data Teller = Teller { salary :: Float } However there is now overloading for field selectors, so it won't help in your case. In fact this GHC change does not change the language, just the way it is compiled.
I think the plan is to port the spec benchmarks for parallelism.
hahaha haskell sux wuts written in it?
BTW it's just 'egg on my face', never 'an egg'.
SWEET! I hope this gets lots of support and becomes one of the foremost open source games. Wouldn't it make things easier (in the long term) to have the Unit as a type class that includes various attributes (such as the hit points, which are hard coded elsewhere)? When I have time I'll have to play around with this - perhaps it will be a hackage-supported project by then!
Is that to be read American style as 5 January (2009-01-05), or European style as 1 May (2009-05-01)? Hehe, can't resist promoting the international date and time standard, [ISO 8601](http://en.wikipedia.org/wiki/ISO_8601), definitely a must in any international communication :-P
As I understand import cycles is a problem specific to GHC. AFAIK Haskell allows cyclic module dependencies.
&gt; We'll be kicking off the first installment of the Real World Haskell Book Club with a joint venture with the Northern Virginia Language Group (NoVALang) on January 5th, 2009 from 20:00 until whenever Eastern Standard Time (GMT 0100 hours).
Having a Unit typeclass might wind up being a good idea, though there are some foreseeable complications this might bring up. For instance, right now the units are maintained in a list ([Unit]). If Unit is a typeclass, we'd need to use a heterogeneous list, ala http://en.wikibooks.org/wiki/Haskell/Fun_with_Types#Example:_heterogeneous_lists The trouble is that, as far as I know, this will cause us to lose some type information. For instance, when iterating over the list, we won't know what type of unit we're iterating over. Since units often need to interact with one another, and since the nature of these interactions might rely on the types involved, we could be in trouble. And yes, it'll be on hackage by the end of the week -intoverflow
This lengthy post is the final part in the serie ([Part1](http://gamr7.com/blog/?p=24), [Part2](http://gamr7.com/blog/?p=65)). 
People disagree on programming style. News at 11.
Hmm... sum' 2 n = foldl (\a e -&gt; let v = a+e in v `seq` v) 0 [1..n] I thought expressions like x `seq` x were identical to `x`? So in this case, `sum' 1` and `sum' 2` are the same.
Yes, you're right. I'm not sure what point the author was attempting to make there.
&gt; I thought expressions like &gt; &gt; x `seq` x &gt; &gt; were identical to x Except for the x `seq` bit forcing the evaluation of x. It's a way of avoiding laziness. Edit: markdown.
No, `seq x x` is always equivalent to `x`. When the expression `seq x x` is evaluated, the value of `x` is evaluated, then `x` is returned. Similarly: when the expression `x` is evaluated, the value of `x` is evaluated, then `x` is returned.
I still don't understand how seq works and why it ensures the first argument is evaluated. It's such a simple function, but I don't get it. Can anyone explain that for me?
`seq` is built into the run time, you can't write `seq` in Haskell. Here's the definition from the '98 Prelude: seq :: a -&gt; b -&gt; b seq = ... -- Primitive :)
The GHC documentation it has it defined as: seq :: a -&gt; b -&gt; b seq _ y = y So you're saying the above code if I defined it myself would not be able to do what seq does?
Is Haskell good enough to handle high end graphics?
This thread is from 2006. It raises some interesting points. Does anyone have any additional information?
&gt; The GHC documentation it has it defined as: Note that this definition is surrounded by `#ifdef __HADDOCK__`, meaning it is only present when building documentation. The real `seq` is a primitive that doesn't have a Haskell source definition in the standard libraries. &gt; So you're saying the above code if I defined it myself would not be able to do what seq does? Yes, this definition is not `seq`, and it is in fact impossible to write `seq` in Haskell.
Semantically, `seq` is: seq _|_ x = x seq _ x = x In English: `seq x y` is undefined if `x` is undefined, otherwise it is `y`. The only way for a Haskell compiler to determine that the first argument to `seq` is not undefined is to evaluate it.
Yes. The evidence depends on what you call high-end graphics: there is a Quake clone called Frag in Haskell, using HOpenGL bindings for OpenGL; there are raytracers written in Haskell.
And the student was enlightened...
I'm kind of newbie when it comes to the whole scene, and I actually came very close to being a computer programmer, but I realized that I'd be programming cash registers all the time. I, like many others, wanted to program video games, and I'm looking for an easy to learn language to do just that; I have a limited knowledge of Turbo Pascal. What application is Haskell mainly used for?
Ah, ok. Let's use type Cont r a = (a -&gt; r) -&gt; r type ContM m a = forall b . (a -&gt; m b) -&gt; m b = forall b. Cont (m b) a Then, the key functions from your post have the type i :: Monad m =&gt; forall b. m a -&gt; Cont (m b) a run :: Monad m =&gt; Cont (m a) a -&gt; m a The type of `run` can be generalized to run :: Monad m =&gt; (forall b. Cont (m b) a) -&gt; m a and we can write i :: Monad m =&gt; m a -&gt; ContM m a run :: Monad m =&gt; ContM m a -&gt; m a Basically, the embedding into the continuation monad does nothing more than replace a monadic action `x` by its continuation `(x &gt;&gt;=)`. What bugs me about this is that the `&gt;&gt;=` comes from the monad of `x`, not from `Cont(M)`. Which means that `Cont` is just an "empty shell", as "empty" as CPS style.
Haskell is used for all sorts of applications. It's a general-purpose language.
Doaitse Swierstra made a similar comment recently: http://thread.gmane.org/gmane.comp.lang.haskell.libraries/10206
Ive had a similar problem with the gmap library: http://hackage.haskell.org/packages/archive/gmap/0.1/doc/html/Data-GMap.html I've ended up putting almost everything into the class so specific maps can override it. It works but it feels wrong somehow and I dont think its maintainable in the long term. The problem is in choosing which functions should be in the class when most of them can be defined in terms of each other. Once people start using a library and defining instances its difficult to change your mind. An alternative might be to define several versions of Applicative based on different schemes and only expose them for consumption through a shared interface. class ApplicativeFmapPure a where ... class ApplicativeStructural a where ... class Applicative where ... contains every applicative function instance ApplicativeFmapPure a = &gt; Applicative a where ... instance ApplicativeStructural a = &gt; Applicative a where ... That way the instances (of ApplicateFmapPure etc) stay small and axiomatic but you can have several different choices of axiom schemes or just implement the whole class at once. This wont typecheck as is (overlapping instances etc). I think I can use a type family to guarantee to the type checker that only one of the underlying instances can be used. Ill have a crack at it later on tonight.
repost.
With GADTs, you can *always* make your methods return construtors (ie. have a deep embedding). So, further combinators can pattern match and optimize. Hence, no need to complicate the class.
I don't follow. Could you give an example?
Shouldn't you Icelanders be rioting and shit?
There's a library (I forget the name) that allows you to attempt to force some data into a type. Turn your Unit list into something like [(Int,a)] (where a be your heterogeneous type) and then based on the fst element convert to the appropriate type. If this is a serious project I'd spend way more time on structure. A decent client/server approach adapted to take advantage of the functional paradigm would be pretty fun to read.
We have decided to be more organized than our Greek counterparts, and split our rioting efforts into smaller divisions. RHUG will be a large feather in our cap. Lazy rioting is where it's at. 
We've got people doing that. We maintain enough non-conformity already by using functional programming languages.
Holy crap.. it's been only one day and someone noticed us!
This sure puts the pressure on us ;)
Weak Head Normal Riots? Good name for a punk band.
In fact, I take it back &lt;* uses const, which we have no control upon.
I'm not sure where he got the idea that haskell tools are only available on Windows. I've got ghc, hugs, and darcs chugging away happily on FreeBSD right now.
Yes, please comment on his site correcting any misconceptions (of which there are a couple).
&gt; In other words, a programmer who is presumably competent but comes from the imperative (not functional) Fortran-C-C++-Java-Python lineage is unable to write a working 3-line program in Haskell. This is being willfully obtuse. The program in question allocates a list of one billion integers before processing it. You can't do that in Java either.
The Factor version is more readable than the naive Haskell code, and it doesn't allocate O(n) memory either. Compare, mean :: [Double] -&gt; Double mean xs = sum xs / fromIntegral (length xs) main = do [d] &lt;- map read `fmap` getArgs printf "%f\n" (mean [1 .. d]) With, : mean ( xs -- n ) [ sum ] [ length ] bi / ; : main ( -- ) readln string&gt;number [1,b] mean number&gt;string print ; To be fair, the optimized Haskell version is faster than the above because of runtime dispatch and such. However the optimized Haskell is even more complex.
Done.
There was a followup by another blogger that introduced a concept of... strict pairs or something? (can't quite remember) That allowed the mean definition to remain simple while maintaining constant space *and* using lazy lists.
Thanks, and I did hear that they all use c++, and I also heard it was a very difficult language as well.
Wow what timing.. just after I switched this little project from Haskell to C, due to lack of some X bindings. hah. I'm even using the shared memory stuff. Not sure if I'll switch back though (not trying to start a haskell-vs-c thing), as it would just feel wrong to do lots of raw memory twiddling in haskell.
 points 0 up votes 1 down votes 2 What, #haskell reddit doesn't like this? :(
Sounds like the Dastardly Haskell Downvoter at work again.
I found page to be content free.
Is it just me or is the Qi approach just defining a single monad's bind and return, and therefore deriving none of the real benefits of having a common syntax across a wide array of _different_ monads like the Haskell typeclass or the Ocaml module?
Working Hard
sez 2009 but I swear I read about this two years ago.
http://homepages.inf.ed.ac.uk/wadler/topics/links.html#blame-scheme
You can always evaluate both arguments to "/" in [parallel](http://kerneltrap.org/node/16735). Then you can write something like: avg xs = (sum' xs) / (len' xs) 
I get slightly better results switching to bytestring IO, http://hpaste.org/13719 7.4k conn/sec Suggestion from olsner, add -threaded (but no forkIO), tips it over 10k conn/s: Request rate: 11427.3 req/s (0.1 ms/req)
I don't think I would agree with the author's premise that it requires previous programming experience. My (limited) experience has been that beginners have as easy a time as experience programmers. Experienced programmers know how the machine works, but they are hobbled by being stuck in the older paradigm, so they *need* the comparisons. By contrast, beginners are not hobbled at all. I knew some people, girls even, who actually picked up languages like ML faster than they picked up C or Java. Indeed, the girls tended to hate C.
Oh, nice… I keep meaning to get around to putting ByteStrings in my code and using more optimisation. For now though, it is baby steps and happiness if it doesn’t crash on me! Thanks for the tips though - I will be sure to try them out as I try to take the server forwards. May the connection rate move onwards and especially upwards! Of course, what it really needs now is the ability to give a slightly more interesting response.
 data Xauth Constructors Xauth xauthName :: [CChar] xauthData :: [CChar] Why aren't all these [Char]? I'm confused by the library providing c bindings (thanks!) but not wrapping everything to expose a more Haskellish interface. EDIT: Reason: 30 minute package job, no marshalling Char -&gt; CChar right now.
I don't know what "readln" does in Factor, but I'd guess the following Haskell program does something very similar (although still with linear complexity): mean xs = sum xs / fromIntegral (length xs) main = readLn &gt;&gt;= print . mean . (enumFromTo 1) 
&gt; (although still with linear complexity): But that's the show-stopper, isn't it?
Yeah, I was just trying to show a cleaner `main` program (you can also omit the type declaration). As for show-stopper, there are many solutions to this "problem" (one elsewhere in this thread). And of course, I've never see anyone mention that a lineaar fold is the wrong numerical algorithm for summing floating point numbers. All this talk about "mean" has me wishing for the days of FizzBuzz. 
Worth noting that the video is 818mb in size.
I use HDBC -&gt; ODBC in non production environment. It is pretty neat. Took a while to get it all compiled in Windows though. (I had to tweak the cabal files a bit to get it compiled with GHC 6.10) Good to know that HDBC is used in production.
It looks like HDBC does not have API for dealing with BLOBs. Have you faced it already? 
Now we just need Haskell XKCD bindings and we'll be all set.
Not yet. I was using it with another in-house ISAM engine (which has its own ODBC driver) for simple tasks. Didn't come up against BLOBs.
Aagh, Agda! My brain!
I read that as "...in a trance"
Share your experiences with this guy, and maybe we can make progress here.
Perhaps the recent paper on how to design with fundeps, http://web.cecs.pdx.edu/~mpj/pubs/fundeps-design.html will help?
Try this paper: http://research.microsoft.com/en-us/um/people/simonpj/papers/fd-chr/ Basically you think about which type identifies which in a multiparam typeclass. If you have class Foo a b | b -&gt; a where ... that means that there can be only one a for any given b. So the compiler can know that if there's a b, there's only one available option of a.
http://www.haskell.org/haskellwiki/Functional_dependencies is pretty good, I got it and I stil don't get type families.
Thanks this was helpful, especially the analogy to relational data.
The lhs file doesn't compile for me due to a superfluous comma on line 1397. I suppose I should let the chap know!
If you manage to reach him, be sure to ask him to license it under some Free license so I can stick it on Hackage.
His yahoo email bounced back - yahoo have deactivated the account some time ago.
Yes, that doesn't surprise me. I emailed him 2 years ago or so and never heard back.
Doesn't compile for me because it "Could not find module `GraphicsUtils'". What package is that from? (googling and hoogling didn't really help - I get the impression it was a Hugs thing, maybe it was in an older version of HGL...?) [Edit: answer was to change the import of GraphicsUtils to Graphics.HGL.]
'Frag'? But I thought that was the FPS! Now I'm just confuzzled. :(
J. D. Salinger of Haskell.
_I'm not sure whether to comment on the blog or on reddit._ [Can you say more about how the event abstraction fails for a remote machine?][1] [1]: http://lukepalmer.wordpress.com/2009/01/12/ridding-ourselves-of-io-before-there-is-a-good-replacement/#comment-571
Yay. xlib's (mostly) synchronous model on top the (mostly)asynchronous protocol really makes a lot of things more painful.
He could have linked to a tutorial that *does not* fall into this pitfall, assuming one exists, of course. I think I grasp more or less what monads are, but of course it's always nice to confront my cognitive model to someone else's vision of it.
Enjoy, guys! :D
I think [sigfpe's tutorial](http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html) is still the best.
Thanks! It looks really cool.
I learned from [All about monads](http://www.haskell.org/all_about_monads/html/index.html).
I don't know about this ... dynamic? OO? just because you can make it that way, doesn't mean that it is that way. Otherwise C would also be OO.
Listened to the podcast while hanging upside down wearing those space boots, very kewl.
These guys have an entire business based on Haskell tools.
huh, I didn't realize that Haskell was your first language in uni. How come you didn't immediately start using it for all your projects? :-P
The author doesn't understand the essence of Haskell pretty much. Why would anyone be interested in Haskell just because he/she can do object oriented style functional programming? Are you not ready to follow the paradigm or constraints imposed by the language? It understands regex.. wait, what? What doesn't these days?
Serious question: what good are typeclasses without the type safety? Doesn't that make them even more like java-style interfaces? 
I spent the holiday break trying to understand the derivative of a functor, upon which the zipper is built. If I may use the modern parlance, "bricks were shat".
Which means you have to use unsafePerformIO a lot?
Neat hack. Does the library support constructor classes like Monad and Functor? And how about instances with contexts, like: instance Ord a =&gt; Ord [a]
Presumably because his projects were decided by the Uni (I know I had to use Java, C, Erlang, MPI, various flavours of asm, but everytime I got the chance I used Haskell of course)?
o/~ anything you can do, i can do better
RTFA. Dynamic language, regex etc are not the author's criteria, they are taken from the [Ruby article he mentions](http://rubyhacker.com/ruby37.html) and he is claiming that Haskell is just as good.
But, I doubt that anybody "loves" Haskell for its OO capabilities, nor would it be a selling point as it is for Ruby.
why would they make haskell the first language to be studied and then not use it in any further courses?
followup: http://intoverflow.wordpress.com/2009/01/13/why-haskell-is-beyond-ready-for-prime-time/
Because a university should teach you more than one language/paradigm.
I can understand the benefit of these packages for applications but not all these libs -- why not use cabal? 
We need a voting app...
So **that's** what a monad transformer looks like.
Dammit, they took fucking rainbows *and* the lambda??!!?.
&gt;It is useful to think of a monad as a strategy for combining computations into more complex computations. Best one line description I have read so far.
What? lhc-compiler? They have a compiler for Large Hadron Collider? how sweet. :)) 
Did you look at [the one that Eelco mentioned](http://groups.google.com/group/fa.haskell/msg/5d0ad1a681b044c7)? Eelco already appointed you as its benevolent dictator - what more do you want, a harem???
It's probalby the worst logo I've ever seen. It's ugly with garish colours as well as being cluttered and intimidating. IMO no logo is better than that logo.
Unfortunately it doesn't really work well in IE, which many people use (e.g. for corporate policy reasons). It doesn't need to be that big of a deal, a bunch of pictures with a number box next to it. 
Yeah, sorry about the name. Thoughtpolice's Haskell Compiler (THC for short) was considered but then I got high and forgot about it.
Ok. So maybe we can move forward now.
What about creating a temporary subreddit and submitting the candidates to it? There should probably be a "no internet funny stuff" auto-elimination clause... otherwise we might have to endure [Mr. Splashy Monads](http://www.greenpeace.org/international/campaigns/oceans/whaling/great-whale-trail/mrsplashypants).
Hey, I voted for Mr. Splashy Pants, and it's a perfectly cromulent name!
So, uh, you're saying you Haskell guys have been *lazy* about *evaluating* your logo choices? There's a surprise.
Mr. Splashy Pants probably gave Green Peace more publicity than they would have had otherwise. It was probably the best name out of all of them to pick if only for that reason.
So I take it you got your harem?
Yeah, but it looks _old_, like nothing's been done with Haskell since the 80s. Haskell is hip, it needs a modern look.
It happens to the best of us.
I absolutely agree. This is very professional work, it'll scale well to a favicon all the way to a big sign.
good read.
Better than a lot of Haskell tutorials out there. Lets newbies see the forest without wondering what the syntax trees mean.
There still seems to be a lot going on with C, I also found a PEG library for plain C at http://fossil.wanderinghorse.net/repos/pegc/index.cgi/index
The interesting thing about this is using CPP macros to work around the fact that making parser first-class values in C would be very painful. So it would be more accurate to call this "Parser Combinators in CPP", with the implication that the combinators are even more unsafe and hard to debug than regular C code. There are also two major flaws with the current implementation, which seem possible but probably awkward to fix: the choice combinator (||) should only try the second alternative if the first consumed no input, and there should be a "try" combinator which stores the parse state and resets it if a parse fails. As it is, this is just a cute way to write standard recursive-descent parsers, and doesn't achieve the expressiveness of parser combinators.
Thanks Brian, this is awesome. Love new perspectives!
More details: http://www.haskell.org/pipermail/haskell-cafe/2009-January/053497.html
That... is completely awesome. He just single-handedly solved the problem of Haskell's libraries still being a bit limited compared to other languages. There is only one thing I could think to add, though it is rather radical. The current implementation relies heavily on strings, turning any typos or other errors into runtime errors. My suggested alternative (which I think should be possible, though I might be overlooking something) would be to convert the whole .NET library to Haskell code via automatic conversion. You write a C# (or other .NET language) program that uses reflection to analyze the whole .NET library and spits out Haskell code, converting interfaces to type classes, namespaces to modules, etc. You could then create programs that look something like import NET import NET.System.Windows.Forms main = do frm &lt;- new Form [set width 200, set height 100] new Button [set text "Hello World"] &gt;&gt;= addControl frm run Application Though there might be some slight inelegancies here and there (e.g. overloaded functions may have to have a number appended), it will result in statically checked .NET interop, which would be awesome.
Looking at the source it seems like it uses a COM component (HsInvoker.dll, source missing?) to talk to Microsoft's VM. So no support for other implementations like Mono :(
If he's using a COM component as his .NET bridge, why not use his Haskell COM binding package instead of C code? http://hackage.haskell.org/cgi-bin/hackage-scripts/package/com
I think the layout support is great. Going from Python to Haskell was a huge step forward. If I had to go back to spraying my already-indented code with redundant braces, it'd feel like a huge step backwards. IMO, code documentation is great, its just that I think code documentation should lie in the code's names. Names are better than comments, because they are scoped - so its clear what they're talking about. Additionally, names tend to be updated when the meaning of the code changes, but comments usually remain out of date. I can't say I love literate programming, especially as it seems absurd to me to view the code (if its Latex, you want to render it) with separate tools than editing it.
There's an 'x' missing from the end of the url.
Excellent article, don't miss it.
No, it would be nice to have a little control over WHO votes and how many times. Any chance of just taking every e-mail address that has posted to haskell.org and giving those one vote each?
Does it work with Mono?
Instant run-off voting! Proven in Isabelle! Oh, if only I had enough time.
how do the goals of LHC diverge from GHC?
Nice. But surely an inefficient GC is an adequate temporary improvement over no GC?
That'd be flushing the baby out with the bath water. LHC aims at generating more efficient programs than GHC. If we can't do that then there's no reason to not just use GHC.
LHC tries to generate more efficient programs through whole-program optimizations. With whole-program transformations we can take a very different approach to laziness, type-classes and garbage collection.
How would you handle overloaded functions? AFAIK Haskell isn't designed to do dynamic dispatch on argument types. E.g. you can't define module System.Type where getType :: Type getType = ... getType :: String -&gt; Type getType s = ... getType :: String -&gt; Boolean -&gt; Type getType s b = ... 
There are two problems I have with white space being significant are the problem of mixing tabs in with spaces (which I've solved by eliminating tabs, but I'm not sure this is a general-purpose solution), and what happens when the compiler wants things indented differently than how I want things indented. There are actual advantages to having braces or brackets around things- in vi, for example, the % command goes to the matching fence (paren, brace, or bracket), and you can combine it with other commands, so d% deletes to the matching fence, y% yanks to the matching fence, etc. This makes it easy to work with whole code blocks. One of the tools I miss from my old C coding days is indent- a program that took C code and consistently indented it. Version control systems could then run indent on checked in code to force them to be in a standard format. Of course, the problem with writing a tool like indent is that you have to be able to parse the language, which is a non-trivial undertaking. This is one of the reasons I think having a (sorta) standard library to parse the language is such a big help, is it allows people to easily write tools like this. 
Via type classes?
Tabs are a problem. But its a really easy problem. You just define a little "everyone uses spaces" rule. Sure, rules are expensive, but this is a cheap rule, and you don't need that many. Good editors should be able to do the equivalent of % (and derivative features) without the braces. Of course if you would have had "}}}}}" then % is not possible, but it's not that useful in that case either. If you have: } } } Then you wasted 3 lines just for the % feature :-) If the compiler wants things indented differently, then the layout rules are bad. In Python, for example, the layout rules are super simple. After colon, same-line code OR indent is always expected (If you want an empty code, you can use "pass"). If parenthesis are open, then you can continue at any indent level you want. Haskell's rules are a little more intricate, and maybe they should be fixed. "indent" is fine for C, but only because you are forced to maintain two things (braces and indentation). indent allows you to maintain just one. If you already have to maintain just one (indentation) then what's the problem? You no longer need indent. 
As I mentioned in my post, one (very inelegant) solution would be to change the names: module System.Type where getType :: Type getType = ... getType2 :: String -&gt; Type getType2 s = ... getType3 :: String -&gt; Boolean -&gt; Type getType3 s b = ... Perhaps some Haskell wizard (e.g. Oleg) could come up with a better solution. Perhaps some very creative use of multiparameter typeclasses and fundeps to allow variable argument numbers (like printf) without allowing an arbitrary amount of them.
If I understand Haskell type classes correctly, this would require that every form of every overloaded .Net function would need it's own type class. This would in turn require machine-generated type-class names like SystemTypeGetTypeStringObject. Right? 
I think publishing regular benchmarks from LHC would be the single most useful contribution here. Start putting the scare on GHC, and we'll see serious improvements. :)
I wish they could add whatever they need to LLVM instead of writing their own native code generator. It has a fairly impressive list of backends, even a portable C one, so you should be able to get the compiled apps to run on pretty much anything (this includes the compiler itself ones it can self-build).
I don't care what terminology gets used, but a single code exmple is worth more than 1000 links to research papers on the subject. That's what the standard library haddock docs lack. Give a simple example of the expected use of this concept and I can immediately see for myself what it does and go on to use it in my code without having to grasp it's place in category theory.
Exactly. Programmers ARE learning haskell. But "requires advanced degree in category theory to understand the basics" is a huge hurdle. "The Haskell School of Expression" is a good book, covering it from a programming angle without getting too esoteric. I don't care if it is called a MONOID, or based on monoids. That is great, what can I DO with it. Like Lift, I finally found a doc described that described it. It lets you 'peel' wrapped monads to get to other monads inside. Wow! That is all I really needed to know.
It's like that old sysmon gkrellm right? You didn't have to write the whole thing in perl. But you did because it was fucking fun as hell. The Haskell community didn't have to call them monads, but what fun would that be? Mind you, I was an OCaml hacker before I was a Haskell hacker, and the quirkiness of the language, from the functional purity down to the naming stuff after category theory concepts really does make it that much more gratifying to learn. It's as if the language has *culture*. OCaml by contrast is sterile. Btw, category theory is pretty effing fun too, if you have the time to dig into it.
How does it compare to [Salsa](http://code.haskell.org/Salsa/README) ? 
One of the biggest problems author addresses, is the lack of simple usage examples on type classes. I do not care why Monoid is called Monoid. I wanna see how do i use it, without delving into Category Theory books. 
"requires an advanced degree in category theory to describe the basics" is also a lie, Not an exaggeration, a lie. I'll admit the terms can scare people off, but you don't need to know much at all to understand these things. You just have to be willing to take a look, and not use the unfamiliar terms as an excuse to beg off.
But the question on everyone's lips: does it have a black hole detector? Oh, not that LHC?
Generalizing support for garbage collection and low-cost concurrency isn't something you do in an afternoon. The C-- guys have been researching how to do it properly for about a decade, and, by their own admission, haven't gotten it right yet. Implementing the needed features in LLVM could easily take another decade. Writing our own NCG is act of desperation. We really have no other options.
`List` is an instance of `Monoid`, so you can do this: &gt; mempty :: List [] &gt; mappend [1,2,3] [4,5,6] [1,2,3,4,5,6]
Exactly. At times, learning Haskell feels like being inside the SICP lectures videos, back when Sussman was explaining that programming is magic, and functions are spells. 
So i would create a new data type and make it derive from Monoid, if i want these 2 functions return me my empty structure or append several of them ? And I do not have to implement those 2 functions, i'll just get them for free ? 
You have to implement at least those two methods. You can then get `mconcat` for free.
Actually there are plenty of examples in those research papers ;)
&gt; I'll admit the terms can scare people off, but you don't need to know much at all to understand these things. But it'd be awfully helpful if that small amount was in the documentation.
Sure, but the point is that research papers should not be documentation. Research papers aren't typically updated to be current with library changes and whatnot, so expecting programmers to hunt down appropriate research papers isn't very helpful. My biggest hurdle when I got started writing Haskell code was just figuring out where appropriate resources were for what I wanted to do, and it took a few months to even find a lot of idiomatic operating procedures that more experienced Haskellers take for granted.
One major gripe about learning Haskell is the lack of good programming tutorial. The ones which python or ruby have. Anything you want to read, would have monads, functors, combinator. Yes, I flunked in Math big time and that has not prevented me from writing code in python,ruby, c or java. 
[Learn you a Haskell](http://learnyouahaskell.com/), do it now!
Geez, I tell Haskellers maybe their docs have problems and I get downmodded. Hey, I am learning Haskell, and I am trying to tell you my problems. Geez, it's like the LISP brigade.
Oh, I absolutely admit that the documentation can be greatly improved, and that examples of use in the haddock for the standard library would be a great start.
Thanks, I was reading Haskell tutorial from haskell.org found it very difficult to follow. I have ordered Real world haskell and I have book marked the link you provided.
This is a fair request, although there are advantages to calling something what it is. We basically have two choices: 1. Use a different, less technical sounding name so that people who are intimidated by technical names aren't afraid of Haskell, or 2. Call it what it is, so that people who have a background in this stuff come to the language with some existing intuition. Perhaps (2) sounds like it favors a small community at the expense of the broader programming community. This is probably true. But then again, we might be at a cross roads, where we recognize that we need to rethink the necessary background for being a good programmer. If there are advantages to thinking about programs in this way (ie, in the way suggested by abstract algebra and category theory), then we should really consider using these subjects as a foundation. Haskell is an experimental language; it has been since day one. I think that this different perspective is a valuable part of the experiment.
Original post here: http://martijn.van.steenbergen.nl/journal/2009/01/11/type-synonym-families/
So it's kinda like Xpath.
I do not get it. The site is completely static. Just a bunch of links to pictures and html pages. Why would any Application Server be necessary in this case ? Simple FrontPage or any other GUI Site building tool, or even html friendly text editor like emacs, would be more than enough. Over-engineering ? 
If only I knew what the hell that meant.
Ah, My NoScript plugin disabled javascript. Now i see that it is a simple site to show bunch of pictures using Jquery component to scroll image thumbnails. Can be easily done in any much more simpler web frameworks, without the need to learn haskell + hundreds of its non standard extentions + Template Haskell + Monad Transformers + Happs itself (it still awfully lacks documentation). I still say - over-engineering. 
This was an excellent question...
Hehe ;)
LLVM is not really a GC-hostile environment. There're intrinsics available for accurate garbage collection. You may run into other issues with LLVM (stack management seems like a big one), but GC's not one of them. And recent versions support TCO via fastcc.
And here's [a static binary for i386 Linux, stripped and gz-compressed](http://progg.free.fr/darcs/darcs_2.2.0_i386.bin)
Needs more proofreading.
Sure, you can use a GC with LLVM. You just can't do it efficiently. What I tried to say in the blog was that even though most languages can support automatic memory management, few (if any) can do so efficiently. Perhaps I didn't get my point across.
&gt; The second point I’d like to make is that the Haskell concept of a monoid and the mathematical concept of a monoid are different concepts. I’ll take just one example- in mathematics, integers are monoids twice over, once over addition (with 0 as the identity element), and once over multiplication (with 1 as the identity element). Due to various reasons, in Haskell, you can only give each type one definition of a given type class, such as Monoid. So Integers are only allowed to be Monoids in one, not two (or more) ways. I disagree with this. Monoids in Haskell and in math *are* the same thing (modulo the fact that Haskell's type system is insufficent to enforce the Monoid laws). The only reason it mathematicians get away with Integers-being-monoids-in-two-ways is that they are sloppy. If you follow a really formal mathematical argument you will see mathematician doing something analogous to wrapping the Integers up into a `newtype`.
&gt; learn haskell + hundreds of its non standard extentions + Template Haskell + Monad Transformers oh come on.
This whining about Monoids gets old really quickly. 
cool, first gtk2hs, now qthaskell. how stable is it? 
Note [wxhaskell](http://hackage.haskell.org/cgi-bin/hackage-scripts/package/wxcore-0.11.0) is also active again. qthaskell is the least used of the three.
This is a really good post. Highly recommended. And timely, too, as there's been a big discussion/flamewar on haskell-cafe on the value of typeclasses with names like Monoid.
Yeesh - someone get that man a spellchecker, I can't even read that without pain.
&gt; I'm not sure why the term monoid is missing from some textbooks Bourbakiphobia.
I agree. w00t
As the developer of this site I must comment on this :) This site is far away from being static. While for the users of the site it may look like it's static the administrative part of it is full of dynamic and juicy stuff, like multi file upload, automatic resize tool for all images and thumbs, category management, tagging, re-ordering photos, etc. I'll probably post a screen cast of that part on my blog in the coming days: http://gisli.hamstur.is/blog/ (which happens to be written in Haskell as well). If you're interested you can see the source code at http://gisli.hamstur.is/src/. Of course there's no need to do this in Haskell. You can do it in any other language without learning all the things you listed above - but where would the fun be in that ;)
abstract concepts + wikipedia = win.
Only tangentially related to Haskell, and no interesting technical content.
Wow! This is the kind of stuff that NEEDS to be in the Haskell docs. This one posting told me what monoids are, and showed me their use compared to many others.
There's something similar inside QuickCheck --- the Gen monad. I actually liked this idea so much when I saw it that I started using Gen from QuickCheck for my random value generation. Now we have two competing monad definitions for the same thing. It'd be nice to see a writeup of how the two compare.
couldn't agree more !
I disagree with the disagreement. The problem here is a shear in the metaphors often used by mathematicians. A monoid is a triple of a set, an element of that set, and a binary operation on that set. A monoid is not (a) a binary operation, (b) a datatype, (b') a set, (c) a binary operation and an identity, nor (d) any of the other simplifications that get thrown around because people are too lazy to talk about the entire triple. The problem is that type classes are a *function* from types to dictionaries, whereas the underlying model is a *relation* on types and dictionaries. Yes, a specific dictionary defined by a Monoid instance in Haskell is exactly the same thing as a mathematical monoid. But the restriction on how type classes can be defined and how the dictionaries associated with them can be obtained makes the relation into a function and is a limitation of Haskell that does not represent the mathematics. No formal mathematics I've seen ever does something analogous to newtype wrapping. They take the entire triple as the object of discourse, rather than focusing on a single field of that triple.
&gt; I'm not sure why the term monoid is missing from some textbooks. In my experience they're considered too common to bother with giving a name to. "Associative operation with an identity" is sufficient for most authors and lectures (who want to move onto talking about groups or semirings). That is, assuming a discrete structures outlook on mathematics. Topology folks seem to be more likely to give it a name precisely because they're so common. *shrug*
&gt; No formal mathematics I've seen ever does something analogous to newtype wrapping. They take the entire triple as the object of discourse, rather than focusing on a single field of that triple. By analogous to newtype wrapping, I mean the following. To talk about the additive monoid of a ring, they have to extract the universe, addition operation, and 0 out of the ring and wrap it up in a triple. To get the multiplicative monoid of a ring, they have to extract the universe, multiplication operation, and 0 out of the ring and wrap it up in a triple. The point is that these two monoids don't come for free (as the original post implied), and some extra work is need. In this case this wrapping function is analogous to the extra work needed in Haskell to make a newtype, although I agree they are not the same. I generally agree with what your response, however you perhaps focus too much on implementation specific details. For example, dictionary passing is not the only way to implement type classes (see JHC), and a triple of a set, element, and binary operation is not the only way to implement monoids in mathematics. 
Awesome :)
Hilarious!
Seriously, we do need a wiki version of the docs, to collect edits and improvements.
It's scarey when the haskell version is simpler!
Wow. In one post, he solved a problem I've been fretting about for months. Namely, how to deal with the one-instance-per class restriction on types- just wrap your type in a suitable constructor like Sum or Product. Don't know why I couldn't figure that out myself.
And the novice was enlightened. :)
Theres also the MC monad, part of the monte-carlo package. It's essentially a rip-off of QuickCheck's Gen, but more geared towards scientific computing. Advantages MC has over MonadRandom: faster, support for standard probability distributions (normal, exponential, Poisson, etc.) Disadvantages: depends on the GNU Scientific Library, not thread-safe, no support for the Random or RandomGen types in the standard library.
Is it just me, or are the arrows in that ASCIIgram wrong? Shouldn't the arrows for `i` and `j` be reversed?
That's the least accessible documentation I've seen. After the first sentence it devolves into mathematics I _really_ shouldn't need to understand to use `True` and `False`. This _is_ a joke, right?
Thanks! Your blog posts are always really helpful.
It's not just you.
You are correct. [Daniel Fischer corrects some typos](http://article.gmane.org/gmane.comp.lang.haskell.cafe/50954) 
| That's the least accessible documentation I've seen. That is exactly the response I was aiming for. | This is a joke, right? Yes, it is a joke. However, I hope some people will come away with more than a chuckle. Although things can be described in unfamiliar categorical terms, it does not mean the underlying concepts are necessarily hard to grasp. And on the other hand, just because something can be described in categorical terms, doesn't mean it should be (although I do grant that it may be difficult to come up with a new, non-categorical description of a categorical idea).
This is painful to read, and my sentiments are with the student. Unfortunately, there is no recourse against the wrath of righteous Platonists.
Oh right. I forgot that people wanted applications of academic concepts like Booleans.
This captures my opinion exactly. Haskell is sometimes criticized for not being "newbie friendly". But if it were so, then there would be no new ideas to learn! Haskell is supposed to stretch your mind. I know it has mine- I'm a mathematician by trade and used categorical ideas in that realm, but they didn't truly click until I discovered Haskell. Too often, I think people confuse software engineering and computer science. Haskell is, above all else, a research language. It's a sandbox. Let's keep it that way.
It seems to me that there are two different things which could be meant by 'formal proof' here. On the one hand, it might refer to derivations in a formal system. If that is the case, a computer-checked proof seems perfectly reasonable. It may be that the TA is unaware of what role the computer played, thinking that the proof was derived automatically by the computer. On the other, 'formal proof' could refer to a rigorous mathematical argument given in informal language (such as English). In that case, I could see a formal proof in the previous sense being inappropriate. I don't know how things are at Berkeley, but "Theory of Sets" could well be the title of an intro to proofs course, between lower and upper division mathematics. If so, then a major goal of the course would be to teach students to read and write proofs _as they are written by mathematicians_. I have never read a paper which used derivation in a formal system for any result. In fact, the only time I have seen such proofs, the focus was on the system being used, not the result being proven. Given the comments from the TA, I think that it is more likely that the latter case holds here, and the student should really not be doing formal proofs with a computer. Finally, it should be noted that the use of computers for doing mathematics is still somewhat controversial. There is a worry of what it will mean if proofs become too complicated to be understood by people. (See the proof of the four color theorem.) This may explain part of the TA's reaction.
Personally, I'm interested in the underlying category theory, but I think the documentation presented could use a couple of outbound links towards explaining the concepts it addresses. It'd be kind of cool if all of the Haskell docs had a CT sub-heading.
Well, some of us probably thought that the proposal of renaming Monoid is a joke, too...
While I sympathise with roconner, it's also possibly harsh on the TA to submit something in a computer language with which he is probably entirely unfamiliar, and which isn't particularly easy to learn at the moment. (People still complain that *Haskell* is hard to learn!)
Why didn't you simply make the angle of the pie slice grow/shrink instead of the area? Area correlates very poorly in human visual perception with magnitude.
this is cool as heck
Posted on Debasish's blog, but that use of the state monad (i.e. appending stuff to a list) seems exactly what the writer monad is for: import Control.Monad.Writer fizzbuzzW :: Integer -&gt; Writer [String] () fizzbuzzW = tell . return . fizzbuzz fizzbuzz n | n `rem` 3 == 0 &amp;&amp; n `rem` 5 == 0 = "fizzbuzz" | n `rem` 3 == 0 = "fizz" | n `rem` 5 == 0 = "buzz" | otherwise = show n main = print $ snd . runWriter $ mapM_ fizzbuzzW [1..100] 
How would you improve the code?
[gtk2hs](http://www.haskell.org/gtk2hs/)!
Why are you writing a GUI application if you're new to Haskell? Start off simple.
gtk2hs is kinda simple though.
gtk2hs is nice because it's pretty simple, the docs are helpful, and you can design most of your UI with stetic exporting to a glade file: http://www.mono-project.com/Stetic
hi-level
Well, the code doesn't look too bad. forkIOn bothers me the most: forkIOn ∷ Int → IO () → IO [ThreadId] forkIOn count io = if count &gt; 0 then do first ← forkIO io rest ← forkIOn (count − 1) io return (first:rest) else return [] I'd probably rewrite it to use replicateM: forkIOn ∷ Int → IO () → IO [ThreadId] forkIOn c io = replicateM c (forkIO io) This saves 7 lines, avoids some primitive recursion, and is more obviously correct, I think. It's short enough it might not even be worth a function definition - just inline it into its only caller. But I suppose this just illustrates his point that a Haskeller could cut the line-count drastically! This actually is kind of a trend in his code - not being familiar enough to use the library functions: &gt; Using return () as a no-op in an if statement or x &gt;&gt;= id for anything at all felt clever but somehow wrong. Indeed. That's because 'if foo then bar else return ()' is bad style compared to using Control.Monad.when - 'when foo bar'. And '&gt;&gt;= id' is worse than using 'join', or perhaps just '&gt;&gt; return ()'. (How is he supposed to know these things? Well, if he had looked at the inferred type for '(&gt;&gt;= id)', and then plugged that type into Hoogle, Hoogle would've immediately told him Control.Monad.join. Ditto for 'when'.) 
Both gtk2hs and wxhaskell make it possible for you to design the GUI with a graphical editor and to hook it up to Haskell code (the use of a graphical editor is optional). I'm not sure how they compare though, as I've only used wxhaskell.
Superficial changes: * Replace doAll with the standard function sequence_. * replace forkIOn with the standard function replicateM * replace doAll (list comprehension) with standard function mapM_ Also, I'd use a much simpler algorithm: import Control.Exception import Control.Monad import Control.Concurrent.QSem import Control.Concurrent -- | 'scheduler n ts'. Execute 'ts' in parallel, with no more than 'n' jobs -- executing at once. scheduler :: Int -&gt; [IO ()] -&gt; IO () scheduler n ts = do sem &lt;- newQSem (max n 1) forM_ ts $ \t -&gt; do waitQSem sem forkIO (t `finally` signalQSem sem) replicateM_ (max n 1) (waitQSem sem) 
qtHaskell too make it possible to design with an editor.
A LawnMonad? Interesting...
It seems like he wrote a Haskell program entirely in Haskell's imperative sub-language (IO) -- and ended up thinking "Haskell is yet another imperative language". Finding ways to structure your programs so that the majority of code is not in IO is an acquired skill, and until you do, you will enjoy far fewer of the advantages of Haskell.
You see monads are like lawnmowers... Well not completly, maybe more like lawnmower bags.
My God, it's full of stars.
Not much he can do about that - his problem is imperative. You're basically saying 'he didn't come out with a flattering view of Haskell because he didn't work on a problem that flatters Haskell.' This is not a response I like. I prefer an explanation like 'he didn't know the libraries &amp; tools well enough' or 'he didn't use the nice abstractions provided.' Not, 'He didn't choose a problem suited to Haskell.'
I think Haskell is as well suited to almost all problems as other main-stream languages, so I agree. However, obviously some problems will flatter Haskell far more than others. Those that flatter Haskell less will offer advantages over other languages, but far less significant ones.
Very cool problem statement. Here's another version: import Control.Monad import System.Process import System.Environment import Control.Concurrent import Control.Exception(finally) main :: IO () main = do args &lt;- getArgs n &lt;- case args of [ ] -&gt; return 3 x:_ -&gt; return (read x) cmds &lt;- replicateM n getLine (tid,done) &lt;- fork (runAll (fmap exec cmds)) takeMVar done &gt;&gt; killThread tid exec :: String -&gt; IO () exec cmd = do handle &lt;- runCommand cmd waitForProcess handle return () runAll :: [IO ()] -&gt; IO () runAll acts = mapM_ (takeMVar . snd) =&lt;&lt; mapM fork acts fork :: IO () -&gt; IO (ThreadId, MVar ()) fork io = do done &lt;- newEmptyMVar tid &lt;- forkIO (io `finally` putMVar done ()) return (tid, done)
Hello haskellers, I am the author. Thank you for all the comments. This is the first useful thing I have written in the language, and I'm pleased that some of you found it worth improving. I'd like to incorporate some of your suggestions, if you don't mind.
Thanks for the contribution, and welcome to the community!
&gt;How is he supposed to know these things? I think this question is generally applicable to any program language you're learning. As you use it more, you learn more about it. I wish more people would do what he did, though. He wrote a program to solve a real problem and posted his solution. Then he gave his own impression of the language. This is a very constructive way to offer feedback or criticism. It allows the community to respond in a constructive way -- ie, by showing him ways more experienced programmers might do things differently -- and it demonstrates to everyone that he is knowledgeable enough to interpret that feedback. There's been a fair amount of Haskell hype lately and the result has been a lot more annoying fanboyism, which in turn has created a lot of anti-Haskell backlash. Most of the trolls that have come out of the woodwork disparage the language without actually understanding it, and so we usually ignore them or flame them. On one hand, those trolls deserve what they get, but on the other hand, bystanders who don't know enough to understand why what they're saying is stupid sometimes come away feeling like we're ignoring them or flaming them because we're unable to address their talking points, which gives them (unfortunately) an air of validity. This guy didn't know Haskell, he wrote something non-trivial but small in it that didn't leverage Haskell's inherent strengths (ie, it was a fundamentally imperative problem) and came away with a lukewarm impression of the language -- not too negative, not too positive. He's not a fanboy talking about Haskell as if it were the second coming, behavior which would otherwise make a lot of cynical programmer types suspicious. His experience therefore seems trustworthy, and while he's not waxing lyrical, it shows people that yes, you can use Haskell to solve problems, and yes, it's not too difficult -- note the lack of OMZG MONADS -- and more importantly, when we as a community address his problems, offer him suggestions on how to improve his program, etc, we demonstrate that we don't dodge criticism, that we don't reflexively ignore everything that might be perceived as critical. I hope brian_jaress keeps using Haskell, and I hope that the feedback you all have given him encourages him to choose it for his next little project. Regardless of whether he does or not, though, I'd like to thank him for writing up his experiences, and encourage others to do the same, *especially* if, when all is said and done, they haven't gone all fanboy. Because Haskell is a real tool that is used by real people to solve real problems, and it's not perfect (although I personally have never used anything I like more). By not pretending it is we not only give ourselves direction in which to grow, we also become, as a community, more inclusive, which is not a bad thing at all.
Gtk2hs still causes problems for Mac users. The post title doesn't indicate whether cross-platform portability is a requirement, but if it is then I wouldn't use Gtk. Since the licence for Qt changed to LGPL I would definitely go with qtHaskell.
Updated the post to include a link to source code
We'd need some tutorials on qtHaskell then I think :)
http://glade.gnome.org/ glade can also output glade files.
Humm, I have a threadPool like function on steroids in a Control.Engine package I created. Perhaps I'll upload it to Hackage. EDIT: This imperitive style library has been uploaded as 'Control-Engine'. The main issue is this library is really on steroids and came into being to spin code out of another program I made. In other words, it could use more documentation and perhaps some simpler functions that hide some of the options.
Does this mean that the type system will prevent me from cutting one of my toes?
No, it simply means that the cut will be clean. 
Have you used the qtHaskell bindings? We seriously need users to write about it.