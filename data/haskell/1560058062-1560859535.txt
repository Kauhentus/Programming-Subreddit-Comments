Nice talk. This was also one of the first things I did when learning haskell. :) [https://github.com/patrickherrmann/siteswap-diagrams](https://github.com/patrickherrmann/siteswap-diagrams)
maybe you are looking for one of those: &amp;#x200B; \- Write yourself a scheme [https://en.wikibooks.org/wiki/Write\_Yourself\_a\_Scheme\_in\_48\_Hours](https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours) \- How to organize a picnic using Haskell [http://lisperati.com/haskell/](http://lisperati.com/haskell/) \- the Practical Haskell book is trying to use something like a project (IMO) [https://www.amazon.de/Practical-Haskell-World-Guide-Programming/dp/1484244796](https://www.amazon.de/Practical-Haskell-World-Guide-Programming/dp/1484244796) &amp;#x200B; btw: long time since I last looked at the first two - you might have some trouble getting started as things might or might not be outdated
It's not quite a real application tutorial, but the \[monad challenges\]([http://mightybyte.github.io/monad-challenges/](http://mightybyte.github.io/monad-challenges/)) were designed around the idea that learning best happens by working with real examples that motivate the abstraction. It might be useful depending on how advanced you are.
This is just a mechanical dosugaring of \`print ("Hello, " ++ "World!")\`
[https://vadosware.io/post/rest-ish-services-in-haskell-part-1/](https://vadosware.io/post/rest-ish-services-in-haskell-part-1/) This one covers a lot
I feel the madness overtaking me. But that's a pretty neat type-level program you got there; I only wish type-level programming would be easier and would come with a syntax like that for the values, so you could program your types as you'd program your values, without "abusing" constructs like type families, GADTs, etc. in non-obvious ways. Maybe, someday, we could have a language wherein the value- and type-grammars would be unified, and you could declare certain functions to be types, and attach them to your value-level functions, for the compiler to then check wether the value-level function fulfills the theorem declared by the type-level function... and then, maybe, even have type¬≤-level functions to check your type-level functions, and so forth. :D
I'd agree with you if this question came from someone who's never written anything in Haskell. But op said they're already gone through "Learn you a Haskell...".
Gary Bernhardt has a video on this. It‚Äôs called ‚Äúfunctional core, imperative shell‚Äù.
I don't know how to do it with cabal, but with stack at least you can use 'stack haddock --open base', or 'stack haddock --open &lt;yourproject&gt;'.
Here's one I wrote for the express purpose of being a tutorial: Building a CLI tool in haskell: [http://bollu.github.io/teleport](http://bollu.github.io/teleport)
So basically Idris?
A number of key differences come to mind: 1. hsp's pipeline. This allows one to combine a sequence of text manipulations (including filtering) into one command. I find myself building the pipeline step-by-step, each time examining the intermediate result. This is aided by hsp's display of split lines as numbered fields. 2. hsp's macros. The easy-to-use ability to save and reuse a given pipeline is a powerful feature. 3. hsp's multiple inputs. The ability to combine several inputs, not just stdin, can be useful. I'm not sure how performance compares. As a start, it would be interesting to construct the palindrome example in hawk and see how fast it is compared to hsp.
I think for fast, it would be better not to run off `stack exec`
Thanks for the info. I'll definitely be checking it out. I suspect performance is comparable since they both use `hint` which I suspect dominates the performance numbers.
I did it 4 years before [https://github.com/cblp/python5](https://github.com/cblp/python5)
Exactly right - currently, you need to build https://gitlab.haskell.org/kcsongor/ghc/tree/unsaturated_type_families if you want to run the example. AFAIK we're all eagerly awaiting Csongor's GHC proposal, as the code is already written!
The general purpose version would be (:) 3 $ [1,2,3] ++ [4,5] And after beta reduction that's (3:) $ [1,2,3] ++ [4,5]
The same Haskell feature that makes it possible to automatically figure out that the type of `[‚ÄúHello‚Äù, ‚Äúworld‚Äù]` is `[String]` is being used to derive an implementation of ‚ÄúFizzBuzz‚Äù at compile-time.
&gt; Our work solves a longstanding issue in GHC, known as the Constraint vs. Type problem. In Section 6.1 we describe this problem and how defining Constraint as a newkind resolves this tension. This is really awesome! I was bitten by this problem a few times while trying to do more advanced type-level stuff.
I tried a number of other ways to run hsp, but kept running into problems with hint not being able find the appropriate modules it needed. I have to admit my understanding of hint is primitive. There must be a better way, so I would love to get suggestions.
Note that the rank2classes library is about functors of kind \`(k -&gt; Type) -&gt; Type\`, not \`(k -&gt; Type) -&gt; (l -&gt; Type)\`. Since rank2classes' functors are not endo-functors, it can't have a Monad class.
Oh, good catch. silly me!
But interesting post! Now I wonder if I can implement f.e. \`(forall a. c a :- d a) -&gt; Free c b -&gt; Free d b\` for my \`free-functors\` types.
Man cannot abide such awesome power
If I remember correctly, the two biggest changes are: * Officially adding `forall`instead of it just being a GHC thing * Removing typeclass constraints on data declarations That's all I could find though
It sounds great, but did you know there's http://hackage.haskell.org/package/hsp
Where is this information?
[here is the list of all the proposals](https://prime.haskell.org/query?status=new&amp;status=assigned&amp;status=reopened&amp;group=state). The ones I mentioned were under the "complete" category.
This is a nice one, thanks for working on it :D
Dependent types are more or less what you are talking about. Haskell should have them at some point in the future. Play around with Agda or Idris for some fun with them now.
Would there be a way to make your Traversal instances become lawful without hampering the usability of your cool library?
&gt; I think the module names should be treated like function names, and be as information-dense and spin-free as possible. Agreed. Another side benefit of not requiring the use of matching module names is to allow for the development of drop-in replacements. Similarly to the above another benefit is the ability to split things out into other packages while minimizing the amount of developer effort required. With that said sometimes the project name is the most concise and useful description of what a module is about, particularly in the case of framework-y libraries. I'm glad `miso` chose the `Miso` namespace and that `servant` chose the `Servant` namespace but I'm also glad `bed-and-breakfast` used `Numeric.Matrix`
The unlawfulness is actually in the semantics of the operation, not in the implementation of the operator; so unfortunately I don't think so. The unlawfulness is caused by the same reasons that `filtered` is unlawful (and if that were fixable I assume it would have been fixed ages ago). Basically the problem is that there's a law of traversals that effectively says: `set traversal a (set traversal b val) == set traversal a val` This is impossible to ensure when using regex, because the first 'set' might change what gets matched for the second set! e.g. `set (regex "\d") "outer" (set (regex "\d") "inner" "1") == "inner"` but according to the laws it should be `"outer"`. In my experience very few (if any?) combinators actually rely on this law holding; in fact I've never had a problem with it in the wild (though I'd love to see some real-world examples if anyone has some), so I happily go on using `filtered` and `regex` and sleep like a baby at night ü§∑‚Äç‚ôÇÔ∏è.
I did see that, so if I ever want to make hsp available from hackage, I'll have to rename the package. I do want to keep the executable name short, so I would hope to keep the executable name as hsp. The two packages deal with completely different areas. Of course, users are free to rename the hsp script to whatever they like.
That looks like the disbanded Haskell Prime committee. I believe Haskell 2020 was tracking itself here [https://github.com/haskell/rfcs/projects/1](https://github.com/haskell/rfcs/projects/1)
Oh thanks, my apologies.
I have no idea what's going on but would be curious to know what the use cases would be?
How about using an associated _type_ family instead of an associated _data_ family? Then you don't need any constructors at all.
`cabal install` does it for me :-)
What is the chance that the various warts of Haskell will be remedied? Prelude? The partial functions? String? etc ...
Indexed types are used heavily by fused-effects and polysemy, which have been featured in this subreddit recently (fused-effects is used by [Github's *semantic* library](https://www.reddit.com/r/haskell/comments/bv9cun/semantic_an_opensource_haskell_library_from/)). Their monads, like mine, are variants of the indexed `Fix` I discuss in my post. The first half of my post also shows two examples of typed ASTs using indexed types, and that area has a lot of ideas in common with effect libraries. There are at least two things being called "indexed monads", as I mention in a footnote. For either of them, the most common use case is to track the state of some resource. For example, a regular monad cannot prevent you from closing a file twice: do closeFile file closeFile file An indexed monad may track the state of the file, so that such a program would not typecheck. The fact that `Free` is a monad "in more than one way" is definitely known by some people. For example, the following post by John A De Goes also mentions it and even shows the indexed functor hierachy: http://degoes.net/articles/modern-fp-part-2, but I haven't seen any use of it elsewhere. A free monad's `call`+`interpret` is more expressive than `pure`+`(&gt;&gt;=)`; I'm quite sure there's some use to that fact, I just don't know what yet.
I struggled with the hawk syntax for the palindrome example and ultimately ran the following: $ time cat /usr/share/dict/words | hawk -a 'L.filter (\p -&gt; (B.length . L.head) p &gt; 4 &amp;&amp; (L.head p == B.reverse (L.head p)))' | hawk -a 'L.reverse' | hawk -m ' ((mappend ("Palindrome: ")) . L.head )' Palindrome: tenet Palindrome: stats (+ 15 more) real 0m1.058s user 0m0.995s sys 0m0.182s $ time cat /usr/share/dict/words | hsp 'T.length p &gt; 4 &amp;&amp; p == T.reverse p | reverse pp | "Palindrome: " &lt;&gt; p' Palindrome: tenet Palindrome: stats (+ 15 more) real 0m0.516s user 0m1.080s sys 0m0.459s The may not be a fair test since I am a complete novice at using hawk. I would certainly argue that hsp has cleaner syntax. But I'm prejudiced.
&gt; Given that the evidence for a HasDefault a instance consists only of the deflt :: a member, GHC compiles this class declaration into a newtype definition, producing an axiom equating HasDefault a with a, at the representational role. Some packages rely on this encoding, and it would be disruptive to the Haskell ecosystem to alter this arrangement. The newkind idea seems interesting. I'm wondering what this has to do with packages relying on the encoding though. If no packages were relying on this, would there be a better solution to the problem?
Using Cabal foreign libraries, I have been generate an .so file. Will the process still the same as .o and .hi files ?
Re partial functions: https://github.com/haskell/rfcs/pull/8
This is super cool, I‚Äôve wanted something like this for a long time but it‚Äôs fantastic to see just how powerful doing this eighth can actually be. This could also be the canonical example of how to do useful things with indexed traversals. Well done, this is fantastic.
I'm using it in instance declarations, so if I try that I get `Illegal type synonym family application in instance`.
[Zero Bullshit Haskell](https://github.com/alpacaaa/zero-bullshit-haskell)
Not even Perl has regexes this nice. Very slick.
I am assuming that this library exports "c style of symbols", without and kind of type encoded in their names or other information. You want to have a declaration that fits the symbol. (same name + argument list and return type). You then link with your compiler the shared object file. This is for C, I have no idea how Java works in that regard. PS: if you feel more adventorous, you can use dl to open the so and load it, then cast the void* to a function type that fits your function.
Ohh, cool, thanks!
I personally value the high quality of the coding assignments of [https://codesignal.com](https://codesignal.com). The basic functionality is free for a developer. Remember, you can learn a lot in comparing your solution with others'.
Change the class to say `type` instead of `data`.
Thank you, I have been able to use dlopen to load. What do you mean in term of adventurous? is this not a good practice to do ?
Seems reasonable. I‚Äôve only accidentally used the single-threaded RTS.
I dont know if it's good or not, it's a bit more complicated to setup for cross platform and you need some more code.
While this is all great nerd fun right now with type-level programming, I am simply sitting this period of time out where Haskell does not yet have dependent types. Unless I need such capabilities for work ;)
Multiple new positions available at Assistant/Associate Professor level in Nottingham. We are keen to receive applications from excellent FP candidates! Closing date 8th July 2019. Please share. http://www.cs.nott.ac.uk/\~pszgmh/advert.html
Me too, moreover, my accidental discover that isn't enabled by default cost me hours of debugging some time ago (but that's me, it's not statistically relevant).
I recall that somebody mentioned previously that `-threaded` by default is a bad default, but I would like to see more proofs and research on this: * https://www.reddit.com/r/haskell/comments/a1skcb/ann_summoner120_tui_better_scaffolding/eauyb0d/
Nothing in the lens library breaks if you don't pass the laws. The only thing that happens is the convention I follow in the library of always fusing things together rather than, say, doing one pass to read and another pass to write becomes "exposable", whereas if you pass the laws you can't care if I do something like get from you then set in another pass or if i fuse. The laws are there so you know you can fuse passes. Each combinator when reasoned about operationally will generally do something sane even for lenses that ignore laws.
I really appreciate the hspec style readme!
Thanks for the clarification üòÑ; Always figured they were more "suggestions" than actual laws, nice to hear it from the source üëç; looking forward to having a beer or two at Monadic Party, cheers! üçª
[https://www.reddit.com/r/haskell/comments/8ll6zz/building\_forum\_software/](https://www.reddit.com/r/haskell/comments/8ll6zz/building_forum_software/)
Link in comment is broken, works in main post.
This needs some rigorous benchmarking, I think.
The container analogy of Functors only gets you so far tbh. `mapM` maps over a traversable and monadically combines the results so you end up with a single monadic action, rather than a list of monadic actions. This is straightforward in many cases: ``` fmap print "abc" = [print 'a', print 'b', print 'c'] -- ghci can't show this unfortunately mapM print "abc" = [(), (), ()] -- and prints 'a', 'b' and 'c' while collecting these ``` Now try predicting the results for the following before running them in ghci: ``` pair a = [a, succ a] -- 'a' -&gt; "ab", 1 -&gt; [1, 2] fmap pair "abc" -- this shouldn't be too hard mapM pair "abc" -- give this some thought before trying it out ``` `mapM = traverse = sequenceA . fmap` btw.
Here are the experiences I had with threaded RTS not being default as a new haskell user: * I was using System.Cmd.Utils from MissingH and my program was working fine; I enabled -threaded and stuff started to hang. It turns out that module forks in an unsafe way; the non-threaded RTS was masking its bug. (Switched to process.) * For a while my program built with -threaded on some systems and without it on others (architectures where the ghc RTS did not support threaded at the time). This led a bug where code that worked with -threaded was deadlocking with the non-threaded runtime. (I think all architectures support -threaded now.) Overall, this was one of the ugliest parts of starting to use haskell, and a large time sink since I kept struggling with deadlocks that occurred with one runtime and not with the other.
Trying to compile class DirectProduct a where type Prod a :: * -&gt; * f :: a -&gt; a instance (Eq a, Eq b) =&gt; Eq (Prod a b) gives error: ‚Ä¢ Illegal type synonym family application in instance: Prod a b ‚Ä¢ In the instance declaration for ‚ÄòEq (Prod a b)‚Äô Sorry if there's something obvious I'm missing, I only just started trying to learn about TypeFamilies and they're still a little opaque to me.
Okay. So when you have an associated `data` declaration in a class, you're forcing each instance to define a brand new type with it's own constructors and everything. When you use `type`, the instances just need to define a type synonym. You can still define a new type outside of the instance and then just refer to it inside the instance. So: ``` class MyClass a where data MyType a :: * instance MyClass Int where data MyType Int = MyIntType ``` is the same as ``` class MyClass a where type MyType a :: * data MyIntType = MyIntType instance MyClass Int where type MyType Int = MyIntType ``` The difference is only where I'm defining the actual type. The advantage of an associated `type` is that I'm not _forced_ to define a new type. I could have just as well written ``` instance MyClass Int where type MyType Int = () ``` and reused the `()` type. Now the issue you mention is interesting. I would have thought that your code wouldn't work even with a `data` declaration, but it does. I'm guessing it's got something to do with injectivity. In any case, how would you implement that `Eq` instance if you don't know the concrete type of `a`?
I haven‚Äôt heard of MissingH for like 5 years. I feel like there was a time where there was only a single Haskell library, and it was MissingH. Don‚Äôt use MissingH
If we do this, can we also disable parallel GC by default when compiling with \`-threaded\`, i.e. implicitly add the (\`-qg\` flag) ? [https://twitter.com/ProgrammerDude/status/884072548954247168](https://twitter.com/ProgrammerDude/status/884072548954247168)
Same here. First time I ever used ForkIO I was very confused. I'd imagine most of us have had a similar revelation.
What are you trying to express using that instance? If you want to say that instances must pick a definition for `Prod` which have an `(==)` instance, you can write class Eq (Prod a b) =&gt; DirectProduct a b where type Prod a b
Thanks, that was very helpful! In the case of a direct product, a ‚äó b = c ‚äó d if and only if a = b and c = d, so using the top level definition I would implement it as instance (Eq a, Eq b) =&gt; Eq (Product a b) where a == b = projl a == projl b &amp;&amp; projr a == projr b
Does threaded rts still burn tons of CPU time with (what I presume are) spinlocks? I had a program using stm and threads that should've been IO bound, but it used a *ton* of cpu time on every core that just vanished when I made it single-capability
With an associated `type` you can just use the normal `(,)` pair as your type. The `Eq` instance on it is the one you want anyways.
&gt; Is the problem they're alluding to the fact that all the output is dumped into memory at once? Based on that wording in the docs, I'd say yes. And I don't see anything wrong with using a streaming library of you want to stream the output of the command.
The problem you most likely ran into is that with -threaded GHC also uses parallel GC which if you run with large numbers of capabilities (i.e. threads) runs into super high lock contention and poor performance. If you disable parallel GC your problem would probably be fixed.
There's two similar cases and for one of them this works perfectly, thank you for pointing it out!
Darwin266 pointed out that what I want from a direct product is just `(,)`. Trying to look at my other structure the same way, it looks like I separately also want a way to lift a `Monoid` to an `Applicative`, ie data MyType a b = MyType a b instance Monoid a =&gt; Applicative (MyType a) where pure x = MyType mempty x MyType f g &lt;*&gt; MyType x y = MyType (f &lt;&gt; x) (g $ y) so I'll dig through the docs for something like that.
For java, perhaps you can use the Eta compiler to compile directly to .class files? Eta is basically haskell for jvm, with some syntax for exporting functions so you can call them from your java code.
I highly recommend checking out [typed-process](http://hackage.haskell.org/package/typed-process), preferably via the [helpful tutorial](https://haskell.fpcomplete.com/library/typed-process); it makes dealing with this sort of stuff a lot nicer IMO. As a bonus, it has very convenient integration with Conduit via [this module](http://hackage.haskell.org/package/conduit-extra-1.3.1.1/docs/Data-Conduit-Process-Typed.html). This combination of libraries means you‚Äôre going to minimize how much lazy I/O you may potentially run into and should make it much easier to stream things without worrying about memory.
This should be the default imo.
"Lots of output" is still a couple thousand lines at most, isn't it? If so, any streaming solution is overkill; just read everything into memory and be done with it.
I suspect you're right. I'd guess that a git repo with thousands of tags would be a relatively rare thing.
Is a gameplay video available?
I might be missing something obvious here. But if the program is interactive, won't the `readProcess` call block indefinitely because the wrapped program might be waiting on user input on stdin? Isn't that what makes the `readProcess` function unsuitable for interactive programs?
Probably. The docs explain that it blocks until the spawned process terminates. OP is making a CLI tool though, so waiting on that might be OK? The bit about strictness definitely reads as suggesting the function accumulates *all* of the stdout output as a single value before returning. Both properties could potentially be problematic.
In my GHCi 1.06 it works without any brackets or '$'. 1:[2,3,5] ++ [4,6,10] \[1,2,3,5,4,6,10\]
On a related topic, do any free monad libraries use this definition? newtype Free f a = Free { runFree :: forall m. Monad m =&gt; (forall x. f x -&gt; m x) -&gt; m a } instance Functor (Free f) where fmap f (Free g) = Free $ \h -&gt; fmap f (g h) instance Applicative (Free f) where pure a = Free $ \_ -&gt; pure a Free ff &lt;*&gt; Free fa = Free $ \h -&gt; ff h &lt;*&gt; fa h instance Monad (Free f) where Free fa &gt;&gt;= g = Free $ \h -&gt; fa h &gt;&gt;= \a -&gt; runFree (g a) h Or, with the power of `QuantifiedConstraints`: newtype Free cls f a = Free { runFree :: forall g. cls g =&gt; (forall x. f x -&gt; g x) -&gt; g a } instance (forall g. cls g =&gt; Functor g) =&gt; Functor cls (Free f) where fmap f (Free g) = Free $ \h -&gt; fmap f (g h) instance (forall g. cls g =&gt; Applicative g) =&gt; Applicative (Free cls f) where pure a = Free $ \_ -&gt; pure a Free ff &lt;*&gt; Free fa = Free $ \h -&gt; ff h &lt;*&gt; fa h instance (forall g. cls g =&gt; Monad g) =&gt; Monad (Free cls f) where Free fa &gt;&gt;= g = Free $ \h -&gt; fa h &gt;&gt;= \a -&gt; runFree (g a) h
Use miso and nix. https://haskell-miso.org, it‚Äôs easy fast and featureful. We have 5 internal websites at my current co. written with it. Highly concurrent websocket interaction, visualization with d3.js, deeply nested components, lens-based interface. Works great. https://polimorphic.com is a public facing website written with miso. Payload size is a cost you only pay for once, and it‚Äôs a transparent cost if you prerender. Type sharing makes a huge difference. We have 50-100 Ajax endpoints, writing that by hand would have really sucked. Servant client ghcjs generates it all for you.
Yes, there are a few on my Youtube channel. The link below is to the most recent and is taken from the demo level. &amp;#x200B; [https://youtu.be/-\_I3zw2RPRM](https://youtu.be/-_I3zw2RPRM) &amp;#x200B; I'd like to add that I've just updated the release, as I've discovered a bug that meant it could crash at unpredictable times. I've disabled the non - player character in the level (as this was identified as the source of the problem) and will patch this problem in the next commit. I've also added a Linux binary. Thanks for your interest.
GHCJS is 10000% overkill if your goal is a mostly static site. Unless there's a *lot* of JavaScript you need to write I'd probably just use vanilla JS.
For static websites there is also [Hakyll](https://github.com/jaspervdj/hakyll).
The application you are communicating with (`git ls-remote --tags`) is not interactive, so I fail to see the problem.
The "traditional " approach would be use to JNI. You'd have to write some C code, since the JVM will call very specific symbols based on the `native` decorator on a method, and you'll provide those specific symbols in your C code and call into the Haskell generated symbols.
&gt; Some have said Reflex can do this I use Miso for small things &gt; GHCJS but that repo hasn't been updated in years If you are referring to GHCJS, the development takes place on other branches. &gt; The point is this stuff is esoteric, few people are doing it, and it's badly documented. Mostly true, but there are people doing it. &gt; It's however easy to call PureScript code from JS. It's highly supported and everybody is doing it. Why not try PureScript? The main advantages of Haskell are libraries and laziness. If you don't make use of lazy data structures, PureScript is a wonderful choice.
That can cause other problems.
Quite the opposite in my case: I usually turn off the threaded RTS, unless I'm doing something where I explicitly need it (e.g. a web app, a test suite).
Not really. The `do` desugaring doesn't "push in" to sub-expressions, it always stays right before a statement. * `do expr` --&gt; `expr` * `do { var &lt;- expr; block }` --&gt; `expr &gt;&gt;= \var -&gt; do block` * `do { let binds; block }` --&gt; `let binds in do block` * `do { expr; block }` --&gt; `do { _ &lt;- expr; block }`
I‚Äôm curious about what these could be.
+1 for Miso. I recently started using it for a small side project at work. As someone with pretty limited web experience (but plenty of Haskell experience) I found it very easy to get started with. There are plenty of high quality examples available.
Out of interest: I count 4 professors and 7 postgraduates. Isn‚Äòt the ratio of postgrads to profs a bit low? Is this deliberate or normal for the UK?
JS is a bad compile target. JS wasn't created to be a compile target. It's not an assembly language, and it never will be, no matter how fashionable it has become to abuse the shit out of it. If you have architectural needs that are so incredibly complex that you can tolerate the downsides of compiling a completely separate language with it's own runtime into JS, then great, do it. If you don't have extremely complex front end architecture, then don't. Please. Your users deserve better.
That's the representation /u/isovector [started with](https://reasonablypolymorphic.com/blog/too-fast-too-free/) in the work which eventually became polysemy. It's barely recognizable though, [it's now called "Yo" and it's a free Effect rather than a free Monad](https://github.com/isovector/polysemy/blob/f909f493d0481a7b65ea8e296607c84f3b56aee4/src/Polysemy/Internal/Union.hs#L56-L63).
This kind of ratio is fairly normal. In theoretical computer science most advisors have around 1-3 PhD students. We‚Äôve had a quite a few students complete their PhDs recently, and are looking to ramp up our PhD recruitment over the next few years. Hope this helps!
GHC Haskell is already a significant tech choice that moves you far away from the mainstream. Layering two more monsters over that (Nix and GHCJS) in order to get a website with a little optional JS doesn't seem like a good idea to me. Not saying that either Nix or GHCJS are bad tools, naturally.
Cool! I knew I must have picked it up somewhere. I thought about it when I read /u/Iceland_jack tweeting about a similar free expression for Monoids. That made me realize there's a whole family of such free constructors: newtype Free0 cls a = Free0 { runFree0 :: cls b =&gt; (a -&gt; b) -&gt; b } newtype Free1 cls f a = Free1 { runFree1 :: cls g =&gt; (forall x. f x -&gt; g x) -&gt; g a } newtype Free2 cls f a b = Free2 { runFree2 :: cls g =&gt; (forall x y. f x y -&gt; g x y) -&gt; g a b } -- ... though there's no direct way to express the poly-kinded data type newtype Free arr cls a {..} = Free { runFree :: cls b =&gt; (a `arr` b) -&gt; b {..} } at least, not yet. I'll put it on my wish list, right next to poly-kinded `Compose` newtype Compose f g a {..} = Compose { getCompose :: f (g a) {..} }
&gt;We have 75-100 AJAX endpoints, writing that by hand would have really sucked. Servant-client-ghcjs generates it all for you. &amp;#x200B; We have over 600 endpoints, and we generate well-typed PureScript clients for all of them using `servant-foreign`. So for us, type-sharing is really not an issue. *Code-sharing* more generally, mind you - that's another story. I would consider GHCJS for the ability to share logic between client and server if we needed more of that sort of thing, but as it is, we have managed to avoid the need for it, for the most part.
It isn't clear to me this is a "little optional js", he writes immediately after, &gt;Only later write JS to enrich the site and make it more feature-complete.
The third big advantage of Haskell over PureScript is codesharing. But otherwise agree with your points.
That's pretty sweet. Come to think of it, there isn't much logic that we share on the frontend either, besides the usual dependencies.. but being able to use Haskell's concurrency on the front end is pretty nice, along with the aeson instances for serialization, unsure how servant-foreign handles that. Has there ever been an issue with forgetting to regenerate the clients? If so, is it even a big deal? Been meaning to try purescript out, looks pretty great.
Am I right in thinking that call = liftF . liftCoyoneda interpret = foldFree if one uses `Free (Coyoneda f)` as one's freer monad? Looks right to me at least. But I'm about to fall asleep, so who knows.
interesting. Thanks!
&gt; JS is a bad compile target. &gt; &gt; JS wasn't created to be a compile target. It's not an assembly language, and it never will be, no matter how fashionable it has become to abuse the shit out of it. I mean, the entire browser DOM is a kinda stupid UI paradigm for the highly-non-static stuff people do with it these days. Aside from a few specific cases like video, the builtin widget primitives are all wrong - there's no way to specify how you want to composite or when you want to render, there's no builtin multi-item view with proper (de-)allocation semantics, etc. etc. It's why everything is so slow, resource-hoggy, and bloated. Anyway, to your point, IMO JS is a significantly less terrible compile target (at least for high-level languages) than the DOM is a UI paradigm. Other than perhaps the initial download latency, I don't think the performance hit you'll get from compiling to JS is going to be a big issue in most cases; I think the performance problems will come from the things I mentioned in the first paragraph. So yeah, I say go ahead and write your webapp in Purescript or Haskell. It will be slow and resource hungry and bloated, but it's not because of the cross-compilation, it's because of the shitty primitives the browser provides you with in the first place.
Not entirely sure because I didn't dig deeper, but it crashed a Yesod web app when I ran it without the parallel GC and then tried to test how many req/s it got. So: the worst-case scenario is you crash previously working programs.
I like using Elm. Its simple to use, well documented and small in scope. Elm-ui does a good job of abstracting away CSS. There's a gadget for [generating static html](https://korban.net/posts/elm/2019-04-16-elmstatic-upgraded-elm-019/).
Purescript on the server isn't that well supported yet, but there's no reason why you can't.
That just sounds like a waste and I hope it doesn‚Äôt become a thing. Either no one would use it or it would fracture the Haskell community.
Yes -- we could just make `Constraint` and `Type` two different, utterly unrelated kinds. This also means having at least three `(-&gt;)` types (I don't think we ever take a `Type` and return a `Constraint`). It would be doable. However, with this one-member class encoding, we have a major problem: a newtype needs to have the same kind as its representation type (because kinds tell GHC how to represent a data argument at runtime, and newtypes are erased), and there's no correct answer for one-member classes. It sounds like a minor thing, but we really have been unable to come up with a simpler solution!
Thousands of tags would be perfectly fine. Revisit it when you regularly have more than a million.
&gt;Has there ever been an issue with forgetting to regenerate the clients? If so, is it even a big deal? I don't remember any serious problems, although it's probably happened at least once by now. It wouldn't be ideal if we did forget, so ideally we would test in our CI system to make sure we remembered.
I feel like there's some way to abuse a `Fold` type family to make the poly-kinded way work (for some definition of work), but I can't quite get my head around it.
&gt; would consider GHCJS for the ability to share logic between client and server if we needed more of that sort of thing, but as it is, we have managed to avoid the need for it, for the most part. (This is from experience in Scala + Scala.js, so take it for what it is. It **think** it should be reasonably generalizable) The single most important opportunity that I've found for code sharing like this was essentially input validation code -- making validation code consistent is often a huge pain, **but** if the bugs that could result from this are relatively minor (user gets a server rejection instead of immediate client feedback before submit), then it becomes much less compelling. It's still *extremely* nice to have, but it's hard to imagine this being a thing that breaks a product. Another important case is where it's desirable to 'predict' what the backend business logic will do and just optimistically do that while waiting for server replies. (I don't have concrete experience with this but it seems like it could be an extremely desirable property that the client/server code is 100% in sync).
Don't most things come with a test suite? Or, to be more explicit: It would seem that you would consider `-threaded` a good thing for test suites, and since most libraries *should* have a test suite, that would seem to indicate that it should be the default (because its a common case)?
As /u/dmjio says: This probably just means that -threaded + non-parallel GC is the correct default. Almost all CPUs (even phones!) these days have multiple cores. If the -threaded runtime causes issues then that means that those issues should be *fixed*... it's absurd that the runtime for a language where parallelism + concurrency are almost trivial should have such issues (yes, it's programmed in C, I get it). I think switching defaults could represent a commitment to fixing them. This is obviously not exactly "trivial", but if the first step towards fixing the majority of the issues is basically just a matter of disabling parallel GC, then that seems like a good way to proceed and commit.
It wont become a thing. Haskell is good enough. (And I say that as someone who is looking forward to a future using PureScript). Besides code sharing is overrated. I've been a front-end engineer for over 10 yrs and I can count the number of times it would have been useful on one hand. Otherwise the overhead is not worth it. If it is then you're probably offloading way too much onto the browser. Someone above mentioned the only reason which is form validation. But even that is only useful in enterprisey/B2B apps with a ton of generic forms. Which can be solved with a good JSON validation -&gt; HTML form parser written in JS, which I recently did by hand in Vue.js. 99% of input validation falls under a few data types (exists, length, within an array, etc). It's super easy to make that generic and repeatable for any model you create.
&gt; there's no builtin multi-item view with proper (de-)allocation semantics, etc. etc. Is there anything like this coming in the web spec?
Afaik no. If you‚Äôre familiar with iOS dev, something akin to their table or collection view is what I have in mind. The API there is archaic and non-fp, but the general idea is good and makes proper use of drawing primitives. You can feel the difference between scrolling through a large list of items in a native iOS app vs scrolling through an infinite scroll on web. The former tends to perform at a constant speed, while the latter drags slower and slower until you just have to kill the tab. It would be great to have a primitive like that on the web, but I just don‚Äôt see it happening‚Äîlargely because the web tends to incentivize devs to have dynamically-sized content whereas iOS makes it more natural to have fixed-size content.
Yeah it's such a common UI element I could see it being a useful component on the web. Especially with dynamic adding/deleting concept being factored into the spec. It's a good idea.
We use a massive amount of codesharing at our company. We use Miso so all the views are shared between the frontend and backend so that we get the benefits of an SPA but also SSR. Also all the data types are shared and various convenience functions that manipulate them are shared. Also the Servant API is shared for obvious reasons.
What type of service do you provide? Complex B2B forms ala Hubspot or Zapier? I've never seen any good use of generated JS on the frontend w/ code/type sharing. GMail and adwords was always the example of how it *used* to be done in the past. To me it sounds like an backend engineer's solution to a front-end problem which could be better served by building out a proper front-end. And I say that with some bias as a fullstack but mostly frontend person. Even the political website linked above looks like it was built with zero frontend people involved (from the various non-standard web UI patterns to the general design). It also loaded really slow on multiple occasions where it was obvious a JS-heavy frontend was being used so the whole "big JS it only loads once thing" is a bit of a gloss over. Much like "cross platform web apps" being used on mobile it always is 90% of the way there. While the last 10% is all the difference in the details. Front-ends should be built from the ground up with the web and browsers in mind. The fact you can get code to run in a browser is not sufficient IMO. Although I will say it's possible not enough eye-balls and open source work has been given to generated-JS like GHCJS, so it still could have potential, I'm just not convinced.
Without codesharing you can‚Äôt have both an SPA and SSR as far as I am aware, and that‚Äôs kind of a nice combination that is very popular these days. Lmao the political website is ours. Honestly most feedback on our UI has been positive, although it‚Äôs currently only two full time devs and my background is full stack and PL and my cofounder‚Äôs isn‚Äôt frontend heavy either. What complaints do you have specifically?
How would you go about having both an SPA and also SSR without codesharing your views?
I'll give the site a run over shortly and post a better critique in another comment once I'm off mobile. BTW, for practical reasons it's not always a bad thing to make compromises like that to get something done. For small teams with only a couple of backend people it can make sense. But I still don't see it as an ideal long-term solution given the option of hiring front-end people. I'm intimately familiar with backend guys who want to cling onto their superior toolset/knowledge when forced to deal with the browser (which I get because JS sucks for large scale projects, but the 'solution' is still a often workaround and compromise).
Why have a functional language support IO at all? Maybe we should have an impure language that defines GUIs and embeds a totally pure DSL for the actual program logic?
Not a project-based per se, but https://exercism.io/tracks/haskell is very hands on
While I am not a member of the Haskell Prime committee, as far as I can tell things have largely stalled. This is unfortunate but quite understandable; it takes a lot of focus to keep a standardization process moving and people are generally busy.
I recommend lucid and scotty. That was a winning combination for me. Miso is also nice but I haven't used it much. Reflex is hard because it's complicated enough to practically be its own domain specific language, it takes a lot a time and effort to learn and get the hang of (full disclosure, I have not learned much of it)
I guess I wouldn't, but I was responding to the claim that "this is what separates ghcjs from elm / purescript". Personally, if I were considering a hybrid SSR approach, I'd want to look more closely at incremental rendering (keep the model on the front-end, send model changes to the server, and receive DOM patches in return) in order to keep things as compositional as possible.
&gt; If it is then you're probably offloading way too much onto the browser. I find this a surprising sentiment. SPAs are the current trend in the web industry which explicitly aims to offload as much to the browser as possible. Am I misunderstanding your point or do you think SPAs are not a good idea in general? All that validation you talk of sounds like a really hacky, manual alternative to simply sharing data types between the front end and backend and leaving the type system to ensure you have in all correct. Aside from forms, if your web app is heavy on xmlhttprequests (such as in the aforementioned SPAs) then code sharing of those data types is going to pay itself off increasingly quickly.
&gt; Is the later step this simplifies renaming before beta reduction? Yes, if all your variable names are already unique, there's no need to rename variables during beta-reduction. Personally, I always convert to nameless form (De Bujin) as quickly as possible. It doesn't actually help with beta-reduction, but I find contexts being `Vect n Type` instead of `Text -&gt; Maybe Type` a bit nicer for typing.
https://hackage.haskell.org/package/godot-haskell aims to be the Haskell game engine.
At CollegeVine we also use Haskell on the backend and PureScript on the frontend. We keep our canonical types in Haskell and generate PureScript from it. Now that our backend and frontend code are in a monorepo we use Git to verify that the PureScript generated types‚Äô SHA is the same age or newer as the Haskell types. This saves us from shipping incompatible frontend + backend. &amp;#x200B; However, long-term, you‚Äôll want to be careful about breaking API changes. Even with a monorepo you don‚Äôt really get atomic deploys, meaning the frontend and backend deploy at the exact same time. In addition, if users have active sessions with stale client code, you want to make sure they don‚Äôt get runtime errors from the newer backend code. &amp;#x200B; Overall, using Haskell on the backend and PureScript on the frontend has worked really well for us :)
If you want other options that are a bit closer to mainstream languages, I've been rather impressed by typescript recently. If you've used javascript, you can be productive in typescript (it really is just statically typed javascript), and the type system is actually pretty impressive. If you enable all of the optional strict options, you get a lot of the safety guarantees that haskell gives you. If you want an example of cool stuff that typescript gives you and haskell doesn't (by default, at least), look at this function: function test(i: number): boolean { return i !== 1 || i === 2; } In typescript, the `i === 2` bit is a type error, because it knows that in order to get to that branch of the code, i must be 1. The flip side is that haskell does check some things that typescript doesn't, and haskell gives you easy access to a bunch of powerful abstractions (with monads being the most well known one). These tools can be extremely helpful, but if they are part of why haskell is confusing to you, then typescript might well be a very practical alternative.
Here's a paper by the Simons on the topic: [https://www.microsoft.com/en-us/research/wp-content/uploads/2002/07/inline.pdf](https://www.microsoft.com/en-us/research/wp-content/uploads/2002/07/inline.pdf) . You can alpha convert (to unique names as in this paper, or to a nameless form) to simplify future inlining steps. There might not even be beta reduction in the this intermediate language if you compile (but there will be if you interpret).
Let me know when you find a language with HKTs. Then, you might have found one with the type-safety of Haskell. Wrapping some boilerplate into a free monad or exposing a sufficiently generic lens to prevent double-walk of a structure are just a couple of the reasons I've reached for HKTs when writing in JS, Python, and Java recently. I certainly delivered something in those cases without using HKTs, but it was either not a reusable, not as efficient, or not as easy to use as it could have been. --- As far as Rust goes, you have to do manual memory management, at least enough to satisfy the compiler that nothing is used outside of it's lifetime. Most checks can be delayed to runtime if you prefer (but that means those checks have a runtime cost). It's a fine language with very low overhead, and a much nicer macro system than C. Haskell is very high level in comparison.
Most people don't think full-blown SPAs are a good idea, it's hardly mainstream. Do you have examples of SPAs that are widely deployed? Instagram is the only one I know that went full React but that's because it's just an online version of the web app and a simple one at that. That's the type of thing its best for. Almost every *good* web app team uses a balance of both. Browsers simply can't handle a ton of JS routes across multiple "pages". It's clunky. Even with tons of fine tuning they still have issues with history, web accessibility, often breaks form-fillers like Lastpass, etc, etc. React et all provide a strong foundation for building complex UI components mixed within a static/server rendered page. I was one of the first people on Backbone.js IRC in 2009 which was the first framework to really allow you to do SPAs and even then it wasn't the end-goal. It almost always a balance between both front-end and back-end. Even the hardcore React.js and Vue.js people I follow rarely build SPAs. They almost always are building "components" that get mixed into an existing page. IMO validation is best handled server side. I don't see the point in replicating it locally. The validation I'm talking about doesn't involve replicating full types/objects on the client-side. I'm talking about parsing a simple JSON response from a POST/PUT from the server and populating validation/error messages inline with a form and the inputs (which again is 99% of the time just a red outline + some text with some variations on styling for inputs, select boxes, radio, or multi-item lists). The models that I do replicate are often 10-20% of the size of the server side model since they are mostly just a hash + some helpers for rendering it (since the app is limited to being the interface). If I actually copied the full objects w/ types from the server that would increase the data transited (and stored by the browser) by 90%. Instead all JSON content delivered to the front-end is strictly what is needed to render the UI (basically GraphQL but through a much simpler serializer pattern) or needed to create/edit an object. This is just one example of the overhead I'm talking about.
polimorphic.com is 18.37MB of JS, 57kB of static HTML, and 252kB of everything else. That's a terrifying amount of weight for a page with less than two full screens of CTA. Hell, the "everything else alone" is overweight for what the content is. For someone who wanted JS as a progressive enhancement, that site is about the worst example possible of lightweight.
&gt; Payload size is a cost you only pay for once Until you update the code in literally any way which will change the giant blob of JS and bust the entire thing all at once. &gt; it‚Äôs a transparent cost if you prerender (gzipping and closure compiling help too). It's not transparent to mobile users, limited data users, people on slow connections, or people with slower computers/devices.
&gt; I am starting to ask myself whether there are not useful type safe alternatives to Haskell when it comes to build backend/frontends. On the frontend, certainly. And on the backend as well, but there is no reason to avoid Haskell on the backend. &gt; Are there experiences how Haskell does fare against Rust in the backend domain? I would be interested to know how much additional boilerplate code and memory management is forced upon the programmer when using Rust. I don't keep up with the Rust ecosystem, but when I last looked Haskell's ecosystem (incl. Servant) was more mature. Rust doesn't exactly force memory management, but the language is much less laconic (and part of the reason is indeed the memory model). &gt; What kind of type safe alternatives should I consider? F#? Julia? I love the actor concept of Erlang, but I would prefer not to use a dynamically typed language. I am less familiar with these. I do not think Julia is designed for web services. F# is "Microsoft OCaml" and it does not get new functional programming libraries as fast as Haskell.
`Free0` is in free-functor :) (which is the same "functor" as in "free monad functor", not to be confused with the "free functor" `Coyoneda f`) https://hackage.haskell.org/package/free-functors-1.0.1/docs/Data-Functor-Free.html
&gt; GHC Haskell is already a significant tech choice that moves you far away from the mainstream Not really a bad choice for web backends at all. I don't think it's something that needs to be justified.
If it had a compiler that optimized as well as GHC. But as of writing it does not.
Sandy Maguire wrote a [blog post](https://reasonablypolymorphic.com/blog/elm-is-wrong/) on all the problems with Elm. I thought it was harsh at first, but after writing a little elm, everything there is completely justified and it's only gotten worse.
&gt; since most libraries should have a test suite, that would seem to indicate that it should be the default No. Plenty of executables are not test suites.
IMO, it's primary advantage is that you can implement stuff faster in haskell than you can in c or python, while also having better performance than python outside of certain very specific use cases. Maybe you'll take 10x longer when you are learning haskell, but once you get through that learning curve, you'll be able to write code faster, and that code will have fewer errors.
You are not the only one to request this; see [#14502](https://gitlab.haskell.org/ghc/ghc/issues/14502). Spurred by this request I've put together the beginnings of binary distribution support for our CI. I'll try to get this finished up for 8.10.
If you are trying to get something done right now and you don't have any haskell experience, then haskell is a terrible choice. This is true for basically every language in existence -- if you had no python experience and had to get somethign done right now, python would be a bad option. This is more true for haskell than it is for many other languages, because haskell is further from the mainstream than most other languages. However, this still isn't an issue that is unique to haskell. The selling point of haskell is that it is very good for a wide variety of (high level) tasks once you get up to speed in it. However, you do need to spend time getting up to speed before you can realize those benefits.
That's almost right! ``` foldFree :: Monad m =&gt; (Coyoneda f ~&gt; m) -&gt; (Free (Coyoneda f) ~&gt; m) interpret :: Monad m =&gt; (f ~&gt; m) -&gt; (Free (Coyoneda f) ~&gt; m) interpret f = foldFree (lowerCoyoneda . hoistCoyoneda f) -- or foldFree (\(Coyoneda k u) -&gt; fmap k (f u)) ```
I'm still trying to puzzle some things out. [This stack exchange answer](https://math.stackexchange.com/questions/2373993/is-alpha-conversion-needed/2374043#2374043) provides interesting thinking material. It also provides an example of when alpha conversion to unique argument names still leaves an expression vulnerable to variable capture: `(\x. xx) (\a. \b. ab)`. However, in the context of a real compiler this might not be a problem, for instance Haskell's typechecker would forbid `(\x -&gt; xx)`. I wonder if there's a similar example that would get past the typechecker?
IMO, if you are comfortable in haskell, you don't need c-level performance, haskell has enough libraries relevant to your problem, and any co-workers you have know or are willing to invest time into learning haskell, then it is just sort of better than python. If all of those conditions hold, there are very few things that I wouldn't rather do in haskell. On the other hand, if you aren't comfortable in haskell already, then you will have to invest a fair amount of time into learning haskell before you will be productive in it. If you do need c-level performance, then you sort of need c. If python has really good libraries for your problem domain and haskell doesn't, that can potentially outweigh the baseline productivity differences between haskell and python. And if you are one person in a team and no one else is willing to use/learn haskell, then working in haskell will sort of fuck over your team if/when someone else has to deal with your code.
So sad! Well go program in something else then.
If the root of this were that the DOM is just inherently slow, then the delta between JS performance and 'X language compiled to JS' would be relatively small - It isn't. Purescript and GHCJS are MUCH, MUCH slower. JS isn't browser bytecode built to support arbitrary operations on primitives. Unfortunately, that API does not exist. Instead, you end up targeting a higher level API with it's own conflicting assumptions about semantics, by proxy, which is exactly as inefficient as you'd think it would be. You can blame the limitations of the DOM API if you want to- The program runtime is certainly going to be spending a lot of unnecessary time manipulating the DOM. But I don't think it's at all accurate to blame the DOM API for that performance hit when the sole "native consumer" of the API executes operations 4-5x faster. So, really, the absolute best you could say for compiling to JS as a paradigm, if we're going to label the DOM as the source of inefficiency , is that we have identified a surefire mechanism for making an already bad situation drastically worse.
\&gt; 20.05 MB / 4.35 MB transferred
I'm doing next year my MSc dissertation in University of Minho and I'm curious if you can share any ideas for a dissertation that's around functional programming and formal method in software engineering! Thank you!
I would personally not be open to such an approach. It adds extra unnecessary networking and server load.
I think what you describe is roughly the state of affairs in Haskell today, right? Where ‚Äúimpure language‚Äù = IO and DSL = ‚Äúpure Haskell code‚Äù. But don‚Äôt you eventually want a file system and outputs to disk or network? The old joke was that a completely purely functional language is undetectable ‚Äî whether it evaluated or not, it couldn‚Äôt affect anything.
If it doesn't typecheck, maybe it's because it doesn't have enough types :) Does this work? data T = Abs { app :: T -&gt; T } f = (\x -&gt; x (Abs . x . app)) (\a b -&gt; a b)
I do.
I don't share the opinion that `-threaded` is a bad default. Any program that uses `forkIO` and calls blocking FFI code essentially needs `-threaded` to work correctly as expected (with the two IO actions running concurrently). It is equally important to allow interrupting IO with functions like `timeout`. The fact that `timeout` works in some cases in the non-threaded RTS is a [lucky accident](https://phabricator.haskell.org/D42#118444) (this link is me taking a deep look at the threaded and nonthreaded RTSs to fix Haskell interruptibility problems for a client, and learning from Simon Marlow why things work the way they do). In general, many programs work on non-threaded on Linux only because of "lucky accidents". On other OSs those break, and once we improve how e.g. the signal works on non-threaded, they will likely also break on Linux. You can use non-threaded when you have full control over any FFI calls that the program makes. If that is not the case (e.g. you use some library that does IO, and it is reasonable to assume that most programs do that), then `-threaded` is likely a more correct default. That said, I do share the observation that non-threaded can give significantly better performance in some cases. It is also easier to debug most Haskell programs on non-threaded (single-threaded cooperative multitasking programs are always easier to debug than multi-threaded preemptive ones), and it makes many programs more deterministic. For these reasons, non-threaded should continue to be supported in GHC, and all libraries that can should strive to work very well on non-threaded.
That's a fair perspective. Ideally, though, I'd like to push the purity as far out as possible. Conceptually, it would be nice to have the OS kernel be the only impure code running. Thus, programs would not have any IO Monad, they'd simply be of type (KernelInput, ProgramState) -&gt; (KernelOutput, ProgramState) And that function would be continuously rerun until KernelOutput contained some flag that indicated the program was done.
Eta Language looks potential and interesting, I may give it a try. Do you think using Eta will be complicated for a big Stack Haskell project consisting of different modules ?
Investing time isn't an issue. But from all the other posts, I kind of fail to see why I would use Haskell for my job at all because it is apparently not good for computationally heavy tasks or BST operations. If the reason other users said its not a good fit is because the ecosystem isnt as large for it, well then thats silly. I didn't ask if the ecosystem was focused on it, I asked if the language would be good for it. I don't mind taking more time to write something rather than rely on the ecosystem (i.e. build a dataframe class vs using pandas). So if Haskell isn't a good language for my example, I'm curious what it is good for in practice other than cleaner code.
Thank you, so basically you create 2 bridge: Haskell -&gt; C -&gt; Java ? Is that right ?
I thought the docs were saying `readProcess` is unsuitable for use from within an interactive application. It didn't occur to me that they might mean it's unsuitable for _spawning_ an interactive process, but that would make sense, now that you mention it.
You still can't count on client and server being in sync unless you force refresh after every update of server logic.
When the docs referred to "interactive applications" I thought they were talking about the application that was calling `readProcess`, rather than the application be run via `readProcess`. Now I'm not entirely sure which they meant.
I used meteor in a project and they do this. It's pretty overrated. When the makers of meteor switched to making apollo graphql stuff they ditched this approach in favor of the client giving an "optimistic response" to use, one that assumes validation passes, and shares no code with the server.
Server side rendering can just be done as part of the systen that serves up the JavaScript, it runs the exact same code on the server to create the page. It's conceptually separate from the actual backend server in that sense. You can of course optimize things a bit so that calls to API servers bypass serialization and http and all that and run in process with the SSR.
I recall the boot camp / rails people adopting this approach at some point and saying and it worked well for them.
Ah shit. It turns out Brick doesn't work on Windows. The package 'unix' is not supported on Windows and that's why stack is yelling at me. I guess I will need to use a vm. Do you guys think procedure that I did to install it would work if I was using Linux?
See [call-haskell-from-anything](https://github.com/nh2/call-haskell-from-anything) for many resources and examples on this topic. Short summary: * Build `.so` file in Haskell. * Load it into your program, either by linking it dynamically or via `dlopen()`. * Call `hs_init()` ([Python example](https://github.com/nh2/call-haskell-from-anything/blob/550c25cbe67ba378c7bebf4df3a970ef5bfe7702/test.py#L19), [Ruby example](https://github.com/nh2/call-haskell-from-anything/blob/550c25cbe67ba378c7bebf4df3a970ef5bfe7702/test.rb#L47)). * You can now call functions that you `foreign export`ed from Haskell. * Call `hs_exit()` at the end.
I‚Äôm just putting a wild guess out there that this is not an efficient use of resources for all types of programs. Callbacks, for example, efficiently solves a domain of problems that I don‚Äôt think this could schema could.
&gt; [It's just a community thing, not many Haskellers are doing it, and hence the ecosystem can't compare with Python's.](https://www.reddit.com/r/haskell/comments/bwd54c/is_haskell_a_good_addition_for_me/epxcima/) If you look at what op was saying, it really is just "the haskell ecosystem for this stuff is sort of crappy". I don't do this sort of stuff myself, but from what I've heard, Python has some very good libraries for doing data science work, and haskell doesn't. If haskell had the same number of man hours invested into making it good at data science stuff, it would be better at it than python (imo, at least). However, it doesn't, and python's ecosystem will probably be more valuable than haskell's language-level superiority.
I'm trying to serve my elm .js file using yesod. My handler function looks like this: &amp;#x200B; `getRootR :: Handler Html` `getRootR = sendFile typeJavascript "static/main.js"` However it serves up the text when I run my server. Do I need to embed the file in Whamlet?
Very strange IMO. Basically puts an upper bound on how snappy your UI can be to no faster than an HTTP round trip.
&gt; with the required state stored in SQLite instead of a ST or IO monad This sentence is a bit confused. If you use SQLite, you are already using `iO`, because without IO you cannot communicate with SQLite. In general, if you want to store state beyond the life time of your running Haskell process, you will have to write it down into a file system one way or another. * Have very simple needs? Read in the whole state from disk, do modifications, write it back as a whole using [atomic, durable file writes](https://www.fpcomplete.com/blog/enhancing-file-durability-in-programs). * Need fine-grained access, protect against concurrent access from multiple processes, or concurrent transactions on the data? Use a database (like postgres) or database library (like sqlite) as suggested. * Need a DB written to concurrently from more than one process, or talked to by multiple machines over a network? Use postgres. Only 1 process? Use sqlite.
That blog post is very misguided..to say the least. It is like complaining that a surgical blade is wrong because it cannot chop wood. Like that that essay pick arbitrary tests and shows Elm fails at them. If it was listing things it encountered while developing a typical SPA, then I could have taken them seriously. We could then gauge how much the faults of ELM was costing the real project. Just saying you cannot all problems "as generally as possible" and holding against the language is quite stupid.
If you can use the nightly-2019-05-11 resolver, you'll get brick along with the snapshot, no need to bother with adding it (and transitive dependencies) to extra-deps.
Thanks, appreciate the explanation!
&gt;Until you update the code in literally any way which will change the giant blob of JS and bust the entire thing all at once. You can separate out the \`rts.js\` and other js deps that don't change often, these will get cached. Even if you do update the site, the landing page loads instantly while the js is fetched in the background. For a normal desktop user on an average connection, this works great. For a mobile user, you should probably make a proper mobile app instead, but [https://haskell-miso.org](https://haskell-miso.org) does load very fast for on my iPhone X and chrome gives it a good mobile website score as well. &gt;It's not transparent to mobile users, limited data users, people on slow connections, or people with slower computers/devices. Agreed, hence why I'm working on native. But slow connections / slow devices are unfortunate scenarios ... for any web framework, not just ones compiled with GHCJS. Also, take a look at the payload size of any large SaaS company, it's common to see a few megabytes.
&gt; you gotta pick the right tool for the job and sometimes, Haskell just ain't that tool Whether something is the right tool for the job depends largely on the people using it for that job. In isolation and assuming you have all other points covered, Haskell is almost always one of the best tools available for almost any job. But consider: * Are you a (team of?) advanced/expert Haskeller(s), thus getting large productivity benefits from using Haskell that exceed "time investment" into less commonly used tools? Use Haskell, and perhaps GHCJS. * Do you know nix very well, and the tradeoffs are in your favour? Then sure, may go for that too. * Beginner or intermediate at each? Get ready for a rough time and double-steep learning curve. Plan in 6 months full-time learning time to master these tools. Try to consider all the factors when making tech stack decisions. Where is your sweet spot between finishing quickly, developer productivity, using high quality programming languages, hacking and fixing your tools, code reuse, ecosystem buy-in, contributors, build speed, size of output, performance, fun and challenge? If you have time and nothing to lose, just try all the approaches and report back.
I'm not sure what you mean when you say resolver or snapshot but I'll look into it tomorrow.
Have you tried to minimize app size using https://prepack.io/?
Ah! I forgot to interpret the `Coyoneda` layer. I *knew* my brain was playing tricks on me somehow. Thanks!
purescript doesn't need to optimize as much as ghc, because as long as it produces reasonable javascript, the javascript jit will optimize it well enough. this is sorta like complaining that ghc passes unoptimized llvm-ir to the backend.
You need substructural type to make the operations sequential. However, it's still too verbose, so let's wrap the state into a monad ...
Except those are also just bindings. There's no reason why we shouldn't have another library with Haskell bindings to the unity game engine.
Reported upstream: https://github.com/haskell/process/issues/146
Actually the entire implementation of what we are talking about here is actually not implemented elsewhere, we had to do it ground up! But I see what you‚Äôre saying. So what are some examples of good use of Haskell in a numerical sense? Back in school, I was taught that FP languages were great for numerical problem sets.
Sure, I'm just saying that test suites are extremely common (perhaps even more so than 'real' executables if you consider all the libraries on Hackage) and so it might make sense to consider them the 'common case' which should be optimized for. Anyway, just a thought.
True, but that can be handled. Either by refresh, timing out sessions, or only making changes which allow for seamless upgrades. ... and as I pointed out you *will* still need a way to communicate server-side validation errors to the client no matter what you do. (There are some things that *cannot* be validated on the client, e.g. checks for duplicate user names or what have you.)
Interesting, but presumably they still have *some* basic validation client-side? (I'm thinking required fields, for example.)
&gt; Besides code sharing is overrated. I agree that sharing the code is mostly useless, at least to me. However, sharing the types is massively useful, because it extends the "Haskell refactoring experience" to the frontend.
There‚Äôs a lot of good material in the HPFFP book, but it‚Äôs very long, and even if you read the whole thing, you won‚Äôt really start to internalise a lot of things until you actually write your own programs. So I would consider closing the book for now, start a Scotty or a Spock project (eg one of many tutorials is from [Haskell At Work](https://haskell-at-work.com/episodes/2018-04-09-your-first-web-application-with-spock.html)) and try to just get a very basic version of the web app you want to write alive. (Haskell is a great choice for web backends.) Don‚Äôt worry if your code feels clunky, or cargo-culted without really understanding everything, or poorly structured. Just try to get something running. If you get stuck on anything (eg the monad transformer types in the callbacks will probably look confusing at the start) then ask your specific questions on the haskell-beginners Slack channel, and the super-helpful folks there will help get you unstuck. You can then refactor and iteratively refine your code one concept at a time, on a concrete foundation, which IMO is the best way to really learn Haskell. You‚Äôll also get a feeling for when you‚Äôre held back by a lack of theory, at which point you‚Äôll be motivated to go back to the book with a specific problem in mind. The first thousand lines of code are the hardest, so be gentle on yourself, but it‚Äôs worth struggling through. Good luck!
Regular function composition already allows you put *one thing* in at one end, put it through a series of modifications, and pull it out at the other end. So when I tried to invent the state monad from first principles, everything I came up with just desugared to plain old function composition, and I didn't get any extra state. I needed to realise that the state monad is about carrying an extra state *s* forward, in addition to the state *a* you already have from just passing data through functions. * *put* takes what you give it and stores it in *s* (*a* becomes () because you don't use *put*'s return value - just like *void* in other languages) * *get* reaches into *s* and copies it into *a*. Your instincts about things needing to be the same type are spot on, hence the types of *put* and *get*: `put :: s -&gt; State s ()` (If you can put in an *s*, then the stored state must have type *s.)* `get :: State s s` If you can pull out an s (the rightmost *s* on the line above), then you must have been storing an *s* (the left *s* above) *s* also has to stay the same type throughout the whole computation, but *a* can vary.
Maybe, I don't know the details of their implementation.
Don't know - eta has its own build tool, I think, which means different configuration files, maybe also a different directory structure... But the code itself should work with it.
&gt;haskell-gi It might be the best option. But it is the typical 0% documentation thing so many Haskell libs suffer. Even worse, the code is auto generated and also the documentation is auto generated. So you get: unreadable haskell code. And then there are lot's of places with "TODO documentation" and so forth. Basically it's complete unusable and a waste of time, if we are honest.
If one does a careful investigation, then the result is: there is not good GUI option for Haskell.
I really like your work. But Threepenny just feels like writing lots of low level html, css, code. It quite the same as writing the GUI in javascript and using a means to communicate with Haskell (e.g., Websockets).
You could try working in the Windows Linux Subsystem, you might have a chance there.
There is related work from Anton Setzer: [http://www.cs.swan.ac.uk/\~csetzer/](http://www.cs.swan.ac.uk/~csetzer/) [http://www.cs.swan.ac.uk/\~csetzer/articles/ooAgda.pdf](http://www.cs.swan.ac.uk/~csetzer/articles/ooAgda.pdf)
In this video, they advise that you should let people know when you think their tone is not great however in an open source setting this is not really possible. If someone is maintaining a great project out of the goodness of their heart it's difficult to complain about their tone, especially when it's not on Linus level bad. So please, if you want to be short and to the point then be especially mindful of your tone and how it may appear to others, it helps everyone in the end.
Indeed we should however the effect of personally not being put off affects others in only subtle ways compared to the effect of coming across as pleasant and inclusive.
Please drop GHCJS and pick whatever else you're comfortable with (Elm, Purescript, server side HTML rendering, etc) to solve the problem at hand. I've had arguments for saying this on this sub-reddit earlier, and I won't be surprised if this comment is down-voted to oblivion. &amp;#x200B; GHCJS is not worth the effort. And, you are taking significant technical risk if you're using it professionally. &amp;#x200B; Personally, I seem to be reverting to server-side HTML rendering nowadays, as I have realised that for \_most\_ projects, a sprinkle of JS is good-enough. Only if your UI is very complex and needs to maintain a lot of state should you reach out for something like Elm, Purescript, Angular, React, etc.
I'd suggest asking Jos√© Nuno Oliveira at Minho if he would like to be the supervisor for your dissertation. He works in precisely the areas you mentioned!
Don't use Haskell. It was not made for Front-end development and its constraints. Either use vanilla JS, or switch to PureScript with (or without) Lumi's React bindings. That's literally what we do at work, and we're very happy to make our services communicate that way :)
Would you mind to articulate this better? From here GHCJS looks like a gigantic hack: poorly maintained, no documentation, enormous js files, etc. But many people in this subreddit looks happy with all of that, and still recommends it. To me, even with miso, is a leap of faith too big to be taken mainly because the first learning step is too high for my baby legs (nix is the culprit, probably, but I was never able to be productive in, like, a reasonable amount of time). I will be happy to read a more lucid opinion about that.
He is my Professor and I most certainly will talk to him. Thanks for your answer! I was curious to see what projects I could find in other universities that worked in the formal methods area.
I cannot agree more with you. I‚Äôm all for Haskell, but site that loads in &gt; 20s is only the thing to be proud of.
GHCJS works. I have used it for years, and it produces code that is performant \_enough\_ and small \_enough\_ for typical workloads. Yes you will download 1MB or so, but with proper caching, that will typically not be an issue. &amp;#x200B; Unfortunately we're in a situation where efforts are spread on 3 different compiler projects. For years people have called for abandoning GHCJS because, say WebGHC or Asterius would be "proper" solutions. The problem is that these solutions have been in development for years now, and instead of a great GHCJS community we are going towards abandonment of the most important platform for computing these days. &amp;#x200B; As a community, we should treat GHCJS as the only JS solution for Haskell and basically ignore other projects \*until they actually deliver something that works\*.
&gt;could schema could schema could FTFY
But then 4MB is absolutely nothing compared to most sites, and the size increase is sublinear with code size.
Scala has rich type system and HKT support. Also there is number of libraries for FP: cats, cats-effect and ZIO (IO monads), monocle (lenses), matryoshka (recursion schemes) and others.
You're using `stack`. One of the main differences between `stack` and `cabal` is that while `cabal` tries to find versions of all your dependencies which are compatible with each other and with your system, `stack` has a single version for every package in mind, and it already knows that all those versions are compatible with each other. After a few months, all those versions are obsolete, so `stack` has a master version, the "resolver" or "snapshot", which specifies a set of versions for a bunch of packages. But you didn't specify any, so you had to jump through extra hoops like adding entries to `extra-deps` and running `stack solver`. Now, one extra complication is that not all resolvers include all the packages. By going to [the stackage page for `brick`](https://www.stackage.org/package/brick), I can see that `brick` appears in the resolvers `lts-12.26 and `nightly-2019-05-11`, among others. So I would add the line `resolver: lts-12.26` to my `stack.yaml`.
I mean the initial payload is proportional to the sum of all features on the site, not just the features you see on the home page itself. But on the upside you only pay for the JS once on initial load.
Don't let comments on using Haskell for _frontend_ web programming affect your judgment of Haskell for _backend_ web programming! According to the [State of the Haskell ecosystem](https://github.com/Gabriel439/post-rfc/blob/master/sotu.md#table-of-contents), Haskell's ecosystem is mature for server-side web programming but immature for front-end web programming, so it's not surprising to see comments claiming that other functional languages do better there, especially languages like Elm and PureScript which were designed exclusively for writing front-end programs.
&gt; Do you have examples of SPAs that are widely deployed? This site you are on right now? Aka Reddit. Also Facebook. Also most Google services including Docs and Mail.
Did you know that Haskell programs used to be a function from a lazy list of messages from the outside world to commands to the outside world? See section 7.1 of "A History of Haskell: Being Lazy With Class".
Looks similar to Elm's API, in which your program is a pure function from an event and a program state to a set of commands and a new state. What you can accomplish with such a system is dictated by the actions and events supported by the system; in Elm, it's web stuff like fetching a URL and html button presses, whereas in gloss, it's drawing triangles and mouse clicks. I like that kind of API, and I think there should be more of those, so please write a gloss-like library with actions and events which make sense for writing programs which talk directly to the kernel, like filesystems and drivers!
I wonder if there's resarch into hyperstatic hyperpure dag search spaces that IO only conflates not unlike quantum mechanics.
You do not need the ghcjs monster for that. However according with my experience, ghcjs works quite well, Anything that run under GHC runs under GHCJS as this is a serious advantage that increases as your code becomes more and more interactive. So you can use ghcjs for your project. It depends on your plans. [polimorphic.com](https://polimorphic.com) runs quite well in my phone.
true the sublinear part is important that ppl might be ignorant of (me ?) hehe
Yay it works now! Thanks so much!
I'm very excited about this episode! Cameron and I talk about the recent [Why Haskell?](https://github.com/github/semantic/blob/7364e164947116406850ff6f298d80ba77105229/docs/why-haskell.md) article by the Semantic team at GitHub. Check it out and let us know what you think!
I like how he manages to be succinct yet thorough while giving an overview of an architecture for a problem with a very "real-world" feel to it.
There's another "gotcha" for programs which don't work well with the threaded runtime, which is that ghci by default uses the threaded runtime (at least in stack). Both interpreted and compiled mode should have the same default IMO.
This is an adaptation of my talk from LambdaConf this year. A few people asked for the slides. I think this is a bit better, since it can give context. This is also my first technical blog post! Any feedback is much appreciated.
In the Clash Haskell-to-Hardware compiler, we need deshadowed expressions for some transformations to be faster/cheaper: [https://github.com/clash-lang/clash-compiler/blob/8b5d176e8d195a399284f9c8e258868df21a8c96/clash-lib/src/Clash/Normalize/Transformations.hs#L1056-L1097](https://github.com/clash-lang/clash-compiler/blob/8b5d176e8d195a399284f9c8e258868df21a8c96/clash-lib/src/Clash/Normalize/Transformations.hs#L1056-L1097)
sometimes i wish it could tell much earlier when a package wont work on a certain platform...I've done building on slower computers and only like 20 min in did i realize it wouldnt work on windows ;\_;
Haha yeah that sucks. I think the only thing we can do is check the github or on forums to see if it is supported before going ahead and trying to build it.
yea, tho it would be cool if packages had someone to explicitly say which platforms they are likely to work on or something that way the dep tool could be all 'hey this may not work on this platform? still want to give it a go? then if it works yea i dunno i'm just trying to come up with something haha..
Yes. My point is that you have to do that no matter what. You don't benefit that much from it in terms of sync.
Take my upvotes.
Thanks for the encouragement, but I'm afraid I have far more ambitious plans. I'm writing a new pure, total language that will be used in this fashion (I've never heard of gloss, but I should probably check it out to see how they've done it). So rather than tackling one radical idea, I'm attempting to deal with several.
I think it could be efficient, if designed right. The imaginary type signature I gave already looks a bit like a sort of callback. KernelOutput could contain list of IO conditions that it would trigger the program function being rerun, which could be time elapsed or disk data being available, etc.
all of you have re-invented Haskell in the 90's before monads were added.
 Interesting article. Purity is a concept that is and should be outside of any scientific or rational discussion since nothing that a program do could be pure, such illusion is a product of leaky abstractions that try (imperfectly) to maintain determinism and commutativity trough update operations of memory locations, update of registers, page swaps, cache invalidations etc. therefore "pure" is nothing and could be anything. it could be any computation that maintain such properties even if they perform IO and distributed computing providing that the appropriate leaky abstraction is used that assures to a certain level such properties implemented in the OS, in the language, the libraries or the program. Sometimes this is not possible since the program is inherently nondeterministic. Like print the time. Any other thing simply push the "non pure" bits out of sight in contrived ways.
I love the balance that the community strikes with theoretical and practical content. Great stuff!
Not to mention the gigantic state machine with big central state that every elm program is
Generating javascript and running via node will not get the same performance as GHC.
Well, what this article argues for is a bit more than the stream-based or continuation-based IO considered in pre-monadic Haskell. Those approaches still leave the OS more or less in charge of the granularity of actions on the environment and the semantics of those actions. But that approach eventually led to the current IO monad which is mostly like embedding C (but with less of a a memory model). The article here argues for taking a higher-level view of what the inputs and outputs are to the computation. If it's a data-processing tool (like a compiler), mapping input files to output files, then it shouldn't depend on the time, OS scheduling etc, so those shouldn't be implicit inputs to the computation.
This is an interesting perspective. I guess I prefer to have faith in the perfectability of digital abstractions. We have error correcting RAM. We can use redundancy in other ways to plug leaks. Mainly the goal here is to unpack what "the program" means. Why should that be one class of thing? Why should a data-processing program have the same capabilities (i.e. access to the same OS/ISA interfaces) as robotics software that truly needs to react continuously to a nondeterministic environment? Reading timers is inappropriate for the former but critical to the latter.
Good article. Some feedback.. &gt;getLine = send GetLine I am going to wonder where the `send` function came form. By it type it looks just like `pure`/`return` from Monad type class. Is it the same or is it doing something more? I felt that the `freer-simpler` library jumped out of nowhere and I wonder how it is related to Eff. &gt;And freer-simple gives some combinators How the use of the word `combinators` justified here? Can we just say `functions` ? &gt;interpretConsoleInIO :: Eff '[Console] a -&gt; IO a Maybe also mention how we ended up with a type level list here. I am also wondering how it works if we have more than one effect...
Regarding efficiency -- I think if doing this kind of continuation-based / callback IO system, you would still need to treat parallelism orthogonally. You could have functional parallelism, or you could have "dischargeable" effects for deterministic parallel models like monad-par, LVish, or Accelerate. The DetIO monad in the prototype described in the post bakes in some of that. It directly incorporates IVars for blocking communication between threads, for instance.
Is that a bad thing?
Obviously, YMMV but I personally find it very beneficial for an application we're developing. (For one thing is means that there's a lot less need for integration testing between frontend and backend.)
Lol
It's more than just compatibility of the data types. If you're assuming that the server and client are going to handle the same data in the same way, then you either have to update them in lockstep or have a ton of integration testing between versions anyway.
Thanks. Great points. I‚Äôll see if I can edit to make it flow a bit better.
Not sure what to say -- we haven't found that to be the case. I don't think we're doing anything that special, but we do have a single conversion layer that handles all the "convert to latest version" bits. (And we *do* force client 'resets' moderately frequently so that we can drop legacy code periodically.)
Many thanks for the heads up. I will try to follow your advice and get to the drawing board :)
Many thanks for your replies, and advice! Much appreciated!
For all but the most trivial or specialized UIs, you're going to need a round-trip to the server on most user interactions anyway, and the goal of the incremental approach is to send only what is absolutely necessary to the server and back. If you want, you can be smarter about it and evaluate on the client if there is no server interaction needed, but I'm not building the sorts of applications where that level of optimization is necessary.
I agree that Scala stands out. I'm still not sure I like it, as the syntax sometimes feels baroque and it's a little harder to enforce purity / lack of side-effects. But, especially if I'm targeting the JVM, I definitely consider and sometime use Scala, including HKTs.
Not trying to stop you from doing your own thing, but I think that contributing to an existing project might make progress faster than kick-starting your own.
I don‚Äôt was there, awesome talk and great article! Ty!
Can be; might be able to arrange for Haskell to generate symbols that the JNI needs directly. (Or vice versa.) But, the C ABI (sans varargs) is remarkably simple, so it can often be used to bridge between two other languages. There's no name overloading, and any name mangling is trivial.
not to downplay OP's accomplishment, but perl6's grammars are pretty slick...
Neither reddit nor facebook are SPAs. GMail might be there, but that could be one reason I prefer a real IMAP client (KMail / K9Mail). Editing a single document in GDocs is an SPA, but the overall docs experience isn't. SPAs mostly suck. It's easier to get the UX right with a SSR, specially around bookmarks, deep links, and other non-linear navigation. In the rare case that your main site and mobile application should have exactly the same functionality, an SPA could be acceptable but I can think of vanishingly view apps/sites were that's even the case.
When running tests it always stops at the first failure. However, you can use `sample'` to see what your generators will provide. You can also use `labeledExamples` to classify test cases. --- If you want better control over your function parameters, produce your own `Gen Int` objects, rather than just using `arbitrary`, which is the implicit default. `arbitrary :: Gen Int` generates values from -30 to 30, inclusive, IIRC. --- The default is not to repeat tests, IIRC. That said, you might look at SmallCheck which does a better job of exhaustively, but not repetitively covering small cases.
That's why I said "dosugaring"
&gt; everything there is completely justified The only thing I see there is a complaint that Elm does not support type classes (which is accurate). I do agree that `MyType.map3` is tedious, but I don't think this is quite as cataclysmic as it is made out to be. In fact, leaving out type classes is one of the things that allows Elm's error messages to be much easier to understand. The author says: &gt; I have another million complaints about other semantics of Elm's design I'd be interested to hear some of the other complaints.
Isn't purity what we are talking about... or what?
No. I don't mean the article. The I love what the article says. I refer to the comments above.
I thought so. I like state machines modeled in pure code.
Ha. I didn't even see the pun. Joke totally "whoosed" me.
I'm specifically responding to you because of you seem to have strong opinions about this; I've been working on a framework inspired by Elm but wrapping React/Redux, and using Haste so it's stuck on GHC 7.something and lacking Template Haskell - on the upside Haste seems to output much smaller artifacts, so using Parcel to accumulate my app code, this framework, React, Redux, Bootstrap, Fontawesome and a couple of other JS libs, I end up with \~1.6MB of assets total. Does this sound reasonable? Is the Haste trade-off worthwhile? I was thinking that I could probably factor out the Haste stuff and support GHCJS too but I'm in no hurry despite occasionally wanting lenses.
My definition of an SPA is a site that never does a full reload, so you are effectively on one page the entire time. Which is what the sites I listed do and what I also do. What is your definition of an SPA?
How are Reddit and Facebook not SPAs? They never do a full page reload and handle everything locally with client side JavaScript.
Sorry you're having a bad experience with `IO`. I like it a lot and wish every programming language had it.
Perhaps you haven't had to migrate to new behavior in that way yet? Or the difference wasn't semantically important? Or you haven't noticed an issue yet? Not trying to critique you or anything here. I'm just pointing out that it's very unlikely that you won't end up with different logic handling between the two at some point, due to feature rollouts (or rollbacks) or clients that are slow to update, and changes need to be managed under the assumption that you will.
It's probabably really cool, but also pants on head for a configuration file that is external not real world by nature. Want to read some system variable or whatever? In the configuration file for your Linux‚Ñ¢¬Æ system window manager? Nope. Not without jumping through hoops, it seems. BTW you can only read this comment if you go down the mariana trench and touch the bottom, it's the only way to keep things puuuuure.
No I totally agree - I'm a professional Haskeller and I don't use xmonad partially because I don't like using Haskell as a config language.
What are you talking about? Neither one of them behaves like that in my browser!
Just write a filesystem layer to generate your config file on demand ¬Ø\\\_(„ÉÑ)\_/¬Ø /s
I never have a full page reload. There is no spinner in the tab on the top of my page. The top bar never gets rerendered etc.
To be fair, it was a bad joke :)
I am old Reddit and that probably matters, or prehaps it just increases the number of full page updates I get. For Facebook, I'm not on that often, but navigation away from my stream is often full page update. Twitter is the SPA I use most often, and I wish it was less SPA.
\&gt; Another important case is where it's desirable to 'predict' what the backend business logic will do &amp;#x200B; I think the ultimate place you arrive along that line is bisimulation and Haskell is the perfect language for that. I'm really hoping, one day, to work on a web project that involves real-time interactions between multiple users using bisimulation with GHC + GHCJS.
&gt;import System.IO.Unsafe (unsafePerformIO) Thanks~, time and try to get that to work.
https://www.reddit.com/r/haskell/comments/bwah9q/why_haskell_why_github_use_haskell_for_their/ for another discussion of the same article.
How does this compare to Tagless Final ?
CSS is pretty powerful these days, so there's no need to go to the server for a lot of simple, pure UI interactions.
Thank you for the sobering statement.
Nobody is forcing you to use xmonad or Haskell in general. Stop whining and use some other tool that you like better.
I can just hardcode the bits I wan't not hardcoded if all things fail. &amp;#x200B; I consider the whining perfectly applicable. IO muddles things up for a configuration file of a piece of software that is meant to be used as a desktop window manager. &amp;#x200B; Also, why are you whining about my post? Why did you read my post? When you could have read something you liked more, instead? &amp;#x200B; Sometimes things just "get read". I didn't know I'd end up with this problem because most example configuration files out there, unless you specifically include "IO" in your search (which I didn't know about) don't cover this use case. They have everything hardcoded. &amp;#x200B; Until I tried doing something more fancy than that, I hit this cowpat of a system just to set a single variable, and the software is really good otherwise.
Some very simple type theory that beginners sometimes get confused about.
Facebook for me is always client side changes and so is (new) Reddit. Except (obviously) external navigation.
Oh, certainly. I'm definitely being a bit tongue and cheek here. Even Perl 5's feature-set for dealing with regexes and string manipulation in general is incredibly ergonomic. I think the language gets an unfair reputation because of it's idiosyncrasies. If you can manage to get used to it, it's really unmatched for the domain of "one-off parsing tasks you thought you were going to spend way more effort on".
Gotta say as a side note I hate the way CSS is progressing. I want a nice programmatic approach to UI and not a bunch of hardcoded rules I have to memorize and abuse. If the browser had a nice low level programmatic interface into the UI then people could build all kinds of DSLs and libraries on top of it, so people who like CSS would lose nothing and gain extra browser compatibility.
This might not help, but why use Docker for this on Travis? If it's to make executables that will live in a Docker container, then on Travis (Linux) you can `stack build` _without_ docker to produce a linux executable, and then `stack image container` to create the docker image. My team did this on a past project and it worked well. The docker build images aren't worth caching on Travis in my experience because they are network-bound, just like Travis' caches: either way, the contents have to come across the network onto your machine, and both the cache and the docker images will come from S3 or similar.
The creators of xmonad aren't going to change something because some random guy on Reddit finds issues with it. How about you contact them directly instead of wasting everyone's time listening to your drivel.
Nice! It can be tricky to get "void" and "unit" right. It doesn't help that "unit" is spelled `()` in Haskell (instead of `Unit` or something). I also like how Elm went with [`Never`](https://package.elm-lang.org/packages/elm/core/1.0.2/Basics#Never) and `never` instead of `Void` and `absurd`.
Nitpicky point: Haskell does actually have a unit type (ignoring seq). It just happens that that type is Void (since there's only one function to it from any type: the function that never terminates on any input)
Arbitrary lines help humans think about things. It's the same reason we bother with programming languages and variable names, and literally any other problem we've ever tried to solve with computers. If the only criticism you can muster about this idea is that it's drawing arbitrary lines, I'd consider that fair praise.
And to add to this, they're probably \*never\* going to change it. Xmonad is in large part formally verified. Adding IO in the middle can absolutely make that harder.
I don't think so? Consider: v1 :: Void v1 = error "1" v2 :: Void v2 = error "2" I think these can be distinguished in `IO`.
There's a lot of things that can be distinguished in IO. For instance functions that run for different amounts of time. I don't think those qualify for extensional differences, since they return the same value
I like your style.
Just to clarify, do you consider these to be the same value? io1 :: IO String io1 = return "1" io2 :: IO String io2 = return "2"
No, those are distinct values of the IO type. IO is still valid Haskell, it just, as it happens allows one to detect differences in Haskell code that's extensionally identical.
of course not, but it'll be fast enough to do stuff in a browser. the fact that ghc is your benchmark makes it clear that your performance needs are not *that* high.
&gt; Xmonad is in large part formally verified. Is it? That's surprising to hear considering that the formal verification of containers is only from last year or so.
OK, consider this: f :: Void -&gt; IO String f v = catch (evaluate v) $ \(ErrorCall s) -&gt; return s Are `f v1` and `f v2` the same, or distinct, values of the `IO String` type?
It's a formal verification of the core logic around how it models windows: http://www.staff.science.uu.nl/~swier004/publications/2012-haskell.pdf
Ok, just to clarify, consider two functions which both calculate the 10,000th prime, one by sieving, and one by exhaustion. Do you consider them to be the same value?
I think a better answer would be that "you can't compare values of the IO string type" since we don't have a framework to do so. are `getTime` and `getTime` both the same value of the IO string type? They look the same, but how do we know they are? When I call one, then the other, they seem to give different values! Spooky.
To be concrete about it: import Data.Void -- ActualUnit - a real, honest unit type -- The name was chosen because () is *called* a unit type, but really is -- not, since it has two values: () and bottom. type ActualUnit a = a -&gt; Void -- Example of an ActualUnit value f :: ActualUnit a f _ = undefined
Can you give us a concrete example, which shows how the IO monad is bothering you? Otherwise the basis for discussion is pretty thin.
I'm not sure why you added the \`t -&gt;\` part, just using \`Void\` is enough. It happens that extensionally it works out, but the type ActualUnit is just Void
Yes, I suppose so.
If you cannot compare values of `IO String`, does that mean it is also a unit type? Or is it more like `()`, with two values?
They are the same. Of course, the interpreter can give different results. We can certainly create, e.g. a Boolean State monad, and have decidable equality for all its terms (whenever `a` is), but of course, using `modify not &gt;&gt; get` will return different results. But there, if we encode it in the right way, we can decide that `modify not &gt;&gt; get == modify not &gt;&gt; get`. But of course, just because you cannot compare values of type IO String at runtime, does not mean you can't talk about equality. Much as we say functions are equal if they're equal on the same input, although in many cases there is no decidable equality for that.
Well under the reasoning they're extensionally the same. Why not consider ``` f :: ([Int] -&gt; [Int]) -&gt; IO Int f sort1 = do t1 &lt;- getCPUTime t2 &lt;- deepSeq (sort1 [1000..1]) getCPUTime ``` So then, is `f quickSort` and `f bubbleSort` the same? After all, quickSort and mergeSort return the exact same values. Yet `f` can distinguish them. In fact, with high accuracy `f` can tell you that two functions do not have the same definition. We could also just call out to C, scan through the memory, and check pointer equality for two values. We choose equality because it gives sensible results as far as computation goes. Yes, many terms are distinct from the perspective of errors, debugging or performance, but it's a much more useful distinction to say that functions which give the same results are the same.
Wait, `f v1` and `f v2` are extensionally the same, while `io1` and `io2` are different? Is that correct?
It's not clear to me that Haskell "types" are really types: they merely approximate types, and we typically elide that approximation. This is particularly clear when we accept that `unsafePerformIO` is a function that is defined in the base package. But if you can construct a category **Hask**, we can at least determine whether or not `Void `is a terminal object, as well as whether those two functions are the same.
I suppose so. It does feel a bit weird to say \`f v1\` and \`f v2\` are the same with different results, but then again it's the same for \`getTime\` and the like. So yes I'd say that's true.
So why are `io1` and `io2` different?
In what sense are they not types?
They're distinct values. I think to some degree it's just a matter of the fact that embedding values in IO isn't equivalence preserving, so perhaps we can say \`f v1\` and \`f v2\` are different even if \`v1\` and \`v2\` are the same, because by putting them in IO there's more we can do to distinguish them. So I could see that viewpoint. If we have to allow \`v1\` and \`v2\` to be distinguished because of what IO can do, then we have to allow every single pair of functions to be distinguished just by timing them or comparing runtime addresses, and that's not something that feels sensible to allow.
\&gt;The creators of xmonad aren't going to change something because some random guy on Reddit finds issues with it. Watch me.
You are missing out :)
You should provide a complete code example - one that we can try out; gives me lots of errors, none of which is the one you report.
The `atomically` function can only return `IO`. But your function signature says that it can return any `m` as long as `m` satisfy the constrain `InMemory r m`. Since there is a `MonadIO m` constrain on `m`, you should be able to just put a `liftIO` infront of `atomically` call to make this work..
`atomically` has type `STM a -&gt; IO a`, so the whole function should have the type `IO ()`, but you declared it as `m ()`. You should add a `MonadIO m` constraint and lift the block with `liftIO`.
&gt; Can you give us a concrete example, which shows how the IO monad is bothering you? Otherwise the basis for discussion is pretty thin. You're right. I should have done so from the start, that way you all are the ones suffering, not I. https://pastebin.com/H1Aah1pH
&gt;Haha yeah that sucks. Stop whining, nobody is forcing you to use it. &amp;#x200B; And, yes, I'm petty. Not gonna take away your upcummies, though. I'm petty, but I don't downvote easily.
This error message usually arises because user specified and inferred type variables are treated differently. For instance foo :: m () foo = bar where bar :: IO () bar = putStrLn "hello world" won't assume `foo :: IO ()` because you manually specified that it should be m. This is usually is relevant for fancy types in where clauses - like having to specify a higher rank function type but requiring ScopedTypeVariables to do so. In this case unifying atomically's type gives `m ~ IO` which creates exactly this problem. The error message is spectacularly unhelpful but still better than silently assuming you meant to write IO instead of m. UnliftIO.STM has a lifted version of atomically `MonadIO m =&gt; STM a -&gt; m a` https://hackage.haskell.org/package/unliftio-0.2.11/docs/UnliftIO-STM.html#v:atomically
It's interesting that there are different versions of liftIO, I'm wondering if alternative versions of functions provided by ClassyPrelude are the cause of this error. Maybe it exports a different variation of atomically
The book is a big project that builds on itself throughout, you'd have to clone my entire repo to test it.
The problem is that the monadic classes aren't in base. MonadIO comes from the transformers package. STM on the other hand is wired into the runtime system and mostly written in C code. So STM can't use MonadIO and you have to manually apply liftIO.
I see - anyway, others pointed out what seems to be the problem (atomically needing lifting). &amp;#x200B; Still, it is always good to try to build a minimal piece of code that produces the error - helps others help you. Plus, I have often, when trying to construct such minimal code, I've ended up finding the cause of the problem without even having to post it on forums... üôÇ
[The Implementation of Functional Programming Languages](https://www.microsoft.com/en-us/research/publication/the-implementation-of-functional-programming-languages/) is available for free.
Precisely - as a minimalistic example of lifting an IO operation into being compatible with MonadIO, I do: ```haskell import Control.Monad.IO.Class -- from transformers myFunc :: MonadIO m =&gt; m () myFunc = liftIO $ print "hello" ```
What are you struggling with here? What is io making complicated?
If that's what ClassyPrelude exports then that's exactly what's wrong, I'm not using it, I'm using the standard STM. Part of the issue is that my understanding of MonadTransformers is extremely shaky, I've only been using haskell for about a year and some of this advanced stuff is really mind bending for me still.
I put that in the comment, and I commented out the offending lines. Instead of hardcoding the paths to the icons, I want to grab the user home directory and prepend it to the icon name. This does not work the way the code is when those lines get uncommented.
Then provide typed stubs for the other functions, for example functionFromAnotherPartOfRepo :: (Int, a) -&gt; a functionFromAnotherPartOfRepo = undefined
There are not different versions of `liftIO`.
Maybe this slides can help https://docs.google.com/presentation/d/1VhS8ySgk2w5RoN_l_Ar_axcE4Dzf97zLw1uuzUJQbCo/edit?usp=drivesdk
I mean to write atomically, edited
You don't know how many inhabitants it has, because you can't compare them. Simple!
I would definitely be willing to do that if I needed to, but I typed what I felt would be minimally necessary to answer the question and the helpful people here answered the question.
Well what is something that is "really" a type anyway. We're playing a sort of silly game here.
We can talk about extensional equality in `State Bool` because this reduces to equational equality in the unwinding of state. We have no general purpose model for "equational equality in the unwinding of IO."
[This list of resources](https://github.com/soupi/rfc/blob/master/fun-compilers.md) that I compiled (heh) has some good stuff.
Ah. I see. Yes, maybe monadic io is overkill for a config file... So, here's the trick for workspaces ( I'm on mobile, so I'm not going to try writing actual code): make myWorkspaces have type `[IO String]`, by applying the icon wrap function to the icons, and `return` to the actual strings. Then in main, write `workspaces &lt;- sequence myWorkspaces` and use that in your config (Or you can apply sequence in the definition of myWorkspaces, so it has type `IO [String]`
I believe that you can solve this with template Haskell. Just use getIconPath :: String -&gt; String getIconPath iconName = let hd = $(runIO getHomeDirectory) in "^i(" ++ hd ++ ".xmonad/dzen2/" ++ iconName ++ ")" I'm on the bus right now, so I can't test it, but this should capture the home directory at compile time and keep everything pure. The only price is that you can't copy the compiled binary to a new computer.
ClassyPrelude lifts most IO functions such that they take or produce MonadIO m =&gt; m, but in the regular Prelude, those functions are monomorphic. You need to manually lift those IO actions using liftIO.
'IO a' is really 'RealWorld -&gt; (RealWorld, a)' so they are functions, not values. And io1/io2 return different values in second element of a tuple.
To explore lazy functional languages, there is: \- [https://github.com/quchen/stgi](https://github.com/quchen/stgi) (Haskell's "virtual machine") \- [http://github.com/bollu/timi](http://github.com/bollu/timi) (A simpler virtual machine in the same spirit) &amp;#x200B; I recommend reading through "The implementation of functional programming languages"([https://www.microsoft.com/en-us/research/publication/the-implementation-of-functional-programming-languages/](https://www.microsoft.com/en-us/research/publication/the-implementation-of-functional-programming-languages/)) and implementing the interpreters mentioned in the book. &amp;#x200B; Then reading the STG paper and the offshoots of that paper should get you quite close :)
I'm not sure of a comprehensive article series, but I do have some pointers for you. First of all, Benjamin Pierce's "Types and Programming Languages". It's the de facto introductory text on type theory and type checking. It's written for (under)grad students with very little required background (previous exposure to lambda calculus helps, but is covered by the book). It starts from the untyped lambda calculus and adds increasingly more features to its type systems. It describes how to type check each of the discussed type systems and comes with example implementations (in Ocaml, but if you're comfortable with Haskell it should be trivial to read). The book covers way more than you'll need for Haskell 2010's type system (but not all the fancy pants extensions). The other recommendation is the STG paper: [Implementing lazy functional languages on stock hardware: the Spineless Tagless G-machine](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.53.3729&amp;rep=rep1&amp;type=pdf) it's a bit dated by now, but covers the basics of "how do you even compile a lazy language to an x86 machine in a reasonably sensible way?!".
The problem with IO is well discussed here [https://www.youtube.com/watch?v=GqmsQeSzMdw](https://www.youtube.com/watch?v=GqmsQeSzMdw)
&gt;binary can't be copied That's absolutely fine with me, thank you.
Thanks, I'm gonna try that out, template haskell I'm going to try, too.
Hah, I did consider writing a program that generates the config file. I also considered a git hook, or something, that runs sed over the file upon cloning, or something. I haven't actually tried the git hook approach enough to know if that would work, it works for generating tags and stuff upon commits, but that's all I know. &amp;#x200B; Anyway, it's a config file, it should not be this hard (for a noob, anyway).
&gt; I was curious to see what projects I could find in other universities that worked in the formal methods area. You can look at the MSc theses posted on /r/dependent_types to get an idea of the kind of projects typical in TT ([search link](https://old.reddit.com/r/dependent_types/search?q=MSc&amp;sort=new&amp;restrict_sr=on&amp;t=all)).
&gt;The default is not to repeat tests I don't think this is true; QuickCheck will generate random data of increasing size but default generators (e.g. lists and integers) can interpret this metric as an upper-bound so it is possible to repeat tests.
Could you expand on what's bad about MissingH?
[http://learnyouahaskell.com/](http://learnyouahaskell.com/)
&amp;#x200B; But Arbitrary lines: \- Can preclude a wider understanding : for example purity suggest that only what is currently observed to be "pure" is "pure", that is, what is covered by conventional leaky abstractions (memory updates, cache invalidations, IO between CPU and memory) could be pure and not what new approaches could bring as "pure". For example, what is suggested in this article for file IO. \- Suggest metaphors which links with erroneous analogies. In the case of purity it suggest a lot of erroneous human preconceptions that are applicable to other contexts, but are very wrong in programming leading to the idea that computer sentences have a moral charge being (\`+) "good" and readFile "evil". These erroneous prejudices hinders the ability of programmers to create solutions for the real world. \- Such metaphoric appeal could lead to a war of constant inventions and reinventions of ephimerous fancy names and buzzwords, which is a plague in computer engineering and is not serious
Pure a programming model that uses a massive mutable state? &amp;#x200B; That is what I mention in other post about putting the mutable state out of sight.
I would really appreciate if someone could tell me what does this line mean &amp;#x200B; \`\`\` No instance for (cql-4.0.1:Database.CQL.Protocol.Class.Cql Char) arising from a use of ‚ÄòCQL.write‚Äô \`\`\`
Isn't Void an *empty* type? There's no Void value, that's quite literally its definition: &gt; Uninhabited data type The unit type would be `()`, which has a single value `()`.
I like it. It shows how to implement a functional language compiler without modern tools like Monad and do notation. It shows you how to implement the G-machine. But the STG machine is not covered in this book.
[https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-TypeLits.html#v:natVal](https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-TypeLits.html#v:natVal) (composed with `fromIntegral`) or [https://hackage.haskell.org/package/singletons-2.5.1/docs/Data-Singletons.html#v:fromSing](https://hackage.haskell.org/package/singletons-2.5.1/docs/Data-Singletons.html#v:fromSing) if you use `singletons`
I ended up going with a map after trying it with mutable vectors for a bit, thanks for the tip!
Thanks!
Which country/timezone are you based in?
Singletons in base seems like a bad idea given that DependentHaskell will likely obsolete it. Also, I believe that I and others have proposed to add Peano `Nat`s to base, with no luck. You could bring this up on the libraries mailing list if you want to see things change.
OK, and, of course, dependent types would be even better than singletons in base How does one join the mailing lists?
Well in that case, we certainly shouldn't be speaking of Void as a unit type, which is the point I was trying to make. Construct **Hask**, or at least **SafeHask**, and we can use that to talk about types. One approach might be to note that Haskell makes no guarantees about timing, so the IO functions that time evaluation are indistinguishable (while `f v1` and `f v2` are distinguishable). This might still run into trouble, though.
Simply that no-one can point to the category that defines them.
If you understand the G-machine, the [STG paper pubically available](https://www.microsoft.com/en-us/research/wp-content/uploads/1992/04/spineless-tagless-gmachine.pdf) should be accessible enough.
I honestly think that for hobbyists, Agda or Idris are better for exploring the space of dependent types and type-level computation. --- AFAIK, GHC doesn't have any optimizations / special support for a type like `Nat = Z | S Nat`, so not only is it *not* the naturals (`aleph_0 = S aleph_0`) but it also generates particularly bad code for any value that still exists at runtime. So, most people *don't* want to use a type like this. `Natural` is basically just `Integer`. It's not really inductively defined (which makes proofs difficult), but it is efficiently implemented through GNU GMP or an alternative multi-precision integer implementation. When doing runtime computations, this can be preferred in some circumstances. Though I've certainly had issues using `Word` instead of `Int`, and similar errors could happen when using `Natural` instead of `Integer`. When constructing proofs, most people don't want to use this type. --- A type class doesn't really help much, unless it provides enough power to transport not only individual values but also equality proofs (of arbitrary order), and preferably optimizes all transports to a no-op. --- In many ways, I don't understand this question any more than the "Why does Haskell have so many string types?" one. If you do even a little bit of research, it's well-documented what disadvantages of existing types that new types were introduced to offset. If you have an implementation that has all the advantages of two (or more) existing types but without some other significant disadvantage, **please** put it forward. If we knew about it, we'd probably already be using it!
Well, dependent types wouldn't really be a part of base, but rather the language. And https://mail.haskell.org/mailman/listinfo/libraries
I wouldn't have type theory depend on category theory. There's some interesting cross pollination, but I can think of a few definitions of type that don't make explicit reference to any categories.
&gt; Isn't Void an empty type? There's no Void value In Haskell, all types are inhabited by \_|\_, bottom, or `undefined`. In GHC, you can avoid this with unlifted types. (However, `throw` and asynchronous exceptions give many other inhabitants for lifted types.)
Looks to me like you are trying to link to two different version of cql. If you are using cabal, try cleaning up your sandbox or user package db. If using stack, this should have already been handled for you.
State transition /= state mutation
Please consider if your communication is respectful.
OK, fair point. About the Agda/Idris thing: In this case, it's actually a real use case, not just some playing around. It just seems to me we could have a backend implementation of Nat like we have of Int. Int is not defined as `... | -10 | ... | -1 | 0 | 1 | ... | 10 | ...`, after all. Also, AFAIK there aren't that many string types in Haskell. Text and \[Char\] spring to mind. If you mean ByteString and Word (not really used them before), as far as I can tell they have their own uses for different things. However, all of these Nat types are almost exactly identical! Save for your aleph\_null example. So we'd need two Nat types: A strict one and a lazy one. Pattern matching can just be done via ViewPatterns.
Thanks, but I think you misread my statement. I meant "(dependent types) are better than (singletons in base)", not "(dependent types in base) are better than (singletons in base)".
Hmm, I think if you can come up with a satisfactory theory of Haskell's types, you can probably construct the appropriate category. In any case, that doesn't seem to have been done.
&gt; In this case, it's actually a real use case, not just some playing around. How performance critical is it? Agda / Idris might still be better. Dependent types are simply *not* **done** in GHC, so there's going to be all sorts of sharp bits. Once it's done, I still can't recommend it for actual program verification (inconsistent logic and all), but it should be suitable for many practical purposes; it's just not there, yet. &gt; we could have a backend implementation of Nat like we have of Int Despite the slightly broken parallelism in the names, `Natural` is what you want for a non-inductively defined well-performing run-time implementation of the naturals. `Nat` is for when you want the `Nat = Z | S Nat` form.
I think that's more a result of the universality of general category theory, and less a result of type theory (or the definition of a type) being subservient to category theory. But, I tend to agree.
But Natural can throw errors. It would be better to, for example, have 3 - 6 = 6
That's sensible.
This is my completely inaccurate recollection of things, but as far as I understand it, MissingH came from a time when all the problems in the entire Haskell ecosystem could be solved with a single package. We‚Äôve now moved way beyond that time. There‚Äôs probably some useful stuff in there but i‚Äôm sure they can all also be found elsewhere that makes more sense.
Monad classes and transformers are actually not that complicated but it's hard to quickly build intuition for them without using them a bunch. Kind of like monads. I can try to give a birds eye view: You have two monads: data State s a = State (s -&gt; (s, a)) data IO a but then you want to combine both and need a new type: data StateIO s a = StateIO (s -&gt; IO (s, a)) You can see the state in there. We can actually be more general: data StateT s m a = StateT (s -&gt; m (s, a)) type StateIO s a = StateT s IO a But we can't do this for all monads - [a] has no valid wrapper equivalent for instance. For it to work we need a function `lift :: m a -&gt; t (m a)` which is a natural transformation (which basically means stuff keeps working no matter where we call lift): lift (return a) = return a lift (f &gt;=&gt; g) = lift f &gt;=&gt; lift g For StateT's `lift` we do almost the same as with State's `return` but the value is monadic now: lift :: IO a -&gt; StateT s IO a lift m = StateT $ \s -&gt; do a &lt;- m return (s, a) This works but is mindboggingly annoying to work with printHello :: ReaderT Int (WriterT String (StateT Bool IO)) () printHello = lift (lift (lift (print "hello))) So MonadIO has a function called `liftIO` which inserts the right number of lift's. All monad type classes are actually just boilerplate to insert the right number of lift's.
I think you're actually better off thinking this way. `Void` is (approximately) and empty type, `()` is (approximately) a unit type, `(,)` is approximately a product, and so forth. Sometimes the approximations break down, of course, but mostly it's helpful to think of Haskell's types this way. By contrast, there does not seem to be a useful sense in which `Void` is a unit type. It seems appealing at first, but breaks down when you poke it: you probably end up with collapse of the `IO` type into a single value, and you still have to pretend that various Haskell functions don't exist, and you haven't really gained anything.
There is no error. `CQL.write` requires `RunQ` for its query, which in turn for a `QueryString k a b` requires `Tuple` for `a` and `b`. Your `a` in this case is `(String, String)`, which would require `CQL String` to satisfy `Tuple`, `String` is `[Char]`, and the `CQL [a]` instance requires `CQL a`. There is no `CQL` instance for `Char`, so this doesn't work. If you want to send text through `cql`, use the `Text` datatype from `Data.Text` (`text` package on hackage) instead of `String`.
Void is a unit type in the very rigorous sense. All functions that return Void return the same value. It's pretty simple and exceedingly rigorous (categorically you want to use equality on functions). It so happens that in the same universe IO also has to exist, but there's no point talking about equality on IO, without an extensional definition.
In my opinion having a natural number type for which 3-6 = 6 seems terrible; that just breaks about all rules/laws/properties one would expect from natural numbers.
I am completely ignorant about Tagless Final (and just learned a little about Freer Monads thanks to the OP), and unfortunately the slides didn't help me to understand exactly what Tagless Final is. I guess there is a lot of context missing from the talk. Is it about encoding effects with type classes? I guess I'll need to read Oleg's paper(s) (just hopping a "no-initiated" like my self will be able to understand it). Anyhow, what really got me wondering in the slides is: &gt;**Effect system != Layering.** &gt; &gt;**Effect systems is an exceptionally bad idea which could only have originated in academia.** and &gt;**Functors of free monads aren‚Äôt composable.** &gt; &gt;**Interpreters of free monads aren‚Äôt composable.** &gt; &gt;**Free monads aren‚Äôt composable.** &gt; &gt;**Free monads are slow.** &gt; &gt;**Essentially, Free Monads are equivalent to Final Tagles.** &gt; &gt;This paper says it‚Äôs impossible. &gt; &gt;This paper says it‚Äôs bad. &gt; &gt;You haven‚Äôt read the X‚Äôs paper, how dare you?! Can someone with knowledge in this are comment about these assertions? Does the work being done in `Polysemy` change something? Is he referring to Oleg's paper(s)? But even more confusing, the last slide says: &gt;**Free monads are powerful and fast.** So, in conclusion are Free(r) Monads good/fast or bad/slow?
[https://serokell.io/#contacts](https://serokell.io/#contacts) says they are in Estonia.
Ah, you're right, I misread.
Ok, if you're going to act like a child you'll be treated like one. I've done your homework for you so you can see how it can be done, consider yourself lucky. I have made what I believe are all the changes you need to make to your program to make it load the paths to icons at program startup time; you can find them [here](https://gist.github.com/axman6/0470c74077209ba52780f57148114306). This is the least constructive post I've seen on r/haskell in a very long time. We all feel like having a whinge sometimes, but in the future, try taking a deep breath, thinking about the problem, and formulating an answerable question to help you overcome, rather than throwing a tanty. Examine this file, learn from it, and learn how to ask better questions. Edit: There are some places where are still hardcoded references to icon paths, as an exercise you should fix this. An alternative way to solve this problem is to just pass your home directory as an argument to all functions which need it. Try implementing this alternative and see which you like better.
If we cannot talk about equality on IO, how do we talk about equality on functions? For example, are these two functions equal or not? iof1 :: () -&gt; IO String iof1 _ = return "1" iof2 :: () -&gt; IO String iof2 _ = return "2"
I don't know how you are using the word "better" there, because that definitely sounds worse to me.
May I ask for help in form of code review? Profiler verdict for following code snippet is such horrible and I can't fix it by my self. {-# LANGUAGE OverloadedStrings #-} import Data.Bool (bool) import Data.ByteString ( ByteString ) import Data.Vector ( Vector ) import qualified Data.Vector import Data.Map.Strict ( Map ) import qualified Data.Map.Strict type JobName = ByteString type Entry = ByteString type Jobs = Vector Entry type Pantry = Map JobName Jobs data Queue = Queue { lastIndex :: Int , pantry :: Pantry } deriving (Show) pantry' :: (Maybe Jobs -&gt; Maybe Jobs) -&gt; JobName -&gt; Pantry -&gt; Pantry pantry' f n p = Data.Map.Strict.alter f n p enqueue :: Int -&gt; JobName -&gt; Queue -&gt; Queue enqueue 0 _ q = q enqueue i n q = enqueue (i - 1) n queue where queue = Queue { lastIndex = (lastIndex q) + 1 , pantry = pantry' (\_ -&gt; Just (Data.Vector.snoc vec "X")) n (pantry q) } vec :: Vector Entry vec = case Data.Map.Strict.lookup n (pantry q) of Nothing -&gt; Data.Vector.empty Just v' -&gt; v' flush :: JobName -&gt; Queue -&gt; Queue flush n q = case Data.Map.Strict.lookup n (pantry q) of Nothing -&gt; q Just v -&gt; bool (flush n (queue (Data.Vector.tail v))) q (Data.Vector.length v == 0) where queue v = Queue { lastIndex = lastIndex q, pantry = pantry' (\_ -&gt; Just v) n (pantry q) } main :: IO () main = let i = 10000 :: Int n = "A" q = Queue { lastIndex = 0 , pantry = Data.Map.Strict.empty } q' = flush n (enqueue i n q) in print (show q') Profiler summery: 430,349,096 bytes allocated in the heap 26,649,928 bytes copied during GC 316,955,632 bytes maximum residency (9 sample(s)) 17,716,240 bytes maximum slop 302 MB total memory in use (0 MB lost due to fragmentation) Tot time (elapsed) Avg pause Max pause Gen 0 372 colls, 372 par 1.466s 0.367s 0.0010s 0.0054s Gen 1 9 colls, 8 par 2.903s 0.745s 0.0828s 0.3776s Parallel GC work balance: 58.47% (serial 0%, perfect 100%) TASKS: 10 (1 bound, 9 peak workers (9 total), using -N4) SPARKS: 0(0 converted, 0 overflowed, 0 dud, 0 GC'd, 0 fizzled) INIT time 0.002s ( 0.002s elapsed) MUT time 0.270s ( 0.254s elapsed) GC time 4.370s ( 1.112s elapsed) RP time 0.000s ( 0.000s elapsed) PROF time 0.000s ( 0.000s elapsed) EXIT time 0.002s ( 0.002s elapsed) Total time 4.644s ( 1.370s elapsed) Alloc rate 1,595,165,974 bytes per MUT second Productivity 5.8% of total user, 18.6% of total elapsed
I suppose you actually want to see the JS rendered result, right? You will actually have to serve at least two files: `index.html` and `elm.js` (which is referenced in `index.html`). From your browser, you should then access the `index.html`, and your browser will fetch the `elm.js` in the background.
Thank you so much, that did the trick
You just said Reddit and Facebook dont do full page reloads then complained about getting downvoted (which is also taboo on Reddit and Hacker News). Why not ask yourself if that is true? I also mentioned Gmail earlier which uses Java to generate JS in a prior thread as an example of the *old* way of doing things which they long abandoned. But yes it is the most famous example of an SPA. The document editor parts of the Docs/sheets/etc are SPAs as well for practical reasons. The latter are all self-contained units because they are trying to replace Desktop UI experiences on the web. Which among web apps is pretty rare but still a reasonable reason to use SPAs
Nice post, thanks!
Fair enough ;-).
If you want some examples of implementations to look at, I made an archive at https://github.com/haskell-implementations that you could look through to see various implementations. The `duet` one is one I wrote, currently archived, based on "Typing Haskell in Haskell". It features a parser, rename, inferer, type class resolver, and substitution stepper. Its README lists numerous web demos (GHCJS-compiled) of its various phases of development.
Functions are extensionally equal whenever it is the case that their result is equal whenever its arguments are equal. If there is no meaningful predicate for equality on the codomain, then there is no meaningful equality for those functions.
Right. So we *don't* have equality on functions, which means Void *isn't* a unit type in any rigorous sense.
I have code like let [a, b, c, d, e, f, g] = words str which correctly gets an incomplete patterns warning. I'm happy with it being partial, but is there some nice way to refactor it to avoid the warning? If it was just two I could do something like let (a, b) = words str &amp; \case [a, b] -&gt; (a, b) _ -&gt; error "..." but with seven variables that's a bit less nice. Since I'm in IO, right now I have [a, b, c, d, e, f, g] &lt;- return $ words str but I don't like it.
What's the compensation package like for this position? Thanks.
&gt; There is no error. Goodness, it certainly looked like a type error to me! ;) The rest of your explanation was great; you are clearly more familiar with CQL than I am. However, this little bit at the beginning certainly comes off as dismissive, which is not the first impression we want to give user seeking assistance.
I'm interested in part-time positions, are you offering anything like that? I fit almost all of your criteria.
I agree with your conclusion that Haskell is not really practical for SPA's or any frontend web development yet. My experience with PureScript is that it's very little documented and unstable (lot's of changes in the language and tooling), however that improves at good speed. I've recently started learning Rust, not for it's web capabilities but for use in embedded (STM32 ARM Cortex-M). I don't think the Rust ecosystem is much better served with regards to frontend frameworks. It's all very unstable and very little real world use. What Rust provides though, is a WebAssembly target, which is very well integrated in the ecosystem and works basically out-of-the-box (with rustup). I'm pretty sure it will take quite some time to have this experience with GHC/Stack/Cabal.
So, actually that one still works out, Void is a codomain with equality. You've made quite a leap from 'some function types don't have X' to 'All function types don't have X'. Besides "meaningful" is not a rigorous term. There is a rigorous equality for which it all works out, it's just not very meaningful.
Would you mind listing out some projects that you're working on and looking developers for?
You want to go to `Never` `never` land?
Do we have equality on functions, or do we not?
Are Serokell engineers required to wear sunglasses at all times?
i can't speak for other folks, but i'm doing some work in ghc that i want to get reflected into H2020, i'm just not doing the ratification process until i have the state of play reflected in GHC to my satisfaction honeslty, i think it should have been organized as H202X, though I'm also having discussions about rebooting H202X properly in the near future
I think his other book, ["Implementing Functional Languages: A Tutorial"](https://www.microsoft.com/en-us/research/publication/implementing-functional-languages-a-tutorial/) is more in the style of write-you-a-haskell. I highly recommend it as a practical introduction to both functional programming and compilers for functional programming languages. You will need to translate from Miranda to Haskell, although that's not difficult -- the languages are extremely close in syntax.
what are you trying to achieve exactly? where does *str* come from and why do you want to have your code working only when words function returns 7 words? I mean you could write a function returning **Maybe [String]** or **Either CustomError [String]**, e.g.: data Not7WordsError = Not7WordsError deriving (Show,Eq) somefunctionMaybe :: String -&gt; Maybe [String] somefunctionMaybe str = case (words str) of l@[a,b,c,d,e,f,g] -&gt; Just l _ -&gt; Nothing somefunctionEither :: String -&gt; Either Not7WordsError [String] somefunctionEither str = case (words str) of l@[a,b,c,d,e,f,g] -&gt; Right l _ -&gt; Left Not7WordsError -- example function calling both maybe and either variants somefunctioninIO :: IO () somefunctioninIO = do str &lt;- getLine print $ somefunctionMaybe str print $ somefunctionEither str but there may be a better way of doing this...
I went to their Team page just based on this comment! Everyone except marketing... Someone inverted the Pretentious filter!
That's like saying, do we have an equality/ordering/Show on values or not? It depends what you're looking for, and it depends on type. In many cases, there are multiple valid answers for a given type, but it's a bit of an odd question to ask of untyped values in a statically typed language. IO actions support the most trivial equality: Syntactically identical terms are equal. You can add additional rules (beta-eta, etc), but that's a valid equality relation. You can choose to allow some terms to be provably distinct, but IO interpretation is not required to be deterministic (e.g. with regards to getting time, or random numbers, or asking the internet, or even catching exceptions, since for instance, evaluation order is not fixed in Haskell, and the compiler can reorder code to change the exceptions thrown). Extensional equality is defined for any functions where the domain/codomain have equality. It also still works on constant functions regardless of whether the domain has equality, though it's a bit odd. In a few cases, we can algorithmically decide whether it holds, but it's still a valid relation even if it can't always be decided.
OK, so we do *not* have equality on functions. &gt; It's pretty simple and exceedingly rigorous (categorically you want to use equality on functions). Categorically we *cannot* use equality on functions, since we don't have that. In fact, we cannot even construct our category unless we can determine whether any two morphisms between the same types are equal. I'm not seeing any rigour here.
This is in my test suite, I have a json file with a list of objects that I want to run tests on, and the objects have a bunch of parameters in a string. (More or less. Details aren't important.) I don't think it's worth making a custom error for, the normal "pattern match failed" error is fine, I'm just hoping to get that without getting a warning about it. (And without disabling those warnings on the whole file.)
Makes sense. In that case you could use the Maybe version instead of the Either one with the custom error data type... If not, you can supress non-exhaustive pattern warnings for a specific file (instead of the whole project) by adding the following to the top of the file that includes your function (I think this is the one, you'll have to try it out cause I can't check it on my phone): {-# OPTIONS_GHC -fno-warn-incomplete-patterns #-} but if you choose this path you have to be careful since you may end up supressing warnings that are relevant for other functions in same file.
sorry, 3-6 = 3, my bad!
It's not meant to be dismissive, but your question implied that you thought that there was something wrong with the type evaluation itself. I merely wanted to point out that this is not the case.
I made a mistake. I'm sorry! please read again, I edited
The maybe function still just returns a list though, I'm specifically hoping to give names to the list components. I guess I can do case words str of [a, b, c, d, e, f, g] -&gt; ... _ -&gt; error ... at the cost of increasing my nesting depth in the code that actually uses the names. I probably dislike that a little less than I dislike the version with return.
Okay, by fiat, IO actions are equal if syntactically equal up to beta/eta reduction (EDIT: plus equal subterms). Done, there's your equality. You don't need a decision procedure to formalize categories, you only need a predicate. If you're picky enough to require decision, despite it never being needed, then use classical logic and take your decision procedure. This kind of stuff has literally been formalized, it can be computer-verified. I don't know what level of rigour you want if that's not enough. You don't have decidability for formalization.
they all have glasses off when you hover
I wasn‚Äôt complaining about downvotes, I was genuinely curious why people were downvoting because I didn‚Äôt say anything inaccurate. I‚Äôve been here quite a while and it is nowhere near as taboo to ask for further explanation. It is 100% true. At least on my machine none of those sites do full page reloads basically ever.
&gt; Okay, by fiat, IO actions are equal if syntactically equal up to beta/eta reduction (EDIT: plus equal subterms). Done, there's your equality. This is incoherent. Consider: f :: Void -&gt; IO String f v = catch (evaluate v) $ \(ErrorCall s) -&gt; return s v1 :: Void v1 = error "1" v2 :: Void v2 = error "2" According to you, `v1` and `v2` are equal (the single value of a unit type), but `f v1` and `f v2` are unequal (cannot be reduced to the same form). So `f` is not even a function. &gt; This kind of stuff has literally been formalized I don't think it has been? Nobody seems to be able to define **Hask**, for example.
Not my question. ;)
I think I'd still prefer the error. I'd actually prefer it at type checking when we if the can't find the required `LTE 6 3` proof ([Idris subtraction](https://www.idris-lang.org/docs/current/prelude_doc/docs/Prelude.Nat.html#Prelude.Nat.-)) but I'd rather it error at runtime than give me `3`. `0` might be acceptable in some circumstances ([Idris minus](https://www.idris-lang.org/docs/current/prelude_doc/docs/Prelude.Nat.html#Prelude.Nat.minus)), but not `3` or `6`.
We are a fully remote company. Most of our employees work in the European timezone.
Please send your CV to jobs@serokell.io and we will contact you if such position is available.
Just because equality cannot be proven, does not mean they are inequal. For instance, suppose we have some natural numbers `x` and `y`; we can't prove equality of `x + 1` and `y + 1` if we don't have any other information, but it may truly be the case that for instance, `x = y = 0`, but we can't prove that until we discover the equality `x = y`. The syntactic equality portion only really applies to the primitive IO actions, so `catch x y` is equal only to `catch x' y'`, where `x = x'` and `y = y'`. So we have `f v1 = f v2`. You missed my edit here it seems. Domain theory itself has been formalized, so we can merely pick one of those formalizations. It may not be the formalization we would like for Haskell, but it would work quite well.
mhm
Relevant username I suppose
ajax + pushState can make it seem like it's an SPA but it's still not the same. aka [pjax](https://github.com/defunkt/jquery-pjax)
How exactly is that not the same? No page reloads -&gt; SPA (at least by my definition, if you have a different one let me know).
the biggest sign of a good programmer is knowing what you dont know. It's always the best indicator.
What a completely idiotic non-answer. Just tell me what your definition of an SPA is instead of being a wanker. From wikipedia: &gt; A single-page application (SPA) is a web application or web site that interacts with the user by dynamically rewriting the current page rather than loading entire new pages from a server. Which Reddit and Facebook and most Google sites all meet the definition of.
The next line explains why Reddit is not an SPA: &gt; In a SPA, either all necessary code ‚Äì HTML, JavaScript, and CSS ‚Äì is retrieved with a single page load,[1] or the appropriate resources are dynamically loaded and added to the page as necessary, usually in response to user actions. A whole page being pulled by AJAX and inserted via pushState is not an SPA. It's a pretend SPA. Reddit is using AMP which is the same idea as pJax to simulate it. The source code of any Reddit page would be mostly empty if it was an SPA, see https://www.instagram.com/'s source code (or any page rendered with JS turned off). If you see elements, it's not an SPA.
The fact you keep fighting this fight is exactly why I was dismissive from the beginning. I can spot one of you from a mile away.
&gt; A whole page being pulled by AJAX and inserted via pushState is not an SPA. It's a pretend SPA. You realize I can open the network tab right? That is not at all what is happening. It's retrieving JSON and client side JS is converting that into the appropriate page update. Of course it is using pushState so that the URLs work properly. &gt; The source code of any Reddit page would be mostly empty if it was an SPA, see https://www.instagram.com/'s source code (or any page rendered with JS turned off). If you see elements, it's not an SPA. That's a terrible metric. Are you completely unaware of how server side pre-rendering works? See [here](https://helpx.adobe.com/experience-manager/6-4/sites/developing/using/spa-ssr.html)
I keep fighting it because I am fairly sure I am correct and your counterarguments so far have been extremely weak.
I'll send it along shortly. Thanks.
Agreed. This is confirmed by this benchmark: https://krausest.github.io/js-framework-benchmark/current.html Imba and Elm are both compile-to-JS and perform well (better than React, Angular, and Vue). Everything done with GHCJS or Purescript is near the absolute worst end on every metric.
 fv1, fv2, io1, io2 :: IO String fv1 = catch (evaluate $ error "1") $ \(ErrorCall s) -&gt; return s fv2 = catch (evaluate $ error "2") $ \(ErrorCall s) -&gt; return s io1 = return "1" io2 = return "2" According to you, `fv1` is equal to `fv2`. But `fv1` is not equal to `io1`. But as far as program behaviour goes, most people would say you can substitute `io1` for `fv1`, even though you say they are not equal. Of course, you might be able to justify that with the fact that there are detectable timing differences, or somesuch. On the other hand, you cannot in general substitute `fv1` for `fv2`, even though you say they are equal. This seems to misrepresent the behaviour of `IO`. So in the end, you can say that `Void` is a unit type, but only if you assign semantics to `IO` that are not connected to its actual behaviour. And bear in mind that all Haskell programs have type `IO ()`.
Reddit is literally using Google's AMP, which is a glorified PJAX with caching on CDNs, and Instagram has talked about the fact they're using a React SPA thoroughly. SSR is just an optimization step nor does it make any of your prior points correct.
SPAs are popular for greenfield projects right now. The reason you mostly see mixing React in with existing sites is because that's easier to do than remaking your entire site. It is pretty easy to make a SPA bloated, I agree. But, I don't think it's a fundamental limitation of the technology. Show me where these SPAs are bloated: https://elm-spa-example.netlify.com/#/ https://ryansolid.github.io/solid-hackernews-app/ https://dev.lemmy.ml/#/ First two are demo apps, granted, and the third is a hobby project. They're still all complex enough. They're all made with different libraries/frameworks also.
Show me where toy projects are bloated? And of course some projects make sense as SPAs. I mentioned multiple. That still doesn‚Äôt make them a common choice for anything but a small subset of apps.
Those apps are toy in the sense that they're not used. A demo can have complexity. I see you mention Instagram, and that's it. What small subset of apps are SPAs appropriate for? What kinds of applications would be the worst for a SPA?
Yes, they happen to give the same total result. In the same way that checking for instance, that the current time is earlier than the year 8000 is going to be True for as long as Haskell is around. Likewise, I think it's reasonable for people to say that two implementations of different efficiency are equal, even though IO can detect a difference. You either have to throw out all reasoning whatsoever, or pick one that can produce different results with IO, or just use fast and loose reasoning. Absolutely no transformations you can make will be unchanging on all programs, because IO can read memory, time and code. But for all pure computations, that form of equality is reasonable. And no, Void still works regardless of everything done here today, because it still has the property that all values of type Void are equal.
agreed
&gt; You either have to throw out all reasoning whatsoever, or pick one that can produce different results with IO, or just use fast and loose reasoning. Right. This is why I say that Haskell "types" only approximate types. &gt; And no, Void still works regardless of everything done here today, because it still has the property that all values of type Void are equal. What you've done is pick one kind of equality that ignores the behaviour of IO. But the behaviour of IO is part of Haskell: Haskell gives different semantics to `fv1` and `fv2`, so if you claim they are equal, you are no longer talking about Haskell.
I don‚Äôt care if they are using AMP or not. When you interact with or click on things: Everything is handled client-side with no full page reload, sending and receiving JSON as needed for the new content. The above is the definition of an SPA. So Reddit, Facebook and most Google sites are all SPA.
I suppose that's reasonable then. So in a war between any sensible equality on values (the same one that says that two functions which do the same thing are the same) and the congruence of equality when you pass to IO, I think we have to give up on the IO one, since it can already distinguish otherwise equal values through many means. I don't think too much is hurt, in the subset of Haskell that doesn't launch the nukes, then Void is the unit type, and that's a sensible outcome. So yeah I'll contend that v1 and v2 are perfectly equal if your program doesn't examine them too hard. Same with (1, 2) and (1, 2). If your program tries to, it's not too hard to distinguish two different tuples which are identical. We'd still want \`1 = 1\` and \`2 = 2\`.
&gt; the subset of Haskell that doesn't launch the nukes Indeed, the subset of Haskell that doesn't do anything at all, and can't be used to create main programs. Awhile ago [I attempted to properly define **Hask**](https://www.reddit.com/r/haskell/comments/4wk0gs/hask_is_not_a_category/d69j1de/), and I think I ended up with the same interpretation as you're using. I believe `Void` is a terminal object of that category.
&gt; Haskell gives different semantics to fv1 and fv2 Actually, the semantics of the expressions you are talking about here are not defined in the Haskell report, as far as I can tell. The fact that `fv1` and `fv2` evaluate to the same strings as `io1` and `io2` is not part of the language specification. Section 3.1 says: &gt; Errors during expression evaluation, denoted by ‚ä• (‚Äúbottom‚Äù), are indistinguishable by a Haskell program from non-termination. [...] When evaluated, errors cause immediate program termination and cannot be caught by the user. and &gt; The actual program behavior when an error occurs is up to the implementation. The messages passed to the error function in these translations are only suggestions; implementations may choose to display more or less information when an error occurs. The report does define the eldritch horror that is `seq` though. So `\x -&gt; undefined x` isn't quite the same as `undefined` :( Edit: Fixed a mistake in paragraph 1. And swapped 'it' for 'the report' in the final paragraph.
Yes you‚Äôve made it clear repeatedly you don‚Äôt care to know what you‚Äôre talking about. You don‚Äôt need to keep repeating yourself.
Dude I don‚Äôt think you realize that how and in what situations Reddit uses AMP does not change the definition of an SPA. Which all of these sites absolutely are.
&gt;IMO validation is best handled server side. I don't see the point in replicating it locally. The validation I'm talking about doesn't involve replicating full types/objects on the client-side. I'm talking about parsing a simple JSON response from a POST/PUT from the server \[..\] &amp;#x200B; I'm going to assume, since we're on the haskell subreddit, that you agree static type checking is valuable &amp;#x200B; When I look at this problem, I feel much better knowing that JSON I'm parsing and validating is also guaranteed to be correctly generated on the client side. ie if I express that JSON object as a haskell type and have it shared both client and server side with toJSON and fromJSON functions proven to be inverses of each other then I know my client and server will never have a problem communicating. The whole problem domain of getting the client and server to agree on the interface is entirely solved by the simple static type checking we all know and love. &amp;#x200B; Likewise, routes and choosing the content type of operations can be statically type checked on both client and server using the same servant api. &amp;#x200B; These seems like huge wins to me. &amp;#x200B; &gt;The models that I do replicate are often 10-20% of the size of the server side model &amp;#x200B; If this is your main objection, I absolutely agree. Nobody needs to export the entire server model to the client. Only the bits that need to be shared. ie the API and the shared data types used for generating/parsing JSON. &amp;#x200B; In my opinion, even if we take exactly only the amount of data you are currently sending between client and server and no more, you still win by code sharing. We don't even need to discuss SPAs. &amp;#x200B; Put another way, you are implicitly sharing that data between client and server anyway: they are both referring to the same JSON objects, the same routes, the same content types. Why not explicitly share that data and take advantage of static type checking to enforce the guarantees that that shared data truly is the same, not just in theory? &amp;#x200B; Or, perhaps you agree with all this and you just think, as you mentioned before "the overhead is not worth it". Is this just a problem where the current tools are too costly to use right now, but if they get better then it would become worth it? For example, maybe you'd like to convert all your javascript over to a Reflex app, but you're reluctant to have the client need to run a whole GHCJS RTS.
\+1 for including very specific knowledge requirements.
And yet, people choose to write [document conversion programs](https://hackage.haskell.org/package/pandoc), [cryptocurrencies](https://github.com/input-output-hk/cardano-sl/), [window managers](https://hackage.haskell.org/package/xmonad), webapps, programming language compilers and more in Haskell.
As people here probably know, Serokell were the team behind the original [cardano-sl](https://github.com/input-output-hk/cardano-sl) code base. I would be interested in hearing what you learned from that experience, what you think you got right and what you think you could have done better.
I think you are right, Haskell *ecosystem* still sucks in many situations. Even if foundations are really good (except records and other little edges) and the language is being used in various areas, some other fields need much more attention. Haskell shines in tasks like writing compilers, parsing text, programming backend services, etc, but it is still weak in mobile programming, making GUIs, VR and 3D graphics, game development, audio processing,etc. The only option as a community is to continue the development to fix those areas, and also write nice documentation and easy to follow tutorials. Thanks to remember us that there is still more work to do!
Will there be a video of this talk in the future?
Haskell is a pretty big pie to ask someone to slice all at once without a real introduction. I think asking someone to include source and do a complete re-compile of your program as a method of program configuration is a pretty shit paradigm from a usability perspective. That having been said... I've never written any config file that can dispatch off an arbitrary environment variable before. Pretty sure that's not standard in most markup languages. So, you might be having a hard time with it, but, I promise you it's a hell of a lot easier than trying to get a JSON file to do IO.
The thing is, you should be able to get most of the content, by replacing IO with something better behaved. I mean, even with this you could have values with effects. But then that takes you out of into all kinds of mess which is more easily avoided by having all undefined values be identical. Your attempt looks really well-done (and fairly unique. I haven't seen someone try to define it outright with (), although I guess that's sort of like the locale/inherent topology version). I guess it does include what you were saying about having all terms in IO be equal. Thanks a bunch for sharing that. So if we flip back to locales/domains, it seems to have, two values `p, q :: T` are equal iff every open containing p contains q and vice versa. Functions are then just extensional with regards to this, which makes sense if we have `p, q :: T` be generalized elements.
Under your definition the most Web 1.0 html site from 20yrs ago would be an SPA with a couple lines of JS to get the HTML on a link click and inject it into the DOM + a pushState call to replace the page. SSR was a solution to SPA's being clunky and slow. I've never heard anyone call a complex frontend built with React/Vue/Angular/etc that is pre-rendered with SSR an SPA. I'm not even being pedantic, this distinction is important.
There's a few good SPA usecases: Anything replicating a desktop app experience, such as Google Docs and a lesser extent GMail, basically where all of the state is self-contained in a single interface. Spotify's music player is another good example. Plus companies that *need* to reuse their website code as a native mobile/desktop app, because they can't afford native app developers or are bold enough to attempt to do it on purpose. Then they can use React/Vue native which is an improvement over the old way with Backbone.js SPA + Cordova (which I had the unfortunate experience of having to build). Or obviously the reverse when you want your mobile app to be available on the web. There's no real point to use SPAs unless you're 95%+ of your UX is 1 or 2 pages (ie, list/show: HN's frontpage -&gt; comments, Spotify's browse -&gt; now playing OR a heavy single page: spreadsheet or photoshop clone). I really can't think of many other use-cases... SSR provides enough of the gains of an SPA for anything with multiple complex interactive UI components across multiple pages. If SSR isn't an option then the next best thing is async lazy-loading of JS+CSS components with something like [Vue-Router](https://router.vuejs.org/guide/advanced/lazy-loading.html).
What is the value of this expression: `let q = nq ; nq = q in q`? It sounds like you should start with a book on Haskell. You'll probably be a le to complete your CPU project after the first chapter or two.
recommend to PureScript. that is transpile to javascript. that can run on browser and node.js.
I don‚Äôt know why you keep going on about injecting HTML into a DOM that comes straight from a server. That‚Äôs not what‚Äôs happening in any of the examples we are talking about, they are all requesting and parsing JSON from the respective backends. So what, if it‚Äôs prerendered at all for perf it‚Äôs not allowed to be called an SPA? That‚Äôs incredibly dumb. You have literally zero evidence of your own, I at least provided Wikipedia as a reference for what it means to be an SPA.
Why are you removing all your comments?
The very next sentence of wikipedia countered you're attempt to use the first. Any SSR or AMP site would not fit into that definition. Go on any frontend subreddit and try to argue the new Reddit (or any complex multi-page React/Vue app with SSR) is an "SPA" then come back to tell me what you've learned.
Dude that entire Wikipedia paragraph matches perfectly with Facebook, Reddit and Google sites. It specifically mentions not reloading the page and using the HTML5 history api, and dynamic loading of resources. Why do you keep deleting your comments? Just because you are incorrect and getting downvoted doesn‚Äôt mean you need to censor yourself.
I only removed one comment about 3hrs ago, I felt was too mean when I called you dumb. I didn't delete anything since. Having trouble using Reddit? I apologize for my bad attitude, we had to fire a dumb young developer yesterday, one we invested \*months\* into, who you reminded me of. He also frequently talked out of his ass about technical subjects he's clearly only had a tangental understanding. I swear it's the biggest sign, the type of people whose goal is to learn when presented with information vs being "right" even on subjects they don't fully grasp. You need to find the guys who are looking to learn first, talk second. It's easy to be fooled by the talkers in interviews. Like I said if you can find other front-end people who agree with you, ie something other than your misunderstanding of a paragraph of Wikipedia, then by all means. I'll be happy to change my view of this topic and I'll start thinking SSR and PJAX sites are SPAs.
I see at least 5 deleted comments that were by you. So either you are lying or I suppose they could have been removed by a moderator. Look dude Wikipedia absolutely agrees with me. And apparently so do people who are reading this comment chain. But feel free to keep being stubborn.
I mentioned ask frontend people twice for a good reason and probably mods yeah.
If your so called ‚Äúfrontend people‚Äù acquaintances want to be wrong together then I guess that‚Äôs fine. But I‚Äôm going to stick to what is said by people on this thread and on Wikipedia and by everyone who I know personally.
Ignorance is bliss!
Because clearly going by several different viable and reasonable sources is ‚Äúignorance‚Äù, and listening to your downvoted belligerent ass is ‚Äúthe right thing‚Äù.
http://nandgame.com/ is a great way to learn about hardware circuits, but software programs don't work the same way as circuits, so you shouldn't expect to be able to use the same tricks here. Are you new to programming in general, or only new to Haskell? Typical first programs for new programmers are [Hello World](https://en.wikipedia.org/wiki/%22Hello,_World!%22_program) and [99 bottles of beer](https://en.wikipedia.org/wiki/99_Bottles_of_Beer#References_in_computer_science). A CPU simulator is a much more advanced program. The 99 bottles of beer program is typically how one would learn about keeping track of a piece of state, which is the software equivalent of what SR laches do.
I‚Äôve been building SPAs and client side web apps for 8yrs since Backbone.js 0.1 and way longer doing pure server side before that. So I don‚Äôt need to read a single paragraph of Wikipedia to make up my mind about a subject then spend 30 comments defending it. I do enjoy watching you try though.
Sounds like you have your mind made up and thoroughly stuck in the sand. No amount of sources or public opinion or logical reasoning will sway you. Have a nice life then mate.
Try: latch r s = (q, nq) where q = not (r || nq) nq = not (s || q) It doesn't have a non-bottom value at `latch False False`, but it works for other values of `r` and `s`.
Hakyll, maybe? If you need to do only a little with JS, vanilla(+Julius) is fine for very small things, TypeScript is good for medium things. For large JS things, I'd probably try and work with an established framework -- React, Vue.js, or something like that -- but that son't mean you can use Elm, PureScript, or GHCJS.
&gt; sources &gt; public opinion Enjoy your mediocrity, mate.
&gt; I think asking someone to include source and do a complete re-compile of your program as a method of program configuration is a pretty shit paradigm from a usability perspective. It's why I'd never recommend XMonad as a tiling window manager for someone that isn't at least interested in learning Haskell for some other reason. I point them at lesser tiling window managers. :)
Lmao dude I went to arguably the most prestigious CS university in the world. So that tickles.
"How do you know someone went to [insert ivy league]? They'll tell you" Still waiting on those sources and public opinion. Almost every article on the internet is about SSR vs SPA (strange headlines considering SSR IS SPA right?). Almost all of the ["downsides" section of SPA's Wikipedia](https://en.wikipedia.org/wiki/Single-page_application#Challenges_with_the_SPA_model) are reasons why people use SSR and lazy-loaded web components instead of SPAs.
I literally never bring it up except when someone acts like a massive wanker and tries a dirty underhanded ‚Äúcall out‚Äù like you did. I never claimed all forms of SSR are SPA. All I said was that SPAs can use SSR as a form of optimization. How about [this](https://simplabs.com/blog/2019/04/05/spas-pwas-and-ssr/) as a source, scroll down to where it talks about combining SPA and SSR. How about [this](https://helpx.adobe.com/experience-manager/6-4/sites/developing/using/spa-ssr.html) as well? Honestly dude I‚Äôm getting bored of arguing with a stubborn wanker who no one agrees with. Have fun tho with whatever you are doing with your life.
&gt; All I said was that SPAs can use SSR as a form of optimization. *I* was the one who said this earlier, dummy. This is getting sad. I said when they added SSR to an SPA it was just an optimization. Hopefully when you finish your CS degree you'll learn that Reddit and Facebook are not in fact SPAs and neither of your links do anything to support your arguments. The second one is actually the opposite of supporting your argument as it compares approaches, SSR and SPA being two different approaches. Did you even read the second article you linked to? So much for good schooling. Copy and pasting random links without even reading them...
I was absolutely the first person to bring up using SSR on an SPA when you were making the stupid argument that ‚Äúview source‚Äù on an SPA should give you nothing and that nothing should be displayed without JS enabled. Stop rewriting history. Already finished my CS degree lmao. I did read the second article: &gt; Using server side rendering (SSR) can accelerate the initial load of the page and then pass further rendering on to the client. &gt; When using SSR, the component interaction workflow of SPAs Notice how both of these quotes are specifically focusing on the idea of SSR to speed up the initial page load of an SPA. It is NOT talking about SSR as a replacement to an SPA. You can have (at least) 3 different approaches: SPA with no SSR SPA with SSR SSR-only non-SPA
Is there a remote option?
Is your company still hiring? I'm new in Haskell and would like to look for a remote Haskell job.
&gt; Haskell: web servers, streaming, serialization, databases, etc. Are you asking about whether an applicant has used these via libraries or if they have implemented them on their own?
I would say subtraction shouldn‚Äôt work on Natural, as subtraction is usually based around the idea of a Ring, which Naturals are not. However `monus` should be supported on Naturals, where `monus 3 6 = 0`. Also they should be cancellative, so `cancel 3 6 = Nothing` They should also be a Torsor with Integer as the other type in the Torsor, so `3 -. 6 = (-3 :: Integer)` I guess for your semantics you want some sort of symmetric difference function. Not sure what algebraic structure that would best correspond to. I suppose a mono moronic function would work too.
&gt; they *all* have glasses off when you hover False. There are 4 engineers that remain in glasses even if you hover the pointer over their pics.
You could use some kind of streaming abstraction. [Programming with Arrows](http://www.cse.chalmers.se/~rjmh/afp-arrows.pdf) has a nice example of how to represent a flip-flop with arrows, using `ArrowLoop` for feedback (desugared from `rec` here) and a `delay` function to prevent the definition from being circular: -- Stream functions. newtype SF a b = SF { runSF :: [a] -&gt; [b] } -- Delay the stream with a value. delay x = SF (x :) -- ‚Äòproc‚Äô notation (with ‚Äò{-# LANGUAGE Arrows #-}‚Äô) flipflop :: SF (Bool, Bool) (Bool, Bool) flipflop = proc (reset, set) -&gt; do rec c &lt;- delay False -&lt; nor reset d d &lt;- delay True -&lt; nor set c returnA -&lt; (c, d) where nor a b = not (a || b) -- = -- Desugaring flipflop = loop $ arr (\ ((reset, set), ~(c, d)) -&gt; ((set, d), (reset, c))) &gt;&gt;&gt; nor *** nor &gt;&gt;&gt; delay (False, True) &gt;&gt;&gt; arr id &amp;&amp;&amp; arr id I‚Äôm sure this kind of thing could also be done with other streaming abstractions such as `pipes` and `conduit` (not super familiar with them‚ÄîI‚Äôd be happy to see a translation if anyone‚Äôs willing to offer one), but in any case you can‚Äôt have *direct* cross-coupling or you‚Äôll just get infinite loops.
I mostly said this because Num has a (-) operator
\&gt; If you do even a little bit of research, it's well-documented what disadvantages of existing types that new types were introduced to offset. &amp;#x200B; But this is actually important. In a language with a JIT compiler, there would be no need to expose the difference between \`String\` and \`Text\` at the type level. It's quite a serious problem to have these leaky abstractions exposed everywhere.
Reflex can SSR
People may have a good reason to prefer unity over godot.
How to write the fastest norm function? So far, I got good results with `U.sum . U.map square`, and it beats naive C, but it's still far from blas performances. It might be because I'm not using SSE or AVX instructions, but there is little documentation on the subject. All I know is that ghc has some primitives for it, but I'm not sure how to use them
Have you looked at the `.prof` file? It'll tell you exactly what in your program allocates this much
You are technically correct, the best kind of correct.
If hardware is something you‚Äôre interested in, clash is something you should definitely look at.
Yes, I did. [.prof file](https://pastebin.com/AdPPKZ28) looks reasonable to me. But putting `A` 10000 times into `Data.Map.Strict.Map ByteString (Vector ByteString)` shouldn't allocation such high amount of memory. What does the `Productivity` last summery line mean? There is nothing about in [Profiler User Guide](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html).
If I recall correctly `Productivity` is the amount of non-GC time spent. As you can see there, most of the time went into the GC, and so less on actually doing the work. So apparently your most expensive line is this one: `pantry = pantry' (\_ -&gt; Just (Data.Vector.snoc vec "X")) n (pantry q)`. A `snoc` operation on a `Vector` is expensive, you create a whole new vector every time, hence, I think the large allocation + GC time. You probably want to choose a different data structure. See these links: - https://stackoverflow.com/questions/1739675/efficient-queue-in-haskell - https://www.reddit.com/r/haskell/comments/4lipsr/recommended_queue_package_xpost_from/ - https://www.well-typed.com/blog/2016/01/efficient-queues/ In short it seems like you'd be much better off with `Data.Sequence`
Thank you for taking your time to help me! &gt; In short it seems like you'd be much better off with `Data.Sequence` I'm going to replace `Data.Vector` by `Data.Sequence` in hope of gaining performance.
The type of \`absurd\` confused the hell out of me when I was learning
I'm as big a fan of over-engineering as the next dev that doesn't want to ever release anything, but this strikes me as an incredibly expensive way to generate a static site?
Since we're dealing with a level-sensitive memory element, we have to module continuous time: import Control.Applicative type Time = Double -- | Continuous time signal newtype Signal a = Signal (Time -&gt; a) instance Functor Signal where fmap f (Signal s) = Signal (\t -&gt; f (s t)) instance Applicative Signal where pure a = Signal (const a) (Signal f) &lt;*&gt; ~(Signal a) = Signal (\t -&gt; (f t) (a t)) -- | Delay a signal after :: Signal a -&gt; (Time,a) -- ^ Delay + default value -- -- We need a default value since we only have we don't -- want to deal with unknown power-up values -&gt; Signal a after ~(Signal s) (d,u) = Signal (\t -&gt; if t &lt; 0.0 then u else s (t - d)) infixl `after` -- | Sample a signal at an interval sample :: Time -&gt; Signal a -&gt; [a] sample i (Signal f) = [f t | t &lt;- [0.0, 0.0+i ..]] -- | Create a signal from a list of samples toSignal :: Time -&gt; [a] -&gt; Signal a toSignal i values = Signal (\t -&gt; values !! (round (t / i))) srlatch r s = (q, nq) where q = not &lt;$&gt; (liftA2 (||) r nq) `after` (0.00001,True) nq = not &lt;$&gt; (liftA2 (||) s q ) `after` (0.00001,False) test = take 10 (sample 0.05 q) where q = fst (srlatch r s) r = pure False s = toSignal 0.2 (False:True:repeat False)
Can anyone think of a better name for the following type class? Or do they think `FoldAp` is suitable? class FoldAp (r :: *) (a :: *) (as :: [*]) where foldAp :: a -&gt; NP I as -&gt; r instance (a ~ r) =&gt; FoldAp r a '[] where foldAp f _ = f instance FoldAp r b as =&gt; FoldAp r (a -&gt; b) (a ': as) where foldAp f (I x :* xs) = foldAp (f x) xs -- Examples of use: foo :: Bool foo = foldAp (const :: Bool -&gt; String -&gt; Bool) (I True :* I "Wurble" :* Nil) bar :: String -&gt; Bool bar = foldAp (const :: Bool -&gt; String -&gt; Bool) (I True :* Nil) Or, has anyone seen this crop up before in the wild to save me defining it myself? Perhaps where the type of the heterogeneous list is abstracted too?
Asked if it can export HTML here https://www.reddit.com/r/reflexfrp/comments/c04c33/can_reflex_render_static_sites_export_plain_html/?utm_medium=android_app&amp;utm_source=share
Yes, you can use nextjs + purescript https://nextjs.org/learn/excel/static-html-export https://github.com/jonasbuntinx/next-purescript-example And prepack-webpack to optimize
This is about where things went off the rails. u/Tysonzero and u/scott__the__dick: I've locked the thread in order to give you an opportunity to cool off.
Yeah I gotta say I hate that aspect of `Num`. I want Semiring and Ring at minimum, all totally separate from `abs` and `signum` and `fromIntegral`. Because yeah current Num is a Ring and then some, and Natural isn‚Äôt a Ring. So it‚Äôs kind of awkward.
Reflex's SSR doesn't seem appropriate here. I suppose technically it could be used to generate static HTML sites, but why bother when you could just deploy a fully working reflex SPA? See https://tomsmalley.github.io/semantic-reflex for an example using github pages. I'd suggest using Hakyll unless you want some interactivity - it's much more straightforward - but you'll have to move away from it if you want more than static HTML.
I figured out a way to make the poly-kinded way work using data families: type (a :: k) ~&gt; (b :: k) = Morphism k a b newtype Natural (f :: j -&gt; k) (g :: j -&gt; k) = Natural { getNatural :: forall (x :: j). f x ~&gt; g x } type family Morphism k :: k -&gt; k -&gt; Type where Morphism Type = (-&gt;) Morphism (j -&gt; k) = Natural class DataKind k where data Free :: (k -&gt; Constraint) -&gt; k -&gt; k interpret :: forall (cls :: k -&gt; Constraint) (u :: k) (v :: k). cls v =&gt; (u ~&gt; v) -&gt; (Free cls u ~&gt; v) call :: forall (cls :: k -&gt; Constraint) (u :: k). u ~&gt; Free cls u instance DataKind Type where newtype Free cls u = Free0 { runFree0 :: forall v. cls v =&gt; (u ~&gt; v) -&gt; v } interpret f = \(Free0 g) -&gt; g f call = \u -&gt; Free0 $ \f -&gt; f u instance DataKind (k -&gt; Type) where newtype Free cls u a = Free1 { runFree1 :: forall v. cls v =&gt; (u ~&gt; v) -&gt; v a } interpret f = Natural $ \(Free1 g) -&gt; g f call = Natural $ \ux -&gt; Free1 $ \f -&gt; getNatural f ux instance DataKind (j -&gt; k -&gt; Type) where newtype Free cls u a b = Free2 { runFree2 :: forall v. cls v =&gt; (u ~&gt; v) -&gt; v a b } interpret f = Natural $ Natural $ \(Free2 g) -&gt; g f call = Natural $ Natural $ \uxy -&gt; Free2 $ \f -&gt; getNatural f `getNatural` uxy
To address servant specifically: I'm confident this would be possible, and reasonably confident that I could do it myself without too much trouble. Like a day's work, give or take, depending what exactly you want to do. I don't know if a tool for it already exists. I don't know your experience level, but I think I would have found it very difficult back when I started with Haskell. So if you're new, it's not the approach I'd recommend.
Hover? Some of us are on mobile and have no notion of hover! :P
Probably yes, but I think it in russian language.
I've made quite a few reflex apps. And I was assuming I could put them as endpoints in my site, currently, [my page](https://trevorcook.github.io) is a reflex app. If you visit you'll see its nothing to brag about. The problem I'm trying to address here is organizing many such pages--some lucid, some reflex--because I like and want to work with them. Hakyll seems like it should do the trick for me. The page says create content in any format I prefer, so it looks like what I need.
I'll give it a try, thanks.
This is a list of assertions/viewpoints that this report refutes/discloses. Church encoded free monads is good.
Shake is another option. Here's an example: [https://github.com/mrkkrp/markkarpov.com](https://github.com/mrkkrp/markkarpov.com)
Yeah, now that you mentioned it, `abs` isn't necessary either. For example, the instance (Floating x) =&gt; Num (Complex x) is hideous. And |x| isn't even a general mathematical concept! There may very well be more spaces with sensible multiplication and addition functions, but no absolute value... I mean, `Complex Integer` would be, but TBH that's a really useless type.
Hint: How can `x` be equal to `author` and `year`? How many arguments should this function be taking?
Your definitions don't name the `Year` parameter. Start them out as: `search_author_year a y ...` instead of `search_author_year a ...`.
I've plenty of Haskell experience, and like I said, this is for a hobby so if it was a valuable thing I might pursue it just because it sounds interesting. If you are able, mind indulging me in some implementation speculation? I don't know servant, and my web knowledge is paltry. It seems to me like you'd have to make a `ToStatic` class, for servant apps, and include basic combinators like `symbol :&gt; Get '[Html] a`, but exclude server dependent combinators such as `Put a b`. The class method would be some `IO` that creates sub-directories and pages based on the usual rendering of those pages. I'm not sure about the link handling. I suppose you might provide to the renderer some prefix where the site would be hosted. Also, why do this? I was drawn to 'servant' because the type safe API's. With the type direction we could ensure that the whole site gets copied, and no broken links. Another feature, I was looking at the raw endpoint and it seems like a good way to integrate multiple projects. I could just call that other projects `toStatic` with the captured prefix + super sites prefix. This probably isn't servant specific though. I imagine Hakyll allows something similar to this as long as you give it a way to render the servant site.
JIT shouldn't be changing the semantics, and String, Text, Text.Lazy, ByteString, ByteString.Lazy, and [Word8] have *different semantics*, so yes, they should be different at the type level.
You should change the name, "looper" is already taken: https://looper.readthedocs.io/en/latest/ and I know at least one Fortune 1 company that is using the existing "looper" quite a bit internally. It's unlikely the existing project will change their name.
And one creative director. Though, they do at least change into "normal" glasses and out of the sunglasses.
This particular example would have worked fine with discrete time. I can't think of anything that can't bee addressed with quantum-level discrete time; 1 tick = Planck length / speed of light, except for possibly some open questions in physics. --- Also, `Double` isn't continuous.
Anyway we can clearly see they are doing shady business.
Reported to /r/PunPatrol ;)
What is the semantic difference between string and text?
Yeah, when you talk about free monads, as I understand it there is a notion of "initial" vs "final" encodings. `polysemy` uses final encodings, `freer-simple` uses initial encodings. I _think_ the main speed difference comes from the fact that the way final encodings are expressed allow them to push the run time cost (paid every time the code executes) to a compile time cost (which is paid "once"). I am _not_ an expert in the implementations of these things though and invite someone to tell me where I'm wrong.
Thanks for the clarification.
Sorry for a late reply. Function is taking three arguments (list, one input for year to search and one input for author). In my limited understanding of Haskell i thought that x is a vaue of the list so i was trying to compare both year and author to the values inside of a list.
Well you do, you can either use USB OTG cable and plug in a generic USB mouse or pair a bluetooth mouse to most android phones and get a pointer. IIRC it used to work, but don't quote me on that! :D
I was passing y from a main method where you would input both author and year. And after that declared them as types above the function. I'm I misunderstanding something I thought both a and x inside the function where used only as a variable for a list?
```search_author_year a [] = Nothing``` I only count two arguments here.
String supports any Char (Unicode codepoint). Text only supports Unicode scalars. Also, the operational semantics diverge quite a bit.
How you are calling your function from `main`: `search_author_year a y list` (Notice: 3 arguments: author, year, and a list) How you are defining your function: `search_author_year a [] = ...` and `search_author_year x ((key, title, author, journal, volume, number , pages , month , year, annote):r) | ...` (Notice: two arguments: something (unclear whether author or year), and a list). Your calls to and definitions of your function need to have the same number (and types) of arguments.
so writing it like this: search_author_year :: Author -&gt; Year -&gt; ListBib -&gt; Maybe Article search_author_year a b [] =Nothing search_author_year x y ((key, title, author, journal, volume, number , pages , month , year, annote):r) | x==author &amp;&amp; y==year = Just (key, title, author, journal, volume, number , pages , month , year, annote) | otherwise = search_author_year x r Should solve the problem? I thought the a variable references only to the list inside that part?
Try it! (This is still not correct. See if you can spot the mistake yourself)
hello from your patreon!
Iam calling a function with this line inside the menu else if (resp=="5") then do putStr "author: " a &lt;- getLine putStr "year: " y &lt;- getLine putStr(show(search_author_year a y list)++"\n") This sends String author and String Year with the listOfBibliography to the function: search_author_year :: Author -&gt; Year -&gt; ListBib -&gt; Maybe Article search_author_year a b [] =Nothing search_author_year x y ((key, title, author, journal, volume,number , pages , month , year, annote):r) | x==author &amp;&amp; y==year = Just (key, title, author, journal,volume, number , pages , month , year, annote) | otherwise = search_author_year x r If I understand this part search_author_year :: Author -&gt; Year -&gt; ListBib -&gt; Maybe Article should take those arguments from the call and then return article If the professora actually explained correctly first part search_author_year a b [] =Nothing serves to have something happen in case of a blank list second part search_author_year x y ((key, title, author, journal, volume,number , pages , month , year, annote):r) matches x and y with the list? and the third part does the comparision and what will happen? | x==author &amp;&amp; y==year = Just (key, title, author, journal,volume, number , pages , month , year, annote)
I did try it its reporting two missmatches Couldn't match expected type ‚ÄòMaybe Article‚Äô with actual type ‚ÄòListBib -&gt; Maybe Article‚Äô ‚Ä¢ Probable cause: ‚Äòsearch_author_year‚Äô is applied to too few arguments and Couldn't match type ‚Äò(Key, Title, Author, Journal, Volume, Number, Pages, Month, Year, Annote)‚Äô with ‚ÄòChar‚Äô Expected type: Year Actual type: [Article]
Look more closely at the recursive call.
Thank you!! I spent 10 hours trying different combinations :) I still have 2 more things to do (save two types of files and make a graph) but this helped alot
Honestly, it sounds like you've thought it through about as well as I have. I'm not sure about the link handling either. If you want to have a collection of template files on disk, and don't want to list them all in your source code, then... I had been going to say you'll want to generate a type with template haskell, but then I realised you probably don't want to recompile every time you add a template file either. In which case I guess you're looking at existential types, but I'm not at a level where I can talk about those extemporaneously.
I see your question was already answered. Here's a little trick you might find useful: You can name pattern matches so you don't have to completely rebuild your article tuple. So instead of this: *(field list shortened for readability)* search_author_year x y ((key, title, author):r) | x == author = Just (key, title, author) You can do: search_author_year x y (article@(key, title, author):r) | x == author = Just article See https://en.wikibooks.org/wiki/Haskell/Pattern_matching#As-patterns It works anywhere you do a pattern match, even recursively so you could do `fullmatch@(article@(key, title, author):r)` and so on.
Both of these are mostly details. You don't want to deal with Unicode points that are not a Unicode scalar in normal code. The real reason is that there are two implementations and thus two types. That's leaky. Chunked and not chunked representations have the same operational complexity.
Thanks for tip
I wrote a discrete implementation: import Control.Applicative (liftA2) infixr :- data Stream a = a :- (Stream a) instance Functor Stream where fmap f ~(x :- xs) = f x :- fmap f xs instance Applicative Stream where pure a = a :- pure a ~(f :- fs) &lt;*&gt; ~(x :- xs) = f x :- (fs &lt;*&gt; xs) liftA2 f ~(x :- xs) ~(y :- ys) = f x y :- liftA2 f xs ys notS :: Stream Bool -&gt; Stream Bool notS = fmap not orS :: Stream Bool -&gt; Stream Bool -&gt; Stream Bool orS = liftA2 (||) srLatch :: Stream Bool -&gt; Stream Bool -&gt; Stream Bool srLatch s r = q where q = False :- notS (nq `orS` r) nq = True :- notS (q `orS` s) This does require pulses which are two ticks in size, otherwise it will oscillate. You could even do it with lists: srLatch :: [Bool] -&gt; [Bool] -&gt; [Bool] srLatch s r = q where q = False : map not (zipWith or nq r) nq = True : map not (zipWith or q s)
White power.
Good point! Should I also change my name? I'm aware of at least one celebrity who shares my first name, and I'm fairly confident they won't change their name.
Hello, and thank you very much! It's very important to me. Inspiring :) &amp;#x200B; Hope, all is OK? I mean, are you satisfied by the activities I do for you and other supporters?
How do you find the head of the following data type? data List :: [*] -&gt; * where Empty :: List '[] Singleton :: a -&gt; List '[a] Append :: List xs -&gt; List ys -&gt; List (xs &lt;++&gt; ys) type family xs &lt;++&gt; ys '[] &lt;++&gt; ys = ys (x:xs) &lt;++&gt; ys = x:(xs &lt;++&gt; ys) I tried head :: List (x:xs) -&gt; x head (Singleton x) = x head (Append xs ys) = case xs of Empty -&gt; head ys Singleton x -&gt; x (Append xs' ys') -&gt; head (Append xs' ys') But that gave the error of ‚Ä¢ Could not deduce: xs1 ~ (x : xs0) from the context: (x : xs) ~ (xs1 &lt;++&gt; ys)
I disagree about only wanting to deal with Unicode Scalars only. I want to be able to handle the letter n composed with umlauts so I can display or take as input the correct version of the name "Spinal Tap."
Just tap a photo :)
The shake build system is used to generate the site as a build output. Interesting, especially since Shake has nothing to do with web frameworks, per se. I'll keep it in mind, but think I'll have to skip for now. Thanks.
Thanks. I didn't know that about reflex.
This looks very interesting! Is it all Haskell? As you say ‚Äúfunctional languages like Haskell‚Äù, it kinda implies there are other languages used?
Hurrah! Thank you stack devs! First impression: stack build is rather verbose by default now. Probably that was done for good reason and maybe I'll come to appreciate it. Surprisingly it doesn't seem possible to mimic the old version's default verbosity, ie just logging package names.
You can add `--no-interleaved-output`, or `interleaved-output: false` in your config files.
There it is! Thank you sir!
I think this is a valid concern and don't quite understand why bss03's response is being downvoted. A known conflict like this makes it more difficult to talk about and disambiguate the project, for no real benefit. Unique names also make it easier for somebody to google the project and its documentation. I just searched for "looper library" and it was nowhere to be found. Even after making it "haskell looper library" it was still this post that came up, a few results down.
&gt; second part &gt; `search_author_year x y ((key, title, author, journal, volume,number , pages , month , year, annote):r)` &gt; matches x and y with the list? No. It matches `((key, title, author, journal, volume,number , pages , month , year, annote):r)` with the list.
Lazy and strict do not necessarily have the same operational semantics.
If you want people to be able to find you on Google by a name, it should be unique or have previously established popularity. Similar to the SAG requirement that members names be unique.
&gt;consider yourself lucky What, you consider yourself lucky that you don't get this kind of stuff on a more regular basis. Or are you going to insinuate that IO has not been one of the most question raising thing across the haskell board? Also &gt;I left this as an exercise for you After boasting about how, in your merciful angelic mercy, you did "my homework" for me. You left it as an exercise because it's a big old pain in the ass to do and you'd rather do anything else but work a single second longer on this. Not that I blame you for it, since IO is horseshit. And I will throw infinite tantys about it, too, because that is the right thing to do it. The web is teeming and chock full of ass backwards hate problems about C and C++. There were literal competitions, for example, to generate the most template error code and I think some contestants managed to have it spew out Boost errors by the gigabytes. The only deep breath I am taking is to tell it how it is. IO is shit. How would I fix it? I don't even know. I don't care much to know. I just know that it is a huge pain in the ass to get going. Now, I would have worked harder on self solving this instead of just finally complaining about it, but have you ever taken a look at stackoverflow, for example? Explaining what a monad itself is often results in not-really-answers and instead goes on a huge grabasstic academical wankorama. And, sure, its quite possible that I'm just a brainlet, that's fair enough, but very few things have elicited this much of a revulsion in me from the get go. Thanks for the partial fix though, I do appreciate it, but you were glad to be not working on it the moment you stopped, I ain't believing anything else.
Yeah, that's why terms that are hard to search for like "stack" and "cargo" and "go" aren't used for software projects.
It really seemed to a few people here and on Stack Overflow that there was to much superfluous code in this. Will Ness who helps me a lot did this which I though was brilliant foldr (\p -&gt; mergeAll . map (iterate (*p))) [1] [2,3,5] It was almost twice as fast as mine in `GHCi` but with `ghc -O2 +RTS -s` it was almost twice as slow. &amp;#x200B; So, I started reading about fusion that I had come across in R. Bird's book ***Thinking Functionally with Haskell*** Almost immediately, I tried. mai n = mergeAll.map (iterate (*n)) t= mai 2 $ mai 3 $ iterate (*5) 1 &amp;#x200B; And it matched Will's in `GHCi` but with `ghc +O2 +RTS -s` it beat all. For 100K Hammings &amp;#x200B; TASKS: 3 (1 bound, 2 peak workers (2 total), using -N1) SPARKS: 0 (0 converted, 0 overflowed, 0 dud, 0 GC'd, 0 fizzled) INIT time 0.000s ( 0.000s elapsed) MUT time 0.000s ( 0.002s elapsed) GC time 0.000s ( 0.000s elapsed) EXIT time 0.000s ( 0.000s elapsed) Total time 0.000s ( 0.002s elapsed) Alloc rate 0 bytes per MUT second Productivity 100.0% of total user, 90.2% of total elapsed Every time I try it, it's the same. I just can't believe it. The elapsed time is what really gets me.
We're going to need the link in order to do that.
Sometimes I amaze myself, not always in a good way. Thanks!
I know the feeling :) Thanks for writing this post. I've wanted something like this for a long time.
They will probably still be applicable to the ML family of languages. At least, that's what I gather.
I would have advised against those sames as well. It certainly would be easier to find them with more unique names.
Nice timing! Over in r/rust there's [a video of a new talk](https://www.reddit.com/r/rust/comments/bzd22g/responsive_compilers_nicholas_matsakis_pliss_2019/) about "responsive compilers" (The talk mentions the "Build systems a la carte" paper!). Seems like they're moving in a similar direction, albeit at a different level in the tool stack. See you at ZuriHac! :)
I'm pretty sure both of those are scalars. Orphaned surrogates (half of a surrogate pair) are codepoints, but not scalars, IIRC.
 head (Append xs ys) = case xs of ... Append xs' ys' -&gt; head (Append xs' ys') What if both `xs'` and `ys'` are empty, and `ys` isn't? Perhaps you meant head (Append xs0 zs) = case xs0 of Append xs ys -&gt; head (Append xs (Append ys zs)) But the problem is that this list for the recursive call has type `xs &lt;++&gt; (ys &lt;++&gt; zs)`, whereas the argument `Append (Append xs ys) zs` has type `(xs &lt;++&gt; ys) &lt;++&gt; zs`. These are two different types as far as the compiler is concerned. We need to give it a proof that they are equal. If we could somehow construct that proof, then we could write: head (Append xs0 (zs :: List zs)) = case xs0 of ... Append (xs :: List xs) (ys :: List ys) -&gt; let pf :: ((xs &lt;++&gt; ys) &lt;++&gt; zs) :~: (xs &lt;++&gt; (ys &lt;++&gt; zs)) pf = undefined -- TODO: prove/implement this case pf of Refl -&gt; head (Append xs (Append ys zs)) However to construct that proof we will need to traverse `xs`, and that has bad time complexity. It's also possible to cheat by claiming an "axiom" with `pf = unsafeCoerce (Refl :: () :~: ())`, but, well, it's cheating. In the `Append` case, we don't know which list is nonempty, so we can't make the recursive call. In other words, "nonemptiness" is not a good invariant for this recursive function. It turns out that a simpler way is to write the very-strongly-typed variant of `headMaybe`, which may take an empty list/tree and return `Nothing`, except that it also returns a proof that the list is empty. To that end, we define this variant of `Maybe`, indexed by the list: -- Head of a list xs data HeadRes xs where HeadResNil :: HeadRes '[] -- there is no head HeadResCons :: x -&gt; HeadRes (x ': xs) Then, `headMaybe`: 1. needs to handle the `Empty` case; 2. in the `Append` case, search in the left subtree, if it's empty, the evidence that `xs ~ '[]` is made available to the typechecker, so that `xs &lt;++&gt; ys ~ ys`, so the head of the list `xs &lt;++&gt; ys` (which is what we want at the top) is exactly the head of the list `ys`, so we can search in `ys` recursively. headMaybe :: List xs -&gt; HeadRes xs headMaybe Empty = HeadResNil headMaybe (Singleton x) = HeadResCons x headMaybe (Append xs ys) = case headMaybe xs of HeadResNil -&gt; headMaybe ys HeadResCons x -&gt; HeadResCons x head :: List (x ': xs) -&gt; x head xs = case headMaybe xs of HeadResCons x -&gt; x
Referential transparency.
I think that's a fine name. It's also a generalized `uncurry`.
Sorry for the delay. Formality Net has a lazy (but sequential) evaluator, which is actually the main one used on the CPU implementations, it is the `reduce_lazy` [here](https://github.com/moonad/Formality-Net/blob/master/javascript/fm-net.js). To use it, just type `fmc -l your_term`.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/haskell_jp] [hsp - a haskell command line text stream processor](https://www.reddit.com/r/haskell_jp/comments/c0cr2e/hsp_a_haskell_command_line_text_stream_processor/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Ok.
I really love the new interleaved output. Makes me feel like a hacker with so much text going across the screen and it's real easy to pinpoint the slow modules in compilation.
So I tried this: getRootR = defaultLayout . handlerToWidget $ sendFile typeHtml "index.html" It takes a few seconds for the javascript to show up. I'm not sure if this is yesod being slow or if its the javascript. My .js file was compiled via Elm.
Hey, sorry it's been difficult to get up and running with Haskell. &amp;#x200B; It looks like the \[tidalcycles GitHub repo\]([https://github.com/tidalcycles/Tidal](https://github.com/tidalcycles/Tidal)) has a \`stack.yaml\` file, which means it should be compatible with the \`stack\` build tool. I'd recommend visiting the \[Haskell \`stack\` homepage\]([https://docs.haskellstack.org/en/stable/README/](https://docs.haskellstack.org/en/stable/README/)) and following the instructions to download and setup \`stack\`. Then you should just be able to run the following commands: \`\`\` git clone [git@github.com](mailto:git@github.com):tidalcycles/Tidal.git stack build \`\`\` ...and it should automatically set up the Haskell compiler (GHC) and build the project.
&gt;git clone git@github.com:tidalcycles/Tidal.git stack build Thanks for the help. &amp;#x200B; I get this message though when I put it into the terminal: &gt;stack build &gt; &gt;git@github.com: Permission denied (publickey). &gt; &gt;fatal: Could not read from remote repository.
Hey sorry it looks like Reddit‚Äôs comment system messed up that link the first time. Try it again? It should work now.
My response was too glib. I'm sorry. I didn't mean to go off on you, but I was surprised to see you double down after u/ijmustafa made the type of remark that I wanted too. I'm tired of seeing this discussion about names not being unique enough. I feel like it comes up every time that a project with a slightly common name hits the news. And the ensuing discussion is rarely interesting or entertaining. For example, these terrible replies to [Small Assets without the Headache in Elm 0.19](https://elm-lang.org/blog/small-assets-without-the-headache): - [is it just me? i thought this old school email client is getting an update after a decade?](https://news.ycombinator.com/item?id=17809266) - [Switched to mutt like 18 years ago.](https://news.ycombinator.com/item?id=17810209) - [The real Elm has been at version 2.5.8 for many years. Why didn't these guys pick a name not already used by a famous piece of software?](https://news.ycombinator.com/item?id=17809309) Careful! You might get burned by those hot takes. It seems to me that projects are likely to succeed or fail regardless of their name. In other words, the outcome of a project is probably tied to something else, like its merits or the popularity of its creator or its budget. As a concrete example, is "Edge" a good name for a browser? No, probably not. But will that prevent people from finding it? Almost certainly not. If someone hears the name, they probably also heard what it is, so they're likely to search for something like "edge browser" or "microsoft edge". Furthermore, why should this author choose a different name for their package because a package from a different language that does something completely different happens to have the same name? Why is [github.com/pepkit/looper](https://github.com/pepkit/looper/) "the" Looper and all other projects must choose something else? Should all of these Loopers change their names too? [spite/looper](https://github.com/spite/looper), [sureskumar/Looper](https://github.com/sureskumar/Looper), and [nathany/looper](https://github.com/nathany/looper)? What about the movie [Looper](https://en.wikipedia.org/wiki/Looper_\(film\))?
**Looper (film)** Looper is a 2012 American science fiction action film written and directed by Rian Johnson, and produced by Ram Bergman and James D. Stern. It stars Bruce Willis, Joseph Gordon-Levitt, and Emily Blunt. It revolves around "present-day" contract killers called "loopers" hired by criminal syndicates from the future to terminate victims that they send back through time. Looper was selected as the opening film of the 2012 Toronto International Film Festival and was released in the United States on September 28, 2012. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/haskell/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
On Debian, I use `aptitude install haskell-platform`. Life is so much easier when you use an OS that doesn't suck.
I got Haskell installed, thank you!
&gt; I'm tired of seeing this discussion about names not being unique enough. I'm tried of people claiming names of software I've used for years that one Google search would have told them is *already in use*. Elm and Chromium being the most memorable to me. Naming things is one of the only hard things in computer science -- people should spend more effort on it, not less. I'd honestly be fine if software projects had to play by [SAG rules](https://en.wikipedia.org/wiki/Stage_name#Guild_and_association_rules); names are first-come first-serve non-reusable -- first looper wins, the rest can go back and come up with something else. I say it better to find a unique name now, than to re-brand yourself later if you end up competing for search space (or trademarks!) with something you share a name with.
What about using fromJust to avoid the nesting?
I actually don't have the 'full' Haskell version. I was able to install Haskell from another Reddit post, but it wasn't the 'full' version. I tried going back to this post. Still the same error message. &amp;#x200B; When I put this code into terminal: &amp;#x200B; `git clone git@github.com:tidalcycles/Tidal.git` `stack build` &amp;#x200B; I get this error message still: `Cloning into 'Tidal'...` `git@github.com: Permission denied (publickey).` `fatal: Could not read from remote repository.` `Please make sure you have the correct access rights` `and the repository exists.`
Looks like everyone is assuming you have a dev setup somewhere. Try cloning the https url, not the ssh url. git clone https://GitHub.com/tidalcycles/tidal.git
&gt; git clone https://GitHub.com/tidalcycles/tidal.git This works but when I double check to make sure it downloaded I put "ghci" into the terminal, then "import Sound.Tidal.Context", and get the error message: &lt;no location info&gt;: error: Could not find module ‚ÄòSound.Tidal.Context‚Äô It is not a module in the current program, or in any known package. Prelude&gt; And i think I get this because i don't have the 'full' Haskell version. When i try to download the 'full' version it asks for all of these dependencies to download, which is a whole other headache.
stack works sort of like Python and Ruby environments - it will install the correct version of GHC (and ghci or whatever) and dependencies for each stack-enabled project. It doesn't install a global system version of Haskell. So after you clone tidal, you'd change to that directory and run things through stack. For example `stack build` or `stack ghci`. Documentation for stack is here: https://docs.haskellstack.org/en/stable/README/ - here is info on ghci through stack specifically: https://docs.haskellstack.org/en/stable/ghci/ It sounds like you *also* have a system version of ghc (and ghci) installed. That won't use the packages or version of ghc that stack will install for that specific package. If you want to make your own project that uses Tidal as a library, what you *probably* want to do is create your own project using stack (refer to the docs) and set up tidal as a dependency. Then you can use `stack build` or `stack ghci` in your own project with Tidal and it will pull in everything necessary.
The examples and concepts are mostly in Haskell. There are a few examples in Scala in the first two chapters. The book was started in 2016, and I stopped working on it in 2017. There is a project in Haskell illustrating the ideas: [Andromeda](https://github.com/graninas/Andromeda) (SCADA-like top app for controlling space ships). You may also get familiar with code samples and listings from the book in this repository: [Functional Design and Architecture](https://github.com/graninas/Functional-Design-and-Architecture). In fact, I successfully used many of these ideas at my regular work. These two frameworks are based on Free monads: * [Node Framework](https://github.com/graninas/Node) \- a comprehensive framework to create complex multithreaded concurrent apps in Haskell with network interaction via TCP, UDP or JSON RPC. You can even serve different protocols at the same time. It's easy to write Rest services for example. The framework contains many needed bolts and pieces out-of-the-box: logging, configs management, file system, KV database, concurrent state based on STM and so on. What's important, the code will be very well structured and easy to write and understand thanks to the design of Free languages. You can read more about the framework in this [tutorial](https://gist.github.com/graninas/9beb8df5d88dda5fa21c47ce9bcb0e16). * [Presto-Core Framework](https://github.com/juspay/purescript-presto). This is a simply made framework that serves a the main business logic at a finance company. You may find even more interesting projects based on the ideas I develop in the book on my [GitHub](https://github.com/graninas).
I‚Äôm so thankful for all the hard work Kazu has done for bringing high quality web standards implementations to the Haskell ecosystem. It‚Äôd be great if there was a way to fund his work directly.
For what it‚Äôs worth, Nix works well on MacOS. That‚Äôs how I manage Haskell stuff on my Macs.
Yesod is not doing any work here, so I don't think it's the problem. Without further details it's hard to guess why it takes so long for your JS rendered page to show up. Maybe you have included external dependencies? Maybe you make some slow HTML calls before actually rendering? You may have a look at the developer console (network tab) in e.g. Firefox to see where most time is lost while loading the page.
I can also recommend /r/haskellquestions
The Gentoo approach.
[removed]
Not a specific answer to your question, but this was a good talk: [https://www.youtube.com/watch?v=y95WtkWCmKg](https://www.youtube.com/watch?v=y95WtkWCmKg) [https://speakerdeck.com/frasertweedale/taming-the-c-monster-haskell-ffi-techniques](https://speakerdeck.com/frasertweedale/taming-the-c-monster-haskell-ffi-techniques?slide=55)
Looks good! But I'm having a few problems: * When I first tried this version, it outputted raw ANSI escape codes instead of colours. Running it with `--color=never` and then `--color=always` seemed to fix this problem, but I'm not sure since I can't reproduce it on the normal command line (although it keeps on giving me raw ANSI escape codes on Emacs). Predictably, I'm using Windows 10. * Whenever I try using `stack` version 2.1.1 in Emacs, whether indirectly via `intero-mode` or directly via `M-x async-shell-command`, I get an error about `'stty' is not recognised as an internal or external command, operable program or external file`. If I'm just running `stack` 'manually', it still works, but if I'm using Intero, this makes it unusable: &amp;#8203; Intero is not installed in the Stack environment. Installing intero-0.1.40 for GHC 'stty' is not recognized as an internal or external command, ... 'stty' is not recognized as an internal or external command, operable program or batch file. Exception while reading snapshot from ghc-'stty' is not recognized as an internal or external command,: InvalidYaml (Just (YamlException "Yaml file not found: C:\\Users\\bradn\\AppData\\Local\\Temp\\interoH3byQg\\ghc-'stty' is not recognized as an internal or external command,")) Could not install Intero! We don't know why it failed. Please read the above output and try installing manually. If that doesn't work, report this as a problem. Guess: You might need the "tinfo" package, e.g. libtinfo-dev. WHAT TO DO NEXT If you don't want to Intero to try installing itself again for this project, just keep this buffer around in your Emacs. If you'd like to try again next time you try use an Intero feature, kill this buffer. It would be nice to report the above issues on the GitHub issue tracker, but since they're caused by a mixture of `stack`, Emacs, Intero and other programs, I'm not entirely sure where to start even...
The other commenter already mentioned this but just to be clear: you need to run `stack ghci`.
[/r/livecoding](https://www.reddit.com/r/livecoding/) is probably a better place to ask this.
I don't have a Maybe, so I don't see how that helps.
Do you have xcode‚Äôs command line tools installed?
This is a bad answer. Instead of solving one problem you‚Äôre creating two problems. It looks like the issue is missing the core tools/libs that come from xcode. Ghcup‚Äôs installer notices and warns. Stack doesn‚Äôt install those tools either. Either way they‚Äôre needed to actually run ghc. Please don‚Äôt recommend ‚Äúuse stack‚Äù as a solution when you haven‚Äôt nailed down the problem.
The parallel GC can be a win or a loss. The variance is also big. It's not at all clear that it should be off by default - my inclination is to understand the cases where it's a loss so that we can fix them. For what it's worth, the parallel GC is a huge win in our (thousands of machines) deployment at Facebook. But we've spent a fair amount of time measuring things and tuning the settings.
To be clear, you must have been using not just \`-threaded\` but also \`-N\`, right? We're not proposing to make \`-N\` the default, only \`-threaded\`. GC would still be single-threaded by default.
Fair enough, but SR-latches don‚Äôt switch at that speed though. I feel that when you deal with asynchronous/level-sensitive memory elements, you shouldn‚Äôt model delays as a discrete time-steps, because in your design you might be accidentally synchronizing, which is just not gonna happen often in your actual circuit.
Interesting project(s)! I've been playing with interaction nets myself, and I'm curious - what did you use to make that animation? And/or do you have recommendations for tools to graphically show and possibly animate/evaluate interaction nets?
Our salaries are competitive for European market and they depend upon your skills and other circumstances, which we are happy to talk through during the hiring process.
A lot of things, but mainly to manage expectations better.
The position is for work on Tezos related projects. We are currently working with [Morley](http://hackage.haskell.org/package/morley) there.
Thanks a lot! I can see how it's related to `uncurry`. Is there no such generalised version in a library somewhere?/should I make one?
I don't think it exists, although I'm not sure where to look for it besides sop-core itself (if that's what you're using).
I think that's accurate. In my use case removing `-threaded` was the first thing I tried since I didn't need much parallelism within each process -- it replaced a fragile shell script doing martialling &amp; data processing for some embedded software benchmarks, and the big performance gain was from scheduling postprocessing simultaneously while the next job was dispatched and blocked on I/O. It was very unintuitive behavior, though, especially since resources like https://wiki.haskell.org/Concurrency encourage `-N` -- it seems like that is only advisable if no other tasks are running on the same machine.
That said, I don't have the build options on hand -- I'll take a look and get back to you with some more details in case they might be surprising
Stack's installer recommends installing the Xcode command line tools: https://github.com/commercialhaskell/stack/blob/b7644ee40d01a58ba1da849c7f899cd2bf5f4b1a/etc/scripts/get-stack.sh#L294-L296
Never mind the type, I've stared at the implementation and I just flatly don't grok it. absurd :: Void -&gt; a absurd a = a `seq` spin a where spin (Void b) = spin b
Great! Very clear and practical introduction. I wish for many more such docs in Haskell land.
Why [removed] ? I wanted to read that.
Hear hear. More: Since TLS 1.3 is a completely different protocol comparing to the older versions, I needed to write a lot of code. Olivier Ch√©ron reviewed my code carefully and thoroughly. He also brought high-quality code to support missing features. My deep thank goes to him. I thank Vincent Hanquez and Viktor Dukhovni for enhancing crytonite and improving certification handling, respectively.
Let's figure it out! When using bindings to a large C library, the author is unlikely to rewrite all the documentation of the original library, and so the way in which you're supposed to figure out how to use the library is by reading the documentation for the original C library and translating the C calls to Haskell calls. So let's look at [libgit2's documentation for `git_remote_url`](https://libgit2.org/libgit2/#v0.18.0/group/remote/git_remote_url): const char * git_remote_url(const git_remote *remote); Get the remote's url. arguments const git_remote * remote: the remote returns const char *: a pointer to the url The Haskell version should somehow correspond to the above: c'git_remote_url :: Ptr C'git_remote -&gt; IO CString Makes sense: we pass a C pointer to the `git_remote` structure, and we get back a C String. In your code, you allocate a pointer to some uninitialized memory and then pass that pointer to `c'git_remote_url`. That would crash in C, and would also crash in Haskell; you're lucky that the type system prevented you from running that code! Clearly, we're supposed to get that pointer from some other call, presumably another libgit2 call which lists all the remotes, like `git remote` does. Browsing through the "remote" section in libgit2's [list of functions](https://libgit2.org/libgit2/#v0.18.0), I see one with [the promising name `git_remote_load`](https://libgit2.org/libgit2/#v0.18.0/group/remote/git_remote_load): int git_remote_list(git_strarray *out, git_repository *repo); Get the information for a particular remote. arguments git_remote ** out: pointer to the new remote object git_repository * repo: the associated repository const char * name: the remote's name returns int: 0 or an error code Corresponding to: c'git_remote_load :: Ptr (Ptr C'git_remote) -&gt; Ptr C'git_repository -&gt; CString -&gt; IO CInt And now we have two problems :) First, we need to get a `Ptr (Ptr C'git_remote)`. This is an output parameter: in C, we sometimes give some uninitialized memory to a function, and the function initializes that memory for us. So while `alloca` didn't work with the type `C'git_remote`, I would expect `alloca` to work fine with the `Ptr (C'git_remote)` type. Second, we need to get a `Ptr C'git_repository`, presumably by receiving it from yet another libgit2 function. Luckily, the demo code you linked to already demonstrates that function: the `C'git_repository` is an output parameter of `c'git_repository_open`, to which you need to pass the path to the `.git` folder of your git repo. Putting everything together: {-# LANGUAGE ScopedTypeVariables #-} import Bindings.Libgit2 import Control.Exception (bracket_, finally) import Control.Monad (unless) import Foreign (Ptr, alloca, peek) import Foreign.C.String (CString, peekCString, withCString) import Foreign.C.Types (CInt) import System.Process (system) git_bracket :: forall a r . String -&gt; (Ptr (Ptr a) -&gt; IO CInt) -&gt; (Ptr a -&gt; IO ()) -&gt; (Ptr a -&gt; IO r) -&gt; IO r git_bracket cmd_name alloc free body = do alloca $ \(ptr_ptr :: Ptr (Ptr a)) -&gt; do r &lt;- alloc ptr_ptr unless (r == 0) $ error (cmd_name ++ " failed") ptr :: Ptr a &lt;- peek ptr_ptr body ptr `finally` free ptr -- | -- &gt;&gt;&gt; main -- Initialized empty Git repository in .../smoke.git/.git/ -- "git@github.com:jwiegley/gitlib.git" main :: IO () main = do -- create a temporary git repo with a single remote. bracket_ (system "git init smoke.git") (system "rm -rf smoke.git") $ do system "git --git-dir=smoke.git/.git remote add origin git@github.com:jwiegley/gitlib.git" -- in the rest of this program, we will use the hlibgit2 to obtain that -- "git@github.com:jwiegley/gitlib.git" URL. withLibGitDo $ do -- specify that we want to look at the "smoke.git" repo withCString "smoke.git/.git" $ \(repository_path :: CString) -&gt; do git_bracket "c'git_repository_open" (\ptr_ptr -&gt; c'git_repository_open ptr_ptr repository_path) c'git_repository_free $ \(repository_ptr :: Ptr C'git_repository) -&gt; do -- get the remote named "origin" withCString "origin" $ \(origin :: CString) -&gt; do git_bracket "c'git_remote_load" (\ptr_ptr -&gt; c'git_remote_load ptr_ptr repository_ptr origin) c'git_remote_free $ \(remote :: Ptr C'git_remote) -&gt; do -- get the url of the remote and print it url :: CString &lt;- c'git_remote_url remote s :: String &lt;- peekCString url print s
Does the following result in \`ExitFailure\` too? \`\`\` $ brew install haskell-stack $ stack new my-project $ cd my-project $ stack setup $ stack build \`\`\`
Random library is not standard built-in. You cannot implement some algorithms without using mutable data structures such as Data.Array.ST which is non-standard.
Even when using fractional time (Double is not continuous; nor is Rational), if you use the same delay value(s), you'll get synchronization artifacts. At time = LCM(all delays), everything synchronizes. You have to either introduce noise into the delays or correctly model at least 2 irrational delays without a multiple (Algebraic numbers / Computable Reals might work, but both are generally slow) to avoid synchronization entirely.
https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#deriving-any-other-class "The compiler will simply generate an instance declaration with no explicitly-defined methods." "The instance context is determined by the type signatures of the derived class‚Äôs methods." --- Looks like it probably also copies the class context to the instance context.
It (generally) won't get to the `spin` call anyway, since `a` is some kind of bottom, and ``x `seq` y`` is `x` when `x` is a bottom. If somehow you did get a non-bottom `Void` value, though it was supposed to give back a bottom (of the infinite loop variety). Also, your implementation doesn't seem to be the implementation [on hackage](https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.Void.html#absurd): absurd a = case a of {}
Oh, I was looking at the one in [`void`](https://hackage.haskell.org/package/void-0.7.1/docs/src/Data-Void.html#absurd). The `base` version is much more obvious.
This is a cool idea for a project and I hope it does what you need and you had fun making it. I still use my "Todo app" as well. Basically a text file and a few bash functions to append to it. Making your own tools is underrated.
Reading this made me wonder what the differences are between a build system like Shake (especially if streaming tasks are now a thing) and FRP? Because this sounds very FRP-like!
And you're going to need to offer a lot more info if you want anyone to help you.
Stack is the way to go if you're new to haskell. However, if you want to see an alternative that's based on cabal alone, you may to take a look at this makefile: https://github.com/metaml/lamha/blob/master/etc/init.mk It's based on brew and ghcup.
Nice writeup! As an FYI, it's likely that in the future, we'll be pushing the library even further in the direction of `withRunInIO` instead of `askUnliftIO`, but there are no current plans for any breaking change.
Good to hear about your interest in i-nets xD The animation is done using Nasic Render ([https://github.com/moonad/Nasic-Render](https://github.com/moonad/Nasic-Render)). Using this repo you will be able to create i-nets, apply the i-net rules and animate it. In the repository, you will find instructions about its usage. To record the animation we have to use an external tool to record the screen, in MacOS, for example, I use Screenshot. To transform the video into a gif I recommend [https://ezgif.com/video-to-gif](https://ezgif.com/video-to-gif).
Fantastic! Thanks a bundle
Personally, I haven‚Äôt had any issues with the latest Stack on MacOS. You could install Docker, set up a linux image and run Stack or Cabal inside it with your project directory mounted as a shared volume.
Yeah, getting the system setup for basically any new vein of work is the worst. I dislike setting up for ocaml, go, ruby, f#... so I sympathize. &amp;#x200B; &gt;My terminal does not recognize a single one of these dependencies. I have HomeBrew installed but still not working. &amp;#x200B; What does this line mean? When I run: `for i in curl g++ gcc gmp make ncurses python3 realpath xz-utils ; do echo "Installing $i" ; brew install $i ; echo "Finished installing $i" ; done` &amp;#x200B; realpath, xzutils, and g++ are the only ones not in brew by those names. \`g++\` is installed along with \`gcc\` so that's already done at this point. xzutils is under the name \`xz\` and likely included in the above dependencies. While I've never heard of or needed realpath it appears early in the results when searching for \`homebrew realpath\`. For this experiment I ignored that requirement and pushed forward to see how things went. &amp;#x200B; At this point I continue with the ghcup install by hitting enter (since it says "press enter to proceed") and it downloads GHC 8.6.5 into .ghcup/bin it seems: &amp;#x200B; `~/.ghcup/bin/ghci-8.6.5` `GHCi, version 8.6.5:` [`http://www.haskell.org/ghc/`](http://www.haskell.org/ghc/) `:? for help` `Prelude&gt;`
Kazu is a treasure
Thanks for the kind words! The write-up was made a lot easier by the existing documentation :)
I happily use \`ghcup\` on OS-X and use \`brew\` for common developer tooling like \`make\`, \`jq\`, and various libraries. &amp;#x200B; That said, I also user docker a lot and find myself running \`docker run --rm -it tommd/haskell\` now and then.
nix. You have to learn nix which has a steep learning curve. But nix on Darwin works great and you get access to not only the Haskell packages but also any C libraries they depend upon.
Ah, there the data type is different, too. Instead of `data Void` (with `EmptyDataDecls`) we have `data Void = Void !Void`. So, the pattern `Void b` is just removing the outermost constructor. And, `spin` will remove as many constructors as necessary to get to be bottom in the Void. This is necessary, since while there aren't non-bottom inhabitants of (that strict, recursive, single-constructor) `Void`, Haskell is lazy so there are expressions that manipulate some `Void`s but still evaluate to a non-bottom value. That implementation of `absurd` wants to give you back whatever `bottom` was involved in constructing the `Void`, not generate a new one. `absurd _ = error "Data.Void: absurd"` would be semantically sound, but potentially throw away information that is useful for debugging. `absurd (Void v) = absurd v` (i.e. absurd = `spin`) seems like it should work, too, but I think somehow it gets turned into it's own little infinite-loop bottom instead of giving you the bottom in the input in some cases. So, you add the explicit strictness (`seq`) to get the "right" bottom. (Much simpler with `EmptyDataDecls`.)
Are you using Spacemacs? If so, consider switching your completion backend to `ghci` until this is fixed. Then, rely on `ghcid` in a separate terminal window to guide you to victory.
Separate compile step and use the resulting binary? I don't consider any compile job that takes less than 1 second to be "quite slow".
I use a nixos docker and mount in everything that I need. I Used to run stack on bare osx, but got segfaults when using ghci and mysql-simple together and didn't find any help.. &amp;#x200B; But be aware that unless you are an experienced and self-going developer then the road to nix is hard.
I'm interested in how to improve compile time as I'd quite like to use Haskell as a scripting language in place of Bash - I understand that it's always going to be slower, but if it could approach the speed of Bash then, for me anyway, it'd provide a great avenue to use more Haskell!
Is `runghc` compiling? I thought it was an interpreter!
Do you have the [`matrix package` installed](https://hackage.haskell.org/package/matrix)? That is, is it listed when you run `ghc-pkg list` from the command line? If not, you'll need to install it using `cabal install matrix`.
thank you so much!
My setup is nix an
You say you are hiring worldwide but only give a vague "competitive for European market" response. How is that helpful for someone from elsewhere? Give an actual salary range! With EUR amounts! Is it ‚Ç¨70K-‚Ç¨100K? ‚Ç¨150K-‚Ç¨200K? Something else?
I could certainly be wrong, but my understanding was that both `runhaskell` and `runghc` do a normal compile to a temporary file, and then execute that file.
On my machine, `runghc hi.hs` takes about as much time as `echo main | ghci hi.hs`, which in turn takes about a third of the time it takes to run `ghc hi.hs &amp;&amp; ./hi`.
https://gitlab.haskell.org/ghc/ghc/blob/master/utils/runghc/Main.hs Yeah, it's definitely behaving more like GHCi, than like GHC. And, it definitely not generating a temporary file that gets exec'd. It looks to me like the "-e" option(s) to GHC forces it to non-interactively interpret rather than compile. (`ghc --help` doesn't document that this flag even exists, and `ghc --show-options` lists it but with absolutely no documentation.)
`-e` is for "[expression evaluation mode](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using.html#eval-mode)". While looking for that documentation I also found [confirmation that `runghc` does not compile its argument](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runghc.html#using-runghc).
You should not have any issue with stack. I strongly encourage you to fix this issue, it's most likely linked to your mac. None of us has any issue with stack (up to date) ;)
(3:) $ [1,2, 3] ++ [4, 5]
Mind sharing a `default.nix`?
That's arguable. that may apply to the transitions of a state monad. certainly not to anything with a big central mutable state. The way to change the state may be more or less organic or composable or expressive, it could be called functional, but not "pure" functional. The paradigm that best match a state machine is object oriented programming. OOP was made to manage events that modify the state of state machines that interact sending messages to other state machines (other objects). State machines do not compose. that's why usually "functional" state machines manage a hugue and unique state machine. there is no algebra for the composition of state machines. Hardly that model could be called functional.
No, I'm not using Spacemacs. But you're right, I should have thought of using `ghcid`!
Is pantry meant to be used by cabal-install as well as stack?
It's fine since that project is in Python so you'll be able to find this looper by writing "looper haskell". The go stdlib has a package called "crypto". Should it be renamed since it is so generic? No, you can just search for "crypto golang" and you'll find it.
Yes.
This is troublesome. I do not have this problem. But I do agree, macOS is a *distant* second-class citizen. A new macOS release will break something, and then IMO it takes months for it to work again. If you're looking for stability, perhaps use Debian under VirtualBox. Set it up to allow SSH and SSH in from the Mac terminal.
I'm surprised to hear this, because I've been working on a mac exclusively for the last 15 years or so, and haven't had any significant problems. I download the binary ghc distribution from the usual ghc page, then use the old style global cabal db. I have some scripts to uninstall libraries, and fiddle with symlinks to change ghc version, but that's basically it. A year or so ago there was an OS X update that caused lots of linker noise, and I had to edit ghc settings to turn a flag off, but I can't think of any other mac-specific problems. I've actually had a better experience on the mac than with linux, because linux can never decide which version of ncurses it has, or which version of libgmp, and I have to fiddle with sketchy dynlib symlinking or non-official packages or whatever. I usually stay a major version or so behind the latest, for both ghc and os x, so maybe that has something to do with it.
I like this idea.
This was an excellent explanation and walk-through. Thank you so much! And instead of giving me a fish, you taught me _how to_ fish.
Actually, cabal works for me but stack does not. I just don't want to keep having a debate with myself over stack vs cabal. I thought about it many months ago and decided to use stack. But now cabal is the only thing that works for me.
I've been considering SSHing into a VM. I will just do either that or use Docker. I don't mind tinkering with things. I just prefer to direct my effort at problems versus tools.
It might be more overhead than you like for a test suite, but I'd probably use aeson/waargonaut to parse the JSON, then get at the values I want with whatever nested structure convenience library I can justify taking on as a test dependency (lenses or something).
"Hello world" is an incredibly poor way to compare Haskell with Bash for scripting. The startup costs for the `runghc` and the the Haskell run time system would be orders of magnitude more than that for Bash. A fairer comparison would be to do something more that just print "Hello world". Another approach would be to run `shellcheck` (written in Haskell) on your bash scripts.
Thank you for bringing awareness to this. I have looked at the makefile.
To be more clear, this is the message I get: Preparing to install GHC to an isolated location. This will not interfere with any system-level installation. Already downloaded. Configuring GHC ... Received ExitFailure 1 when running Raw command: /Users/myuser/.stack/programs/x86_64-osx/ghc-8.6.5.temp/ghc-8.6.5/configure --prefix=/Users/myuser/.stack/programs/x86_64-osx/ghc-8.6.5/ Run from: /Users/myuser/.stack/programs/x86_64-osx/ghc-8.6.5.temp/ghc-8.6.5/ The only thing I can think of is to add this to my system path. When I checked my bashrc, there was already one that I had added for stack. I had nothing with a .stack in its path. I added /Users/myuser/.stack/programs/x86_64-osx to the path and sourced but still have the same errors.
[https://github.com/ingarsjekabsons/dotfiles/blob/master/default.nix](https://github.com/ingarsjekabsons/dotfiles/blob/master/default.nix) . If you are interesting in vim setup, it's here - [https://github.com/ingarsjekabsons/dotfiles/blob/master/init.vim](https://github.com/ingarsjekabsons/dotfiles/blob/master/init.vim)
Thanks. It was `readline`. Stack wanted version 7 and I had version 8.
I do want to use nix, though I need to wait until I have time to properly learn it.
If you‚Äôre already taking on the burden of requiring that Haskell exists on the system before the command can be run, is it much extra work to require that your compiled script be installed? I guess it seems like Bash is useful because it‚Äôs available everywhere. If you‚Äôre fine assuming nonstandard tools exist in the environment, maybe it‚Äôs fine to just apply that assumption to the compiled Haskell tool itself.
Why is this a bad answer, and how am I creating two problems? As /u/taylorfausak points out below, the `stack` installer tries to tell the user about the tools it thinks should be required to run GHC and co. on a given operating system. In this case the user seemed to simply want to get up and running with a fun library, not necessarily to understand the intricacies of Haskell development, and in my experience the quickest way through these problems has been to say: "Download this tool, it's designed to make the happy path as easy as possible, and we can try to work through any problems that shake out after-the-fact."
I use ghcup to install &amp; manage ghc: https://www.haskell.org/ghcup/ https://github.com/haskell/ghcup/ I use Linux, but the readme mentions it
I use ghcup on Linux (but it also works on Darwin) https://www.haskell.org/ghcup/ https://gitlab.haskell.org/haskell/ghcup But you need to install system dependencies by your self.
 Did you fix it? How? Maybe your stackage snapshot was too old or too recent?
Yes
Well that's the thing really, I do have Haskell installed and know how to write Haskell scripts that will be compiled and run, but simply due to the warm up time they don't feel great, so I carry on writing bash scripts, which makes me a little sad.
Are the papers available somewhere?
And, is it still vulnerable to timing attacks?
just to mention, "absolute value" (i.e. `|x|`) most certainly *is* (an instance of) a general mathematical concept. Specifically that of norms, `||x||`, as in normed linear spaces, and of course therefore arises naturally out of metric spaces and inner product spaces.
Authors will typically post papers either on arXiv or on their own websites. As far as I can tell that's probably your best bet.
The following generically created Aeson fromJSON instance parameterized by 'a' works fine. &amp;#x200B; \`\`\` data MyResponse a = MyResponse { jsonrpc :: String, -- should be BS.ByteString, result :: a, id :: Integer } deriving (Show, Eq, Generic, FromJSON) \`\`\` &amp;#x200B; How do I go about writing the instance manually, &amp;#x200B; \`\`\` &amp;#x200B; data MyResponse a = MyResponse { jsonrpc :: String, -- should be BS.ByteString, result :: a, id :: Integer } deriving (Show, Eq) &amp;#x200B; instance FromJSON (MyResponse a) where parseJSON = withObject "MyResponse" $ \\v -&gt; do jsonrpc\_ &lt;- v .: "jsonrpc" \-- result\_ &lt;- v .: "result" -- presumably we need to consume the field name, and then call an instance of fromJSON for a here? but how? result\_ &lt;- ???? id\_ &lt;- v .: "id" return $ (MyResponse ) jsonrpc\_ result\_ id\_ \`\`\` &amp;#x200B; Also in the same way that ToJSON has a toEncoding variant for efficiently dealing with ByteStrings - is their a corresponding equivalent for FromJSON that avoids String . &amp;#x200B; Thanks,
Does anyone has any tips on resources I can study to get to a level I can understand this research level PL stuff?
Hi, I'm using scotty + blaze + clay, currently I understand how to generate html pages with blaze and add css using clay but couldn't understand how to generate a javascript, can someone forward me to a place I can read about it? or a relevant library? Thanks :)
I found just reading them and pushing on if I didn't understand something worked. After about eight or so papers I had most non-specific things worked out. There are questions and answers on the stackexchange network that are helpful to read as well, typically with tags such as "type-theory".
Start with pierces' Types and Programming Languages. Maybe move on to Mitchell's Foundations for Programming Languages. Also harper's pfpl (http://www.cs.cmu.edu/~rwh/pfpl/index.html) and perhaps some of Pfenning's lecture notes on constructive logic: http://www.cs.cmu.edu/~fp/courses/15317-f00/handouts/logic.pdf Beyond some background like from some of those things, just start with the paper you're interested in, then when you get confused follow the citations to prior work that explains background material, and maybe follow the citations from that prior work as well.
&gt; So, I have a Mac. I want to program Haskell. I want stability. What combination of containers, software, solutions, etc. do I need to just be able to develop without worrying about my tool breaking so I can focus on development only? [ghcup](https://www.haskell.org/ghcup/) (for GHC) + cabal v2-*
No worries! Thank you for your explanation. Now I gotta grow familiar with fmc. Simple examples, then infinite data structures and then I wanna try to translate Haskell Core or rather STG (has stricter laziness annotation) into FMC. I would like to avoid translating Haskell directly, since I would like to leave desuggering to GHC. Would the above be of help to you?
That makes sense, thanks!
It does, cool stuff! I think "not being able to type self application" was a red herring for me. The crux of the matter is if you're writing straightforward evaluation to WHNF variable capture isn't an issue (with some caveats about either being strict or tracking the environment a thunk was created in). Assuming this is right then the alpha-conversion stage isn't to prevent capture during beta reduction. It's to make optimizations easier, like some of the other people in this thread have mentioned.
This was my strategy as well, though I did end up picking up TAPL, Okasaki's PFDS, and Advanced TAPL. TAPL is, I think, quite approachable, though some precursory maths training can help, but it tries to get you through that as well. Acedemic papers are often absurdly-well sourced and following the references as definitely help. A subscription to the ACM DL will give you access to most (but not all) papers that aren't just on the web in PDF form. All of the references I foillowed out of TAPL were to investigate broader ideas, not because the explaination in TAPL needed further clarification. Oksaki can be consumed without any prior complexity theory, but it's really designed to be consumed *after* you have the understanding of complexity theory that an undergraduate should get. Despite acquiring it, I haven't actually gotten much into ATAPL. It's a very different book than TAPL, and I don't think it even particularly useful background for many of the ICFP (and other PL / TT) papers.
Seems like maybe an issue with XCode 9: https://forums.developer.apple.com/thread/87097 Can you try using a different version of XCode, instead?
Especially focus on code examples, follow along, remix and fool around. The compiler keeps you in check and applying it is easier And anything by spj is recommended
The site is down. Can we please have here at least a link to the github?
For what it's worth, this was also recently discussed in `#ghc` on IRC. This resulted in a [ticket](https://gitlab.haskell.org/ghc/ghc/issues/16822). I have left some of my early findings but as always, feel free to run with the issue yourself if you have time.
This is an issue not unique to GHC. It‚Äôs a Homebrew issue. Since Homebrew 2, upgrading a formula automatically cleans older versions from the cellar. Not only that, it automatically updates formula definitions before running some commands, like `install`. Furthermore, this last step, I‚Äôm not sure about, but I believe it to be the case; it automatically upgrades formula under certain conditions. Your `readline` may have been auto-upgraded at some point, the old version removed, and some software that depends on the older version would have broke, specifically if it has not been upgraded itself afterwards (no new version, managed by Stack or other external (i.e. non-Homebrew) software or manually, pinned on Homebrew, etc.). I had this problem with PostgreSQL. There‚Äôs a setting to force Homebrew to keep the older version of `readline` alongside the newer version when you upgrade with an environment variable (you can find it somewhere in the Homebrew docs, I‚Äôm on mobile right now). (Same with forcing Homebrew to not automatically update formula definitions if you care.)
https://github.com/ad-si/TaskLite
We should have a preprint of ours (Gradual Dependent Types) up by Tuesday
My `readline` was too high of a version.
What about it makes it a solution for stability?
Do you have a stack stanza for this?
How is this related to XCode? Of course, I don't know all the details of what the OP is trying to do, but as far as I'm aware `intero-global-mode` is an Emacs major mode for Haskell.
It's arguably the bare minimum to build a Haskell project, so it's as stable as you can get. Apart from these, I only use emacs, ghcid, and a terminal. ghcid is just a thin wrapper around ghci, so it's stable almost definitionally.
I wound up having to write a `MonadUnliftPrim` recently for working with `primitive`. https://github.com/ekmett/codex/tree/master/primitive-unlift I may also wind up writing a blog bost about a rather unusual way of using this pattern to reduce the overhead of the "ReaderT" pattern by using implicit params (no, really). For example, [withEngine](https://github.com/ekmett/codex/blob/66e294656bec3d24b4ab9854c2aba397a7d00a55/engine/src/Engine.hs#L48) may have an awful type, but [using it](https://github.com/ekmett/codex/blob/66e294656bec3d24b4ab9854c2aba397a7d00a55/engine/example.hs) is super easy! No funny monads, it just works in IO or whatever reader transformed stack you have lying around.
Wasn't [this](https://github.com/haskell/rfcs/projects/1) the "roadmap" for Haskell 2020? https://github.com/haskell/rfcs/projects/1
Is your concern that you might start relying on some language extensions which get removed from GHC in the future? Something else?
I may be being particularly dumb today, but I'm not quite sure how to use this alpha distribution. It installs `Cabal-3`, but not `cabal-install`, so any attempt to actually compile something yells at me about an unsupported `ghc` release, as it tries to compile with the existing `cabal-install` 2.4.1.0 that I have installed and I can't `cabal install cabal-install` because that version isn't yet on hackage.
Looks like there's some broken markdown: `([GHC Proposal #7][proposal7])`
I'm finding that I need multiple versions of ghc. Would altering the GHC_VERSION allow me to have multiple at once? I'm finding that even with stack and creating sandboxes, I am somehow still running into dependency issues.
You can use `cabal-install-head` from Herbert's PPA or compile the HEAD version of `cabal-install` yourself.
Is there anything that you think is in need of updates?
Can't use the PPA, I'm on a mac, so I'm currently in the nasty process of doing that, and consequently updating to unreleased versions of dlist, zlib, etc. along the way.
Here's one, based on https://github.com/DanBurton/stack-setup-info-gen. I'll push updates to the repo later. # This file was generated: # https://github.com/DanBurton/stack-setup-info-gen/ setup-info: ghc: linux32: 8.8.0.20190613: url: "https://downloads.haskell.org/~ghc/8.8.1-alpha2/ghc-8.8.0.20190613-i386-deb9-linux.tar.xz" content-length: 204060792 sha1: 0fe7fc95073602078e0677ae623dd02f46ae3a5b sha256: 77d23afaf035775c99b48f0c78117a8073682dde3c6104b8ced4d5d062287772 macosx: 8.8.0.20190613: url: "https://downloads.haskell.org/~ghc/8.8.1-alpha2/ghc-8.8.0.20190613-x86_64-apple-darwin.tar.xz" content-length: 184846152 sha1: 116bdaadcde045f78adcf1ffce291c79fb1c3eb6 sha256: 04b5b4dc35db2bc26f5e4d46946409a5d21f47a7923bf69ee31b093b7e71e889 linux64: 8.8.0.20190613: url: "https://downloads.haskell.org/~ghc/8.8.1-alpha2/ghc-8.8.0.20190613-x86_64-deb9-linux.tar.xz" content-length: 199898532 sha1: 11360a17f61da02c82d0f64f07e124479cedecc4 sha256: ff532d0b700fcd9c5343a942eab35450cd9d70ce5c5064ca4dfe7af94b05616e linux64-tinfo6: 8.8.0.20190613: url: "https://downloads.haskell.org/~ghc/8.8.1-alpha2/ghc-8.8.0.20190613-x86_64-fedora27-linux.tar.xz" content-length: 201560804 sha1: 07eb8ab473f2aa3c21ac2b497142a01466ace5ee sha256: cf972265333244c8648b99fd1bcf90e1a3e7b5335c0a418f6bc9849382de8f48 windows64: 8.8.0.20190613: url: "https://downloads.haskell.org/~ghc/8.8.1-alpha2/ghc-8.8.0.20190613-x86_64-unknown-mingw32.tar.xz" content-length: 224468920 sha1: b4a3b2b45625eb32dd7f892246da9a602d9ce7db sha256: 83b4c89d01c711c0f64bcc5abda287678c027b1b0d44ada17036917aeae588eb resolver: ghc-8.8.0.20190613 compiler: ghc-8.8.0.20190613 compiler-check: match-exact packages: []
http://haskell.futurice.com used to be the place to go for mac `HEAD` builds, but it stopped being updated since [/u/phadej](https://www.reddit.com/user/phadej) changed jobs
Page is working for me.
&gt; dyld: Symbol not found: _utimensat Is the error OP is getting. The link I gave says this is caused be an XCode 9 bug that advertises that symbol even though it doesn't exist in the libraries.
Here's a thing to get stack users started with it: https://github.com/DanBurton/stack-setup-info-gen/blob/master/output/stack-ghc-8.8.1-alpha2.yaml
Spelling it out a little more explicitly: https://gist.github.com/DanBurton/56c444f22c8706f27fd0cf826a017104
I mean you could use state monad, but I'm not sure why you'd like to do that when simply folding the thing does the job?
Lol I have no idea why I didn't think of fold... Thank you
http://www.cis.upenn.edu/~cis194 is redirected to http://www.cis.upenn.edu/~cis194/fall16/ Previous versions are still there if you know the direct url including Spring 2013 - http://www.cis.upenn.edu/~cis194/spring13/ It seems they've removed the navigation links to previous versions for the Fall 16 course, but the Spring 15 course - http://www.cis.upenn.edu/~cis194/spring15/ - has navigation links to all previous versions.
Thank you!
 instance FromJSON a =&gt; FromJSON (MyResponse a) where ... result_ &lt;- v .: "result" ...
Oh! I don't have Xcode on this computer, but I have a computer with it installed and I don't encounter this error. That must be it!
A lot of language extensions, some of them pretty radical, are currently being developed. Also, the standard libraries are being cleaned up. I'd say that it's a good thing that the current efforts are merely a
It wants to try to forecefully resolve 'FromJSON a'. Rather than deferring to later when 'a' is a known type - eg. an Integer or ByteString etc, with the corresponding FromJSON instances. src/Helpers.hs:308:21: error: ‚Ä¢ No instance for (FromJSON a) arising from a use of ‚Äò.:‚Äô Possible fix: add (FromJSON a) to the context of the instance declaration ‚Ä¢ In a stmt of a 'do' block: result_ &lt;- v .: "result" In the expression: do { jsonrpc_ &lt;- v .: "jsonrpc"; result_ &lt;- v .: "result"; id_ &lt;- v .: "id"; return $ (MyResponse) jsonrpc_ result_ id_ } In the second argument of ‚Äò($)‚Äô, namely ‚Äò\ v -&gt; do { jsonrpc_ &lt;- v .: "jsonrpc"; result_ &lt;- v .: "result"; .... }‚Äô When using Generic, and {-# LANGUAGE DeriveGeneric, DeriveAnyClass #-} etc, it works fine.
You seem to be talking about the Haskell standard, the previous standard versions of which were `Haskell98` and `Haskell2010`. The Haskell standardization work only ever seems to make existing well understood language pragmas as part of the default set. The mailing list for this standardization process is [here](https://mail.haskell.org/pipermail/haskell-prime/). &gt; with GHC's continued excellent language options, and without decisions made about which to adopt, Haskell in use becomes more fragmented, disorganized and difficult to understand. Fragmented? There is really only one Haskell implementation. Doesn't sound very fragmented to me.
By fragmented, I'm guessing they mean different teams carving out different subsets of the language to use in their codebase. This is true with C++, where some teams use STL, some don't, some use exceptions, some don't, some use RTTI, some don't etc.
You don't even really need a fold: import qualified Data.Map.Strict as Map xs = [(1,2),(1,3),(2,3),(2,4),(2,17)] m = Map.fromListWith (++) . map (fmap pure) $ xs
How does Haskell deprecate features? One of the things in Javascript is: "dont break the web" This is nice, except it looks, to me, like it means always add never remove cause youll break someone's workflow &lt;insert xkcd here&gt;. I think this leads to bloat and a higher barrier to entry for beginners. I once watched a talk by Simon Peyton Jones that touched on this. That early on Haskell could just break things and the community moved calmly. There is also moving Monad under Applicative or something like that and moving Monad into Control.Monad (i recently found an old tutorial that didnt work because of this) TL;DR; Does Haskell have a process for removing or moving things from the language?
I've seen the fragmented concern often but never understood exactly what it means. Maybe it is a comparison to C++. And it leaves me confused because extensions play nicer together than exception discipline does, so it doesn't have the same effect.
support for dependent typing? (e.g. making Singletons) :)
Exactly. A cartesian product of extensions, preludes, error handling, record emulation, data validation, etc.
https://github.com/llelf/icfp2019-papers Send PRs.
Weren't these on the way? I guess proper implementation takes time.
On my phone at the moment, but usually I do this with : unionsWith (&lt;&gt;) . fmap (uncurry singleton) Hopefully that's right haha, something like that üëç
I am a still a beginner and others can likely put this better, but AFAIK, this is exactly what SPJ meant with "avoiding success at all costs". Baking one particular error handling mechanism into vanilla Haskell would fall too much on the "success at all costs" side. Clojure has a strong opinion about how it should be used baked into the language itself, Haskell does and want not. It is much more open, and like this, remains the hybrid between research-language and industry-grade language. It wears two masks and will forever to so, unless some huge kind of community shift happens.
This is needed so often, I wonder why it's not in the Data.Map API (along many other missing things...). A general version should like this: build :: Ord k =&gt; (a -&gt; b) -&gt; (a -&gt; b -&gt; b) -&gt; [(k,a)] -&gt; Map k b and then your function would be your = build (:[]) (:) `build` can be implemented for example with `Map.alter`.
I see a ton of issues in making any meaningful statements based on the outcome of this test. The sample size is obnoxiously small, one single group per language, and with widely varying abilities and approaches and experience. Particularly the Haskell dev‚Äôs only having a few thousand lines of code each, in a language that‚Äôs known to have a learning curve and be very different from the norm. It‚Äôs not just about ‚Äúfancy complex abstractions‚Äù, but just being more experienced will lead to more efficient structuring and designing of code. If you just look at any compilers class at any college you will notice that the variance in code size and so on of two teams using the same language is far higher than the differences you see here. Which more or less guarantees that anything you noticed is noise. A more interesting experiment might be to spec out some compiler project, and give language communities lots of time to implement multiple different implementations of it. Then compare the best of each. It would still have some serious flaws, but it would be an improvement.
I have two images of the same resolution and I want to create an image double the height where they're one above the other. How can I achieve this?
Did you add a `FromJSON a` constraint to the instance? (and like the derived instance does) instance FromJSON a =&gt; FromJSON (MyResponse a)
Broad descriptions of code is not code. I used \_\_dict\_\_ to access the AST before Python 2.7. Now there is better to access it. But Haskell is now better in my job because lexers are easy in Python, LALR parsers not.
I said it on HN, I'll say it here. Haskell without lens, text, vector, etc... is a bit like rust with only core not std. Rust's standard library is very much batteries included, Haskell not so, much. This is a comparison of standard libraries more than language expressiveness.
Out of that list, Haskell2020 will only help with extensions, and probably not all that much. The rest are either in the domain of libraries that the spec is silent on, or they're explicitly over-riding the spec's defaults (in the case of non-standard preludes).
Fixed in the blog.
Did they publish the sources?
`Typeable` is basically an open singleton, which is made redundant by a closed singleton like `Sing`. To compare types, one can compare their singleton values: eqSing :: Sing t1 -&gt; Sing t2 -&gt; Maybe (t1 :~: t2)
No. The school has a policy against it.
Next to the sample size being incredibly small and every team having wildly different experience in the language they're working on, I wonder how much actual time went in to every project. How many man-hours were spent on coding, how many on debugging, and how many on "working on the project" as a whole (planning/going through tutorials/other tasks/etc.). That would give more useful insight into differences between the usages of the languages. And as /u/avi-coder said, not being able to use dependencies also skews the results. A programming language is not just the syntax, it's also the environment surrounding the language (already existing packages/frameworks, the community in general, etc.)
or this: Map.fromList . map (\xs -&gt;(fst $ NE.head xs, map snd $ NE.toList xs)) . NE.groupBy ((==) `on` fst) . sortBy (comparing fst)
The list of functions "needed so often" in the Data.Map API is unending. In the early days, we used to add each one as it came up. The API quickly became larger and larger, less and less usable, and less and less maintainable. As some point, there was a consensus that we should stop and draw a line. Now the API has only the essential primitives, plus a few of the most commonly used combinators, and that's it.
&gt; Haskell fans my object that this team probably didn‚Äôt use Haskell to its fullest potential and if they were better at Haskell they could have done the project with way less code. I believe that someone like Edward Kmett could write the same compiler in substantially fewer lines of Haskell, in that my friend‚Äôs team didn‚Äôt use a lot of fancy super advanced abstractions, and weren‚Äôt allowed to use fancy combinator libraries like lens. However, this would come at a cost to how difficult it would be to understand the compiler. The people on the team are all experienced programmers, they knew that Haskell can do extremely fancy things but chose not to pursue them because they figured it would take more time to figure them out than they would save and make their code harder for the teammates who didn‚Äôt write it to understand. This seems like a real tradeoff to me and the claim I‚Äôve seen of Haskell being magical for compilers devolves into something like ‚ÄúHaskell has an extremely high skill cap for writing compilers as long as you don‚Äôt care about maintainability by people who aren‚Äôt also extremely skilled in Haskell‚Äù which is less generally applicable. I don't know what exactly constitutes "extreme skill". My 2c: using libraries like uniplate is fairly easy, and it makes operations on trees a breeze. Using (micro/generic)lens is more complicated, you have to understand rank 2 types. Using libraries like bound is probably more complicated because of the polymorphic recursion, and you need to define your data types in a particular way. It's a spectrum. Just because one end of the spectrum has a high ceiling, doesn't mean that even the lower hanging fruit shouldn't be used. However, it seems that people weren't allowed to use libraries outside the standard ones (so I'm guessing haskell-platform here), which means that all these are out of question. "as long as you don‚Äôt care about maintainability by people who aren‚Äôt also extremely skilled in Haskell" -- I think maintainability has much less to do with the libraries you use, and much more with how you use them, and how your organize your code and documentation. You could easily write a compiler that is terrible to maintain while just using `base` üòê.
&gt;A more interesting experiment might be to spec out some compiler project, and give language communities lots of time to implement multiple different implementations of it. Then compare the best of each. How do you judge though? Seems like an impossible task... whatever criteria you pick, you're gonna' get criticism from the lower ranked languages that the weights are not fair.
Right, it's indeed type checking. But in some way it's also type inference. Roughly saying, each instruction is a function type from input stack to output stack. And input stack is indeed known beforehand, but the other part of type signature is inferred. As for `Typeable`, I see your point, but still would recommend using `Typeable`, not singletons for type comparison. The reason for that is that in Haskell types are compared in `O(1)`, as pre-generated hashes are to be used. Well, at least that was my understanding after examining documentation (if you think I'm wrong, do not hesitate to correct my words). Whereas with singletons it will be `O(n)` where `n` is a size of type (amount of constructors used to create the type).
This sounds very promising, thanks for working on the Tooling Situation.
Stopped reading at this: &gt; my friend‚Äôs team didn‚Äôt use a lot of fancy super advanced abstractions, and weren‚Äôt allowed to use fancy combinator libraries like lens. Seriously, how is this "language comparison" comparing anything, if they were intentionally writing bad Haskell? I wrote a tiny parser+interpreter in Haskell and I am appalled by a prospect of doing this without parsec, state monad, transformers and lenses or equivalents of these (I don't view any of those terribly advanced, I would say quite ordinary in the Haskell world). I would consider this a torture and would not pick Haskell if facing same homework with stupid arbitrary limitations. I would probably went with Scala and get my hands dirty.
Thanks for link to Stitch, that's an interesting reading :)
Considering that your list is already sorted you can use `fromAscList`.
&gt; You could easily write a compiler that is terrible to maintain while just using base üòê. One could argue that "only using base" would result in a worse maintainable code, because of heaps of noise libraries can eliminate elegantly. Also these old big libraries have usually massive tests, so libraries itself tend to be rock solid, which won't be a case when a team is reinventing wheel by writing their own types and helpers.
Profressors also indicated that Haskell quality in this class has substantially higher variance that other languages. This makes the small sample size more problematic / less predictive.
The "at all costs" is about sacrificing core values (laziness, in particular) for broader acceptance. It doesn't have a lot to do with opinionated solutions. That said, I think consensus in the report may also be a Haskell core value. If true, that could be contributing to the timeline; I've heard some of the changes/extensions are hard to specify without reference to GHC's implementation.
Maybe wait for an least one implementation before we try to bake it into the standard?
Indeed the `Cabal-3` dependency does complicate things. Currently there is not an official `Cabal` release which supports GHC 8.8. That being said, I believe that `cabal-install` 2.4 should work fine, although it will indeed complain.
On a somewhat tangential note, I'd love to see an article that talks about the costs, not just the benefits of using such techniques. What about compile times when making small changes? Does deriving type class instances become more difficult? How understandable are the type errors? Do tests become more brittle?
You can write: main = do store &lt;- ... print =&lt;&lt; readTVarIO store to avoid the intermediate variable. You need to use the `Monad` type class/interface to work with `IO` values. `readTVarIO store` has the type `IO [a]`. The function `=&lt;&lt;` has the type `(=&lt;&lt;) :: (Monad m) =&gt; (a -&gt; m b) -&gt; m a -&gt; m b`. `print` has the type `Show a =&gt; a -&gt; IO ()`. So we can use `=&lt;&lt;` to "glue" these two values together, feeding the result of one into the input of another.
Thank you!
The `val &lt;- readTVarIO store` is equivalent to `readTVarIO store &gt;&gt;= \val -&gt; ...`, so `(atomically $ newTVar []) &gt;&gt;= readTVarIO &gt;&gt;= print` is equivalent to your first example. The issue in the second is that bind (`&gt;&gt;=`) hasn't been used to pull `val` out of its monadic context.
GHC_VERSION is specific to the makefile. But once you have ghcup working, installing and using a particular version is easy: https://github.com/haskell/ghcup
I am having trouble understanding this function. To me, it looks like this should cause infinite recursion due to mapping over an infinite list. I don't see how laziness factors in here because there is nothing I see consuming `n` elements of the list, nothing to limit the recursion. The purpose of the function is to generate the set of all combinations of positive integers that sum to `n`. Can anyone explain what's happening here? g = [] : map f [1..] f n = [n] : [x : p | x &lt;- [1..n], p &lt;- g !! (n - x), x &lt;= head p]
Most of them (or preprints/drafts) https://github.com/llelf/icfp2019-papers
Ah, so you use a vanilla ghc and cabal setup. I'm kind of reluctant to not use the nix build system, but I'm not deep enough into that part of nix. Guess I should just start using something like you do, thanks :)
Coincidentally I recently listened to a \[Future of Coding podcast\]([https://futureofcoding.org/episodes/024](https://futureofcoding.org/episodes/024)) from a year ago where they are talking about using a build system such as shake to work out which artifacts, tests, and other feedback to generate every time a file is changed.
Hey all, OP here -- I just got through creating a super naive implementation of a count min sketch in haskell and writing about the process, would love some feedback! No idea when I'm going to sit down to work on the project again (it took way longer than I would have thought, and the quality still isn't great), but felt I needed to release *something* sooner rather than later. Things you might find useful in the post and accompanying [code repository](https://gitlab.com/mrman/haskell-countmin): - Example usage of `doctest` &amp; `doctest-discover` - `haddock` documentation - Use of GitLab for CI (tests run in ~1min 50 seconds w/ caching!) - Use of GitLab Pages for [hosted haddock documentation](https://mrman.gitlab.io/haskell-countmin/) - Use of [`weigh`](https://www.fpcomplete.com/blog/2016/05/weigh-package) to check memory allocations - Use of [`criterion`](https://hackage.haskell.org/package/criterion) for benchmarking Nothing crazy in here type-wise but hopefully it will be an interesting read or at least an example for some!
What do you mean by warm up time? Hello world in Bash on my machine finished in 7ms, and in Haskell 20ms. Haskell doesn‚Äôt have a heavyweight runtime like V8 or the JVM that needs to warm up after startup. When compiling with optimizations Haskell can be pretty fast.
I mean the compile phase prior to execution, which Bash doesn't have because it's interpreted statement-by-statement.
\&gt; Due to on-going work on our release and testing infrastructure this cycle is proceeding at a pace significantly slower than expected. However, we anticipate that this investment will allow us to release a more reliable, easier-to-install compiler on the planned six-month release cadence in the future. &amp;#x200B; For what it's worth, in my limited contributions to GHC, I've really enjoyed the testing infrastructure and Marge bot.
* `print &lt;$&gt; readTVarIO store` * `readTVarIO store &gt;&gt;= print`
&gt; Does adding a common feature X suddenly make things much harder? It's well-known‚Ñ¢ that this sort of 'intrinsically-typed' AST (where the AST is indexed by types/contexts) does not scale to dependently-typed object languages. As soon as your type contexts are telescopes instead of lists (i.e., types in the context can refer to other types in the context), you need induction-recursion and it gets unpleasant. If your language has a conversion rule, you're definitely better off with a non-indexed AST. Then again, if your eDSL is dependently typed, that may be the bigger problem.
Even though it's definitely an interesting project that they did, then remembering what I did in haskell in the university was nothing like what&amp;how I do things now, 10 years later. So as far as language comparisons go then I'd say the text has little to no predictive power. (But does make bases for interesting discussions though!)
While I agree with you, I actually wonder how much of the tools we take for granted (lenses, record types, overloaded strings, Singletons, free(er) monads/polysemy, etc) we would have to relinquish once we were to target standard 'Haskell2010' rather than 'Haskell2010 + GHC's kitchen sink of extensions'. Probably a lot. Probably far more than I can think of.
While I agree with a lot of the criticism of the article I think the conclusion is still spot on: ‚ÄúOverall I‚Äôm very glad I did this comparison, I learned a lot from it and was surprised many times. I think my overall takeaway is that design decisions make a much larger difference than the language, but the language matters insofar as it gives you the tools to implement different designs‚Äù Design decisions affect the project a lot and languages influence those decisions
Also, Haskell's superpowers on compilers come from powerful libraries that couldn't be created on any of thise other languages. But those were prohibted. I also don't think most people would be able to replicate the Python history.
Yes. MTL, containers, or a text manipulation library aren't "fancy super advanced abstractions", these are basic tools to write anything non-trivial in Haskell.
What libraries would you consider in that set? I've written a few simple DSLs / compilers in Haskell, and have yet to see anything particular magical for the process other than recursion-schemes. Mind, I'm a relative novice.
Well, Megaparsec is a nice place to start (or Attoparsec if you don't want nice error handling).
and linear typing?
Not strictly needed, since you can use dependent typing and index monads to enforce linearity of tagged resources. I would also like to see it though, as a QOL improvement if for no other reason.
You probably already know this, but a `cabal-install` binary built from HEAD with GHC 8.6 will work fine, so you don't need to do the whole bootstrapping dance on 8.8.
I find that language pragmas do not much if any fragmentation. I put pragmas at the top of each file rather than in the cabal file and only ad the ones needed by each file. By way of contrast, I do think the Lens library causes some fragmentation.
nice! here are the counts I measure for a few of those projects. c++ 636,1011,1044,1079,2726,3042,3508,4282 go 685,824,1126,2557,3550 haskell 722,1429 java 733,2193,2867,3116,3171,3322 js 1519,1991 python 336,834,1003,2346 rust 387,1432,1435,1512,2407,2564,3033,5086,9569 each number is the `wc -l` for one project, excluding tests and including grammar files. the differences between languages definitely look like noise compared with the differences between projects written in the same language!
Thanks for picking this up.
It's 100% the truth. It's literally just a configuration line and it's so BAD and AWFUL to deal with that a *single configuration line* must be left as an exercise. &gt;but I wrote a solution Yeah, the easier one. Anyway, I'm keeping it hardcoded, just in case you think this is reverse psychology. It's not. If this weren't as garbage as I rightfully assert it is, then the solution would have been posted by everyone in minutes. But it's not. It is not easy. It's awful and you would have had to refactor quite a bit of code to implement the "exercise" in more than one place, too. Why is that so? Because IO is the worst thing. I am 100% right about it.
I‚Äôm not sure I accept the conclusions of slides 45-47‚Äînamely, that finally-tagless approaches are slower than free monads. A finally-tagless interface _atop_ a free monad is going to be slightly slower than just using that monad directly, since it involves more dictionary passing, and that‚Äôs reflected in the results. But you can have finally-tagless interfaces to things other than free monads‚Äîmost notably monad transformers. And in the [several](https://github.com/joshvera/freemonad-benchmarks) [benchmarks](https://github.com/patrickt/effects-benchmarks) I‚Äôve worked on, free monads‚Äîwhether encoded as `Free`, or the Church-encoded `F`, or `Codensity`‚Äîare several orders of magnitude slower than monad transformers. Unless I‚Äôm missing something, I don‚Äôt think it‚Äôs a very fair comparison. If the [code in question](https://github.com/graninas/Hydra/blob/1acdd61c2272539cc753200b0714dd514f1607ee/app/PerfTestApp/FTL.hs) was benchmarked against an MTL-style `MonadRandom` interface instantiated with IO and/or State, I‚Äôd expect to see extremely different results.
Those numbers are misleading because of the fact that half of the implementations are nowhere near done: see [this github issue](https://github.com/munificent/craftinginterpreters/issues/455).
This came up recently: https://np.reddit.com/r/haskell/comments/byokbb/are_there_any_updates_on_haskell_2020/
I don't get the common sentiment that this understandable. There are plenty of well run programming language ecosystems where people do find the time to volunteer.
I think these slides need a talk paired with them. Which isn't a bad thing when designing talks for slides! It's just that, though I can understand the point of individual slides, the connecting argument isn't coming through for me, and it makes the conclusion seem hostile (since text sucks at tone).
A completely valid point; I still think a indexed AST is preferred for correctness, particularly between phases. They definitely quite more time/dedication to complete though -- telescopes are much harder to deal with than lists.
Looks like one of the roadmaps that's not happening.
&gt;Out of that list, Haskell2020 will only help with extensions, and probably not all that much. That's pretty sad. And well, that Haskell 2020 isn't going to happen.
My concern is that Haskell isn't usable out of the box for a long list of reasons.
Tons. But it's nothing different than what every language needs: a public, continual process of improvement. E.g., languages who do it well: * [https://rust-lang.github.io/rfcs/](https://rust-lang.github.io/rfcs/) * [https://www.python.org/dev/peps/](https://www.python.org/dev/peps/)
There's an excellent paper that helped me get the gist of do notation, check out section 2.3 :) [Tackling the Awkward Squad: monadic input/output, concurrency, exceptions, and foreign-language calls in Haskell](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/mark.pdf)
Are you mainly interested in having a faster release cycle?
Sorry, I missed that. perfect! Thank you!
IMO, the reason Haskell isn't usable out of the box has very much to do with the editor/IDE experience (which a lot of other languages provide) and not so much to do with the fact that we don't/won't have a Haskell 2020 standard (which most people aren't concerned with). We do have some excellent tools, but we're missing the basics in some respects. The GHC users guide describes the extensions in quite some detail, and there are often papers backing the more sophisticated ones, which very few languages can match. Learning which ones to use and avoid is mostly a one time affair. OTOH, the editor experience creates friction on a constant basis. The larger the code base, the worse it gets.
Yeah. Nix is definitely a big undertaking. But, once you get comfortable with it -- it is pretty sweet. At work we use nix to build over 300 Haskell packages using ghc and ghcjs, and the same configuration just works under OS X/Darwin.
Interesting ‚Äî In contrast, I've found the editor experience pretty great! Spacemacs and Visual Studio Code have plugins (Intero-based) that I like. As just one example, I'm talking about the experience of getting pretty far on the Haskell learning curve, and then learning that there's a whole rabbit hole of things to learn to just understand error handling: [http://www.randomhacks.net/2007/03/10/haskell-8-ways-to-report-errors/](http://www.randomhacks.net/2007/03/10/haskell-8-ways-to-report-errors/) Another is choosing a specific set of language extensions to enable: [https://lexi-lambda.github.io/blog/2018/02/10/an-opinionated-guide-to-haskell-in-2018/](https://lexi-lambda.github.io/blog/2018/02/10/an-opinionated-guide-to-haskell-in-2018/) Every one of these extensions is another rabbit hole learning required. I **think** the idea was supposed to be that GHC would be a testing ground for these...
GHC has a very mature and structured process for proposing and discussing extensions to the language, core libs, etc. and it has been imo extremely successful, e.g. in coordinating and finding consensus for some fairly hairy long-term plans such as AMP. It's not clear to me what you're looking for. Maybe imagine "Haskell" is just GHC with all extensions turned on and that versions of the language correspond to ghc releases?
&gt; Maybe imagine "Haskell" is just GHC with all extensions turned on... That'd be nice! But that's not how people use Haskell in the real world.
&gt; Spacemacs and Visual Studio Code have plugins (Intero-based) that I like. Those are the only two that work IME üòÇ. I've tried helping people get set up with Atom, Vim and other editors and using HIE/ghc-mod is very frustrating. Even with intero, I routinely have problems with autocomplete not working in Spacemacs ü§∑‚Äç‚ôÇÔ∏è. &gt; Error handling I think that article is pretty outdated, most of the options listed there are terrible. From a library, I'd expect custom error ADTs and returning Either MyError. That's it, follow the KISS philosophy. Using Maybe instead of Either is ok if there is only one possible reason for failure and it is highly unlikely that there might be more in the future. There are very few reasons to deviate from this for a library. Applications have different requirements, so it depends a lot on how the rest of your code is organized (e.g. 3 layer cake pattern, using algebraic effects etc.). &gt; Another is choosing a specific set of language extensions to enable: &gt; &gt; https://lexi-lambda.github.io/blog/2018/02/10/an-opinionated-guide-to-haskell-in-2018/ &gt; &gt; Every one of these extensions is another rabbit hole learning required. In fact, I'd say it's the opposite. If you blindly follow the advice given in that article, you're going to encounter very little friction with the type class system. The only potential (and inevitable) problem is that you will run into is the monomorphism restriction at some point, but that's a bump that is easily overcome.
Good stuff to know! But you can imagine, for a beginner the relevance of articles like these isn't obvious.
Right, people don't turn on all extensions in the real world. Again I'm not sure what point you're making, sorry.
Without actually being able to see the implementations this isn't particularly useful, sadly.
Please release your benchmarks. Extraordinary claims require extraordinary evidence.
It is a somewhat less perfect solution for me in that it is an extra step for users or the repository to have to dance through, relative to simply including links to the version of `Cabal`, `tar`, `zlib`, etc. that I require and having a user just install 8.8 and move on. My main source of disappointment was having gone through the effort of patching all the individual upstream-of-Cabal dependencies to see if I could build it from 8.8, I was still getting a copy of 2.4.1 trying to build from nowhere. The status quo means you have to install two Haskell compilers.
My major reason for moving my entire project to 8.8 prematurely is that it _really_ needs `cabal-install` 3 support so that I can cut the number of packages in a third using multiple public libraries per package. I've pulled the trigger and moved anyways, and patched a couple dozen upstream dependencies, because it is all greenfield code, but it was a looong blind alley to try to get Cabal built from the wrong side of the 8.8 divide.
It's not all that hard to write a parser combinator library yourself. Surprised the Haskell team didn't do that instead of regexp-based lexing and an LR parser which (to me) seems harder.
Yes, to add to this. Slide 47 make it seem like "Chuch-encoded free" is faster than final tagless but the conclusion says Free monads are slow. Which one is it?
Also, make a lisp maybe? https://github.com/kanaka/mal
Apparently, these slides are from a conference called FPure, which was hosted in Kazan, Russia. So even if there is a recording of the talk, it is, most likely, in Russian.
Why would one make english slides to russian talk? üôÇ
will do!
It‚Äôs both. ‚ÄúNa√Øve‚Äù Free is slow, Church-encoded free is faster. You can see it on slide 45, although I can‚Äôt comment on these specific benchmarks implemented/used (i.e., I feel like some explanation is in order of how Church-encoded free can possibly be faster than finally tagless, where almost all interesting work happens _in compile time_).
The organizers promised to publish videos "soon"
Why would one say that software development is ‚Äúphysics‚Äù, make some benchmarks, and then not explain their results, given that ‚Äúperformance‚Äù is a very flexible thing: today your benchmarks show that X is faster than Y, and tomorrow a bug in the compiler/libraries is fixed and it becomes the opposite? :) (Seriously though: to publish them in their blog or on Reddit, although this only works if the slides make sense without the accompanying talk, which is not quite the case here.)
Hi, I'm the author. That's not conclusion, the list of statements shows the claims I usually get in discussions. These authors of these claims consider them a stronger argument than experiment results
This part (To whom it may concern) is claims I'm getting in the discussions when I'm trying to explain my ideas. So the tone is borrowed from the opponents who consider these claims valid irrespective the experiment results I'm deonstrating as proofs.
Makes sense. I'd love to hear the talk that goes along with the slides!
AFAIK there is no formal process, but if the breaking change has a real advantage, it gets slowly phased out. First guarding the change behind an extension that is enabled by default, then adding a warning to -Wcompat, adding the warning to -Wall and finally turning it off. That's at least what happened (happens) with `StarIsType` (https://github.com/ghc-proposals/ghc-proposals/pull/143)
Sure, but the talk is in Russian. Slides in English.
It's pretty FRP like. When viewed this way, Shake is just a parallel FRP system with a specific notion of caching. We've actually abstracted the "Shake" to be more FRP like - perhaps there are benefits to switching to a real FRP system, but that's not our area of focus right now.
Awesome! I'll take a look, and see if they thought of any interesting flaws/improvements over our design.
I don't know how much of this applies to Haskell, but in a proper dependently-typed language the choice is not between intrinsic typing and no verification but between intrinsic typing and extrinsic typing. For the latter, you define first an untyped AST and then relations for typing, context validity etc. This is more verbose and you don't get as much guidance when writing AST transformations, but you won't run into these situations where intrinsic typing suddenly becomes a huge pain to work with. It's also closer to traditional paper presentations and works even in languages with crippled pattern matching (*cough* Coq).
Use the hip library functions of readImage, topToBottom, and writeImage.
You basically always get the choice between those two styles, plus external proofs of correctness. I always prefer the one that's nicest for library users, which is often some blend of intrinsic and extrinsic. Enough intrinsic typing to be correct-by-construction, and everything else extrinsic.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/haskellgamedev] [Lambda-Heights - fast paced haskell game](https://www.reddit.com/r/haskellgamedev/comments/c1obgg/lambdaheights_fast_paced_haskell_game/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Consider that your first situation is equivalent to: main = do store &lt;- atomically $ newTVar [] let var = readTVarIO store print var so the issue you are really asking is "What is the difference between let and &lt;-" in do blocks? One way you could look at it is through the types. For do blocks, if you have an IO action `act :: IO Bool`, then if you do let x = act then `x` would have type `IO Bool`. It is literally just defining an *alias* for `act`, an IO action. But, if you do x &lt;- act then `x` would have type `Bool`; `x` then refers to the *result* of the IO action, and *not* the action itself.
It's not as if the people involved were experts, they're final year students.
It may be due to their inexperience with haskell: &gt; The Haskell team was composed of two of my friends who‚Äôd written maybe a couple thousand lines of Haskell each before plus reading lots of online Haskell content, and a bunch more in other similar functional languages like OCaml and Lean
I'm a bit unclear what you mean by "out of the box"?
I don't think the cause of the variance is relevant to my statement.
can you explain what you mean with unstable? It's probably related to HIE itself, i think the vscode-specific part is very small and i therefore expect the bugs in the plugin to be easy to fix.
I've had issues where if I fire up an editor fresh, it'll give me underlines, (some) completions, and hover-for-type-info support. But it seems that If I leave the editor running long enough, I stop getting any of that, and also HIE eats all my memory. It's possible these issues are related. I haven't rigorously tested when it seems to stop helping, but It always seems to work best when I fire up everything from scratch, and somewhat gradually deteriorates from there. Hopefully that info helps?
This is probably all related directly to HIE's behaviour, not so much its editor integration. Switching to a different editor is unlikely to fix any of that.
It‚Äôs pretty rare for compensating for job ads to be posted publicly, so don‚Äôt hold your breath
Very recently some memory leaks were fixed. I suggest you, reinstall from hie master. Ghc &lt; 8.6 has a memory leak, so if your project is built with an old Ghc hie will have an additional huge memory leak.
You'll get this issue regardless of client. The LSP server that HIE runs has some issues with space leaks/ performance. HIE is an awesome effort, and personally I find it worthwhile to deal with the warts, but it definitely has some challenges.
I see, that makes sense
Don't understand this slide https://imgur.com/6P03TTn Is this the right (TM) way to write applications? P.S. waiting for video (and book) :)
I've had a great experience with [Doom Emacs](https://github.com/hlissner/doom-emacs), LSP &amp; HIE work out of the box. Emacs being Emacs the integration is amazing, and it's fully customizable ‚Äì provided you're willing to get your hands dirty. [Link to the Haskell module for reference.](https://github.com/hlissner/doom-emacs/blob/develop/modules/lang/haskell/README.org)
Hi, I placed this slide to be fair. It shows that even in FT/mtl it's possible to hide the list of effects. I took the idea from [this](https://serokell.io/blog/tagless-final) article. I was also told that "FT on the slides not a real FT" and "hardly one writes FT in a such way". So I'm not quite sure is the presented slide the right way to do it. I'm arguing it's not. Thanks, but I should notice that the talk is in Russian, while the presentation is in English.
I'll be there!
For a second I read those as single numbers. "Hey we're doing pretty well.." :)
working through that right now actually. I'm on 8.6 I think, but if not I'll look into upgrading
Great, congrats! A playable arcade game, 1600 lines of haskell not using a game engine. Thanks for the write-up. (Including https://github.com/morgenthum/lambda-heights/blob/master/IMPLEMENTATION.md, with its nice demo of graphmod - I'm going to try that.)
I'm always happy to read more Haskell gamedev success stories. well done and thank you for sharing! My best high score was 42. Is it possible to get more? I also love the replay feature, it works very well! Suggestion: Add a short youtube video showing the gameplay of the game.
vscode
Is there a way to launch an REPL in the test module using Stack? When I try `stack repl --test`, I'm getting errors on importing modules from the library itself.
PS since we're posting scores: 77 :) Game feedback: - having trouble figuring out the jump tricks, despite your description (and they become necessary for survival early on). No harm, that motivates me to study it.. like in the old days of gaming.. - always let the primary action button (space) advance menus etc., instead of (undocumented) enter - replay is a cool feature, play it automatically (maybe faster) - if you decide to add sound and a bit more - global &amp; group high scores like Advent of Code ? this could live on!
I'm still fairly new to Haskell and am uncertain how to translate this bit of Scala code to Haskell: trait Q[M[_], A, B] { val M: Monad[M] def f(): M[A] def g(): M[B] } This works in Scala, but I'm not sure how to accomplish this in Haskell. class Monad m =&gt; Q m a b where f :: m a g :: m b This I think is the closest direct translation, but this gives ambiguous type errors; I'm not sure if I'm grasping for the right tools. I've tried adding associated types to the class (type families), but that was giving issues, as well. Could not deduce (Q m a b0) from the context: Q m a b bound by the type signature for: f :: forall (m :: * -&gt; *) a b. Q m a b =&gt; m a at &lt;interactive&gt;:7:5-12 The type variable ‚Äòb0‚Äô is ambiguous It does suggest `AllowAmbiguousTypes`, (which might work here?) but I find that's a bit annoying/verbose at call sites when I turn it on and things do work out. I'd like to parameterise a typeclass over a Monad and a couple return types, chosen by the instances. I think somewhat get the issue here -- during instance resolution, it wouldn't be obvious which instance to choose given the way I've defined it. Is there a specific tool I should be reaching for here to guide that? Thanks ahead of time for any help!
If you want the Monad instance itself to decide the two return types, then there are two obvious solutions: Functional dependencies through ```haskell {-# LANGUAGE FunctionalDependencies #-} class Monad m =&gt; Q m a b | m -&gt; a b where f :: m a g :: m b ``` Type families through ```haskell {-# LANGUAGE TypeFamilies #-} class Monad m =&gt; Q m where type A m type B m f :: m (A m) g :: m (B m) ```
Awesome! Turns out I had the right idea in my attempts but was just writing it down incorrectly... too much Scala on the brain. Thanks very much!
[removed]
Anyone who's interested in Higher Kinded Data should look at [Higher-order Type-level Programming in Haskell](https://www.microsoft.com/en-us/research/uploads/prod/2019/03/ho-haskell-5c8bb4918a4de.pdf). It lays some groundwork for using unsaturated type families that could make HKD much easier, removing the need for defunctionalization.
Looking at the definitions of `Everywhere` and `Gmap` in section 6.2 I instantly wanted to write a `Traverse` type family.
Thanks for your feedback! Yes its possible to reach a higher score. Thanks for your suggestion - I made a video that shows how to play the game: [https://youtu.be/drdjfy\_NYCo](https://youtu.be/drdjfy_NYCo)
oh wow I barely scratched the surface, nice!
Thank you! Nice suggestions, I will document it a bit better. Automatically playing the replay on death is also a nice idea. And I will have a look at how to embed files in the executable - that would be cool.
`stack repl --test` works for me in a very simple library project. Which stack version are you using? Can you share the project?
One way to do embedding is just to use template haskell. It allows you to run either pure or side-effecting code at compile time and reduce it to a constant. So your load font code for example. Have that executed at compile time and the font is just a constant in code thereafter.
Awesome guide, thank you!
Very nice article, thanks for writing it. For profiling, I highly recommend using profiteur and profiteur. They are easy to install and use and can give very good insights. If someone is familiar with an easy how-to guide to link here please share, otherwise I'll try to write one in the next few days.
Thank you for the clarification!
Thanks for the suggestion, I will add a link to it. One question though: I do not want to recommend people to use `cabal install profiteur` directly, as I think that's going to install packages that profiteur depends on globally, potentially creating cabal hell in the future. What's the simplest alternative that doesn't affect the global registry? git clone + cabal v2-install?
With respect to `stack`, I think you can override the compiler check with these directives: https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md#compiler-check https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md#compiler
This is overall a fantastic set of recommendations! &gt; Getting help I'd highly recommend adding the [FPChat Slack channel #haskell-beginners](https://functionalprogramming.slack.com/messages/C04641JCU/) ([invite link here](https://fpchat-invite.herokuapp.com/)). Lots of folks are on there regularly helping beginners out, myself included. &gt; Setting up CI To this day I pretty much just copy the relevant [Travis CI config from the stack website](https://docs.haskellstack.org/en/stable/travis_ci/), though there's also the non-stack [`haskell-ci`](https://www.google.com/search?q=haskell-ci&amp;oq=haskell-ci&amp;aqs=chrome..69i57j0l5.1452j0j7&amp;sourceid=chrome&amp;ie=UTF-8) project. &gt; If you really must use a lens library (to see what all the fuss is all about or otherwise), I recommend using microlens (or microlens-platform). This is good advice for *library* writers, but it's awful for application or beginners. Almost every article or guide is going to expect `lens`, and `microlens` isn't meaningfully simpler.
It's not worth 1604$.
Yes. Yes they do. Facebook has Haskell in production, which IIRC uses pretty much a forked/modified version of GHC. (because Facebook wants crazy performance, etc.) A ton of companies use Haskell/GHC in production. Hell, my company has only Haskell in use as the backend server platform, which yes, is using GHC. `GHC is the de facto implementation of Haskell as a programming language.`
&gt;Maybe imagine "Haskell" is just GHC with all extensions turned on... That'd be nice! But that's not how people use Haskell in the real world. &amp;#x200B; \^\^ That's what I wrote. Maybe you meant to respond to this comment, which says that companies do **not** just turn on all extensions. (?) [https://www.reddit.com/r/haskell/comments/c141zb/any\_movement\_on\_development\_of\_haskell\_the/erdnap2/](https://www.reddit.com/r/haskell/comments/c141zb/any_movement_on_development_of_haskell_the/erdnap2/)
&gt; This is overall a fantastic set of recommendations! Thanks! I admire your writing, so good to see that we mostly agree. &gt; I'd highly recommend adding the FPChat Slack channel #haskell-beginners (invite link here). Lots of folks are on there regularly helping beginners out, myself included. Thanks, I'll add that. &gt; To this day I pretty much just copy the relevant Travis CI config from the stack website, though there's also the non-stack haskell-ci project. I'll add a link to it. &gt; This is good advice for library writers, but it's awful for application or beginners. Almost every article or guide is going to expect lens, and microlens isn't meaningfully simpler. 1. I don't think beginners need to be using lenses (at least, either the Van Laarhoven or profunctor formulations). From a learning POV, there's a cliff where everything's fine and dandy one minute and type errors get inscrutable if you do something out of the ordinary. Which is why I strongly recommend _not_ using lens. 2. My line of thinking for recommending microlens as a last resort (instead of `lens`), is the the main module `Lens.Micro` has much better documentation with examples compared to `lens`, which kinda' negates the point That said, I should add a comment saying that `Lens.Micro` is roughly a subset of `Control.Lens`, so one can understand follow along the tutorial without friction.
I'd second that, gitlab-ci is pretty nice. [Here is a link to the introduction](https://docs.gitlab.com/ee/ci/introduction/index.html#how-gitlab-cicd-works)
Let's say I want to write a small text-processing command line app that does proper error checking. It's not enough to learn basic Haskell and get it installed ... both non-trivial. One must also navigate the controversies and alternatives for error handling and text types. And probably change out the Prelude after learning about all of those issues, etc. In short: like every programming language, Haskell needs tending. But the weeds aren't being pulled, and new flowers not planted.
I'd agree that `Lens` should be discouraged until the student knows all the simpler means of solving the same problems (and techniques to avoid having those problems in the first place). That `Lens.Micro` has much better documentation is something I wasn't aware of, and it definitely provides a point in favor for that library. Thanks for making me aware of that :)
Thanks for understanding. Do you know if the invite link for the FPChat Slack channel has a timer (i.e. does it expire after a limited time) or not?
irrelevant
I don't believe that it does - that's the same link I've been using for years to invite folks.
I think a lot of us have waited for this proposal! I think for the benefit of Haskell one has remain calm but I am very (very!) excited! üòâ
I'm happy to keep yelling at people until this being rare changes. I've only been involved in hiring once, and we put the ranges crystal clear in the job posting, and everyone who applied appreciated it. Like discouraging people from sharing salaries (which people should do! It's legal! If your employer tells you it's not, they are lying), not posting salaries on job listings is a worker-hostile practice that makes it much easier for employers to exploit people (if I know I'm well qualified and a really good fit for a job, I'm going to ask for near the top of the range; if there is no range, I may overshoot, in which case they will either tell me to go away or, if I'm lucky, counteroffer down to near the top of the range, or I may undershoot, in which case they will hire me for much less than they were willing to pay me. In expected value, I'm worse off).
AFAIK, that link is a proxy to Slack which generates invites, rather than a temporary invite link.
In theory, globally installing tools is fine as long as users are using `cabal v2-*` in their actual projects (since a profiler isn't really part of your project). That said, you can always say something like cabal v2-install profiteur --package-env tools which will get you a nicely segregated package DB for just your tooling dependencies.
According to [this page](https://gitlab.haskell.org/ghc/ghc/wikis/platforms), GHC considers ARM a "Tier 2" platform: the project tries to keep everything working, but they don't build or publish binaries etc. It's left to "the community" to build them, if they want. If you really want recent GHC but can't find binaries anywhere, that means you should probably just build it yourself. The only sane way to do that is to find a moderately recent x86 computer (anything built within this decade should work) and cross compile GHC on it, but it should be painless enough that everyone who develops Haskell on arm probably does it that way. I would not trust your distribution's package manger to maintain good packages for GHC, whether on arm or any other architecture. It's a better idea to download binaries from the GHC site and go the traditional `./configure --prefix=/opt/ghc(or wherever) &amp;&amp; make install` route. (Well, `stack` does that for you. The important thing is that `apt` and co. are not good places from which to get GHC.) In the case of arm these binaries don't exist anyway; refer to paragraph 1. There's nothing particularly wrong with setting your path to prefer `llvm-5` over `llvm-6`. That's what the `PATH` is *for*. You may also try seeing if `update-alternatives` knows about LLVM and can symlink version 5 into the global locations, but that would configure the whole system to use `llvm-5`. (`update-alternatives` is for reconfiguring the whole system, `PATH` is for reconfiguring your own environment, or even specific processes.) You can also use [the options `-pgmlo` and `-pgmlc`](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/phases.html#ghc-flag--pgmlo%20‚ü®cmd‚ü©) to set which commands are used.
I've just finished my IoT project which was written in haskell. Based on my experience, the most difficult part for haskell on ARM is building, as you said, there is no binaries distribution for up-to-date compiler, tools or libraries. You need to build almost everything from scratch. My approach to build haskell app for ARM is: 1. buy an ARM VM instance from a public cloud provider(google for it, you will find a few) because the ARM vms from cloud provider are more powerful than your own and can speed up the build process 2. use Nix to manage dependencies. Nix pkgs has almost all hackage in their repositories and it will cache the binaries once some one built and upload the packages. I spent most time to setup build process for my IoT project. But once the haskell projects get built, they will run very well on ARM.
Anyone know a detailed, step by step parser combinator tutorial? I've been wrestling with this thing on and off for months and I cannot make heads or tail on how it actually works. Preferably not megaparsec because the types is very confusing and I am looking tp understand the basics of how parser combinators work.
Damn that guy's making influential GHC proposals at his age and what am I doing with my life?
To be honest, I tried to play the game using the following nix command: ``` $ nix run '(with import &lt;nixpkgs&gt; {}; haskellPackages.developPackage { root = fetchTarball "https://github.com/morgenthum/lambda-heights/archive/master.tar.gz"; name = "lambda-heights";})' -c lambda-heights-exe lambda-heights-exe: SDLCallFailed {sdlExceptionCaller = "SDL.Font.load", sdlFunction = "TTF_OpenFont", sdlExceptionError = "Couldn't open fonts/HighSchoolUSASans.ttf"} ``` And, as you can see, it fails just because of the fonts. I actually had to git clone it. And I really enjoyed it actually.
I understand the importance of text (and vector to some extent though I wouldn't call it essential). But why would you consider lens is a primary prerequisite for writing a competent compiler? GHC itself is an example of perhaps the most non trivial compiler written in Haskell and it doesn't use lens anywhere.
Oh, I largely agree that salaries should be more public, but I just don‚Äôt expect much to change
[removed]
Have you tried the \`ghc\` in \`nixpkgs\` for arm? As far as I know (but not tested personally), it works well if you are directly on an arm machine. Cross compilation from k8 may be another story. You can try to install nix and then \`nix-shell -p ghc\` and see what's happening. Then you can continue with nix + cabal or nix + stack depending on your needs.
[Issue #1296 is relevant](https://github.com/haskell/haskell-ide-engine/issues/1296)
Size of code / features is a useful metric, but it leaves out a several factors. For example, having written tons of Python and Haskell, Haskell can be far more succinct than Python, but sometimes it's far more verbose. But either way, Haskell is encoding about 10x more information than Python is. Python (without type hinting, which is how I used it) has almost no encoding of type information. This means that Haskell is actually encoding 10x more information in its lines of code than Python is. This "10x" is an off-the-cuff made-up figure. If you could actually quantify this somehow, you'd find that Haskell is, overall, a far denser language than Python. It's encoding a lot of constraints and invariants in those lines of code that are missing in other languages.
I am probably older than you and I still haven't gotten around to reading about type families, so the proposal doesn't even make any sense to me lol.
I don't consider *lens* a prerequisite for writing a competent compiler. I consider *lens* a prerequisite for writing concise Haskell. I consider banning *lens* a handicap especially if LOC is being counted.
In short, GHC's support for ARM has until very recently been a bit spotty. There has always been a handful of people (myself among them for a while) who have tried to keep things working however the architecture did not have proper testing and there were numerous corner cases which users had to avoid (e.g. [spotty LLVM](http://www.smart-cactus.org/~ben/posts/2014-11-28-state-of-llvm-backend.html), a [number](https://gitlab.haskell.org/ghc/ghc/issues/16784) [of](https://gitlab.haskell.org/ghc/ghc/issues/10977) [linker](https://gitlab.haskell.org/ghc/ghc/issues/11289) [issues](https://gitlab.haskell.org/ghc/ghc/issues/11123), [memory ordering troubles](https://gitlab.haskell.org/ghc/ghc/issues/15449)). It was quite possible to use but one had to know where not to step. Thankfully, this is changing now (in the past month or so). The move to GitLab and generous hardware donations from ARM and [Packet](https://www.packet.com/) has allowed us begin testing on AArch64 more rigorously. Moreover, I have been able to put a bit of my paid time on fixing several of the more pressing problems facing the architecture (specifically [fixing memory ordering issues](https://gitlab.haskell.org/ghc/ghc/merge_requests/1128/)). Finally, because these will be properly tested platforms, we will be able to provide official binary distributions for at least a couple AArch64 Linux distributions. This work will be in GHC 8.8.1. If you have any questions regarding how to get started I am happy to help.
Good job, looks great.
&gt; I highly recommend using profiteur and profiteur. Did you mean to post the name of two different tools?
My work for the last four years has relied on hs-tls - thanks Kazu and everyone else who worked on it!
I'm definitely stealing the term "Painstream developers" :)
What is wrong with distribution packages for ghc?
As you see here, they have a tendency to be outdated. I believe that there was some issue with the Haskell packages provided in Arch Linux's AUR that caused everything to be hit with link failures or some such. I have also directly experienced an issue where the Homebrew `ghc` formula for version 8.6.4 apparently misconfigured `ghc` so it could not find the linker and therefore couldn't do anything. Yet, you can pretty much always trust the binaries on the GHC website, so you may as well use them.
This is a fantastic talk. Thanks for sharing! Harper is a much better lecturer than I was expecting!
"a sufficiently expressive programming language is a foundation for all of mathematics" This helps explain why Bob Harper doesn't like Haskell, which is something I'd wondered about before. Haskell is good for creating and maintaing useful programs, not so good for founding mathematics. I'm more sympathetic to his approach now that I know what's motivating it.
Did you have a particular application in mind?
My pleasure! Be sure to actually click the link, not just watch the one video in the preview. It's a series of 5 lectures.
How would you ensure \`pure\` and \`map\` are related? E.g. why would I choose \`pure x = \[x\]\` over \`pure x = \[\]\` or \`pure x = \[x, x\]\` for the List functor?
No, because there are \`Functor\`s that have no reasonable \`pure\`. For example, \`data FunctorOnly b a = F b a\` is a \`Functor\`, but you're going to have a bad time trying to find a function of the form \`pure :: a -&gt; FunctorOnly t a\`. Specifically, note that there \*is\* a function \`first :: FunctorOnly b a -&gt; b\`, so \`first . pure :: a -&gt; b\`. Too good to be true.
I don't know. What's stopping you from making \`pure x = \[\]\` for \`List\` right now? \`pure\` is currently part of \`Applicative\`, but you can still define \`pure x = \[\]\` in \`Applicative\` right?
Applicative can connect `pure` to `&lt;*&gt;`: ``` pure id &lt;*&gt; v = v u &lt;*&gt; pure y = pure ($ y) &lt;*&gt; u ``` Therefore, for a useful `&lt;*&gt;` of applying every element on the left to every element on the right, `pure` has to be `pure x = [x]`.
there's more to it than that‚Äîi think he prefers SML to haskell, and SML also has a hindley-milner type system iirc
Yes, profiterole was the other one i wanted to mention. I'll edit my comment, thanks.
Links of to previous versions are also at the bottom of http://www.cis.upenn.edu/%7Ecis194/fall16/resources.html
To install the tools i use stack install or git clone, stack init, and then stack install. For gitlab ci [I used something like this](https://gitlab.com/gilmi/nyanpasu/blob/master/.gitlab-ci.yml) but I'll search around and see if I can get it updated to something better.
Possibly unconstructive but as a user I would want this to just work (or give a helpful error in the case of failed inference). Is there no way to stuff the concept of "Matchability" back into GHC? Is there a simpler proposal that would work only for injective type families, say?
Is there a recording of the talk in Russian? It would still be helpful to those of us who can understand it.
This sounds very promising! I think the current state of GHC on ARM is actually sufficient for my current goal of just playing around, but it's good to know that it'll improve further.
My understanding was that his beef was with the formal nature of Haskell (and friends) in that in these formalisms, programs cannot exist independently of their type, whereas in his world, programs exist and have computational meaning independently of whatever types they are shown to have.
The recording is not yet published. Organizers of FPure promise it will be done soon.
For this use case I'd recommend Turtle. It's basically a much better version of shell scripting. (Plus, it's opinionated, so if you just use the Turtle.* modules you'll be good to go.)
Do you have any sources for this?
We have some fairly robust and well documented CircleCI orbs for "cabal v2-" based CI workflows: https://circleci.com/orbs/registry/?query=haskell&amp;filterBy=all
This seems to work quite well, thanks! Further thanks to whoever donated an ARM machine for building binary Nix derivations.
The linked video? How did you interpret what he was saying?
Thanks for your hardworking, Ben!
Reading in between the lines, because Haskell 2020 has stalled, does not imply that that GHC has stalled. Every new GHC release brings new language features/extensions, updates to packages, and a slew of bug fixes. &gt; like every programming language, Haskell needs tending. But the weeds aren't being pulled, and new flowers not planted GHC seems pretty healthy to me: https://gitlab.haskell.org/ghc/ghc/graphs/ghc-8.8/charts. &gt; Let's say I want to write a small text-processing command line app that does proper error checking If that is your goal, I'd say let that be your learning project to explore the capabilities of Haskell. Learning Haskell/FP is hard enough without all those distractions--at this point in the learning game, they're distractions. You're not going to get an intuitive feel for the issues you've raised until you understand how to compose a non-trivial haskell program. And the only way to do that is through coding.
Oh, I didn't realise that your comment was directly referencing the video - I interpreted the comment thread as general commentary about Bob Harper. I'll watch the video and get back to you.
I find that the general issue is probably what most people experience when they arrive at Haskell for the first time. The multitude of choices, libraries, extensions, techniques are quite overwhelming, in addition to learning FP, for beginners. I think there's also a mistaken view that Haskell 2020 is going to resolve these issues for beginners.
Sounds like a common misconception about one of the requirements of functor, namely functor `f` maps `a` to `f a` for any object (type) `a`. It means that `f a` is a *type* for every `a`, not that a function `a -&gt; f a` exists.
EXACTLY.
Inventing your own is usually a good way to go: [http://dev.stephendiehl.com/fun/002\_parsers.html](http://dev.stephendiehl.com/fun/002_parsers.html)
Also `Const b a`, the bedrock of Lenses
Almost agree. The definitions of pure and &lt;*&gt; are indeed related by the laws you state which why it is sensible that they are separate from Functor in their own Applicative typeclass. But the specific definitions you state are not the only sensible ones for List, just the default ones. For example, the different ones offered under the ZipList newtype for List are equally valid and just as useful.
But given that the premise of the comparison was building a compiler (one of the core strengths of standard Haskell) I wouldn‚Äôt consider banning lens as a handicap. I would have a different opinion if the comparison was on writing a web app exchanging complex JSON requests etc.
If I have a monad `MyMonad` and an instance `MyInst`, is there some way to implicitly add `HasCallStack` to any functions returning either a `MyInst a` or a `MyMonad m =&gt; m a`? i.e. right now I'd write f1 :: HasCallStack =&gt; Int -&gt; String -&gt; MyInst String f2 :: (HasCallStack, MyMonad m) =&gt; Int -&gt; String -&gt; m String but it would be nice if `HasCallStack` could be added automatically. `class HasCallStack =&gt; MyMonad m` gives an "illegal implicit parameter" error. I can presumably do `type MyMonadCS m = (HasCallStock, MyMonad m)`, but then I need to remember to use that (and import it), so it's not ideal.
And how do you implement pure for (,) Int without picking an Int out of nowhere, or for the Functor that we have for Map k, etc. `pure` isn't a requirement of Functor. You can build a class of "Pointed" thing that admit `pure`, but not every functor does, and pure on its own is basically useless without some law relating it to other behavior like (&lt;*&gt;).
He's one of my favorite computer scientists, I'm thrilled to see a full presentation from him! His [blog](https://existentialtype.wordpress.com/) is also a great read, especially if you're someone who comes from more of an ML background like me.
This reminds me, could we *please* update the sidebar (*Learning Material*) to something that is more along the lines of what we actually recommend people start with nowadays?
It's my blog post so if you have questions let me know!
There is a way to tweak your code to make it work, but I recommend learning to write recursive functions manually before using the list comprehension subtraction sugar.
Ok, I didnt know this was considered sugar :P If you have any material you like I dont mind reading it!
I'm sure your books will cover it soon enough!
Ha, glad we talked about it the other day :)
In list comprehensions, your x and l will comprise of all pair that satisfy your condition. Thus, 8 will be paired with 0 to 9, thus being printed so many times.
I saw this talk in person and although he moves quickly (and still didn't have enough time to get through everything he wanted to!) he's enthusiastic, organized and usually presents things in a logical way.