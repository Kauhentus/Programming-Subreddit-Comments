Any progress? I'm very interested in the topic but can't stand watching the video without seeing the slides.
`BangPatterns` is (mostly) simple, and tremendously useful.
Or use it with `DerivingStrategies`
No. I mean to make it very clear whether something is defined/imported for macro processing time or run time.
Sure, but none of these are "must haves for writing production code", as was asked.
&gt; No, I'm talking about "as you type" with implicit type hole assumed at cursor position. I don't think this kind of completion would be at all useful. The number of potential things you could put there is way too large. If anything I would expect that sorting more concrete types first would be counterproductive. You'll get way more value by just putting all possible symbols and filtering the list down as you type the prefix.
I like laziness. It's just something you mustn't get sloppy with.
Agreed. `OverloadedStrings` is ubiquitous and stable, not esoteric and experimental.
&gt; The worst thing that can happen is the compiler runs forever. In practice, this doesn't happen, it just fails after too many iterations.
[Might be referring to this](https://typesandkinds.wordpress.com/2013/08/15/roles-a-new-feature-of-ghc/). Should be fixed after GHC 7.8
Take a look at elm and cycle.js as well.
for every a you have #B possibilities to map it, hence overall (#B * #B * ... * #B) = #B^#A.
Very representative answer that illustrates of the deep corruption of computer science. Like science has been corrupted into scientism, which is an ideology, the world of the technique has been corrupted into technologism. Is is no longer a way to improve human life but some kind of empty onanistic narcissistic religion. It is massaging abstract list in the most contorted way possible and making boring post and papers that say nothing interesting. People not completely empty feel guilty for that emptiness. 
To be fair, you can implement an API similar to field tags with TypeLits and Generics and get that same decoupling in your Generic serialization instances. But to be fair, I’m pretty sure you can implement ALL of Go’s features as a Haskell EDSL.
I think the original tweet is more about perceived difficulty than lack of seriousness. And yes, the hello world example is easy, but there are other things that are harder and for some people that extra cognitive load might be too high a price to pay. Instead of trying to evangelize people on Haskell it's better just to write useful and reliable software with it.
To be honest, I feel like some ill-defined set of GHC extensions is de facto part of the core language.
I appreciate `LambdaCase`, which lets you replace `\x -&gt; case x of {...}` with `\case {...}`, which avoids creating an unnecessary variable and is generally cleaner.
This is also nice for replacing things like mx &lt;- readIORef ref case mx of Nothing -&gt; ... with the equivalent readIORef ref &gt;&gt;= \case Nothing -&gt; ... This pattern occurs often, for example with `try`.
Do you have any hobbies, like collecting things or building things for fun? If so, do you feel the same guilt spending your weekend playing a sport like soccer, or building boats in a bottle?
I don't have any hobbies, by the time I go to work and do life chores there is not much time left over. But I would feel guilty spending too much time on things non programming related. Its just the guilt is sometimes multiplied if I feel like I am not focusing on what I should in terms of developing as a coder. 
Agree with the former. But do you think the latter situation is getting worse? or better. As I see, it is getting better.
To me, `MkFoo` makes sense when constructing a value (`let x = MkFoo 5`), but it looks weird when deconstructing one: case x of (MkFoo 5) -&gt; ... That "Make" (`Mk`) feels out of place – it makes me think I'm undoing a "make" operation instead of just unpacking some values. Not sure if I should just throw these terms around, but `MkFoo` feels more imperative ("I'm making a Foo"), while `Foo` is more declarative ("it's a Foo").
Building a hideous, unmaintainable piece of garbage is not always a failure. Maintenance is not always needed. Sometimes it's more important to ship, and at any rate, *not* shipping is a definite failure even if the thing you made that no one wants is beautiful and interesting.
The problem seems to be specific to scientific notation literals. On GHCi, Both `10^1000000 :: Double` and `:t 10^1000000 :: Double` terminate near-instantly, while there is a noticeable delay with `1e1000000 :: Double` and `:t 1e1000000 :: Double`.
What you say is true but since there is so much ghc does that folks start expecting infinite smartness from it ;-). Even if there was an InfiniteWisdom language extension the spoilt Haskell programmer would start demanding Wisdom of the next cardinality.
No, I feel guilty when I write error prone in other language.
Re: The visibility problem. You may already know this but reflex-style FRP deals with this using a combination of `MonadFix` and laziness. You can create a label which reads its value from a `Dynamic`, and a text fields that exposes a `Dynamic` representing its current value. You don't necessarily need `MonadFix` for this one, actually: if the label widget appears after the text field widget you can just extract the `Dynamic` and pass it down. But `MonadFix` lets you have the label refer to the `Dynamic` from the text field even before you've called the function to create the text field, and laziness and `mdo` make it all magically work.
[I *think* `MFunctor` might be what you're looking for](http://hackage.haskell.org/package/mmorph-1.1.2/docs/Control-Monad-Morph.html#t:MFunctor). It comes from a package that's more tied to monads, but I believe `MFunctor` itself is just functors on the category of functors; i.e. things that can always lift natural transformations. You mentioned `(f ~&gt; g) -&gt; n f -&gt; n g`, which `MFunctor` doesn't provide. But it *can* if you wrap and unwrap [with `Some`](http://hackage.haskell.org/package/dependent-sum-0.4/docs/Data-Some.html).
Yeah `MFunctor` has the correct types but you're expected to ensure that you only hoist monad morphisms. That trick with `Some` is clever, but you might lose information about the contained element?
In 2004 I started learning Ocaml because it was a good match for a problem I wanted to tackle (building a simple computer algebra system). I wrote a whole bunch of stuff in Ocaml, but during the course of 2008 I mostly switched to Haskell, because Haskell had a stronger community, more libraries and made type level distinctions between pure and impure functions. I have now been programming Haskell professionally for 5 years. Do I feel guilty? Hell no!
You may be right, though the comments do politely ask you to hoist only monad morphisms.
If the original was `LimitTo Int` why use `Natural` instead of `Word` which is the unsigned equivalent if `Int`?
this is so awesome! thanks for sharing
In case you have to write a WebUI, I am co-maintaining [Cycle.js](https://cycle.js.org/), a functional reactive frontend framework. Basically keep all the side effects in one place (called drivers) and let your complete app be pure. Also it's written in typescript, so you get at least some types.
There's lots of rank-2 versions of Haskell type classes in the [rank2classes](https://hackage.haskell.org/package/rank2classes-1.0.2/docs/Rank2.html) package (I think the `Functor` there is basically your `NTransformable`). Not sure if it's exactly what you're looking for, but I've found them useful -- particularly because the template Haskell utilities provided remove some of the pain in the same way `deriving (Functor,Foldable,Traversable)` does for regular Haskell classes.
My view is that it is worsening. I see Haskellers more and more comfortable playing inside of the box.
&gt; ... even when I cannot know their types? No, that wouldn't make any sense. But you can ask GHC to add type information just for this function: {-# LANGUAGE GADTs #-} {-# LANGUAGE ScopedTypeVariables #-} {-# LANGUAGE TypeApplications #-} import Data.Typeable myMin :: forall a b . (Typeable a, Typeable b, Ord b) =&gt; (a,b) -&gt; Maybe b myMin (a,b) = case eqT @a @b of Just Refl -&gt; case compare a b of LT -&gt; Just a EQ -&gt; Just a GT -&gt; Just b Nothing -&gt; Nothing This `myMin` returns `Just` the smaller of the two inputs when they have the same type and `Nothing` otherwise. *Main&gt; myMin ("hello", "world") Just "hello" *Main&gt; myMin ("hello", 7) Nothing *Main&gt; myMin (1,2) Just 1
WTF Reddit, I did not remove anything.
That is some good stuff you smoke.
Can you please provide a link to the post you refer to?
Ah yes. That does indeed look nasty, but unless one is using a more than 4 year old version of GHC this shouldn't be a problem I s'pose.
I'm not against laziness per se. I'm against implicit laziness, which is the case in Haskell. It introduces so much accidental complexity into the language, its infrastructure and makes it hard to reason about how code will be evaluated. There's so much complexity in the compiler dealing with the consequences of the language being lazy. We have packages like "deepseq" working around the obstacles that laziness introduces to concurrency and parallelism. We have strict versions of most of basic abstractions and data-structures, confusing the newcomers and not only. And we have every haskeller having to go thru the nightmare of fighting leaks. I wish Haskell was strict with laziness provided with explicit abstractions. Laziness could be just another monad. [I've written a post about it](http://nikita-volkov.github.io/if-haskell-were-strict/). 
There's something like this [in the `conkin` package(http://hackage.haskell.org/package/conkin-1.0.2/docs/Conkin.html#t:Functor).
Professional haskeller Alexis King has got your back https://lexi-lambda.github.io/blog/2018/02/10/an-opinionated-guide-to-haskell-in-2018/
Have you seen my (unfinished) half book "Functional Design and Architecture"? It has exactly this goal to accomplish. Unfortunately, I was not able to finish it that time due to financial reasons and because the publisher has considered this project not interesting to continue with. https://www.reddit.com/r/haskell/comments/6ck72h/functional_design_and_architecture/
Well, I assume, that if you choose finite number to represent limit then you wouldn't limit something like `Integer`. At least it feels inconsistent and slightly weird that you can limit with upper bound only some range of data type values. If you have `toInteger (maxBound :: Word) + 1`, it could be limited only by `Unlimited` constructor and this just doesn't feel right. The problem can be solved partially if you have function like `Integer -&gt; Maybe Word` but it just feels slightly wrong to me to represent limit for **any number** with finite number and separate `Unlimited` constructor. And if you limit number that are less than `maxBound :: Word` then you don't need special `Unlimited` constructor because values of those types can't be possibly bigger than `maxBound :: Word`. 
That's one of the things I want to do with [`n-ary-functor`](http://hackage.haskell.org/package/n-ary-functor) once I get around to it (I have way too many projects...). I have already implemented (but have not yet published... did I mention I have too many projects?) a generalized version in which each type parameter has a specific variance, and then the mapping function expects a different kind of function for transforming that parameter. I don't think it would be too hard to support type parameters with different kinds, so that type parameters of kind `* -&gt; *` would be transformer using a natural transformation.
He's smoking from the tree of wisdom.
I'm new to Haskell (only started to learn 2 weeks ago). My only reason to not use it in production is the lack of user friendly tooling. There is not IDE I can install and then just start to program, I have to install extension x, y, z in either editor a, b or c, and then find out that several extentions don't work with haskell version n, so I'll have to compile (!) extention w instead... Starting with a language and get some automatic support from an IDE shouldn't take 6+ hours to get it running. Fix that, and I'll take Haskell seriously. 
Ubuntu 18.04, and via `apt-get`. I actually fixed it by running `sudo apt-get purge cabal-install`, manually deleting `.cabal` from my home directory, then reinstalling using the tarball.
http://joeduffyblog.com/2016/02/07/the-error-model/ Sorry. it was linked under "here" in my reply to ocharles.
&gt; But sometimes you have to pay the price of novelty to get out of a design space rut. I'm interested in hearing about examples from the real world. Would you mind giving an example or two of this?
I use the Haskell intellij plugin and never installed Intero. The plugin installs all its needed dependencies itself in a separate folder so that it doesn't mess with your project. It also installs Hindent, Stylish Haskell, etc.
Look at purescript. 
I'd assume this is correct, but for if you're interested in the performance of these functions you might find the following comment in the source illuminating in terms of some of the considerations that come into play: https://hackage.haskell.org/package/base-4.11.1.0/docs/src/GHC.Base.html#line-305
AutoModerator being its usual, overzealous self. 
Hi, /u/yungbull9190/. I'm afraid I'll have to remove this post. This subreddit is not for helping you with your homework.
Not to mention the Monad m constraint on hoist. So yea not quite what you want
To elaborate: The reason forkIO is used in this example is because the example lets you create JWT tokens on the fly by entering information in the terminal. You can then access the protected endpoint using those tokens, as demonstrated. If the server isn't forked into its own thread, it would not be possible to accept input. 
&gt; Professional haskeller Alexis King Did you read the first sentence of this (helpful) blog post?
I try to learn more about lens package. Support I have a structure \`\[(a, a), (a,a)\]\`. Now I want to apply \`over\` with a function \`a -&gt; Maybe b\` into the second item of the second tuple. How can I get \`Maybe \[(a, a), (a, b)\]\` back. &amp;#x200B; Thanks
This sounds like copatterns (I was just reading about this, look at subsection [**2.2 Copatterns in functional programming: Restoring a missing symmetry**](http://www.cse.chalmers.se/~abela/popl13.pdf))
The `a` in `it` in your program is `WaiSession ()`. It has an `Example` instance: type WaiExpectation = WaiSession () instance Example WaiExpectation where type Arg WaiExpectation = Application (The actual instance is for the type synonym WaiExpectation) So that means that: it @(WaiSession ()) :: String -&gt; WaiSession () -&gt; SpecWith Application
You might try asking anyone with a dependency on one of your packages if they'd like the maintainer bit, since I assume they would (a) know a little bit about the code, and (b) be invested in keeping it in working order.
I'd first like to say: thank you Secondly, I'll start taking a look at some projects this week and see if any of the issues are up my alley.
I currently have a lot of free time on my hands so I'll see if there is something i can do. Let me know if there is something specific you would want me to take a loot at.
This is just a hunch, but I get the feeling that it's something we would scratch our heads about, learn why it is that way, then ignore the little idiosyncracy it creates.
Idris goes this direction, but it has some disadvantages. For example, early versions of Idris didn't have short-circuiting `&amp;&amp;` and `||` operators. (This was fixed before the 1.0 release.) It's you also don't get free ana/cata fusion; intermediate structures are always forced into existence. If you are aware of both ends, you can rewrite as a hylo, that's not always easy and usually anti-modular. Ubiquitous laziness (like Haskell) allows you get ana/cata fusion between coalgebras and algebras that are in separate modules with no meaningful cross-dependencies. It means that things like Pipes and Conduits can be manipulated as data, but often completely disappear by runtime. I think purity is *much more* important than laziness, but I think ubiquitous laziness is actually a good design choice because it makes it easier to reuse code.
If you're on Ubuntu, you can read my blog post about introduction to Haskell build tools. There I described preferred way to install `ghc` and `cabal-install` and gave example of basic workflow with Haskell build tools. * https://kowainik.github.io/posts/2018-06-21-haskell-build-tools.html
This is not possible. Lists are homogeneous in Haskell. You can't have values of type `(a, a)` and `(a, b)` at the same time inside list. The closest thing is to have list of type: [Either (a, a) (a, b)] If you have a function of type `a -&gt; Maybe b` then it's possible to write function: (a -&gt; Maybe b) -&gt; (a, a) -&gt; Either (a, a) (a, b) And then you can work with your list of `Either`s.
I just started using megaparsec for a project a couple of weeks ago, after using normal Parsec for all my previous parsing needs. It's been great. I would be happy to help maintain megaparsec. I'm currently familiar with the package *as a user*, but haven't dived into the implementation, so it might take a bit of time to get up to speed.
While looking at `:info Eq` in ghci, I noticed `Eq` is specialized for tuple of different size. &gt; instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f) =&gt; Eq (a, b, c, d, e, f) -- Defined in ‘GHC.Classes’ instance (Eq a, Eq b, Eq c, Eq d, Eq e) =&gt; Eq (a, b, c, d, e) -- Defined in ‘GHC.Classes’ instance (Eq a, Eq b, Eq c, Eq d) =&gt; Eq (a, b, c, d) -- Defined in ‘GHC.Classes’ instance (Eq a, Eq b, Eq c) =&gt; Eq (a, b, c) -- Defined in ‘GHC.Classes’ instance (Eq a, Eq b) =&gt; Eq (a, b) -- Defined in ‘GHC.Classes’ Does haskell has something similar to `parameter pack` in C++? In C++, the `=` operator signature is very simple for tuple, template&lt; class... TTypes, class... UTypes &gt; bool operator==( const tuple&lt;TTypes...&gt;&amp; lhs, const tuple&lt;UTypes...&gt;&amp; rhs ); https://en.cppreference.com/w/cpp/utility/tuple/operator_cmp
Thanks. I attached your comment to the bug report.
`Maybe Char` is a type, its values may be `Just 'a'`, `Just '~'`, `Nothing`, etc. This function signature (`Char -&gt; Maybe Char`) makes sense if it takes a char value and maybe makes another char from it. E.g. you want to capitalize a character and do not want to return anything if it's not possible: ``` import Data.Char -- this is the type signature, -- it says to the compiler that it's not possible -- to call this function on anything except Char: onlyCapitalized :: Char -&gt; Maybe Char -- the runtime definition: onlyCapitalized c = if ord 'a' &lt;= ord c &amp;&amp; ord c &lt;= ord 'z' then Just (chr (ord c - 0x20)) else Nothing ```
Thanks guys for the inspiration! Just to follow up on this after giving it much thought and draft implementations, I settled on something basically everyone suggested: A design that transforms the program state into a widget hierarchy (note that I don't have a DOM in the background, sadly) and then renders this hierarchy. This happens every frame, currently, so the widget hierarchy is immutable, conceptually. No back-and-forth callbacks and components mutating state as they please. Widgets, in turn, can emit events which change the program state. There's a few minor things that are the downsides of this approach: &amp;#x200B; \- Performance probably isn't as good as with a more mutable design, as always. \- Management of focus is a little more complicated, as focus is something I want to preserve between successive frames (at least if the widget tree doesn't change dramatically, i.e. the focused widget is gone). I achieved this by adding a string label to each focusable widget and remembering this string between successive frames. This way, I can re-find my widget in the widget hierarchy. \- The program state has to be augmented in a few places, more than the user should really care. For instance, to preserve the cursor position of input widgets, the user has to store not only the input field's content, but also this position. It's not hard, though, and this way, the user even has ways to modify the cursor position, which would be awkward otherwise.
If maintainers are people who improve the projects, are co-maintainers people who will get improved by the projects? Jokes aside is there, are there specific ways this would start? Probably working on open issues / feature requests? I am interested in Req, Zip and maybe text-metrics.
I've only played with this very briefly, but my feeling is that the problem is not that `&gt;&gt;=` is type changing, it's that `a'` isn't in scope at the call-site. If you get rid of the wildcards and comment out the first `case` branch, ghc will start to complain about `a'` escaping its scope. The issue (as I understand it) is that the `a'` type is tied directly to the `w` name. `w'` has a different existential type variable attached to it. As for why *that* `a'` (the one introduced by `w'`) unifies with `a` when the first case branch is present I couldn't tell you. `undefined` might be to blame? I'm afraid I don't know how to solve this though. I don't have much experience plumbing existentials around in haskell. 
This doesn't have anything to do with existential types. It's because you specified two different type variables so ghc assumes they must be different. I think 'Rigid Type Variable' used to be called 'User Specified Type Variable'? Anyway, you might wanna think about whether horizontal and vertical composition should be mixed like this. That is, cat b c -&gt; cat a b -&gt; cat a c and m a -&gt; (a -&gt; m b) -&gt; m b Maybe look at the implementation of pipes or conduits for an example of how they could be split.
Yes, the biggest missing things at this point, I think, are some really good docs (like the tutorial, but for servant-auth), and maybe a couple other solid auth schemes.
Think of `(forall a'. Process m a (b, Maybe (Process m a' b)))` as the type of a function that takes a type argument `a'` and returns a process of type `Process m a (b, Maybe (Process m a' b))`. In Haskell, type applications are (typically) implicit. When you call `stepProcess` on `w`, the function has to be applied to a type to get a process. This means that the type is fixed in the result, with the inferred type being `Process m a (b, Maybe (Process m a b))`, instead of being a `forall` type, which is required for the recursive call to `switchM`. If you replace `(forall a'. Process m a (b, Maybe (Process m a' b)))` with `Process m a (b, Maybe (Process m a b))` in the signature for `switchM` then you don't get the errors, and that is perhaps closer to what you have in mind. I think the root of the issue is that the rank 2 type for `w` is not doing what you expect. &gt; I use a rank 2 type to represent that the new Process starts fresh and doesn't depend on any values from the previous Process. Quantifying the type doesn't achieve that. What it actually means is that the process `w` is a process that may generate a process of any input type you choose. Parametricity implies that this process would have to effectively ignore its input, since the input type is abstract. Moreover, since the new process is returned by another process, the choice of new process can absolutely depend on values from the old process. For instance: testProc :: (forall a'. Process Identity Int (Int, Maybe (Process m a' Int))) testProc = PProc $ \a -&gt; ((a, Just (restProc a)), testProc) where restProc a = PProc (const (a, restProc a)) What you might intend to achieve with the rank 2 type is to ensure that `stepProcess w'' undefined` does not evaluate the `undefined` input. In that case, it also won't evaluate any of its inputs. (Actually, this is a bit of a simplification, since it is still possible for it to evaluate the argument and throw the result away (e.g. with `seq`), which would result in an error when passed `undefined`.) Perhaps changing `(_, Just w'') -&gt; stepProcess w'' undefined` to something like `(r, Just w'') -&gt; return (r, w'')` would do the trick? 
Thanks for the replies, makes sense! &amp;#x200B; &amp;#x200B;
Got it. But i think i have described my problem poorly. Let's say I have a aeson Value called `userData`. I have a lens likes `key "data" . key "user" . key "someUserField" . _String`. Now I use this lens to get the Maybe Text out, perform a `f :: Maybe Text -&gt; Maybe Value`. If it returns `Just` then update Value into `userData` using the lens above and return `Just newUserData`. if `Nothing`, return Nothing. I can write normal Haskell with pattern matching, lens get and set to accomplish that. But can I do it in a more lens likes way?
Non-exhaustive list of packages you'll likely need. - [async](http://hackage.haskell.org/package/async) for general concurrency support (running various servers simultaneously for example). Functions like [concurrently](http://hackage.haskell.org/package/async-2.2.1/docs/Control-Concurrent-Async.html#g:9) are dead simple to use. - Some kind of concurrent queue / channel library, like [stm]([http://hackage.haskell.org/package/stm-chans](http://hackage.haskell.org/package/stm-chans)) or [stm-chans]([http://hackage.haskell.org/package/stm-chans](http://hackage.haskell.org/package/stm-chans)). - Possibly some kind of streaming library like [conduit](http://hackage.haskell.org/package/conduit), [pipes](http://hackage.haskell.org/package/pipes) or [streaming](http://hackage.haskell.org/package/streaming). They often have integrations with the channel libraries. - [yaml](http://hackage.haskell.org/package/yaml) for, well, Yaml. Notice that it reuses the representation of the popular JSON parser, [aeson](http://hackage.haskell.org/package/aeson).
Please open an issue then using your GitHub account. You can just put "add me as a co-maintainer" and that's all. I'll give you access to the repo.
I think it's best to give the status of co-maintainer to people who are confident in their skills and who can make decisions about future of a project (design decisions, etc.). I think unfortunately this only comes with experience. But you can still contribute and get your work merged! &amp;#x200B; Don't get me wrong, I'm trying to unload myself, but I know from experience that guiding beginners (and in general coaching people) is going to actually increase my load :-)
Thanks! Open GitHub issues for asking to add you as co-maintainer when you are ready :-)
I am going to preface my answer by referencing /u/thomaswdyoung's answer and say "I am pretty sure this isn't what you mean to do"; a process that is universally quantified on its input type can't possibly make meaningful use of *any* input type. That said, here is how to rewire this to get the result you want. The problem as a few people have specified is that when you apply `stepProcess` you need to decide on a type `a'` for the result. In some cases it might be possible for `stepProcess` to depend on the `a'` it was called with (for example, if `a'` had any constraints applied to it). In this case that's not true, but the way Haskell does higher-rank types has no way to know that. [Here are some details](https://en.wikipedia.org/wiki/System_F). To make your code compile you need to delay the requirement to know what `a'` is. newtype AnyInputProcess m b = AnyInputProcess (forall a. Process m a b) switchM:: (Monad m) =&gt; Process m a (b, Maybe (AnyInputProcess m b)) -&gt; Process m a b ... (_, Just (AnyInputProcess w'')) -&gt; stepProcess w'' undefined ... 
[Zoom to the section](https://www.haskell.org/definition/from12to13.html#do)
23.06.1994 Gofer 2.30 
23.06.1994 Gofer 2.30
I think there are some trade offs. While the repetitive manner in which things are implemented in Haskell might not be terribly elegant, the type signatures are more expressive. For instance, the C++ type signature tells you nothing about the fact that an `operator==` needs to be defined for tuple elements. This means you can easily declare nonsensical functions. Now either the compiler will barf a horrendous error message at you (this is subjective of course and has improved over the years), or won't tell you about your mistake at all. Either because the template isn't actually instantiated, or because it is *technically* correct but doesn't do what you want. Like comparing pointers of decayed c-strings, for example. Another thing would be the requirement that the tuples have to be of the same size. If you look at the implementation of `operator==` (for instance via `echo '#include &lt;tuple&gt;' | cpp -xc++ -H | grep -A20 operator==`), you will see that this is manually checked with a `static_assert`, while in Haskell it is part of the type signature. Regarding tuples specifically, I think there is a different mind people have depending on which language they come from. When `std::tuple` came out, people asked "How do you iterate over a tuple" or "How do you concatenate tuples". Which simply isn't something you would do in Haskell. Tuples are not heterogenous arrays, and it is not really common in Haskell to use "raw tuples" greater than size four or so. You would define a record type instead, so in practice the code repetition you described is not that much of a problem really.
Haskell 1.3 where it appeared is actually from May 1996.
That being said, you *can* do these kinds of things in Haskell, for instance via `GHC.Generics`, or if all else fails, `TemplateHaskell`. The latter was actually inspired by C++ templates and is equally, if not more expressive. It is usually frowned upon if misused, since the type signatures are just as opaque as in C++. For instance, a template haskell function (executed at compile time) would look like declareAllTheTupleInstances :: Q [Dec] which only tells you that some stuff is going to happen "inside the `Q` monad" at compile time, yielding zero or more declarations. The "stuff" may however include arbitrary IO, including stealing your credit card, or scraping hackage and downloading the function definitions...
Tutorials. Especially providing the type of code that covers everything from defining tables, creating/dropping tables on an actual database, inserting values, writing queries etc. (ie. something that reduces to `IO`). Basically a tutorial that covers all aspects of what you need to do if you want to use Squeal to create e.g. a blog or another simple web app. I chose to use `beam` because it has a fair amount of tutorials, but I’m currently stuck trying to issue create/drop table commands against an actual database, because the tutorials don’t cover that part.
Thanks, I do have a mini-tutorial which includes table creation and dropping and inserting and querying, right in the [documentation](https://hackage.haskell.org/package/squeal-postgresql-0.4.0.0/docs/Squeal-PostgreSQL.html) for Squeal. But it would be a good idea to write a more full-fledged tutorial as well. Did you notice the mini-tutorial?
These guys are incredibly nice. No HR intermediary. I genuinely enjoyed each interview and recommend it to anyone considering applying.
Interesting. That gives a very different `Traversable` from `rank2classes`. I wonder when each is better.
Yep. The I’ve been programming Kotlin, which is made by Jetbrains the IntelliJ people. It’s great. Not that Haskel isn’t great but its IDE support is not as good. IDE support is progressing but slowly.
r/programmingcirclejerk
To add to what other people said, I think [More categorical version of Functor](http://hackage.haskell.org/package/categories-1.0.7/docs/Control-Categorical-Functor.html) can represent `NTransformable`/`NTransformableA`. newtype (:~&gt;) f g = NT (forall x. f x -&gt; g x) instance Category (:~&gt;) where id = NT id NT f . NT g = NT (f . g) instance Functor Coyoneda (:~&gt;) (:~&gt;) where fmap (NT f) = NT (hoistCoyoneda f) instance Functor (DSum tag) (:~&gt;) (-&gt;) where fmap (NT f) (ta :=&gt; fa) = ta :=&gt; f fa
Nice pattern. &gt; We could abstract this a little more. Introducing a wrapper for errors with context and writing some common context-adding functions might be worth it. It would be great to see this expanded upon, rather than left as a footnote. The core idea is a bit obvious, and the post doesn't really explore it.
If I'm understanding correctly you just want `key "data" . key "user" . key "someUserField" . _String %~ f`
Thanks for the hint about hiding the forall. in the newtype. I can't believe I didn't think to try that! You are right, the example as it stands is a little contrived. This actually comes from some really old code I was writing a year ago that worked with a specific library handling the Processes, and was already successfully using the RankNTypes trick. The Process actually get some state threaded through them (through stepProcess) representing (usually) the current time, and the library was formulated to give good space guarantees for evaluation and to ensure that continuous, forward-moving-only time was respected. This meant that you didn't actually get a lot of access to the internals of processes (for sure you couldn't access the data constructors without importing unsafe modules, and I think you might not have even got `stepProcess` either). This meant that you were mostly building up processes using various combinators, including something like `switch` or `switchM`. It's still not entirely accurate though that a process that can't act on its input is useless. In fact, if you constructed a giant Process representing the behaviour of the entire program, it would pretty much have to be able to work ignoring its input, since the only input you really get are the command line arguments, which represent an instantaneous value, and not a time varying supply of data (of course you could just pass it in as a constant stream, but I don't think that really fits the semantics of what a process is trying to be). As an example, pretend that you had `Arrow`, `Monad` and `Applicative` instances for Process, and that delta-time as state was being threaded through the `stepProcess` function (although you can get the same thing through your choice of the `Monad` for `m` anyways *). If you had a function `integral c` that represented a Process that integrated its input over time with the given constant, the Process: `pure (-9.8) &gt;&gt;&gt; integral 0 &gt;&gt;&gt; integral 30` would give you a Process representing the motion of a free-falling object dropped from a height of 30 meters. All of the 'input' is done by passing arguments to the functions constructing the process, but the process itself doesn't rely on its own time-varying input `a`. * The thing I like about threading the state is (as I mentioned) you can pick `Identity` for `m` and guarantee you have a Process you can restart, re-run or replace, without having to worry about 'winding back' any state. Is there any way we can identify all of the "idempotent" Monads we could use here (i.e. the action `a` is equivalent to `a &gt;&gt; a`), like Identity, Reader, etc...?
Yup, you've seen through my example haha. This is actually from a boiled-down case of something I was trying to do with an arrowized-FRP library.
See my reply to /u/ryani for why I was using this rank-2 trick. I agree with you that GHC must be attempting to pick a concrete type at the call to `stepProcess` (although the aforementioned reply gives a way to fix it by hiding the forall. in a newtype), I was just curious as to *why* GHC was picking `a` as the type to instantiate. `w'` is only used in one other place, in the call to `switchM`, which is expecting an existential type, so where does GHC even think to pull in `a` from? (In fact, GHC's type error suggest GHC *already knows* that a is the wrong type, but it still picked that to instantiate `a'` as)
OMG that's a lot of contributions. How many hours did that take?
And why not just a function? What do you think the typeclass buys you?
You are missing a space between the text and the link
I did not count! Just created stuff :)
Firstly, let's separate fusion and laziness. There's no requirement for the language to be lazy to have fusion. You can fuse the operations together erasing the intermediate data-structures in a strict language just as much. Secondly, the effect of not getting intermediate data materialized is easily achievable with abstractions, as well. E.g., like [this one](http://hackage.haskell.org/package/deferred-folds-0.9.7.1/docs/DeferredFolds-Unfoldr.html). Thirdly, I'm not suggesting to get rid of laziness. I'm suggesting to make it explicit and as a consequence have it explicitly reflected in the type. Then there'll be nothing stopping you from exploiting laziness wherever it makes sense, however it won't be forced :) upon you when it doesn't. E.g., `foldr` as we know it, requires laziness, so we could implement it explicitly: ``` foldr :: (a -&gt; Lazy b -&gt; b) -&gt; Lazy b -&gt; [a] -&gt; b ``` Please also notice that having it be explicit about laziness now exlains the mechanics of `foldr` way clearer. Also the type-checking now comes to nudge the user to apply it properly. The same goes for the operations that you've mentioned: ``` (&amp;&amp;) :: Bool -&gt; Lazy Bool -&gt; Bool ``` In case you missed it, I've explained the mechanics of how explicit laziness could be implemented before in [the post that I've previously linked to](http://nikita-volkov.github.io/if-haskell-were-strict/).
Things like this aren't "too obvious to write", because the target audience is people for whom this is *not* obivous. Good work :)
^The linked tweet was tweeted by [@argumatronic](https://twitter.com/argumatronic) on Sep 17, 2018 02:47:47 UTC (0 Retweets | 20 Favorites) ------------------------------------------------- so here's a little more about what happened with the book. i think the story should be told, somehow, but it's complex and difficult, so maybe i can tell it best episodically. or maybe this will be it, i don't know. ------------------------------------------------- ^^• Beep boop I'm a bot • Find out more about me at /r/tweettranscriberbot/ •
I hope this is appropriate for /r/haskell as I'm convinced the community needs to know
&gt; Did you notice the mini-tutorial? I did not. I must have Googled "squeal" and only seen Hackage docs (which I apparently assumed didn't contain a tutorial).
One further enhancement that can be made is using template haskell and the [loch-th package](https://hackage.haskell.org/package/loch-th) to get the source location of the error: {-# LANGUAGE TemplateHaskell, DeriveFunctor #-} module Err where import Debug.Trace.LocationTH (__LOCATION__) import Language.Haskell.TH.Syntax (Q, Exp) import Control.Monad.Except (throwError) data WithLocation a = WithLocation String a deriving (Eq, Ord, Show, Functor) throwErr :: Q Exp throwErr = [| \x -&gt; throwError $ WithLocation $__LOCATION__ x |] And you use it by importing the module and replacing `throwError` with `$throwErr`. The output looks something like this: Left (WithLocation "Main.hs:29:27-35" DivByZeroError) By combining this with the context trace approach, you can probably get more helpful errors. 
Fair! I added a little section showing what I'd probably do. 
Lol
Ok, something like this (may not compile): processTMSocket :: Channels -&gt; (Socket, SockAddr) -&gt; Simulation () processTMSocket channels (sock, clientAddr) = do race_ (checkerThread sock interface) (loop True) `finally` liftIO $ do close sock logStr tmArea "TM processing loop terminated." where tmChan = chanTMIF channels loop :: Bool -&gt; Simulation () loop False = return () loop True = do cmd &lt;- liftIO $ atomically $ readTChan tmChan case cmd of MCSTM hdr pl leaps -&gt; do liftIO $ do sendTM sock hdr pl leaps loop True .... MCSTMTerminate -&gt; loop cfg False checkerThread :: Socket -&gt; Interface -&gt; Simulation () checkerThread sock interface = do cont &lt;- liftIO $ do recv sock 1 if B.length cont == 0 then liftIO $ do ifRaiseEvent interface EV_TM_Socket_Disconnected else checkerThread sock interface This is a bit a stripped down version of what I sometimes do with async. A thread (processTMSocket) is listening on a STM TChan for messages and sends the content of the messages to a socket. This thread only writes to the socket. There is no reading as the protocol is unidirectional. So you never detect, if the socket disconnects. Therefore there is a checkerThread, which tries to recv from the Socket. As there is never data received, this is ok (while it would be better to use a recv with MSG_PEEK flag which the standard Network.Socket.ByteString does not provide, this is ok in this case). If the return value of recv is 0, since this is a TCP socket, this means the connection went down and the checkerThread terminates. The race_ call from async ensures, that if one thread terminates, the other is terminated as well. So if the checkerThread terminates, the other thread, possibly waiting on the STM channel also terminates. On the other way round, when the processTMSocket thread gets a MCSTMTerminate message, it also terminates the checkerThread automatically. And if an exception is thrown in any of the two threads, they are closed, and the exception is populated upwards (there is also another parent thread which basically runs the accept loop for the socket). This is short and simple. In e.g. C++ something like this is much more effort to do. With race from async you can build up whole tree-like thread structures which are all terminated at once on certain conditions despite blocking read/write operations, without you explicitly sending them termination messages (which otherwise could be very tricky sometimes). 
For the return type to be correct, the term `stepProcess w'' undefined` must have type `Process m a b`. This means that `w''` must also have type `Process m a b`, and `b` must have type `(_, Maybe (Process m a b))`. The return type of `stepProcess w a` must then have type `m ((_, Maybe (Process m a b)), _)` and the type signature for `stepProcess` then means that `w` must have type `Process m _ (_, Maybe (Process m a b))`. So this means that the quantified type variable `a'` must get instantiated as `a` at this site. More intuitively, when you switch to the new process, you still want a process that takes in `a` typed inputs. This means that when the old process gives back a new process, you want it to be one with `a` typed inputs, so that forall must get instantiated with `a`. If you remove the `stepProcess w'' undefined`, you can see that GHC doesn't otherwise know that it should be `a`. However, it still has a problem, because it needs to be some abstract type that is not yet determined (because the recursive type expects something of type `forall a'. ...`, and this `a'` is a separate instance). GHC knows that `stepProcess w a` must fix the some choice for the type variable `a'` in the type of `w`; but without the `stepProcess w'' undefined` line, it doesn't know what choice to make. However, it can't choose to make it something that is bound by a later forall (i.e. in the type of the recursive call to `switchM`).
TIL. Thanks!
Using [`getCallStack`](https://hackage.haskell.org/package/base-4.11.1.0/docs/GHC-Stack.html#v:getCallStack) you can convert a CallStack to a list of callsites, including the source locations. Most recent call first. You have to be careful to add the `HasCallStack` constraint to every callee of the function where you use `callStack`. A single omission will break the chain. (But you still get the call stack up to that point). The reason becomes more clear once you realise it is implemented using [implicit parameters](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#implicit-parameters).
On a somewhat related note -- if somebody has resources and wants to "Attach stacktrace information to SomeException" https://ghc.haskell.org/trac/ghc/ticket/12096 -- *please* go ahead and do that.
Hey @empowerg, thanks for the example code and description. I will surely get back to it as soon as I can find some time.
For certain types, `mconcat` may be asymptotically better than `fold`. With something like `[ByteString]`, the implementation of `mconcat` walks the list, figures out the total length, allocates a new mutable bytearray of that length, and finally walks the list again, copying all the chunks. By constrast, `fold` will concatenate one chunk at a time, building a new immutable bytearray every time. For a list of singleton `ByteString`s where the total number of bytes is `n`, `mconcat` is `O(n)`, while `fold` is `O(n^2)`.
&gt; Firstly, let's separate fusion and laziness. There's no requirement for the language to be lazy to have fusion. You can fuse the operations together erasing the intermediate data-structures in a strict language just as much. [citation needed] Maybe under whole-program optimization, but that anti-modular. Ubiquitous laziness can do it across ABI boundaries. &gt; I'm not suggesting to get rid of laziness. I'm suggesting to make it explicit and as a consequence have it explicitly reflected in the type. Which is *exactly* what Idris does. It has a delay type that is used for both laziness and co-data. At the type level, it needs to occur explicitly. At the value level, it is inserted automatically and treated as a special syntactic form. &gt; In case you missed it, I've explained the mechanics of how explicit laziness could be implemented before in the post that I've previously linked to. And, as many, many people have already covered that doesn't even nearly approach the call-by-need that is currently implemented in Haskell. Also, either `pure`/`return` is a special syntactic form or *it isn't lazy* in that encoding.
https://old.reddit.com/r/haskell/comments/78xxql/structures_of_arrays_functors_and_continuations/dp0lczy/
&gt; why is everyone seemingly more concerned with the somewhat contrived examples that linear types help us express Why do you think they are? Personally I have no idea what they're interested in but I'd guess that if they're indeed not interested in performance then it's because they've tried it and observed that linear arrows don't really help with performance.
Once you have the basics worked out, take a week or two off and come back with fresh eyes. Because your API is probably bad. It's not you; it's the nature of library development. You'll likely have a better idea for structuring things later. Once you've rewritten the thing once (cutting and pasting good implementation bits as appropriate), ask others for feedback. There may be conventions you've unintentionally violated, or mistakes you're not the first to make.
Linearity is just a constraint on what a function is allowed to do. To do in-place mutation, that isn't enough: you need the promise that the function's argument is not used anywhere else, either. In other words, you need both (1) guarantees that certain functions use their arguments linearly, and (2) guarantees that the arguments are not referenced elsewhere (e.g. with uniqueness types) in order to get optimizations, and the linear types proposal only addresses point (1). What a hypothetical Haskell with linear types and uniqueness types should look like is not at all clear right now.
I am not the person you replied to but maybe look into [miso](https://github.com/dmjio/miso) (it is inspired by Elm and Redux)
See also section 6.3 of Linear Haskell where this same point is made much more coherently: https://arxiv.org/pdf/1710.09756.pdf An excerpt (but read the whole section, it is short and lucid): &gt; Linear types and uniqueness types are, at their core, dual: whereas a linear type is a contract that a function uses its argument exactly once even if the call’s context can share a linear argument as many times as it pleases, a uniqueness type ensures that the argument of a function is not used anywhere else in the expression’s context even if the callee can work with the argument as it pleases. &gt; Seen as a system of constraints, uniqueness typing is a non-aliasing analysis while linear typing provides a cardinality analysis. The former aims at in-place updates and related optimisations, the latter at inlining and fusion. 
[*hask*](https://gist.github.com/ekmett/b26363fc0f38777a637d) is my favourite class (Category (Dom f), Category (Cod f)) =&gt; Functor (f :: dom -&gt; cod) where type Dom f :: Cat dom type Cod f :: Cat cod fmap :: (Dom f) a b -&gt; (Cod f) (f a) (f b) in that terminology, you want type (~&gt;) = Nat (-&gt;) (-&gt;) type HitByNat f = FunctorOf (~&gt;) (Cod f) f and the instances look like instance Functor (DSum tag) where type Dom (DSum tag) = (~&gt;) type Cod (DSum tag) = (-&gt;) fmap :: (f ~&gt; f') -&gt; (DSum tag f -&gt; DSum tag f') fmap .. instance Functor Coyoneda where type Dom Coyoneda = (~&gt;) type Cod Coyoneda = (~&gt;) fmap :: (f ~&gt; f') -&gt; (Coyoneda f ~&gt; Coyoneda f') fmap (Nat nat) = Nat (hoistCoyoneda nat)
&gt; In my opinion, the greatest weakness of Haskell -- as implemented by GHC -- is its "immutable" garbage collector Would like some more evidence backing this up. &gt; This causes certain algorithms implemented in idiomatic Haskell to be n times slower than their Java counterpart Still requires evidence. &gt; We can get around this by using stuff like the ST monad but -- in my opinion -- this means we lose what makes Haskell great, which is the ability to express outselves in terms of logic rather than operations. Not at all. In fact, the use of monads to express effects like this is quite elegant. It has the side effect of making things look more operational, but then what do you expect? You try to mimic a Java algorithm exactly. My first approach would have been to solve the same problem with an immutable functional data structure. If that doesn't work, *then* one can use the `ST` monad. &gt; Optimizations should happen at another level. That would certainly be nice. &gt; I'm just puzzled that so few people seem interested in a huge performance boost like this For one thing, I'm not convinced it's a "huge performance boost" in practice.
My blogpost [Linearity, Uniqueness and Haskell](http://edsko.net/2017/01/08/linearity-in-haskell/) might answer some of these questions, but bear in mind that this blogpost was based on an earlier version of the proposal, I have yet (to my shame) to to read the POPL paper. 
&gt; Linearity is just a constraint on what a function is allowed to do. To do in-place mutation, that isn't enough: you need the promise that the function's argument is not used anywhere else, either. I'm aware of this. To be clear, here's the optimization I'm proposing: Given a function `f` of type `a ⊸ a`, we can do the following: 1. Allocate a copy of the input argument of the function 2. Apply `f` to this value (in-place) any number of times If the type `a` is e.g. a `Vector` of size *n* then this will speed up operation **2** by a factor of *n* (since the array can be updated in-place rather than re-allocated with a small change, and the old copy being GC'ed). So this is an optimization for tight loops where Haskell functions can be really slow, currently (because of the immutable GC), and where the initial cost of **1** (allocating a copy of the input argument) is tiny compared to the cost of **2**. 
Well, they probably have to implement it before they can start optimizing it. In any case, it already does increase efficiency by letting us mutate arrays in pure code.
That makes sense.
&lt;%~ if you want the result too
Some links: - http://oleg.fi/gists/posts/2018-09-13-regular-expressions-of-types.html slides with some notes - https://github.com/phadej/kleene-type the implementation
Interesting. I'm rather curious whether it will turn out that they're actually (essentially) equivalent. Can each be implemented in terms of the other, perhaps using something shady that's similar to `Magma`?
Which examples were you looking at and where did you find them? Using linear types to build a pure interface to mutable arrays is indeed one of the examples in [the paper](https://www.microsoft.com/en-us/research/uploads/prod/2017/12/linear-haskell-popl18-with-appendices.pdf) (see Section 2.2). &amp;#x200B; Not that this would improve performance much per say. Because as you point out, mutating arrays is already possible in the ST monad. I should also note that performance \*is\* (one of) the motivations for linear types. Again, not that linear types give you a magic performance boost that you couldn't otherwise have, but for some workloads manually managing system resources like (part of the) memory can yield a performance boost and linear types just help in making that safe. That was our original use case.
The authors of the paper propose an array API that benefits from the optimization you describe; it's explicitly part of the motivation for the work. If youre looking for the compiler to turn arbitrary library code into something that uses in-place updates, that sounds like magic.
I'm using Haskell-Src-Exts (HSE) to parse Haskell source code into ASTs. Is there a programmatic way to 'move' through the tree (ideally one node at a time) without necessarily doing pattern matching? For any given type, there are some many constructors that a pattern matching sequence would grow gigantic. Thanks in advance :)
Another question: can I 'force' a type coming from a 3rd party library to use record syntax? It would be so convenient 
You can use [`-XPatternSynonyms`](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#record-pattern-synonyms). Say you're using a library that defines data Person = Person String Int [Person] Then you can create the pattern synonym pattern Person' :: String -&gt; Int -&gt; [Person] -&gt; Person pattern Person' { name, age, friends } = Person name age friends With this you'll be able to use the `Person` type just like you would if it was defined as data Person = Person' { name :: String, age :: Int, friends :: [Person] } For example: birthday :: Person -&gt; Person birthday person@Person'{age=oldAge} = person { age = oldAge + 1 }
Type level nonce?
No, you can not. What you can do is provide a lens for each field but that is more involved. Morally it is just a flexible field accessor and setter.
Is there a way to use a parameterised `fix` inline? ``` λ :t fix $ \f a -&gt; a fix $ \f a -&gt; a :: p -&gt; p ``` So I want to call that function with a parameter from the left hand side, as with `&amp;`, and without using parentheses. 
&gt; arbitrary library code into something that uses in-place updates, that sounds like magic. I think the compiler should be able to turn linear record updates into in-place updates automatically. (And, I think this optimization should be able to "filter up" to updates via a "linear lens".) For arrays/vectors and maps, I agree that separate libraries can be developed in parallel or after linear types are available.
Nice "trick". I never thought about record-looking pattern synonyms.
&gt;Avoid "success at all costs" I'd much rather end up with an expressive logic that can be optimized, rather than focus on optimization first and wind up with terrible kludge with many compromised corners and rough edges.
Cool stuff! Some related work is the Kleene Meets Church line of work from Fritz Henglein and his collaborators: [https://di.ku.dk/kmc/](https://di.ku.dk/kmc/)
&gt; because the GHC GC keeps allocating and freeing new arrays every time a single item in the array is updated To be clear, the garbage collector is not responsible for this. It is true, however, that most of our array libraries expose persistent arrays, which are copied on update.
At first glance, there is no reason the compiler shouldn't be able to do that. And in fact, why do we even need linear types? The compiler is smart enough to figure out if a value is only ever used once or not. That's a *sharing analysis*: Answering the question whether a binding is used/called at most once. Compare that to strictness analysis, which asks if a value is used at least once. Both are part of the demand analyser. You can find out more about usage analysis in [the cardinality analysis paper](https://www.microsoft.com/en-us/research/wp-content/uploads/2014/01/cardinality-popl14.pdf). So: GHC already knows about these annotations. I see linear types mostly as a way for the *programmer* to guarantee/assert that certain optimizations can fire. Judging from the amount of information available, a program that type checks with linear types has as much optimization opportunities as the same program types without linear types: Any used-once information should be found out by GHC by employing above analyses. Why are linear types all the rage then? Because as with `ST`, we can provide safe abstractions over unsafe stuff like mutability. That's were the speedup comes from: Not from linear types suddenly speeding up our Prelude, but because it's now safe to do (read: internally use) mutation without `runST`/monads.
I think [haskell-src-exts-prisms](https://hackage.haskell.org/package/haskell-src-exts-prisms-1.18.2.0/docs/Language-Haskell-Exts-Prisms.html) would be the idiomatic way. You can see some examples of expressions using these prisms in the examples for [refactorio](https://github.com/SuperpowersCorp/refactorio).
You are welcome! Bear in mind that the nginx dir in my repo is not the whole configuration. I include those files in my `/etc/nginx/nginx.conf`. I can't include the whole thing in my repo because there are also a few other rules used for other projects. I will explain how I use nginx on next week's post.
I commission a open letter from SPJ entitled "Avoid seriousness at all costs. Haskell, an history on silly things"
Yes, I don't claim that *regular expressions as types* is a novel idea. There's even a *regular expressions as* ***linear*** *types* paper. Though I haven't seen anyone explicitly claiming (which I don't do explicitly in the talk or the notes either), that linear implication -o in NCILL(L) internalizes \le relation on regular expressions.
*Custom build State Monad* I am trying to come up with an implementation of State Monad. Here I what I came up with: *First deriving the concept of Monad:* `data Maybe' a = Nothing' | Just' a deriving Show` `sqrt' :: (Floating a, Ord a) =&gt; a -&gt; Maybe' a` `sqrt' x = if x &lt; 0 then Nothing' else Just' (sqrt x)` `inv' :: (Floating a, Ord a) =&gt; a -&gt; Maybe' a` `inv' x = if x == 0 then Nothing' else Just' (1/x)` `log' :: (Floating a, Ord a) =&gt; a -&gt; Maybe' a` `log' x = if x == 0 then Nothing' else Just' (log x)` We can have function that composes these functions as follows: `sqrtInvLog' :: (Floating a, Ord a) =&gt; a -&gt; Maybe' a` `sqrtInvLog' x = case (sqrt' x) of` `Nothing' -&gt; Nothing'` `(Just' y) -&gt; case (inv' y) of` `Nothing' -&gt; Nothing'` `(Just' z) -&gt; log' z` This could be simplified by factoring out the case statement and function application: `fMaybe' :: (Maybe' a) -&gt; (a -&gt; Maybe' b) -&gt; Maybe' b` `fMaybe' Nothing' _ = Nothing'` `fMaybe' (Just' x) f = f x` &amp;#x200B; `-- Applying fMaybe' =&gt;` `sqrtInvLog'' :: (Floating a, Ord a) =&gt; a -&gt; Maybe' a` `sqrtInvLog'' x = (sqrt' x) \`fMaybe'\` (inv') \`fMaybe'\` (log')` &amp;#x200B; `-- now we can generalize the concept to any type, instead of just Maybe' by defining a Monad =&gt;` `class Monad' m where` `bind' :: m a -&gt; (a -&gt; m b) -&gt; m b` `return' :: a -&gt; m a` &amp;#x200B; `instance Monad' Maybe' where` `bind' Nothing' _ = Nothing'` `bind' (Just' x) f = f x` `return' x = Just' x` &amp;#x200B; `-- using Monad sqrtInvLog'' can be written as:` `sqrtInvLog''' :: (Floating a, Ord a) =&gt; a -&gt; Maybe' a` `sqrtInvLog''' x = (sqrt' x) \`bind'\` (inv') \`bind'\` (log')` &amp;#x200B; Trying to apply it to State (a,s) where s is the State: `data ST a s = ST (a,s) deriving Show` `sqrtLogInvST' :: (Floating a, Ord a) =&gt; ST a a -&gt; ST (Maybe' a) a` `sqrtLogInvST' (ST (x,s)) = case (sqrt' x) of` `Nothing' -&gt; ST (Nothing', s)` `(Just' y) -&gt; case (log' y) of` `Nothing' -&gt; ST (Nothing', s+y)` `(Just' z) -&gt; ST (inv' z, s+y+z)` &amp;#x200B; It is not possible to define a monad using the above definition as bind needs to be defined as taking in a single type "m a". &amp;#x200B; Second attempt based on Haskell's definition of State Monad: `newtype State s a = State { runState :: s -&gt; (a, s) }` At first, attempt to define function that is built using composed functions and maintains state: `fex1 :: Int-&gt;State Int Int` `fex1 x = State { runState = \s-&gt;(r,(s+r)) } where r = x \`mod\` 2` &amp;#x200B; `fex2 :: Int-&gt;State Int Int` `fex2 x = State { runState = \s-&gt; (r,s+r)} where r = x * 5` Composed function: `fex3 x = (runState (fex2 y)) st where (st, y) = (runState (fex1 x)) 0` &amp;#x200B; But even the definition: `newtype State s a = State { runState :: s -&gt; (a, s) }` does not fit the pattern of m a -&gt; (a -&gt; m b) -&gt; m b One attempt to do this was: `instance Monad' (State s) where` `bind' st f = undefined` `return' x = State { runState = \s -&gt; (a,s) }` bind' is undefined above becuase I did not know how I would implement it. &amp;#x200B; I could derive why monads are useful and apply it the first example (Maybe') but cannot seem to apply it to State. It will be useful to understand how I could derive the State Moand using concepts defined above.
Yes; `CC.length` will do a full scan, but it's done in a streaming manner. The implementation is not ideal, it's something I quickly threw together. Will be updating the repo with better solutions when I find time.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [ekmett/dsl2011/.../**TrainTrack.hs** (master → 8664dc8)](https://github.com/ekmett/dsl2011/blob/8664dc87b6897a6bb46904ab8d83bd7257bb44ea/TrainTrack.hs) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e668imk.)
&gt; why is everyone seemingly more concerned with the somewhat contrived examples that linear types help us express (the examples I've seen really aren't that interesting) compared to speeding up Haskell by a factor of n? Because we don't yet know how to even try to hook them in meaningfully to our garbage collector with them implemented like this? This leaves only the "contrived" examples as the ones that currently make sense at all.
http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html -- The last example is a limited State monad.
i think Idris does this.
i think Idris does this.
I'm approving this post, but please be nice. 
There are three "major" performance losses incurred by using ST: - CPR is much worse for nested types, but ST is a newtype that vanishes early - the extra state token parameter could end up as extra closure allocations, state hack handles this - Overly strict sequencing which is just build into monads Linear types also can be used to pass mutable arrays around as pure types. You need some cps to make the api work out, though.
Even the pure vectors in the vector library do this optimization, no ST in sight (for the users). Look at the rewrite rules around Data.Vector.Generic.New for details. The linear api could do inplace updates for mutable vectors and avoid iterator invalidation so streaming lvalue mutable vectors is safe.
I don't _quite_ get `forall`. I thought I did, but then I thought some more and now I don't. After re-reading [this](https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types) I'm fine with: ``` id :: a -&gt; a id :: forall a . a -&gt; a ``` And I'm also okay with: ``` map :: forall a b. (a -&gt; b) -&gt; [a] -&gt; [b] ``` In both those cases it makes sense that you don't have to _assume_ anything about the type variables, and I'm happy with that. I got myself confused when I wrote this: ``` weird :: Show a =&gt; a weird = 'x' ``` And get: ``` • Couldn't match expected type ‘a’ with actual type ‘Char’ ‘a’ is a rigid type variable bound by the type signature for: weird :: forall a. Show a =&gt; a ``` My brain tells me _this should be fine_ because we're *not* assuming anything: I know `weird` is (by definition) `'x'`, and I know I can `show 'x'`. So why `Couldn't match`? Even more frustratingly this is accepted: ``` weird :: Show Char =&gt; Char weird = 'x' ``` And so is this: ``` data ShowBox = forall a . Show a =&gt; ShowBox a weird' :: ShowBox weird' = ShowBox 'x' ``` Could anyone spare any intuition?
&gt; So: GHC already knows about these annotations. I see linear types mostly as a way for the *programmer* to guarantee/assert that certain optimizations can fire. Judging from the amount of information available, a program that type checks with linear types has as much optimization opportunities as the same program types without linear types: Any used-once information should be found out by GHC by employing above analyses. That answers my question. Thank you! So, to repeat what you said: in order to type-check linear arrows in the first place, GHC needs to know how many times a variable is used. Otherwise GHC can't throw an error when a linear arrow is used and the argument in question is used not exactly once. So linear types don't enable optimizations. It enables added expressiveness, which is why people focus on that rather than optimizations.
Not sure this brings much constructive to the sub.
I feel bringing light on this topic is important. The Haskell Book is, imo, the most pedagogical and well-written book for Haskell beginners, and we shouldn't act like blind consumer of this work. There are real people behind it and it matters that we keep that in mind
Note that step **2** in general requires another buffer of the same size. If you start writing to the original copy in-place, you may overwrite elements that haven't been read yet. You also need to make sure that `f` fully evaluates its argument. But two buffers are enough, regardless of the number of times you apply `f`, so it's still an optimization.
&gt; There are real people behind it and it matters that we keep that in mind Some of us are very much aware of this since the authors decided to back a conference which invited a nazi as a speaker. They stayed on board even when other co-sponsors who were avowed white supremacists started keeping a list of "SJWs" to harass, and the conference still didn't have any issue with it.
Yeah, this happens because ghc is forced to pick a' too early. With ImpredicativeTypes you can write this down without the newtype wrapper {-# LANGUAGE ImpredicativeTypes #-} ... switchM :: forall a b m. Monad m =&gt; Process m a (b, Maybe (forall a'. Process m a' b)) -&gt; Process m a b switchM w = MProc $ stepProcess w &gt;=&gt; \(b, w') -&gt; case b of (_, Just w'') -&gt; stepProcess w'' undefined (r, _) -&gt; return (r, switchM w') But it's probably better to go with the newtype because I don't know how well ImpredicativePolymorphism works yet.
Are you looking for http://hackage.haskell.org/package/indexed-0.1.3/docs/Control-Monad-Indexed.html?
I believe /u/LeHaskellUser is referring to LambdaConf which is a topic that was recently discussed in https://www.reddit.com/r/haskell/comments/7vgpjp/bigotry_and_its_amplifiers_a_response_to/
Fist of all: `'x' :: Char` without exception. That's syntax for a character. Then let's assume you intended to write `"x"`. You expect that something of type `String` or with `OverloadedStrings` of type `IsString a =&gt; a` can be unified with `Show a =&gt; a`. This is simply not the case and I don't know why it should be. * `Show a =&gt; a` and `String` * `Show a =&gt; a` and `IsString a =&gt; a` There surely are instances that be both but there are also a lot that don't. Otherwise it has to work *for all* (pun intended).
You can write code blocks by indenting it 4 spaces.
&gt; The authors of the paper propose an array API that benefits from the optimization you describe; it's explicitly part of the motivation for the work. I'm aware of this API, but -- as far as I can see -- given that we know a function uses its argument exactly once, GHC can optimize repeated applications of these functions without any special API. &gt; If youre looking for the compiler to turn arbitrary library code into something that uses in-place updates, that sounds like magic. I'm not talking about arbitrary code. I'm talking about composition of linear functions, e.g. given `insert :: Key -&gt; a -&gt; IntMap a -o IntMap a`, the expression `foldr (\int map -&gt; insert int int map) Data.Vector.empty [1..1000000]` shouldn't need to allocate a new `IntMap` 1000000 times (every time a value is inserted). If we allocate a `Data.IntMap.empty` specifically for this fold, we know we can safely do a sequence of in-place `insert`s on that `IntMap`, since `insert` guarantees to only consume the `IntMap` once.
&gt; agitators TIL reminding people of documented facts is agitation &gt; professional agitators Yes. I'm getting paid by (((George Soros)))... ¬_¬
Yeah, and because they can encode the necessary pre-conditions in linear types that enable them to use `unsafePerformIO` under the hood without the user ever noticing. It's not about teaching the compiler how to count identifier occurrences, it's about extending the type language in a way that allows the compiler to check if the pre-conditions we want to encode are satisfied. 
paid some protection but you will not stop unitil LC end in the hands of your capos. It seems that your capos see Haskell as an strategic asset, since traffic of white slaves, arms, porn, drugs finances etc is already taken over.
Unhinged to the highest level. Hope you get banned for your antisemitic rant.
I think it’s not likely to be constructive. Without the full facts from all parties we are unlikely to have any real clarity. Likewise one party engaging a lawyer is not a signal of who is at right. Merely of an irreconcilable disagreement 
Not guilty, just mentally impoverished time and time again. I bought a paper version of RWH when it first came out, and ever since then it's been like learning Lisp but worse; everyday languages are gun-to-the-head. I consider myself lucky to be an Erlang/Elixir hacker by day, I will never do PHP again that's for sure! I quote that noble and learned bard Paul Weller on this matter: &gt;I've got a pen in my pocket does that make me a writer Standing on the mountain doesn't make me no higher Putting on gloves don't make you a fighter And all the study in the world Doesn't make it science So...if you wanna be a Haskeller, write some code again and again and again. You won't and don't regret it. Since I started I have learned so much more about maths and sets (meths?) and generally improved my game in all areas of coding hackery.
Thank you! It's actually not a library but an application, but still the code I write will probably be subpar.
&gt; I think it should be possible to create a subuniverse of types which are guaranteed to only be used linearly. Isn't this what the [Linear Haskell-paper](https://arxiv.org/pdf/1710.09756.pdf) refers to as "linearity via kinds" (as opposed to "via arrows")? If so, what is your opinion on the section **6.1 Linearity via arrows vs. linearity via kinds** of the paper, in which the authors argue that "*“linearity via arrows” has an edge over “linearity via kinds”*"?
I'm curious, though: is *sharing analysis* a part of current GHC and, if so, why doesn't GHC use this information to reduce allocations[1] (through in-place updating of values that are only used once)? [1] according to [this old reddit post](https://www.reddit.com/r/haskell/comments/24ec7h/can_ghc_do_puritytomutability_rewriting/)
So that is antisemitic ? why?
The cardinality paper lists two motivations for doing usage analysis (subsumes sharing analysis): 1. Identification of one-shot lambdas, e.g. lambdas that are executed at most once relative to a single evaluation of their binding site. 2. Identification of single-entry thunks While 1) is more like an enabling factor for further optimizations, 2) has immediate operational consequences: There is no need to memoize the result of evaluating the thunk, so GHC doesn't need to push an update frame in its STG model and doesn't need to allocate space on the heap for the result. You might also like page 2 of Simon Marlow's "Update Avoidance Analysis by Abstract Interperatation" (only could find a PostScript of this, sorry). It's possible, in theory, to exploit this information further by re-using heap space. But this turns immutable data structures into mutable ones, which means more work for the generational GC, which must consider all mutable references into account (because they allow pointer from old to new generations). Also, it's not entirely clear to me when that would actually yield a benefit. I think I read somewhere that wasn't really beneficial, but have nothing to quote on that. Also, GHC is mostly smart enough to figure out the "obvious". For example: let r = R { a = "foo", b = "bar" } r2 = r { b = y } in b r2 GHC would never allocate a space for `r`. Not even for `r2`, for that matter: It would just simplify this to `y`. There is no need for in-place update when the old record isn't even used! Even if the let body was `b r2 ++ a r` it wouldn't allocate any record. So the old reddit post asks the wrong question: Instead of asking if GHC supports in-place update (it doesn't), it should rather ask the question of what gets allocated for a specific example. Your original use case was about array update. But for arrays, one of the builtin rewrite RULEs should fire (granted, brittle). For the cases where arrays are actually copied, maybe GHC/`array` could be smarter. But it's hard to tell without an example, really.
what is the tldr? since I would like to buy this book as someone trying to learn haskell seriously. 
It was not even subtle about it. Don't pretend.
No, this actually isn't linearity-via-kinds. It is a way to sort of "recover" the conveniences of linearity via kinds but built _on top_ of linearity-via-arrows. Since linear-via-arrows functions can be lmapped over "linear values" then we still get all the conveniences of code reuse described in section 6.1. What I'm suggesting should be seen more as a certain type of generalization of 2.7. (Incidentally, I disagree with the article's description that "there is no such thing as a linear proposition". In fact, considered modally, there sort of is. The "linearity monad" paper I link sort of captures this. Though in the usual setup what you have is a class of propositions that are "nonlinear" [i.e. the subuniverse for which `x ~= !x`] and nonlinear logic is recovered by "localizing" at this equality.). 
&gt; I think the compiler should be able to turn linear record updates into in-place updates automatically. Record updates in a lazy language are not *that* inefficient, because you can simply copy pointers (and so you do not need to copy a whole string, for instance). I'm not sure if it does in-place mutation for records but it would certainly be nice.
Great post. I was curious to play with it, but I am not sure how. It's probably a trivial thing, as I am not quite up-to-date with the haskell build ecosystem. So I naively : - launched a nix-shell, which builds a shell with ghc from the current state of my Nixpkgs, yielding a ghc 8.4.3 - from the /nix/store, and cabal (cabal-install version 2.0.0.1, compiled using version 2.0.1.1 of the Cabal library) - Then "cabal update, cabal new-build" builds many libraries successfully, but then fail at `hedis-0.9.12` Is there an easy fix, or would it require to publish some Nix User Repository entry ?
I prefer to think of it as "a rough draft" rather than "subpar" :)
wow that's very informative thank you. I'm really unsure as to why you've not had the opportunity to work in it full time!! Sounds like you should have a breadth of knowledge. The production experience of Haskell I've had was Yesod and it's all pretty intuitive. Think the number of job opportunities in Haskell would surprise a lot of people. In my narrowed search of Haskell/PureScript/remote I've touched base with over 30 companies. Had from straight no's to interviews, to tech tests. The stars haven't aligned as of yet. The point being that's quite a lot for a niche language. I'd argue that from speaking to all these people they can accommodate for junior/mid a lot easier onsite which is totally understandable, but also very positive sign for us remote folk because there is a slight market need but it's not there just yet. I'm now personally searching for places that are open to functional programming as mentioned above that will most likely be a better way into doing Haskell full time vs going for outright Haskell jobs due to lacking in knowledge not enthusiasm :) But feel free to PM me if you are looking, I should probably become a recruiter at this rate!!!
I'm intrigued by [algebra](http://hackage.haskell.org/package/algebra) and [numeric-prelude](http://hackage.haskell.org/package/numeric-prelude) (the ubiquitious use of `T` and `C` in this package does not bother me at all). What are the chances that the algebraic and numeric towers get the full treatment in a future Report?
This is amazing! Great work, just tried it out and works really well, maybe I'd add in the documentation something for the people who doesn't use the built-in vim package manager, where it's just a matter of \`Plug 'Fyrbll/intero-vim'\`
&gt; Record updates in a lazy language are not that inefficient, because you can simply copy pointers Well, that's still 15 copies for a 16-field record, which we can avoid with as in-place update.
Lawyers handled disagreement about what to do moving forward. There is, as far as I know, no dispute about what *happened*. The book hasn't been published because the person whose job it was didn't want to do so until he could have all the profit. People who work in the same industry as bitemyapp can benefit from being aware of this.
&gt; People who work in the same industry as bitemyapp, and might potentially consider working with him in the future, benefit from being aware of this. I wonder if such people like u/snoyberg would have reconsidered employing u/bitemyapp when provided this knowledge
I'm not pretending anything. I asked because as a moderator it is my duty to investigate reports, and antisemitism is a serious accusation which should be handled carefully, including asking you why you think the comment was antisemitic in the first place. I looked up "capo" (**not** "kapo"), and it's apparently the head of a mafia organisation (from "captain"?), which ties in with the rest of the rant where a mafia was mentioned. But yes, this doesn't belong on the subreddit, which is why I have deleted the comments. And neither do your retorts, I'd wager. And since the two of you jousting seems to be the overwhelming majority of discourse on this thread, perhaps it was a mistake to approve it... /u/fsharper and /u/LeHaskellUser: you are both well on your way to receiving an official warning, if you continue with this disruptive behaviour. Please stop.
Anti-semitic, anti-italian, anti-whatever. If it is not anti-mutation or anti-stringly-typed-programming then it doesn't belong on this subreddit. I have deleted your unconstructive and disruptive comments. I'd suggest you don't post anymore until you have some view or position worth entertaining, and moreover **relevant to this community's purpose**. 
the details on the tweets are pretty vague, and my experience has always been theres more going on in a business conflict than any one person's story. Unless other folks can see tweets that aren't visible to me. (either way a set of twitter posts can't be considered an authoritative summary for posterity...) Any business (or non business) partnership benefits from having explicitly articulated termination agreements around work products and or money. I dont know what agreements were made in this case and/or what the applicable case law is. 
I'm also pro mutation is some cases and pro-stringly-typed-programming in some other cases too ;). But I like composability. that is not incompatible with mutation even if this destroy the commutative property. There are non-commutative algebras. Thanks moderator for your equanimity. And for the rest of you: You had an opportunity to think about what's going on. Thanks for reading. At last this is the Western world where everyone has freedom of speech no? hahaha.
The simple solution here is to use `ghc-8.2.2` to compile the program. However, I wouldn't encourage too many people to run this exact program as I don't want to stress the servers too much where the maps are hosted.
While I might not have "*relevant knowledge*" either, I feel that little good can come from this kind of public exposition. I strongly vote for closing this thread, especially if it might lead to public shaming.
Definitely will give it a try 
Hey! Haskell is the best language for mutation and stringly-typed code, too! Let's be inclusive. ;)
Ah, I like this outside/inside distinction, perhaps that is a more useful mental model than thinking about what you may \_assume\_ about a variable. Thanks.
The reason you don't need to write `forall` implicitly for parametrically polymorphic functions like `id :: a -&gt; a` lies in the way Haskell separates namespaces. Specifically, type variables are always lower-case. Assume this was not the case, and you could write id :: A -&gt; A Okay, to you it may be clear that 'A' denotes a type variable. But what if I were to define data A = A somewhere? You see the problem. If we were to allow upper-case type variables, we would need to be able to say "this is a free variable" (i.e. it stands for some type that has been defined somewhere else), or "this is a variable *bound* to the name `A`". And you would then need to bind the variable by some quantifier, in this case the `forall` quantifier. This parallels the situation at the expression level: fun x y = 2 * x + y + c, or rather fun = \x -&gt; \y -&gt; 2 * x + y + c, where the variables `x` and `y` are bound by a lambda-abstraction, and you say that `c` "occurs freely". And then there is the arguably abusive way we use `forall` in different contexts as well. I say abusive, since it is kind of confusing, even if technically correct in the sense of intuitionistic logic. Anyhow, consider the following types: data F = forall a. (Foldable f, Integral a) =&gt; F (f a) (f a) newtype G = G (forall a. Num a =&gt; a -&gt; a -&gt; a) `F` uses existential quantification, while `G` requires the `-XRankNTypes` extention. The types of the constructors are F :: (Foldable f, Integral a) =&gt; f a -&gt; f a -&gt; F G :: (forall a. Num a =&gt; a -&gt; a -&gt; a) -&gt; G In particular, the `forall` does *not* occur right after the `::`. Now we know the following things about `F` and `G`. For `F`, we need to supply two things of the same type, subject to some typeclass constraint. It can be `[1..5]` or `Right 42` or `Nothing`, doesn't matter. Note that when you construct an `F`, you will have to supply *concrete types*. The reason is that there are no `Foldable` methods that have a `Foldable f =&gt; f a` occuring in covariant (result) position. You construct the `F` type and the type information has been "forgotton". You only know what you can do with it, but you may never, ever, assume some concrete type anymore - that's where the weird errors about skolems come from. Contrary, when you have a "rank-n-function", you have some input (usually you have a higher-order function) at which you want to shout "STAY POLYMORPHIC!". Because this is what this extension does. You may construct a `G` value with (+) :: Num a =&gt; a -&gt; a -&gt; a, but not with (+) :: Int -&gt; Int -&gt; Int. This allows you to use the function in different type concrete types, for instance useTwice :: G -&gt; (Int, Double) useTwice (G f) = (f 1 2, f 3 4) Getting something out of `F` is harder. When we get an `F` as argument, we can only really try to do something with the typeclass methods - which by the way is the reason we can't use `newtype` with existential types, since the typeclass dictionary has to be carried around as well. I chose `Integral`, since we can use toInteger :: Integral a =&gt; a -&gt; Integer. So even though we don't know "what kind of integrals" we are working with, we know we can make an `Integer` out of it, the type of which is indeed allowed to show up at the top-level, without weird errors about "variables escaping their scope". For example: consume :: F -&gt; G -&gt; Integer consume (F f1 f2) (G (#)) = (toInteger . sum $ f1) # (toInteger . sum $ f2)
Dude, as someone who is also learning, this was awesome! Thanks for writing it up and sharing.
Trying to use a custom .hsfiles on windows, but Windows refuses to save it under .hsfiles and stack refuses to accept a .txt file. Any solution?
I think I used that model mentally in some of my math classes involving proofs, as an analogy between a proof and an *very formal* argument / discussion. Turns out, where the choice is made / who makes the choice is also part of a [mode for linear logic](https://en.wikipedia.org/wiki/Linear_logic#The_resource_interpretation) which we'll get when the linear arrow is added to GHC. (NB: My understanding is that most approaches to linear logic are linearity-as-kind while GHC is implementing linearity-as-an-arrow; but I also hear they are intra-convertible.)
[Use Linux?](http://dilbert.com/strip/1995-06-24) ;)
What do you mean by "windows refuses to save it under .hsfiles"? How are you trying to save it? You might be running into [a problem like this](https://superuser.com/questions/64471/create-rename-a-file-folder-that-begins-with-a-dot-in-windows) where you just have to create the file with a different tool that isn't artificially limited, then stack will be able to use it.
You might enjoy [The Essence of Functional Programming](https://page.mi.fu-berlin.de/scravy/realworldhaskell/materialien/the-essence-of-functional-programming.pdf) paper by Philip Wadler.
Thank you
Yes, `IMonoidal` is not a superclass of `IMonad`. I believe this is related to the fact that `IMonad` instances are not generally strong, meaning you don't have `strength :: (p :*: m q) :-&gt; m (p :*: q)` except in trivial cases where `m` never changes its index. Note that `iprod` needs to combine two operations with the same index (i.e., they "start" from the same place). In contrast, `iextend` can only put one operation after another (i.e., the second starts where the first left off).
I actually bought the book I saw recommended in this sub, Manning - Get programming with Haskell. Maybe I should read that cover to cover first.
Thank you! Can I be checked my understanding? Usual Functor is already strong, so being Monad implies being Applicative. Not every endofunctor are automatically strong. I reminded a phrase "applicative functor = lax monoidal functor with tensorial strength" although I understand that only as a Haskell analogy but not as a category theory. Applicative also should require strength? Also, [I drew Applicative and Monad hierarchy based on current understanding](https://i.imgur.com/mY2S6KN.jpg). This Applicative is Monoidal + StrongFunctor + (laws to relate Monoidal and StrongFunctor).
It's been my experience that it's not uncommon that one side in a business conflict is mostly or entirely full of shit. There's no shortage of people who will attempt to take advantage of another, given an opportunity where they think they can do so.
What do you mean by a full scan in a streaming manner ?
/u/dfordivam talked with me a while ago on twitter on the code size problem. Asterius uses trampolining as well but doesn't suffer from huge wasm binaries, and most probably it's due to limited LTO capabilities of lld for wasm right now.
Yea, it's not impossible to workaround these issues with trampolines, we just haven't done it yet :P
You mean llvm-ng backend which emits bitcode? IIRC it's still not merged so probably has its own quirks to be ironed out before switching? Also re DCE for trampolined code, asterius does not strip dead code, instead it discovers live code via whole-program traversals. So I guess it's just a matter of granularity in the end..
So (among other things, iguess) the cardinality of a function indicates how many ways of implementing it exist? Never having dealt with this topic before it seems that the intuition of counting possible values of a given type does not translate well to how many 'mappings' a function can have. 
I am very happy that you eventually discovered that, like, State Int is the monad, not State itself. It takes a while to see that monads are each a sort of *adjective* that modifies a “type noun” into another “type noun,” so Maybe is “a nullable ____,” List is “zero or more _____s,” the tuple (Int,) is “an Int and a _____,” the sum type Either String is “either a failure with a String description or a success with a _____,” the reader monad (Config -&gt;) is “a _______ which comes from some Config,” and finally IO is “a computer program which returns a _____.” Given a monadic adjective “blue” you can do three things to it. First it is trivial or maybe you would prefer the term universal: so this means you can paint the world with it. I give you a function from lists of ints to strings, you can give me a *blue* function back. I give you a GameState, without digging inside it you can describe it as a nullable GameState (it happens to not be null), zero or more GameStates (just one, this one), a program which produces a GameState (it has a no-op interaction with the world before it returns the GameState). This is the subject of `return` also called `pure` in Haskell. Second it is *outputtish*, or you might say mappable, so there is a way to take functions and apply them over whatever is described. There are four functions that take a bus and return a wheel, `frontLeft`, `frontRight`, `backLeft`, `backRight`. Given a *blue* bus you need to be able to use this to give me a *blue* wheel. So given a program which produces a bus, and one of these functions that extracts a wheel from that bus, give me a program which returns a wheel. Or given zero or more buses, you can give me zero or more wheels with this. We call this mapping a function f by the name `fmap f`. And if you want to get creative and say “haha I will just return zero wheels, zero for all mappings!” or something that's ok but we do ask that it play nicely with `pure` above: if I apply `fmap f . pure`, so I map the function over something that I just trivially tacked on the adjective to, then that is the same as `pure . f`, doing the function directly first and then trivially embedding the output. So maybe with two buses you can nefariously return zero wheels, but with one bus please return one wheel. A given adjective might have more than one way that it is a monad, the language forces us to pick one. This is easiest to see for (Int, ) where `pure x` could give back either (1, x) or (0, x) and the following step could multiply or sum the ints respectively. Third, it *doesn't mean much to repeat it.* Like there is some technical distinction between a blue bus and a *blue* blue bus, but in practice we just want to reduce everything to one use of adjective: there has to be a way to do this. So given “zero or more (zero or more ints),” that doesn't *really* say much more than just “zero or more ints”. There is a function `concat` which merges the list of lists together into one list. Similarly given “a program which produces (a program which produces coffee)” you're going to be like “please make my life easier, please just give me a program which produces coffee. It should run the program-producing-a-program and when that produces the program-producing-coffee it should *immediately* run that output program, too, and produce me my damn coffee.” This is an operation called `join` and it has to play nice with the other two operations. The first one is, using the mapping, there's technically two ways to turn a blue-blue-blue bus into a blue bus. If you apply join directly, you merge the first two blues first. If you use `fmap join` you merge the second two blues first. And you want this to be associative so that it doesn't matter which way you merge them, they just always merge together to one. It is not hard to see that for lists, map and concat do this, because when you print a list, concat does not affect the order of the elements printed, it just erases some of the left and right braces. So if you print a list of lists of lists, two concats done either way first gives the same result. And how join plays nice with pure is also pretty straightforward, if you had something that was already blue, and you accidentally fed it to pure to make it blue-blue, you should be able to use join to undo your mistake. It doesn't have to go the other way, once you destroy the internal structure of a list of lists with concat, pure doesn't have to recreate that internal structure. Another good way to understand a monad, is to understand the Kleisli arrows for that monad, which are the functions `a -&gt; m b`. They form a category, which is basically a monoid where the type system prevents you from combining two functions if the one's output variable doesn't match the other's input variable. So being able to see why that operation is associative, is the same as seeing why join is associative. Trying to find the unit element of the monoid is trying to find pure. And once you have pure, you can tack it onto any ordinary function to make a Kleisli arrow and this bring it into the algebra to be used in mapping. So if you can understand why these arrows form a category, then you understand the monad in full. 
Thank you for the large effort! Focusing on how IApplicative instance should be for Vec/Path sounded very good for me. Noticed point: What can we do with `IMonad` instance for `Vec`? iextend :: (Succ a :-&gt; Path (Succ b)) -&gt; (Path (Succ a) :-&gt; Path (Succ b)) -- What can we do with this? Passed Kleisli arrow can't change "length" of -- (Succ a (n, S n)), so only way to construct (Path (Succ b)) is mapping -- some function (a -&gt; b) and construct singleton Vec. -- So this can't do much more than `imap`. iextend :: (Succ a :-&gt; Path x) -&gt; (Path (Succ a) :-&gt; Path x) -- What about using (x :: (Nat, Nat) -&gt; *) other than (Succ a)? -- This also can't change the "length". But for example x (n, S n) ~ V.Vec 5 a, -- Number of element, not the "length" represented by the type index, -- increases to n * 5. -- Converting Path x (n,len+n) into Path (Succ a) (n, len*5+n) cannot be done -- using IMonad interface. IApplicative class for length-changing functions is **not** a superclass of IMonad. I speculate that there can be plenty of Applicative-like structures defined on `(k -&gt; *) -&gt; (k -&gt; *)`\-kinded type constructors, but only one of them is compatible with `IMonad` and others are not related to *this* `IMonad`. I don't know whether the one compatible with `IMonad` (or `IStrongMonad`, as said in the other reply) will be useful.
Yes. For Vec, we'd need something like: ibind :: (a -&gt; Vec b m) -&gt; (Vec a n -&gt; Vec b (n * m)) if one stares at that long enough, one can see type ~&gt;m = forall n. 1 * n -&gt; m * n there. I'm too tired to make GHC believe me (and/or plug it into Conor's framework). FWIW, I know from practical experience that `indexed` approach works, requires only quite conservative extensions (if any?), and is enough to describe open/closed file example as in the paper. So, I'm not sure what's your goal: - If you are interested in using indexed functors in practice in Haskell, try `indexed` - If you try to understand CT stuff, forget Haskell for a moment and work examples out on paper. Starting with why `Monad` is a subclass of `Applicative` in Haskell, but not in general. They say you have to unlearn some Object-Oriented ways of thinking to do FP; I continue that you have to unlearn some Haskell ways of thinking to do CT.
&gt; the two of you jousting (...) you are both well on your way to receiving an official warning, I have only stated facts and have been attacked with dog-whistles and outright antisemitism but I am somehow put on the same level as the person who attacked me and threatened to get the same treatment as them? This is senseless. Get better at your job.
Yesod is more like a conservative MVC framework (but with batteries included - you'll find it easy to add sessions, database support is readily set up, ...) Servant uses sophisticated type level programming and let's you use types to describe your routes and then use those types to even generate documentation or even client-side code for you. It's not as mature as Yesod though (link generation, session support and adding your own monad-stack is all possible but it's a bit tricky to set up sometimes) For a SPA I would go with Servant but it's a bit harder to get into, so if this get's to fancy for you Yesod is a very fine framework.
No I just meant the regular LLVM backend but that'd be cool too. Yea that's why I mentioned LTO; discover live code at link time and DCE the rest.
It’s definitely worth adding more details about your goals. Is this a web app for a production site? Do you plan to add team members new to Haskell to the team? Are you just curious about Haskell’s capabilities? How do you feel about JWT for authentication?
Inasmuch as monads are a context on actions -- they don't do much unless you're evaluating some function after all -- perhaps they're best described as more analogous to adverbs? I suppose translating to spoken grammar concepts is going to be imprecise no matter what though.
&gt; I’m used to just diving into a OOP/C based language, learning the syntax in a few hours, and just building something. I haven’t felt this hazy gap where I don’t know what direction to head since I started to learn to program, and I feel it now with Haskell. This is normal. From a big-picture point of view, all the OOP languages are essentially the same thing, give or take syntax and some minor details - of course you can pick up more of the same in a matter of days. Haskell however is radically different, so naturally you need to learn a lot of concepts from scratch, and it can feel overwhelming at times. But it gets better, I promise. It just takes longer - a few months, maybe even years.
It’s hard to find a Haskell opportunity at all, outside of UK and US. What I am digging into is to form an LLC, because even in the mainstream languages like Java, I feel that my skills are being underused.
Yes, endofunctors over indexed types and index-preserving functions are a great example of non-strong functors. If you have a strong monad, you can define an operation with the appropriate type for your `iprod`, but I haven't checked whether it satisfies the appropriate laws. There are a bunch of different categorical definitions for `Applicative`, and I'm not sure whether they are all the same in all categories. There's a good definition in "Notions of computations as Monoids" by Rivas and Jaskelioff, but it took me a while to grasp it.
Yep, that’s why I formed my LLC in the first place. Lots of freedom, but lots and lots and lots more work.
The problem is that this isn't how folding works. foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b For starters, the function you give to `foldr` takes 2 parameters. Your `line` takes one. Secondly, `foldr` itself takes 3 parameters, you gave it 2. The way folding works is that you provide some initial value and a function that says how that initial value changes as you go through the elements of the list. For example, if I wanted to sum up all the elements in a list, I would write `foldr (\elementOfTheList currentSum -&gt; elementOfTheList + currentSum) 0 [1,2,3,4]`. Here I'm saying that the initial sum is zero (this is the result I'd get if the list was empty). My function describes how that sum changes as I go through the elements of the list. In this case, they just get added on to the current sum.
Yeah. Haskell is a statically typed language so you just need to read the types to know how to apply a function.
You can implement O(1) field access, provided that you either never need to mutate the record, or that you mutate the record in-place (which, obviously, means that reads and writes must be in IO or ST). This is done by using an array as the backing store.
Can this be solved today by generating the conversions at compile-time?
There's also `foldr1` if you just want to use the first value of the list as your initial value.
What is their to improve here? You will need to include the GHC RTS anyway. If you are that constrained, Rust is likely a better option.
That would cause problems for the Haskell server ecosystem. Haskell servers use async exceptions to prevent denial of service attacks.
Also note that *many* of the things that make GHC-generated code fast don't work in the browser. This mostly impacts lazyness, IIRC. I suspect that a strict variant of Haskell would be much, much easier to compile.
Which features are you referring to?
What about specifying that evaluation order is unspecified?
So far the comments haven't been bad and personally I was wondering what the status of the book was since if has been in a nearly finished state for a long time. It is nice to know what it going on even if the details are vauge.
What about it? Specifically, how do you think that's different from non-strict semantics of Haskell.
but both sides /s
fwiw, hopefully it'll be published soon, since (anecdotally) it has been just straight up the best book for learning haskell.
For internal API service with a web GUI in front, I'd definitely go with Servant. If you want authentication because the application is directly on the Internet, you may need some good-old server-generated HTML/CSS for infrequent support pages =&gt; I'd go with Yesod. Also, don't forget that you can actually serve both apps on the same binary quite easily using `wai` routes.
Haskell is a mind bending way of development when you first start. My advice is to build something substantial. How else will you get really good, if you don't? I built [hnes](https://github.com/dbousamra/hnes) as my first non trivial Haskell program. It took me ~6 months, but I now feel very comfortable with Haskell. I have tonnes of ideas of similar scope if you want 
Sounds to me like the programmer would suffer all the disadvantages of both but couldn't count on the advantages of either. A bit of a worst of all possible worlds scenario.
A few `DataKinds` question: ``` {-# LANGUAGE DataKinds #-} data Tove = Brilig mimsy :: Brilig -&gt; Brilig mimsy = id mimsy' :: Proxy Brilig -&gt; Proxy Brilig mimsy' = id ``` The signature for `mimsy` is invalid because: ``` Expected a type, but ‘Brilig’ has kind ‘Tove’ ``` 1. I assume here that `type` means the same as _something whose kind is just `*`s and `-&gt;`s? 2. Is it ever valid for function's type signature to not 'end up as' just `*`s and `-&gt;`s? I was sort of hoping, but a bit surprised to see that the signature for `mimsy'` is okay. Or at least I was until I did `:kind Proxy` in GHCI and got `Proxy :: k -&gt; *`, so: 3. Does the `k` mean 'any kind'?
I dropped it when I realized ghc-mod doesn't support GHC &gt;= 8.2
oh, how do you do that? It was my understanding that the whole plugin relies on it? 
 f :: [Int] -&gt; String f x = "+" ++ foldr g "" x where g x y = replicate x '-' ++ "+" ++ y &amp;#x200B;
Those are my plugins: [https://imgur.com/a/WXR8Tro](https://imgur.com/a/WXR8Tro) Using it with stack and ghc v8.4.3 (resolver: lts-12.9). What was that plugin were you trying to? I actually remember that I had some issues with ghc-mod and some plugin in the past but can't remember any details now.
Thanks a lot! I was trying to go for [atom-haskell](https://atom.io/packages/atom-haskell), and I tried to installed the required binaries, which failed since ghc-mod wouldn't install. I remember when I tried Atom + haskell a few month ago, it had ghcid running too, do you know if it still works? 
Thats how Ive always learned. Read a bit. Do some concrete programming. See how I can expand the programming. Read more. Do more programming. Combine the various ideas. Etc. 
Well, I think you were trying to install plugin [haskell-ghc-mod](https://atom.io/packages/haskell-ghc-mod) which obviously requires ghc-mod. I'm not using it anymore. Don't know anything about ghcid, sorry mate.
I am in the process of doing some experiments using llvm-ng currently (without LTO and trampoling) just to check the code sizes .. so the output will not be a proper wasm exe. But I hit this bug in llvm few weeks back [https://bugs.llvm.org/show\_bug.cgi?id=38866](https://bugs.llvm.org/show_bug.cgi?id=38866) Also the process of linker --gc-sections is essentially live code detection, though it works at the level of sections. It works quite well for x86 binaries when -split-sections is enabled. &amp;#x200B;
Use `haskell-gi` for new projects. The `haskell-gi` packages (`gi-*` on hackage) are generated from the GObject introspection information and are far more complete. Some of the gtk2hs packages (such as the gtk3) package do not include all the functions. Anyone still using the gtk2hs packages should consider porting their projects to `haskell-gi`.
Mah, ok, thanks a lot anyway!
Has it become easier to build haddocks locally? This hasn't really worked for me last time I used it. I think it was `stack haddock` or `stack haddock --open` that kept rebuilding, but failed to produce output. Also build times and executable size may become significant, since basically everything that is gtk will go into the `.text` segment. If you can afford to use something more lightweight like [fltkhs](https://github.com/deech/fltkhs), you should consider it an option.
The advantage would be speed. The compiler would be free to make optimizations like stream fusion that you mentioned, without needing to insert code for lazyness.
```haskell length' [] = 0 length' ('a':xs) = 1 + length' xs length' _ = 0 ```
Thanks for the quick and useful answer! :) 
I'd only believe that advantage would exist if it can be demonstrated. Haskell and GHC can output strict code if it won't violate the non-strict semantics.
&gt;**What is applied category theory?** &gt; &gt;Upon hearing the phrase “applied category theory,” you *might* be thinking either one of two thoughts: &gt; &gt;\#1 *Applied category theory? Isn’t that an oxymoron?* &gt; &gt;\#*2 Applied category theory? What’s the hoopla? Hasn’t category theory always been applied?* &gt; &gt;For those thinking thought #1, I hope to convince you that the answer is *No way*! It’s true that category theory sometimes goes by the name of *general abstract nonsense*, which might incline you to think that category theory is too pie-in-the-sky to have any impact on the “real world.” My hope is that these notes will convince you that that’s *far* from the truth! &gt; &gt;For those thinking thought #2, *yes* it’s true that ideas and results from category theory have found applications in computer science and quantum physics (not to mention pure mathematics itself), but these are not the only applications to which the word *applied* in *applied category theory* is being applied. So what *is* applied category theory? &gt; &gt; *Read on*. &amp;#x200B;
It's a small market currently, so there won't be lots of jobs available for everyone across the spectrum of experience and ability. Having a lot of experience or strong natural talent will always be valued. There are multiple ways to gain a lot of experience - you can build up increasingly complex projects alone, you can find a rare Haskell job for beginners, you can find jobs using functional programming in other languages. If you pursue functional programming in other languages, just be careful to ensure that the engineers really are into using the functional aspects of a given multi-paradigm language. I suspect someone will internalize functional programming fastest by joining a company using another functional language, rather than trying to learn it alone.
Consider implementing filter' :: (a -&gt; Bool) -&gt; [a] -&gt; [a] first, and then try implementing `numAs` in terms of `filter'` and your existing `length'`.
Quite honestly, if none of the money from sales goes to one of the two co-authors, I'd rather recommend another good book (and there are some!) which has less ugliness attached to its backstory.
I don't understand this "duality". &amp;#x200B; If a value is passed to a linear function, the function parameter (bound variable) has to be used exactly one, i.e. in that environment it is unique. Similarly, let's take \`f : A ⊸ (B -&gt; C)\` with the intention of \`B\` being used multiple times by the body. When we partially apply \`f a\`, the returned function can be used exactly once (since it is a closure that when evaluated uses up a linear value). These examples suggest that linear type system already implements uniqueness as described in chapter 6.3 of the proposal. Also I have never seen formal typing rules for uniqueness typing. &amp;#x200B;
why not? I recommend that book to everyone. transparency is good, and it explains (maybe) why it hasn't been "finished" yet.
Can you explain about "(a -&gt; Bool) -&gt; \[a\] -&gt; \[a\]"? Does it mean that filter function takes two parameters?
With a generic function, the type variable is always specified by the *caller*: you can think of a `forall`-quantified variable as an additional argument to a function, which is passed implicitly at the type level by the compiler—but can also be passed explicitly if `{-# LANGUAGE TypeApplications #-}` is enabled. When you write this: weird :: forall a. Show a =&gt; a weird = 'x' You’re promising that if someone calls `weird @Int`, you’ll give them an `Int`—likewise `weird @String` should produce a `String`—but you don’t: you always return a `Char`. When you write this: data ShowBox = forall a. Show a =&gt; ShowBox a Or in GADT syntax: data ShowBox where ShowBox :: forall a. Show a =&gt; a -&gt; ShowBox The caller of `ShowBox` decides which particular type `a` to store in the box. When deconstructing a `ShowBox`, that type `a` is completely opaque—the *only* thing you know about it is that you can call `show` on it, because you’ve also (implicitly) stored a `Show` dictionary in the `ShowBox`, which likewise can *only* be applied to values of that type. This is known as an *existential* type and it’s the kind of polymorphism that people are accustomed to from OOP languages—a vtable in an OOP language is existentially quantified, since an object has some concrete type, but you don’t know which derived class you have if you’re only given a base class or interface pointer—the type is invisible to the user of the object unless they use (unsafe) downcasting. An existential can always be rewritten in terms of *higher-rank* universal types: matchShowBox :: forall r. (forall a. Show a =&gt; a -&gt; r) -&gt; ShowBox -&gt; r matchShowBox k (ShowBox x) = k x Here, `matchShowBox` is a rank-2 polymorphic function, because it takes a rank-1 function as an argument. Examples of ranks: -- rank 0 zero :: Int zero = 0 -- rank 1 id :: forall a. a -&gt; a id x = x -- rank 2 apply :: (forall a. a -&gt; a) -&gt; (Int, String) apply f = (f 0, f "hello") -- This is actually useless because ‘f’ must be the identity function! Anyway, the caller of `matchShowBox` decides the result type `r` of the continuation, but `matchShowBox` is the caller of `k`, so *it* decides the type `a`, and could even call `k` multiple times on different types if it wants, like `apply` does in the example above. So this is saying you *must* pass a function to `matchShowBox` that is generic in `a`—you can’t pass a function of type `Int -&gt; String` for example, because what’s in the `ShowBox` might not be an `Int`. 
Yes, rust comes with predictable memory and a wasm-unknown-unknown compilation target by default. But although I love rust and [have made non-trivial wasm experiments with it](https://www.migniot.com/OthelloRust.html), I'd rather code in Haskell. I've recently heard about [Asterius](https://www.reddit.com/r/haskell/comments/9h3wtz/tweag_io_haskell_webassembly_calling_javascript/) but not tested it yet. In [the same thread](https://www.reddit.com/r/haskell/comments/9h3wtz/comment/e68xqn5), there's a discussion about wasm output size. &gt; If you are that constrained You're right, I'm not - and Rust has been developed specifically for that. I'm just dreaming :)
Funny, just emailed my tax guy today r.e. freelancing and creating an LLC. I was super inspired by [this talk](https://youtu.be/riJuXDIUMA0).
With the new `ArgumentDo` extension in GHC 8.6.1, you can write `() &amp; fix \f a -&gt; a` without any parentheses. You could also use `() &amp; fix (\f a -&gt; a)`, which reduces the nesting by one, or inline the definition of `fix` instead of calling it, using a recursive `let` binding: () &amp; let loop = (\ f a -&gt; a) loop in loop () &amp; let loop a = a in loop 5 &amp; let f x = if x &lt;= 1 then 1 else x * f (x - 1) in f 
&gt; It would be up to the programmer to ensure that this didn't cause problems. How's that working out for other things -- like correct pointer operations in C, or lack of race conditions in Java, etc. The great thing about Haskell and other pure languages is that they generally err on the side of only accepting correct code, trying to move as many runtime errors as possible to compile time.
The intended semantics seem to be more like \`takeWhile :: (a -&gt; Bool) -&gt; \[a\] -&gt; \[a\]\`, but this is a good recommendation—especially for a beginner, but to create good readable &amp; reusable code in Haskell in general, it’s good to break a problem down into smaller, more easily solved subproblems, which can then be composed to solve the larger problem.
I don't quite get what you mean in this context. (Sorry -- ideally I'd rather not extend this subthread further, but it is hard to leave it at that when there is an upvoted comment telling a mod to "Get better at your job (and ban racists on sight ffs)".)
While some languages have interchangeable quotes, this is not true in Haskell. `'a'` (single-quotes) is always a `Char`. It is never a `String` or any other type. `"a"` (double-quotes) is normally a `String` or a `[Char]`, the former being an alias for the later. There's also a language extension available so that `"a"` is a `IsString s =&gt; s` -- if this extension were active *and* a `IsString Char` instance is visible, then `"a"` could be a `Char`, I've never considered that useful behavior. Also /r/haskellquestions is a dedicated forum for these kinds of questions.
Tai-Danae Bradley is one of the best popular maths communicators, and this is classic TDB, a highly accessible introduction to a dense topic. I hope it inspires people to get interested in this emerging field, which I'm convinced will have a lot more to say about how we do software development.
Until I can quote an excerpt (or abstract) in the body of a *Link* post to provide a bit of context, ¯\\\_(ツ)\_/¯ 
Do you people getting into freelancing know any good resources for how to go about doing it with Haskell? I'm assuming there aren't a lot of people asking for a consultant that will build their product using Haskell, so how do you find clients that are ok with you using a less popular language?
&gt; The intended semantics seem to be more like `takeWhile` Perhaps. The problem specification is vague: do we add 1 only if the input is `'a'`, or do we recurse only if the input is `'a'` and otherwise just return 0? But you're right, I didn't notice it could be something other than `filter`.
WxHaskell is also pretty good and lightweight
Not even close. There are many types you can't express in Haskell, and type theory is just one calculus of categories.
I have to admit I don't quite understand `type family` stuff or `GHC.Generics`, as I am still new to Haskell. The haskell wiki looks really great with lots of examples. Thanks you and /u/mbw_rdt for your answers. At the moment I am reading the haskell book, but I really don't like ebook. I hope the hard copy will be out soon.
Does the WebGHC project ever do some blog post write ups with updates? I love following both these projects, but have no idea what state WebGHC is in, unfortunately :(
Yea, I wanted to avoid the parens or `in loop` method since usually these are multiline fix lambdas. ArgumentDo looks lovely though, thanks for that! 
Exactly, doing it this way allows you to quickly apply concepts that you've just learned to gain more intuition for how they practically work. It's very helpful for learning Haskell concepts imo, but it certainly doesn't give you great results initially, in terms of usefulness.
I think you missed the *badum tss*.
Now if I can see if I can get out of my own way trying to understand Monads. I swear, its been a year with countless articles and videos. The most recent one was by [Bartosz Milewski](https://www.youtube.com/watch?v=gHiyzctYqZ0). I liked it, I especially liked how he compared Monads to functions. Its still, you have _bind_ and _return_ (or whatever you want to call them) group, this with that, bing bang zooey in 3 lines of code I wrote a full HTTP server and it tests itself with 100,000 clients. It can take me a while to really grok an idea, but generally once I do I can connect it to everything else. However, Im either overthinking them, or I just havent found the right knot to pick at. Sorry, got a bit wordy, eventually Ill figure them out. Theres even a chance Ive incorporated them into some design in an unrecognizable form. 
Can someone explain the "Haskell is category theory!" -&gt; "HASKELL IS NOT CATEGORY THEORY" meme? Is it just the yin and yang of overzealous Haskellers asserting a deeper connection to category theory than actually exists balanced out by math types that want to put them in their place? I have a hard time understanding who's being serious and to what degree. Haskell is like a facsimile of a fairly small subset of category theory, but category theory certainly is useful for reasoning and developing intuitions about some of the bigger Haskell ideas.
Hey man, I didn't even know that meme existed. I have just a basic intuition about all this stuff and this is basically me trying to appear smarter than I am through a joke :D
Yeah, I didn't mean to insinuate you were trying to beat a dead horse, but I see the type of exchange you were alluding to fairly often and no one really explains why they take a position either way other than 'bottom means Haskell cannot category'.
Short version: type families are like type-level functions; you probably won’t need to use them until you want to leverage the type system to enforce some complex property, or do certain kinds of metaprogramming for convenience and code reuse. Long version: type families let you pattern-match on types as if they were ordinary values, and compute new types or other compile-time values, similar to the metaprogramming you can do with C++ templates and specialisations. So the call `Tuple '[Int, Char, String]` evaluates to the type `(Int, Char, String)`, which is how `myTuple`’s definition can just be an ordinary 3-tuple, even though the type signature spells it differently. The advantage is that once you have a list of types, you can use type families to work with it just like a normal value-level list. That `All` in my example is a specialised `map`, mapping a constraint over a list of types to create a new constraint, so `All Eq '[a, b, c]` evaluates to `(Eq a, Eq b, Eq c)`.
It won't do everything, but maybe some things: https://github.com/nomeata/ghc-proofs
can you show the rest of your program? It seems the error is somewhere above that line (or that line *should* be intended but it looks like a top level definition to me)
It’s Haskell’s syntax for list construction. You can pattern match on it like (x:xs) to say bind x to the head of the list and bind xs to the tail of the list. You can also use it to construct list. In that case you can view it as a function with signature (:) :: a -&gt; [a] -&gt; [a]. Also pronounced “cons”. In you map example it is saying build a list with head (f x) and tail (map f xs).
Why use a fold if you can do without `'+' : concat [ (replicate n '-') ++ "+" | n &lt;- ns ]`
scan the whole `Source`, but doing it one element at a time. So you only need as much space as the size of a single element.
Just out of curiosity, what language did you choose? And why? Or was it just tooling or the feeling of not ready? I admit I was/am learning Haskell on and off for years now. It might be a good idea for your first project to pick something which doesn't require external libraries, just plain IO, or at least libraries without their own monads. Tooling is IMO quite bad in Haskell, for example there are two plugins for IntelliJ IDEA and neither is passable. One is quite good (e.g. linting), but breaks randomly even when I don't change anything (like globally installed packages); the other doesn't support almost anything beyond highlighting (so IDEA is essentially worse than clever editors like Atom), but at least it doesn't break randomly. PS: There is a very Haskell-like language called Eta which runs on JVM. I don't think it is mature yet (just few weeks back I hit a performance issue in its runtime), but the rate of development seems really fast (they identified issue in a few days and fixed it really quickly). Compared to Haskell, Eta's IntelliJ IDEA plugin seems great considering how young it is, I even use it for editing Haskell source files (very small projects).
I'll add that you can read the expression as `(f x) : (map' f xs)`
I don't think this is quite right. From section 2.1: "Meaning of the linear arrow: `f :: s ⊸ t` guarantees that if `f u` is consumed exactly once, then the argument `u` is consumed exactly once." So in your example, this just means that `a` will only be consumed once if `f a` is consumed / used once, but there is nothing preventing you from using `f a` multiple times. e.g. you can do this: ``` g :: A -&gt; (C,C) g x = let fx = f x in (fx b1, fx b2) ``` (but note that `g`'s type has been weakened to `-&gt;`)
In the future, instead of posting screenshots: * Switch the text field on reddit to markdown (as opposed to the 'fancy pants editor') * Copy and paste your code * Put 4 spaces in front of each line of code It'll look like this: this is some text with 4 spaces in front of it this line also has 4 spaces in front of it
I didn’t know you could do that! Yea I’ll definitely do that next time. Thanks! 
Yay! Now show us the rest of you program - like CKoenig said, it looks like your error is somewhere *above* the line that's shown in your screenshot.
I would put it like this: to pick an example from the paper linked here, saying "Haskell is category theory" is very much like saying "chemical reactions are category theory". In other words, even though Haskellers do borrow vocabulary and methods from category theory, Haskell is first and foremost a flesh and bones programming language. It is not an offshoot of a branch of mathematics -- it didn't evolve historically like that, and it isn't dealt with like that in practice.
Thanks. Seemed to be an issue only on mobile.
While there might be a lot of advantages to this approach, I don't think this is a very good suggestion. This isn't a binding, this is a library for generating bindings and if I'm asking for a binding, that means *I don't want to generate one*.
&gt; Can someone explain the "Haskell is category theory!" -&gt; "HASKELL IS NOT CATEGORY THEORY" meme? More than any other language, certain people have found some concepts map well between Haskell (or total subsets of Haskell) and certain parts of category theory. We also get the names of some of our oldest type classes (`Functor` and `Monad`) from category theory, even though they don't perfectly match the category theory ideas with the same name. So, there's some connections that might be useful, but they are analogies at best and like all analogies break at some level of formalism.
Self-defense can involve escalating aggression OR it can de-escalate the situation. The later is fine; the former can be rightly policed by the moderators.
Ops sorry, I’ll delete this and post it there 
The monthly (?) question thread on this subreddit is also a good place. 
filter takes too parameters, yes. The first one is a function of type `a -&gt; Bool`. The second is a list. It returns a list containing only the elements of the input list for which the function returned True. 
I enjoyed reading this blog on the class Typeable: https://chrisdone.com/posts/data-typeable
Thanks! Yes, I realize these are just includes. I have used Nginx fairly extensively before but I like being able to close the knowledge loop in terms of how something works when looking at the Haskell code (e.g. being able to see that the `getIpAddress` function relies on a header set through `proxy_set_header` before the `proxy_pass` takes place in Nginx).
Excellent suggestion!
Oh guys I fixed it!! I added spaces after = and added brackets for fractional values 
`AllowAmbiguousTypes`, in my opinion, should now be pretty much on by default, because the ambiguity check is made completely irrelevant/superfluous by `TypeApplications`. 
Cool blog post, well done! `typerep-map` library is an example of the real `Typeable` usage, it implements dependent map data structure with types as keys: https://github.com/kowainik/typerep-map And here is the blog post with the details of the implementation: https://kowainik.github.io/posts/2018-07-11-typerep-map-step-by-step.html
TaPL or ATaPL includes an implementation in OCaml, I think. --- That said, Dear PL implementors, get off your lazy backsides and learn to read some real judgements, without needless verbosity, I beg you please! --- I've been going through TAPL plus the MTLL (and W-Types) pages on nLab and trying to implement in (ASCII-only) Agda, and it's honestly not that hard to translate the judgements (to types). Now, the judgements aren't always a direct line to a implementation -- that's often a different paper or chapter, but I've also not had much trouble translating the implementation-oriented papers into code, either.
My plan was to settle down as a full-time programmer and then start to learn what I want. The best options from the perspective of vacancies were: Java, C++, JavaScript and Python. I had chosen Java at that point. Yeah, I know... But it was just practical decision: familiar C-style syntax, good tooling, and huge amount of vacancies. Ironically, only first part of my plan had come true(to become full time dev), the project I was working (and still work) was so complex(strange mixture of network programming, big data and classical enterprise), that I'm still spending most of my free time reading project's domain-specific literature. Recently I've started to investigate golang, and again - not because I like it, but as a practical tool for devops related things. So that is my story for now.
Doesn't that return 0 for "ba"? I think it should be: ``` length' [] = 0 length' ('a':xs) = 1 + length' xs length' (_:xs) = length' xs ```
Well it also catches accidental introduction of type variables in the constraint that don't appear in the type, due to a misspelling for example. That being said, I'm having trouble coming up with a case that wouldn't also result in some other error. 
Wow, thank you for replying, \`:i (-&gt;)\` just blew my mind. For some reason I think I've been thinking of type signatures as some \_special thing\_, but I'm starting to see they're more similar to 'value level' expressions than I previously realized.
\&gt;Bartosz Milewski &amp;#x200B; That guy is awesome. I kept seeing his answers on Quora and then stumbled across his blog and finally his youtube channel. I'm looking forward to getting through the rest of those category theory videos of his. &amp;#x200B; \&gt;Now if I can see if I can get out of my own way trying to understand Monads. I swear, its been a year with countless articles and videos. &amp;#x200B; I know the pain. I thought I understood them pretty well up until recently when I finally pieced together their relation to `monoid`s and it all finally clicked for me. &amp;#x200B; Just in case it's helpful to you, these are a few things that helped me: 1. Try to avoid leaning on `do` notation since it just obscures what you're trying to understand by nice looking syntax 2. Go about learning `Applicative` functors *first* and try to justify `Monad`s by finding examples for which `Applicative`s aren't powerful enough. (There is a lot of information about these in the [typeclassopedia](https://wiki.haskell.org/Typeclassopedia)). 3. Get used to viewing `Functor`s and `Monad`s both as data structures and "computational contexts" (where relevant). 4. Try deriving specific instances of `Functor`, `Applicative` and `Monad` yourself (in many cases the types force you into the correct derivation). 5. Imagine type signatures like `(&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b` as two entirely seperate type signatures. You have `Monoid` appending of the functor: `(&lt;&gt;) :: f -&gt; f -&gt; f` and you have normal function application: `($) :: (a -&gt; b) -&gt; a -&gt; b`. However since `f :: * -&gt; *` it allows us to have both happen simultaneously inside `(&lt;*&gt;)`. It is a very similar process (but slightly more powerful) in the case of `(&gt;&gt;=)` I hope these help you. If you get stuck with anything, feel free to ask me about it cause I like thinking about this stuff :) &amp;#x200B;
TaPL (Types and Programming Languages by Benjamin C. Pierce) I've read, it's great, but I'm not getting the last parts, and at least my copy does not contain a whole interpreter. I might just be too dumb for this. I've got my own version of such an interpreter, all the way to System F. Been banging my head at this for weeks. Dumb thing is, it's probably stupid simple and I'm just not getting it. ATaPL, I duckduckgo'd it and found [Advanced Topics in Types and Programming Languages](https://www.cis.upenn.edu/~bcpierce/attapl/). Have not seen this before, may order a copy. &gt; I've been going through TAPL plus the MTLL (and W-Types) pages on nLab and trying to implement in (ASCII-only) Agda, and it's honestly not that hard to translate the judgements (to types). Now, the judgements aren't always a direct line to a implementation -- that's often a different paper or chapter, but I've also not had much trouble translating the implementation-oriented papers into code, either. I'm glad to hear you aren't having trouble with it. When I crack it, I'll write a blog post summing it up in plain English for the next guy. 
&gt; There are the full implementations on his website Yeah; that's what I meant. Very little of the OCaml code is actually in the books, and even if it were, I know I would prefer in separate from the prose in a compiler-friendly format. &gt; When I crack it, I'll write a blog post summing it up in plain English for the next guy. Awesome; I suck at explaining things.
Wow, this is of really high quality. I wasn't sure what to expect when I saw the title.
&gt; I am not suggesting you roll your own gtk package with it. Just use the gi-gtk one that is provided in Hackage. Thank you for the... clarification? I'm good with additional build-time deps. :)
Yes.. unfortunately we two have been working on and off on the project, and communicating mainly on IRC or github issues.. Perhaps this weekend I will write an update, to give an overview of where we are..
This post will look at the chunk size Haskell’s bytestring library actually gives us and explore some ways we can get the required chunk size we need for SIMD.
I have seen that article. I think that is one blog with a bit more accessible content. Sadly in this case, it didn't work for me. But now that I have come to understand Typeable a bit, after looking at it again, I am not sure why it didn't work for me. But I think it might have to do with subtle things like the order in which things are introduced. For example take the case of the use-cases. I think the use-case-3 should have been put first, and then the use-cases 1 and 2 would have made much sense. Still a great post.
Yes, that's really great to show what is `Typeable` at small and simple examples, it's very helpful.
I think having an edit button on Hackage pages which automatically link to a GitHub/GitLab PR would be useful. The ENSIME docs (Scala) have this.
No. It can handle linefolds but not where/let blocks.
Have a look at this definition: data List a = Cons a (List a) | Empty `:` is an infix data constructor that is similar to the `Cons` constructor and `[]` is similar to the `Empty` constructor (similar as in `[a]` is isomorphic to `List a`). Think of it as something that glues the head of the list to the tail of the list.
What makes those things difficult in mtl style?
[Here's the link.](https://www.youtube.com/watch?v=dQw4w9WgXcQ)
I updated the wiki page with the latest status of WebGHC project. Hopefully we will keep it updated from now on. [https://github.com/WebGHC/wasm-cross/wiki](https://github.com/WebGHC/wasm-cross/wiki) &amp;#x200B;
In the first diagram under "Rechunking &amp; resegmenting", is the `d` there used twice? Or is the second `d` just wrapping around from the previous line?
Every time I have to turn on this pragma right now I cry a little for this very reason. It lets through so much bad code that I want it to be as localized as possible.
This is the one: https://mail.haskell.org/pipermail/haskell-cafe/2018-September/129992.html
From the code examples for [freer-simple](https://github.com/lexi-lambda/freer-simple/), it looks like, in order to use IO, I need to define an GADT with all the functions I want to use as constructors and then "implement" them. Is that really the case? It sounds like a lot of work.
Do you have an example of bad code that it lets through?
I needed to create several versions of the same algorithm: a persistent version which read and wrote to the database, a semi-persistent version which read from an in-memory representation and wrote to the representation and database, and a non-persistent version which only read and wrote to the in-memory representation. In the last two cases the in-memory representation is built from the database state at startup. Thought it would be a cool opportunity to use free monads, and settled on `freer-simple` because I could *sort of* understand the documentation if I squinted and turned my head sideways while scrunching up my nose. In particular, using free monads eventually results in having to write ones own interpreters (otherwise you have the same set of built-in effects as `mtl` -- except for `ContT`, of course -- and might as well use that), and all of the other freer implementations, apart from being unmaintained, had rather harrowing syntax which would have required either a great deal of lamenting, or resorting to cargo cult programming (bad idea, especially when you're dealing with code that produces side effects). Now, some not-very-rigorous instrumentation suggests that the non-persistent algorithm could potentially run at least 5 times faster were it not for the extra interpretation infrastructure. Using a typeclass instances to represent the various algebras' interpretations is next on the agenda. Overall, `freer-simple` was a boon to work with, but maybe I shouldn't have tried it on the most performance-critical component of the entire system... Disregarding performance concerns, I'm still not yet ready to give up on freer effects. The inability (IIRC) to create a `ContT`-like interpreter literally means nothing to me, and I honestly think that at least conceptually they make more sense than monad stacks. That is, conceptually, if one ignores performance and the harrowing syntax for creating interpreters (much of which stems from Haskell's lack of open data types, but I'll save that rant for another day). 
Walked in not knowing what `Typeable` was; left having a basic understanding of what `Typeable` does and why one might use it. Good article! How does this square with the specialize pragma? Are they basically confronting the same kind of problem, but specialize is just "if you're lucky for the compiler to spot this specialization at compile time, you get the specialized version" whereas `Typeable` is paying a runtime cost but getting a guarantee that you actually get the specialized case?
Haxl is basically a free monad and used in production at facebook. The free monad part mostly manages data fetching, though, and that will always dwarf any performance disadvantage.
You have spotted a legitimate error. Thank you for bringing it to my attention. I have updated the post with the corrections.
&gt;Walked in not knowing what Typeable was; left having a basic understanding of what Typeable does and why one might use it. Good article! Thanks. &gt;How does this square with the specialize pragma? Are they basically confronting the same kind of problem, Not terribly familiar with the specialize pragma. I had to look it up. From its documentation [1] it does not seem that it and Typeable are addressing same kind of problem. For one thing, I don't think specialize pragma influences the type checking process at all. That is. It does not provide the type checker with additional information. This is unlike Typeable, where, by using it, you are actually providing new data to the Typechecker. For example, when you send a polymorphic value through the `cast` function and it comes out of the `Just` branch, the compiler have additional information about the value that just came out. The information says that the value wrapped in `Just` is this concrete type. I don't think that the `specialize` pragma has the capability to talk to the type checker and provide it additional info in that manner. [1] https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#specialize-pragma 
You could create a constructor which takes an IO action as an argument.
Wait, I was thinking of `RULES` not `SPECIALIZE` - it's called "template specialization" in most other languages, so that's the word that comes to my mind when I think of this. Anyway, I was trying to say that both give you the ability to violate (hopefully tastefully) parametricity and pattern match on the type.
I disagree, because there is often a variant that *does* infer. I'd much rather we strive to build APIs that inferred, rather than saying "eh, we've got `TypeApplications`".
Almost anything with a constrained but unused type variable: foo :: Show a =&gt; Int foo = 42 The type signature here is definitely a mistake, but with `AllowAmbiguousTypes`, the compiler doesn't tell us about this mistake until it gets to the call site, which might be in a different module.
That's what I was thinking but it's pretty unlikely you're going to write a constraint by accident when you don't have any actual type variables. What could happen is that you misspell a type variable, but then you're missing a constraint on the real one and you'll get an error anyways.
Many sensible `TypeApplications` APIs cannot possibly infer (e.g. there is no explicit parameter to infer other types from, to begin with), and the point of type applications there is to obviate the need for supremely ugly `Proxy`-es. I admit that I am taking an Agda/Coq perspective on this matter, where choosing between explicit/implicit params is not a mechanically tractable problem, is to a great extent up to personal taste, and is generally treated as elaborator sugar and not something with fundamental significance (since it's easy to switch explicitness). Hence my subjective Haskell experience is that the ambiguity check rejects all of my sensible `TypeApplications` cases, while giving me very little value in other regards. 
I would recommend simple syntax patterns that just help you to write more compact code: * ViewPatterns * BangPatterns * RecordWildcards * OverloadedStrings * LambdaCase * MultiWayIf * TupleSections They're really easy to understand and give you direct improvement in everyday code. For types related stuff learn GADTs and TypeFamilies. If you need other extensions compiler usually says you about it. Actually, if you're not writing compiler or something ultra high-tech you probably don't need most of the type extensions. Haskell is pretty good for many tasks without extensions. GeneralizedNewtypeDeriving is useful with newtypes. In general just read GHC docs about extensions. If you don't understand what extension do then it's probably not necessary for you now.
newtype Foo m a = Foo (m a) instance MonadIO m =&gt; MonadIO (Foo m) where liftIO io = Foo $ do liftIO $ print "before" res &lt;- liftIO io liftIO $ print "after" return res
Worth noting that this crashes at runtime if the list is empty. Data.Monoid.mconcat :: (Monoid m) =&gt; [m] -&gt; m Uses the monoid typeclass to get an appending operation and a fitting empty element. Quite often you don't want the default operation and working around that is usually more trouble than using a fold.
The worst part about this is that e.g. asking Google for the definition usually gets it right, and then the examples are backwards again.
Doesn't this basically boil down to "Haskell is inherently harder than Python and requires more education?" Why does that have to be the case?
Most Typeable uses I have seen are related to generic programming. SYB builds on typeable, uniplate builds on SYB. If you want to generically traverse a large and sprawling data structure uniplate is great - hlint uses it to search through the haskell ast, for instance. SYB also used to be popular for generic programming, e.g. deriving default Aeson instances using gson style runtime inspection. This was mostly replaced with the newer GHC.Generics which can be optimized away.
In Agda/Coq, type variables are exclitly introduced. Should AllowAmbiguousTypes require that: IMHO yes.
See my other reply. Requiring explicit `forall` with AllowAmbiguousTypes would solve this pain point. Though will introduce another one. IMO reasonable trade-off
Occasionally you actually want a "redundant" constraint to confine some unsafe dirty work. For example, `atomicModifyMutVar#` and (to a lesser extent) its upcoming replacement `atomicModifyMutVar2#` have much more general type signatures than they deserve to.
To be honest everyone worries about this, but I'd actually like to see a "our usage was made impossible by the performance overhead incurred by *x*". That is, are we worrying about the right thing? You allude to this in your last paragraph, but I wanted to reiterate this seeing as it's the top comment. I don't think this performance should be at the top of your list of things to consider. The well implemented libraries are probably fast enough.
Working with `IO` defeats the point of using these libraries. The point is to precisely define the operations you're running, so that you can latter switch out the implementation with an in memory implementation, or an implementation that adds logging, etc. If you are just passing `IO` around, there is almost nothing you can do other than just run what you're given.
If you have `IO` in your effect stack, you can still use `liftIO` with `Eff` from `freer-simple`. As /u/ocharles points out, however, that really defeats the whole point of using an effect system. If you’re not defining your own effects, and you’re just using combinations of `ReaderT`, `StateT`, and `ExceptT` over `IO`, `mtl` is *fine*. There’s a lot of boilerplate involved, but it’s all in the library. I’m not satisfied with that, though, since I want to be able to define my own effects, largely so that I can unit test them, and [doing that with `mtl` style is obnoxious](https://github.com/lexi-lambda/mtl-style-example).
Thank you and /u/lexi-lambda for your input!
You are looking for Okasaki's [Even Higher-Order Functions for Parsing or Why Would Anyone Ever Want To Use a Sixth-Order Function?](https://www.westpoint.edu/eecs/SiteAssets/SitePages/Faculty%20Publication%20Documents/Okasaki/jfp98sixth.pdf)
Yes, I use it in [Aura](https://github.com/aurapm/aura), a CLI tool for Arch Linux. I don't use any custom effects, just `Reader`, `Error` and an embedded `IO`.
For an SPA backend, wouldn't something simpler like `scotty` be better? Yesod is probably an overkill, and `servant`'s type-level hacking with it's custom DSL operators may get in the way since I think that `scotty` is closer to idiomatic Haskell and it's just Haskell. But if you're already a `servant` user I think `servant` would be a better choice.
Is your `Storable` the same as `Foreign.Storable`? If that's the case, then you need `Storable a` not `Storable a k` (not sure what the `k` is doing there?). More generally, it's more helpful if you can put code that can be pasted into a new file to reproduce the exact error. There is a discrepancy between your code sample which has run t f = run (toStore t) f and the error message which has run' t f = run (toStore t) f
Hi, it is not that 'Storable' but rather my own. I have pushed the error to a branch. git clone git@github.com:barischrooneyj/simple-store git checkout type-family-error stack build :)
Sure, not *everything* can be inferred - I'm not suggesting that. Merely that I don't want people giving up on making things that could infer, infer.
&gt;I think the first thing to do is use a pure functional language, instead of trying to learn these concepts in Scala where I can lazily just revert to my old mutable ways of thinking. Yes, I've heard quite a few negative things about Scala. It seems like it's trying to do too much at once which makes it extremely complex whilst allowing people to write ugly functional/imperative hybrid code. Although I would still prefer to use Scala than VB.net that my current job uses. That stuff about game programminh is really interesting, I would love to get more involved with it. I have played around with the Gloss Haskell library a bit and was considering trying to write a very simple 2 game engine which utilizes it. I know Haskell probably isn't the best language for something like that, but it's my main hobby language so any experience I can get writing interesting stuff in it, I want to take.
Haskell type errors are much less intuitive to a newcomer than stack traces Understanding how to run effectful computations can be challenging in the presence of things like ResourceT Python has “requests”, haskell has “conduit-http” Basically it’s haskell’s huge swaths of generic machinery that allow haskell programmers to be productive while having type safety at the expense of simplicity.
&gt; &gt; I think the first thing to do is use a pure functional language, instead of trying to learn these concepts in Scala where I can lazily just revert to my old mutable ways of thinking. &gt; &gt; Yes, I've heard quite a few negative things about Scala. It seems like it's trying to do too much at once which makes it extremely complex whilst allowing people to write ugly functional/imperative hybrid code. &gt; Although I would still prefer to use Scala than VB.net that my current job uses. Oh dont get me wrong, I love *Scala*. I strongly prefer multi-paradigm languages for work. I have this unresearched idea about complexity walls. If youre using code generation, youve hit the wall. If something is in the compiler vs its stdlib, youve hit a wall. In some languages, you hit it quickly, like Java. Very little expressibility. Besides *C++*, the only languages Ive not hit low complexity walls in are *Scala* and the *lisp*s. From looking at what folks do in **Haskell**, it looks like it has a super high wall too. Ive seen stuff that I previously assumed could be done in the compiler done as a quick easy short set of code. &gt; That stuff about game programminh is really interesting, I would love to get more involved with it. &gt; I have played around with the Gloss Haskell library a bit and was considering trying to write a very simple 2 game engine which utilizes it. Yeah I love game programming. Though ironically what Im doing now is closer to massively horizontally scaling servers with lots of state. Since **Haskell** is purely immutable, Im sort of suprised it has any issues with GC, which is the big killer on how a game feels. Even a pause \&gt; 30ms every minute can make a game feel bad. That doesnt matter for a hobby project and learning immutability of course. If I _have to_ use tricks to get around a GC, I generally consider that a wall, but with some languages you can hide that behind nice APIs. And a caching layer is fine for the bigger objects. Hell, I bet one (maybe even me : ) can build a ref memory management system as a **Haskell** library. &gt; I know Haskell probably isn't the best language for something like that, but it's my main hobby language so any experience I can get writing interesting stuff in it, I want to take. Exactly. Learning new techniques is the best. Which is my point about using **Haskell** vs *Scala*. *Scala* lets me revert to my 'well, I know how to do this, so Ill use that' thinking. 
This was very insightful, esp for a beginner like me. I'm especially looking forward to the integration with Haskell in the next blog post. Thank you for sharing.
i was asked to evaluate the quality of one of Julie's talks for intro pedagogy earlier this summer, and me and some other folks were incredibly disappointed at how poor the content was in terms of introductory accessibility or substantive content. https://www.youtube.com/watch?v=tfQdtPbYhV0 (to be fair, i gave an advanced track talk that was definitely inaccessible because it was me live coding ideas/formal methods i'm still figuring out how to mechanize and teach to humans) chris allen aint perfect (i know this better than most), but i'm pretty comfortable asserting that the majority of the material (which is by no means perfect) in their haskell book was developed by him :-) i generally assume folks who claim theres private stuff they cant share that proves them right as the likely party in the wrong. Caginess is never healthy.
I'd like to give brittany a try but it uses AGPL license which prevents me from using it (at least at work). The formatting definitely looks much nicer than the one provided by hindent.
I feel like a lot of these concerns could be addressed in a clean way with something like `generic-lens`. You'd represent agglomerates of record fields with `HasField` constraints rather than row types, but most of the features you would expect from rows are there. Have you tried this approach, and if so, what was that made you think you'd still prefer row types?
Did you try [Typing Haskell in Haskell](https://gist.github.com/chrisdone/0075a16b32bfd4f62b7b)?
Makes sense. With the freer approach, we can actually make the function I wrote above polymorphic over an arbitrary effect parameter by replacing the `@IO` type application. You can make a `newtype` for every monad in your stack, but is there anyway to do it generically?
As far as I am aware that does not give me the ability to union records or variants or algorithmically create new data types. This first class manipulation of structures is what I find quite lacking in the generics approach. 
&gt;I have this unresearched idea about complexity walls. If youre using code generation, youve hit the wall. If something is in the compiler vs its stdlib, youve hit a wall. That actually makes a ton of sense. &gt;Exactly. Learning new techniques is the best. Which is my point about using Haskell vs Scala. Scala lets me revert to my 'well, I know how to do this, so Ill use that' thinking. I see what you mean, I ended up investing so much time in Haskell at uni that it slowly became my "I know how to actually do stuff in this" language. I'm at a bit of a weird point now though where I'm infatuated to the point where I feel like I don't even want to learn other languages. It's hard for me to tell how much this is about me having a preference for abstract and mathematical concepts and how much it's just about wanting to have a niche and be good at that niche.
&gt; our usage was made impossible... You're setting the bar too high, the real question is if your users have a noticeably worse experience due to your slowing down your program, not if the program actually becomes unusable.
That happily worked with ghc-8.6 with -XQuantifiedConstraints. Until then, what you can do is like this (painfully tedious but not impossible) class MyShow f where myLiftShowsPrec :: (Int -&gt; x -&gt; ShowS) -&gt; Int -&gt; f a b x -&gt; ShowS newtype SampleF (a :: State) (b :: State) x = SampleF x instance MyShow SampleF where myLiftShowsPrec showx p (SampleF x) = showParen (p &gt; 10) $ ("SampleF " ++) . showx 11 x instance (MyShow f) =&gt; Show (Thing f) where showsPrec p (IntThing fab fbc) = let showF = myLiftShowsPrec showsPrec 11 in showParen (p &gt; 10) $ ("IntThing " ++) . showF fab . (" " ++) . showF fbc showsPrec p (DoubleThing fab fbc) = let showF = myLiftShowsPrec showsPrec 11 in showParen (p &gt; 10) $ ("DoubleThing " ++) . showF fab . (" " ++) . showF fbc 
Awesome! Thanks a bunch team :)
This is a good day :D
Huzzah! All kinds of great stuff here, wonderful job team!
God so many features in this release I have been craving!
Wasn't aware of Typeable till now. Good blog post. And hello from India.
.. or you could do the same thing with backpack * build the module signature for the operations you want. * write an module that implements that signature against IO. * write a module that implements it against whatever bespoke logging and mocking stuff your test framework wants. Either against a concrete StateT, etc. stack or as a free monad. * then link your code against both, the real one in production, the mocked version in your test suite. * now you aren't paying a huge interpreter tax just for testing purposes, and you don't have to plumb extra type variables all over your code for the choice of 'm'.
You can work in `Free f`, and then have the interpose action fire between each interpreted layer of `f` if you really feel the need to do this. Something like: foldFree (\io -&gt; liftF $ print "before" *&gt; io &lt;* print "after") $ do liftF $ print "hi" liftF $ print "bye" (I don't have a compiler handy at this exact moment to test.) You can choose different effects to call out as `f` in `FreeT f m` if you have one particular `f` that matters to you. Here you don't have to lie about `liftIO` being a monad homomorphism, either.
I'm still on 8.2. I guess I'll have to stop procrastinating at some point and bite the bullet.
FYI if the maintainers are reading this: the downloads.haskell.org is down.
&gt;GHC now supports British spelling of GeneralizedNewtypeDeriving. god, finally. :p
Would it be possible to publish compiler performance stats along with the release notes? I'm always worried that I'd be slowing down an already slow code-compile-debug cycle by upgrading my compiler. 
Hey! Thank you!
&gt; GHC now supports British spelling of GeneralizedNewtypeDeriving. This made me giggle, but I am also happy to see it, as now and again I tend to mix the two spellings (English is not my native Lang, but I did learn British English and thus that spelling comes more natural to me). Thanks all for the hard work and for another great release! &lt;3
Carter and I aren't having a disagreement. He merely expressed frustration that he is unable to help in this conversation. I hope to reassure him that that's okay, and he doesn't need to.
Sorry for the late response. Just seeing this now. This appears to be a "feature" of the way nginx rewrites work? I tried to fix it by replacing location ~* /platform/download/(.*) { return 302 https://downloads.haskell.org/~platform/$1; } by location ~* /platform/download/(.*) { # this is a hack to attempt not to decode spaces in uris? rewrite ^ $request_uri; # get original URI rewrite ^/platform/download(/.*) /~platform$1 break; # drop pfx and replace return 400; if we don't match return 302 https://downloads.haskell.org$uri; } but i'm not sure if it worked. on the other hand, i'm not sure what automated tools get broken. curl and wget seem to handle it just fine? Also we've had this config for a long time and this is the first report, which confuses me, because I know that people have used the cask successfully in the past. 
This is fine if you just have "a" test monad. If you want to do testing that is more like a mock/test double/spy, where each test has a slightly different implementation of an effect, this is going to be painful.
This is cool! What do you mean generically? Typeclass constraints make it generic enough imo, when do you ever need to be able to run something that could be absolutely anything without knowing anything about your constraints? I'll worry about that problem if I ever see it in the real world ☺️ I don't think I've ever newtyped mtl transformers other than the typical "AppM", what does it get you?
I feel the need to reiterate this here ☺️ https://chrispenner.ca/posts/monadio-considered-harmful
Agreed! I started off with a text editor as my first ever haskell project, the difficult parts made me learn things!
Which compiler version are you using now? This may be important. I am under impression that since 8.2 there were only spurious compiler regressions for certain libraries or code bases - not a slowdown in general. There are ongoing efforts on multiple fronts to make GHC devops infra more reliable, including performance regression. [Like the ones described here](https://ghc.haskell.org/trac/ghc/wiki/Performance/Tests), which where a subject of a HSOC. Right now performance regression is verified on extensive, but brittle tests. [ghcperf also exist](https://perf.haskell.org/ghc/) but it doesn't compare compiler versions, just recent commits I think. 
Text editor is another really great project. 
What’s are the differences between WebGHC and Asterius?
Asterius is implementing a custom codegen and runtime. WebGHC attempts to reuse almost 100% code existing in GHC, with correctness modifications. WebGHC gets the benefits of not having to write a custom runtime or codegen (very hard) in exchange for the loss of the best possible performance. More editorialized option time: If I had to guess, I'd guess that WebGHC has gotten much further with much fewer hours put in. I suspect this performance gap will close significantly as the LLVM backend becomes more appropriate, but time will tell. The goal for WebGHC is *far* less ambitious, in that almost everything is reused instead of reinvented, so it's seemed like we've had a lot less time invested. Plus the eventual runtime and codegen will much more closely resemble the regular native runtime and codegen with WebGHC. I don't suspect anything like GHCJS or Asterius could ever be upstreamed, whereas WebGHC is designed to be upstreamed without compromising performance eventually.
8.4.3 is also very good IME. Do you have hard dependency constraints?
Strange, it still doesn't show up in the versions list, and `latest` still points to 8.4.3
I do want to remove that 'Storable' dependency and move to superrecord
I'm also still on GHC 8.2.2 for most of my projects as vanilla GHC 8.4.3 still has a couple of unresolved issues I hope to see resolved in GHC 8.4.4.
Great work!
Do we have a stack.yaml for that?
I was surprised to see this &gt; Valid hole fit hints, helping the user to find terms to fill typed holes in their programs Awesome!!! Yet, nobody talks about it... 
&gt; I don't suspect anything like GHCJS or Asterius could ever be upstreamed, whereas WebGHC is designed to be upstreamed without compromising performance eventually. Disagreed. We're already basing our work on a custom GHC fork which will eventually contain all logic of asterius, and generate/link wasm code simply with a ghc flag. I guess that counts as potential for upstreaming? &gt; but time will tell. Definitely :)
It could be used for this, yep.
Thanks :) I'll probably make a post about Windows changes in 8.6 and those coming in 8.8 soon. Probably the best way to draw attention to them. 
I've just been using it to create a cli tool to wrap up a load of glue stuff for my infrastructure. For this use case I've found it to be really really nice. For example I got a `--dry-run` flag almost for free, just write an interpreter that writes commands to a writer instead of running them in IO. Also nice that in my dry run interpreter, some effects were interpreted purely and some in IO. I have also had to play around quite a bit with when to use a custom effect and when not, TBH it's quite a different way of thinking but I'm really impressed with it. I'm almost finished writing a blog post about it which I'll post here. I'll definitely use it again unless I'm in a situation where it could be a performance problem.
Thanks for looking. Did you already deploy that config change? Because I'm still seeing the spacey URL in the Location: response. Yes, `curl` and `wget` handle it fine; the client failing to do so in this case is Ruby's `open-uri` module: open 'https://haskell.org/platform/download/8.4.2/Haskell%20Platform%208.4.2%20Full%2064bit-signed.pkg' OpenURI::HTTPError (302 Moved Temporarily (Invalid Location URI)) That original link has a valid Location header, but it redirects from `haskell.org` to `www.haskell.org`, which is the one with the broken Location. Maybe relevant: I notice that the headers are capitalized in the original reply from `haskell.org`, but have all been lowercased in the reply from `www`. curl -i 'https://www.haskell.org/platform/download/8.4.2/Haskell%20Platform%208.4.2%20Full%2064bit-signed.pkg' | grep ^locat location: https://downloads.haskell.org/~platform/8.4.2/Haskell Platform 8.4.2 Full 64bit-signed.pkg 
&gt; ghcperf also exist but it doesn't compare compiler versions, just recent commits I think. Right, this is one of the principle short-comings of `ghc-perf`. I do have [this little plotting webapp](http://home.smart-cactus.org/ghc-perf/) which I use to look for regressions over longer times. It works well enough (to get started enter, for instance "compile-allocs" in the search field on the left and check a few tests) but it could use some TLC. Currently the implementation is an unholy mess of Javascript and JQuery. Rewriting this in a more maintainable fashion (Reflex/GHC-JS, React, Vue, Halogen/Purescript, $INSERT_YOUR_TOOL_OF_CHOICE_HERE) would allow more interesting analysis (change-point detection, perhaps?) and might make for a nice project for someone looking to contribute to GHC. The source is [here](https://github.com/bgamari/ghc-perf-import); if you are interested in picking it up let me know.
Caveat: lazy IO reading is controversial these days. Its problems aren’t worth it, when you have proper streaming libraries. This post has really interesting content, so my comment an aside. 
You would use functions data Tree = Flowering | HasFruits | Dead isHealthy :: Tree -&gt; Bool isHealthy Dead = False isHealthy _ = True
But that'd only give me a Tree type containing Flowering, HasFruits or Dead. Even if I want cases where it has Tree IsHealthy TreeState
Then I don't think I understood your original question correctly. When you said that IsHealthy was redundant in the third case, what did you mean? Can you give a concrete example of a tree with variable number of arguments?
Why should the information about the tree's health be stored with the tree if it can be easily calculated from it's actual state?
I wonder if I should express it as something like: data DeadTree = Dead data FruitingTree = IsHealthy data FloweringTree = IsHealthy data Tree = FloweringTree | FruitingTree | DeadTree Meaning that I have to "split" the different cases of Tree to separately defined data types for each case of Tree.
Please see my redacted answer above :)
It was already 2 hours before you commented: https://github.com/NixOS/nixpkgs/commit/2ffcbeda133775bc19b80623be29746ce75d7411
I've modified the example.
But in that case I don't see if I have an "identifier" for Tree. That is, I might be able to match for a Tree in function declarations, but I don't think I'm able to expect in as a parameter Tree Alive TreeState, but rather I must expect in e.g. like fun :: Tree -&gt; Bool fun (Alive TreeState) = True right?
Yeah this seems like it. Although then it will mean that I will have to match against "all possible Trees" to discover what kind of Tree I'm getting into a func?
You *can* write incomplete pattern matches, but they are extremely frowned upon. Functions that don't cover all inputs are called "partial functions" and people avoid them. HealthyTree and DeadTree are data constructors, not types, so you can't make a function operate on one or the other exclusively. If you want to operate only on HealthyTrees, you would write a function of input type `TreeStage`, the information held by a `HealthyTree` but not a `DeadTree`. 
Is 8.4.4 planned? Might be nice to backport the FFI bugfix that affected xmobar.
Also what if there's repeating of the TreeStage, e.g. data TreeStage = Flowering | HasFruits data Tree = HealthyTree TreeStage | SemiHealthyTree TreeStage | DeadTree Initially this doesn't seem to create an error of multiple declarations though!
Thinking aloud. Would end-to-end compile times of popular libraries like lens, mtl, persistent, servant, opaleye, etc be a good thing to benchmark and publish? Will they give a good idea about real-world compiler perf? 
If you don't want to repeat `TreeStage`, you could add another type to the existing product type: data TreeStage = Flowering | HasFruits data Health = Completely | Semi data Tree = HealthyTree Health TreeStage | DeadTree 
No, just do not have a need to push forward. 8.2.2 works just fine and I'm not looking for new features.
Yep! `(-&gt;)` behaves like a type-level function that takes two arguments (an input type and an output type) and the result of that is the type of a function from the input type to the output type. To be pedantic, it is actually a "type constructor", not a type-level function. You can "partially apply" type constructors like `(-&gt;)` just like you can partially apply term-level constructors. For example, this is valid Haskell code: instance Functor ((-&gt;) i) where -- fmap :: (a -&gt; b) -&gt; (i -&gt; a) -&gt; (i -&gt; b) fmap aToB iToA = aToB . iToA -- Same thing as: fmap = (.)
Look forward to what you're going to invent for 8.8 ;)
I would consider users noticing akin to failing to deliver/delivering bugs. That is, I think my comment still holds.
Ahh, I see. Yeah that's something that is of course possible with mtl, but definitely would be clunky with a lot of boilerplate, looks like freer has a lot of boilerplate for this stuff too, but if you need to do fancy tricks like this all the time it would be reasonable in the long run; can't say I've ever needed to interpose anything, but I guess I'll keep an eye out for that pattern more now!
The way you describe it here, Backpack sounds like a nice alternative to mtl-style effects.
I believe you want something like data kinds. https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/promotion.html
Can you elaborate on what the note about \`ghc-heap-view\` in the changelog means? I haven't gotten to play with it yet but that package has been around for some time right? It doesn't look like it's included in the distribution and I don't see anything about it in the detailed release notes.
You should match against both the data constructors - HealthyTree and DeadTree. Why do you think that is "bad"? After all, the tree you receive as argument could be either healthy or dead.
You'd have a tough time getting O(1) definitions for an arbitrary number of effects, but if you know which effects you're working with you can do it using a trick with DataKinds; you parameterize your base monad newtype with phantom DataKinds and you can define a different implementation per DataKind member while leaving the others parameterized; I talk about how in this blog post (which I'm still editing, but should be releasing publicly soon) https://gist.github.com/ChrisPenner/6b4dbc0b8242cc482c511926ad329f7a
Nice article! One thing to note is that my web app has about 20 different effects at this point and at least 40 interpreters (a real one + at least one mock for testing). Adding a new effect, and this happens fairly regularly, in this system would mean updating 40 class instances. Another cool thing about the free monad approach (and this might be able to be done with mtl, not sure) is that we can define a sort of standard, base interpreter and then compose with specific interpreters when we want specific behavior. Example: baseTestRunner = baseHttpRunner . baseDBRunner And then in a test case, you could use baseTestRunner . dbOnFireRunner Which would essentially override the `baseDBRunner` (while leaving the http runner unchanged) 
There's two answers here, I suppose. Firstly, you *can* do what you're asking directly, but it's probably not what you want to do. Nonetheless, I'll give an example at the end. The way to accomplish what you're looking for is by decomposing the information into smaller pieces, and embed the smaller pieces into those which they depend on. Looking at it another way, you want to embed the successively more specific bits of information into the broader ones. In your case, this basically means the following: type Health = Int data FruitState = Flowering | HasFruits data TreeStatus = Dead | Alive Health FruitState data Tree = Tree TreeStatus Now, as I said, you *can* accomplish what you were asking directly, but I'd advise against it. {-# LANGUAGE GADTs, DataKinds, KindSignatures #-} import Data.Kind data LifeState = Alive | Dead data TreeState :: LifeState -&gt; Type where HasFruit :: TreeState Alive Flowering :: TreeState Alive Deceased :: TreeState Dead type Health = Int data TreeHealth :: LifeState -&gt; Type where TreeHealth :: Health -&gt; TreeHealth Alive data Tree :: Type where Tree :: TreeState isAlive -&gt; Maybe (TreeHealth isAlive) -&gt; Tree The final `Tree` type there has two fields: the latter can only be `Just` if the former is either `HasFruit` or `Flowering`. 
Thanks, I had done a quick search on the repo but missed that. I'd love to try out 8.6.1 in my project but I'm stuck trying to upgrade. I'm not sure if this is the best place to ask this (if it isn't, I'd love a pointer) but figured it's related -- how can I actually get a Nix env with 8.6.1 cached? I tried running `nix-prefetch-git` on that commit, i.e. ``` nix-prefetch-git https://github.com/nixos/nixpkgs-channels.git 2ffcbeda133775bc19b80623be29746ce75d7411 &gt; nixos-master.json ``` and then starting up an env using haskell.packages.ghc861 of that result, but it tries to build a lot of stuff: ``` $ nix-build release.nix --dry-run these derivations will be built: /nix/store/zjw6vlbr4d7sff7a8j6i942nd66hbga5-ghc-8.6.1.drv ... lots more... ``` Is this because: 1. the cache entries for these packages aren't built yet? (related, how would I check that?) 2. ghc861 isn't the "default" haskellPackages, so the cache entries aren't going to be built for this commit regardless? 3. something else?
I thought about using a data type but I think I will leave it settle for a while and move on to other parts. I like how with the typeclass an instance writer of 'Store' need only implement a few minimal methods and the rest are implemented in their terms, or they can be overridden if they choose.
Hurrah! Now for the grand ceremonial bounds bumping!
https://twitter.com/tritlo/status/1024328814443327489?s=21
Great, looks like GHC 8.6.1 just released (and should hit stack soon...?) and in the meantime that's a good workaround. Thanks!
Other option, add garbage query params at the end of the url, like `?foo=1`.
lol
what
#`ALLOWAMBIGUOUSTYPES`, IN MY OPINION, SHOULD NOW BE PRETTY MUCH ON BY DEFAULT, BECAUSE THE AMBIGUITY CHECK IS MADE COMPLETELY IRRELEVANT/SUPERFLUOUS BY `TYPEAPPLICATIONS`. 
Your type signature is specifying that `f` is a function that takes one argument (itself a function). Your definition of `f` has two arguments, so it doesn't match the type signature. If you want `f` to "expect" a function, your type signature is correct. You might have to make `f` less polymorphic though, you're going to run into trouble writing any useful function that matches that signature. An example: f :: (Int -&gt; Bool) -&gt; String f someFunc = if someFunc 3 then "hello" else "goodbye" Here `f` is expecting a function which can be applied to an `Int`, and it picks an `Int` to apply this function to. 
Not really sure what you are trying to say, but the type of your `f a b` would indeed be `a -&gt; b -&gt; c`. `f :: (a -&gt; b) -&gt; c` means `f` takes a function, which takes an `a` and returns a `b`, and returns a `c`. So the declaration would be something like `f g = ...` where `g :: a -&gt; b`.
There's a way of matching the request even more directly: {-# LANGUAGE GADTs #-} {-# LANGUAGE DataKinds #-} {-# LANGUAGE KindSignatures #-} {-# LANGUAGE TypeFamilies #-} module Tree where type Health = Int data TreeStateTag = FloweringTag | HasFruitsTag | DeadTag type family TreeExtra a where TreeExtra FloweringTag = Health TreeExtra HasFruitsTag = Health TreeExtra DeadTag = () data TreeState a where Flowering :: TreeState FloweringTag HasFruits :: TreeState HasFruitsTag Dead :: TreeState DeadTag data Tree where Tree :: TreeExtra tag -&gt; TreeState tag -&gt; Tree 
It doesn't accept \`MyType a\` as an \`a\`. The second parameter to \`MyConstructor\` is of type \`MyType a\` (you can read it in the data declaration). The \`Num\` constraint is there because of the literal 1 you have in place of the \`a\` in the definition. &amp;#x200B; And yes. It is kind of a 'loop': \`\`\` let a=MyConstructor 1 a in a == let a=MyConstructor 1 (MyConstructor 1 a) in a == let a=MyConstructor 1 (MyConstructor 1 (MyConstructor 1 a)) in a \`\`\` Except that Haskell doesn't do this computation unless strictly necessary (eg. calling \`show\` on the result) &amp;#x200B;
To add on to what some other folks are saying here; note that there's really no useful function of the given type `(a -&gt; b) -&gt; c` unless you specialize the types a bit more. From that type signature we know NOTHING about any of the types involved, so there's no way we can 'make up' an `a` to pass to the function, and even if we could we don't have any way to turn the `b` into some `c`, and we can't just make up a `c` out of nowhere either (without using 'bottom'), so you're gonna have a bad time :) Once you specialize some of these types things will get easier to talk about.
Are you asking why the types check out? `MyConstructor (1::Int) b` must have type `MyConstructor Int`. Going back to the definition, we see thus that the argument `b` must be of type `MyConstructor Int`, so `b = MyConstructor (1::Int) b`actually checks out, type-wise. This is not an infinite loop because the type is lazy. It doesn't need to evaluate `b`unless you request it. And you don't have to. You could just throw it out if you pattern match it like case b of (MyConstructor m (MyConstructor n _) -&gt; ...
On Ubuntu, I had to install `libgtk-3-dev` too
Dude, Just attend the supervised sessions! The TA's are there to help you with stuff like this. :) Kind regards, The lecturer Ps. you can certainly ask reddit also, but discussions like these could be a lot faster face to face.
I cannot see what is now possible with `QuantifiedConstraints` and which was not possible before. The release note README show the following example: ```haskell data Rose f a = Rose a (f (Rose f a)) instance (Eq a, forall b. Eq b =&gt; Eq (f b)) =&gt; Eq (Rose f a) where ... ``` However, this was possible earlier using: ```haskell instance (Eq a, Eq (f (Rose f a)) =&gt; Eq (Rose f a) where ... ``` Do you have a simple exemple of something possible with the new extension and which was not possible before?
For a similar (and very useful) construct like this, consult `cycle` from the `Prelude`.
I've deployed a number of config changes, but nothing seems to help. I contacted an nginx rewrite "expert" to see of they have better luck than me. The case of the headers doesn't seem to be a good indication of anything. Making the same request on two different boxes with two different versions of curl, one has uppercase headers and one doesn't.
One other thought -- if this issue is just with brew casks, could you submit a pr to them to use the rewritten (and correctly encoded) url rather than the original to begin with?
You can accelerate it a lot by using something like GHCid, which operates orders of magnitude faster than compilation and automatically listens for file changes.
 data Tree = DeadTree | FloweringTree Health | FruitingTree Health It's equivalent to /u/foBrowsing's answer, but I think it's a bit cleaner. It says "there are three different sorts of trees, which each have different data associated with them". A single data constructor definition is better written as a newtype: newtype Tree = Tree TreeStatus and to me this is saying "a Tree is a TreeStatus, but should be considered nominally different", which I don't think makes sense given the domain. This feels close to bikeshedding, but I hope it's a constructive comment.
I'd love to see an example.
The cask itself would then become version-specific and have to be updated every time the HP version or URL changed. Which I guess is better than it not working at all...
Numbers in code and in explanations do not match
The book was co-authored and that isn't in dispute. I don't know why you're raising this stuff here. It doesn't seem relevant. But anyway, they were always quite explicit that one person knew more about Haskell and the other did not. Nonetheless, my understanding is that in terms of the _exposition_ then a great deal of the work was done by Julie. So not only is the question of who did "which work" irrelevant here, but also your assessment of any particular talk by either of the co-authors doesn't speak to who was responsible for the _authorship_ of an expository text.
I think the guy who does HaskellRank solves the problem in a more Haskell-y way, though this is cool too. My solutions for problems like this is god awful, but it's a fun exercise. 
Thanks for pointing it out, I have fixed it.
Before `QuantifiedConstraints`, even though every valid instance `Bifunctor p` had to also satisfy `Functor (p a)` for all `a`, there was no way to write that as a superclass of `Bifunctor`. Now we could write `class (forall a . Functor (p a)) =&gt; Bifunctor p`, if we were inventing `Bifunctor` today.
&gt; infers a as MyType a, but I'm not sure why it accepts a as MyType a. Why would it not? `a` does have the type `MyType a`. It is a recursive function so if u try to call it may blow up but it type checks just fine. 
Interesting. The cask does appear to have been deleted; I had an older version installed and \`brew cask reinstall\` didn't show me the deprecation message. I've written Homebrew formulas before, but not casks. It does appear that this one was already version-specific, so my concern above was unfounded. The HTTP response is still invalid and should be fixed, but since \`brew install ghc cabal-install stack\` works, it's not as urgent an issue. Thanks for taking the time to look.
The types check perfectly, so it compiles. If it is an infinite loop or not depends on how you use it. If, for example, you don't use `a` at all, there will be no loop.
(not simple, but) it replaces, for example, requiring `(Eq1 Identity) =&gt; ...` with requiring `(forall x. Eq (Identity x)) =&gt; ...`. I'm writing a package that provides generic deriving utilities for "`Vinyl`-like` records. e.g.: data User f = User { name :: f String , age :: f Int } `Eq1` (while in `base`) is (1) more obscure than `Eq`, and (2) doesn't support automatically writing instances. which means few library authors do. In particular, custom `Show1` and `Read1` (like their unlifted counterparts `Show` and `Read`) instances are a huge pain. Besides `Identity` and `Const`, pretty much package that provides some functor (outside the standard library) also provides the appropriate lifted instances (i.e. `Eq1`, `Ord1`, `Show1`, `Read1`, etc). Worse, most packages that provide a typeclass don't provide a lifted version (with the recent exceptions of 'NFData' from @deepseq@, 'Hashable' from @hashable@, 'FromJSON'/ 'ToJSON' from @aeson@). TL;DR library authors don't write lifted instances for their types, or a lifted typeclass for their typeclasses. thus, working with a broad range of useful types (like my "record of functors", `User`) becomes gratuitously inconvenient. 
Doesn't this confuse solving and aligning the cube? As in a solved cube flipped on any axis is still solved but not aligned.
I mean to say that two expressions are the same. Forgive my lack of precision. I am still a beginner and I am writing a breakdown of the solution and would like to verify my steps without needing to consult anyone.
Operationally you could think of it as MyType&lt;Int&gt; a = new MyTypw&lt;&gt;; a.1 = 1; a.2 = a;
FYI: Reddit flavoured markdown is weird, you need to indent your code four spaces for it to become a code block.
What u/d3b105b is talking about is this: https://www.youtube.com/playlist?list=PLguYJK7ydFE4aS8fq4D6DqjF6qsysxTnx You should really check it out! :)
https://www.reddit.com/r/haskell/comments/7toutl/now_there_is_a_branch_to_play_with/dte5jfi/
The rotations are defined only on the 6 front faces, so the center of the cube and the centers of the faces are fixed. Did I answered you question?
Or we can rename things to remove the mystery. data List a = (:) a (List a) let ones = (:) 1 ones ones
Oh I was under impression that GHC perf was on stall until the performance numbers became more reliable. Are they reliable enough to compare throughout time/versions?
Thanks, I will.
6 faces, a face has 9 cubes, but 1 is unique to the face, 4 are shared to two faces, 4 are shared with 3 faces. 6 centers, 12 edges, 8 vertices, 26 in total. OP reaches 27 by taking 9 cubes from a 'row' times 3 columns. The center of the cube, while irrelevant to the Rubik's problem, is invariant to rotation and translation, so its the same thing.
Nice, however there is a whole section at Hackerrank devoted to functional programming. Some of the challanges appear also at the non-functional sections of Hackerrank. For example "John and Fences" is the same as "Largest Rectangle" at the Data Structures section. &amp;#x200B; When solving challanges for the Functional Programming section I always try to use as less IO Monad as possible. Usually `x &lt;- getContents` is enoguh to grab the complete input from the console and pass it to a pure function. 
Most of the HackerRank problems are quite amenable to being solved in Haskell, but the boilerplate that HackerRank spits out is awful and often longer than a solution. It's pretty nice for writing relatively terse solutions that are still moderately readable. import Control.Monad import Data.Function main :: IO () main = do n &lt;- readLn let diag = take n . map (head.head) . iterate (map tail . tail) replicateM n (map (read :: String -&gt; Int) . words &lt;$&gt; getLine) &gt;&gt;= print . abs . (((-) `on` (sum . diag)) &lt;*&gt; reverse)
Thanks! 
The newName implementation uses whatever the type of what Q wraps is (presumably IO), not the definition for Q itself. Hence there at least isn't an infinite loop directly in the code you posted 
In those cases you can also use [*`interact :: (String -&gt; String) -&gt; IO ()`*](http://hackage.haskell.org/package/base-4.11.1.0/docs/Prelude.html#v:interact) (there are also versions for `Text` and `ByteString` if those are better suited.
But we are not C programmers, nor are we writing C. If you told C programmers they get no control over memory allocation and garbage collection, they'd also lose their mind (I mean, they wouldn't, but it's the same as your comparison). I'm on the same page, but we should really measure things. If the cost of &gt;&gt;= is bad (and for the state of the art it is only a constant factor), maybe we've bought something else, like increased programmer efficiency, more code reuse, improved test access, whatever, then maybe this is justified. I am not arguing either way, just that we should evaluate the options and be aware of alternatives.
&gt; i generally assume folks who claim theres private stuff they cant share that proves them right as the likely party in the wrong. Settlements often include an NDA agreement to not disclose certain details to others. Personally, I think these should be much more aggressive pushback against, but that's the current reality that we live in. 
Type and data constructors always have to be capitalized. ``data MyWord = MyWord Word8 deriving (Eq, Show)`` is the correct form.
Like I said on the lecture, all Haskell constructors, and types, start with a capital letter. You want `data MyWord = MyWord Word8 deriving (Eq, Show)`
Yay! You can now write this: &amp;#x200B; withForeignPtr fptr \\ptr **-&gt;** c\_memcpy buf ptr size as opposed to having to put parentheses: &amp;#x200B; withForeignPtr fptr **(**\\ptr **-&gt;** c\_memcpy buf ptr size**)** Or: &amp;#x200B; main **=** hspec **do** describe "Prelude.head" **do** it "returns the first element of a list" **do** head \[23 **..**\] \`shouldBe\` (23 **::** Int) &amp;#x200B; instead of the added dollars here: &amp;#x200B; main **=** hspec **$** **do** describe "Prelude.head" **$** **do** it "returns the first element of a list" **$** **do** head \[23 **..**\] \`shouldBe\` (23 **::** Int) &amp;#x200B; &amp;#x200B;
Problem getting started with Stack &amp;#x200B; Hi, I wanted to use stack to develop an "App" and a "Lib" in two different packages, both hosted in a private git repo on my raspberry. I started by building the Lib in a package called FileDataHandler Next I wanted to use that package in my App, called SparkLines, but I am not sure how to go about it. &amp;#x200B; I have added the following lines to stack.yaml &amp;#x200B; ```` packages: # - some-directory # - https://example.com/foo/bar/baz-0.0.2.tar.gz - location: git: 'ssh://gitgod@mypie/home/gitgod/Stuff/FileDataHandler' # ```` which does not seem to cause any trouble but does not really help either... If I try to include it in the package.yaml I get an error that I am missing a version number. Any help would be appreciated
What are those features?
That makes sense. Thanks for sharing!
`*&gt;` is analogous to `;`. `&gt;&gt;=` is something completely different...
A bit lazy answer, but you can check list of companies which may have Haskell jobs [1] and collect requirements from their vacancies. You can even post results of your analysis here, it may be interesting. From what I've seen recently: * https://medium.com/@neongreen/wire-is-hiring-a-haskell-developer-and-an-operations-engineer-berlin-51e7f3ed3050 * https://www.dfinity.org/openings * https://iohk.io/careers/ [1]: https://github.com/erkmos/haskell-companies/
IMO, I don't see Eta taking off. We discussed this once at our senior architect meeting and everyone's opinion was that it would have been much better off if it was just a JVM backend for Haskell instead of a fork.
I am interested in what they have done around error reporting. I wonder how hard that would be to back-port to GHC.
I actually spent a few days getting Eta to compile our Haskell codebase at my work. Surprisingly, it was not too difficult (albeit there were some gotchas). I encountered a pretty gross bug though, but fortunately the Eta team fixed it in good time (in general they've been quite responsive). In the end, the compilation worked and our suite of unit-tests ran on the JVM! Unfortunately, the suite took 10-15s in Haskell and around 3m on the JVM, so I abandoned it. It's still early days so even though Eta is not ready for primetime yet it'll be interesting to follow their efforts.
Any more details about how exactly the senior architects came to that conclusion?
Thanks /u/ezyang for writing down the full talk! 
Basically the common sentiment was additional care will be required not just at the tooling level but also at the programming level. If Eta was a just another backend then we don't need to care which extension is supported or not, which library is compatible or not. Not to mention the tooling and development tools have limited overlap. Consider who prevalent Docker is, the only real use case that came up for Eta was Java FFI, and this wasn't really useful for us, we are doing primarily microservices. If we need to solve some problem for which there are great java libraries for, we will just make a Java microservice and connect to it using AMQP/HTTP, etc. 
I actually just started in on this book last week. The approach is interesting; the book makes a little statement, then builds on it slowly, walking the reader through the thought process of more complex ideas. It also often formats things as questions conversationally - the pages are split on half with one side asking a question - e.g., `(is 'Pair' a Type?"`, and the other side responding - e.g., "It certainly looks like it, based on the rule that types start with a capital letter."` It feels slightly silly, but overall seems to be doing a good job - it's easier to follow than, say, "Naive Set Theory", which similarly builds on small facts to create larger understanding, but just sort of "dumps" them on the reader, making it easy to get "overloaded."
Note that the definition of `Q` is newtype Q a = Q { unQ :: forall m. Quasi m =&gt; m a } not newtype Q a = forall m. Quasi m =&gt; Q { unQ :: m a } nor newtype Q a = Q { unQ :: IO a } That is, Q doesn't wrap a concrete (or even an existential) type which has a `Quasi` instance, it wraps a polymorphic action which can be specialized to any `Quasi` instance you want. If you pick `Q`'s instance, you'll get another `Q` constructor wrapping a polymorphic action, on which you can pick `Q` again, and so on; so if `Q` was the only instance of `Quasi`, we could see `Q (qNewName s)` as an indirect encoding of `Q (Q (Q (Q ...)))`. Not an infinite loop, rather an infinite data structure, but not a particularly useful one. There also an instance of `Quasi` for `IO`, but it it not very useful either, since [every operation fails with an error](http://hackage.haskell.org/package/template-haskell-2.13.0.0/docs/src/Language.Haskell.TH.Syntax.html#line-113). So if neither `Q`'s instance nor `IO`'s instance does anything, how does TemplateHaskell work? I believe ghc has some instance of `Q` which is not exposed by the template-haskell library, and that when slicing in a `Q Exp`, it uses this secret instance to obtain the `Exp`. A quick search through the code did reveal [an instance of `Q`](https://github.com/ghc/ghc/blob/6bb9bc7d3c935dcb77e0700cce28de2c9df646df/libraries/ghci/GHCi/TH.hs#L168) and an internal [`runQuasi`](https://github.com/ghc/ghc/blob/1c2c2d3dfd4c36884b22163872feb87122b4528d/compiler/typecheck/TcSplice.hs#L635) which interprets a `Q a` into some internal GHC representation, but both of those seem specific to `GHCi`, which makes me think that there must be some other template-haskell code somewhere for compiled programs.
The branch corresponding to the "As-pattern synonyms" proposal was deleted when it was closed, so the "rendered" link is a dead link. [here is a working link](https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0016-as-patterns-synonyms.rst).
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [ghc-proposals/ghc-proposals/.../**0016-as-patterns-synonyms.rst** (master → b58d645)](https://github.com/ghc-proposals/ghc-proposals/blob/b58d64543fd7bb548aa4b46d0e56115f4c813a06/proposals/0016-as-patterns-synonyms.rst) ---- 
In this format it stays true to its predecessors, The Little Schemer, The Seasoned Schemer and The Reasoned Schemer. All three are awesome books, the first two focusing on functional programming concepts and the third talking about logic programming. I can't recommend them enough!
Thx, I wish I have reddit gold.
There's also A Little Java, the Little MLer, and the Little Prover. Every "Little" book is excellent in it's own right!
Prelude Lens.Micro&gt; foo :: (Int, Int) -&gt; \[Int\]; foo = \_ &amp;#x200B; &lt;interactive&gt;:44:35: error: \* Found hole: \_ :: (Int, Int) -&gt; \[Int\] \* In the expression: \_ In an equation for \`foo': foo = \_ \* Relevant bindings include foo :: (Int, Int) -&gt; \[Int\] (bound at &lt;interactive&gt;:44:29) Valid hole fits include foo :: (Int, Int) -&gt; \[Int\] mempty :: forall a. Monoid a =&gt; a Valid refinement hole fits include concatMap (\_ :: Int -&gt; \[Int\]) where concatMap :: forall (t :: \* -&gt; \*) a b. Foldable t =&gt; (a -&gt; \[b\]) -&gt; t a -&gt; \[b\] uncurry (\_ :: Int -&gt; Int -&gt; \[Int\]) where uncurry :: forall a b c. (a -&gt; b -&gt; c) -&gt; (a, b) -&gt; c toListOf (\_ :: Getting (base-4.12.0.0:Data.Semigroup.Internal.Endo \[Int\]) (Int, Int) Int) where toListOf :: forall a s. Getting (base-4.12.0.0:Data.Semigroup.Internal.Endo \[a\]) s a \-&gt; s -&gt; \[a\] const (\_ :: \[Int\]) where const :: forall a b. a -&gt; b -&gt; a foldMap (\_ :: Int -&gt; \[Int\]) where foldMap :: forall (t :: \* -&gt; \*) m a. (Foldable t, Monoid m) =&gt; (a -&gt; m) -&gt; t a -&gt; m &amp;#x200B; Prelude Lens.Micro&gt; foo :: (Int, Int) -&gt; \[Int\]; foo = toListOf \_ &amp;#x200B; &lt;interactive&gt;:45:44: error: \* Found hole: \_ :: Getting (base-4.12.0.0:Data.Semigroup.Internal.Endo \[Int\]) (Int, Int) Int \* In the first argument of \`toListOf', namely \`\_' In the expression: toListOf \_ In an equation for \`foo': foo = toListOf \_ \* Relevant bindings include foo :: (Int, Int) -&gt; \[Int\] (bound at &lt;interactive&gt;:45:29) Valid hole fits include both :: forall a b. Traversal (a, a) (b, b) a b folded :: forall (f :: \* -&gt; \*) a. Foldable f =&gt; SimpleFold (f a) a traverse :: forall (t :: \* -&gt; \*) (f :: \* -&gt; \*) a b. (Traversable t, Applicative f) =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b) traversed :: forall (f :: \* -&gt; \*) a b. Traversable f =&gt; Traversal (f a) (f b) a b each :: forall s t a b. Lens.Micro.Internal.Each s t a b =&gt; Traversal s t a b Valid refinement hole fits include to (\_ :: (Int, Int) -&gt; Int) where to :: forall s a. (s -&gt; a) -&gt; SimpleGetter s a lens (\_ :: (Int, Int) -&gt; Int) (\_ :: (Int, Int) -&gt; Int -&gt; (Int, Int)) where lens :: forall s a b t. (s -&gt; a) -&gt; (s -&gt; b -&gt; t) -&gt; Lens s t a b folding (\_ :: (Int, Int) -&gt; \[Int\]) where folding :: forall (f :: \* -&gt; \*) s a. Foldable f =&gt; (s -&gt; f a) -&gt; SimpleFold s a traverseOf (\_ :: LensLike (Data.Functor.Const.Const (base-4.12.0.0:Data.Semigroup.Internal.Endo \[Int\])) (Int, Int) (Int, Int) Int Int) where traverseOf :: forall (f :: \* -&gt; \*) s t a b. LensLike f s t a b -&gt; (a -&gt; f b) -&gt; s -&gt; f t (%\~) (\_ :: ASetter (Int, Int) (Data.Functor.Const.Const (base-4.12.0.0:Data.Semigroup.Internal.Endo \[Int\]) (Int, Int)) Int (Data.Functor.Const.Const (base-4.12.0.0:Data.Semigroup.Internal.Endo \[Int\]) Int)) where (%\~) :: forall s t a b. ASetter s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t Prelude Lens.Micro&gt; foo :: (Int, Int) -&gt; \[Int\]; foo = toListOf both -- or toListOf each
For people who are wondering what Growl is (mentioned in the Q&amp;A), that's a typo, it should be [Graal](https://www.graalvm.org/).
Are the examples for it in Haskell? I'm interested to learn about dependent types, would this book be a practical place to start?
`Eff` is the Milhouse of monads.
If the LYAH helps you and keeps you interested, then by all means keep reading. But as far as a practical view of Haskell code it doesn't do that great of a job. I read the whole book then sat down to try and write some 'real world' code and was completely lost. www.haskellbook.com is very good so is graham huttons Programming Haskell (available on amazon)
I have a few SPA projects running in production, making money for businesses. I use Elm on the front, and Yesod in the back. Not once have I ever thought “oh I wish this web framework were more light-weight”. In fact, I’ve worked on another project once which was in one the frameworks that gives you less stuff, and an up-front problem was “hmm… how should we do logging?” To me, that’s a completely uninteresting problem. I see no reason not to just use Yesod.
Yes
How does `freer-simple` compare performance wise to the `operational` package ?
&gt; And do you live in Europe, preferably in Helsinki, Finland? Are you willing to sponsor visas for non-EU people?
At best it sounds like a mis-statement. There are various ways to prove totality; for example, the Idris compiler can reason about structural recursion over "smaller" pieces of inductive data types. This results in a compile-time "proof" of termination with no run-time witness required. It is true that sometimes one has trouble ensuring that proof terms get erased in dependently-typed systems, which can cause code size issues and even changes in asymptotic complexity. That's not a totality-specific issue, although it could well apply to scenarios where one had a type encoding a proof of totality.
They’re in Pie, which is a small language developed for the book. 
As the maintainer of freer-simple and the author of its documentation, this is a really solid (and useful) blog post. I would love to improve the documentation based on what people find confusing, so this is incredibly helpful. I do think I disagree with this statement slightly: &gt; The big downside that would stop freer monads becoming ubiquitous is performance, in certain situations they can be up to 30x slower than a monad transformer. **Unfortunately there are fundamental limits on how much this could be improved, so monad transformers will always be faster.** Emphasis mine. There is no *fundamental, theoretical* reason that the extensible effects interface *has* to be slower. It is true that it seems impossible to retain the current interface and improve performance in GHC as it exists today, but this is not fundamental. Fundamentally, extensible effects could theoretically be harder to optimize only because effect handlers are first-class, while typeclass instances (which are the equivalent to effect handlers in transformers/mtl style) are second-class. This means that the effect handler can be determined dynamically, at runtime, which is far more difficult to optimize. **However**, in practice, I find that effect handlers are almost always used in an entirely static way. Different handlers are used in the executable and in the test suite, but this choice is known statically, at build time. A sufficiently smart compiler could “see through” the machinery used to implement extensible effects and make it as fast as transformers/mtl style. Of course, a “sufficiently smart compiler” is often an impractical target. I think it’s highly unlikely that any performant compiler could be clever enough to optimize freer-simple to be as fast as mtl style. Still, this does not mean you should give up hope: a compiler with a little more support for things extensible effect systems do would allow extensible effects to be implemented in more optimizer-friendly ways, which could very well actually be made far faster. This is obviously largely irrelevant right now—all of this is theoretical handwaving. *Currently*, if you need performance, mtl style will be better. I just think it’s premature to think that extensible effects will *always* be slower, and I hope that further research can help move towards the performance we’d like! In any case, that tangent aside, this helps inform how the freer-simple documentation can be improved. I probably won’t get to making any changes to freer-simple this week, as I am currently at ICFP, but hopefully I’ll get some time to look into that soon.
You should probably open an issue on the repo. `deriveJSONAndTypeScript someOptions ''Currency` constructs the following instance: instance TypeScript (a :: Symbol) =&gt; TypeScript (Currency a) where and there is no `TypeScript` instance for symbols, used later for `ExchangeRates`. This library seems to assume that types are only indexed by types, and not symbols or other things. Either a `TypeScript` instance for symbols must be added, if it makes sense, or the derive script must avoid generating such a constraint in the first place.
TIL! Thanks!
This is likely an issue with your particular email provider's setup? We've been getting trustee emails regularly over the past few days, and I just sent a test one myself to confirm. Message me privately with your email address and we can sort this out.
This is awesome!! I was procrastinating integrating HsLua because I thought I would have to do some tricky things to avoid the exception issues, and now that's all sorted. I think its wonderful that haskell has tight bindings to a great configuration/scripting language. Thank you very much Albert!
I'm not surprised that the performance isn't great. Memory allocation and garbage collection are both handled very specially in GHC Haskell compared to other languages. Does Eta use the JVM's GC and allocator or does it implement something more like GHC? The [GC does several optimizations](https://osa1.net/posts/2018-03-16-gc-optimizations.html) on code at runtime; I've been told that losing the "Selector Thunk Evaluation" is a surprisingly massive performance killer. Allocation in GHC, if I understand correctly, is practically as cheap as incrementing a pointer; not so with JVM's allocator.
Haskell doesn't truly support Dependent Types (and uses some pretty hard-to-follow antics to emulate them). If you like a Haskell-ish Syntax and want real dependent types, then Idris is your best bet these days and has an excellent book. Maybe 3 years we might have instead said Agda, which is really good but qf I like the Idris book more. :)
Let's just all agree more people should try out Idris and see how awesome that work is. Especially the editor integration where you go, "So, computer. Why don't you TELL me what you think this program should be?!"
You have a few options. First off, you can run `stack setup ghc-8.6.1` to have stack install this version of ghc for you. You can try it out with `stack repl --resolver ghc-8.6.1` Next, you can define projects with ``` resolver: ghc-8.6.1 ``` And then specify *all* of your project's dependencies in `extra-deps`. Alternatively, you can try a `nightly` or `lts` resolver as usual, but override the compiler. For example: ``` resolver: nightly-2018-09-23 compiler: ghc-8.6.1 compiler-check: match-exact ``` However, various packages in that nightly snapshot may not build correctly with the new ghc, so use this sort of approach with caution.
yes, I always wondered why the official docs cannot simply link to blog posts and other written material. &amp;#x200B;
Thanks, the error message makes a lot more sense now! For anyone who comes across this post in the future, I fixed this by manually writing the following instance for Symbol types (and I'll probably open an issue on the Aeson repo): instance (KnownSymbol s) =&gt; TypeScript (s :: Symbol) where getTypeScriptType s = "\\"" ++ symbolVal s ++ "\\""
Here's the reference [https://existentialtype.wordpress.com/2014/03/20/old-neglected-theorems-are-still-theorems/](https://existentialtype.wordpress.com/2014/03/20/old-neglected-theorems-are-still-theorems/). It's about the Bloom Size Theorem which is a linked paper. I can explain more later... but dinner now.
*The Little Typer does not attempt to teach either practical programming skills or a fully rigorous approach to types. Instead, it demonstrates the most beautiful aspects as simply as possible, one step at a time.* What does it cover? I have some basics in idris and I'm currently reading software foundation so I kind of know what are dependent types. However, I'm not really familiar with the math part.
How often do you have openings? I am living in Espoo and unable to apply in the next year but very interested. Do you have a newsletter / email list to stay updated if you need people later on?
Is there a library that can render SQL queries without requiring a database connection?
Thank you then. I will try to keep an eye out for whatever you happen to be doing.
Does composing more interpreters contribute significantly to making it slower?
A program using this would likely contain this boilerplate a lot `:: Members '[ ... ] effs =&gt; Eff effs` I wonder if that could somehow be made easier to write.
It gives a story for how to think about dependent types, how they can arise in the course of giving characterizations to programs, and motivates the increasing power of various induction or recursion schemes to capture universally the sorts of reasoning we can use a priori over such types, with special attention paid to equality and proofs (though only 1-equality -- i.e. classical mltt and not any of the higher-order/homotopic variants that have arisen).
You typically only make your Members [concrete in one place](https://github.com/aurapm/aura/blob/master/aura/exec/aura.hs#L86). Then your individual functions [look like this](https://github.com/aurapm/aura/blob/master/aura/lib/Aura/State.hs#L156) to avoid any strict ordering of effects. If those long signatures are gross, it's not hard to hide it behind a type alias.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [aurapm/aura/.../**State.hs#L156** (master → 3c43282)](https://github.com/aurapm/aura/blob/3c43282a36b667910031caea1ccd837759c06afe/aura/lib/Aura/State.hs#L156) * [aurapm/aura/.../**aura.hs#L86** (master → 3c43282)](https://github.com/aurapm/aura/blob/3c43282a36b667910031caea1ccd837759c06afe/aura/exec/aura.hs#L86) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e6l1ehh.)
as a followup: I'm working with OP offthread. It looks like its an issue with certain microsoft email services picking up a blacklisting for haskell.org. email admin is the worst!
I have a CSV file as input and I want to output a file with some SQL queries. I would like to have some code that safely escapes the query bindings to avoid injection and bad data, etc from input CSV files. `postgresql-simple` has some helper functions that can render queries to ByteStrings but it requires an actual database connection for some reason. And this seems to be a common feature among the libraries I have found so far: `squeal-postgresql`, `esqueleto`, `persistent`, `HaskellDB`. It's probably not a common use-case but I'm hoping someone out there knows about another library or how to trick one of these libraries to use a mock connection so I can render queries.
 type WithEffs ms es = Members ms es =&gt; Eff es Haven't checked it but I think this should work, perhaps with some extension.
There's really not much of a "sponsor visas" thing in Finland, unless you really need a Schengen visa: https://migri.fi/en/artikkeli/-/asset_publisher/erityisasiantuntija-voit-tulla-toihin-suomeen-kolmeksi-kuukaudeksi-ilman-oleskelulupaa https://migri.fi/en/specialist/en
[removed]
I'm trying out recursion-schemes, and trying to compose para morphisms. type ParaF t a = Base t (t, a) type ParaAlg t a = Functor (Base t) =&gt; ParaF t a -&gt; a funzipPara :: Functor (Base t) =&gt; ParaF t (a,b) -&gt; (ParaF t a, ParaF t b) funzipPara = fmap (fst &amp;&amp;&amp; fst.snd ) &amp;&amp;&amp; fmap (fst &amp;&amp;&amp; snd.snd) combineParaAlg :: (Functor (Base t)) =&gt; ParaAlg t a -&gt; -- The first t-algebra ParaAlg t b -&gt; -- The second t-algebra ParaAlg t (a,b) -- The combined t-algebra combineParaAlg f g = (f \*\*\* g) . funzipPara This works, but it recurses down the tree once for each algebra. Is it possible to apply two algebra so that there is only one recursion?
Next step: `inline-lua`
GHC wiki, migration to 8.6 section?
OK, I've changed it to be a bit more accurate, thanks!
Sorry, I've only used `freer-simple` so far.
I guess it would, probably there are more optimizations that GHC can do if all paths are using the same code, probably depends on your interpreters quite a bit and I would imagine the effect is very small. The only way to know for sure, benchmark.
I ran it many times, but I suppose the JVM started cold each time. In any case, I probably could have done some profiling to see if it might be a pathological case that some of our code triggered, but I ran out of time to spare. 
Not my paper: just thought it was really interesting and it doesn't seem to have been mentioned in this subreddit before.
&gt; the only real use case that came up for Eta was Java FFI It's not just FFI, JVM gives you good profiling, monitoring, stacktraces, better optimizations with HotSpot, dynamic linking, etc. If Eta was _just_ a backend for ghc it wouldn't be able to reap the benefits of _tight_ integration with JVM, but as a fork, they are able to focus on that. GHC is not modular enough yet to integrate back GHCJS and Eta.
I wouldn't hold my breath: https://twitter.com/d_christiansen/status/1042086809830739968
Sweet!
Good luck, i have currently completed chapter 10, i love the book.
I tried it out in the end and installed 10.14. Everything seems to work as before.
Oh yeah, my wording was loose. What I meant was "are you willing to support people coming in from outside the EU with whatever kind of stuff they might need to work onsite with you".
I'm not sure if the paper mentioned it, but judging by the code and auther name's email, I think this is the corresponding Hackage package: http://hackage.haskell.org/package/learn-physics-0.6.3
Sorry, I can't seem to find Martin's response, but yeah we help getting work permits and stuff.
Aura is the only project I found via hackage reverse dependencies that uses freer-simple. Why did you decide to use it and how did it all work out? Was it a good decision conpared to MTL? Also, I love aura, use it myself and think the code looks clean! Thanks for building it :)
What if I already know a lot of Quantum Mechanics and just a little Haskell. Is there a "Learn Haskell with Quantum Mechanics" paper out there? For quite a lot of us QM is a lot easier than type theory. LOL.
Seems very similar to https://pursuit.purescript.org/packages/purescript-logging
Ah, so the paper itself can't be used to learn Quantum Mechanics, that's the purpose of his university course. So then the paper is a description of the course, as well as the primitives it uses.
Thanks :) I've been following `extensible-effects` for a few years, and really like the idea. `freer-simple` is the "third generation" of these libs, and currently seems to have the most momentum / best documentation / best API. I used it to replace a fixed transformer stack, the `Aura` monad, which was ReaderT-over-ExceptT-over-IO. I first pulled out `ExceptT`, leaving the classic "rio" structure, which was kind of nice. Then I threw that all out in favour of `freer-simple`, which allowed me to reduce the number of available effects in certain functions, as `mtl` does. The usage of the API became much nicer overall. Performance-wise, Aura is `IO`-bound, so the "free monad churn" isn't a factor for me. For now I'm sticking to just native effects - `Reader`, `Error`, and an embedded `IO` - but I feel that if I wanted to extend that (say by splitting up `IO`), it would be much easier than `mtl` (i.e. having to write my own `MonadFoo` classes).
You should rename it so that Combinatorial is just before Logging, then you can call it "CO-CO-CO-CO-COMBO LOGGING!!"
Yes, that’s great, and completely fair. Thanks again!
dang this is really cool!
Funny you say that - my impression glancing through the paper was it was targeted at people who don't know Haskell, and I was hoping for something closer to what the headline implied: an explanation of QM through our vocabulary, like products, functors, composition, etc.
Great, I think I'll buy it then, thank you :)
If this is a co-logger, does it mean it eats up your logs rather than creating new ones?
So what do you want the OP to do? Omit the name of the book that will be used, for the sake of heaven knows what?
With such amount of bikeshedding, I wonder why Haskellers get surprised when almost nobody serious about programming takes Haskell seriously.
I've got a bunch of function (endomorphisms) that I have to compose all together. The issue is that I have some constraints (some functions must be called before some others). For example: Let's say I have the functions a, b, c, d and e a must be called before c (not necessarily just before, it's possible to have other function calls between them) b and c must be called before d So a possible combination would be e . d . c . b . a I'm not sure on how to statically enforce this.
I too would like to know more about this. For example, how does that problem manifest in [this definition of GCD in Idris](https://stackoverflow.com/a/50666314/1364288)? Also I've heard that dependently typed languages can throw away proofs once they have checked them during compilation, so they don't need to be run with the program itself. Does that help in any way with the slowdown?
&gt; This premise is completely incorrect, unless you play within an extremely strict and oppressively small subset of the language. I hope you realize this sooner rather than later. if you're talking about stuff like wartremover – most of its rules have zilch to do with referential transparency and a lot to do with blind hate on subtyping or are simply batshit insane (ban default arguments? really?). A language can be safe without being a sugared lambda calculus. &gt; but they will not be able to step into the source of compiled module dependencies by sheer fact of how the ecosystem works - how would it? It's compiled. If you're looking for a JAR-type source grepper, build something which greps Hoogle or Hayoo. I'm sure it will be welcome. I wonder what are the gigabytes of hscolour files with the source code of my dependencies doing on my hard drive if the ecosystem just can't work like that? I bet they were piped from /dev/urandom/ by sheer coincidence. You can't even hypothetically end up with no access to the source code – there are no binary distributed libs, and there's no possibility for them because of binary incompatibilities not even between different versions of the compiler, but between different builds of the same compiler – ghc build is still not reproducible (AFAIK?). &gt; So? It's the same story in every language. There is no wait to get around it as a programmer. This is a very lazy way to think. There's no way to get around it, but there's a way to cut down the time required to do it by an order of magnitude. It's called a working integrated development environment with a working module browser &amp; interactive worksheets. &gt; I don't care about an intended api. I care about what function does. It's impossible to reason about this in Scala. Can you reason about [this function](http://hackage.haskell.org/package/yaml-0.10.2.0/docs/Data-Yaml.html#v:decodeEither-39-)? Do you seriously program on assumption as if Haskell's type system was sound? If so, what's wrong with applying the same loose reasoning to an RT subset of Scala? &gt; That snipped is uh... haha very bad. He must've stolen it from John's attempts to reinvent the wheel. It's sound. What's the issue? &gt; It is not any more convenient than having to grep Hoogle if you understand how types work... or don't work. The difference in time between seeing the types and type errors instantly and spending 30 seconds on a hoogle query is infinite. &gt; Scala will give you no more information than an undecompilable module, because you cannot derive equational information from its code. You gotta pick straw men you can win against, even purely theorically any imperative code can be transformed into equivalent pure CPS – derive all you need. In practice, the code I write and use is already RT, the equational information is directly available. &gt; Unless you are in a very very strict context Nothing wrong with that. &gt; I'm not being a tool apologist here. Haskell's tools have reached the same level (albeit, without compileds source grepping, sure) that something like Intellij has with minimal effort. There isn't even a working rename refactoring (VScode HIE). No one's talking about grepping compiled source in Intellij, there's source jars. 
Phantom type! newtype TaggedState a b c x = TaggedState x data Done -- a turns the tag for "a is done" from () to Done a :: TaggedState () b c x -&gt; TaggedState Done b c x -- b turns the tag for "b is done" from () to Done b :: TaggedState a () c x -&gt; TaggedState a Done c x -- c must be called only if "b is done" tag is Done -- and turns "c is done" from () to Done c :: TaggedState Done b () x -&gt; TaggedState Done b Done x -- d must be called only if "b is done" tag and "c is done" tag -- are Done d :: TaggedState a Done Done x -&gt; TaggedState a Done Done x -- e do not cares tags e :: TaggedState a b c x -&gt; TaggedState a b c x process :: TaggedState () () () x -&gt; TaggedState Done Done Done x process = e . d . c . b . a anotherProcess :: TaggedState () () () x -&gt; TaggedState Done Done Done x anotherProcess = d . c . a . b . e This goes more and more complex as constraints grow, so consider more powerful type-level programming tool like TypeFamilies or DataKinds if you need. (Sorry, I wanted to provide a link explaining these but I couldn't find a handy one.)
Yes and no. They make for decent real world use cases. But libraries might not build with future GHC versions making comparison hard if you update the libraries.
Why do you think “nobody serious about programming takes Haskell seriously?”
This is cool, I've always used [https://www.musictheory.net/exercises/ear-interval](https://www.musictheory.net/exercises/ear-interval) for this which works pretty well, but seems like a fun project!
Naming suggestions are always appreciated! I like `contramapM` more as well. 
I can personally understand forking the compiler like GHCJS did. But I personally strongly disagree with forking the language itself. Once Eta and Haskell deviate sufficiently you will lose the interop with the Haskell ecosystem, which seems like it will make it way too niche to thrive. The main reason I like GHCJS so much is that the vast majority of the time I'm coding in regular Haskell with all the lovely Haskell libraries I like, occasionally using JS FFI or JS libraries as needed. If I had to build primarily off of JS libraries I would not be using it or supporting it. 
With that said I will say Haskell (the language, ignoring popularity and libraries for now) is excellent at basically everything. With the exceptions being hard correctness requirements (Coq, Idris, Agda), hard perf/pause requirements (C, C++, Rust) and perhaps situations where a scripting language (Lua, Lisp) is more appropriate. 
I'd say `&gt;&gt;=` is just as close as `*&gt;' to `;` a = foo(); bar(a); Is equivalent to `&gt;&gt;=` foo(); bar(); Is equivalent to `*&gt;` 
I should maybe point out that by replacing every instance of the number 12 with a higher number, you can learn to distinguish microtones. Elsewhere I have made [the case that the next step after 12 is 31](https://msu.edu/~brown202/31et/index.html). The argument, in brief, is that 31et approximates the 5th harmonic far better than 12 does, 31et approximates the 7th harmonic very well while 12et doesn't even try, 31et gives decent approximations to harmonics 11 and 13 which 12et doesn't even try, 31 gives an excellent approximation to harmonics 17 and 19 which are higher than ordinary humans can hear before pitch blurs into timbre, and the cost is only a very slight worsening in the approximation to the 3rd harmonic. The only microtonal system with no more than 31 tones that sacrifices less harmonic accuracy is 24et, but 24et is no better at any of the harmonics below the 11th. 53 arguably dominates 31, but I've tried playing it (on a monome) and it's unbelievably hard; you've got to keep track of two different kinds of major second, which ain't nobody got time for.
Long ago I used Practica Musica, which was seriously amazing. It does way more than EarTrain.Vivid. However, there's something to be said for customizability. If you can pair sounds with labels, Vivid.EarTrain lets you drill yourself on them. It doesn't have to be in 12 tone equal temperament (see my other comment), and it doesn't even have to be about harmony -- you could train for perfect pitch, or for a sense of timing, or learn to distinguish different kinds of timbres. I should probably add that to the comments at the top of the file. Thanks for the prompt!
I can't focus well enough to really read this yet, so I'll just point out two things about the setup: First, `HasLog env msg m` seems to be just a lens from `env` to `LogAction m msg`, so there's *probably* some things you can do to streamline that. Second, the `Semigroup` and `Monoid` instances for `LogAction m msg` can be automatically derived (albeit with, perhaps, too many imports): {-# language DerivingVia #-} import Data.Monoid import Control.Monad.Reader import Data.Functor.Compose import Data.Functor.Identity newtype LogAction m msg = LogAction {runLogAction :: msg -&gt; m ()} deriving (Semigroup, Monoid) via (Ap (Compose (Reader msg) m) ()) Both of these feel kinda obvious to me, but my knowledge is not necessarily your knowledge, and I found it relevant.
Seriously? You see no ad like promotion for the book in the post? Anyway. A fool and their money is soon parted. I am not going to ruin my day over it...
It's not supposed to be, but in a sense it's a very direct ad for the book. In fact since I've gone through it once already it's basically a testimony plus ad! On the other hand I'm not gaining anything from sales, and am not associated with the authors in any way.
I assume you're taking about the price being in there? That's for the simple reason of honesty: if anything it has a negative effect as students (who are fairly likely to be interested) are put off by such a large number.
Oh dear. Does the first one really compile? That makes me sad. (I also don't like the latter one particularly, but at least the "introducer" do is a sign that something special is about to happen with layout. IME \\ is used way too much in various contexts where it being greedy makes little sense.)
Where do you get these operators from? The "contravariant" package certainly does not export them. ``` (&gt;*&lt;) :: Divisible f =&gt; f a -&gt; f b -&gt; f (a, b) (&gt;|&lt;) :: Decidable f =&gt; f a -&gt; f b -&gt; f (Either a b) (&gt;*) :: Divisible f =&gt; f a -&gt; f () -&gt; f a (*&lt;) :: Divisible f =&gt; f () -&gt; f a -&gt; f a ```
&gt; For example, how does that problem manifest in this definition of GCD in Idris? It may not - I think the theorem is just saying that it's demonstrable that there exists pathological cases, not that cases we're interested in tend to be pathological.
These operators were introduced in this video by George Wilson: * https://www.youtube.com/watch?v=IJ_bVVsQhvc I found those operators extremely useful. So I've opened the following issue in `contravariant` package to add these operators: * https://github.com/ekmett/contravariant/issues/57 And while these operators are not in the `contravariant` package, `co-log-core` has specialised versions of them: * http://hackage.haskell.org/package/co-log-core-0.0.0/docs/Colog-Core-Action.html#v:-62--42--60-
That first point makes a lot of sense. Thanks for explaining. For the second point, I was mostly trying to point out that your `Monoid` instance is the canonical "applicative wrapping a monoid" instance, specialized for the composition of the `Reader msg` and `m` applicatives and the trivial monoid.
What could this be used for?
 I tried to make a simple algebra to demonstrate: ``` data MyExpr a = AExpr a | BExpr (MyExpr a) (MyExpr a) deriving (Show, Eq, Functor) makeBaseFunctor ''MyExpr af' = AExprF bf' = BExprF af = AExpr bf = BExpr myTracer :: String -&gt; (MyExprF Int (MyExpr Int, Int) -&gt; Int) myTracer s tree = case tree of BExprF a b -&gt; traceShow (s ++ show (snd a + snd b)) (snd a + snd b) AExprF x -&gt; traceShow (s ++ "1") 1 myTracers :: MyExprF Int (MyExpr Int, (Int,Int)) -&gt; (Int,Int) myTracers = algebra1 `combineParaAlg` algebra2 where algebra1 = myTracer "First pass:" algebra2 = myTracer "Second pass:" someFunc2 :: IO () someFunc2 = print result where tree = bf (af 0) (af 1) result = para algebra tree algebra = myTracers ``` Running someFunc2 gives the following: "First pass:1" "First pass:1" "First pass:2" "Second pass:1" "Second pass:1" "Second pass:2" (2,2) which implies that it's recursing through the first algebra, THEN the second. Could it be the trace function? P.P.S (id *** fst) = (second fst)
Because: https://www.google.es/search?safe=active&amp;rlz=1C1GGRV_enES805ES805&amp;tbm=isch&amp;q=Peacock&amp;chips=q:peacock,online_chips:peacock+dance&amp;sa=X&amp;ved=0ahUKEwjq67W13tjdAhWEo4sKHSCADqUQ4lYIKSgC&amp;biw=1280&amp;bih=953&amp;dpr=1
FWIW I don't find that these `Divisible` operators compose or generalise well. I prefer \a b -&gt; contramap fst a &lt;&gt; contramap snd b \a b -&gt; a &lt;&gt; contramap (const ()) b \a b -&gt; contramap (const ()) a &lt;&gt; b Trying to make `Divisible` look too much like `Applicative` hasn't turned out to be very useful in my experience. At most I would suggest adding something like fromUnit :: Contravariant f =&gt; f () -&gt; f a fromUnit = contramap (const ()) 
Concerning `fromUnit` see [phantom](http://hackage.haskell.org/package/contravariant-1.5/docs/Data-Functor-Contravariant.html#v:phantom).
That's caused by lazy evaluation. When `(x,y)` is printed, first `x` is forced, then `y` is forced. Forcing `x` does not force any part of `y`. So traces for `x` were printed out first, then traces for `y` were printed out. But you built both *thunk* one-pass. Compare following examples. someFunc3 :: IO () someFunc3 = print result where step a (x,y) = (trace ("A " ++ show a) (x + a), trace ("B " ++ show a) (y + a)) result = foldr step (0,0) [1,2,3,4::Int] someFunc4 :: IO () someFunc4 = print result where step' a (!x,!y) = (trace ("A " ++ show a) (x + a), trace ("B " ++ show a) (y + a)) result = foldr step' (0,0) [1,2,3,4::Int]
&gt; Seriously? You see no ad like promotion for the book in the post? They didn't say that. The problem is how do you get rid of ads in disguise whilst still allowing users to share study groups and the like? Disguises only work because the thing they're disguised as are a plausible and reasonable thing to be. If this is an ad for the book disguised as an ad for a study group, it's because ads for study groups are plausible and reasonable posts to create. So how do you allow those reasonable posts whilst disallowing secret commercial ads? Do you have a rule saying that the name of the book should not be shared for such a study group? This is pertinent information that is important to some people when making a decision to join or not.
That's wonderful. Thanks
Thank you for the reply!
I am, like, 99% sure that hotspot allocation uses thread local buffers with pointer bump allocation. If the buffer is full we call the gc, just like in ghc. I can't quite recall if selector thunk were more relevant for runtime or memory usage. But the write barriers probably make a difference as well since updating all the thunks without the promotion trickery from ghc causes a ton of mutation. 
 apply :: (forall a. a -&gt; a) -&gt; (Int, String) apply f = (f @Int 0, f @String "hello") with [`TypeApplications`](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#visible-type-application) f :: forall a. a -&gt; a f @Int :: Int -&gt; Int f @String :: String -&gt; String
They came later [in GHC 8.0](http://mpickering.github.io/posts/2015-12-12-pattern-synonyms-8.html) ([pattern synonyms](http://mpickering.github.io/posts/2015-12-12-pattern-synonyms-8.html) since 7.8) 
It's not an operator, it's part of `do` notation syntax. If it were an operator, then `main = do { line &lt;- getLine }` would be valid, but it's not. As to what you'd call it; I've seen it referred to as a "binding" or "bind", or "variable bind", but that's slightly confusing, because `&gt;&gt;=` (which *is* a proper operator) is also conventionally called "bind".
I had wondered why users of electric guitar used power chords so often. Your site explained it. Thanks!
The typically recommended learning resources are: * Real World Haskell (RWH) * Haskell Programming: From First Principles (a.k.a. Haskell book) * Learn you a Haskell (LYAH) * Programming in Haskell (by Graham Hutton) * CIS 194: Introduction to Haskell course * Try your own project and consult these books/API docs/Reddit/IRC/Slack/SO when you get stuck. * Probably some more that I'm forgetting right now. Unless you already know some other similar language like OCaml, jumping into a new codebase and trying to learn Haskell at the same time might not be the best idea.
It's the first "The Little" book I've read, and I'm definitely enjoying it a lot so far. The format is a bit silly, but quite cute at the same time. While I am at it, if there are other readers here, I am confused by the "Final Second Commandment of lambda" on page 140. Any insight would be appreciated. My confusion is two-fold. First, what does it mean for "y" to not occur in "f", since "y" is anyway only bound in the type of "f"? Is that a typo and was it meant "does not occur in X"? And second, isn't the conclusion simply eta-expansion? Does eta-expansion not hold over dependently-typed functions in general? I should know that, but I'm suddenly confused.
In Haskell, an operator is just an infix function. `main = do { line * getLine }` is invalid, but not in the "invalid syntax" sense - the syntax is alright, it just doesn't typecheck. We can even fix that: ``` instance Num (IO String) where (*) = (&gt;&gt;) line :: IO String line = return "Hello!" main = do { line * getLine } ``` Try it!
Operators in Haskell, like \*, are ordinary functions, whereas &lt;- is special syntax and not a function/operator. The reason your example is invalid is because it doesn't typecheck, not because of whether or not \* is an operator. 
I challenge your assumption that logging is a simple task. I also don’t see what’s dishonest about anything proposed here. 
μονοπάτι ;-) 
Yep even printing may be complex in haskell http://i.imgur.com/6FhL6QJ.jpg I'm surprised by the non existence of print "hello world" frameworks in hackage (comonadically, of course). Maybe I didn't search well.
Operators *are* functions; the only differences are syntactic.
so basically openresty in haskell instead of lua?
If I recall correctly, the first is from the release notes. Why would a compilation error be better? In the contexts where greedy \ doesn’t make sense, it will be parenthesised as now, won’t it?
Looks promising. But I curious, why String and not ByteString (if you not like to use FilePath -- BS looks better). And other note -- if you provide own implementations for posix and/or windows, why not use `unix` instead `directory`? (I know, my notes is very opinionated)
The code I’ve seen there is really very good, especially the property tests.
I see a post spreading the word about a study group somewhere in the world, like scores of similar posts submitted here over the years, and I have no reason to doubt its authenticity. Harrying the OP because their choice of words supposedly sounds "ad like" is unfriendly behaviour, and we should not encourage that here. 
Looks like a [`cokmap`](https://github.com/ElvishJerricco/kleisli-functors/blob/d0bde122c1d0c988b16d3737bba712931b25c963/src/Control/Kleisli/Functor.hs#L48) to me.
There is a close correspondence between the operators `(.)`, `(&lt;=&lt;)`, and `(&amp;)`, `(&gt;&gt;=)` respectively. The first two correspond to "compositional thinking", i.e. thinking in terms of making functions out of functions. The other two are more about thinking "serially", i.e. in terms of a series of steps that happen in a certain order. `(&gt;&gt;=)` is called *bind*, because it allows you to name things, i.e. to bind the results of monadic actions `m a` to names. The `(&lt;=&lt;)` is analogous to the function composition operator and is called Kleisli composition, among others. Compare this contrived example: import Control.Monad (filterM, foldM, (&lt;=&lt;)) import Data.Function ((&amp;)) -- (&amp;) = flip ($) -- Point-free style. transmogrify :: [Int] -&gt; Int transmogrify = sum . map (+ 42) . filter even -- We use let bindings to bind intermediate results to names. moreDescriptive :: [Int] -&gt; Int moreDescriptive ints = let evens = filter even ints truthed = map (+ 42) ints result = sum truthed in result -- Oh no, we can't use let anymore. We shall instead use -- (&amp;) :: a -&gt; (a -&gt; b) -&gt; b. withoutLet :: [Int] -&gt; Int withoutLet ints = ints &amp; filter even &amp; \evens -&gt; evens &amp; map (+ 42) &amp; \truthed -&gt; truthed &amp; sum &amp; \result -&gt; result simplified :: [Int] -&gt; Int simplified ints = ints &amp; filter even &amp; map (+ 42) &amp; sum sumM :: Monad m =&gt; [Int] -&gt; m Int sumM = foldM (\acc n -&gt; return (acc + n)) 0 -- Compare: -- (.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c) -- (&lt;=&lt;) :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; (a -&gt; m c) transmogrifyM :: Monad m =&gt; [Int] -&gt; m Int transmogrifyM = sumM &lt;=&lt; mapM (return . (+ 42)) &lt;=&lt; filterM (return . even) moreDescriptiveM :: Monad m =&gt; m [Int] -&gt; m Int moreDescriptiveM mints = do ints &lt;- mints evens &lt;- filterM (return . even) ints truthed &lt;- mapM (return . (+ 42)) evens result &lt;- sumM truthed return result -- Compare: -- (&amp;) :: a -&gt; (a -&gt; b) -&gt; b -- (&gt;&gt;=) :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b withoutDo :: Monad m =&gt; m [Int] -&gt; m Int withoutDo mints = mints &gt;&gt;= \ints -&gt; filterM (return . even) ints &gt;&gt;= \evens -&gt; mapM (return . (+ 42)) evens &gt;&gt;= \truthed -&gt; sumM truthed &gt;&gt;= \result -&gt; return result simplifiedM :: Monad m =&gt; m [Int] -&gt; m Int simplifiedM mints = mints &gt;&gt;= filterM (return . even) &gt;&gt;= mapM (return . (+ 42)) &gt;&gt;= sumM
/u/chrisdoner points out most of my concerns, but there's one more: the library is unsafe! `part`, as it is defined, permits strings like `"/usr/bin"` to be treated as components of a path. It also allows you to write `part "/usr" :: Path Relative File` with no complaints. At best, `part` should be relegated an `Unsafe` module or called `unsafePart`.
 next :: Player -&gt; Player next P1 = P2 next P2 = P1 Replace `p` in the recursive call with a call to the above.
It's fixed now!
Around here, it's called "gets", as in "line gets getLine".
Is this what you mean by a nested query? Because there isn't any nesting going on here. Also are you referring to sql level errors, or hand-written validation errors, like your example demonstrated. 
Works for me. I use it through stack though
&gt; it would be good to work out what this library enables that the existing ones don't My guess that the fair comparison of all logging libraries requires thorough research of all of them. And in order to see benefits and drawbacks of some logging framework, you at least need to use it in some medium-size application. This looks almost impossible to achieve for a single person. Especially if you want to avoid opinionated overview of different approaches. So writing a comparison of different logging libraries looks more like the community effort to me. And there's already a web resource that has a goal to help people to choose between libraries by providing brief description of every library in the ecosystem. It already contains the section about alternative preludes. So we just need to add the logging section there (by saying _we_ I mean both logging libraries maintainers and users). * https://guide.aelve.com/haskell &gt; From skimming co-log-core and co-log, I'm not seeing anything that couldn't be done with logging-effect `co-log` and `co-log-core` is not that mature as other logging libraries. There's still a lot of things to do! * https://github.com/kowainik/co-log/issues I'm going to use the library in a big application with `servant` and database and see what can be improved further. After looking more closely at `logging-effect` I can give the following rough comparison of `logging-effect` and `co-log`: 1. `Handler` in `logging-effect` is a type alias for a function. `LogAction` in `co-log-core` is a `newtype` wrapper over a function. Being a type alias has its own benefits. But by having explicit `newtype` I have an opportunity to implement more instances and make them more efficient. For example, I can implement `Contravariant` instance for `LogAction` but there can't be such instance for `Handler`. If you convert `Handler` to `newtype` then you will get exactly `LogAction` from `co-log` and the core ideas are already moved into separate `co-log-core` package with only `base` in dependencies. 2. `logging-effect` has it's own `MonadLog` typeclass. My guess is that `logging-effect` is supposed to be used in `mtl` style with its own interface while `co-log` doesn't have such assumption and one possible `mtl`-like solution is built on top of the existing `MonadReader` typeclass. 3. In addition to the previous point, `MonadLog` typeclass is a more general abstraction for logging, but at the same time it looks more complicated: class Monad m =&gt; MonadLog message m | m -&gt; message where logMessageFree :: (forall n. Monoid n =&gt; (message -&gt; n) -&gt; n) -&gt; m () This typeclass looks hard to grasp for beginners. And according to my experience, what is hard for beginners also makes reasoning about performance and behaviour harder for experienced programmers. Though I see value in this abstraction and I think it's even deserves its own package. Maybe this `MonadLog` typeclass can be combined with `LogAction` in some way? :thinking: 4. The types of the combinators for modifying logging action in `logging-effect` are implemented for the specific monad transformer `LoggingT`: mapLogMessageM :: MonadLog message' m =&gt; (message -&gt; m message') -&gt; LoggingT message m a -&gt; m a While in `co-log` they are implemented for `LogAction` value: cmapM :: Monad m =&gt; (a -&gt; m b) -&gt; LogAction m b -&gt; LogAction m a If I add more nested `mapLogMessageM` calls in `logging-effect` performance will be decreased because the more transformers you have in your monad transformer tower the lower performance will be. With `co-log` I don't add any extra transformers when I want to change the behaviour of logging in some parts of code, I only apply functions to actions and I only change an action which is stored inside the monadic context, so I can reuse the existing `MonadReader` machinery with the `local` function. So from this overview it's clear that it's possible to do all things with both libraries, just in different ways. That's why I don't think that people shouldn't write new libraries where they explore new approaches just because there're already similar libraries for the same problem. I don't think `co-log` can be built on top of the `logging-effect`, I think that the approach is different and we can experiment with it to get clearer vision of how it works.
&gt; Why would a compilation error be better? Because as the example stands, you need to know where the "end of the lambda function" is before you can start reading the contents of the lambda for comprehension. I conjecture that this lowers readability significantly. The "do" example requires much less mental effort because usually "do" indicates that "big" block is coming up and thus you'd usually shift your attention to that first *anyway* ($ or no).
yes - that's great. someFunc3 A 1 A 2 A 3 A 4 B 1 B 2 B 3 B 4 (10,10) someFunc4 A 4 B 4 A 3 B 3 A 2 B 2 A 1 B 1 (10,10) I've tried putting bangs in someFunc2 (and the rest of the code), turning on -O2 in ghc-options. I'm still seeing the lazy behaviour. You've shown me that recursion CAN be strict. Is there something in the recursion-schemes library that is preserving the laziness?
&gt;Why not just one operation? &gt; &gt;(&lt;/&gt;) :: Path b Directory -&gt; Path Relative t -&gt; Path b t Well, relative paths defined in stack structure in direct order and absolute path s - in reverse, that's why we can't replace them each other. My idea was to use comonadic operations on absolute paths, (get pointed directory of file, find out if there is some relative way within absolute), but I didn't mention this in the blog post. &amp;#x200B;
Yes, you're right, you can put strings with slashes to feed \`part\` function. But it doesn't mean that the whole library is unsafe. Functions that do system calls like \`getCurrentDirectory\` or createDirectory\` can throws an exceptions, for example. If you doing something like this, you put the gun on your foot: \`part "/usr" :: Path Relative File\`. Types just can't control everything.
[removed]
&gt;I think you can generalize your two operators by a single one: &gt; &gt;(&lt;/&gt;) :: Path ref Directory -&gt; Path Relative points -&gt; Path ref points Well, relative paths defined in stack structure in direct order and absolute paths - in reverse, that's why we can't replace them each other. My idea was to use comonadic operations on absolute paths, (get pointed directory of file, find out if there is some relative way within absolute), but I didn't mention this in the blog post, it will be the next step for this library to define such functions. &amp;#x200B;
Thank you for feedback. &gt;Maybe think of how to lift extensions to type-level as well? Can be useful if you want to filter files by language extension, like filter file with .hs part in type to some HaskellFile data type. No always files have extensions, and if they have \`.\` in the filename - it doesn't mean extension. I mean, if we can't use slash in directory name, we can use dot everywhere we want. So, I don't think that extension should be one of the path abstractions. If you want to filter file based on extension you can take some list function.
The point is when we pattern-match to the tuple, we want to ensure its contents are also forced. There are some ways to achieve it, here's one: combineParaAlg' :: (Functor (Base t)) =&gt; ParaAlg t a -&gt; -- The first t-algebra ParaAlg t b -&gt; -- The second t-algebra ParaAlg t (a,b) -- The combined t-algebra combineParaAlg' f g tab = let a = f $ fmap (second fst) tab b = g $ fmap (second snd) tab in a `seq` b `seq` (a,b) And late reply to P.P.S: **Oh.**
It's not allowed to have the empty stack because it means root (`/`). There is nothing point (nor directory, nor file).
But 'next P' will always be P2 if p is P1 (and vice versa). I tried to modify gtr to something like `gtr p b` but that ruins the `map` call.
Yes, to some extent. Except, they have a lower level interface and can use Nginx' \*request object\* directly in scripting, while this module only shares with Nginx C code string buffers, thus gaining less power in scripting capabilities and being forced to use Nginx variable interface or C plugins (though the variable interface is almost always sufficient). On the other hand, they seems to be missing an elegant way to run \*services\*, i.e. \*global\* tasks not bound to user requests, it seems to me that they're missing even the notion of \*service\* as it's defined in this module.
Thanks for the reply! I mean handwritten validation errors, basically my question is how do I run the queries within an error handling monad since the queries live within a `liftIO` called by `runDb`
The nested part is poor choice of words, ignore that 
If a validation error occurs, what do you plan to do with it? Does it go all the way to the top to simply display to the user (as against, something on the server-side "catching" it and handling it in some other way)? If yes, then my recommendation is to NOT bother with `ExceptT` at all, and start using `throwIO` or throwM` instead. At the Servant-level (top-level, should be in a single place in your app) write glue-code to catch all unhandled errors. If the error is of type `ValidationError` (or such-like), covert it to a 400 with an appropriate JSON to indicate he actual error payload. However, if you are convinced about introducing `EitherT` in your entire app (bad idea, based on personal experience), here's how you would _probably_ do it: data ValidationErorrs = UserBanned | IncorrectEmail | WhateverElse runDb :: (MonadReader Config m, MonadIO m) =&gt; SqlPersistT IO b -&gt; ExceptT ValidationError m b runDb = -- left as an excercise for the reader ;) Actually, after writing that snippet, I've realised it is not possible to answer your question, till you tell me what monad are you running `runDb` finally in? 
For this example: Path Relative Directory + Path Relative File = Path Relative Directory "bin/" &lt;&gt; "git" = "bin/git" Shouldn't this yield a `Path Relative File`?
Oh, thank you, this is my mistake.
This is because \`base\` library use \`String\` type as path value. \`unix\` is a kinda low-level package.
&gt; The mystical monad I haven't heard of such kind of monad yet. Please tell me more! :)
Algebraic effects in Multicore Ocaml are way faster than monad transformers though.
`/` is listed as a directory.
SourcePlugins can do almost anything. Technically they still need dynamic loading, so benefit over TH is not huge (in this case)
&gt; AGPL Why can't you _use_ it though? I'd understand if you wanted to integrate it into some existing code, but it'd be fine to use it, no?
MadLab had a FP group, not sure if it's still running as been out the country for a few years but might be worth looking at to see if they are interested.
Is it Lambda Lounge you're referring to? They retweeted my invitation :)
This type of questions are probably better suited to /r/haskellquestions. That said, what happens when you rotate by n where n is the length of the list? It similar to the clock, so [modular arithmetic](https://en.wikipedia.org/wiki/Modular_arithmetic). Another (inefficient) possibility is to first implement a single rotation, then iterate that. For the second question, again you want to iterate a single rotation, but also keep all the previous results. Another possibility is to iterate over [0..n-1], compute a rotation for each, and return them as a list. Do you know about [list comprehension](https://en.wikipedia.org/wiki/List_comprehension) syntax?
**Modular arithmetic** In mathematics, modular arithmetic is a system of arithmetic for integers, where numbers "wrap around" upon reaching a certain value—the modulus (plural moduli). The modern approach to modular arithmetic was developed by Carl Friedrich Gauss in his book Disquisitiones Arithmeticae, published in 1801. A familiar use of modular arithmetic is in the 12-hour clock, in which the day is divided into two 12-hour periods. If the time is 7:00 now, then 8 hours later it will be 3:00. *** **List comprehension** A list comprehension is a syntactic construct available in some programming languages for creating a list based on existing lists. It follows the form of the mathematical set-builder notation (set comprehension) as distinct from the use of map and filter functions. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/haskell/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Maybe a bit too much help for someone's homework.
For the first one: what about using `m \`mod\` length xs` instead of just `m`? For the second one: for a list xs of length n, you need to create the list `[rotate 0 xs, rotate 1 xs, ..., rotate (n - 1) xs]`. You can do that by using `map` over the list of numbers from 0 to (n - 1).
I think your `throwM` suggestion is what I am looking for, if a validation error occurs I want to return an appropriate error through Servants `throwError` method 
That was the answer I was looking for! thanks a mill! I can't try it out now but I will at the weekend and will let you know how it goes :) Cheers
The policy is that I'm not allowed to install any AGPL software on my work machine unless I ask an explicit authorization from my employer. I could probably get it for brittany, but I don't think it's worth the trouble.
Well, you need to rip out slashes. Again: types are not helping here. What do you propose? \`TemplateHaskell\`? But it can check something on compile time, not runtime (correct me if I'm wrong).
&gt; But it doesn't mean that the whole library is unsafe. That's like if `unsafeCoerce` was named `coerce` and was in `Prelude` and you said "Yes, you can change the types of anything to anything else, but that doesn't mean it's unsafe; types cant do everything, you know." To me, at least, this defeats the whole purpose of using a path library and of using types. (In a downstream comment, you say) &gt; What do you propose? You could check for invalid paths and throw an error or return a maybe. &gt; If you doing something like this, you put the gun on your foot Perhaps, but the library put the gun in my hand and loaded it.
Aaah, fair enough!
One of the authors here, in case you have some question or comment :)
I see, this makes a lot of sense. Thanks a lot for the answer David, and even more so for the book!
This coercion seems safe AFAICT but the type system is too thick to understand that. For `MyData Int Double` to be coercible to `MyData Bool Double`, the constraint solver looks at the roles of `MyData` (you can see this with `:info MyData` in ghci): type role MyData nominal representational This means that to coerce `MyData x y` to `MyData a b`, `x` must be *nominally equivalent* to `a` (i.e., they must be exactly the same type, which is the source of conflict here), and `y` must be *representationally equivalent* to `b` (i.e., one must be coercible to the other). The roles are inferred from the data declaration, and GHC tries to pick them to be as general as possible. In this case the first parameter is nominal because it is an argument to a type family: changing its *name* may change the representation of `MyData`. In this case it seems you need the role system to understand that things are fine as long as `X Bool = X Int`, but this constraint is too fine grained to express at the moment.
&gt; I've searched around for the definition of an operator and apparantly there is no solid one https://www.haskell.org/onlinereport/lexemes.html#sect2.4
Thanks for a good summary of what’s going on. I ran into this when trying out the “Trees That Grow” approach for a project I’m working on. It’d be nice to be able to coerce between these two types without having to manually recourse down the whole tree. 
That gives a little feedback on the delay for the printed version. So that's interesting to know. I am waiting impatiently for it since a long time now
Hello! I just almost figured it out. The rotate function is working completely fine, but I am struggling with the circle. I got the logic, but the I mess up the brackets hard. &amp;#x200B; circle :: \[a\] -&gt; \[\[a\]\] circle a = map (\\i -&gt; \[0.. (length(a)-1\] can you take a look please. &amp;#x200B; ANd thank you very much!
The lambda just extends as far to the right as possible. The manual has this to say on the subject: The grammar is ambiguous regarding the extent of lambda abstractions, let expressions, and conditionals. The ambiguity is resolved by the meta-rule that each of these constructs extends as far to the right as possible. [https://downloads.haskell.org/\~ghc/8.6.1/docs/html/users\_guide/glasgow\_exts.html#extension-BlockArguments](https://downloads.haskell.org/~ghc/8.6.1/docs/html/users_guide/glasgow_exts.html#extension-BlockArguments) 
I actually consider the meta-rule a *bad* thing. The fact this just adds a case where the meta-rule comes into effect is this *also* bad by my estimation. (For obvious reasons it would be impossible to remove the need for the meta-rule since it would break a lot of existing code.) (For me it all comes down to explicit vs. implicit and I'd prefer all "grouping" syntactic constructs to actually have delimiters at both ends rather than an implicit "close at EoL". AFAICT this is the case for almost all such syntactic constructs in Haskell, but fewer now.)
Fair enough. I imagine you should be safe for a good while :-)
Just look at how many logging libraries there are for python https://libraries.io/search?keywords=logging&amp;languages=Python&amp;platforms=Pypi
Contact info?
Glad to help!
I think writing your own code is much better for learning.
Pithon is already a mainstream language. It can have thounsands of idiots doing their shit. Haskell has a much smaller community most of them doing stupid things like comanadic logging, writing long discussions about such stupid things as semigroups and breaking compatibility in order to split a module of 20 lines in two of 10.
Just shout "Lee broke the build" loud enough and he'll show up to tell you that only happened once. Then you can hand over your resume.
I find myself reading that every few months, looking for clues as to when I should expect it. Is an expected date of release buried in there somewhere?
I made a ticket in case https://ghc.haskell.org/trac/ghc/ticket/15683#ticket
There's not. I wouldn't count on it anytime soon, perhaps over the next couple of years. GHC 9, perhaps?
Since the given code is equivalent to main = getLine &gt;&gt;= putStrLn or expanded: main = getLine &gt;&gt;= (\line -&gt; putStrLn line) I think it's pretty reasonable to call it "bind", since it performs exactly the same function as `&gt;&gt;=`.
Cool work. Is [this](https://github.com/serras/ultimate-generics) the Haskell repo? Where can we find the Agda formalization? Is the Agda formalization able to encode `Rose`?
Is anyone in writing a Haskell version of Pie??
Sorry missed the link https://github.com/raaz-crypto/raaz#backpack-based-pluggable-implementations
Not sure if this helps in your case, but here's a fascinating paper on implementing the genuine sieve of Eratosthenes in Haskell: https://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
Hey! You got the list of numbers right, but you're missing a vital part. Here's what it should look like: circle a = map (&lt;what goes here?&gt;) [0..(length a - 1)]
An "entire square root" is a single machine operation. It is incredibly fast.
If you've never done any programming before, then I'd recommend against using an IDE for Haskell. Instead: - An OS. The Windows story is a bit rough, unfortunately, so if you're familiar with Linux or OS X, use one of those. - A shell of your choice (bash is the default on most platforms, and can be had on Windows via cygwin, msys, or git-bash). - A text editor. Emacs, vim, etc., make sense if you're already comfortable with them, but otherwise, just something simple. You can always switch later. - GHC (which comes with GHCi), Cabal, and probably Stack, too. That is enough to get you through any beginner course / tutorial / book, and quite a bit beyond. Once you know how things fit together, you may want to adopt a more IDE-style workflow, but GHC's IDE support is somewhat brittle, so you need to be able to troubleshoot issues yourself more often than not. Personally, I do professional Haskell work with a fairly vanilla vim setup, plus a selected handful of command-line tools: git, ack-grep, tmux, hasktags, hlint; the only vim things I have for Haskell are a handful of macros and settings, and a syntax highlighting definition.
I suggest [Visual Studio Code](https://code.visualstudio.com/). Install the extension [Haskero](https://gitlab.com/vannnns/haskero/blob/master/client/doc/installation.md) which almost gives you an IDE feeling. As an added bonus with VSCode, you will have in-built terminal (of your choice): and depending on your OS - a shell of your choice - bash, powershell, etc. You can fire up a ghci REPL here. And get everything on Haskell in one VSCode window. Atleast, this is my setup and I enjoy it this way.
Welcome to the ride!
1. I gather that its still possible to instal Haskell and debug it on windows? lots of the editors, ide etc. have windows support. and it really is a lot of trouble to switch to another system and my potato laptop doesnt have much space for a new os anyway (reinstallation would be, far, far, time consuming). My tutors asked us to use atom +some ide plugins at first but it turned out buggy as hell so they told me to use any editors we like....and i dont know any apart from windows notepad 2. What is a ''shell''? You mean like the command prompt thingy on windows that someone had shown me that can run haskell codes and check if they are bugged? Couldnt i use windows powershell? 3. i am using note ++. 4. Frankly I have no idea what 'GHC' 'GHCi' 'Cabal' 'Stack' mean at all. I only know that there is a big package that i can download from the haskell website called haskellplatform. Are they other seprate subpackages? Plugins? How do I install them (do i need to load them into IDE or editor or whatever i am using)? yeah and by new to programming i also mean i have almost 0 software knowlege. so plz go easy on me. I will learn as i go on but now i need some easy solution----- i only need something that can run haskell code and check for error---- first to get on with my homework practises. I will keep using note ++, and try finding those GHC, CABAL, Stack packages you mentioned and installing them. I will need something to help debug my codes tho. I used to use ATOM for that but it got buggy, and then windows powershell (but i cant get it to work anymore), and you say that a better one would be bash through git bash and so on?). thank you for your reply.
I dont think Haskell is a good start. Its pretty difficult language and can detter you from programming for good. Consider Python or C# as your first language
I enjoyed that way too much :)
oh jes... let me sort it out one at a time. So basically i need to instal two thigns to get started with haskell 1. Visual Studio Code 2. Extension Haskero And thats done after installing Haskell environment? How about "GHC (which comes with GHCi), Cabal, and Stack", do i need to instal them (and where do i find them&gt;) and also 1. what is a terminal in programming? 2. what is a shell? thank u
thx. also plz tell me: what is a terminal? what is a shell? you mean like power shell? how is that related to coding? 
unfortunately its uni mandatory course. I am learning python and java alongside it. Had to. Have no idea about how to get started.
&gt; haskell is computing an entire square root everytime it generates a number Why do you think so? I expect that Haskell will compute a sqrt only once per list. If you need integer square roots of really large numbers (bigger than 64 bits), you may use something from https://hackage.haskell.org/package/arithmoi-0.8.0.0/docs/Math-NumberTheory-Powers-Squares.html Otherwise it is fine to do `ceiling . sqrt`.
Interestingly I came to the very conclusion that this is really what's wanted, when doing stuff like this. I'm doing something similar to this [here](https://github.com/ocharles/rio-effect/blob/master/src/RIO/Effect/EFF.hs#L29)
If you press the Windows key and R it opens a little window with the title "Run". Entering "cmd" in this window will open windows command line (or terminal). It's the black window with text on it you see sometimes in hacker movies ;) Even if those movies often show a wrong picture of using it, the command line/terminal is a powerful tool: You can type in commands to start programs and adjust their parameters without the need of an GUI. For example Haskell's compiler (GHC) comes without a GUI or any other interactive program. You just enter `ghc &lt;filename of your code&gt;` and it will compile your code into a program that can run on your PC. You can also add flags to the compiler to change its behavior, for example when you compile a program for multithreading (a way to collect data/read files/do other stuff in the background so your main program doesn't get interrupted or unresponsive for that time). An other command you've already seen is `ghci` if you type it in, it will start the an interpreted version of Haskell in the terminal. It will show you some greeting messages and will leave you with a blinking cursor on the black window. You can think of it like a playground. If you enter any Haskell code it will "sort of compile it" and run it, showing you the results directly. It's a perfect way to tinker around and getting used to new code, libraries, etc. Just try it out, it's fun. If you want to leave GHCi just type `:q` or press Ctrl and D. There are other things GHCi can do, but feel free to ask them, when you're at this point of your journey. I wish you luck, and hope you will not loose your motivation. Programming is like riding a bike: The beginning is hard, you will often fail, but when you're on it and riding down the street it's super awesome and a lot of fun. Happy coding. 
I just use notepad++ and command prompt.
 "And that's done after installing Haskell environment?" Exactly. You first have to install the Haskell environment. This is needed so your computer knows what Haskell is, how to read it, how to run it, and all that stuff. GHC is Haskell's compiler, the programming that turns your code into a real programm. And GHCi is like GHC just with some programming magic, so you don't have to compile your programming to run it. It's used for testing and makes it easier and faster. Cabal is used to manage your packages and dependencies. Sometimes in programming you need for example to connect to the internet and download something in your program. Think of an application that checks your local weather via a website. So you could just go and tell windows, to open a connection to this website, and tell it how to send data, and how to encrypt this data, and oh there are timeouts and what is it doing if there is no connection and... - so you see, there's a lot to think of when coding this. But connecting to the internet is something you need quite often, so someone took the effort and made a library for this. You can now use cabal to install this library onto your computer and don't have to think about all the little details of the internet. You can just build on their work. Libraries are a great way to minimize your code and work, because you don't have to reinvent the wheel. And to your last question: A terminal and a shell are often used synonymous. Mostly they mean the command line (the black window with white text) and what version it is using (in Linux there are more than just one command line, unlike windows). In my other answer I tried to explain to you, how to use your command line and what it is in detail. But if you have any more questions, feel free to ask. 
Here are a few things you'll need: - Install Haskell tooling - you can use [stack](https://haskell-lang.org/get-started/windows) to install programs that can convert your source code into programs or just run them. [This guide](https://haskell-lang.org/tutorial/stack-play) explains how to use them from the command line. (See next bullet on how to use the command line) - Interact with the Haskell tooling - there aren't any simple GUI programs that I'm aware of that can help with this so you'll probably need to use the command line in order to run the programs you write. You can use [Git Bash](https://gitforwindows.org/) to install a command line for windows and you can learn more about how to operate it [here](http://www.linuxcommand.org/lc3_learning_the_shell.php). - A way to write programs - You can definitely use something simple like notepad++. Truth is that while IDEs offer features that may help when you already know what you are doing, the fast feedback can hurt when you are just learning as it doesn't give you time to process the code you wrote. So just using syntax highlighting is fine. Just make sure to change the settings in your editor so it will replace tab characters to spaces automatically. (Haskell does not like tabs). Also, if you are not married to Haskell, another alternative to learn how to program is using the book [How to Design Programs](https://htdp.org/2018-01-06/Book/) and the development environment DrRacket. This is not Haskell, but it's also a good way to learn how to program. 
thx. also is there a place where i can ask for others help debugging my script... etc? and basically you write your code with a text editor and try running it with GHCI through a shell?
how do you run it with command prompt? 
Yes, that links to the Haskell repo. The idea is to eventually merge this work and [generics-mrsop](https://github.com/VictorCMiraldo/generics-mrsop), which would allow to encode `Rose`.
You're welcome :D
thakn you also where do i find beginner practise coding problems with answers? i have some on the textbook but iam afraid i need more to practise
It's often the case, when you're actually writing and developing the code. You have to try things out. Normally things aren't working correctly on the first try. But you'll get used to it. When something isn't working, don't give up - we all have this problems, programming sometimes means to spend hours looking for a mistake you made yourself :D When your program is ready and completed you can compile it to an executable file. So you just have to double click it or type it's name in the command line (all our first programs were something like reading a number from the command line and printing it back out again). If you need help or are stuck, you can try googling the error message or the functions you can't get to work. This will lead you to sites like the almighty "StackOverflow", where you can find really good answers but often very detailed and intimidating for starters. The other place - especially for someone who just started - is a place you already found yourself: Describe your problem to r/haskell on Reddit. Add some code snippets. Perhaps the error message and explain, what you are trying to do. Haskell's community is wonderful, grateful and incredibly kind and helping, especially for beginners. If there is any problem just ask us here, we'd be happy if you someday become a part of this community too and can help another person diving into programming with Haskell. 
I'm learning Haskell and implemented a sieve implementation. http://p.ip.fi/wmO0
haskell was the first language i was taught in uni as well, with very little prior programming knowledge. Haskell is a good language to learn basic cs algorithms because it's hard to drag mistakes along and knowing several paradigms is always useful.
Which text book are you using? You can use: - [99 Haskell Problems - 01 - 10](https://wiki.haskell.org/99_questions/1_to_10) - [99 Haskell Problems - 11 - 20](https://wiki.haskell.org/99_questions/11_to_20) - [Exercism.io for Haskell](https://exercism.io/tracks/haskell)
This is pretty cool, I always looked at log to be composed contravariantly. In fact, I am working on contravariant concurrent composition in streamly and log is one of the things that I have been thinking about, pretty much on similar lines at a high level.
Haskell on Windows works perfectly ok, though it has some rough edges. I recommend to install the [Haskell Platform](https://www.haskell.org/platform/) (full version), that's basically a one-click installer (ok, several clicks :) If you are on Windows, instead of a shell I recommend to use something like [Far Manager](https://www.farmanager.com/screenshots.php). It's a text-mode program to navigate within the file system, and it has a built-in shell (just press ctrl-o) which is by far more convenient than the built-in command line (for example copy-past works :) Notepad++ is a good editor to start with (but Far Manager has even a built-in editor, just press F4 on a text file), download Haskell syntax highlighting if it's not included by default. GHC is the standard Haskell compiler (the program which takes Haskell source code and creates an exe from it). GHCi as an interactive version of GHC. Cabal is build system (for managing more complex Haskell programs). It can be used to install libraries (larger pieces of useful Haskell code, so you don't have to reinvent everything). Stack is made to resolve some (historical?) problems with Cabal, it can be also used to install libraries. It is not necessary to start. All these programs are included in the Haskell Platform above
It's mandatory, but the course doesn't provide you with documentation about how to set up a Haskell development environment on various OSes?
Wikipedia has a page about [implementing integer square root](https://en.wikipedia.org/wiki/Integer_square_root). There is a Haskell implementation in the [combinat library here](http://hackage.haskell.org/package/combinat-0.2.8.2/docs/Math-Combinat-Numbers-Primes.html#g:4).
But there is no Agda in either of this repos?
What do you mean for hard? Strict/loose or hard/easy? Are you talking about measurements?
&gt; I gather that its still possible to instal Haskell and debug it on windows? Yes, of course it is. As long as you're writing straight-up Haskell, avoiding C dependencies and such, you'll be just fine. &gt; My tutors asked us to use atom +some ide plugins at first but it turned out buggy as hell so they told me to use any editors we like....and i dont know any apart from windows notepad Notepad is probably a bit too spartan, and has a history of problems with handling encodings and line endings, but if that's what you're familiar with, something like Notepad++ should be right up your alley. Haskell-specific plugins are nice if and when they work, but they're not essential, just a plain text editor will be fine. &gt; What is a ''shell''? You mean like the command prompt thingy on windows that someone had shown me that can run haskell codes and check if they are bugged? Couldnt i use windows powershell? A shell is a program that runs in a terminal, and provides a command-line interface for starting other programs, combining them (e.g. by feeding output from one program into the input of another), and even scripting things. Windows traditionally combined shell and terminal emulator into a single program (called `cmd.exe` on most releases), while on Unix-like systems, the two are separate. Powershell will probably work, too; however, many Haskell-related tools and Haskell libraries rely on a Unix-style shell in one way or another, so I'd strongly recommend getting some flavor of bash running and learning a handful of essential commands. The "thing that runs Haskell codes" is probably GHCi, a program that ships with the Haskell compiler, GHC, and can run Haskell code fragments interactively. &gt; i am using note ++. Assuming Notepad++; yes, that'll do fine. No need to install another editor. &gt; Frankly I have no idea what 'GHC' 'GHCi' 'Cabal' 'Stack' mean at all. I only know that there is a big package that i can download from the haskell website called haskellplatform. Are they other seprate subpackages? Plugins? How do I install them (do i need to load them into IDE or editor or whatever i am using)? - GHC is "the" Haskell compiler ("The Glorious Glasgow Haskell Compilation System"); there are others, but GHC is the biggest, most featureful and most robust by far. For most practical applications, GHC is the only serious contender. - GHCi is "GHC Interactive", a program that ships with all GHC releases. It gives you a shell-like command line interface where you can enter Haskell code and have it run immediately. It can also do a few more things for you, such as displaying type information. - Cabal is a build tool and dependency manager. You use it to build Haskell programs that are more complex than a small self-contained handful of modules, and it can also download and install libraries from Hackage, "the" Haskell package repository. - Stack is *another* build tool and dependency manager; it follows a slightly different strategy that you don't have to worry about yet right now, despite ongoing debates in the Haskell community. In a nutshell, `stack` uses a project-centric approach, where you set up a separate, independent environment (complete with compiler, libraries, etc.) for each project. - Haskell Platform is a package that contains GHC, GHCi, Cabal, Stack, and a selection of essential libraries. Now, there are several ways of getting your Haskell tools installed. The first one is via the Haskell Platform; instructions are [here](https://www.haskell.org/platform/). The second one is using Stack; follow installation instructions [here](https://docs.haskellstack.org/en/stable/README/#how-to-install). Once you have installed `stack`, you can use it to install GHC, and any libraries you may need. The third one is the barebones / hardcore approach: install only GHC and Cabal, and then use Cabal to install anything else. I'd recommend the Haskell Platform for now; you don't need to manage multiple compiler versions yet, and having a set of essential libraries around without having to worry about dependency management will allow you to just start writing simple Haskell programs without too much hassle. &gt; I will need something to help debug my codes tho. I used to use ATOM for that but it got buggy, and then windows powershell (but i cant get it to work anymore), and you say that a better one would be bash through git bash and so on?). None of the things you listed are debuggers. But before I recommend anything here, I'll have to explain one thing: Haskell has some properties that make the debugging approaches used in many other languages less useful, especially the "step debugging" workflow that you'll see in almost every imperative programming language, where you step through your code one statement at a time, and watch some variables change as you go. But Haskell doesn't have statements, variables never change, and expressions aren't evaluated where they are written but rather when their values are demanded (which might be never). Step debugging is kind of possible in Haskell, but it's only useful in some exceptional situations. So how does one debug Haskell code? Well, there are several approaches: 1. Follow the compiler errors. In Haskell, many bugs manifest as compiler errors (which is a good thing, it means we can never hit them in a production environment, because the broken code cannot be compiled, let alone run), so a lot of debugging work amounts to figuring out what the compiler errors mean. Often, just adding explicit type signatures in strategic places will allow you to narrow it down, and also have you split up your complex expressions into smaller ones, which makes it easier to pinpoint type mismatches and understand them. 2. Make your types better. Some bugs come about because our types are too lenient. By using more restrictive types, or just generally types that more accurately reflect what you want, you can sometimes make the undesired behavior impossible, and code that attempts it produces a compiler error (and you can apply strategy 1 to nail it). 3. Ad-hoc interactive testing. If a function or expression misbehaves, or you suspect that it doesn't do what it should be doing, load it into GHCi and evaluate it manually to see what comes out. Most of your Haskell code will be "pure" (in the sense that it doesn't involve `IO`), so if it behaves correctly in GHCi, it will behave exactly the same in the real world if fed the same inputs. 4. Unit tests and property tests. Haskell has some really powerful testing frameworks; use them to your advantage. A common workflow is to start with interactive testing, and once things solidify, copy those manual tests into unit tests. 5. Trace logging. The `Debug.Trace` module has a bunch of useful functions that you can use to dump all sorts of values and other information to the console while your program runs. 6. Pen and paper. Haskell code can often be reduced and evaluated manually, and doing so will often reveal rather clearly what your code does and why. We call this "equational reasoning": rather than trying to understand "what it does", we simply apply a set of formal rules to transform expressions into simpler expressions, much like solving Math equations. And just like with the type annotation thing and manual testing, if it gets too complicated, then that's often a sign that you need to break things up into smaller chunks that are easier to debug individually.
/r/haskellquestions for beginner language questions or debugging code
Yep. Its a `ReaderT` layer around a monad `m` that carries the implementation of some effect for that monad.
Great intuitive explanations! I would like to emphasize one aspect that tripped me for some time: although `Applicative` functors are _monoidal_ functors, I couldn't see the explicit relationship to the `Monoid` typeclass. I came to realize that `Applicative` doesn't depend on the `Monoid` typeclass, because it operates on a "_type-level_ monoid." † The explanations of [Justus Sagemüller](https://stackoverflow.com/users/745903/leftaroundabout) (leftaroundabout) were illuminating in this regard: &gt; What the "monoidal" in "monoidal functor" refers to is a monoidal structure on the category's objects, i.e., on Haskell types. Namely, you can combine any two types to a tuple-type. This has per se nothing whatsoever to do with the `Monoid` class, which is about combining two values of a single type to a value of the same type. [link](https://stackoverflow.com/a/51673707/474311) and &gt; The monoid that's referred to with "monoidal functor" is not a `Monoid` monoid, i.e. a value-level monoid. It's a type-level monoid instead. Namely, the boring product monoid: `type Mempty = ()` `type a &lt;&gt; b = (a,b)` [link](https://stackoverflow.com/a/50703828/474311) --- † There are, however, cases when the two typeclasses are related: 1. `Applicative` functors preserve `Monoid`s: if `m` is a `Monoid` and `f` is an `Applicative` then `f m` is a `Monoid` (as you already pointed in the PPS). 2. `Monoid`s are phantom `Applicative` functors: if `m` is a `Monoid` then `Const m` is an `Applicative` (as pointed out in section 4 of the [Applicative paper](http://www.staff.city.ac.uk/~ross/papers/Applicative.pdf)).
^The linked tweet was tweeted by [@markeibes](https://twitter.com/markeibes) on Sep 19, 2018 16:57:37 UTC (191 Retweets | 99 Favorites) ------------------------------------------------- If anybody is interested in a Haskell Job at Zalando in Berlin, please DM me. A retweet would be appreciated as well! ------------------------------------------------- ^^• Beep boop I'm a bot • Find out more about me at /r/tweettranscriberbot/ •
I think you could split the file up at line 239 and go from there. The code looks nice and clean to me.
Thanks! That works. Here is the working diff: https://pastecode.xyz/view/ec50db35
As for composition, it just works. Those functions would look like this in `simple-effects` persistUser :: MonadEffect SqlStatement m =&gt; RuntimeImplemented PersistUser m a -&gt; m a logStatements :: MonadEffects '[SqlStatement, Logging] m =&gt; RuntimeImplemented SqlStatement m a -&gt; m a executeSql :: MonadIO m =&gt; PostgreSQL.Connection -&gt; RuntimeImplemented SqlStatement m a -&gt; m a logToIO :: MonadIO m =&gt; RuntimeImplemented Logging m a -&gt; m a persistence = excuteSql conn . logToIO . logStatements . persistUser
Awesome!
Make a pull request!
Nothing against having procedural, object oriented, functional and logical programming paradigms on your tool belt. Just saying it hard language and I wouldn't pick as a first one
I wonder how this (more generally laziness) works without GC. Is it just leaking memory?
Haskell wasn't my first language. I am currently studying it this year in university and me and my friends are really struggling with it. Maybe it's because we learned Object Oriented languages first. I think Haskell is useful it it's own ways but at least for now it looks hard and boring, I think it's better to pick up python or c sharp because for a person who learns programming for a first time it gives more instant gratification.
This is slightly different, but has the same effect (ha!). In my example, `persistence` is a handler - something you would give to your `implement` method to provide to `RuntimeImplemented`. In your example, you're actually using a monad transformers like approach, in mine I fuse a big handler that will be used diectly when `send GetUser` is called. That is, you would essentially write `runReaderT (getUser 42) persistence` - there is only one layer of the monad transformer, despite `getUser` (part of `EFF PersistUser`) being handled by various reinterpretations.
Idk why this has downvotes. Haskell is a language that brings in a lot of concepts very early; a beginner/non-CS who’s just trying to do simple tasks might be overwhelmed. This isn’t a rag on Haskell, just that *maybe*, just maybe, there may be a better choice for a *beginner to coding*.
Definitely hidden, but it's there -&gt; https://github.com/VictorCMiraldo/generics-mrsop/blob/writeup/writeup/haskell2018/GenericsNSOP.agda
I had a bit more time to explore the differences here, and I think it comes down to: 1. You take a record of handlers for each operations of an effect, into some `m`. This is approach taken by ["van Laarhoven free monads"](http://r6.ca/blog/20140210T181244Z.html). Mine has a handler pattern match on a sum of construtors. I'm going to explore your approach, because it might lead to even more efficient code (there's no pattern match, just field selection, which I feel might be marginally faster). 1. Each effect is a layer in a monad transformer, whereas for me, each effect is an entry in the set of effect handlers. This removes the `CanLift` machinery you have to write, but trades it for `Handles` to find an effect handler in a record of effect handlers. It also means that I work with a single monad transformer layer, rather than multiple. 2. You handle re-interpretation of effects in a traditional monad transformer style. That is, if you have effect `Foo`, and you want to interpret `Foo` into `Bar` and finally `Bar` into `IO`, you would use `implement barToIO . implement fooToBar`, for suitable `fooToBar :: MonadEffect Bar m =&gt; Foo m` and `barToIO :: MonadIO m =&gt; Bar m`. 3. You work with `eff :: ( * -&gt; * ) -&gt; *`, whereas I work with `eff :: (k -&gt; * -&gt; *) -&gt; * -&gt; *`. I call the shape of my effects "parameterized effects", and it allows me to recover a crucial functional dependency for `EFF` (your `MonadEffect`). I have: `EFF eff cfg m | eff m -&gt; cfg`, which means `m` can only have unique `eff`s. This makes inference considerably better - you can read `EFF Reader r m` as `MonadReader r m` and obeying the functional dependency. `simple-effects` could (and imo, should) do this - [I'm encouraging](https://github.com/lexi-lambda/freer-simple/issues/14) `freer-simple` to add the same. 4. You have `Control.Monad.Runnable`, which seems to be somewhat like `MonadUnliftIO`. I haven't gone down this path yet, and am currently just preferring to use `MonadUnliftIO` directly.
A lot of the current design was guided by the fact that I didn't want to lose the ability to define more complex effects (this wasn't the original goal of the library, hence the name). For example, `catch` or `fork` can be defined as effects in my system. The lifting semantics of that effect over other transformers are determined by the effect itself. The `CanLift` machinery is invisible for normal effects and defaults to `MonadTrans`. The code that does the lifting in that case can usually be derived via the provided generic instances. For effects like `catch` however, `CanLift` provides extra flexibility since they can require more than just `MonadTrans` of the transformers in the stack. That being said, since your approach doesn't deal with transformer layers at all, you don't even need this machinery. The thing about the fundep, I actually want to allow multiples of the same effect (if the effect is polymorphic). Yes, you lose the inference which is unfortunate, but with type applications it's not that bad from a usage perspective, and often enough the context will actually let you infer the correct types. Still, it's a shame that code like myFunc :: MonadEffect (State Int) m =&gt; m () myFunc = do i &lt;- getState setState (i + i) doesn't infer even though it's obvious what I mean.
Are you a macOS user? http://haskellformac.com/ is probably what you're looking for. If you're on Windows you may have to install a few things: Visual Studio Code and the Haskell Platform: https://www.haskell.org/platform/windows.html You'll then want to configure Visual Studio Code with some extensions for Haskell development. Best of luck -- using Haskell as your first programming language! I'm rather jealous. I've had to unlearn years of hard-earned knowledge to get proficient at Haskell! If I could start over I think I would like to have started where you are now. Such good times!
I did
How does this compare to [asterius](https://github.com/tweag/asterius) - and is there the same volume overhead - the RTS ?
If it's been a while since you used a windows shell you may be interested to know that they eventually got copy paste working a few years back. 
A short video showing how to use this would be helpful. I just tried to import an .mp4 file but nothing happened. I can't see the asset anywhere, the timeline or preview hasn't changed, and render button doesn't do anything. I don't see any errors either. Not sure what happened to the .mp4 I just imported. Tried few other mp4 files too, but none of them had any effect -- I still see an empty timeline/preview.
I see this printed in the terminal ffmpeg -v quiet -stats -nostdin -i /tmp/project.komposition-ffb1fd0bd7f1d088/MOV_0091.mp4 -filter_complex scale=width=640:height=360:force_original_aspect_ratio=disable -f mp4 -framerate 25 -vcodec h264 /tmp/project.komposition-ffb1fd0bd7f1d088/proxies/MOV_0091.proxy.mp4 I tried "a v c" but I got "Cannot perform InsertClip (Just Video) when focused at sequence".
By the way, please submit any usability issues on GitHub. One should be able to use it on first try, otherwise there's some problem with the UX.
OK, that command is run to generate the proxy media for the video you're importing, so that seems to be working fine. Regarding the message, if you press the "arrow down" key to focus the parallel inside the sequence (I know, this is not very clear from the white border around it, need to find a better way to visualize it!), and then press "a v c"?
Your data constructor here is `(:&gt;)`, so you can make one: rose :: Rose Int rose = 1 :&gt; [2 :&gt; [], 3 :&gt; [], 4 :&gt; []]
Float and Double have negative infinity, wouldn't that work for Min? I guess NaN screws it up.
The main answer seems to be that it's not GHC-based. From the README: "It accepts only a tiny subset of the language." So how it compares to asterius today is *not very well*. But it might be something in the future.
This killed me lol
Speculating about why things are downvoted is a fool's errand. But I think there's good reason to be skeptical of the advice to abandon Haskell and go learn C# instead. Haskell is nicely suited for a beginning programming language, if used in a suitable way. It has a core that is far, far simpler than anything C# or Python can offer. And learning Haskell is a different thing from learning Python or C#, and can be motivated by different goals. It's as if you asked a bunch of carpet layers for advice on installing carpet, and were told "install laminate flooring instead". Not helpful advice.
/u/dantheodor's [comment](https://old.reddit.com/r/haskell/comments/9jfq7w/relationship_between_applicative_and_monoid_in/e6sf3ue/?utm_content=permalink&amp;utm_medium=front&amp;utm_source=reddit&amp;utm_name=haskell) and links therein seem like a good place to start. :-)
yay, always happy to see GTK projects. Feels like a lot of effort to make an app from scratch instead of improving Pitivi though… &gt; gstreamer1.0-gtk3 gstreamer1.0-libav libgstreamer1.0-0 libgstreamer-plugins-base1.0-dev libgstreamer-plugins-good1.0-dev libgstreamer-plugins-bad1.0-dev Speaking of which, you're not using their gstreamer-editing-services thing… Is it not necessary?
Thanks! I appreciate the more correct formal descriptions. This also gets at part of the disconnect some of us were having on the FP Slack conversation.
It is indeed a lot of effort. I've though about doing it as a plugin for another application, but haven't tried it yet. I want the editing UI in a specific way, so that's why I went with a new application. But, there are also ideas around exporting to other video editor project formats, so that Komposition can be really simple. You could do any final editing in another more general video editor after the rough cut is done.
I'm not sure. Haven't heard about it.
That was an excellent read.
You can separate branching and extension: `data Cofree f a = a :&lt; f (Cofree f a)` `type Rose = Cofree []` Now you can do something like this: `example :: Rose Int` `example = 1 :&lt; [2 :&lt; [], 3 :&lt; [], 4 :&lt; [5 :&lt; []]]`
Hi! I have been teaching Haskell as a first programming language to children for about seven years. I would love to provide some feedback on your points. Of course, my audience, at ages 11 to 14, is somewhat different from a university or professional programmer, but it also puts an interesting lens on the question of what beginners struggle with. Semantically, Haskell is a fine place to start. It's a good choice for the same reason MIT wanted to teach Scheme, and others want to teach Racket. The stateful mutable-variable approach to programming is actually pretty complex, when you get down to it, and purely functional programming provides a far simpler semantics. And when some say they believe functional programming is harder, it is indeed because they are trying to shoehorn the sequencing from imperative languages onto the learning of declarative ones. Recursion, for instance, should not be taught as early as loops are taught in Python. There are other things to focus on first: expressions and variables, functional abstraction, and hierarchical decomposition are chief among them. That said, though, I do agree that in some sense functional programming is still *harder*, and the reason is that the way things combine is less intuitive. The human brain seems to naturally have a bunch of machinery devoted to reasoning about effectful actions in a stateful world, so even though it's a mathematically very complex task, we do it remarkably well. Mathematics teachers exploit this when they find they can get their students to perform better on exams by memorizing steps and procedures for manipulating symbols, rather than understand the meanings those symbols represent. And computer science educators make use of the same phenomenon when they find their students can produce working software using Python, often without understanding what they are doing. Teaching pure functional programming, on the other hand, has a different feeling to it. Often the solutions are quite simple, but students are just unable to see them. It's like trying to teach someone to see what is right in front of their eyes, but they have just not seen how to look for it. Despite being harder, though, I continue to believe it's more valuable. Purely functional programming is the language of mathematics, and removing complexity, not adding it, is the better way to prepare oneself to solve difficult programs. Imperative languages, of course, add complexity. There's is supporting evidence in other fields, as well: research by Carlson and Oehrtman, authors of a very popular calculus textbook, found that (aside from obvious things like past math grades), the best way they can predict success in undergraduate calculus classes is my looking at whether students fundamentally understand a function as something that *does things in steps* (they call this the *action view*, and it predicts failure in calculus), or as a process of information flow (the *process view*, which predicts succeeding). It won't be lost on most functional programmers that, indeed, purely functional programming is all about seeing functions as a process of information flow between expressions and subexpressions rather than a sequence of actions. I think you're overestimating the usefulness of static typing, type safety, and reasoning. These are great benefits to someone whose main concern is to produce correct code. But for a beginner, the first concern is to produce any code at all. If the code does the wrong thing, then *great!* That's a learning opportunity. It's also fine, though less helpful, if the code works. But worst of all is when the computer refuses to try. Haskell actually loses here, but GHC features like deferred errors at least help a bit. If only we had \`-fdefer-parse-errors\`... Anyway, sorry for the disorganized jumble of thoughts. Hope it's been interesting.
But isn't that the same as making a helper logging function that specializes the argument? Then you only have one place where you need to annotate.
It’s a high throughput gc!
Yes, but I often have different bits of code that use different logging types. I hardly want to have to define a myriad of logging functions specialised at each type. (E.g., https://hackage.haskell.org/package/logging-effect-1.3.2/docs/Control-Monad-Log.html#v:logDebug).
Hm. I haven't found this anywhere online. Do you know where I could find this?
Yeah, that's what I meant. If Haskell needs yo generate 10,000 prime numbers, it does around 104,000 square roots. This obviously isn't the largest time chunk, but it's pretty costly.
Sorry, I know that last comment seemed really rude. I didn't mean for it to come out this way
I get what you mean but it would be the same (or more likely less) effort if went the newtype way, no? The only way I see this requiring less work is if you disallow multiple of the same effect. 
&gt; The only way I see this requiring less work is if you disallow multiple of the same effect. That's what I'm suggesting - and it's what the fundep does. I'm just saying if you *really* want multiple types of the same effect, rather than having MonadEffect (Reader r1) m, MonadEffect (Reader r2) m You have MonadEffect (TagR1 (Reader r1) m, MonadEffect (TagR2 (Reader r2) m You would then map `ask` calls into `TagR1` or `TagR2`. This is akin to newtype wrapping at the value level.
On x86 processors, it's the `fsqrt` instruction.
While Float/Double have infinity values, there is not an instance for `Bounded`, hence `Min Float` and `Min Double` are not `Monoid`s and so `(,) (Min Float)` and `(,) (Min Double)` are not `Applicative`s. Also, yes, the existence of NaN values for floats would make them unlawful Applicatives/Monoids too. (since NaN &lt; +Infinity returns False, you can't use +Infinity as identity since it's not an identity for `max`, and for the same reason -Infinity isn't an identity for `min`)
Well I'm on win7 here, and in cmd.exe I cannot even select anything, neither with the keyboard nor with the mouse (even though there is "mark" item the context menu). So no copy. Pasting works but only from the context menu (right-click, select paste), which is very inconvenient. I wouldn't recommend this experience to anybody, and especially not to somebody who is not familiar with the concept of shell...
Do you really think that this is a helpful reply considering that the OP was not able to construct a value of the data type that he/she has given? .....
Ooh, well this looks very cool! It's been so long that I can't remember anything about this. Sometimes I'm quite surprised by the stuff that seems to have come out of my imagination.
Nice write-up! &gt; The Maybe applicative is monoidal in the sense that you have to combine Maybes in some way, and your pure Maybe must not bias that combination. Maybe actually acts just like the All monoid for booleans, where Just is like True and Nothing is like False. The `Alternative Maybe` instance acts like the `Any` monoid for booleans, where `empty` is `Nothing` and `&lt;|&gt;` is `or` (and it will return the first non-empty `Maybe`). Also worth mentioning the `Alternative []` instance concatenates the lists and uses `[]` as the empty element.
It's fixed in Windows 10, not Windows 7. 
I see. And you'd only need to tag the effects if you used multiples of the same one in the same function. I'll have to think about this.
I think those are excellent points, and I appreciate your taking the time to type them up. You make a good point about the compiler refusing to run code being great for correctness but perhaps not so great for encouraging exploration. Also your distinction between simple semantics vs pre-existing thought patterns (even without experience in imperative coding) is well taken. I suppose that in an ideal universe, whatever cost there might be in initial learning difficulty would be offset by the profusion of benefits we might hypothetically experience, were FP to become the "mainstream" default instead of the relatively niche field it currently is. As long as imperative languages are seen as "normal" coding with a larger and cheaper (in multiple senses) hiring pool, that may be unlikely. I would like to think that by making comp sci education "FP-first" it would tilt the balance a bit, but perhaps more people would share /u/macro161's feelings about the language than I would expect. I find it personally surprising that anyone would think of Haskell as "boring" compared to e.g. C++, but that may be a personal bias I need to re-calibrate. :-)
DogFood a
Strict
Like racket!
Ah, I think your observation is closely related to [this answer](https://stackoverflow.com/a/50717675/474311) by Conor McBride. He investigates those applicative functors that are containers (that is, data types that are characterized by shape and position) and states that the apply operator `&lt;*&gt;` acts monoidally on the _shape_ of the data types: &gt; The applicative laws tell us that `neutral` and `outShape` must obey the monoid laws. He mentions that the shape of the `List` data type is given by the natural numbers (the length of the list) – which is in line with your interpretation. I wonder if the other functors that you mentioned are also containers with the shape given by the monoids you identified. Unfortunately, I'm not able to fill the details myself, since I don't fully grasp the idea of containers and I'm not familiar with dependent type theory.
I finally watched this. I was impressed by how candid they were about the process and what happened. I also generally want to see more small companies working with this many users/volume in Haskell. It feels like only Freckle and a few others have this many users at the moment. I felt kind of bad for what happened. It sounded like a normal Java shop, without major issues, was pushed into Haskell. Its NYC, so a layoff isn't as bad to deal with. If one considered the same scenario where the languages were swapped, I imagine the founding Haskell developers would be upset to have their job disappear over time.
Do you really think you’re look so smart to dislike me when I’m trying to show decomposition method for this question?
Check out [gloss](http://hackage.haskell.org/package/gloss) if you want some quick flashiness. [Here](https://pastebin.com/k9hxVwwP) is a 50 line implementation of Snake.
I'm happy that you're finding it useful! Thanks for reading it!
I don't know of anyone doing so, but if you want to take a crack at it, I'd start by porting [this tutorial](http://davidchristiansen.dk/tutorials/nbe/) to Haskell, and then reading the appendix to _The Little Typer_ called "Rules are Made to be Spoken".
The project started in November and used the latest Stackage LTS at the time, which was [LTS 9.14](https://www.stackage.org/lts-9.14). The first snapshot using GHC 8.2 was [LTS 10.0](https://www.stackage.org/lts-10.0), which didn't come out until mid-December. 
A no-op gc can actually be useful in certain scenarios like ruling out gc-related non-determinism for profiling. See [JEP318](http://openjdk.java.net/jeps/318) for a serious proposal to JVM.
Here a repo with lots of best Haskell Book PDFS: [https://github.com/allenleein/brains/tree/master/Zen-of-Functional-Programming](https://github.com/allenleein/brains/tree/master/Zen-of-Functional-Programming), including [Programming in Haskell](http://www.cs.nott.ac.uk/~pszgmh/pih.html) by Graham Hutton. :) 
Our codebase is about 9 months old and we just upgraded to 8.4. Definitely wasn’t as easy as OP’s experience, but it was pretty much all library breakage from Yesod’s move to UnliftIO (which from my brief-ish investigation is a good move). About 3 days of work to get everything together (but this includes getting Nix working under Mojave). Still, I have no complaints. I have been the one to upgrade my past company’s codebase from Rails 3 to 4, then 4 to 5, and also from Ruby 1.x to 2. It was a massive find and replace operation every time, followed by playing whack-a-mole with exceptions and obscure runtime bugs. I have ~95% confidence our codebase has been correctly and completely updated to the new compiler/libraries without even running it. The process was just make small 
ok so i have installed haskell platform (one click installer ver) i have notepad ++ and installed far manager. am i set to go? basically i write the codes with notepad and run it through far manager? is there some sort of pictorial tutorial for debugging with far manager? do i need anything else. and stuff like GHC, CABAL and Stack are all included in Haskell Platform right?
Thanks i am now installing haskell platform but its awfully slow. it keeps on saying that its 'prepending the target to PATH' or 'appending the target to path' I googled and found only this thread https://github.com/haskell/haskell-platform/issues/78 Little bit help? Am i stuck due to some glitchy things on my computer?
You are basically set up. Try the following: Create a directory for your experiments, and create a file in it with `.hs` extension (that's the standard for Haskell source files), say `hello.hs`. Edit it with either Notepad++ or Far manager to have the following content: module Main where main = do putStrLn "hello world" Now you want to run it. There are 3 different ways you can run it: You can simply enter `runghc a.hs` into the command line (either in Far Manager, or cmd.exe, or other shells). Note that you have to navigate to the directory your file is first. It will print the text `hello world` to the screen (into the shell). If you are in Far Manager, press ctrl-o to see the output (press it again to go back). Or you can compile it to an executable: enter `ghc --make a.hs` into the command line. This will create an executable file `a.exe`, which you can run like other .exe files (in Far Manager, just press enter while you are located on the file; in cmd.exe just type `a.exe` and press enter). The third way is to use the interactive environment GHCi. This wil be very useful for development. First start GHCi by entering `ghci` (but don't forget to first navigate to your directory!). This will take you into a new shell, similar looking to others; but this is a Haskell shell, not an operating system shell. Into this you can type different commands. Typing `:load a.hs` or `:l a.hs` will load your program; then typing `main` will run execute your main function (which is the only one here). Now you can try editing the source file (for example changing the text), and after saving it, you can reload it with `:reload` or `:r`. This feature is very useful while developing programs. Debugging is a harder story. Far Manager cannot really help you with debugging, it's only for navigating in the file system. It does not know about Haskell. GHCi (the last one) has an integrated debugger, but I never used it so I leave it to somebody else to help with that. Debugging Haskell is a bit harder than some of the more mainstream programming languages, because the order your computations are executed in Haskell is less predictable. A simple old trick which can be surprisingly useful is simply to print out temporary results to the screen, and check whether they match your mental model of what the code should do. Good luck!
Is it possible to change the escape character in postgres?
Also it really is annoying if you benchmark stuff. See for example https://ghc.haskell.org/trac/ghc/ticket/15333. 
It's also useful when the machine that runs the program is always destroyed before it runs out of memory: https://blogs.msdn.microsoft.com/oldnewthing/20180228-00/?p=98125
Exciting! Combine this with typed holes and we never need to write term-level code ever again :P
As far as I can see the only issue is the slow installation process. There should be nothing wrong. If it's not working, tell me (perhaps via pm) and I'll look what I can do, when I come back home and have access to my windows machine. 
It's a kind of metaphorical box that resembles a burrito.
&gt; Our Haskell codebase compiles quite quickly on GHC-8.0. But what about the new version you might ask, expecting to hear a gotcha finally come in. It is even faster! Significantly so. Across 100 iterations of building GHC-8.4 came out 24 percent faster on average. This makes me happy.
Well, programs we write are rarely fully correct. Most often they have mistakes, some them are easy to spot, some of them are subtle. For example your web browser etc is not supposed to crash, but still it happens sometimes. These are called "bugs" (for historical reasons, where in very early computers actual flying bugs caused issues). "Debugging" is the process of finding these mistakes, usually by stepping through the working program manually. I think at the stage you are right now you shouldn't worry about this too much. Try to write simple programs, notice when they don't work (often they seem to work correctly for typical inputs, but there are corner cases where they fail), and try to figure out what's the problem. It is important that you build a mental model of what happens in the computer (at some level of abstraction); this will help spotting the issues. Simple examples: One of the simplest data structures in functional languages like Haskell is the list (which is just that, a list of things, for example a list of numbers). The standard list library in Haskell contains a lot of very simple functions which do various operations on these lists. You can look at these [here](https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-List.html), and for each function there is a little "source" button on the right side; when you click on that you can read the source code of that function. I will try and find some introductory resources which guide you through the very first steps.
Same here. It took one dev a few evening; we learned about tons of new cool stuff about ghc 8.6 at ICFP and so he was motivated to spend some time after each day's presentations to at least upgrade us to the latest lts, so we can upgrade to ghc 8.6 as soon as an lts which supports it comes out. The UnliftIO changes were definitely the hardest bits; we ended up writing orphan MonadBaseControl instances and kicking the UnliftIO can down the road, because we want to use effects other than Reader and IO.
What’s the 8.6 stuff you’re looking forward to?
&gt; or whatever I specify on the command line How did you specify it in the command line? Did you try `stack --resolver lts-12.9 new MyProj simple`? (Also note the global project does not specify defaults for new projects; it just supplies a default environment if you are using Stack outside of a project.)
No - I'm aware you **can** specify the resolver but I just did a regular `stack new ProjectName simple`
The video is up now: [https://www.youtube.com/watch?v=VRmn76TZadg](https://www.youtube.com/watch?v=VRmn76TZadg)
The "global project" is not meant to be "global configuration". It is simply a default "project" which is used when you do things like `stack install` outside of any particular project folder. None of the global project settings are used for invocations of `stack new`. Try reading through the debug statements printed by the following command to get a little more insight on when stack falls back to the global project: `stack --verbose exec which ghc` &gt; What would you recommend for stack based projects in particular the resolver setting across time and projects? I would recommend sticking with stack's default of using the latest LTS, and periodically upgrading any projects you actively work on to the latest LTS. Otherwise, you may be missing out on performance or bug fixes. 
Thank you! I *have* misunderstood the global project. That explains what's happening. 
Hi. This is the original poster on an alt-account. Thanks for sharing this!
That's a good question. I would assume so mostly because I can't imagine someone going to all the trouble that `postgresql-simple` does in order read it without good reason, but I couldn't find anything about it after a brief bit of googling. 
DerivingVia and type hole suggestions
Oh somehow I didn't notice before that _you_ are /u/dantheodor, hah. Ah, this makes perfect sense – glad we figured out how to close the loop so to speak.
I'd honestly suggest JavaScript for a very first language for someone interested in programming. Why? Open the browser, press f12, type console.log("hello world") and hit enter. No other language in the world has an easier dev environment bootstrapping experience. Basically, the ability to set up a development environment is entirely orthogonal to learning to program. One has to learn a lot of concepts, vocabulary, and different ways of going about things. Adding in a soft requirement of being a walking IT technician to the whole pile is a bit much. I vastly prefer online one step REPL experiences for dev environments for beginners. Codepen is excellent for this. Very few other languages that I've seen hit this level of ease of experimentation, which is a huge shame. But yeah, there's a lot of things to dislike about JavaScript but it's ecosystem of easy access to tinker tools is something to envy :)
hmm what
I get that – visual feedback is a strong motivator.
oh sorry guys I didnot notice lool
oh sorry guys I didnot notice lool
It's my pleasure. To be perfectly honest, error messages still aren't that great. I'm working on it, but didn't want to delay the release any further (the release fixes a bug which affected pandoc). If you really end up adding HsLua to your project, could you ping me? I'd love to add a list of show-cases to the website.
I've seen a ton of posts lately describing problems with mocking/testing mtl-style constraints. This isn't a perfect solution, but it helps reduce the (n*k) instance problem down to 1 instance per type-class behaviour. Unfortunately it does still require updating all type-class instances each time a new effect is added, but it's mechanical and easy to do so.
What have you tried, exactly?
The point is that this is a beginner question. Pointing them to the cofree comonad is a tad much.
Does it really scale? I mean, on a long-term run, do you consider a project written in such a style be ready to consume a side contribution containing new effect?
&gt; If you really end up adding HsLua to your project, could you ping me? I'd love to add a list of show-cases to the website. Will do!
Honestly? I have no idea how this scales. The fact is though, that even if you use this without extreme granularity it's still (IMHO) strictly more expressivity with less boilerplate overall, so I don't think you're losing anything. The alternative is to basically write tests using your main App monad or not write tests at all, neither of which are great solutions. Plus it's just a cool trick which is applicable to more than just testing (you can use this to specialize the way your app does logging for instance) so I figured it's worth exploring anyways. Maybe I should add a disclaimer that it's not tested in a large app; but people can also reach their own conclusions.
If a dependently typed language uses a formal theory T, the terminating program "check all proofs in T up to 10^10 length, if any proof of 0=1 is found then go into an infinite loop, if no proof of 0=1 is found then terminate" has no short termination proof in T.
You are right.
There isn't really any pattern matching going on. Typeclass method dispatching happens on a per-type basis, and hence is resolved at compile time. If you have some function add :: Num a =&gt; a -&gt; a -&gt; a add x y = x + y, without any optimizations, this gets translated to something like this: data NumDict a = NumDict { plus :: a -&gt; a -&gt; a , minus :: a -&gt; a -&gt; a } add :: NumDict a -&gt; a -&gt; a -&gt; a add dict x y = (plus dict) x y Of course, if the compiler can prove that you have a `NumDict Int`, it can omit the dictionary entirely, and inline the primitive function that adds to Ints. This doesn't always work, since the concrete type may only be known in another module et cetera.
While I think you mbw_rbt's explanation is pretty good, in case you want to read up more on this, you may want to look up "Scrap your typeclasses" (how you'd do it in Elm).
I think it's worth mentioning that the problem is undecidable in general.
It’s part of the learning process, and for many exercises there is more than one way to solve them. Sometimes you may find that after going through a later chapter, you gain additional insight into earlier topics and you can go back and solve previous exercises in a different way. It all benefits you in the end. &gt; I am able to find many repositories when googling but I have so far found some mistakes in a few of them. If you can spot mistakes then you’re obviously learning! :)
Well then, I was expecting this kind of an answer :-D. Maybe you are right. Maybe it is better to post own answers some day which I find correct. :-)
You’ll try so much harder if you know there isn’t a handy set of ‘correct answers’ you can just peek at any time! I know I did :)
Thanks for your advises guys :-).
Absolutely amazing. This is the future for the specification and coding of snippets. How many times you have to create a piece of code that is at the same time easy to define, tedious to program and full of corner cases that makes it a nightmare to program?
A positive, solid piece of real world haskell programming. Congratulations! 
Thanks! :)
&gt; type hole suggestions I thought GHC 8.4 had this? Although admittedly the recommendations haven't been very good in my experience -- half the time the only thing there is stuff like `undefined` or `error`, which is practically never what I want.
I hadn't noticed it was in 8.4, but indeed, it is! There was a presentation about type hole suggestions at the Haskell Symposium whose results looked pretty good, so presumably what's new in 8.6 is that the suggestions make sense now :)
you might be interested in [https://github.com/pushcx/hpffp-resources](https://github.com/pushcx/hpffp-resources) and [https://github.com/larrybotha/haskell-book](https://github.com/larrybotha/haskell-book)
In figure 3, the type of the `S&amp;` constructor S&amp; :: SΓ ks α -&gt; SΓ (k -&gt; ks) (t :&amp;: τ) should be something like S&amp; :: SΓ ks α -&gt; SΓ (k -&gt; ks) (t :&amp;: α)
What level are your assigmnents at? Are you an absolute beginner?
Hey, u/mstksg, I will be sending the new call for contributions in the upcoming week. Just wanted to give a short reminder in advance, hopefully you can submit :) Thanks
Hey, u/fosskers, u/vaibhavsagar, I will be sending the new call for contributions in the upcoming week. Just wanted to give a short reminder in advance, hopefully you can submit :) Thanks
Is remote help fine
Too much magic IMO, I wouldn't trust this to keep type inference and present readable errors. In the example you linked they even said they ran into weird type errors they couldn't solve. It's a super cool idea though! I imagine you could do this with OverloadedLabels too 
No expected date. But bits of it are getting worked on. Ningning Xie [implemented coercion quantifications](https://xnning.github.io/papers/gsoc-report.pdf) this summer. I've heard from reliable sources that Csongor Kiss has a branch of GHC with support for partially applied type families sitting on his computer somewhere. And there are some [GHC proposals](https://github.com/ghc-proposals/ghc-proposals) that deal with other stuff that dependent haskell will need.
Depending on your skill level, I may be able to assist you. I am a tutor at my local college so I have teaching experience.
[removed]
Question about incompatible packages. According to the [MAINTAINERS.md](https://github.com/commercialhaskell/stackage/blob/master/MAINTAINERS.md#following-dependency-upgrades), packages that fail to build will result in either an issue being opened, or *build logs showing failures* being given. I noticed that `haskeline` isn't there anymore, for instance. There isn't an issue on the stackage repo, nor the haskeline repo. I don't know where these build logs are. Using the [packdeps](http://packdeps.haskellers.com/feed?needle=haskeline) with haskeline as needle, I see that `ghci-haskeline` and `haskeline-class` are mentioned as having restrictive upper bounds, but they use the most recent version and aren't on stackage either. Could somebody give some short overview on how to "debug" this kind of thing? How can I find out the steps necessary to get this package back on stackage? (Yeah yeah, rtfm I know...)
I realize that people writing Haskell are not inspecting assembly all that often (compared to say C++ programmers). Nonetheless, this is a super interesting package especially, given that many of us here use Emacs or similar. Since it supports bytecode inspection as well, perhaps it could be hacked to include support for GHC Core as well.
I'll help, PM me if you'd like to set up a time to call.
Sure... so it looks like [buildQuery calls buildAction](https://github.com/lpsmith/postgresql-simple/blob/master/src/Database/PostgreSQL/Simeple.hs#L282) which [in turn calls](https://github.com/lpsmith/postgresql-simple/blob/master/src/Database/PostgreSQL/Simple/Internal.hs#L565) one of [the escaping functions](https://github.com/lpsmith/postgresql-simple/blob/master/src/Database/PostgreSQL/Simple/Internal.hs#L584) which rely on [escapeWrap](https://github.com/lpsmith/postgresql-simple/blob/master/src/Database/PostgreSQL/Simple/Internal.hs#L576) which makes the actual connection to get the value.
I think this is too overcomplicated for now. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [lpsmith/postgresql-simple/.../**Internal.hs#L565** (master → 14d00c2)](https://github.com/lpsmith/postgresql-simple/blob/14d00c22713aab7d55a81a81b47cc5bb7280398f/src/Database/PostgreSQL/Simple/Internal.hs#L565) * [lpsmith/postgresql-simple/.../**Internal.hs#L584** (master → 14d00c2)](https://github.com/lpsmith/postgresql-simple/blob/14d00c22713aab7d55a81a81b47cc5bb7280398f/src/Database/PostgreSQL/Simple/Internal.hs#L584) * [lpsmith/postgresql-simple/.../**Simeple.hs#L282** (master → 14d00c2)](https://github.com/lpsmith/postgresql-simple/blob/14d00c22713aab7d55a81a81b47cc5bb7280398f/src/Database/PostgreSQL/Simeple.hs#L282) * [lpsmith/postgresql-simple/.../**Internal.hs#L576** (master → 14d00c2)](https://github.com/lpsmith/postgresql-simple/blob/14d00c22713aab7d55a81a81b47cc5bb7280398f/src/Database/PostgreSQL/Simple/Internal.hs#L576) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e6x77gh.)
I'm gonna keep shilling for DerivingVia though – IMHO it's the most modular DI you can do in Haskell without going full handle pattern everywhere.
Here are some more issues: https://github.com/search?q=label%3Ahacktoberfest+state%3Aopen+type%3Aissue+language%3Ahaskell&amp;type=Issues
Yes, it would. However, it avoids global knowledge, avoids listing all the modules in one place and avoids mtl lifting rules – which is why I say it's more modular. Phantom data kinds are definitely way more convenient when the amount of modules is low, I'm not saying they're bad at all. But I do think that DerivingVia scales much better by avoiding pretty much all global constructs.
I recently noticed how Stack was suddenly downloading and compiling everything so much faster than usual. It was also doing many packages simultaneously, something I had never noticed it doing before. I must have upgraded Stack at some point. My mind was blown. It seems like someone has been making some improvements under the hood. It's good to know someone has got my back. Thank you all for your efforts.
Yup, DerivingVia is definitely a clean and easily understandable solution; it may avoid the traditional n+k, but you'll still pay the tax on the number of possible combinations you'll need to newtype. That said, the code involved in enumerating them is relatively small and pretty tough to screw up; so maybe it's worth the boilerplate for the clarity it brings.
What is the simplest, but still convincing, explanation that `forall a. a-&gt;a` is the identity function (or something that fails to compute)? I'd answer 'Reynolds Abstraction Theorem', but that isn't really the intuitive layman explanation.
I'm trying to define a Free Monad (my first free monad) on top of some instructions that have to be played out. Essentially I have Events coming in, and I want to be able to handle these events. The handlers should be able to perform certain actions, pause and wait for the next event, pass the event on to subsequent handlers and finally (and here is where I'm struggling) conditionally branch based on certain predicates. ``` data HandlerF e a = Act Action a -- ^ Perform an action and keep processing | Next (e -&gt; a) -- ^ Wait for the next key to keep processing | Continue a -- ^ Hand the event down to the next handler | Done -- ^ Wrap up this branch | Choice Predicate (a, a) a -- ^ Choose one of two branches deriving (Functor) type Handler = Free (HandlerF Event) ``` I've understand how to implement most of the utility functions etc. but I can't for the life of me figure out how to deal with that last `Choice` option. How do I define branching behavior in a Free Monad? The final `a` parameter in the `HandlerF` datatype is the next instruction to be executed, but the `Choice` datatype doesn't have one, it has two. All the examples I've found online seem to be of linear execution of different commands but I haven't found any that include conditions and branching like this. Is what I'm trying to do simply impossible, am I trying to apply the wrong tool, or am I just not getting the implementation right? Any advice would be deeply appreciated.
I'm doing the capstone project from unit one in *Get Programming with Haskell* by Will Kurt. But I got a problem with one of the extra exercises at the end. The exercise instruction: &gt;Write a threeRoundFight function that takes two robots and has them fight for three rounds, returning the winner. To avoid having so many different variables for robot state, use a series of nested lambda functions so you can just overwrite robotA and robotB. The following code compiles without problem: robot (name, attack, hp) = \message -&gt; message (name, attack, hp) name (n, _, _) = n attack (_, a, _) = a hp (_, _, hp) = hp getName aRobot = aRobot name getAttack aRobot = aRobot attack getHP aRobot = aRobot hp setName aRobot newName = aRobot (\(n, a, hp) -&gt; robot (newName, a, hp)) setAttack aRobot newAttack = aRobot (\(n, a, hp) -&gt; robot (n, newAttack, hp)) setHP aRobot newHP = aRobot(\(n, a, hp) -&gt; robot (n, a, newHP)) damage aRobot attackDamage = aRobot (\(n, a, hp) -&gt; robot (n, a, hp - attackDamage)) fight attacker defender = damage defender attack where attack = if getHP attacker &gt; 10 then getAttack attacker else 0 killerRobot = robot ("Kill3r", 10, 100) gentleGiant = robot ("Mr. Friendly", 10, 300) threeRoundFight robotOne robotTwo = (\r1 r2 -&gt; (\r1 r2 -&gt; (\r1 r2 -&gt; "Round 3" ) r1 r2 ) r1 r2 ) (fight robotOne robotTwo) (robotTwo) But when I switch `(robotTwo)` to `(fight robotTwo robotOne)` at the end of the `threeRoundFight` function I get two error messages when I try to compile. This code threeRoundFight robotOne robotTwo = (\r1 r2 -&gt; (\r1 r2 -&gt; (\r1 r2 -&gt; "Round 3" ) r1 r2 ) r1 r2 ) (fight robotOne robotTwo) (fight robotTwo robotOne) cause this two errors: Prelude&gt; :l robot.hs [1 of 1] Compiling Main ( robot.hs, interpreted ) robot.hs:45:72: error: • Occurs check: cannot construct the infinite type: b1 ~ ((a2, b1, p) -&gt; t1) -&gt; t1 Expected type: ((a2, ((a2, b1, p) -&gt; t1) -&gt; t1, ((a2, b1, p) -&gt; t1) -&gt; t1) -&gt; ((a2, b1, p) -&gt; t1) -&gt; t1) -&gt; a1 Actual type: ((a2, b1, p) -&gt; ((a2, b1, p) -&gt; t1) -&gt; t1) -&gt; a1 • In the first argument of ‘fight’, namely ‘robotTwo’ In the second argument of ‘\ r1 r2 -&gt; (\ r1 r2 -&gt; (\ r1 r2 -&gt; "Round 3") r1 r2) r1 r2’, namely ‘(fight robotTwo robotOne)’ In the expression: (\ r1 r2 -&gt; (\ r1 r2 -&gt; (\ r1 r2 -&gt; "Round 3") r1 r2) r1 r2) (fight robotOne robotTwo) (fight robotTwo robotOne) • Relevant bindings include robotTwo :: ((a2, b1, p) -&gt; ((a2, b1, p) -&gt; t1) -&gt; t1) -&gt; a1 (bound at robot.hs:36:26) robotOne :: ((a, ((a, b, a1) -&gt; t) -&gt; t, ((a, b, a1) -&gt; t) -&gt; t) -&gt; ((a, b, a1) -&gt; t) -&gt; t) -&gt; p (bound at robot.hs:36:17) threeRoundFight :: (((a, ((a, b, a1) -&gt; t) -&gt; t, ((a, b, a1) -&gt; t) -&gt; t) -&gt; ((a, b, a1) -&gt; t) -&gt; t) -&gt; p) -&gt; (((a2, b1, p) -&gt; ((a2, b1, p) -&gt; t1) -&gt; t1) -&gt; a1) -&gt; [Char] (bound at robot.hs:36:1) | 45 | ) (fight robotOne robotTwo) (fight robotTwo robotOne) | ^^^^^^^^ robot.hs:45:81: error: • Occurs check: cannot construct the infinite type: b ~ ((a, b, a1) -&gt; t) -&gt; t Expected type: ((a, b, a1) -&gt; ((a, b, a1) -&gt; t) -&gt; t) -&gt; p Actual type: ((a, ((a, b, a1) -&gt; t) -&gt; t, ((a, b, a1) -&gt; t) -&gt; t) -&gt; ((a, b, a1) -&gt; t) -&gt; t) -&gt; p • In the second argument of ‘fight’, namely ‘robotOne’ In the second argument of ‘\ r1 r2 -&gt; (\ r1 r2 -&gt; (\ r1 r2 -&gt; "Round 3") r1 r2) r1 r2’, namely ‘(fight robotTwo robotOne)’ In the expression: (\ r1 r2 -&gt; (\ r1 r2 -&gt; (\ r1 r2 -&gt; "Round 3") r1 r2) r1 r2) (fight robotOne robotTwo) (fight robotTwo robotOne) • Relevant bindings include robotTwo :: ((a2, b1, p) -&gt; ((a2, b1, p) -&gt; t1) -&gt; t1) -&gt; a1 (bound at robot.hs:36:26) robotOne :: ((a, ((a, b, a1) -&gt; t) -&gt; t, ((a, b, a1) -&gt; t) -&gt; t) -&gt; ((a, b, a1) -&gt; t) -&gt; t) -&gt; p (bound at robot.hs:36:17) threeRoundFight :: (((a, ((a, b, a1) -&gt; t) -&gt; t, ((a, b, a1) -&gt; t) -&gt; t) -&gt; ((a, b, a1) -&gt; t) -&gt; t) -&gt; p) -&gt; (((a2, b1, p) -&gt; ((a2, b1, p) -&gt; t1) -&gt; t1) -&gt; a1) -&gt; [Char] (bound at robot.hs:36:1) | 45 | ) (fight robotOne robotTwo) (fight robotTwo robotOne) | ^^^^^^^^ Failed, no modules loaded. I can't come up with an explanation why it cause an error. Shouldn't both expressions result in a two new "objects" being accessible for the inner lambda functions? The book doesn't contain a solution for this extra exercise.
You can make the idea of "if I try to do it, there's really only one way" more formal by enumerating terms in normal form having that type and find that the only one is indeed the identity function. Take System F for simplicity's sake. By exhaustive inspection of the typing rules of the language, we can show that a term of type `forall a. a -&gt; a` in normal form must start with a type abstraction and a value abstraction, and the only way to complete the function body is to put the single variable in scope. [This blogpost gives a more involved example](http://prl.ccs.neu.edu/blog/2017/06/05/syntactic-parametricity-strikes-again/) (I'm the second author), where we show `forall a. [a] -&gt; [a]` to be isomorphic to a product of concrete list types.
The constructor `Choice Predicate (a, a)` is equivalent to `Choice Predicate (Bool -&gt; a)`. (Assuming the third `a` to be a typo.) So that's like a combination of `Act` and `Next`, where the action is instead to evaluate a `Predicate`, and the expected result is the value the predicate. Putting the continuations `a` in a function `(Bool -&gt; a)` or in a pair `(a, a)` only changes how you extract it given a boolean `b`, by applying it `(k :: Bool -&gt; a) b` or by using a field selector `(if b then fst else snd) (k :: (a, a))`. 
For the record, ~1000 packages have been dropped.
Find something you can write/prototype in Haskell without anyone complaining (utilities that improve your team's productivity are probably the best candidates). Keep the code simple and well formatted and share ithe utilities with your team ("oh, btw, this is written in Haskell."). Leave simple modifications/parameters that people might want to change to be editable by editing the source. Direct the ones that are interested to resources that can help them get started quickly.
Yeah, Core would be great. 
I think most of them will be back up before the LTS containing GHC 8.6 is released. At least that was the case previously.
When GHC gives you cryptic error messages like this, the first course of action is generally to add type annotations for at least the top-level functions. This will clarify where your expectations and GHC's diverge (and is good practice anyway). At a glance, I don't see the exact problem either, but it is suspicious that GHC infers different types for `robotOne` and `robotTwo`.
That makes perfect sense. I can see clearly now the fog is gone. Thanks! :-D
Thank you!
Yes please! I'll keep an eye out.
&gt; I had the unique opportunity to take a merger between two IT companies and build their software development department culture and tooling from scratch. I now have 10 never-touched-Haskell-before developers happily building a myriad of projects with it. I have a lot of questions! Not sure if you'd be comfortable answering them all but here goes: * How long did it take to go from zero Haskell to reasonably comfortable (mean +- stdev)? * How did you manage different people learning at a different pace? * Were people incentivized/nudged to learn Haskell? If yes, how? * More generally, how did you offset the negative feelings people felt when they were unproductive as beginners? How did you manage expectations w.r.t. "yes, this will take more time to learn than you might anticipate"? * How did you bootstrap, so to speak? By writing some non-critical code in Haskell? At the bootstrapping step, I'd think it would be hard to advertise ease of refactoring and have people take it seriously. More succinctly, could you please write a blog post detailing your journey + strategies and do an AMA here?
I think you should at least implement a Haskell web app first before trying to convince your company to try it
Only if they notify the maintainers. I wasn't yet.
Now, if you ask 'Why?' after any of the above claims, is there a better answer to any of them "because it's defined like so!"? &amp;#x200B;
What benefits do you think it will bring to the project? Is it just because you like Haskell or you like functional programming? If its because functional programming is good practice then maybe you should suggest Scala, Kotlin, F#. 
Has anyone managed to successfully build a project that uses Backpack on Windows? I keep getting errors during compilation/linking: "ar.exe" complains that it can't find a file with a really long path. Lifting the Windows limitation on long paths didn't seem to help.
Maybe /u/saurabhnanda can share his experience.
Opaleye can do that: https://hackage.haskell.org/package/opaleye-0.6.7002.0/docs/Opaleye-Sql.html#v:showSql I was also frustrated by Esqueleto in this regard: https://stackoverflow.com/questions/20435797/how-can-i-get-esqueleto-to-generate-an-sql-string-for-me
Our application keeps a lot of data around for significant amounts of time. The vast majority of that data consists of primitive values living inside large [Data.Vector.Storable](http://hackage.haskell.org/package/vector-0.12.0.1/docs/Data-Vector-Storable.html#g:1) vectors. Now that I'm working on optimizations, I want to be sure that these vectors are stored outside the GC's heap, so that they aren't copied and traced during each GC cycle. I was looking into whether the relatively new [compact regions](https://downloads.haskell.org/ghc/latest/docs/html/libraries/ghc-compact-0.1.0.0/GHC-Compact.html) feature would help, but I believe storable vectors already provide the same benefits, am I right?
Great questions. The caveat is that I’ve had a long term relationship with this company, even if I haven’t worked with them the entire time. Without that prior connection I am not sure I could have achieved bringing Haskell development into the company, at least not easily. It helps to know what the company is for starters. Officially we are a Managed Service Provider who sells data center servers and Microsoft support to small-medium sized companies. Our new parent company is a telecom, of which we have taken over their internal IT services, including software development. I have worked with my CEO in various capacities for ~20 years now, and we have talked about building a software company during that time, but the timing was never right. After the merger we've been able to get things rolling finally. Right now we are building software to suit both the parent company and our own business needs. To be fair it is mostly boring enterprise style stuff. &gt; How long did it take to go from zero Haskell to reasonably comfortable (mean +- stdev)? The only true development tools and culture my company had were from when me and a colleague consulted for them years ago, which is to say not really anything at all. The rest of the team were not interested in enterprise programming, and definitely wanted to tinker with FP (via Elixir). The parent company could reasonably be said to be a C# shop, but not something the developers felt they were married to. That said, they had very reasonable points of view on writing code in an enterprise scenario, but were also constrained by that point of view as well. Needless to say they were the hardest to win over (and we lost a few due to unhappiness with the merger anyways). That all said, my colleague and I prototyped a core system in 3 months , during which time others were working on existing projects while learning Haskell via books and talks from me. After that point we added more members and spun up another project. The fastest person to become absolutely productive was about a month, the slowest maybe 3 months. After 6 months everyone was on the same page. We are training a new dev right now and it is going even faster due to cumulative knowledge. It’s been 1 year and 9 months since I started as the manager of this team, and we have 3 user facing applications and a dozen blackbox vendor wrapping microservices making our lives easier. No C# development is officially occurring, although we still support a handful of apps. It’s worth noting we have a very solid devops culture behind all this, which I think ultimately helped sway hearts and minds as much as using a powerful language like Haskell. &gt; How did you manage different people learning at a different pace? There's no straightforward answer really. The simplest answer is: We fully expect to spend ~1 month training someone new to Haskell. To help move that along, we are now at a point where we can slide someone into an existing project and have them learn by knocking out features. Everyone learns differently, so I try to find the right combination of book reading (LYAH, HB), relevant blog posts, or one on one meetings to help move people forward. &gt; Were people incentivized/nudged to learn Haskell? If yes, how? I mostly answered this, but half the team was already chomping at the bit to do functional programming. Incentivizing the rest of the people simply took patience, persistence, and showing them the strengths of the paradigm. &gt; More generally, how did you offset the negative feelings people felt when they were unproductive as beginners? How did you manage expectations w.r.t. "yes, this will take more time to learn than you might anticipate"? This was probably the hardest hurdle to get over. For the few that knew absolutely nothing about Haskell, it was frustrating to learn that they couldn't pick up the language in a day, let alone a week. There were a few strong rants at some point even, however, I think the desire to not be "defeated" allowed them to overcome their misgivings. As for myself, it was a test of conviction + tenacity as I pointed out in [this exchange on twitter](https://twitter.com/mojobojo/status/921522791731511298). The most important lesson I learned personally is that you have to be diplomatic, and above all patient. Maybe that is just my age showing, but 10 years ago I'm not sure I would have been so successful. &gt; How did you bootstrap, so to speak? By writing some non-critical code in Haskell? As mentioned earlier, my colleague and I bootstrapped a core application, and then we added people onto that project and the supporting microservices. In our case this was a nice split between writing Servant APIs and Reflex UIs. I tried to cater to people's interests (backend vs. frontend), and for the most part it ended up working out. A few guys are still learning the other technologies, but their general Haskell experience has some solid foundations now. I've considered writing a blog post about this over the past year or so, but I was never sure whether this information would benefit many people. It truly was a right place-right time kind of scenario.
Is there any plans to fast-track support for backpack ? This is something that is really missing from stack and that is the reason why my crypo-library raaz is not on stackage. 
you should write a blog post about it. it will support the language growth too.
Why can't we [compact](http://hackage.haskell.org/package/compact-0.1.0.1/docs/Data-Compact.html) a function? What's stopping the runtime from compacting a function's closure along with a [static pointer](https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/static-pointers.html) to the function? The ability to compact functions would be incredibly powerful, could do wonders for distributed computing.
Why do you have to yield an 'a'? The type says so. Why is it arbitrary? Because it is implicitly quantified as any possible 'a' at all. Why can't you conjure up a value of an arbitrary 'a'? One example showing that is that 'a' could be the empty type, with no values at all. Language-wise, there's also no construct that generates values of such types. That also explains why the 'a' you received as a parameter is the only 'a' you can use. Why can't you manipulate values of an unconstrained type \`a\`? Because it is an opaque black box -- as there are no properties it's guaranteed to have. There is no shared commonality between values of \*all possible types\*.
It would be really hard to introduce in Ruby shop. The prime reason to use Rails is the quality and quantity of libraries. Haskell certainly doesn’t have that. And anyway will it solve any problems your team is facing?
No. There is per definition no value that all types share with the exception of bottom (`let x = x in x :: forall a. a`). That means the only value you can use is the one that is in scope.
Not sure what exactly are you trying to do, but you can likely use persistent's \`mockMigration\` for that: [https://www.stackage.org/haddock/lts-9.0/persistent-postgresql-2.6.1/Database-Persist-Postgresql.html#v:mockMigration](https://www.stackage.org/haddock/lts-9.0/persistent-postgresql-2.6.1/Database-Persist-Postgresql.html#v:mockMigration)
Find that you get in ICFP and decide to reread your paper. Congrat! Was just talking with my friends about incoherent instance and Map issue (I am all for class = implicit dict and incoherent should be fine camp), and the paper solve it in ghc right now, nice.
&gt; The regular test assertions of Hspec would print the entire trees in a failing test, which is not helpful. https://hackage.haskell.org/package/tree-diff ! &gt; make it easier to troubleshoot differences between results, we implemented a contextual difference pretty-printer, showing us any specific difference and the surrounding context: :(
Holy crap, Haskell in ZA?
The release candidate is here https://hackage.haskell.org/package/raaz-0.3.0/candidate One unfortunate side effect of the backpackisation is that docs have suffered. It is not entirely clear how the documentation should be exposed, because now the api description is in the signature files, where as the top level exposes the mixed-in variant. I am not sure if there is a good story here. 
 I'm trying to interpret an ast
Hmm! I don't know of any such notation, but remember that refactoring is easy in Haskell, so you might not need as much ahead-of-time preparation as you think. Another concern I have about such a notation is that we have many different ways to compose smaller parts into larger parts, it's not always objects composed of other objects like in OOP. So I think you should first decide on how you want to combine your top-level components, and then pick an appropriate notation for that, and then if that isn't detailed enough, decide how each of those are composed from smaller components, and draw a separate diagram for each one, possibly with different notations. Or, to make things simple, you could use Monad Transformers everywhere. That's not as elegant as using dedicated combinator libraries, but it's a common approach and it's imperative enough that I think UML class diagrams might model them just fine.
Ah, that makes more sense! What is the type of `eval`?
Try the [hint library](http://hackage.haskell.org/package/hint-0.8.0/docs/Language-Haskell-Interpreter.html#v:interpret).
Just to clarify: we wanted the *minimal* relevant context, whereas `tree-diff` shows the *full* context. Another thing is that we needed a custom representation of numeric values in order to facilitate inexact comparisons. /u/phadej, please let us know if these features are somehow supported in `tree-diff`, or if you think they are in scope for a future version.
An interesting suggestion. It would seem to me as if the hard part's already there in hoogle integrations. You'd have to figure out how to query it though, with the specific type or polymorphically too.
`eval :: Map.Map String Int -&gt; E -&gt; IO (Int, Map.Map String Int)` &amp;#x200B; but i'm trying to be able to use this to evaluate more stmts `exec vars (Seq n) = exec vars (head n)` i tried: `exec vars (Seq n) = map exec (vars, n)` but i can't get it to work
Based on the fact that there are zero issues in https://github.com/phadej/tree-diff/issues I can only say that the current version of `tree-diff` is perfect. Without feedback it's very hard to improve things.
`map` won't work because it can only apply a _pure_ function to all the elements of the list, but you are trying to apply an IO action. Try [`traverse`](http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Traversable.html#v:traverse) instead, as it is designed to apply an _action_ to all the elements of a container. The other problem is that you are applying `map` to a function of two arguments and tuple, but `map` expects a function of one argument and a list. I am guessing that you want to apply `exec` to `vars` and to each element of `n`, but that's not all all what you wrote. Remember that you can apply a function to some of its arguments in order to obtain a function which expects fewer arguments, so while `exec` expects two arguments, `exec vars` only expects one! Instead of using either `traverse` or `exec vars`, however, I recommend writing a recursive function evalList :: Map.Map String Int -&gt; [E] -&gt; IO ... which pattern-matches on the list in order to call `eval` on each element one at a time. That's what `traverse` does under the hood, but before using a higher-order function such as `traverse`, it is good practice to write the corresponding code manually a few times, in order to get an intuition for what that higher-order function is doing under the hood.
that stuff is impressive , i need to look into it more. does it relate back to this use case where you just have one type.. the expressing is incomplete. I realise an inherent philosophical difference between expression and statement syntax, still 1 type should narrow things better than nothing sometimes
i'm sorry, but i still can't figure out what to do. i get that i can't use map, but i don't know how to apply traverse or mapM to this? &amp;#x200B;
Makes sense, I made https://github.com/commercialhaskell/stackage/issues/4008 ( and 4009 and 4010) as a best effort to notify people. It's error prone, we need to get more tooling to do this properly.
That's a good idea, but we need more tooling for this. I'll open an issue later today when I'm back (need to run to work now)
What libraries are you using? 
There is https://github.com/commercialhaskell/stack/issues/2540 but development there is slow
I'd start with this: https://github.com/yesodweb/yesod-cookbook/blob/master/Cookbook.md#auth
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [yesodweb/yesod-cookbook/.../**Cookbook.md#auth** (master → a68518d)](https://github.com/yesodweb/yesod-cookbook/blob/a68518d989f333247d70b503d31452f0371c1e25/Cookbook.md#auth) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e6yyhpx.)
&gt; If its because functional programming is good practice then maybe you should suggest Scala, Kotlin, F#. I'm not familiar with F#, but Scala has *many* impediments to functional programming and Kotlin just isn't a functional programming language. There's absolutely no reason to pick Scala over Haskell for web development.
Autocompletion on dot sure is nice, and if you have some working autocompletion setup, (I use emacs + intero, but there are many alternatives), it works on the module level - i.e. for things like `MyModule.foo`. On the other hand, in OOP languages you might argue that it can invite people to push too much stuff into class methods and/or interfaces instead of free functions, and violate the law of Demeter by having many nested calls like `foo().bar().baz()`. In the C++ world at least, it is recommended to prefer non-member functions (unless you actually need to rely on class internals, for instance for efficiency reasons), see [here](https://stackoverflow.com/questions/5989734/effective-c-item-23-prefer-non-member-non-friend-functions-to-member-functions) for example. I don't know, is this different in Java? Of course in Java, you use the dot for module qualification as well, but you specifically talked about member functions. In any case, the canonical "nested dot equivalent" is probably `lens` anyway. Example: &gt;&gt;&gt; myData = [("First", Just [1..5]), ("Second", Nothing), ("Third", Just [6..10])] &gt;&gt;&gt; sumOf (each._2._Just.each) myData -- sum all numbers 55 &gt;&gt;&gt; myData &amp; each._2._Just %~ sum -- polymorphic update with partial sums [("First",Just 15),("Second",Nothing),("Third",Just 40)] &gt;&gt;&gt; myData^..each._1 -- get every first tuple element ["First","Second","Third"] &gt;&gt;&gt; myData^? ix 2._2._Just.ix 3 -- Get the nested element, if it exists Just 9 The weird operators are just synonyms for normal functions, which you could use instead. But here, the dot is just the usual `(.)` function composition operator. I feel that any clever IDE solution would have to play nicely with lens, since it is the most powerful data manipulation language we have right now.
I found looking at examples in [yesod-auth](http://hackage.haskell.org/package/yesod-auth-1.6.4.1/docs/Yesod-Auth-Hardcoded.html) helped me implement some pretty insecure auth for my website.
&gt; in OOP languages you might argue that it can invite people to push too much stuff into class methods oh absolutely. Seperate debate - I'm on the side that wants UFCS in C++ to avoid that. Just like we see here with ```foo a b``` ```a `foo` b```, it is my opinion that the "." should just pretty much be a syntactic convenience for the reader/writer of code, and nothing whatsoever to do with the organization of functions
Thanks for your reply. Once I am done with exercises I can check on yours and compare. :-)
With Yesod auth you can create a plugin that will do whatever you want to verify someone and then provide a credential record to the authorize function. I’d look at other plugins to see how they do it.
Something I've been thinking of trying someday is an autocomplete UI that offers nice suggestions for holes that includes functions whose return types would fit in the hole. Completing to such a function would initially fill in the parameters with more holes. When combined with some hotkeys for moving the cursor from hole to hole, there might be a really compelling, convenient flow for building up expressions.
Jump to def could be done using tags, depending on what editor you're using? I think both Intero and HIE have name completion once you start typing the name itself.
&gt; es it relate back to this use case where you just have one type.. the expressing is incomplete No, type holes only work on syntactically-valid expressions. If you write foo `_` you will get a syntax error, not a valid-substitution suggestion. &gt; I realise an inherent philosophical difference between expression and statement syntax Haskell doesn't really have statements, only expressions, so I'm not sure what you mean here
&gt; i know you could also make an equivalent of the F# |&gt; operator There's `&amp;`. `|&gt;` is also in the `flow` library
While I am all for UX improvements, I think the workflows in a typed functional language and a C++/Java-ish language are a little different. For one, you can always have a REPL open (or use whatever editor integration you are comfortable with), and use `:info MyType` to see how it can be (de)constructed, what typeclasses apply and so on. If you implement some algorithm, you can use expressions like `foldr _ Set.empty inputList` and have GHC tell you what kind of function is needed here. You don't have dot-directed autocompletion, but other tools to compensate for it. Then there's the other aspect of having sum types, meaning that applying `foo` to `a` might not always be the right thing to do for every `case`, whereas an Object is supposed to know what to do on its own when you call some method. Point being, I *personally* don't agree with the notion that it is "such a pain point". There are things that slow down productivity, but this isn't it. Records as they are right now are a pain point. And we spend more time thinking about how to make some impossible state unrepresentable, or make things more explicit at the type level. There is also some vocabulary that is shared across libraries, and thus they are required to be imported qualified. For instance, the `vector`, `containers` and `unordered-containers` packages contain many functions that are very similar to the ones found in the `Prelude` and in `Data.List`. Even if you don't know the exact name of a function, with some experience you will gain some intuition about what the "approximate shape" of its type signature should be, and you can hoogle it. If you use `stack`, you can use `stack haddock --open containers` for example, to browse documentation locally. I think this helps a lot, and unlike a few years ago, documentation is searchable now ("Quick Jump"). This is all not perfect, but I think there are some things that make up for "lost autocompletion time" too. Refactoring in Haskell is in my opinion an order of magnitude faster and safer, especially for the stuff an IDE can't help you with. And unlike in an OOP language, I can do "the dumb thing" and don't need to anticipate change and design big up front. That is all subjective of course. And if I really have no idea what I'm doing, I defer things of course: transmogrifyWith todo (inp :: [Int]) = do confirmed &lt;- todo inp case confirmed of Left _ -&gt; undefined Right (fp :: FilePath) -&gt; undefined or something like that, and keep checking the inferred type, think more about my problem based on it, and iterate. My problem might become easier if I generalize the type, or if I make it more concrete, perhaps even by introducing some throw-away type that is only used once. Some of these things, like being guided by type inference, I just can't do in C++, and I need to structure my thoughts around the language differently. Perhaps you have some example where you thought that Haskell was "in the way"?
With emacs/intero, jump-to-def works with `M-.`. It won't jump into library code, though.
Is remote a possibility?
(And `Data.Sequence`/`Control.Lens`.)
Certainly, I'm not making any claims of equally sophisticated tooling here, just trying to give approximations. Lots of big companies use C++ for large codebases, and there is some excellent tooling available for it. I did a C++ internship where I used Visual Assist and it worked remarkably well, so I understand your perspective/expectations to an extent. However, I personally find the language ergonomics to be more important, so I'm okay if the tooling isn't perfect.
This is sorta offtopic, but there's this \[gdiff-1.1\]([https://hackage.haskell.org/package/gdiff-1.1](https://hackage.haskell.org/package/gdiff-1.1)) package. Could you get a tree-diff from the gdiff?
Would dropping the upper bound solve the problem?
Lamdu is doing exactly what you describe (though not for Haskell code)
Great to see more Haskell in the Bay Area!
If you use Nix (which many Haskellers do), apparently you need to upgrade to Nix 2.1 before upgrading to Mojave ([http://weekly.nixos.org/2018/09-nixcon-2018-program-macos-1014-mojave-support-haskell-and-python-packaging-tips.html](http://weekly.nixos.org/2018/09-nixcon-2018-program-macos-1014-mojave-support-haskell-and-python-packaging-tips.html) )
You can only work with what you know. In a -&gt; a, We know nothing except that we have some value, a. Because we have no other values and because we know nothing about a, we can only echo back a.
The speaker at one point remarks "We can distinguish `foldl` and `foldr`, for example." Surely he meant `foldl` and `foldl'`?
&gt; I would even personally consider rebinding the . to insert a pair of backpacks unless after a numeric literal, and if you delete one it reverts to a dot.. it's burned into my fingers that deeply Don't do this.
There were some requests in the https://www.reddit.com/r/haskell/comments/9kafdv/how_to_introduce_haskell_in_a_webdev_shop/ thread to write a blog post, so here you go. I hope it helps.
I'm learning Haskell and haven't really been sold on the value of laziness or non-strictness. I wish I could watch a video about just the first slide of this talk. Could anyone share some resources on this topic?
Tsuru Capital is looking for interns. Haskell knowledge is required, experience with pricing futures/options would be nice but not necessary. Located in Tokyo, company language is English. Casual environment, nice monitors and a big coffee machine. Duration 3-4 months, starting at your convenience. We will help you with visa and looking for a place to stay. There's some salary. Details how to apply are on our website. Feel free to ask questions here, in email or #tsurucapital on freenode.
Thank a lot. I could do this.
Fun fact: I found the project on github before it was published and told the author(s) exactly the same: their usage of "laziness" is just "non-strictness". So I definitely share your opinion : ) I think they adjusted the usage in the paper a bit. For interested readers: there's also work on testing functions for unnecessary strictness by Christiansen and Chitil. The tool introduced by Chitil even has the same name as the tool presented in the paper. [Sloth – A Tool for Checking Minimal-Strictness] (https://www.rpe.informatik.uni-kiel.de/de/rechnergestutzte-programmentwicklung/dateien/forschungunddiplomarbeiten/PADL.pdf) [Investigating Minimally Strict Functions in Functional Programming] (https://macau.uni-kiel.de/servlets/MCRFileNodeServlet/dissertation_derivate_00004370/dissertation_jac.pdf) [StrictCheck: a Tool for Testing Whether a Function is Unnecessarily Strict](https://kar.kent.ac.uk/30756/1/content.pdf)
I never worked with you, but I worked for three years at a rails shop where there was a bit of elixir/go/swift dabbling on the side. Everything written above is accurate. I managed to push some ideas that I'd picked up from FP, but knew I'd never be able break to say "I can be that guy if things catch fire", so I ended up moving jobs to get that full-time haskell experience. Meanwhile, my former colleagues on the frontend went from jQuery to React to Redux to Elm and are now keener on the paradigm. That lead to an institutional perspective shift that made people much more amenable to trying Haskell on the backend. At this point they're teething with backend deployment questions, but they'll get there.
You can do `-Werror=incomplete-patterns` so you can't just ignore the incomplete pattern match.
There was a question about the strictness of f x = undefined And ghc's answer is kinda interesting. x is 'Hyperstrict' - if we force `f x` then we always diverge so it is safe to evaluate `x` arbitrarily deep before entering `f x`. In other words `f x` may be rewritten to ```x `deepseq` f x```. This means exceptions in pure code are imprecise, ghc can change which one is thrown if the function crashes either way. Similar to undefined behaviorin c/c++ I guess?
Well, we know that completion _should_ activate after every infix operator, because it makes sense. In other cases IDE can just wait until the user has stopped typing for some time before trying to autocomplete. You can use `_` to instantly trigger autocompletion suggestions - the semantic is that a user who put down a hole likely wants to fill it in ASAP.
[Why Functional Programming Matters ](http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html) shows how laziness aids modularization. There are also cases where laziness gives asymptotic speedups over pure functional programs, e.g. Data.Sequence. And custom control combinators usually require macros and are really easy in haskell. Guess that could be interpreted as a form of modularization as well, though. 
&gt; Haskell doesn't really have statements, only expressions, that's exactly what I mean I realise: inherent philosophical difference between imperative statements (eg C++) and pure expressions (Haskell) with middle-grounds like Lisp
&gt; Autocompleting haskell code would be a nightmare since you'd have very little syntactic shortcuts to narrow I say the opposite: the point is you could choose any of those to trigger the search. What you actually insert after you found it is up to you. imagine (the cursor at the end in each..) step 1 - you type ``` someBinding ` ``` step 2 - the IDE shows you... ``` someBinding `suitableBinaryFunc1` :: ...-&gt; ``` ``` someBinding `suitableBinaryFunc2` :: ...-&gt;``` ``` ... ``` ``` (suitableOtherFunc2:: *Bar*-&gt;Baz ``` ``` (suitableOtherFunc1:: Foo-&gt;*Bar*-&gt;Baz-&gt;``` ``` (suitableOtherFunc3:: Foo-&gt;Foo-&gt;*Bar*-&gt;Foo-&gt;Baz ``` you could still select the last . and it will refactor what you just typed into (suitableOtherFunc _ _ Bar _) the IDE takes ` as a hint you wanted it as the first parameter. or you could start the process with ```|&gt;``` take that as a hint you want it as the last parameter instead hell , you could even trigger with '.' for muscle memory reasons, and just press escape or space to actually use it as composition
Not sure why you are downvoted because you are right, except the bit about 'quality' so maybe that upset people. But quantity and 'battle testedness' of libraries is bigger in Ruby than Haskell.
why not? it's just a shortcut for me. I Could even do `.` just to emphasise it's still there. position the cursor after the dot ready to delete it (1 more keypress in my most common case saves the second backtick) ,just 4 keypresses for my less common case (i don't use composition so much, and when i do i'm thinking more than typing so it wont annoy me). I am happy with haskell's idea of backtick quoting (great to write ```axis1 `cross` axis2```) etc, i just find axis1.cross(axis2) still easier to type , my fingers aren't used to regularly finding the backpacks 
I've experienced many problems with upper bounds, but haven't experienced any problems due to their omissions. Could you elaborate on what problems would occur without the upper bounds? Is the benefit that for every upper-bounds update the library's test suite is being run with the new dependency?
There's also not "general" `pure` function that works for everything. It only works for `Applicative` things, and not all types are applicative functors. If you're fine with that, then you'll be happy to know that what you're looking for does exist and it's called `extract` (http://hackage.haskell.org/package/comonad-5.0.4/docs/Control-Comonad.html). As for the `Maybe` returning variant, that _could_ work for any type except that it would always return `Nothing` for a lot of them.
It doesn't make sense to have it for most instances because in many contexts you're not actually putting values in a box. In light of that, why would you want to add it? The better way is to add another type class on top but even then I don't think it would be useful at all to have it abstracted. Can you think of another instance where it would make sense (except for trivial ones like `Identity`)?
One counter-example is: reversePure :: Maybe a -&gt; a What are you going to do if I give you `Nothing`? :)
&gt; It would seem to me as if the hard part's already there in hoogle integrations. from what I'm reading, a hard part might remain: it ideally needs to deal with **incomplete expressions**, for the kind of rapid 'as you type' autocomplete you get in imperative environments. I kind of got this impression a bit in Rust aswell: it's looking for a subset of cases where enough information is available through forward inference. I hope that would still be workable in 'let / where blocks' eg ``` foo::Foo-&gt;Bar-&gt;Baz-&gt;Qux foo x y z = let sub1 = some_expr_of x z subexpr2 = sub1 `&lt;&lt;&lt; autocomplete this based on the type of sub1.. ```
You are asking about tools to solve something, but don't mention the actual problem. This looks dangerously like an instance of the [XY problem](https://en.wikipedia.org/wiki/XY_problem).
&gt; The only counterargument I've read about is that sometimes it's just not possible to retrieve values, but why then is &gt; reversePure: Monad m =&gt; M a -&gt; Maybe a &gt; not an option? Good question! The answer is that, for some monads, even the function you provided isn't possible. Consider: instance Monad (a -&gt;) where How do you write `reversePure` for that? What you're looking for is a function with the type: reversePure :: (a -&gt; b) -&gt; b Which you can't write. Aside from just an example, in general you can't write this function because you can't write it using the `Monad` methods alone (`fmap`, `pure`, `&gt;&gt;=`). The typeclass that *does* give you something like what you want is `Foldable`: head :: Foldable f =&gt; f a -&gt; Maybe a Finally (and this might be a little tangential, so feel free to ignore), you *can* make some higher-order functions pure. For instance, you can turn `traverse` into `fmap`, or `replicateA` into `replicate`, by using `Identity` as the wrapper.
Awesome things about this talk: - The content - The colors in the presentation - Kenny's hair This was definitely one of my favorites from ICFP.
Consider a parser for A, then there is no reasonable extractor
It’s like anything else; if you show tangible business benefits for why something should be done, you stand a better chance of that thing getting done. Functional languages with automatic type systems like Haskell make it much easier to write concurrent code safely while improving readability. 
Thanks for taking the time to write it up! :D
Just out of curiosity( if you don't mind my asking), why would you be willing to hire interns for Haskell? I would imagine sponsoring Haskell interns to Japan would be an expensive process with not much benefit? Bless you for providing people this opportunity though. 
Not to be nosy, but out of curiosity, why a 4-char passcode? A PIN is usually something in addition to some other authentication mechanism, usually a physical object such as a card. At the very least, you'll want to limit brute-forcing attempts... &amp;#x200B;
I'd call it "indeterminacy" rather than UB -- you're going to get one of those exceptions, not a segfault or nasal demons.
One of the great benefits of laziness is that it decouples your data flow from flow control. Want the first item that satisfies a predicate? Return all of them and let the consumer decide if it wants the first -- no need to build in any short-circuiting logic. Granted that's a trivial example you can reproduce in any decent language with streams and HOFs, but laziness means extending that to every data structure for free (FSVO "free" anyway).
&gt; Haskell knowledge is required If you're looking for interns, you might want to broaden that to general FP? Interns don't often come with specific domain expertise -- that's why they're interns.
\`Monad\` is a mathematical construct, with defined boundaries, so this question does not make that much sense in this context. However, the world "pure" can be used as an opposite to "effectful", and in this sense, we can take \`IO\` as an example. What \`Monad\` offers to \`IO\` is a \*model\*, that is, a manner to interpret the phenomenon into a formal language. The idea behind not having \`reversePure\` is that we want to \`IO\` be explicit everywhere, since we deem that valuable for technical and human reasons. Otherwise we can just use: \`\`\` makePure :: (a -&gt; IO b) -&gt; a -&gt; b makePure f = reversePure . f \`\`\` and our model makes sense. In the case of \`Maybe\` we get the same, we can destroy \`Maybe\` using the \`maybe\` function, and return to a point where we have no traces of \`IO\`, which is not something we desire for our model.
That's indeed a very good point, that having a reverse pure would mean we could annihilate the monad's sideeffects!
I recommend waiting for 8.6.2, since there is a optimizer bug in 8.6.1, which affects `Ord` instances. See [https://ghc.haskell.org/trac/ghc/ticket/15696](https://ghc.haskell.org/trac/ghc/ticket/15696).
How would you get a reverse operation for all monads? I have a monad that starts and earthquake and returns the number of buildings destroyed. How can you get the destroyed buildings without the earthquake? Monads can have side effects or represent computations over inputs and these can not simply be ignored in favor of the result of the action. More examples: * `recv :: IO ByteString` How do you get a bytestring without actually doing IO? * `decodeAvroFile :: Parser (Either String Int)` You can't make up an Int out of thin air - you need to provide the input to the parser and run that parser. To restate: Monads and Applicatives don't just contain a value of type matching the type variable - they are more versatile than that.
 reversePure :: Monad m =&gt; m a -&gt; Maybe a reversePure _ = Nothing Your turn :)
So it IS possible to defined such a function, but it's rather harder to have a non-trivial one ;P
1. The visa process for Japan interns is not that difficult, nor especially costly to them as far as I know. 2. I like to think that many of the past and current interns have been useful to the firm; there's a significant amount of useful stuff in their codebase that was written by interns. My experience was that I was treated much like a full-time developer, free to work projects that I was comfortable with or start new ones that I felt there was a need for. Tsuru employees/the current intern can probably say more about this.
Thanks for the tip! I'll return to this exercise after read the next unit of the book that describe the type system.
I mean isn't this only the second release made with the new cycle? I don't think that's enough evidence to worry just yet.