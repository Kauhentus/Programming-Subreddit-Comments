Try Frisby (or even Earley). https://hackage.haskell.org/package/frisby-0.2.2/docs/Text-Parsers-Frisby.html https://hackage.haskell.org/package/Earley-0.12.0.1/docs/Text-Earley.html They all embed their grammal dsl (i.e. into Haskell, without some macro or preprocessor), via Rank2Types. 
I do occasionally try to develop haskell on windows, even though my primary dev env is linux currently. These are two issues I remember running into at the moment: - Windows path length limitation, had to move stack root to `C:\SR\`. - Wanting to use `Chart` with `Chart-cairo` has lead to: &lt;command line&gt;: can't load .so/.DLL for: libcairo-2.dll (addDLL: libcairo-2 or dependencies not loaded. (Win32 error 126)) Now, I know this is not strictly a haskell-the-language pain-point, but if some of the most used libraries have foreign non-cross-platform dependencies that's going to impact the user experience. Currently I am looking into how I could get over this, either with installing GTK+ or through MSYS2, with neither of which I have much experience.
Because unreified grammars like in parsec are different from stuff like parsing expression grammars. 
(just want to thank you too :-)
&gt; Equational reasoning My favorite term for this is "copybastability". You can always copypaste any part of an expression out into its own function.
I have never actually had any issues with GHCs windows linker, and any of the rest of these issues are something any language ecosystem deals with on Windows. These aren't haskell specific problems or problems that are worse with haskell than basically any other language you might want to write software with on Windows. I have never run into a single issue with haskell development that actually had to do with compiling the haskell language itself. DLL management on Windows is a pain in the ass, but it's not going to be an issue for most beginners anyway, and learning how to solve these problems is essentially a language agnostic skillset. So, development sucks on Windows - yes, everyone knows this. Haskell development sucks on Windows - not really so much.
What sort of program are you writing, and what architectural advice are you looking for? I'm sure we could conjure up some good advice from within this community, if you asked directly.
Why is it bad to use Haskell on Windows?
Maybe, but even if so it would be a cruel joke, because the linux subsystem can't access graphics in any way.
I have a function like: `response :: ToJSON a =&gt; Maybe a -&gt; Action ()` - works fine when passing a `Just x`, but won't compile when passing `Nothing` because it can't deduce the type of `a`. Is there a better way to write this function? I don't want to need a `emptyBody = Nothing :: Maybe ()` helper, seems ugly.
Great post. &gt; and the GC will still have an overhead during its trace to dispose of the allocated cells I'll clarify that the time it takes for a sinlke GC is not proportional to allocated objects but live objects. Of course more allocations leads to more GCs though. This fact tends to be what people talk about when calling allocations cheap.
Thanks for mentioning specifics. RE: Cairo - This is a series of hoops I had to jump through myself not long ago. The main issue I had there was not that this was hard to do, but that it was unpopular enough that resources were limited and I had a hard time finding help - Basically, the story of Windows Dev in general. To start, `stack exec bash`, and then that gets you `pacman`, and you can pretty much just use pacman to install whatever dependencies you're going to need. I personally ran into an issue in which something was mangling my `%PATH%`, and ended up needing to manually massage it to look at `%LOCALAPPDATA%\Programs\stack\x86_64-windows\msys2-[XXX]\mingw64\` due to a dll name conflict elsewhere on my path. This sort of thing happens on linux all the time to, it just usually leads to a forum post immediately followed by some helpful fellow who had exactly the same issue and gives you a one-liner that fixes the problem, whereas on windows you're probably looking at archived garbage from the 90s telling you how to solve a different but vaguely similar problem on Windows XP, some elements of which apply to your issue and some do not, and if you go to reddit or SO some jack-hole just tells you to install linux on a VM and twirls their mustache.
&gt; the GC will still have an overhead during its trace to dispose of the allocated cells. That overhead can be huge compared to the simple cost of a register operation. FWIW, you'll notice that your program still spends just 2% of its time in the GC. There is almost zero tracing overhead, because there is almost nothing to trace. The GC is doing almost no work. I bet the vast majority of that time is just spent *incrementing that pointer* so many times! Here's a C program designed to simulate incrementing a pointer as many times as that program likely did. It assumes that each allocation was allocating five machine words, which IIRC, is somewhat accurate for most ADTs in Haskell. #include &lt;stdio.h&gt; int main() { long long lim = 80000062264; long long step = sizeof(void*) * 5; for (volatile long long i = 0; i &lt; lim; i += step) { }; } $ gcc test.c -O3 -o test $ time ./test real 0m4.052s user 0m4.051s sys 0m0.000s As you can see, just incrementing a pointer takes a little more than half the time that your program took. So my claim that the allocations come at little more cost than incrementing a pointer seems correct!
Although allocations are cheap, [they are still not free](https://www.reddit.com/r/haskell/comments/7ujw4a/usrsbin_selling_laziness/dtndtb6/)
&gt;- Windows path length limitation, had to move stack root to `C:\SR\`. Next time, use `\\c:\&lt;whatever&gt;`, which I believe doesn't have the same path length limitations because it uses a different file subsystem.
In my experience, ghc itself was fine except unicode encoding related problem but some packages not supported on windows such as vty, unix which many other packages rely on. so I eventually switched to macos and everything was way better. Now there is WSL, so situations maybe improved.
[grammatical-parsers](https://hackage.haskell.org/package/grammatical-parsers) supports PEG grammars. 
You can have it take Maybe Value instead. Then you don’t have a constraint.
Probably would be worth cross posting this to the r/programminglanguages and r/types subreddits!
I think the ghc bug here is that stg always uses a let binding before calling a function. But [in stg-&gt;cmm](https://github.com/ghc/ghc/blob/master/compiler/codeGen/StgCmmExpr.hs#L447) seq# isn't actually a function call: {- Note [Handle seq#] ~~~~~~~~~~~~~~~~~~~~~ case seq# a s of v (# s', a' #) -&gt; e ==&gt; case a of v (# s', a' #) -&gt; e (taking advantage of the fact that the return convention for (# State#, a #) is the same as the return convention for just 'a') -}
Just had a look at some of the exercises for the 3rd chapter. Looks pretty nice. Should be some good material to get people up and running quickly.
Other than `mappend`, I don't have a good answer to this. I have wondered the same question myself. In mathematics, there's often very little you can say that's interesting about a particular algebraic structure. For groups, let's say, usually you need additional hypotheses. You can say quite a bit about a *finite* group. Or a topological group. Or a compact lie group. But with regards to arbitrary groups, all you can really do is use the given axioms (existence of identity, inverse, and composition) and combine those in trivial ways.
Fair. Though I'd reckon these costs *are* negligible compared to more typical operations.
Fair, but I'd still call this fairly cheap in the grand scheme of things
I’ve been programming in Haskell for 10 years and never seen such clearly presented introductory material. I’ve also never see listen for writer, so thanks for teaching me something! I’ll need to give you some coffee money next time i’m on patreon. Keep it up!
[hie](https://github.com/haskell/haskell-ide-engine) actually works really quite well. I can't speak to whether or not it works alright in neovim, but it's been working fine for me w/ the sublime text and VSCode LSP clients (even on windows). 
It's the same guarantee, yes. The advantages of `tagged` are A: there's some tools for manipulating the tags e.g. `retag` and `untag` and B: you can write functions that work on any tag . If you need to change the type without changing the underlying data, or write code that works on the underlying data irrespective of the outer type, then I think `tagged` is worth it. For example, at work we have something like this: {-# LANGUAGE DataKinds #-} data PhoneOwner = Customer | Company type CustomerPhone = Tagged Customer Phone type CompanyPhone = Tagged Company Phone parsePhone :: Text -&gt; Maybe (Tagged t Phone) isAmerican :: Tagged t Phone -&gt; Bool sendMessage :: CompanyPhone -&gt; CustomerPhone -&gt; Text -&gt; IO () provisionPhone :: IO CompanyPhone The idea is to separate phone numbers the company owns from phone numbers our customers own. Some operations work on either, and some only on one or the other. So the greater expressivity of `tagged` is useful.
Fingertrees are monoid-polymorphic structures that generalize search trees and interval maps, among many other things https://apfelmus.nfshost.com/articles/monoid-fingertree.html
I have no opposition to this new work, but there *is* a good free online resource already (and you can help make it better): https://en.wikibooks.org/wiki/Haskell (and it's already linked here in the sidebar at reddit)
I've been into the idea of Hypothes.is for a long time but not really used it. Love that this embraces it! Right on!! Nice to also use FLO tools like ReadTheDocs. Please release the book itself under CC-BY-SA or compatible FLO license though.
How about summer interns?
It's exponential space that's the issue.
The Writer Monad is polymorphic over a Monoid.
Some links regarding what we're working on: # Pact Github: https://github.com/kadena-io/pact Compose'17: https://www.youtube.com/watch?v=l7XuSuEe-Yg # Chainweb (Braided PoW) Whitepaper: http://kadena.io/docs/chainweb-v15.pdf BPASE'18: https://www.youtube.com/watch?v=p1OFJOrgRWw
So, a majority of my experience programming is with Java, Haskell, and Rust (in that timeline order). I've read the books of other languages, done a small thing or two, but anything more than a few hundred lines has been one of those three languages. Of those three, Haskell has the worst ability to just work on windows. Full stop. I don't care if other languages have _an even worse_ story on windows. That doesn't make my life better. I understand that Haskell is all volunteer and community, and I'm not saying this is the fault of anyone. If Haskell isn't a good time on windows, _I am personally to blame as much as anyone else is_. It's not like I'm out filling in the gaps. However, that said, trying to tell people they'll have a happy fine time programming Haskell on windows is borderline lying to them, and I'm sure not gonna do that. The average Haskell+windows experience is that things work, until suddenly they don't, and then usually no one knows anything about how to fix it because such a low proportion of the community uses windows that the knowledge isn't there. But you wanted actionable complaints, so here are some very plainly put solvable problems: * make Haskell smarter at getting FFI libs on its own. This isn't a "haskell the language" issue it's a "haskell the ecosystem" issue, but that _doesn't matter_ because you can only use haskell-lang within the larger context of haskell-eco anyway. It's easiest if you just assume I'm a dummy and [make a script that will do it all correctly for me](https://github.com/Rust-SDL2/rust-sdl2#bundled-feature). That's the best route. Or you could use Appveyor, and then I can just copy whatever your appveyor script does, that's alright as well. * Stop relying on the unix package so much, gosh. * Build some proper user-IO systems that work on windows. I don't mean like pipes and conduit IO pushing data invisibly around, I mean user interaction with a GUI and visuals. Right now you can use Haskeline OR ansiterminal (not both at the same time!), or SDL, or GLFW+OpenGL. That's sure a start, but that's not quite enough either. Could go with GTK, could got with FLTK, could roll your own. Just pick whatever and build that up until it works, and works well, on both unix and windows. I'd even accept some sort of curses-ish thing like brick/vty (even though they're too abstract for their own good) as a stop-gap if it worked on windows _without_ the linux subsystem (some of us aren't on win10, thanks). You can pull in and link against PDCurses or something, that's what [pancurses](https://github.com/ihalila/pancurses) does. And, like, Swing is awkward and looks like garbage, but it operates. I'm sure that if you're building web apps it doesn't matter if you're on windows or linux because you don't ever interact with a local user and put pixels on a screen. That's cool, but if you're on windows you probably want to build something visual, probably a game. That's pretty much what windows is for, it's for game development, because that's where the game players are.
I went through building a GTK+ app (with cairo, pango, etc) on Windows recently. It's documented [here](https://www.reddit.com/r/haskell/comments/7jcla7/compiling_haskell_on_windows_finding_the_good_way/dr60cil/). Maybe it can help.
These instructions had just the right amount of details for me, thanks a lot for sharing! Now I can suddenly build this codebase of mine on Windows too! Hooray! I thank both you and /u/IronGremlin too for mentioning `stack exec`, I never thought I could use bash/msys/packman from inside there. I was fumbling with trying to get the deps from the outside, global msys2 console.
I just watched it, great talk! Excellent motivating example and getting all the way through solving the practical problem with "sorcery". The windup with dependent pairs explains the sigma thing beautifully.
First, thank you! It's great to have a new resource for learning Haskell, I've tried with LYAH before. But, even in the first exercises there are errors. ie sumOfList &amp; sumOfEven etc (I've added annotations) It really makes it hard to get to grips if we (Haskell newbs) are having to work out if we or the content is wrong right out of the gate.
The whole point of generic abstraction is to be precise over what "interface" is required for a given application/interface. So "not saying much" is precisely the thing that we need. It also gives what I call cross-domain intuition. For example, I might know about list and its properties. If I understand how it is a monoid then I can transfer some of the intuition there to another domain say for example Text. When it comes to prefix, concatenation etc I can "think of" text as a list although the implementation can be, and is, very different. 
What types are comonoids? Is there a free comonoid? 
I misremembered. It's actually `\\?\C:\&lt;whatever&gt;`.
`foldmap`. For example, add all `Just` values, or return `Nothing` if there aren't any: sumJust :: [Maybe Int] -&gt; Maybe Int sumJust = fmap getSum . foldMap (fmap Sum) This will work Just as well with any Foldable, for example Data.Sequence
Excellent ! also have a look at http://www.clash-lang.org/ The idea is to stop trying to adapt software, and instead *generate* suitable hardware from an Haskell subset.
composition trees?
"Unbeatable programming-language tooling" Does this refer to in-house tools?
CSS classes are separated by whitespace, not comma.
+1 for simple experiment which prove your point, well done ;)
If `a` is `String` for example you can do `(Nothing :: Maybe String)` to tell ghc what `a` is.
Ok, I think I've got it. Thanks to everyone who replied. The idea here is that one uses some subtype of Monoid with more properties, but can use a Monoid interface just for the part that glues pieces together. So I could write for example ``` double :: Monoid a =&gt; a -&gt; a double x = x `mappend` x ``` and then things like ``` print $ double (double [1,2]) !! 7 print $ getSum $ double (7 :: Sum Int) ``` It's a way to get greater genericity for just the part of the code that's doing appending only.
There are two talks with Haskell-specific content: * Testing monadic programs using QuickCheck and state machine based models * New Hasql - a native Haskell Postgres driver faster than C And three Haskell-related tutorials: * Introductory Haskell * A tutorial on Liquid Haskell * Terminal GUIs with Haskell: vty and brick And more talks and tutorials about FP in general.
The biggest pain points except of having to hand compile c dependencies I had is that stack's docker integration is broken on windows.
Thank you very much! Nice that you got some use for it. I'm trying to make the videos practical, and to maybe even give practitioners something new to learn. I don't claim to know that much about Haskell, but I can share what I bump across when working with it. :)
Very cool! I had a project with similar goals about 5 years ago. However, the implementation was using a far more naive approach. My thing is so WIP it's barely worth sharing, but maybe one day I will return to it. Rather than doing anything clever like proof search, it would just speculate many different ways to apply a set of identifiers to eachother. The user would guide the search by specifying which functions they anticipate may be useful. The main bit of cleverness was trying to optimize the search by noticing when types of some terms are the same. Then you only need to test one candidate, and can perhaps use your "which term is best" heuristic to select it.
Your link is broken because there's an extra `]`.
I'm trying to write an ebook management program. Like Calibre but more specifically for Gnome. I've had a few busy months that prevented me from working on it, so my exact problems are a bit hazy, but I remember struggling with the following: 1. In OO languages MVC structure is very common. Do I use this in Haskell too? Something else? 2. What is the recommended way to structure a GUI/GTK application in Haskell? Especially when I need to keep track of widgets and stuff. I guess this question is vague, but my GTK application in Haskell feels quite disorganized even though I try to keep it to one source file per widget. Call backs and sub widgets seem to get passed along throughout the whole code tree for example. 3. What is the recommended way to add mutable state in a GUI application anyway? Now I'm using several IORef's but I believe that is actually not recommended because they would interfere with each other. It's the easiest way though....
Ah but then I have to manually convert it to a Value correct? Might still be a good option though, thanks!
This looks amazing, but sadly clashes with Lambda Days. Will the talks be recorded?
It is worth noting that sum generally won't generate a space leak unless you compile without optimizations or use a non push-flow combinator like zip.
If you told me 6 years ago that Isabelle/HOL experience would bring in the big bucks (and not just research grant peanuts) one day, I would have laughed.
Fixed. Thank you.
Does anyone have a link for a paper for LJT proof search? Didn’t find anything just googling
I'm not sure. I've not played with autogenerated modules except as a consumer of them.
[R. Dyckhoff, Contraction-Free Sequent Calculi for Intuitionistic Logic, The Journal of Symbolic Logic, Vol. 57, No. 3, (Sep., 1992), pp. 795-807.](https://rd.host.cs.st-andrews.ac.uk/publications/jsl57.pdf) I’ll add this link to the blog post.
A dirty bit crossed my mind but it didn't occur to me that I didn't need to stuff the bit inside the MonoTerm itself, and could instead wrap both in a new type. I'm gonna be trying this since it just makes sense, along with Solonarv's and Syrak's suggestion which plays nicely with this. Once I make the distinction between possibly dirty MonoTerms and guaranteed clean ones, I just expose the clean MonoTerm type. This suggestion along with another response in this thread reminded me of phantom types, which I haven't diddled with yet but it /feels/ like it could be used to implement this if I wanted to get fancy, which I'm gonna mess with once I do these suggestions. Thanks a lot for these suggestions!
I think the applicative instances for tuples are a nice example - I'll motivate it with an example of the 2 tuple (a, b). We will write an Applicative instance for `(,) r` - where the first type parameter has been applied. First we need define a function `pure :: a -&gt; (r, a)`, but how can we create a value of type `r` from nowhere? This looks exactly like `mempty`! Next we need to define `(&lt;*&gt;) :: (r, a -&gt; b) -&gt; (r, a) -&gt; (r, b)` - ok so it's simple function application of the second argument of the tuple, but which `r` value do we use? Is there some way to `mappend` both of them together? You'll see that the instance for `Applicative ((,) r)` requires `r` to be a Monoid. It might be obvious as to why we need `mempty` but do we really need `mappend`, couldn't we use one of the `r`'s and forget the other? Try proving the applicative laws [2]. [1] https://hackage.haskell.org/package/base-4.10.1.0/docs/src/GHC.Base.html#line-338 [2] https://en.wikibooks.org/wiki/Haskell/Applicative_functors
TIL about https://hackage.haskell.org/package/djinn-ghc-0.0.2.3/docs/Djinn-GHC.html This might be helpful for Intero https://github.com/commercialhaskell/intero/issues/8 The GHC API is rough so any packages that do the work for me that I can just drop into Intero is awesome. I've a plan for being able to write `foo (map _ . _) . _` kind of code where the engine will infer how to fill in the "template", given a set of holes `_`. This would permit completion one step above foo.bar.mu() in OO languages, I imagine.
With `-XTypeApplications`, you can use `response @Int Nothing`. That's maybe the best I can think of.
Yes, you should give it a shot! I originally tried to use djinn-ghc in ghc-justdoit, but it was hard to get well-typed Core terms. But since you probably want simply Haskell source, then it pretty much already does what you need!
Reminds me to be related to [MagicHaskeller](http://nautilus.cs.miyazaki-u.ac.jp/~skata/MagicHaskeller.html).
There seems to be a monthly one now, stickied: https://www.reddit.com/r/haskell/comments/7uqkxy/monthly_hask_anything_february_2018/
One way is to create a `.ghci` file in your `$HOME` folder, and add :set -XOverloadStrings :set -XTypeApplications
The android/iOS apps for https://www.wrinkl.com are almost 100% Haskell
To avoid these kinds of annoyances, I usually like to use `ExtendedDefaultRules` and `default` declarations like so: {-# language ExtendedDefaultRules #-} module Main where default ((), Int) main = print Nothing
I think that thread is still very much open for beginner questions. Maybe /u/BoteboTsebo didn't mention that inadvertently, or intentionally for some reason.
You may find this relevant: https://www.reddit.com/r/haskell/comments/57yvam/haskell_code_reloading_has_it_been_solved/
While this is nice to have, it's for development, not deployment.
Weekly threads were problematic. Particularly because we would forget to create them in time! The monthly threads would impose less of an administrative burden. And yes, they're most certainly intended to be beginner-friendly... 
I've got one for you-- bear with me, I'm super new to Haskell. `(&gt;&gt;= replicate 2)` I know that this duplicates every element in a list, but can you kind of explain to me char-by-char the syntax of this line? Specifically like the `&gt;&gt;=` part. 
GHC typechecker plugins seems quite versatile.
More like that Haskell has the best "tools" for writing PLs: libraries for parsing, variable substitution, SMTLIB2/Z3, etc etc. The tooling we've built for Pact is good too though!
threetimes and triple are functions, so their type is not Integer. Things with a type of integer are just, well, integers. For example: x :: Integer x = 5 The type of a function is written like &lt;type of first argument&gt; -&gt; &lt;type of second argument&gt; -&gt; ... &lt;type of the value returned from the function&gt;. In the case of triple, the type could be written as: triple :: Integer -&gt; Integer The triple function takes an integer and turns it into an integer, as written here. (You could be way more general and write triple as taking any numeric type. Doesn't have to just be integers.)
let's start with `tripple` (it's the easiest one) without further knowledge you see that it takes one argument and returns something (as every function) - let's call the type of `x` `a` and that of the result `b` (so `tripple :: a -&gt; b`) now in the body you use the operator `*` (which is `Num n =&gt; n -&gt; n -&gt; n`) and the number `3` (which types needs to be in the `Num` class also) so you unify this and see that `x :: a` needs to be in `Num` (and equal `n` above) - also the result of the multiplication is the result of the function so `b ~ n ~ a` as well and you get: tripple :: Num a =&gt; a -&gt; a ---- a similar argument (try it please) shows you that `threetimes` with it's to arguments need to be `threetimes :: (a -&gt; a) -&gt; a -&gt; a` (note that `f` has to be a function as it's used as one) --- no try with last and assume `reverse :: [a] -&gt; [a]` and `head :: [a] -&gt; a`
OK, so I'm making assumptions about your cs background. Mostly that you've used something like c/Java First, functions have types. The function type is not the same as the return type. For example triple takes an Integer, and returns an Integer. So the function triple has type Integer -&gt; Integer. We write that as triple :: Integer -&gt; Integer. The threetimes function is a little more complicated. Since threetimes has 2 parameters, we need two parameter types threetimes :: ? -&gt; ? -&gt; Integer The second one is easy. x is just an integer. threetimes :: ? -&gt; Integer -&gt; Integer The first one is a little more complicated. f is a function, so it has a function type. Since x is an integer, f must take an integer as its argument. Otherwise f x wouldn't make sense so f :: Integer -&gt; ?. Finally since threetimes returns an integer, f must as well. So f :: Integer -&gt; Integer That gives a final type for threetimes as threetimes :: (Integer -&gt; Integer) -&gt; Integer -&gt; Integer This is a valid type for threetimes, but we can actually 
Generally, you can use `GHCi` to check your answer via `:type f` or just `:t f`. But think about it first. The function `threetimes` doesn't "know anything" about `x`, except that it can be supplied as an argument to `f`. But then, the result of this function application must yield some value, which has to be of a type that has to fit into ... `f` again! So the type mustn't change. So if you choose `x :: a`, what is the type of `f` ? `triple` is a little different. Since it uses `(*) :: Num a =&gt; a -&gt; a -&gt; a`, it has to make an *assumption* about `x`, namely that it *implements* the `Num` type class. So again, we might want to choose `a` as the name of our type variable, but now we have `x :: Num a =&gt; a`. Finally, there is `last`. In order to figure out its type, we have to look at the types of the functions that are applied to `xs`. We have &gt;&gt;&gt; :t reverse reverse :: [a] -&gt; [a] &gt;&gt;&gt; :t head head :: [a] -&gt; a So we see that neither of them can make any assumption about the element type of the input list. Do you see why this is "problematic" for both `head` and ultimately `last` ?
&gt; Personally, I do not think beginners will mind such language. That's not why I think it's inappropriate. The problem with this kind of language in a beginner textbook is that it creates certain expectations. And those expectations aren't helpful - not now, and certainly not later. Don't get me wrong: material like this is direly needed, and I applaud everyone who attempts to write it. I'd just prefer it to use a less offensive / sensationalist tone. &gt; We are not really "avoid success at all costs", right? It's "avoid (success at all cost)", not "(avoid success) at all cost". Big difference. We're not trying to avoid success; we're just not very keen on making big sacrifices for the sake of success.
I'm trying to write a GUI application in Haskell, on Windows (yeah, I know). I would like to use gi-gtk, but after much fiddling and googling I still have not gotten the library to even build. Here's the output from my latest attempt. Solonarv@daresso MSYS ~/dev/accord $ XDG_DATA_DIRS=/mingw64/share PATH="/mingw64/bin:$PATH" stack build gi-glib-2.0.15: configure gi-glib-2.0.15: build gi-cairo-1.0.14: configure gi-glib-2.0.15: copy/register -- While building custom Setup.hs for package gi-cairo-1.0.14 using: C:\msys64\tmp\stack7996\gi-cairo-1.0.14\.stack-work\dist\ca59d0ab\setup\setup --builddir=.stack-work\dist\ca59d0ab configure --with-ghc=C:\Users\Solonarv\AppData\ Local\Programs\stack\x86_64-windows\ghc-8.0.2\bin\ghc.EXE --with-ghc-pkg=C:\Users\ Solonarv\AppData\Local\Programs\stack\x86_64-windows\ghc-8.0.2\bin\ghc-pkg.EXE --user --package-db=clear --package-db=global --package-db=C:\Users\Solonarv\ AppData\Roaming\stack\snapshots\d9865764\pkgdb --libdir=C:\Users\Solonarv\ AppData\Roaming\stack\snapshots\d9865764\lib --bindir=C:\Users\Solonarv\AppData\ Roaming\stack\snapshots\d9865764\bin --datadir=C:\Users\Solonarv\AppData\Roaming\ stack\snapshots\d9865764\share --libexecdir=C:\Users\Solonarv\AppData\Roaming\stack\ snapshots\d9865764\libexec --sysconfdir=C:\Users\Solonarv\AppData\Roaming\stack\ snapshots\d9865764\etc --docdir=C:\Users\Solonarv\AppData\Roaming\stack\snapshots\ d9865764\doc\gi-cairo-1.0.14 --htmldir=C:\Users\Solonarv\AppData\Roaming\stack\ snapshots\d9865764\doc\gi-cairo-1.0.14 --haddockdir=C:\Users\Solonarv\AppData\Roaming\ stack\snapshots\d9865764\doc\gi-cairo-1.0.14 --dependency=Cabal=Cabal-1.24.2.0 --dependency=base=base-4.9.1.0 --dependency=bytestring=bytestring-0.10.8.1 --dependency=containers=containers-0.5.7.1 --dependency=haskell-gi= haskell-gi-0.20.3-Gnav7JoNYW1CG0yUS8yjsn --dependency=haskell-gi-base=haskell-gi-base-0 .20.7-LkuSYHov7rcHoL3o9H69XR --dependency=haskell-gi-overloading=haskell-gi-over loading-1.0-27QuWHK6oxK6ozcekEpmYe --dependency=text=text-1.2.2.2-9UQZjEJZQFSGMf fj1Z5g00 --dependency=transformers=transformers-0.5.2.0 --extra-include-dirs=C:\ Users\Solonarv\AppData\Local\Programs\stack\x86_64-windows\msys2-20150512\mingw6 4\include --extra-lib-dirs=C:\Users\Solonarv\AppData\Local\Programs\stack\x86_64 -windows\msys2-20150512\mingw64\bin --extra-lib-dirs=C:\Users\Solonarv\AppData\L ocal\Programs\stack\x86_64-windows\msys2-20150512\mingw64\lib Process exited with code: ExitFailure 1 Logs have been written to: C:\msys64\home\Solonarv\dev\accord\.stack-work\logs\gi-cairo-1.0.14.log [1 of 2] Compiling Main ( C:\msys64\tmp\stack7996\gi-cairo-1.0.14\Setup.hs, C:\msys64\tmp\stack7996\gi-cairo-1.0.14\.stack-work\dist\ca59d0ab\setup\Main.o ) [2 of 2] Compiling StackSetupShim ( C:\Users\Solonarv\AppData\Roaming\stack\setup-exe-src\setup-shim-Z6RU0evB.hs, C:\msys64\tmp\stack7996\gi-cairo-1.0.14\.stack-work\dist\ca59d0ab\setup\StackSetupShim.o ) Linking C:\msys64\tmp\stack7996\gi-cairo-1.0.14\.stack-work\dist\ca59d0ab\setup\setup.exe ... Could not resolve symbol "cairo_gobject_context_get_type" in namespace "cairo" CallStack (from HasCallStack): error, called at lib\Data\GI\CodeGen\LibGIRepository.hs:167:8 in haskell-gi-0.20.3-Gnav7JoNYW1CG0yUS8yjsn:Data.GI.CodeGen.LibGIRepository ** (setup.exe:9372): WARNING **: Failed to load shared library 'libcairo-gobject-2.dll' referenced by the typelib: 'libcairo-gobject-2.dll': The specified procedure could not be found. I *did* install cairo, and the "missing" DLL is in `/mingw64/bin` which is on the `$PATH`. What am I missing?
VC-speak for "we actually make money"
VC-speak for "we actually make money"
&gt; Definitely for the fall/next year but I can’t be certain for this summer. It’s simply a timing problem as we’d already be getting a late start and I’m not sure we’d be in a place to offer summer internships until April/May/June... _just_ too late to be useful. That timing estimate may be too conservative though, so please apply and we’ll keep you in the loop.
That's a creative twisting of SPJ's words, which might reflect the underlying meaning, but given ie his HaskellCast I think clear he was being just as tongue in cheek as the quote sounds. He says (from memory) "once these languages become embodied in millions of lines of code, it becomes understandably increasingly difficult to change them. Up to now, we have changed Haskell fairly liberally". 
What is LJT?
I recently got a GTK+ app working on Windows and documented my steps [here](https://www.reddit.com/r/haskell/comments/7jcla7/compiling_haskell_on_windows_finding_the_good_way/dr60cil/). I didn't use gi-gtk, but maybe it can help?
I somehow hadn't thought of using `stack exec --` to install the dependencies, thanks! I hope that'll do it.
The ```&gt;&gt;=``` is known as bind - what this does is: on the left of the operator it takes some value with context. On the right needs to be some function that takes a pure value (one without context) and returns one in the same context as the left. The type of replicate is ```Int -&gt; a -&gt; [a]```, so it takes a number, a value and returns a list containing that value however many times specified. Because the return type of ```replicate``` is a list of values, then our context is a list. With lists, ```&gt;&gt;=``` will apply the function to every value in the list on the left. So given ```[1,2,3] &gt;&gt;= replicate 2``` it will first do ```[[1,1],[2,2],[3,3]]``` however then what happens is it will flatten the list so there's only one nesting of list, so: ```[1,1,2,2,3,3]```. Now, I've avoided the use of the word monad here, it's seen as one of those scary words however it really isn't! If this doesn't make sense now don't worry. Go learn about lists, higher order functions, functors. Then when you're learning about monads, think about flatMap and join and experience the eureka moment we've all had :)
I am a super Haskell noob currently just starting Haskell Programming From First Principles. I have a fresh install of Manjaro Linux to work from. Can someone link me to a good source for setting up a development environment. I don't have experience with emacs or vim but am willing to learn, but would prefer VSCode integration if possible. Sorry if this is out of the scope of this thread.
&gt; First, functions have types. The function type is not the same as the return type. To demonstrate for OP: C-ish function signature, using different types for clarity: int triple(float x) { ... } would convert to a Haskell-ish (not valid Haskell!) function signature: triple :: float -&gt; int triple x = ... Take a moment and observe that both signatures have the same information, just in different places. Concrete types need to be upper case in Haskell, so we do that to make it valid: triple :: Float -&gt; Int triple x = ... Going back to the original post, the function doesn't actually take a Float and return an Int; it's more general than that - it takes a numeric value, and returns a numeric value of the same type. Give it an Int, you get an Int back; give it a Float, you get a Float back, etc. We can make it more generic by giving it a *typeclass constraint* and using lower case *type variables* in the signature: triple :: Num a =&gt; a -&gt; a triple x = ... That should be read as "this function can take a value of any type which is of class `Num` - numeric types - and will return a value of that same type." 
Is there a way to get stack to link to a non-system library? I'm trying to work through [Implementing a JIT Compiled Language with Haskell and LLVM](http://www.stephendiehl.com/llvm/) on a Mac, and I can't get stack to find the LLVM that was installed through homebrew. Homebrew doesn't want to link into the system due to conflicts with the system's own LLVM, so would I have to force it or can I point stack to LLVM installed somewhere else?
Meet you there! 
The reason this is faster is not because strictSum is slow, it's because foldl is ridiculously optimized. Foldl has some rewrite rules, and foldl in base is actually written in terms of foldr so that the fancy foldr fusion has a chance to kick in and make things fast. Lots of tricky stuff goes on in there :)
See: the Futhark language :)
What are some fast/actively maintainied parser combinators library for programming language parsing?
Glad I could help! After you get everything working as you'd like maybe you could update your top level comment with the combination of the approaches mentioned. That way others reading through the thread can get a nice overview of the solution without having to piece together the comments :)
https://github.com/mrkkrp/megaparsec
Try [`extra-lib-dirs`](https://docs.haskellstack.org/en/stable/yaml_configuration/#extra-include-dirsextra-lib-dirs).
Update on that 1.2? Looking forward to it!
/u/mu_mu_lambda has an explanation below, but I thought I would try this too. First, the `(&lt;operator&gt; &lt;argument&gt;)` syntax is known as a ['section'](https://wiki.haskell.org/Section_of_an_infix_operator), specifically a right section. This means that λ&gt; (&gt;&gt;= replicate 2) list is equivalent to λ&gt; list &gt;&gt;= replicate 2 The next thing to know is that the (&gt;&gt;=) operator is defined differently for different data types, and for lists it's equivalent to `concatMap` with its arguments in the opposite order: flipConcatMap :: [a] -&gt; (a -&gt; [b]) -&gt; [b] flipConcatMap list f = concat (map f list) `concatMap` applies a function that outputs a list to each element of another list, and then concatenates the resulting list. We can substitute that in to get λ&gt; flipConcatMap (replicate 2) list which is the same as λ&gt; concat (map (replicate 2) list) `replicate 2` takes a value and replicates it twice, returning a list of two elements, so it has the right type for `flipConcatMap`. Let's try this with an example for `list`, such as `[1, 2, 3, 4]`: λ&gt; concat (map (replicate 2) [1, 2, 3, 4]) λ&gt; concat ([[1, 1], [2, 2], [3, 3], [4, 4]]) λ&gt; [1, 1, 2, 2, 3, 3, 4, 4] And that's how `(&gt;&gt;= replicate 2)` duplicates every element in a list. 
Have you seen http://www.haskellforall.com/2017/10/advice-for-haskell-beginners.html?
Not out of scope! Try this for VS Code: https://marketplace.visualstudio.com/items?itemName=Vans.haskero But at the beginning, I recommend not using IDE features other than syntax highlighting because it will force you to think more instead of trying things/auto-complete/etc until the code compiles.
Thank you
Are there things that you intending to do with the no-hole version that won't be done with the hole-version? If you type-check, execute, etc, you'd probably want everything to also be supported for code that has holes? So in that case what's the benefit of having a no-hole version?
Hi, sorry for the delay: * Read https://www.fpcomplete.com/blog/2017/06/readert-design-pattern : this is as close to a design pattern we have in Haskell at the moment. It's meant for IO-heavy applications that must track exceptions and keep tabs on a (possibly mutable) environment. * Mutation (as in, overwriting memory such as ) might not be strictly necessary: the language is garbage collected so if `a_old` is not referenced anymore after `a_new = a_old + 1`, its memory is freed up. As a general tip, don't chase performance as you would in C from the beginning; make it work first, then optimize selectively after profiling. * GTK and widgets: can't properly comment here as I don't have relevant experience, but perhaps your code organization concerns can be alleviated by using a good combinator library; IIUC the currently best battle-tested solution for exception handling in callback-heavy code is monad-control ( Rationale: https://www.yesodweb.com/book/monad-control ). 
I dont know, that's why I am asking. Maybe I can write less boilerplate?
You should take a look at this: http://www.cs.uu.nl/research/techreps/repo/CS-2008/2008-044.pdf It goes way further than the standard parsec like parsers. Some code examples need to be changed before they will work, but I think the ideas explained are very interesting.
Would that reduce boilerplate or just move it around? I think I'd go ([and am going with](https://github.com/lamdu/lamdu-calculus/blob/master/src/Lamdu/Calc/Val.hs#L53)) with having the hole in the AST.
I am also going with it :)
Seems to be due to this article: Contraction-free sequent calculi for intuitionistic logic - R Dyckhoff - https://rd.host.cs.st-andrews.ac.uk/publications/jsl57.pdf
Given a type, under what conditions is the implementation unique?
Would be awesome to see blog post with name _Revisiting Monadic Parsing in Haskell_ which explains type of parser from `megaparsec`... newtype ParsecT e s m a = ParsecT { unParser :: forall b. State s -&gt; (a -&gt; State s -&gt; Hints (Token s) -&gt; m b) -- consumed-OK -&gt; (ParseError (Token s) e -&gt; State s -&gt; m b) -- consumed-error -&gt; (a -&gt; State s -&gt; Hints (Token s) -&gt; m b) -- empty-OK -&gt; (ParseError (Token s) e -&gt; State s -&gt; m b) -- empty-error -&gt; m b }
I sensed this. Just trying to poke out any hidden tooling advances. ;)
I haven't seen any speed numbers for trifecta. But I've seen that [Dhal is intended to be switched from trifecta to megaparsec](https://github.com/dhall-lang/dhall-haskell/issues/240): &gt; I think there may be parsing performance improvements by switching from trifecta/parsers to megaparsec since megaparsec provides high-efficiency bulk parsing primitives while still preserving good error messages.
Wrt downplaying "theory" and "mathematical thinking", I'm basing this off of comments that I hear from fresh undergrads who try Haskell for the first time after joining Vacation Labs. The following is a verbatim comment - "Haskell seems too mathematical, other languages I've worked with are more logical". Don't try to deconstruct that comment solely on the terms that the beginner has used (what does "mathematical" vs "logical" really mean?). Instead, understand the underlying emotions/feelings. There are so **many** new concepts in Haskell, that beginners struggle to convert perfectly reasonable pseudo-code into working Haskell code. Some examples of new concepts: * Immutability * Tail recursion * Weird compiler errors * Differences between GHCi and GHC * ADTs, values, types, and data-constructors * Polymorphism that works differently * Type-classes * Purity (or is the correct term referential transparency?) My intent is to get them to write meaningful programs as quickly as possible. Deeper mathematical underpinnings can be revealed later. If a beginner is going to take 6-9 months to write a Twitter/Slack bot in Haskell, then mathematical reasoning is of no use. The person is not going to stick around for very long. He/she will **feel** fare more productive in other tech ecosystems.
&gt; The problem with this kind of language in a beginner textbook is that it creates certain expectations. And those expectations aren't helpful - not now, and certainly not later. What kind of expectations are you referring to?
Sure, your compromise is probably pragmatic, and it's worth a shot. Making beginners be productive as soon as they can is a good goal. Perhaps you should remove the, er, non-factual asides about "category theory and lambda calculus", is what I'm saying.
This is not ready yet for wider consumption. It's being dog-fooded at my company as I write them. Thanks for the annotations -- I'll push a fix in the next commit.
Doesn't the Haskell Book start off with Lambda Calculus in the first chapter itself? Or has that been removed now?
It's a little easier to think about if you consider it only taking one function with an ADT data BigArg e s a = ComsumedOk a (State s) (Hints (Token s)) | ConsumedError (ParseError (Token s) e) (State s) | EmptyOk a (State s) (Hints (Token s)) | EmptyError (ParseError (Token s) e) (State s) newtype ParsecT e s m a = ParsecT { unParser :: forall b. (BigArg e s a -&gt; m b) -&gt; m b } Or I guess you can factor out the `State s` data BigArg e s a = ComsumedOk a (Hints (Token s)) | ConsumedError (ParseError (Token s) e) | EmptyOk a (Hints (Token s)) | EmptyError (ParseError (Token s) e) newtype ParsecT e s m a = ParsecT { unParser :: forall b. (State s -&gt; BigArg e s a -&gt; m b) -&gt; m b }
Haskell also works fine on Windows with cabal. Like most things with cabal vs. stack, cabal does fancier things by default, and stack has a much smaller learning curve by default. Furthermore - there is absolutely no reason not to use Haskell in WSL nowadays. It works no differently than on any other flavor of Linux.
I'm currently pn WSL. It's great. Our other devs are all on Windows, they're also doing just fine.
&gt; without detours like newtypes No, because the kinds won't match. &gt; Functor :: (* -&gt; *) -&gt; Constraint &gt; HList :: [*] -&gt; * 
well using a newtype is the current solution, but I wondered whether I could improve it somehow
&gt; Seems currently `ghc-justdoit` still depends on `djinn-ghc` though. Is the synthesis completely irrelevant to `djinn` as of now? I am confused; how does it depend on it? 
Yes, that is indeed one of the two points I am trying to make with this – now all you people out there, create actually useful plugins! :-)
One condition might be: We only allow total definitions, the type consists only of type variables, functions and non-recursive data types, and the LJT algorithm finds one solution.
From a category theoretic perspective, why is `Functor` called `Functor`?
A `Functor`? No. But a functor? Yes. Let me explain, first at the most visceral level, by comparing the kinds of `Maybe` and `HList`, clearly something different Maybe :: Type -&gt; Type HList :: [Type] -&gt; Type Does *fmap* even make sense? Let's explore, mapping a singleton `HList` looks very similar to *fmap* (a -&gt; a') -&gt; (HList [a] -&gt; HList [a']) How boring. `a` is isomorphic to `HList [a]` and can be made a `Functor` instance with a *newtype*. Let's try something more interesting () -&gt; (HList [] -&gt; HList []) (a -&gt; a', b -&gt; b') -&gt; (HList [a,b] -&gt; HList [a',b']) (a -&gt; a', b -&gt; b', c -&gt; c') -&gt; (HList [a,b,c] -&gt; HList [a',b',c']) Oh there we go, rather than a **single** function `a -&gt; a'` we must have as many as the `HList` list is long. type Cat ob = ob -&gt; ob -&gt; Type data Funs :: Cat [Type] where FNil :: Funs '[] '[] (:/:) :: (a -&gt; a') -&gt; Funs bs bs' -&gt; Funs (a:bs) (a':bs') funs :: Funs '[Bool, Int] '[Bool, String] funs = not :/: (show :/: FNil) and now we can write *fmap* for `HList`.. it's exactly like `Functor`'s *fmap* only we replaced the first `(-&gt;)` with our novel `Funs` fmapHList :: Funs xs xs' -&gt; (HList xs -&gt; HList xs') fmapHList FNil HNil = HNil fmapHList (fn :/: fns) (a :&amp;: as) = fn a :&amp;: fmapHList fns as &gt;&gt; fmapHList funs (False :&amp;: (55 :&amp;: HNil)) True :&amp;: ("55" :&amp;: HNil) The current situation is sad: `Functor` only goes from `(-&gt;)` to `(-&gt;)` so it does not model `HList` class Functor (f :: Type -&gt; Type) where fmap :: (a -&gt; a') -&gt; (f a -&gt; f a') This bites is over and over again, to talk about functors from `(&lt;-)` to `(-&gt;)` we need [`Contravariant`](https://hackage.haskell.org/package/contravariant-1.4.1/docs/Data-Functor-Contravariant.html). To express functors between `(~&gt;)` and `(~&gt;)` we need [`HFunctor`](http://hackage.haskell.org/package/category-extras-0.53.4/docs/Control-Functor-HigherOrder.html).. Same with `Bifunctor`, `Profunctor`, .. 
Thank you! We definitely enjoy working in this domain as it's so multidisciplinary with a lot of room for new ideas, but also crying out for old-school sound engineering. Perfect place for Haskell really.
http://okmij.org/ftp/Haskell/tr-15-04.pdf
Thanks! That looks like exactly what I was looking for! 
May I also suggest a point (to get back to)[https://youtu.be/73B1uc3xkvo?t=4404]. :-) 
what I find most problematic regarding these parsers, is that each implementation has a different behavior regarding consumption and backtracking, which are determined by the implementation of the monad/applicative with regards to `satisfy`, which is pretty central/fundamental to understanding how to use the combinators correctly, but doesn't show up anywhere in the types and typically requires a blurb of documentation to explain, (but that blurb is frequently omitted). (e.,g. readP is different from attoparsec) 
You could go full modulus. Implement your new modular type as a value-modulus pair and actually answer your question "what is the result of a mod b multiplied by a' mod b'?" Off the top of my head a reasonable answer would be a*a' mod lcm(b, b'). This will get an answer rather than an error when you multiply numbers of different modulus, but I'm not sure whether that's a bug or a feature. At least it doesn't involve bringing in the heavy type machinery. I'm not sure why the monad approach needed GADTs or was hard. I would be inclined toward something like runMod 17 $ do a &lt;- b + c d &lt;- a * b return d which I *think* should be straightforward? Or you could do the thing /u/augustss [linked](https://www.reddit.com/r/haskell/comments/7v8im8/modulus_context/dtqb0td/). More machinery than I'd want, but it looks pretty.
You can actually have very much imperative (looking and behaving) code even in Haskell, you don't need to reach for a whole different language just for that paradigm. E.g. you can write many of your functions in IO with `do` notation, as long as they are descendents from `main :: IO ()`. If you want, perhaps as a learning step, you may write your whole app in `IO` with `IORef`s, with some pure functions hanging at the leaves. And then you can refactor bit by bit to introduce more purity when implicit and/or global (or widely shared) state starts to bite you in the rear end. And you can be more subtle as well, not having to reach for the big gun `IO`, by using the `ST` and `State` data types, which can give you a more fine grained level of imperativeness between full `IO` and full pure. Further reading that you may find interesting: - http://vaibhavsagar.com/blog/2017/05/29/imperative-haskell/ - https://www.microsoft.com/en-us/research/wp-content/uploads/1993/01/imperative.pdf
&gt; Do haskellers commonly have a portion of their program in an imperative language, to make it easier to have some state going for it Yes, but we don't use a _separate_ imperative language, we use DSLs defined in Haskell which are designed to provide an imperative look-and-feel. IO computations and State computations use this style. For example, here is an IO computation which imperatively mutates an accumulator `ref` in order to sum all the numbers from 1 to 10: import Data.IORef import Data.Foldable import Text.Printf -- | -- &gt;&gt;&gt; main -- The total is 55 main :: IO () main = do ref &lt;- newIORef (0 :: Int) for_ [1..10] $ \i -&gt; do modifyIORef ref (+ i) total &lt;- readIORef ref printf "The total is %d\n" total In this case, it would be much shorter to use `sum [1..10]`, but in some circumstances the imperative version can be easier to write, when translating a piece of pseudo-code which uses mutation for example. &gt; or would that likely only be for performance if you really need it While some of those DSLs are meant for performance, other are only used for the imperative look-and-feel. IO computations and ST computations are two examples. 
So I had a course on HOL at uni (the old HOL) and it was not very ergonomic. Later I discovered coq and it seems like a way better implementation of the idea. Why isn't everybody using that instead?
Thanks. I'll give it a go.
A functor F between categories C and D maps every object `c` in C to an object `F(c)` in D, and every morphism `g : c1 -&gt; c2` in C to a morphism `F(g) : F(c1) -&gt; F(c2)` in D. A Functor `f` of kind `*` -&gt; `*` maps every type `a` of kind `*` to a type `f a` of kind `*`, and every function `g :: a -&gt; b` to a function `fmap g :: f a -&gt; f b`. That is, we can model part of Haskell as a category Hask whose objects are types of kind `*` and whose morphisms are functions from one type to another. A Functor instance for a type constructor `F` can be viewed as a functor from Hask to Hask, where the type constructor itself maps a type `a` to a type `F a`, and the Functor instance's `fmap` method maps functions from `a` to `b` to functions from `F a` to `F b`.
In case you need any help there's [Gitter](https://gitter.im/haskell-gi/haskell-gi)!
Ahh I see. My mistake was viewing Hask's objects as concrete Haskell objects, not as Haskell types. "Going up a level" to kinds makes everything much clearer.
Seems like you've accidentally put a tab character before modifyIORef. I believe you meant to write: -- | -- &gt;&gt;&gt; main -- The total is 55 main :: IO () main = do ref &lt;- newIORef (0 :: Int) for_ [1..10] $ \i -&gt; do modifyIORef ref (+ i) total &lt;- readIORef ref printf "The total is %d\n" total 
Others have explained why you can't quite do this. /u/Iceland_jack has given one alternative. Another, in some cases, is to use a slightly different sort of heterogeneous list: data Rec :: (k -&gt; Type) -&gt; [k] -&gt; Type where RNil :: Rec f '[] (:&lt;) :: f a -&gt; Rec f as -&gt; Rec f (a ': as) Note that `HList as ~= Rec Identity as`. Now you can define the mapping function, which lifts natural transformations: rmap :: (forall x. f x -&gt; g x) -&gt; Rec f as -&gt; Rec g as rmap _ RNil = RNil rmap p (fa :&lt; fas) = p fa :&lt; rmap p fas For example, we can use rmap (either (const Nothing) Just) to convert a `Rec (Either a) bs` into a `Rec Maybe bs`.
At that point you will have a lot more pleasant time working with length-indexed vectors (`Vect 4 Int` isomorphic to `HList [Int,Int,Int,Int]`) but you are seek [`Each`](https://hackage.haskell.org/package/lens-4.16/docs/Control-Lens-Each.html#t:Each) from the lens library. [`Setter`s](https://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-Setter.html#t:Setter) (and thus `Traversal`s) generalize our usual *fmap* so if we can define a `Traversal'`. Existing instances give you over each :: (a -&gt; a') -&gt; (Identity a -&gt; Identity a') over each :: (a -&gt; a') -&gt; ((a, a) -&gt; (a', a')) over each :: (a -&gt; a') -&gt; ((a, a, a) -&gt; (a', a', a')) over each :: (a -&gt; a') -&gt; ((a, a, a, a) -&gt; (a', a', a', a')) And we can add our own `HList` instances instance Each (HList '[a]) (HList '[a']) a a' where each :: Traversal (HList '[a]) (HList '[a']) a a' each f (a :&amp;: HNil) = fmap (:&amp;: HNil) (f a) instance (a2~a, a2'~a', Each (HList (b:bs)) (HList (b':bs')) a a') =&gt; Each (HList (a:b:bs)) (HList (a':b':bs')) a2 a2' where each :: Traversal (HList (a:b:bs)) (HList (a':b':bs')) a a' each f (a :&amp;: as) = liftA2 (:&amp;:) (f a) (each f as) This seems complicated for various reasons (to aide inference we forbid empty lists, a `Traversal` is a lot more general than a `Setter`, we support polymorphic update) but the final result is quite simple, we map over a homogeneous `HList` of characters abc :: HList '[Char, Char, Char] abc = 'a' :&amp;: 'b' :&amp;: 'c' :&amp;: HNil &gt;&gt; over each abc 97 :&amp;: 98 :&amp;: 99 :&amp;: HNil and because we put in the effort to define a `Traversal` we can iterate over a `HList` with a [`for`-loop](https://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-Fold.html#v:forOf_) &gt;&gt; forOf_ each abc print 'a' 'b' 'c'
I've just helped run the Data61 (formerly NICTA) fp course in a couple of cities. There was a pretty good turn (50+ people) in both cases, ranging from interns still at uni through to some folks with 30 years of programming experience. We covered most of what was in your list in 3 days and folks seemed to range from doing pretty well to very well with it. The open source materials for the course are - unfortunately - incomplete, as they don't capture the explanations and examples that are presented when the course is run in person. It'd be great to try to find a way to fix that. Having helped our with the course a few times now, I'd feel I'd be doing the participants a disservice if I skipped any of the theoretical bits. To be fair, I am assisting someone who has been running the course for around 10 years now, so that might be having quite a large effect on the outcomes :) 
Why would strictSum get rewritten to foldl'? I'm not aware of any mechanical method to automatically generate fold definitions from general recursion.
Well, you never remove anything from the first list so all the letters just get compared to 'f'. Also, the correct solution is probably going to be a bit more complicated than that. For each letter in the first list you'll need to go through the second list and filter it out.
That is what I'm stuck on. Any suggestions on how to move the first list along so I can check for everything besides just f?
With a modern ghc you can do it in a simpler way. You can have a type `M n a` where n has kind Nat, and then use natVal to get its value at runtime. It will only require a KnownNat context. 
You can refine your cases a bit and you should be good. Lines 2 and 3 can be expressed as a single equation: fun [] [] = [] fun [] (y:ys) = (y:ys) because whatever the value of string2 is, you return it, so you can write just fun [] string2 = string2 also, the following equation in line 4 makes an assumption: fun (x:xs) [] = [] ... you are assuming string1 can be contains at least one element (`x`) and something else (`xs`). If the result of this expression does not depend on string1, you can leave it out with `_` (as a marker for "i don't care about this value"), so you get a more general equation: fun _ [] = [] 
Is the inner list truly untyped? Or are the elements always the same (date first, then doubles)? Chances are, if there is a pattern to them, you will want to capture it in your types. You may have to write your own JSON instances to make it work, but that is inevitable sometimes.
Are you familiar with the concept of a functor as defined in category theory?
The HList (called `Many`) from my [data-diverse](http://hackage.haskell.org/package/data-diverse) library allows for a [fmap-like](https://github.com/louispan/data-diverse/blob/c973409bfc3876803d3ae3352dadaf1673851b7e/test/Data/Diverse/ManySpec.hs#L329) functionality.
Perhaps ask your instructor?
I figured it out actually. This is what I have, thanks for the help! How would I do it using folds? I know pretty much everything should stay the same except for the last line. https://pastebin.com/UR7ftpXK
A nice facelift indeed. Though it doesn't seem to fix the organizational issues that seem to be the larger complaint (not that I think this has been an actual impedance to anyone). Mobile layout could use some work
The problem appears to be in L6, you have to remove the pre-pended x from the beginning of the string. fun :: String -&gt; String -&gt; String fun [] [] = [] fun [] (y:ys) = (y:ys) fun (x:xs) [] = [] fun (x:xs) (y:ys) | x == y = fun xs ys | otherwise = y:(fun (x:xs) ys) Although without the actual problem I don't know if that just happens to work for your inputs "fog" and "foeg". It could be correct for that case but incorrect for something else.
What's up with all the wasted space on the sides?
Maybe the [modular-arithmetic](https://hackage.haskell.org/package/modular-arithmetic) package is what you're looking for? (Using the fancy Unicode Z is optional.)
Good work! Though for the haddock documentation I would still prefer the old layout. After seeing your work, I feel these two improvements can be done 1. The color of link (&lt;a&gt;) can be changed from red, to the one you have selected. 2. The background of example expressions can be changed from light blue to grey. But still have some difference between the type signature background and examples. Apart from these I feel the old look is quite good for usage on laptop screen. 
Doing it! Should I have gone through Functors first?
Like, you make your own money, or real money? :-)
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/T3tp3wn.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dtqxk9n) 
The header also takes up more space when display height been shrinking on laptops and monitors.
The max-width limit makes sense, but the old color scheme had a lot more contrast for the text, which is the most important part of documentation. It doesn't have to #FFFFFF on #000000, but the new text fg/bg is a regression in terms of readability.
It's the same Nuno so the same scheme.
"lack of visibility on type class instances" -- could you expand on this? E.g. your linked screenshot shows all the instances beneath the class. Do you think it doesn't show enough information with them, or do you mean something else?
On mobile (small screen sizes in general), the unused vertical space has a big impact on readability because it causes function signatures to wrap more often.
That's not wasted space. It's good design. Margins exist for more reasons than printers not being able to print to them. It is fatiguing on the eyes to read back and forth across the entire length of a screen. 
In my opinion, this content is fine. If there is a corresponding Stack Overflow question, a link to it would be nice. However it's not necessary. Since the OP deleted their question, here it is on SO: https://stackoverflow.com/questions/48601573/how-would-you-define-these-types-in-haskell
I think the previous design is more compact.
Using `DataKinds`, you can write a type that has a modulus at the type-level: newtype Modulo (n :: Nat) a = Modulo a Then, you can give it the relevant `Num` instance: instance (KnownNat n, Num a) =&gt; Num (Modulo n a) where fromInteger i = Modulo (i `mod` natVal (Proxy :: Proxy n)) Modulo a + Modulo b = Modulo ((a + b) `mod` natVal (Proxy :: Proxy n)) -- etc... Then, a value `3 :: Modulo 5 Int` cannot be added to a value `4 :: Module 7 Int`. This is exactly the trick used by [`modular-arithmetic`](https://hackage.haskell.org/package/modular-arithmetic-1.2.1.2/docs/Data-Modular.html) that /u/globules linked to.
I like it! It's definitely an improvement, although the text contrast will likely need to be higher, especially for links. My problem that I see so far is that a lot of the css seems to be semi broken on Flynx (an Android browser that tends to break a lot of websites due to not supporting a lot of dumb edge cases. It uses webview); particularly the table views and the "summary" tab thing. It would be nice to see it tested and fixed for webview and looked at on some more minimal browsers that only implement specs rather than the cocktail of extra magic that most modern browsers have to work around and accommodate bad code.
Well they're certainly less emphasized than other top level definitions, for starters. But I'd say the bigger problem is the way Haddocks placed on an instance are formatted. If you want to document the behavior of an instance (the other problem is that people tend not to do this...), then the Haddocks will be displayed almost like a footnote next to the instance, which is not how I would hope for any purposefully written Haddocks on top level definitions to be displayed. TL;DR: Everything about instances is displayed as a footnote, when they should have more emphasis.
Do you mean the unused horizontal space? In that case, the function wrapping isn't a bad thing, it just needs to be wrapped more intelligently. Putting soft line breaks after class implication arrows, and indenting wrapped types to start at the same column as where the type bit of a type signatures normally starts would be a big difference. Before (made up example): foo :: (Monoid a, Traversable b) =&gt; (a -&gt; b -&gt; b) -&gt; ... After: foo :: (Monoid a, Traversable b) =&gt; (a -&gt; b -&gt; b) -&gt; ...
I half way agree with this. Limiting the width of content is good. But wasting space is bad. The /r/Haskell style is almost the perfect layout. It takes up my screen, but uses every inch effectively without making anything hard to read. I think this design needs to make better *use* of the margins, not decrease them.
There's a couple of ways you can think about this: implementation of type classes as a language feature, and library design of various type classes in Haskell. The overall theme seems to be "Don't give in to convenience!" Haskell's type classes rely on a property called *global coherence*: a type may have at most one instance for a type class, and this instance is the same instance everywhere. One way to preserve this property is to require that all type class instance declarations are located in either 1) the module defining the type, or 2) the module defining the type class. Instances that don't fit those two definitions are called "orphan instances," and can cause problems in code. PureScript banned orphan instances. You might consider doing the same thing. Orphan instances can be convenient, but if your API/library design requires orphans, then perhaps it should be rethought. There's likely a good formalism for moral orphan instances in the places where it makes sense (eg Servant), but we haven't figured it out yet. PureScript is actually a great place to look for what a "clean slate" implementation of type classes could be like -- the language has a number of Haskell's extensions on by default (`MultiParamTypeClasses`, `FunctionalDependencies`) and is getting a new feature called "instance chains" that allow you to have something like `if-then-else` at the type level. This allows for more advanced type level computation. As far as library design is concerned, the "bad" type classes tend to be: - `Num` -- Way too many concerns! It handles converting numeric literals, adding and multiplying, and negation -- these three would ideally be their own type classes that map more closely to a numeric hierarchy, like `Group`, `Ring`, etc. This would also allow you to have numeric literals that don't permit operations like `negate`. - `Read` and `Show` -- These two classes ideally are used for debugging, where `show` is only used to inspect/debug a data structure, and `read` only used on the output of a `show` call (and, ideally, it should hold that for any `x`, `read (show x) == x`). Unfortunately, `read` is used for parsing strings, and `show` is used for end-user display output. The relationship between `read` and `show` is only a soft convention. Finally, we don't have a real *debug* class that can be used to print eg functions or other opaque types from the REPL, which limits its use as a debugging tool. - `Monad` superclasses: it used to be that `Functor` and `Applicative` were not superclasses of `Monad`, which resulted in a lot of wailing and gnashing of teeth. Part of the problem with the upgrade path was that there isn't an easy way to *add* a super class constraint without breaking all the downstream code. This is now fixed, but it caused ecosystem churn. There's a similar thing happening now with `Monoid` and `Semigroup`. - `Monad` has a `fail` method that was included to allow partial pattern matches in `do` notation. We really wanted you to be able to write something like: main = do [from, to] &lt;- getArgs doStuffWith from to Which looks quite nice and can be convenient, but it ends up being a bad idea almost all of the time. We're moving `fail` into it's own class `MonadFail` and removing `fail` from the `Monad` class. - Lawless type classes. Stuff like `ToJSON`, `FromJSON`, `Arbitrary`, `Read`, `Show`, etc. all fall into this camp. The big idea is that "using a type class for name overloading alone is abusing the feature." This is a little more controversial, but some people prefer for any type class to have laws that the operations must abide by.
My aesthetic sense is bad and in general I should shut up in matters of presentation. But I was thinking whether it would make sense to condense the package landing page. The main idea would be to show the documentation as prominently as possible with meta information hidden but easily revealed by a click. I would think something as simple would do # PackageName Version: 4.2.42 (Older) &lt;- expandable Synopsis: Description: Meta: &lt;- expandable # Modules ... ... ... 
It does. I'm currently learning haskell through that book, and as a high-school dropout "lambda calculus" sounded really scary. It was nothing to be scared of though.
Amazing work! But too bad it will never be used. This is not the first time someone has tried to redesign Hackage/Haddock. Whoever runs hackage is too in love with the current hideous design. Do you think LTS releases are the only reason Stackage exists?
I could agree on a refresh that updates colors and fonts, but most refreshes seem to actually make it harder, to find information by spreading the content out so much and adding lots of space. 
A previous redesign put the synopsis and topbar links in the margin. Most other package repos do the same. Examples: * https://docs.serde.rs/serde/ * https://docs.racket-lang.org/binary-class-mp3/index.html * https://docs.python.org/3/library/stdtypes.html * https://nodejs.org/docs/latest-v7.x/api/os.html
I'd suggest talking to the PureScript folks -- they've probably got the most advanced open source type class implementation aside from GHC, and are very friendly and accessible. They hang out on the [FPChat](https://functionalprogramming.slack.com) slack ([invite link](https://fpchat-invite.herokuapp.com/))
Hi. Herbert and I tend to be the gatekeepers for hackage PRs these days (though on anything architectural or major there are many others who play a key role -- we're more sort of janitors and tweakers in our own contributions). We're both very supportive of the current redesign effort, as we have been of past redesigns. To my knowledge there aren't other redesign PRs that have foundered or been spiked. If anything, the difficulty, as the discussion on this thread evinces, is that when it comes to design there are a _lot_ of views, and it takes an enormous amount of patience and care to sort through them, and a certain amount of guts to ever "pull the trigger" on a redesign knowing that invariable some portion of people will always prefer how things used to be. I'm very appreciative of and impressed by how well Nuno has been responding the huge variety of input thus far!
I'd argue that the global coherence property type classes rely upon is fundamentally anti-modular and would advocate instead for something like OCaml's implicits and module system.
Interesting idea. Hanging reverse-indents are actually not-too-awful to implement in css. I worry that this may behave badly when you get degenerately-long function names however...
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [haskell/hackage-server/.../**packagePageAssets.st** (master → 8664d03)](https://github.com/haskell/hackage-server/blob/8664d038f9e787b8911cf0892d73822e0c1b3aaa/datafiles/templates/packagePageAssets.st) * [haskell/hackage-server/.../**Html** (master → 8664d03)](https://github.com/haskell/hackage-server/tree/8664d038f9e787b8911cf0892d73822e0c1b3aaa/datafiles/templates/Html) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dtrc6n6.)
Good point. Here's a relevant ticket: https://github.com/haskell/haddock/issues/300 And here's a really bad example from it: https://hackage.haskell.org/package/servant-server-0.12/docs/Servant-Server.html#t:HasServer
first notice that you can make this quite a bit shorter: Fun :: String -&gt; String -&gt; String Fun [] [] = [] Fun [] (y:ys) = (y:ys) Fun (x:xs) [] = [] Fun (x:xs) (y:ys) = Fun xs (rmChar x (y:ys)) notice how you never use `y` or `ys` themself? You always use on the right side `y:ys` too - this tells you that you don't need to break it down in the first place: Fun :: String -&gt; String -&gt; String Fun [] ys = ys Fun (x:xs) ys = Fun xs (rmChar x ys) at this point you can probably see the fold pattern(?)
The experience on mobile is not very good - the gutters are relatively huge and much of the baseline alignment is broken. Also, could you rollup the section headings into a sticky side menu on desktop and hamburger on mobile?
Some nice ideas, and there's a ton more that could be done, as some of this stuff is just presented in a very suboptimal way (e.g., timestamps are in a very human-unfriendly format). A couple changes I'd recommend: you can remove some of the static vocabulary that surrounds data and just present the data itself. Two cases where I'd do this are replacing `The X Package` with just `X` and `Tags: tag1, tag2` with just `#tag1 #tag2`. I think the color balance is geared too far to the right and makes it kinda difficult to look at. The header has some easy issues too - the text isn't all aligned correctly (there's more margin above than below), and there's needless dots between the items on the right. [Here's a screenshot with a few of these changes I made hacking in the browser inspector](https://i.imgur.com/FmaxrnP.png).
I like the design, but I think a lot of the issues are just beyond what a redesign can fix, stemming from the way that documentation is written, or just the way haddock/hackage works. - There's no indication when documentation hasn't built for the most recent version of a package, [the links just vanish](https://hackage.haskell.org/package/HList-0.4.2.0). - Having the package page separate from the top-level documentation page just clutters google results. Coupled with the previous point, this makes finding docs pretty frustrating. - Content from modules that are re-exported is [completely undiscoverable](https://hackage.haskell.org/package/containers-0.5.11.0/docs/Data-Map.html). How on earth do I find out what's in scope when I import a module? How do I search within a module? An input box with auto-suggest/live results would go a long way. [Look](https://doc.rust-lang.org/regex/regex/struct.Regex.html) how cool the Rust one is. Moving the synopsis to a default-open sidebar would be a start. - Pages are often [cluttered with esoteric instance declarations](https://hackage.haskell.org/package/aeson-1.2.4.0/docs/Data-Aeson.html). I'm probably not reading the docs to find an Eq1 instance on a 7-tuple. - In contrast, it seems common to just not document anything covered by a typeclass. There are some packages with no documentation aside from a listing of instance declarations; An experienced user sees that and thinks "awesome, I already know how to use this", but a novice sees that and thinks "I guess this doesn't do anything" or "looks complicated, must be internal/for advanced users". Maybe we need a standard place to point people to learn what, e.g., "Contravariant" is, or maybe some instance declarations should be expanded by default. - Code blocks are mostly not syntax highlighted - Type signatures are unreadable. Look at Data.Aeson's `genericLiftParseJSON`, to just pick one at random - what _are_ those parameters? Contrast with the [Python docs](https://docs.python.org/3.4/library/re.html): "re.**search**(pattern, string, flags=0)". Constraints also push the signature arbitrarily rightward, making it hard to find the start - syntax highlighting might help there. Breaking them across lines like in Numeric.Kalman helps, but at the cost of lots of vertical space. - There's no consistency in function descriptions - some are missing, some are short, some are long and include large example code blocks which, while helpful, make pages un-skimmable. [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp) keeps things skimmable at one line. [Java](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html) at least has some nice boxes. Python's a mix, but they seem to have a habit of giving more space to more commonly used functions. - Same for documentation at the top of the page - sometimes it's practically a blog article on basic usage (Control.Lens), sometimes it's a description of implementation (Data.HList.HList), sometimes it's a proof (Numeric.Kalman), and sometimes there's nothing (Data.Functor.Compose). A lot of packages don't even tell you how to construct a value to get started. First thing on those MDN pages is how to construct a value. - There's often little indication of what common usage looks like. Even the more nicely documented `containers` package seems to give equal or more weight to esoteric zips and special-case optimized operations as it does to `lookup`. Other ecosystems admittedly aren't much better here, but they're better about compensating with examples that make it clear. Maybe sorting functions by usage statistics somewhere would help? I don't mean to rant - I think the thing to do would be to put together a set of best practices for writing documentation, and build the design to look optimal when those standards are met, like how git tools often rely on the 50/72 rule for commit messages. That would at least let a redesign do things like collapse/de-emphasize the more detailed content, and create some useful visual hierarchy. As things are, any designer's hands seem pretty tied by the freedom Haddock gives users to just write whatever.
Can't we put more of the metadata in the margin? Make more things visible at once.
Could you perhaps expand a bit on that for the sake of those that aren't familiar with OCaml?
Instances for associated types are not shown at all. https://github.com/haskell/haddock/issues/526
Can wholeheartedly recommend! You can check out my project from last summer out for inspiration if you want to. Feel free to ask any questions as well! https://github.com/m0ar/safe-streaming https://m0ar.github.io/safe-streaming
(finally) installing ghcjs/reflex https://github.com/ElvishJerricco/reflex-project-skeleton and (relatedly), adding almost trivial `vinyl` wrappers around `reflex` and `reflex-dom` functions https://github.com/sboosali/reflex-vinyl/blob/master/sources/Reflex/Vinyl/Example.hs#L62 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [sboosali/reflex-vinyl/.../**Example.hs#L62** (master → c83d662)](https://github.com/sboosali/reflex-vinyl/blob/c83d6622b808f3ad07febc50ffab30dd313e585a/sources/Reflex/Vinyl/Example.hs#L62) ---- 
Those are great comments. Can you add your header alignment fixes as a comment on the PR? https://github.com/haskell/hackage-server/pull/648
I feel one of the largest problems with Haddock documentation is that you can not see parameter names (without clicking Source).
Pisces looks really good on mobile !
This needs to be fixed at a documentation level because top level pattern matching doesn’t make extracting the parameter names easy.
Its untyped in the sense of "not all elements in the list are of the same type" so i cant do a simple 'decode "[1,2,3]" :: Maybe [Int]', but yes you are right, its always the same pattern. I end up with a 'Maybe Value', which should by a 'Maybe [[Value]]'. How can convert a Data.Aeson.Value to Integer or Double?
&gt; I can imagine others (people who use those distributions) might care about this a great deal As a data point, I primarily use hackage when browsing, but I like that there is an "LTS" link so that I can browse the documentation when it is not built on hackage.
Isn't it sometimes okay to want something anti-modular? What if, for example, I want to ensure that I have only one serializer and one deserializer for any given type (to avoid accidental mismatches) across my whole codebase? How would I ensure this property with modular implicits?
I would put the serialiser/deserialiser in the same module as the type itself then. Then introducing any other serialiser/deserialiser would require you to define and import one which would make implicit resolution ambiguous and therefore you'd have to specify which one you mean explicitly. That's sufficient protection against accidental mismatches, while still allowing you to define an alternative serialiser/deserialiser if you need to.
I agree that it *should* be sufficient, but I can definitely imagine it failing to prevent problems in certain settings. Thanks for the description; wanted to make sure I wasn't missing some foolproof solution.
&gt; There's no indication when documentation hasn't built for the most recent version of a package, the links just vanish. See the "status" field. That's an old page, so its not clear what happened exactly, but it shows that there was no build attempted, likely because of a bad manual doc-upload by the user that pre-empted the builder. Typically for a package with failed docs you'll see the build reports. (And if the docs are pending, the status will say that too). &gt; Content from modules that are re-exported is completely undiscoverable. this is hard :-) c.f. https://github.com/haskell/haddock/issues/563 &gt; An input box with auto-suggest/live results would go a long way We have quickjump in haddock HEAD. go to https://hackage.haskell.org/package/lens-4.15.4/docs/System-FilePath-Lens.html and type `s` :-) &gt; Pages are often cluttered with esoteric instance declarations. I'm probably not reading the docs to find an Eq1 instance on a 7-tuple. I am :-P. That's what makes universal usability hard. Fair point on syntax highlighting -- I opened a ticket asking about that... I suspect it might be hard to do something really nice given the data that's lying around at docgen-time. I've got no feedback on how individuals choose to do their documentation of their own packages, as that's not really something that can be centrally controlled through improving the code -- the best that can happen is some package authors can set a good example and encourage others to follow suit. I like the idea of optimizing for "docs done right" but I don't know if there's even a possible uniform standard for that. Note that package authors can sort the functions they expose and organize them however they see fit. If they want to put all the esoteric stuff hidden away -- that's in their power right now :-)
Thank you! I read the JSON as list of tuples with the specified types `[(Integer, Double, Double, Double, Double)]` and map this list over a function that constructs a `Candle` using record syntax. Actually 4 lines of code, that's great. :) Never thought aeson can parse things flexible like this. I think I have to re-read the documentation.
You could take it one step further, and make a `FromJSON` instance for `Candle` that does this, then you can decode to `[Candle]` directly. Remember, just because you *can* create JSON instances by deriving them, or through generics, doesn't mean you *have to*.
WriterT always leaks, both variants. You should use something like StateT instead.
This sounds good, but I have another problem. I load the candle data from different exchanges. One of them giving me a list of objects `[{"high":0.1234,...}]` and this exchange we are talking about gives me a list of lists. If I create a `FromJSON` instance for `Candle` i would bind the creation or deserialization of a candle-presentation directly to my data structure. In Java I would build a abstract factory or builder pattern or something like that. Then I have the opportunity to control the creation of a `Candle`. Do you have any ideas how I could solve this with haskell?
I don't quite recall how was it for me, I think I only knew the basics of functors (having read about them, but not used) - and I still didn't have much problem with these exercises.
My thesis. Sadly that's taking time away from programming, but ostensibly I'm still working on [dejafu](http://hackage.haskell.org/package/dejafu), my concurrency testing library. Around the time of the last thread I released [version 1.0.0.0](https://github.com/barrucadu/dejafu/releases/tag/dejafu-1.0.0.0), which added support for bound threads, significantly improved performance of testing, and resolved a lot of interface clutter. Since then I've been on maintenance mode: reworking docs, organising the GitHub issues, and finally converting all the examples in the Haddocks into doctests. I hit an interesting issue with GeneralizedNewtypeDeriving. It turns out that this sort of thing does not work: ``` {-# LANGUAGE GeneralizedNewtypeDeriving #-} class Class a where foo :: proxy a -&gt; Int data Type1 = Data1 instance Class Type1 where foo _ = 5 newtype Type2 = Data2 Type1 deriving Class ``` The issue is that GHC doesn't know enough about the `proxy a`: ``` foo.hs:11:38: error: • Couldn't match representation of type ‘proxy Type1’ with that of ‘proxy Type2’ arising from the coercion of the method ‘foo’ from type ‘forall (proxy :: * -&gt; *). proxy Type1 -&gt; Int’ to type ‘forall (proxy :: * -&gt; *). proxy Type2 -&gt; Int’ NB: We cannot know what roles the parameters to ‘proxy’ have; we must assume that the role is nominal • When deriving the instance for (Class Type2) ``` The solution is to make things less polymorphic (boo, hiss!) and use `Proxy a` or something similar. This bit me when someone found they [couldn't derive an instance](https://github.com/barrucadu/dejafu/issues/172) of `MonadConc`, the class dejafu uses to abstract over concurrency.
Two approaches come to mind. The first one is to consider both of these alternative representations of a `Candle`; then you would write a custom JSON instance that accepts either format. This isn't too hard; in `parseJSON` you can pattern-match on the `Array` and `Object` constructors, and use whichever parser is appropriate based on that. The second approach is to have two different types for the candle serialization formats, and another type for the actual `Candle` you are going to use in your application, and then you'd write functions to explicitly convert the intermediate formats into the proper `Candle` type. The first approach is better when conceptually any server is free to pick either format, and clients are supposed to accept both interchangeably. The second approach allows you to more precisely select which one you expect, and reject the unexpected one. You can also combine the two approaches: if you have the two specific candle types (say `CandleSerList` and `CandleSerObj`), you can use their `FromJSON` instances to write a `FromJSON` instance for `Candle`, like so: instance FromJSON Candle where parseJSON value = (candleFromSerArray &lt;$&gt; parseJSON value) &lt;|&gt; (candleFromSerObj &lt;$&gt; parseJSON value) This will try to first convert the JSON value via `CandleSerArray`, and if that fails (e.g. because you are getting an object, not a list), it tries going via `CandleSerObj`. The in your JSON readers, you can pick your deserialization strategy by declaring one type or the other. Especially when you're working with third-party serialization formats, making separate types for the JSON representations is a good idea, because it allows you to decouple your own data structures from what the APIs can give you, so I would probably go with the second approach here.
For sure. I've mostly been idly pondering how the various pieces in between would best be presented if we were going to try to translate the experience a little better to the world at large. It might mean some blog posts, but possibly also some screen casts, some blog snippets, maybe some gifs of using type holes and the like. I don't really know - but from the experience of the course, it really feels like something like that is likely to be possible. I could be wrong, but eventually I'd like to try some of these things and find out.
I so wish that blockchain is going to be Haskell's "killer app". It really looks like a great fit: fast, safe, facilitating changes, able to codify high level concepts well.
It looks like I might finally be getting paid due writing haskell. It depends on whether or not I can convince a customer (who is also a friend and a fellow FP/Haskell enthusiast) that Haskell is a good choice for a web API back end. To that end I'm currently whipping up a proof of concept using servant and persistent, trying to demonstrate some of the cooler features that he isn't aware of. There's also a fair bit of exploring I need to do in this space myself. I'm pretty optimistic.
I think I would use the second approach. The first approach means that I have to touch my old code every time I add the support for a new exchange or candle format. Using separate types for different formats or implementations sounds good. I would use these types only in different `Internal` modules for each exchange. What would be your approach? At first I still have to find out how to implement a parseJSON version using an array.
&gt; `Num`... This leads to another important point - using type classes to overload literals. In general, type classes methods only resolve at runtime. Literals must be guaranteed to resolve at compile time. If you must have overloaded literals, use a macro facility, or some special notion of type class that is guaranteed to resolve at compile time. Otherwise, just use type-specific literals like most languages do. In my opinion this is one of Haskell's biggest warts. &gt; `Read` and `Show`... I don't think this is so bad in Haskell. But let's compare with, say, Python. It's not perfect in Python either, but people are generally happier with it. What's different? Python has two methods: `repr` like Haskell's `show`, which provides a runnable code representation of the value, and `str`, which provides a human-readable string representation. Haskell lacks a separate human-readable class, so the two are sometimes conflated, and in my opinion that's what causes most of the problems. &gt; ...`fail` ...a bad idea almost all of the time. Not really. It's a **good** idea for monads that have a natural notion of failure, like `Maybe`, lists, and other instances of `MonadPlus` and `Alternative`. In fact, for lists it's essential for comprehensions, which are really nothing more than a slightly different syntax for `do` notation. It's a bad idea for monads like `IO` where `fail` throws an async exception. &gt; Lawless type classes... Right, and let's not forget `Foldable` and `Traversable`, perhaps the most notorious lawless classes ever since the "FTP" event. While I actually like those classes in some situations, it's a problem for them to be the default for so many important list and `Maybe` combinators.
I am building a uniform EDSL for cryptocurrency exchanges. [https://github.com/McGizzle/crypto-binder] (https://github.com/McGizzle/crypto-binder) I would love to eventually release it onto Hackage and hopefully involve the community and get even more exchanges added. 
I wrote a toy Haskell implementation of the ZKBoo protocol to better understand it myself https://github.com/cocreature/zkboo-hs
Made a nice way of writing type safe Martix and Vector literals this morning m :: Matrix 4 5 Double m = matrix ((1,2,3,0,0) ,(4,5,6,0,0) ,(7,8,9,0,0) ,(0,0,0,0,0)) v :: Vector 3 Int v = vector (1,2,3) it should make my notebooks a little bit prettier
Continuing to work in the UK rail industry space using Haskell. I've been working on a project to automate collecting receipts / categorise my taxi trips into ones I can claim expenses on and ones I can't. It uses web scraping with selenium, produces some files (screenshots, csvs) and in the future I want to look at interfacing with the Google Maps API (addresses -&gt; long/lat -&gt; distances from known points) to help with categorisation as well as look at storing my data in a postgres database instead of scraping every time I rerun something.
The two things I usually see from people who have used both is that some stuff is easier (or shorter) to express in Isabelle/HOL, and that coq doesn't have an analogue for sledgehammer.
Yes, but I wasn't clear on how the category Hask was defined
Why can't we just check for colliding orphan instances at linkage / global level? 
I think that would be nice, iff we had type-level indexing for instance selection. i.e: `Map k v` becomes `Map k ord v` where `ord` is the ordering relationship on `k`. Otherwise, you lose efficient map merges. 
It's essentially the same as Set, with the only difference being that every type is inhabited by the additional value `_|_` (or `undefined`). Most of the time this difference doesn't matter.
Nah, you don't need indexing for Map or Set merges. Just use ML functors. Generates a new map type for each ordering. i.e Map(Ord1).T /= Map(Ord2).T 
The difference is what the parameter scopes over, isn't it? The map type, or the whole module. A relatively superficial one? Adding type-level instance indexing to Haskell is easy and relatively non-overlapping. Adding ML functors much less so. 
We're not talking about Haskell in this case though. Juniper is at-present a fairly minimal functional language so I think ML modules with functors is no more difficult than type classes at this point.
[This paper](https://arxiv.org/pdf/1512.01895.pdf) does a reasonable job of explaining it.
As I said, I'd prefer the second approach in this situation myself. As to how you'd write your own array-based instances: [this](https://hackage.haskell.org/package/aeson-1.2.4.0/docs/Data-Aeson.html) covers most of the stuff you need to know.
That's an interesting idea. I think the reason it is not done currently is because of GHC's "separate compilation" model. Each module compiles to a standard object file, and we use the standard linker. If we compile one module when we see one instance, and then another module when we see a different instance, and then try to link the resulting object files together, the result is undefined and can result in a segfault.
Haha, the fact that our strict pattern trickled through GHC without the extension enabled has pickled our minds in the MSc thesis for a few days. This explains it! :)
Great job!
I have a pet peeve with data types and type classes in Haskell in general for being parametrized positionally. I think row types are much better for readability and allow you to select which parameter you want to apply to in class instances. Here's a [small write-up](https://gist.github.com/chrisdone/5bfaa534f843035a932185a1864cb7a7) exploring that. I'm excited to explore this more in prototype mini-languages, and possibly in Duet.
But it does see the "global" picture when building `Main.hs` (or whatever top level module is). It can (and probably already does) propagate instance existence information in `hi` files all the way up to the top.
How did you enable dependent types in Haskell? Would love to see the whole code!
One aspect that went unmentioned is that documentation should try very hard to render in lynx or dillo, two fast and lightweight HTML engines. That way there's a high chance that any simplistic HTML engine will also render it correctly. And if we have that, then it'll be very easy to load Haddoc in a fancy GHCI or haskell-mode with eww. To achieve that the HTML has to gracefully 'downgrade' to basic HTML. In addition to that, accessibility is a feature that is easier to achieve if we focus on that clean/basic mode. tl;dr: basic, clean HTML enables new Haddoc use cases and accessibility, if we do not hard-require complex CSS and skip JavaScript.
Hey, I'm also in the UK rail industry and am using Haskell for a few odds and ends! (Not officially. We're a C# shop sadly).
Those aren't dependent types, just type-level numbers. Look up the -XTypeLits extension.
My understanding of GHC "separate compilation" is that it does not do that, by design. An `.hi` file for a module just provides the information needed to reference exports in other modules' object files. It plays the role of a `.h` file in C. I could be wrong though.
Working on a walkthrough again. Though it's really messy. This time about Telegram bot.
For literals one option is to have the value of literals be stored at the type level, then the type checker will verify their correctness at compile time. So like: class IsInteger (v :: Integer) (a :: Type) where fromInteger :: Proxy v -&gt; a And then `5` would desugar to `fromInteger (Proxy @5)`. So then for example `Natural` would NOT be an instance of `IsInteger (-5)`. I think that regardless of how useful or not useful `fail` is, we can all agree it does not belong in `Monad`. On a side note traversable is not lawless, it does have laws. 
Hm, the materials you referred to were LYAH and RWH, neither of which talk in any depth about those things. I haven't read the Haskell Book. [From the description, it looks like](http://haskellbook.com/progress.html#lambdacalculus) it was added *in response to reader confusion/feedback*, not based on expert assumptions about "deeper mathematical underpinnings": &gt; This chapter provides a brief introduction to the lambda calculus. This chapter was added some time after our initial May 2015 release in response to reader testing that showed later concepts were still a bit confusing. In addition to this introduction explaining the basic semantics, we list optional follow-up reading in order of difficulty for those that want to go further. Do not skip this! It'll make Haskell concepts, such as currying, easier to understand later on. And that makes sense, precisely *because* currying, partial application, and just the kind of heavy "functions here, functions there" style of Haskell is very alien to newcomers coming from Python/(classic) JS/Java/what-have-you! For a &gt;1000-page book, building useful fundamentals (like understanding the lambda calculus at a basic level, not "monads are just ...", let's be clear on that) is a good idea, considering literally all of the language relies on functions.
Is it the norm now to have a lifted `instance Monoid a =&gt; Monoid (f a)` that doesn't match with the `Alternative`/`MonadPlus` instance? Don't know how I feel about this, on the one hand it is confusing that Monoid and Alternative don't act the same way, but on the other hand: if we have different operators, we might as well use them for different things.
I was interested in the initially presented use case, but it never really got very fleshed out.
Out of curiosity, what's the argument against lawless type classes (like `ToJSON`)? The advantages seem obvious, but I'm having a hard time coming up with an actual problem such a typeclass would cause.
We have base haddocks on hackage? http://hackage.haskell.org/package/base (they have to be manually uploaded, since base can't build automatically on the builder, so sometimes things fall behind a bit, although processes are improving...)
I've seen it, and it's cool, but I don't see why we couldn't just embed similar primitives in Ocaml, Haskell, Agda or Idris.
This is as close as I could get, but you have to wrap the values in a `Single` constructor, so I suppose it doesn't really count. I wouldn't be surprised if there was a proper solution. data Foo a = Foo a deriving Show newtype Single a = Single a deriving Show class Updatable u where update :: u a -&gt; Foo a -&gt; Foo a instance Updatable Single where update (Single a) (Foo b) = Foo a instance Updatable [] where update xs foo = foldl (flip update) foo (map Single xs) 
You can do it with a closed type family. {-# LANGUAGE TypeFamilies, MultiParamTypeClasses, FlexibleInstances #-} data Foo a = Foo [a] deriving Show type family U a b where U [a] a = a U a a = a class Update a b where update :: a -&gt; Foo b -&gt; Foo (U a b) instance Update [a] a where update as (Foo fs) = Foo $ as ++ fs instance (U a a ~ a) =&gt; Update a a where update a (Foo fs) = Foo $ a : fs
You should publish the code somewhere! I think it's a shame that Haskell doesn't have great support for numerics, because type level information like this would make it a great language for it.
Now that there are a few solutions to show *how* it can be done, it's probably worth asking *should* it be done? For a case like this, it seems like a lot of complexity for a tiny benefit. Instead, how about only providing `update'` and, wherever you want a single-element update, just using `update' [c]`?
It's essentially the fear of C++ style overloading problems. It's real, but I think the issue is overstated. Lawless overloading can be quite useful. It's especially useful in `mtl`-style code, where you can start subbing in new transformers that manipulate how a certain overloaded term behaves. Reflex does this for a lot of things, e.g. to support static rendering.
Thanks for the response! And all your work! Just to clarify a bit - &gt; See the "status" field Yeah, I know what to look for now, but the situation's really problematic for newcomers. It would be better to maybe have some copy around where the links are that says "The documentation for this version isn't available; the last version with documentation available is 0.0.1.0" &gt; [listing re-exported modules] is hard Makes sense. &gt; We have quickjump in haddock HEAD Awesome! &gt; I am :-P. That's what makes universal usability hard. Yeah, me too, but I mean, maybe for some things that are more accessible from, e.g., ghci :info, it's worth finding a way to hide behind a click or some scrolling for the sake of readability for newcomers. &gt; I like the idea of optimizing for "docs done right" but I don't know if there's even a possible uniform standard for that. I was suggesting git's practice (of having the first line of the description separated) somewhat literally, truncating long descriptions with "..." and maybe a link/expand to the full description - that would allow for an overview more like the [Methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#Methods_2) section on the MDN page. That's definitely the kind of change that'd need some broader support, though. Not to dwell on it, just some food for thought. Admittedly, my suggestions are biased toward "it needs to be more friendly to necomers", because the issue at the top of my mind right now is onboarding (and getting buy-in from) other people. The current state of the documentation has been a bit of a hinderance there, especially with the people who just want to dive right in.
I use the following scheme for formatting signatures: shortFunctionNameShortType :: Ctx =&gt; T1 -&gt; T2 longFunctionNameShortType :: Ctx =&gt; T1 -&gt; T2 anyFunctionNameLongType :: Ctx =&gt; T1 -&gt; ... -&gt; Tn No idea whether this could be implemented in CSS though. A simpler and more consistent variant would be to always have the line break between function name and type, but this of course wastes a lot of vertical space in the typical case (short name and shortish type).
 In which case, I should probably switch the names, providing only update on lists (or Foldables) and not export update on characters, if I use it at all.
TypeFamilies and GADTs, another rabbit-hole of research to go down. We did try something similar to this I think (not exactly the same), but ran into the problem with not being able to do "class Update a b where..." because of a lack of MultiParamTypeClasses which we didn't know about. 
For your numeric hierarchy, you should definitely look at what Purescript has come up with. Nothing is ever perfect, but Purescript's is much better than haskell's. `Semiring`, `Ring`, `Group`, etc. are great. Here's a [guide](http://a-guide-to-the-purescript-numeric-hierarchy.readthedocs.io/en/latest/introduction.html).
Thanks for the response! And all your work! Just to clarify a bit - &gt; See the "status" field Yeah, I know what to look for now, but the situation's really problematic for newcomers. It would be better to maybe have some copy around where the links are that says "The documentation for this version isn't available; the last version with documentation available is 0.0.1.0" &gt; [listing re-exported modules] is hard Makes sense. &gt; We have quickjump in haddock HEAD Awesome! &gt; I am :-P. That's what makes universal usability hard. Yeah, me too, but I mean, maybe for some things that are more accessible from, e.g., ghci :info, it's worth finding a way to hide behind a click or some scrolling for the sake of readability for newcomers. &gt; I like the idea of optimizing for "docs done right" but I don't know if there's even a possible uniform standard for that. I was suggesting git's practice somewhat literally, de-emphasizing or hiding text after the first line - that would allow for an overview more like the [Methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#Methods_2) section on the MDN page. That's definitely the kind of change that'd need some broader support, though. Not to dwell on it, just some food for thought. Admittedly, my suggestions are biased toward "it needs to be more friendly to necomers", because the issue at the top of my mind right now is onboarding (and getting buy-in from) other people. The current state of the documentation has been a bit of a hinderance there, especially with the people who just want to dive right in.
Hmm, so if Foo were a more complicated ADT, then it would look something like: data Foo a = Empty | Single a | Pair a a deriving Show class Updatable u a where update :: u -&gt; Foo a -&gt; Foo a instance Updatable Char Char where update c (Single a) = if a == c then Empty else Single a update c (Pair a b) = if a == c then Single b else if b == c then Single a else Pair a b instance Updatable a a =&gt; Updatable [a] a where update s foo = foldl (flip update) foo s and get `(Single 'd') == update 'a' $ update 'b' $ update 'c' $ Pair 'a' 'd'`? Would it be possible to replace `instance Updatable Char Char` with `instance Updatable a a`, or does there need to be a concrete type somewhere in there? 
I can't say I particularly like this instance. It seems very adhoc. Why not add it for all monads?
I'm not *actually* suggesting adding it for all monads. It was a *reductio ad absurdum*. If we actually did that it would have to be for each monad individually (which just seems to make it even more ridiculous).
Next episode: `Num` instance for `IO` * https://twitter.com/ChShersh/status/922435077275078656
This seems more Haskell related than Haddock related. Also, due to currying, it is not always clear what will be shown.
Is this approach compatible with currying by default? Or that would oblige single parameters to functions to be single-field record?
For me, it actually is the norm for the `Monoid` instance for monadic types to lift the inner monoid this way. Not everyone agrees though. For example, we don't have a `Monoid` instance for `ReaderT` because some people feel that the existence of two possible instances (both the monoid-lifting one and the alternative-matching one) means that neither should be chosen. I personally prefer the monoid-lifting one very useful. 
If you optimize for beginners at the expense of correctness, you get nasty warts like `Num`. `Num` is a problem because it is too complected. You might ask "How to break it down?" and one possibility is "a type class for every operation" -- `class Add a where`, `class Multiply a where`, `class Negate a where`, etc. Another possibility is "Reuse the hierarchies from mathematics," which gives you `class Semiring a where`, etc, and now you have a teaching/documentation problem ("What is a Semiring?"). You can reuse the math hierarchy and give it totally different names, like `class AddMultiply where` along with a doc comment "This corresponds to the Semiring concept from abstract algebra, and the laws are the same." I generally think that this ends up confusing folks more than not, as an "intuitive" name for eg `Ring` is something like `AddMultiplySubtractWithSomeLaws`. Ultimately, I think that the "optimize for beginners" is a false flag. A person is a beginner for only so long, and will be proficient for the rest of their life. Maybe it takes a year to learn something, but they'll have it on hand for 5-10-20-50 years afterwards.
This is a very superficial change and ultimately doesn't do much to improve the usability of Hackage. Why is the bug tacker link more prominent than documentation. Why do listing pages waste space showing "rating", a field seemingly nobody uses? Compare Hackage to NPM On NPM a package's documentation is fron and center and it uses a multicolumn layout to display less important metadata (https://www.npmjs.com/package/twitter) On Hackagewe have tons of wasted space with the single column layout, we're overloaded with metadata, most of which we don't care about, and the documentation is way down the page, underneath the fold (with a sickly yellow background, no less) (https://hackage.haskell.org/package/twitter-conduit)
I think being negative about someone's hard work because it doesn't resolve _other_ things you would also like resolved is not a very good way to engage in community interactions. It tends to discourage contributors and potential contributors -- including people that may want to implement the very things you'd like! That said, a multicolumn layout is definitely a potentially good idea, and I think a PR for it would receive good consideration. Some ideas from this thread beyond the scope of this PR have been tracked at: https://github.com/haskell/hackage-server/issues/667
The notation is fine, I guess. The code generated us 100s of functions with 100s of arguments, coerces everywhere and magic byte tables. Ugh...
I am not asking for it to show me names that do not exact in pointfree style. I am asking for it to show me e.g. which one is called needle and which one is called haystack in the code. Doesn't even have to work for functions that have different names for their parameters in different clauses.
lol at "by a few radical political extremists" That's the usual drivel from de Goes trying to discredit the author, presenting them as politically-motivated hypocrites out to get LambdaConf. The talk of people building "political dossiers" reeks of conspiratorial thinking when the reality is much simpler: LC invites nazis and mysoginists, tells everyone who's not happy about it to go get lost, then cries about the awful SJWs whilst getting (financial even) support from Breitbart or some other far right organizations. These far right extremists then target and harass whoever spoke up. But, sure, the "radical political extremists" are the ones saying "eh, maybe don't have nazis ans mysoginists on stage at your event if you want it to be inclusive". To see that this is endorsed by an /r/haskell mod (using his official role to broadcast it) is pretty concerning tbh.
Would a newtype-wrapper (similar to `Sum` and `Product`) be an acceptable compromise?
&gt; This aggressive Twitter posturing used to harass or supress those you don't agree with is the real bigotry. This rhetoric is straight out of the far right's playbook: classic reversal to victimise the victims by presenting them as "the real [fascist/racist/sexist/bigot].
Working on [Lamdu](http://www.lamdu.org). Some of our recent work includes: * Revamping the whole naming model, to support multilingual program collaboration (i.e: see and even edit the same code in English, Spanish or whatever language you speak). * Support for monadic IO execution in the REPL * Detect old DB schemas for graceful upgrades rather than crashes * Support various new structural AST edits * Tons and tons of code cleanups * The underlying [Momentu](https://github.com/lamdu/lamdu/blob/master/src/GUI/Momentu.hs) GUI framework enhancements (we need to extract it from Lamdu when it stabilizes enough) * RTS support for sockets (Lamdu runs a toy web server now!) * Lots of bug-fixes Our next milestone, hopefully in a couple of months, is to be usable for some realistic small web server projects.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [lamdu/lamdu/.../**Momentu.hs** (master → 88ac74c)](https://github.com/lamdu/lamdu/blob/88ac74c67b1aa398a4bb4fc88a33bd3d7a6123a3/src/GUI/Momentu.hs) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dts832x.)
I honestly hope everyone will be able to power through and make it happen. I've literally had coworkers laugh when they first saw haddock. It would be a mistake to convince ourselves that the current design is fine just because we've gotten used to it.
" It would be a mistake to convince ourselves that the current design is fine just because we've gotten used to it." Nobody thinks that. :-)
One way to learn the details of the story would be to read the linked post, and follow the links therein. In any case, I don't think that a discussion, as contentious as it may be, of one of a well-known FP conference and its policies, is "tangentially related to Haskell at best." It is on topic for this subreddit by any measure, even if past experience shows that a lot of angry back-and-forth discussion that arises is comments may be so vitriolic as to be off-topic and require moderation.
Is there any reason for `Alternative` to even exist if it has the same behavior of `Monoid`?
If instance resolution could depend on the instance contexts, you could add it to all, perhaps. I wonder if that idea even works.
Back when I was making my own monad library, that was the design I used. One wrapper for lifting `&lt;*&gt;` and another for `mplus`. (Two, actually, because I had separate classes for distributive and non-distributive `mplus`.)
I think that the newtype wrapper (providing a `Monoid` instance for `Applicative` type constructors) would be a good thing to have in `base` regardless. I think David Feuer has lobbied for this in the past, but it never picked up enough traction. Still, as [I've argued before](https://mail.haskell.org/pipermail/libraries/2017-November/028312.html), I would prefer that types like `ReaderT` be given a `Monoid` instance that lifts the inner monoid. I want to be able to use things like `foldMap`, `fold`, and `mconcat` on `ReaderT` without the burden of a newtype wrapper. We've already got an `Alternative` instance that makes use of the underlying alternative. It's seldom very useful because `Alternative`'s set of halfway-agreed-upon laws encourage the behavior of short-circuiting on the first "success". Meanwhile, `Monoid`'s set of completely-agreed-upon laws encourage the behavior of combining information. I want to be able to use this combining behavior (which is much more useful to me) as easily as people are already able to use the short-circuiting behavior today.
One reason is that until now (one of the next versions of GHC will have quantified contraints), we could not have something as `forall a . Monoid (f a)`. as a constraint. Also, `Alternative` has further laws that cannot be written just using the `Monoid` interface.
So make an `unsafeIOToTransaction`, where you have to choose it explicitly, instead of when you reflexively `liftIO` your way into a mistake.
So replace `update 'a'` with `appEndo (update 'a')` and replace `update' "abc"` with `appEndo (foldMap update "abc")`? That seems against the stated goal, which is to be able to more closely match the language used in the paper I'm working off of. It seems to make the situation more complex.
Ideally you should have a way to refactor type classes more easily. Examples: Adding `Applicative` between `Functor` and `Monad`, Adding `Semigroup` as a superclass of `Monoid`. It is frustrating that these project have to take as long as they do. It is great that there are people with the will and the patience to do them. This is easier said than done.
It doesn't have the same behavior. They don't even talk about types of the same arity: class Monoid (a :: *) where mempty :: a mappend :: a -&gt; a -&gt; a class Applicative f =&gt; Alternative (f :: * -&gt; *) empty :: f a (&lt;|&gt;) :: f a -&gt; f a -&gt; f a `Monoid` has the following laws: - `mappend mempty a == a` - `mappend a mempty == a` - `mappend a (mappend b c) == mappend (mappend a b) c` `Alternative` has similar laws, but it's got some additional laws as well, and people don't agree on what the additional laws should be. Also, it's got `Applicative` as a superclass. One could imagine a classes like this: class MonoidForall (f :: k -&gt; *) where memptyForall :: f a mappendForall :: f a -&gt; f a -&gt; f a class Monoid1 (f :: * -&gt; *) where liftMempty :: a -&gt; f a liftMappend :: (a -&gt; a -&gt; a) -&gt; f a -&gt; f a -&gt; f a mempty1 :: (Monoid1 f, Monoid a) =&gt; f a mempty1 = liftMempty mempty mappend1 :: (Monoid1 f, Monoid a) =&gt; f a -&gt; f a -&gt; f a mappend1 = liftMappend mappend Either of these classes (equipped with appropriate laws) are more genuinely the "higher-kinded `Monoid`" than `Alternative` is. Fortunately, we will not need either of them once [Quantified Constraints](https://github.com/ghc-proposals/ghc-proposals/pull/109) happens. 
This seems to be part of a larger social/ethical question, that is, should we allow bad people (e.g. "misogynist") to do good things (e.g. "deliver a heartfelt, vulnerable, and inspiring keynote on facing fear, for free")? I don't think we're going to solve this question here, tbh.
Maybe that's common on laptops, but desktop users seldom have their browser window taking up the whole screen. That would be pretty inefficient for browsing documentation while coding anyway.
I think a better question would be "is a bad person *capable* of delivering a heartfelt, vulnerable, and inspiring keynote on facing fear, for free or otherwise, or is he just virtue signalling?" I don't think we're going to solve this one here either, sadly. 
Well, apparently he actually *did*, and everyone thought so until his previous MRA/PUA/whatever history was discovered.
The article opens with: &gt; I wrote a response to LambdaConfs’ purposeful invitation of misogynist Ed Latimore as their keynote speaker. Does anyone have a copy of this? I would be interested in reading it, but I cannot find anything about this story other than an article written by Breitbart, and it's a pretty horrible article.
Future extension `-XDerivingVia`: `Monoid` (and friends) can be derived for any `Applicative` using your `Lifted` deriving (Semigroup, Monoid, Num, Floating, Fractional) via (Lifted Foo a)
Worked on a few of my toy projects: - [x86-debug] - a REPL/debugger for a tiny subset of x86 I was working through a compiler course and it was getting kinda hard debugging the output of my compiler, so I made a tool to help me with that. - [nyanpasu](https://github.com/soupi/nyanpasu) - the compiler in question. I've been working on this on and off for a while. Last time I implemented proper tail calls and pairs allocation, and integrated x86-debug into it. - [msg](https://github.com/soupi/msg) - a toy chat server/client. I found [purescript-specular](https://github.com/restaumatic/purescript-specular) which is heavily influenced by reflex-dom and decided to give it try and build [a client](https://github.com/soupi/msg/tree/master/app/client) for my chat server. I am not very familiar with web development, especially client side, and i was pleasantly surprised by reflex-dom's model - it was fairly flexible and a lot easier to learn that I thought it would be! On the way I also converted the messages the server sends to use JSON format using Aeson. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [soupi/msg/.../**client** (master → 2402059)](https://github.com/soupi/msg/tree/240205900868f46469258fa52de34ab78c19ac0d/app/client) ---- 
The joys of being a beginner; always new stuff to learn, in this case, guards. 
I don't think that opening the conversation by labeling the other party as "radical political extremists" is professional, and gives an unfair characterization of the other party.
Make a kickstarter for `DerivingVia`. I'd chip in if it helps it get done faster. Actually, with the new proposals process working as well as it is, it would be really cool if there was a way to donate to an accepted proposal to help incentive their implementation.
I have done no work for Stackage though.
Ah, thanks. I totally goofed and thought that the horizontal divider signaled the start of a different post.
What is ad-hoc about it?
Note that the Num instance is not law abiding so long as subtraction is allowed because you don't have `x - x = 0` However, if you remove subtraction from the `Num` class then it's a perfectly fine instance
I'm currently working on two projects: * a compiler (written in Haskell) for a subset of the Julia language for Fully Homomorphic Encryption (FHE). So that if your program fits the subset it can compute on encrypted values without decrypting them! Yay privacy. (FHE is known to be slow though :-\) * With some folks at UMD's PLUMLab I'm working on Probabilistic Abstract interpretation for determining the Quantitative Information Flow (QIF) of programs. We recently got a paper accepted on a way to give you better bounds on the QIF by switching from 'full soundness' to 'probabilistic soundess', i.e. i'm 99.999% sure that the bound on QIF is X or lower. Galois is also hiring so if these sorts of projects seem interesting to you let me know :)
Yes, "bad people" experience fear, and learn how to overcome it, and feel a desire to share that with others in a spirit of generosity. It happens, shockingly, because in truth people don't sort into neat boxes marked "good" and "bad".
That flag was being used. After some discussion, we all agreed it was inappropriate in this case, and I appreciate Taylor taking constructive criticism in growing into his role as a mod.
* https://github.com/ocharles/dhall-to-cabal mainly. I should be able to release it this month, I think it's pretty much cooked now.
Lol! I'm not even remotely far right nor am I reciting from their playbook. Trying to get someone removed from speaking at a privately organised meeting - that you have every right NOT to attend - just because one labels them a misogynist is oppressive and bigoted. 
&gt; Lists and Maybe play a fundamental role in the semantics of Haskell's type system I assume you mean "people frequently use lists and Maybe in Haskell programs"? &gt; Lists and Maybe [are frequently used in Haskell programs], so by default it should be as easy as possible for a human reader to be able to see directly in Haskell source code that the type of an expression is a list or a Maybe If you believe this, then you believe that `[]` and `Maybe` should not have any typeclass instances at all, and instead we should have `mapList`, `mapMaybe`, `bindList`, `bindMaybe` etc. If you want to figure out the type of some expression `fmap f x` then you have to know the type of `x`. It would be *easiest* if `fmap` wasn't polymorphic. Then you either have `mapMaybe f x`, `mapList f x`, or some other `mapX f x`, and now you can instantly guess the expression's type by looking at the name of the function. There is a language that believes this approach is the best one; it's called Elm. Ask people who frequently use Haskell why they won't use Elm.
For what this is (a reskin of the current Hackage) I think it's a great step. I'd like to just merge it now. :) Of course there are lots of other issues, but those shouldn't prevent this improvement from being used.
I have locked this thread while I review it. Please do not be alarmed.
Which one? The funding thing or the `DerivingVia` implementation?
I'm working on a toy cryptocurrency for an interview challenge.
.cabal as a total config language, nice!
I've never understood that requested equivalence when I've heard it. For instance, it seems clear that `Nothing &lt;|&gt; Just 2 == Just 2`, and natural enough that `Just [2..4] &lt;&gt; Nothing &lt;&gt; Just [5..7] == Just [2..7]`. Moreover, for data analysis, it's nice to be able to do `foldMap getDBRows inputs` and have it do what you want. 
True, but just to be clear, critiquing someone's work is not being negative about said worker. 
For file IO it uses async system calls which do not block the IO thread and uses `epoll` to check when calls complete and block iff all haskell threads are bloccking on IO.
Thanks for unlocking it promptly. 
Ah, shocking indeed. You have posited a question "are bad people capable of good things", with which I've engaged in good faith, and you have responded with a sarcastic dismissal of the concept of badness, thus negating your entire premise. What a waste of time.
I mean, if you need to use slurs like "SJW" to make your point then maybe your point isn't a particularly valid one. 
Systemd socket activation can be used for zero-downtime swapover between compiled versions of a service as long as the old version supports a clean shutdown on a TERM signal (complete existing requests but stop accepting new connections).
Leave the ad hominem where it belongs and answer with a proper argument please.
Shocking indeed.
Answer to *what*? You've not even engaging in the conversation, just badgering and sealioning.
I use `State` where I don't want to pass and handle an argument that contains the state and I use `TVar`s and `TQueue`s for concurrency. This doesn't happen that often though. I care for purity very much and have only used unsafePerformIO a handful of times and only for shallow reasons (i couldn't be bothered to do it the right way, it was something that i didn't care much about, and i would've seen it immediately if the code did something unexpected). Every time I needed to fix a performance issue it was due to a too naive algorithm/using the wrong data structure. Up until now I've always got acceptable performance doing things "the right way". Vanilla Haskell with purity and everything can get go quite far imo.
I have not clue WTF LambdaConf is. But if it has ties to Breitbart, it better have nothing to do with our haskell community.
[LambdaConf](http://lambdaconf.us/) is an annual functional programming conference in Boulder, Colorado.
Your `Monoid1` class is *almost* `Applicative`. You just need to change the type of `liftMappend` to `(a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c` and they're equivalent (with `pure = liftMempty` , `(&lt;*&gt;) = liftMappend id`, and `liftMappend f a b = f &lt;$&gt; a &lt;*&gt; b`). Interestingly, the laws of the two are exactly the same, just phrased differently.
I [clarified](https://twitter.com/jdegoes/status/960488713548570624) exactly what happened on Twitter. Unfortunately, Sonia's account is filled with intentional inaccuracies (Ed was not hired, Yarvin was not invited, etc.) and character smears. LambdaConf does not research or endorse views of speakers or attendees, and focuses strictly on providing a safe and professional educational environment for career advancement. Latimore's [motivational keynote](https://www.youtube.com/watch?v=17rgUgdZHgg) on overcoming fear was highly-acclaimed, even by Sonia herself, which is a testament to the value it provided to attendees. Anyone who met Ed, shook his hand, and talked with him for even a minute would understand he's a kind person who is very passionate about helping people improve their lives. Indeed, I believe every one of us has a thing or two to learn from someone who grew up in the ghettos and overcame alcoholism and abject poverty to become a physicist and teacher. And yeah, Latimore has stuff to learn from us, too. That's what it means to be human.
I don't think this is a particular thorny ethical or even logistical question. It's not hard to organize a great conference that doesn't include even a _single_ white supremacist, professional misogynist, eugenics enthusiast, etc., as unbelievable as de Goes might find that. Why not choose to invite someone else equally good to tell an inspiring personal story? The embarrassing parade of men that is the 2017 line-up speaks clearly enough, but the response by De Goes makes me want to have no part in LambdaConf going forward. Luckily there are projects such as Strange Loop and Compose Conf that seem to take inclusiveness seriously, to the benefit of both the social health _and_ technical advancement of the FP community.
The latter, I thought there was a branch with this somewhere.
&gt; There is no way to model IO, for example, or even exceptions in the style of Either. IO I can live without, but the loss of Either seems pretty killer, no? Can you model any non-determination at all? (E.g., Maybe or lists)
&gt; LambdaConf does not research or endorse views of speakers That first of all seems foolish, since it seems to regularly be causing issues such as this one. &gt; Anyone who met Ed, shook his hand, and talked with him for even a minute would understand he's a kind person who is very passionate about helping people improve their lives. Are you dismissing the charges of misogyny because he was nice to you? &gt; And yeah, Latimore has stuff to learn from us, too. It would have been quite interesting if this became a teachable moment. Maybe LambdaConf could have provided a platform for him to explain himself and apologize. Or if you and LambdaConf had issued a statement acknowledging that you have a role in perpetuating sexism in our industry, and a responsibility to do better (as we all do). It doesn't seem like anything like that happened here.
Well you can always emulate exceptions using `Cofree`, like you might use `Free` in an extensible effects setup.
&gt; `repr`... which provides a runnable code representation of the value Real nitpick here, but values for `repr` are often (maybe even usually) not actually runnable. In practice, classes often can't be built from a short argument list, are instantiated from other objects which may not themselves have runnable reprs, or have important state this isn't effectively conveyed by a runnable constructor. Really, both `repr` and `str` are supposed to be human readable representations of objects. The difference really is that `repr` is intended to be useful for a developer, while `str` should be appropriate to display to end users.
Start by implementing the function: hog :: (c -&gt; d) -&gt; (a -&gt; b -&gt; c) -&gt; (a -&gt; b -&gt; d) hog f g a b = f (g a b) Now you need to get rid of `b`, `a`, `g` and `f` in this order to obtain a point-free expression. hog f g a b = f (g a b) hog f g a b = f ((g a) b) -- using associativity hog f g a b = (f . g a) b -- by definition of (.) hog f g a = f . g a hog f g a = (f .) (g a) -- associativity hog f g a = ((f .) . g) a -- definition of (.) hog f g = (f .) . g hog f g = ((f .) .) g -- associativity hog f = ((f .) .) -- equivalent to (.) ((.) f) hog f = ((.).(.)) f hog = (.).(.)
If one does not research speakers, it seems like it would be rather difficult to invite a keynote, no? :-)
Not a "bad person" -- rather, a person whose career was built on advancing ideas that you do not wish to support. (assuming, that is, that these are ideas that people do not wish to support, which is what one hopes).
Thank you! I have a couple more questions thoughm where did f g a b come from? how did you get the second line ``` hog f g a b = f (g a b) ```
This didn't occur to me, thanks for the suggestion! Fixed and updated.
I'll use `comp` instead of `(.)` here because it is easier for me to read. First, lets write out a definition of `comp`/`(.)`. comp f g x = f $ g x Now, lets write out a definition of `hog` for comparison's sake. hog f g x y = f $ g x y Well, this sort of looks like `comp`. Let's try to plug it in. hog f g x y = ((comp f' g) x) y The only issue is that `f` isn't the right type -- we need some other `f'`. What's the type of `f'`, and what can we use to make it? Well, we've got a `c -&gt; d`. `(comp f' g) x` will pass `g x` to `f'`, so `f'` should take in a `b -&gt; c`. The result of `(comp f' g) x` will be passed `y` and the result will be returned immediately, so `(comp f' g) x` should return a `b -&gt; d`. The type signature `(c -&gt; d) -&gt; (b -&gt; c) -&gt; (b -&gt; d)` should look pretty damn familiar -- it's just `comp`/`(.)` again. Therefore `comp f` is of type `(b -&gt; c) -&gt; (b -&gt; d)`. Perfect, so let's plug it in and simplify. hog f g x y = ((comp f' g) x) y where f' = comp f hog f g x y = ((comp (comp f) g) x) y hog f g x = (comp (comp f) g) x hog f g = comp (comp f) g hog f = comp $ comp f Now, this definition should look familiar -- we have a function that expands to `foo $ bar x`. Lets plug in `comp` again and simplify. hog f = (comp comp comp) f hog = comp comp comp Replace `comp` with `(.)`, and we have `hog = (.).(.)`
Here's [a nice blog post on it](http://jobjo.github.io/2018/01/28/implicit-functors.html).
These are just made up parameter names, you can chose whichever you want. To implement hog, just look at its type: given a function whose type is (c -&gt; d), another whose type is (a -&gt; b -&gt; c), a value whose type is `a` and another value whose type is `b`, we want hog to return a value whose type is `d`. There is only one way to compose the parameters to return a `d`.
That’s part of the question, but not all of it. Being invited to give a keynote address at a large public conference deposits a certain amount of legitimacy into one’s bank account. Speaking at a conference gives you more than one type of platform: even if Latimore didn’t say anything offensive when he was at the conference standing on a literal platform, when he tweets something offensive he’s writing as Ed Latimore, Keynote Speaker at LambdaConf 2017. People involved in public discourse have a responsibility to act respectfully in _all_ of their speech. Do conference organisers really want to lend their hard-earned legitimacy to people who might abuse it?
Perhaps you're being confused by the naming of things. It's very weird to think of the argument to the function passed to foldr as an accumulator, since it doesn't really accumulate anything, it's just bound to the result of folding over the rest of the list (which generally won't have been computed yet, as lists can only be processed from beginning to end). One way to think about what the function foldr c n does is to take each (:) in the construction of a list, and replace it with the function c, and the [] (if any) and replace it with n. So in this case, we're replacing each (:) with the function (\x ys -&gt; f x : ys) which is a sort of modified version of (:) that applies f to the element before adding it to the beginning of a list, and then we're replacing the [] at the end of the list with []. So we could just write: map' f = foldr (\x ys -&gt; f x : ys) [] leaving off the argument for the actual list to be processed. If we want to make that explicit, we can though, and we pretty much end up with the version you gave. If you want to replace the [] at the end of the list with something different, that's also possible. An example of that is in writing (++), the function which appends two lists: xs ++ ys = foldr (:) ys xs i.e. we can compute xs ++ ys by replacing the [] at the end of xs with ys, (and replacing each (:) with (:)) You can see a graphical representation of what foldr does in the top left corner of this picture I made a long while back: https://i.imgur.com/QgqXFC8.png
I can’t speak to the possible historical reasons why it was written that way, but it’s good to get comfortable with looking at the documentation and source for library functions that you use. [Here’s](http://hackage.haskell.org/package/base-4.10.1.0/docs/Prelude.html#v:foldr) a link to the documentation for foldr in prelude, where you can see the type signature. The type signature indicates that the order of the arguments in the accumulation function (element, partial accumulation) are the other way around from as the starting values passed in (starting value for accumulation, structure with elements being folded over).
Foldr takes three values, so don't make the mistake that [] and xs are being directly fed into that lambda. The type signature of foldr is foldr :: Foldable t =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b Meaning that the initial accumulator value is put before the list (or other Foldable structure) the fold happens over, and is fed into the function as the second (right) value.
Wait wait! **`proxy`**? With a small '`p`'?? In a type declaration? Or did you perhaps mean to use `proxy#` with magic hashes? 
Do you mean `-XDataKinds`? I can't find any documentation on an extension called `-XTypeLits`. Or does the former imply the latter (like the case with `-XGADTs` implying `-XGADTSyntax`)? 
But where do you draw the line? What is considered bad today, is not tomorrow, and what I say considered okay today is not tomorrow—it changes with the times. By starting to draw arbitrarily lines in the sand stating what you think I should okay or not, you go down a slippery slope of non-diverse thinking. And listen, I'm not saying that white supremacy is correct, but by shutting off the opportunity for discourse, you end up not solving any problem, and only strengthen your own group, while further polarizing others. Imagine if people were able to just have a dialogue for once. That is of course a little besides the point. I personally think that if a talk went through without any consideration to its author, and it was found valuable, then it should stand by its merits. That fact that some people feel unequipped to be in the same room as someone with a dissenting opinion, just shows that they have a lot of growing up to do, if they cannot separate one view from another. &gt; The embarrassing parade of men that is the 2017 line-up speaks clearly enough... Why is it embarrassing that it is predominantly men? Sure, if they actively excluded women, then yes I would agree, but it being a professional conference, and that they do author-blind reviews, I don't see how reverse sexism is gonna move things forward. If you want more women included in the lineup, then try to reach out to more women, but if it only happens to be men submitting talk proposals, then why should they be punished, when the opportunities were the same. Or are you arguing for equality of outcome?
&gt; And listen, I'm not saying that white supremacy is correct, but by shutting off the opportunity for discourse, you end up not solving any problem, and only strengthen your own group, while further polarizing others. Sure, feel free to have a discourse about sexism, racism, and anything else. But it's still not clear why marginal and offensive viewpoints are being sought out and promoted by a functional programming conference. When LambdaConf invited Curtis Yarvin in 2016, a lot of people protested, but at least he was involved in a software project (even if not one particularly relevant to functional programming). In 2017, it's pretty clear that LambdaConf explicitly looked for another speaker that would provoke controversy, and is trying to trade on their wink-wink approach to racism and sexism to attract a certain crowd. That's their right, but it's something people should be aware of going into the conference. Personally, it's not something I'm willing to financially support by attending.
&gt; In 2017, it's pretty clear that LambdaConf explicitly looked for another speaker that would provoke controversy, and is trying to trade on their wink-wink approach to racism and sexism to attract a certain crowd. /u/jdegoes is this true?
We're comparing and contrasting two people here: one refers to women as "it", holds incredibly toxic misogynist views, and harassed at least one women on Twitter; the other is concerned with how women and minorities are treated at events and advocates for a safer future for all (and might have tweeted a comment celebrating the death of a Nazi or something? Idk). That's about as fair and objective a description as I can find, so far. &gt; It is very unfortunate how the US cannot seem to hold any public discourse without people resorting to black and white polarization I quite agree. However, what I find equally disconcerting is the massive amount of gaslighting required to twist the social narrative around to where somehow these two people are being put on even footing--both being equally "wrong." Where did America go wrong when attempting to point out how implicit endorsement of white supremist views, or highly misogynistic views is seen as resorting to petty polarization? &gt; There is a regular occurrence of people being ostracized, loosing their jobs, being shunned from communities and getting personal harassment from people that target them through Twitter. The author spends a majority of her article discussing how all of this happened to her at great length. Why does this only a bad thing when it happens to Nazis and Red-pillers? &gt; Ironically, your personal attack, which it indeed is, can likewise be seen as a classic move from the far left to discredit anyone that does not hold the same extreme views as simply being "alt right" or "naizs". I use the term Nazi in my comment here as the last controversial speaker at lambdaconf was literally a white supremist who identified with Nazi views, not as some strawman insult. It's one thing to claim people are being dismissed by a strawman, but that is not the case here.
Maybe we should view legitimacy as contextual, rather than fungible? It could save a lot of drama. "Keynote Speaker at LambdaConf 2017" shouldn't hold any weight when it comes to political or social views, and for most people, I don't think it does.
&gt; ... and promoted by a functional programming conference But that's the thing, they explicitly do not endorse *any* of the speakers viewpoints no matter if they agree or disagree, and have stated so clearly several times. &gt; In 2017, it's pretty clear that LambdaConf explicitly looked for another speaker that would provoke controversy, and is trying to trade on their wink-wink approach to racism and sexism to attract a certain crowd. I think that is quite the stretch, and is not the perception I have of LambdaConf (although never having attended, I'm in the EU and just finishing up my MSc, i.e. too expensive). 
Fun. I had to halve the y increment and circle size and open the output frame in a new tab to see the 3d. Can it be made more dense with color? 
[removed]
[removed]
&gt; they explicitly do not endorse any of the speakers viewpoints Indeed. But they do promote their speakers' viewpoints. How many people ran into Ed Latimore's openly sexist positions because of his speaking position at LambdaConf and surrounding publicity? The article proves that the answer is not zero. It seems more likely in the hundreds, or more. I suppose anyone can reach their own conclusion on whether the *same* conference in two consecutive years just *happened* to decide to invite two different people with publicly extremist views on fundamental civil rights issues (the second of whom had absolutely no connection to the topic of the conference at all) entirely by accident.
Is `x-x=0` even a law of `Num`? Does `Num` even have laws (given that `Float` has a `Num` instance)?
Thanks! while `ComposeFunctor` is nice, does that means we're unable to write (in haskell syntax) `map isJust [Just 5, Nothing]`?
Like this? https://code.world/haskell#PmzpiQ0-AC5jfaYSDUvz0WQ
This is what it looks like for a community to have a conversation about what is and isn't within the common sense bounds of our discourse. LambdaConf is, of course, free to invite (or not invite) whomever they want. But people *are* going to talk about the decisions they've made as a basis for choosing whether to participate in the future. People in this community are making decisions about whether to attend, and it's a normal time to have those conversations.
Not sure to be honest! It may be that the implicit resolution allows for it, but it also might mean you have to explicitly annotate what functor instance you are using. Would have to actually try it to see!
In our MSc thesis we are looking at improving the heuristics of `ApplicativeDo`with optional statement weights, to pave the way for better implicit parallelism with `Haxl`-style packages
You're doing awesome work! Thank you!
It was with `-O2`. I don't think it is a bug, perhaps just a missed optimization opportunity.
&gt; foldl' doesn't participate in fusion so it can increase allocation. So how comes that `foldl'` usually leads to 0 allocation traversal? See this discussion for example: https://www.reddit.com/r/haskell/comments/7ujw4a/usrsbin_selling_laziness/dtn6fn8/
It is simple: your most complex non-static argument should be your last argument since it is easy to use the (.) operator.
[removed]
[removed]
I agree, there's way too much wasted whitespace. On some of the examples the margins in the same direction are bigger than the text itself. There's a balance between good design and practicality.
Nope, `proxy` with a small `p`. It's just a type variable, so you can supply lots of things for a `proxy x`: a `[x]`, `Maybe x`, `Proxy x`, `Free x`, whatever.
Since your question has been answered I will impart an intuition: Think of `hog` as updating the return type (*c*) of a binary function *a -&gt; b -&gt; c* (c -&gt; c') -&gt; (a -&gt; b -&gt; c) -&gt; (a -&gt; b -&gt; c') Similarly `(.)` updates the return type (*b*) of a function *a -&gt; b* (b -&gt; b') -&gt; (a -&gt; b) -&gt; (a -&gt; b')
[removed]
&gt; We're comparing and contrasting two people here I was actually not comparing anyone, since my comment is in the context of /u/LeHaskellUser's comment, and the preceding one. &gt; the other is concerned with how women and minorities are treated at events and advocates for a safer future for all Well, that is not entirely what she did. There was never any danger at the event, and what she is trying to champion is exclusion of people with inappropriate viewpoints, not caring about their actual behaviour at the events. &gt; somehow these two people are being put on even footing--both being equally "wrong." I never implied they were on equal footing. Disagreeing with the way one party holds their discourse, indicates no stance on the other party, and is entirely something you are reading into it. As I say it is not just black and white. &gt; Where did America go wrong when attempting to point out how implicit endorsement of white supremist views, or highly misogynistic views is seen as resorting to petty polarization? It is petty polarisation, when your go-to-reaction is that the people that hold views that you disagree with, should entirely be cut off from society, in one way or the other. What relation does the speakers viewpoints on an entirely unrelated subject have to do with a programming language conference? &gt; The author spends a majority of her article discussing how all of this happened to her at great length. Why is this only a bad thing when it happens to Nazis and Red-pillers? Again, you are saying something that I neither indicated nor said anywhere. It certainly is not good that she had to go through those experiences, in fact no one should. If you follow the context I'm replying to, I'm alluding to the court of public opinion has become increasingly vitriolic. Take for example Matt Taylor that was bashed simply because he "wore a shirt depicting scantily-clad cartoon women with firearms made by his female friend"[0], or Bret Weinstein and the Evergreen scandal, which was ridiculous. Few examples out of many. &gt; I use the term Nazi in my comment here as the last controversial speaker at lambdaconf was literally a white supremist who identified with Nazi views, not as some strawman insult. It's one thing to claim people are being dismissed by a strawman, but that is not the case here. I wonder if that incident is what spurred this response degoes.net/articles/lambdaconf-inclusion. Unfortunately I never saw the original comment at the start of this thread, because it was [removed] when I found the thread, so I think I'm loosing some context here, and my comments are in entirely in response to /u/LeHaskellUser. [0] https://en.wikipedia.org/wiki/Matt_Taylor_(scientist)#Shirt_controversy 
You should add that there's `cabal new-build`.
I am strongly against deriving any JSON representation (the exception being `newtype`s with `-XGeneralizedNewtypeDeriving` where the wrapped type has its own implementation already). Deriving your instances locks down your internal representation or forces you to introduce new data types when you want to handle multiple / changing representations. I firmly believe you should be very conscious about the data you are accepting and producing for other sources. We once had a bug introduced where someone changed a field name which unexpectedly (to the dev) changed the JSON we could accept. You don't want to have to deal with these kinds of problems. The compiler errors should guide you through almost all of your code problems and your tests should cover the rest. It's easy to let something slip through the net when you start deriving your JSON.
&gt; That fact that some people feel unequipped to be in the same room as someone with a dissenting opinion, just shows that they have a lot of growing up to do, if they cannot separate one view from another. People who think some of my friends and family and intrinsically inferior are not just people with "dissenting opinions". Stop normalising racism and sexism.
&gt; It is very unfortunate how the US cannot seem to hold any public discourse without people resorting to black and white polarization Not everyone on the internet is from the US.
&gt; you just mean that it can give you _|_? Yes, that is the worst case. Or the wrong value, which is also very bad. &gt; Basically every piece of library code you ever use can do that. We are talking about *literals*. Isn't it ironic that Haskell, the language that promises to be so much safer by pushing so many kinds of error checking from run time to compile time, is the *only* widely used language where a *literal* can throw a run time exception and crash your program? And this happens in the wild. It has happened to me. It's unacceptable. &gt; who exactly would be verifying the correctness of the value returned? Your static *compile time* code. Any errors are guaranteed to happen at compile time. Whatever value it has is determined completely at compile time. That is the expected behavior of a literal. &gt; I personally would not be willing to use TemplateHaskell just for overloaded literals Why not? It seems like the perfect tool, providing exactly the needed behavior. &gt; I would personally be very much against traverseMaybe and traverseList showing up in the prelude `traverse` is great just as it is. The function `map`
May I suggest you having a look at: Does the Left hate Free Speech? ([Part 1](https://www.youtube.com/watch?v=GGTDhutW_us) and [Part 2](https://www.youtube.com/watch?v=IBUuBd5VRbY)). You're repeating exactly the talking points of Rubin &amp; the like so my answer will have to be the same.
I don't mean necessarily depending on Nix literally, but it would still be a dependency smaller than a host of build artifacts laying around here and there; why implement the same logic twice? But actually, reading on `cabal new-*`, I gather the folks up there went ahead and implemented binary caching that is inspired by, but not dependent upon, Nix's. Concerning your saying: &gt; I don't think you can have Stackage without Hackage -- I don't really get what you mean. Did I unintentionally imply something about abolishing either somewhere in my post?
Right, something like that. Here's the official requirement, from the [Reference Manual](https://docs.python.org/3/reference/datamodel.html#types): &gt; ...the “official” string representation of an object. If at all possible, this should look like a valid Python expression that could be used to recreate an object with the same value (given an appropriate environment). If this is not possible, a string of the form &lt;...some useful description...&gt; should be returned. As opposed to `str`, whose requirement is: &gt; ...the “informal” or nicely printable string representation of an object... This method differs from [`repr`] in that there is no expectation that [`str`] return a valid Python expression: a more convenient or concise representation can be used.
I thought you wanted to replace Hackage with Stackage entirely. Obviously you need the Hackage base to pick the package version for stable LTS Haskell releases.
[removed]
&gt; I assume you mean "people frequently use lists and Maybe in Haskell programs"? No. Because semantically they represent fundamental concepts that are at the core of programming using Haskell's type system.
Oh, right. Didn't remember those articles. 
&gt; By the look of it, not a hard problem. Yet it is a very hard problem, for reasons both practical and fundamental. Several approaches exist to tackle these, including stack's "publish curated lists of fixed package versions" and cabal's "rely on authors to correctly declare package versions and dependency version ranges"; other language communities have made different choices (often sacrificing correctness), but they're all facing the same problems. And none of the solutions is perfect; it's a matter of priorities. &gt; There are so many extremely smart people around Haskell -- it must be that they don't see the need to address the problem as a problem and crack it once and for all? Again, it's a hard problem, and the Haskell community is famous for being full of brilliant but stubborn people - after all, the insistence of doing things correctly is what lured most of us in, so unlike, say, JavaScript, we're hesitant to roll with a "solution" that we know is incorrect but gives us somewhat usable results fast. You are, of course, very much invited to write a perfect `solve` function.
Thanks! Much appreciated!
Ultimately it's up to oneself to look up and understand the extensions. I don't mind them. They extend haskell in very nice ways.
It didn't in 2008. Perhaps things have changed in the past 10 years. In any case, if you provide a patch to GHC that solves the orphan instance problem using `.hi` files, I think everyone would be thrilled. To me, the solution that feels right is an extension that enables explicit import and export of instances. That would also involve `.hi` files of course.
From a reductionist point of view, blocking IO is a concern in single-threaded languages (like nodejs), since Haskell is a multithreaded language, only the thread that is waiting for the thread blocks, but all other thread are free to keep doing what they need. This means that a webserver can still serve more requests as other requests (threads) are waiting for IO to finish.
that's very interesting, thanks.
&gt; I think that the newtype wrapper (providing a `Monoid` instance for `Applicative type constructors) would be a good thing to have in base regardless. Like [`Alt`](https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Monoid.html#t:Alt)? newtype Alt f a = Alt (f a) instance Monoid (Alt f a) where mempty :: Alt f a mempty = Alt empty mappend :: Alt f a -&gt; Alt f a -&gt; Alt f a mappend = coerce ((&lt;|&gt;) @f @a)
&gt; Also, can we please build everything with -fPIC so we can link together all-inclusive shared libraries? Seconded. I'm not sure why this isn't the default, but IMO it should be.
Oh, turns out I was out of date on the current [foldl' definition](https://hackage.haskell.org/package/base-4.10.1.0/docs/src/Data.Foldable.html#foldl%27): foldl' :: (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b foldl' f z0 xs = foldr f' id xs z0 where f' x k z = k $! f z x At first I got really confused because I couldn't figure out how the higher order functions would get optimized away. Turns out a super cool new optimization called [call arity analysis](https://www.joachim-breitner.de/publications/CallArity-TFP.pdf) was added in 2014 to enable this. Not sure why `sum` is defined via `foldl` instead of `foldl'`. It has been that way since [quite a while](https://github.com/ghc/ghc/commit/7822166732d75185195fe479b95beb84763225b1#diff-668db0ec7c3cbf63562c8639df523af6L1021). But I don't think this will matter unless you have a Num implementation that ignores its first argument?
Nice! I was already planning on trying out Semantic-UI for my reflex-dom UI and this library looks nicely structured. It has a `SetValue` type defined like this: data SetValue' t a b = SetValue { _initial :: a , _event :: Maybe (Event t b) } I have something similar in my reflex-dom code: data External t a = External (Maybe a) (Event t a) The initial value is optional so widgets that have a "native" initial value can provide it without the client of the code needing to provide one. The event is non-optional as one can always use `never`.
I feel your pain! I spent a week building a dynamic lib in Haskell (as in, I spent a week simply getting it to build, lol). So much pain for something that should pretty straightforward.
Haskell isn't necessarily multi-threaded though, right? It can be run in single-threaded or multi-threaded mode and concurrency is provided by green threads managed by GHC. I'm sure you know that green threads are designed to avoid expensive context switching that goes with real OS threads, but you lose at least some of that benefit if you need to use real OS threads for blocking file IO. Just working my way through the [links](https://www.reddit.com/r/haskell/comments/7vdx0k/how_does_ghc_handling_blocking_file_operations/dtski1b/) provided by /u/adamgundry but it seems that GHC uses a pool of real OS threads to simulate non-blocking IO in an at least approximately similar way to Node (libuv). It's not immediately obvious which might be the most efficient or what the differences are.
Your proposed code snippet doesn't look straightforward to me. What do you suppose `runMod` will do? It can't apply `(flip mod 17)` in the `&gt;&gt;=` operation, because you can't require a Num constraint for monadic values. It has to be legal to write `x &lt;- return "hello"` too, and of course you can't reduce `"hello"` mod 17! Trying to do modulus operations on any value that we bind seems like it would require breaking some monad laws, as well.
I was directly comparing it to Node, in that you would usually write a http server with it. In the case of existing haskell http servers, all requests are handled in a separate green-thread, so no IO would block other requests. You can of course write an IO blocking CLI script, if you will, but in most cases that is exactly what you want. As for what is more efficient... I don't know. I can only attest for Haskell's amazing ability of opening ten of thousands concurrent network connections in a non-blocking way. You should also check out the 'async' package, it is the go-to library for concurrent operations inside IO.
Explicit instance imports that breaks global coherence?
So I think what the slides are saying is rather than modeling consumer-driven contracts as a list of cases, we should model them as a state machine which can then be used to verify the backend / provide mocks for the frontend, allowing both to be developed in parallel. Yes? I'm not sure, but from [a brief look at their example code](https://github.com/aleryo/homomorphic-event-sourcing/blob/b05c08cd1a2f733a8b311992795acb738b73c4ee/sources/pet-store-v1/src/PetStore/Model.hs#L39), it seems like the key to translating a state machine to both use cases is [the `IOAutomation` class](https://github.com/abailly/ioautomata/blob/b247044d11dcbeb58deddf5b966c4d56736e84b2/src/IOAutomaton/IOAutomaton.hs#L20) from one of the author's (as yet unreleased) [`ioautomata` package](https://github.com/abailly/ioautomata#readme).
Works!
It's easier if you think of it as `fmap . fmap` for the `(-&gt;)` Functor. `fmap` allows you to change the `a` in an `f a`, and `fmap . fmap` allows you to change the `a` in an `f (g a)`. That's because the rightmost `fmap` turns an `a -&gt; b` into a `g a -&gt; g b`, and then the leftmost `fmap` turns that `g a -&gt; g b` into an `f (g a) -&gt; f (g b)`. Instantiating `f` with `(r1 -&gt;)` and `g` with `(r2 -&gt;)`, we get that `fmap . fmap` lifts an `a -&gt; b` to an `(r1 -&gt; r2 -&gt; a) -&gt; r1 -&gt; r2 -&gt; b`. That is, `fmap . fmap` has type `(a -&gt; b) -&gt; (r1 -&gt; r2 -&gt; a) -&gt; r1 -&gt; r2 -&gt; b`.
I make Windows releases of my enduser-facing Haskell software ([arbtt](http://arbtt.nomeata.de/), [tttool](http://tttool.entropia.de/), [bSpokeLight](https://github.com/nomeata/bSpokeLight)) using some shaky WINE setup. Do you think that eventually I can just crosscompile to Windows?
&gt; Stop normalising racism and sexism. Or you could reread my post. What I'm arguing is, that if the goal is to reduce racism and sexism, then the current way people are going about it, is not going to solve anything. My comment goes beyond just this simple conference, and is a commentary on the way that (mainly) the US is currently having their discourse in the current political climate.
If you have feedback, please leave it on the proposal, not on Reddit.
If you get rid of subtraction, then the laws I would expect are: 0 + x = x x + 0 = x (x + y) + z = x + (y + z) 1 * x x * 1 (x * y) * z = x * (y * z) 0 * x = 0 x * 0 = 0 x * (y + z) = (x * y) + (x * z) (y + z) * x = (y * x) + (z * x)
I would say that it has loose moral laws, given that it's a class with lose morals, created to serve convenience rather than theory ;) It is a bit of an unfortunate type class though. That being said, I'm not sure I'd want to go the Purescript route without some better way of being able to group together and talk about extremely fine-grained type classes than we have right now.
Treat an imported instance as imported data, like any other. It will then be kept consistent across dependencies and versions the same way that any other imported data and types are kept consistent.
That is so cool! I had never realized that.
I'm not questioning the right to choose to attend or to talk about it. I'm questioning the approach the link's author took to challenge the organisers when she didn't agree with a speaker there. 
It doesn't seem to be a particularly natural construction to me. Even if deriving a monoid for `f a` from a monoid a and an `Applicative` f is a natural construction this isn't doing that. It's doing it for one privileged `Applicative` that happens to be `IO`. I don't see why we'd have this instance and not one for `Writer`, `Reader`, `State`, etc. etc..
Sounds like the "Market" has supplied the variations required, that cover inclusiveness or not. 
Can you cross your eyes, as if to stare at your own nose? When you do, do you see double images (one from each eye)? This is like that, except you're "uncrossing" your eyes; relaxing them to look further away than the actual screen. The idea is to get one of your eyes looking at one spot, the other eye looking at the spot next to it, and convince the perception level of your brain that they are looking at the same point. If you can do that, your brain does triangulation to find the distance to the point, and you see points behind the screen. There are some tricks people recommend to get started. For instance, move your face very close enough to the screen that you can't focus directly on the screen itself, then slowly back off. Personally, I've always found this to be easy. But then, I remember spending hours as a child staring at spots on walls crossing and uncrossing my eyes just to see the double images, so I might have developed an unusual amount of conscious control of my eye movements...
You are seriously suggesting that Ed Latimore go to a functional programming conference in order to confess his alleged sins and beg the public for forgiveness? I think you are confusing functional programming conferences with churches. Churches are places you go to in order to confess your sins and beg forgiveness. Functional programming conferences are places you go to in order to advance your career. If you're looking for a church, you won't find it at LambdaConf.
I think there should be matching instances for all of those other `Applicative`s, too Think of it this way: your line of reasoning would imply that we shouldn't provide `MonadState` instances for `WriterT`/`ReaderT`/... because there exists a general `MonadState` instance that we could write for anything that implements `MonadTrans`
&gt; I think there should be matching instances for all of those other Applicatives, too And how about `[a]`? &gt; because there exists a general MonadState instance that we could write for anything that implements MonadTrans Does there? That's rather surprising to me! 
Refactoring "we" sounds hard.
Not at all, it's a complete fabrication. Yarvin was _not_ invited (despite how many times this false claim is repeated), but rather, his proposal was chosen by the blind-committee based purely on technical merit. I was _not_ part of the blind committee. I did personally invite Latimore after personally being inspired by some of his mindset tweets (on personal responsibility, gratitude, and discipline) and learning how he changed his life around. I was not aware of his views on gender differences or mens rights issues. Despite having large public scrutiny for months, no one questioned or had any issue with our speaker lineup (nor did they raise any concerns, in public or private), and if it hadn't been for a _single_ member of the Drupal community, there would have been no incident at LambdaConf 2017. In other words, the fact that this happened at all is a fluke.
&gt; In 2017, it's pretty clear that LambdaConf explicitly looked for another speaker that would provoke controversy, and is trying to trade on their wink-wink approach to racism and sexism to attract a certain crowd. This is completely false—it's a character smear, and it's clearly libelous. I request the moderators remove this post.
That doesn't respond to my complaint /claim. 
I believe that people who cannot engage in professional discourse, but instead rely on libelous accusations and gratuitous insults, should not be permitted to participate in this thread. This is not 4Chan here. It's a professional forum for the advancement of functional programming in Haskell, and we should all act like professionals and treat each other well. That's just my 2 cents.
I updated the question, I am not satisfied with the function `updateArticleBySlug` and I think it can be written in a better way.
Consider this: for_ :: (Foldable t, Applicative f) =&gt; t a -&gt; (a -&gt; f b) -&gt; f () SPECIALIZES TO for_ :: Maybe String -&gt; (String -&gt; m Int) -&gt; m () So try this: unsafeUpdateArticleBySlug :: (MonadIO m,MonadReader r m,IConnection r) =&gt; T.Slug -&gt; T.UpdateArticle -&gt; m () unsafeUpdateArticleBySlug slug article = do conn &lt;- ask for_ (T.updateArticleTitle article) $ \title -&gt; liftIO $ S.updateArticleTitle slug title conn for_ (T.updateArticleTitle article) $ \body -&gt; liftIO $ S.updateArticleBody slug body conn liftIO $ commit conn return () 
I think you're right that it wasn't worded as precisely as I intended. I've edited the comment to make it clear that I'm drawing the obvious conclusions from the facts, rather than claiming any unique insight into the conference organizers.
Hoogle is also really handy for finding utility functions: https://www.haskell.org/hoogle/?hoogle=Monad+m+%3D%3E+Maybe+a+-%3E+%28a+-%3E+m+%28%29%29+-%3E+m+%28%29 Sadly there are both www.haskell.org/hoogle (better type search) and www.hoogle.haskell.org (all packages on stackage but occasionally misses things)
I think the exact problem is mentioned in the monad introduction in real world haskell book. You need to understand the bind operator for Monads. http://book.realworldhaskell.org/read/monads.html
Why don't move CLC proposals discussion to Github like GHC proposals?
But that allows you to violate global instance coherence?
Maybe start with something simple like [Reading Simple Haskell](https://soupi.github.io/rfc/reading_simple_haskell/) and then jump to the Intermediate Haskell section in the [Haskell wikibook](https://en.wikibooks.org/wiki/Haskell)? I'm guessing OCaml is pretty similar to Haskell in many ways, but he'd still need to tackle lazy evaluation, kinds, typeclasses, IO, etc. 
The only reason I separated the types is for cases like the dimmer module: The initial value must be either one of `In` or `Out`, but there can be a set value event which specifies `Just` a direction or is `Nothing` (causing a toggle). So for dimmers we have the type `SetValue' Direction (Maybe Direction)`. I could probably skip this case entirely and simplify the type though. Really this is something I didn't give too much thought to. `event` being a `Maybe` is purely an in the moment premature optimisation :) 
I've derived this before and started to answer this question and realized that I couldn't, i.e. not off the top of my head. So I wrote a [gist called (Compose) Compose (Compose)](https://gist.github.com/cscalfani/40b63c1933ad9f5719a199ff9571e857) so I won't have to derive it again. My approach, unlike many here, was to start only with the `(.)` function and **only work with types**. The other answers all start with the knowledge of the final signature. But most of the time you don't know the final type of something. Imagine you just asked "What is the type signature of `(.) . (.)`"
Yes! Can you belive that someone guilty of such thought-crimes could ever be allowed to speak at a conference? Unacceptable.
Do you have any idea how to get a square n-cube of a given dimension? So like Matrix 4 4 Double would be NCube 2 4 Double? Or, possibly even more generally, how to have an n-dimensional list as the levels, so Matrix 4 5 Doule = NCube [4, 5] Double?
Writing and CQRS/ES backend, experimenting with eventful, websockets, and graphql.
incoming requests (at least in node) are handled totally asynchronously. some other forms of IO, notably file IO and outgoing http requests are blocking but use a libuv thread pool to emulate non-blocking calls. just reading through the papers referenced in the link that was posted, it seems that GHC does something similar. For some reason that I only have a fuzzy understanding of, it seems that OS file IO functions are inherently blocking and using a thread pool seems to be the way around this. I wondered if maybe GHC had it's own non-blocking IO primitives. definitely worth a read of those papers. your understanding seems similar to mine before I started pulling at this particular thread (pun intended).
For a second there I thought this was /r/MechanicalKeyboards What column staggered split hand board is that? Reminds me of a Dactyl, but with a different kind of construction.
The use of `Monad` (or `Applicative`) is pretty slick. But I'm also fond of the more explicit idiom of just using the `maybe` function. This is more "universal" in the sense that it works to replace any-old pattern matching, not just one that results in monadic actions... maybe :: b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b So you can write, e.g. `liftIO . maybe (return 1) (\t -&gt; S.updateArticleTitle slug t conn) . T.updateArticleTitle $ article`
Well you won't know if it gives you the "wrong" value seeing as you won't see that value until the code actually runs. You will only know if it gives you `_|_`. Like if `5` became `Seven` how would you ever know until it's too late (runtime), without inspecting the outputted `core`. Do you get what I mean? The "best" you could do is force all literals to `NF` during compilation. But even that isn't always going to be desirable some of the time, say for example a lazy arbitrary precision binary value where the literal will generate an infinite sequence (`0.2 = 0.00110011...`). So maybe just `WHNF`. And the reason why not TH is because TH is a really big hammer and is not itself type safe, now the code it generates is type checked, but not really the TH itself. We should be striving to move things from TH to more elegant and reasonable alternatives, not the other way round. Also there isn't any way to know in advance that every literal will end up type checking, you could perhaps make a type where `7 :: Foo` works but `8 :: Foo` generates code that doesn't type check but in an obscure and hard to debug way. Whereas with my way you know that if the `instance` declaration compiles then all the values that satisfy the constraint will type check just fine. I don't get what you mean with the `traverse` stuff, the only "mistake" Haskell made was having `map` not just be `fmap` and removing `fmap` altogether. 
No it's construction. Now, I fix that. Thanks!
Does anyone know where to find the change log?
Github would at least be an improvement. The argument that we shouldn't trust github seems a little like a tin foil hat to me, since we can always migrate everything off of it. I think it'd be better to move to github than sit on mailing lists forever, waiting for someone to bring an alternative to the table
A system where you cross your eyes is easier.
[removed]
First off, I'm not sure how deep your question goes: For example, I might do: ``` data UpdateArticle = UpdateTitle String | UpdateBody String | UpdateTitleAndBody String String ``` And then update could be: updateArticleBySlug slug article = do conn &lt;- ask liftIO $ do case article of UpdateTitle title -&gt; S.updateArticleTitle slug title conn UpdateBody body -&gt; S.updateArticleBody slug body conn UpdateTitleAndBody title body -&gt; do S.updateArticleTitle slug title conn S.updateArticleBody slug body conn commit conn return () ``` (I moved `liftIO` up since by the time I was done, everything had a call to `lifIO` in it) I left the `return ()` in place for similarity, but really you should use the `void` method and write: ``` void $ liftIO $ do ``` above
It's an expression; I'm not sure what a construction is
There's certainly a lot of work going on in Haskell -- us, Stephen Diehl's company, IOHK, Blockapps. I've always thought one way Haskell can win as an app lang is to provide something like a blockchain or really any kind of platform service, where users don't have to know the app is in haskell, but just enjoy the superior stability and excellent performance. We've certainly been able to outpace our competitors just in sheer shippitude by the productivity and maintainability offered by it.
Seems there isn't alpha3 tag on github, but there're all commits in `ghc-8.4` branch since `ghc-8.4.1-alpha2`: https://github.com/ghc/ghc/compare/33e3b3eb55cb6cfa4abc7f57581066779a046626...ghc-8.4
Both!
Ok, I just fix this now. But I think it like a synonyms.
Lately I've successfully rewrote the backend and the frontend of [my app] in Haskell. The frontend uses [Reflex](http://docs.reflex-frp.org/en/latest/). Currently I intend to resurrect my [hierarchical diary](https://github.com/srid/chronicle) idea, reimplement it in Haskell (from Elm), and create mobile apps using Reflex.
The second problem is the bit I don't understand. If you have Package X needing `Package A 1.2.3`, And Package Y needing `Package A 1.2.4`, can one not grab both `Package A` versions and build dependencies in isolation, linking them to the final result as necessary? Which part of this equation needs Package's X and Y to be harmonious in their version of Package A? Can't you just consider `Function A 1.2.3` to be inherently different from `Function A 1.2.4` ?
I don't understand your question. Suppose you want to do a multi player game using `gloss`. Each of your player have a `playIO` function. Any communication with other players can be done in any of the display, input, step `IO` function.
It wasn't really a question (besides asking how cool it would be). I was just proposing the idea.
Aha! Well, you see, you *could* do that, but GHC doesn't currently support this. But even if it did, it might not be very desirable thing, because 1) packages routinely re-export things, and if those things are versioned too, you'll just move the incompatibility up the chain; and 2) it could easily lead to a lot of duplicate code being linked into the end result. For example, a lot of libraries out there depend on `text`, and many of them expose functions that involve the `Text` type. So if you have, say, package `foo` that has a function `generateFooText :: IO Text`, and a package `bar` that has a function `barifyText :: Text -&gt; Text`, and they both depend on different versions of `text`, then the `Text` types in those signatures would no longer be the same types, and something perfectly reasonable like, say, `barifyText &lt;$&gt; generateFooText` would no longer typecheck. And you would also have two full copies of the `text` library in your project, for no good reason, and every additional dependency that also needs `text` is likely to add another copy to that. So then you end up with an insanely bloated binary that has 16 slightly different versions of `text` linked into it, and it doesn't even solve the problem, because you also have 16 incompatible `Text` types in your codebase, rather than a single one being used everywhere. It kind of works in languages like JavaScript, because there are no type checks there, everything is essentially duck-typed; but in Haskell, that won't work, we need exact type information from our dependencies, and we need them to check out exactly.
I still don't understand the idea, sorry ;) What should be represented by the `Player` type ?
I believe the idea is that there is a *shared* state, not one state per player. The events from all users collectively act on that shared state. Joachim Breitner did pretty much exactly this with CodeWorld, which is essentially a fork of Gloss ported to GHCJS and HTML Canvas drawing.
Thanks, calling out the types specifically made this much easier to internalize. Having multiple versions of `Text.justifyLeft` seems like it wouldn't be an impossible problem to solve, having multiple versions of `Text.Text` seems like a fairly intractable issue.
Cool! For those wondering what the equivalent of the `playIO` function in CodeWorld, its [`collaborationOf`](https://hackage.haskell.org/package/codeworld-api-0.2.1.0/docs/CodeWorld.html#v:collaborationOf), which is almost the same type as what I put in the post. (They use `Int` as the `Player` type.)
Wow! I started down this path at one point and realized it was going to be a ton of work. But I'm really glad some has started the initiative!
If you can't find things like that on Hackage's hoogle, Stackage usually comes up with more results! https://www.stackage.org/lts-10.4/hoogle?q=lookupstaticptr
If mods are removing posts for those reasons then [this one] would be a strong candidate. Unless there is some proof of intent that goes along with &gt; Unfortunately, Sonia's account is filled with intentional inaccuracies then I think that can be read as being just as much a character smear / libellous statement as the quote you had problems with. 
It is not easy to migrate off github once on. You can extract the data -- thanks to https://github-backup.branchable.com/ (in haskell even!). However, to then put that data in a meaningful way into a self-hosted system is not really standardized (though of course it can be hacked up).
Yes, that's true. CodeWorld is intended for teaching younger students. While I'm happy for it to be useful to others as well, that always comes with a caveat - as long as it doesn't get more complex for the children for whom it's mainly intended. You could port the networked game logic over to Gloss, as well. Because there is no central Gloss server, you'd need to do something more clever for establishing connections. Most importantly, though, the `IO` in your proposed types is probably disqualifying. It's of foundational importance that all functions need to be pure functions. Otherwise, you'll end up contending with desync bugs until your eyes fall out. In fact, the notion of purity needed is a very strong one. It must guarantee the same function gives the same answer even across operating systems, different installed library versions, etc. In CodeWorld, we (either do, or should and there's an open bug for it; I don't recall) monkey-patch many of the floating point math functions at the JavaScript layer, to ensure that they are completely deterministic, for example. This is harder to do for general-purpose Haskell.
LYAH is showing its age. The constructor `Writer` no longer exists in `mtl`, as the `Writer w` type has become a synonym for `WriterT w Identity`.
I think he actually referred to [distributed closure](https://hackage.haskell.org/package/distributed-closure). 
I'd be hesitant; networking is pretty hard to do right. You'd need some way to differentiate which parts of `world` are critical to synchronize (player locations, global variables), and which aren't (locations of bullet holes, where player X is in an animation). Unless you have some machinery for keeping every game in step, desyncs are going to happen and everybody will start seeing different versions of what's happening in game. Shawn Hargreaves (the XNA guy) [posted a lot of great resources on dealing with networking](http://www.shawnhargreaves.com/blogindex.html#networking), if you're interested.
&gt; Most importantly, though, the IO in your proposed types is probably disqualifying. Oh yeah, forgot about that. You'd probably want a way to have clients broadcast custom program-controlled events then, so you could interact with the outside world.
Perhaps only the server would update `world`, and it would transmit `Picture` to the clients (which they would then render as actual graphics).
I should say that I found it easier to pause the animation (hover in the lower left to see the pause button), then “focus”, and then run the animation.
[Clash](http://clash-lang.org) is what you are after. Somebody is already toying with a Risc-V implementation IIRC.
There is an old thread here: https://deskthority.net/workshop-f7/designing-a-custom-topre-board-t11734.html
Video linked by /u/AshleyYakeley: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [Edward Latimore - The Hidden Costs of Fear and How to Get a Better Deal - λC 2017](https://youtube.com/watch?v=17rgUgdZHgg)|LambdaConf|2017-10-12|0:27:44|15+ (83%)|378 &gt; Description: I want to speak about fear. The way fear... --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/AshleyYakeley ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=dtuizlv\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v2.0.0
&gt; Infamous drupal community? Probably a reference to [this](https://www.theregister.co.uk/2017/04/13/drupal_gor_protest/).
&gt; Yarvin was not invited (despite how many times this false claim is repeated), but rather, his proposal was chosen by the blind-committee based purely on technical merit. I, and presumably many other people, would consider this (at least colloquially) an invitation to speak at the event. &gt; Despite having large public scrutiny for months, no one questioned or had any issue with our speaker lineup Even if there was no scrutiny beforehand, do you acknowledge that there is legitimate reason to be concerned that someone who espouses misogynistic views to a large twitter audience gave a keynote speech? And if people are concerned, why does when they brought it up matter?
For a slow network, the lag is awful in this model. It's probably fine if you're connecting over a local network, but a few hundred milliseconds of latency makes a huge difference when you're delaying even animation effects and mouseovers. That's a big part of why CodeWorld ended up as a 100% client-side model. In a more real-world setting, you probably want to separate the game into two layers. The shared game state is only acted on by abstract game moves. The local UI state is acted upon by the raw physical UI events like key presses and mouse clicks. These raw events can only directly affect the local state, but can generate a game move when the user does something that affects the shared state. Then you run the local state on the client, but the shared game state can either be server side (if the shared game state is serializable so the current state can be sent to clients), or client-side (if the game move is serializable, so it can be broadcast to other clients). In cases where cheating is a serious concern, you may need to get even more complex. For instance, only send clients abridged versions of the game state, and validate on the server that their game moves are reasonable. It's still appealing to model this as one program, which is executed simultaneously in different modes on the clients and the server. But the programmer model is far more complex. That's why it wasn't done that way for my students!
This is exactly what Reflex needs. It's kinda slow to switch between examples though, especially on Firefox, but still noticeable on Chrome... is this expected?
Mathematicaly that is tensor. A more general representation is `Tensor [4, -5] Double`, where positives for covariant and negative for contravariant.
Just today, I found myself in a situation where I really wanted instance resolution to depend on the constraints.. Is there any reason this wouldn't be possible? In my case, I had something like instance (Foo a, Bar a) =&gt; Baz a where .. instance (Foo a, Bar a, Qux a) =&gt; Baz a where .. In this case, I'd like it to pick the latter if `a` satisfies all of the constraints, otherwise pick the first(given that it satisfies `Foo` and `Bar`). Is there perhaps some other way to achieve this behavior? `OVERLAPPABLE`/`OVERLAPS` didn't seem to do it.
Good points. Thanks for the explanation. 
Maybe -- but then you're going to have a best-case latency of two frames between doing something and seeing it happen; more typical would be closer to ten, which is definitely slow enough that a human can experience it. I'm not saying getting automatically networked games is a bad idea, merely that it's a harder one than just changing some type signatures (unfortunately!).
Thank you sir.
For cloning follow: https://ghc.haskell.org/trac/ghc/wiki/Building/GettingTheSources For patch submission, try the following walkthrough: https://medium.com/@zw3rk/contributing-to-ghc-290653b63147 In general, you want to clone from ghc.haskell.org and neither from phabricators copy nor from GitHub. 
As a lurker I'm loving this thread so here are my upvotes. Isn't this what semver is supposed to solve? Function A 1.2.3 and Function A 1.2.4 are supposed to be different functions (because bugfix), but they have the same type (because API is not changed). (Exposed) Types between 1.2.4 and 1.2.3 should also be the same. Am I completely misguided?
I use cabal to build my projects and Nix to pin my dependencies deterministically. With those two tools, stack is nothing more than a different command line interface for cabal aka worthless to me. I've always wondered: Why not have each Stackage snapshot be defined in Nix and then have stack be a wrapper around cabal + Nix (maybe auto-generated some Nix stuff w/stack.yaml overrides). I'm guessing it's 1) politics and 2) the cost of migrating to that. Because technically, stack doesn't really do anything that cabal + Nix don't do. It's all social crap.
They're still not the same type though - even with semver or PVP, you cannot guarantee that their internal representations are the same, so calling the wrong functions on them may still lead to bugs / crashes. PVP only guarantees compatible public APIs.
The word "construction" is far more general than "expression". Perhaps thats why you find them synonymous, even though they are not. Of course, since we're in the context of Haskell, it's more appropriate to employ the term "expression", than the more abstract term.
It's weird because it looks like [most of the work is actually already done](https://phabricator.haskell.org/D4353) but... ah, I don't know if there's actually a real GHC proposal out there for this yet or if there's really anything official about it. It also hasn't been given a milestone of any sort as well. So I'd be surprised if it made it in 8.4, but considering it's a fairly small patch, pretty useful, and unlikely to go horribly wrong... who knows? ¯\_(ツ)_/¯
You dropped this \ *** ^^To ^^prevent ^^any ^^more ^^lost ^^limbs ^^throughout ^^Reddit, ^^correctly ^^escape ^^the ^^arms ^^and ^^shoulders ^^by ^^typing ^^the ^^shrug ^^as ^^`¯\\\_(ツ)_/¯`
Polishing of the Android variant of [gonimo](https://gonimo.com). We are making really good process, expect an Android app very soon! :-)
Yeah, thank you for your describe! I fixed that yesterday. Maybe, if you interesting this repository and you have some time - you can help me:)
Ahh ok, so in this case it WAS actually LYAH eing slightly off. I will look into that, and play around with it tonight. Thanx for the reply!
This is an established term that they themselves use to describe their outlook. It is not a slur.
`lookupStaticPtr`, actually `unsafeLookupStaticPtr`, is in the [GHC base libraries](https://hackage.haskell.org/package/base-4.10.1.0/docs/GHC-StaticPtr.html). Variations on closure are currently provided in two alternative packages, [distributed-static](https://hackage.haskell.org/package/distributed-static), used in Cloud Haskell, and [distributed-closure](https://hackage.haskell.org/package/distributed-closure), used in the [Haskell Spark bindings](https://github.com/tweag/sparkle). It's somewhat unfortunate that there are two alternatives out there, and the goal is to unify them eventually, but that thunk just hasn't been forced yet :) Incidentally, I have a SkillsMatter talk [Static Pointers, Closures and Polymorphism ](https://skillsmatter.com/skillscasts/10632-static-pointers-closures-and-polymorphism), presented at the most recent Haskell Exchange, where I discuss these types and their motivation in a lot of detail.
Perhaps I'm missing something peculiar to the GHC repo, but generally it's easiest to run a single 'git clone --recursive' on the top level repo and let git do the hard work.
:thinking: oh, I see, you are saying that version 1.1 can export type T with constructor T1, and version 1.2 can add, but not export, a constructor T2. Now T has not changed the public API but the internal representation has changed (the ABI if you want). Is that correct?
Well, one problem to making stack be just cabal + Nix would be Windows support. As far as I am aware, Nix doesn't work on Windows and without Windows support Haskell will become much less practical.
Would be good if we can somehow integrate your plan with our Haskell course: * https://github.com/jagajaga/FP-Course-ITMO
&gt; Given how easy it is to find Ed's personal views, this suggests to me that either a) John didn't do much research at all into Ed, or b) John felt that overlooking the misogyny was worth it given Ed's other qualities (success story re rising out of poverty, person of color). "And John goes, 'Hey man, I really like your stuff, I like your blog, I like your Twitter, I like a lot of things you're doing".](https://youtu.be/17rgUgdZHgg?t=3m40s) So the answer is clearly B. 
Yes, I get it now, thanks for spelling it out for me. The thing is that I always thought in terms of api compatibility but it’s really an ABI problem (But harder because we got types). 
More fundamental problem: how do you resolve instances of `Package A 1.2.3` with instances of `Package A 1.2.4`? Ideally, they are identical, but suppose they aren't?
Thanks. That did the trick. I'll update the Phab guide to mention this.
I really like this use of `for`/`for_` for `Maybe`—after all, it’s just a loop over the elements of a `Traversable`, of which there happen to be only 0 or 1 in the case of `Maybe`—but somehow I often forget to use it. :P Haven’t checked but I think you can factor out the `liftIO` as well, as in [psycotica0’s comment](https://www.reddit.com/r/haskell/comments/7vogmf/function_with_maybe_is_a_bit_verbose/dtu62b3/): liftIO $ do for_ (T.updateArticleTitle article) $ \ title -&gt; … for_ (T.updateArticleBody article) $ \ body -&gt; … commit conn And this can be made point-free by changing the order of arguments to `updateArticleTitle` &amp; `updateArticleBody`: \title -&gt; S.updateArticleTitle slug title conn ⇓ \title -&gt; S.updateArticleTitle slug conn title ⇓ S.updateArticleTitle slug conn 
It occurred to me that you can also do it with FunctionalDependencies and the code is a but simpler. {-# LANGUAGE FunctionalDependencies, FlexibleInstances #-} data Foo a = Foo [a] deriving Show class Update a b c | a b -&gt; c where update :: a -&gt; Foo b -&gt; Foo c instance Update [a] a a where update as (Foo fs) = Foo $ as ++ fs instance Update a a a where update a (Foo fs) = Foo $ a : fs
The style is overall very good and readable. :) No warnings from GHC or `hlint`, first of all. (If you’re not using `hlint` already, that’s a good thing to have in your workflow.) In terms of project organisation, the standard way of doing things is to create a (non-empty!) `.cabal` file (e.g. `Huffer.cabal`) so you and people who use your code can build with Cabal or Stack; this makes it easy to add tests, too—in general I’d recommend `hspec` in conjunction with `HUnit` and `QuickCheck`. This is a great opportunity to use `QuickCheck` to test properties like `decode (encode x) == x` on many randomly-generated inputs, also a reason to prefer pure functions. Stylistically, when there are many case in a function, equational style like: execute ("encode":args) = … execute ("decode":args) = … … Gets to be kinda repetitious, especially when you have multiple arguments, so this is a good time to switch a `case` expression: execute args = case args of "encode":rest -&gt; … "decode":rest -&gt; … … Or lambda-case: execute = \case "encode":rest -&gt; … … (With the `LambdaCase` extension.) In the future, if you need something more flexible for argument parsing, I’d recommend `optparse-applicative`. You could split some `IO` and non-`IO` functions more if you want to make the pure bits more testable in isolation. For example, the `getFileSize` and `readFile` calls in `generateInfo` could be moved to a wrapper function. You read each input file twice during compression: once to build the frequencies and once to compress it. I guess that makes sense for a compression tool where you can’t necessarily retain the whole input in memory, I just noticed it in passing. All in all, good work. :)
I would be surprised to see it in 8.4. There's a [proposal](https://github.com/ghc-proposals/ghc-proposals/pull/109), but it needs committee approval. The [new release schedule](https://ghc.haskell.org/trac/ghc/wiki/WorkingConventions/Releases/NewSchedule) seems to indicate that new functionality can be added up until release candidate 1, so maybe it could make it in time.
Good job of using your knowledge of Haskell to make something useful! My main suggestion is to use the cabal-install tool or stack to do builds rather than invoking ghc yourself. Doing that will allow you to share and reproduce the builds more easily. My other suggestion is libraries to make use of. I would recommend optparse-applicative for command-line argument processing. It makes handling command-line arguments a lot easier. I'd also recommend avoiding String where possible. I see that you have used ByteString already, and another type you should check out is Text. I also see that you have `HuffTree` defined in both Decoder.hs and Encoder.hs. For things like that I'd recommend organizing a shared type into one file imported by both of those. You can then import it where needed. The less you repeat yourself the better. Some of the others may have other suggestions, but those stood out to me right away.
I don't really think that's more fundamental, really. For any given combination of type and typeclass, there can only be zero or one instances at a time, so either we can figure out how to unify types between versions, in which case we should be able to do the same for instances, or we can't, in which case instances are "not a problem" in the sense that they refer to different types. It's kind of the same problem, but from a different angle.
I am happy you found the code readable, I think Haskell syntax gives a big help in this. I already configured atom to use hlint, I really like it and it's very useful. I am surely going to read about project building with cabal or stack, because to be honest I know nothing about it :) (the .cabal empty file is there because atom's Haskell plugins couldn't recognize the import of the modules without it; I will fix this as well). The use of the case expression is so obviously better that I am going to adopt that right away, and I will review those IO functions to split them. I will also check out optparse-applicative in the near future, but this time around I purposefully avoided any non-standard library to get my hands as dirty as possible, hoping that this would make me learn more, as it did when I learned other languages. Thank you very much for your suggestions and also for spending the time to review the source code!
I will go and look into the building process, I just called ghc and since it was working I didn't really thought about it :) As I said into another comment I will also look into optparse-applicative, but in making this I avoided exploring libraries in an attempt to learn more. I have two HuffTree defined because there is a little difference in them: the Encoder one has an Int value that keeps track of a word frequency (it needs it to build the tree, which is why also internal Nodes have it) but the Decoder one doesn't, because it has no use for it. Is this generally a good practice or not? Anyway you made me notice I also have defined FileEntry twice, and the difference between them has no use, so I will use your suggestion on that. Thank you for your comment!
I would recommend just using stack for getting started with ghcjs. As described here - https://docs.haskellstack.org/en/stable/ghcjs/.
`QuantifiedContexts` will very likely be in 8.6.
Thanks for updating the documentation!
Well one thing that stack does better than nix is work without trying to take over my whole system.
Happy isn't designed to generate human-readable Haskell. It's designed to generate parsers. Similarly, GHC isn't designed to generate human-readable assembly code; it's designed to generate machine-runnable programs.
Yes, it's been replaced with a `writer` function. The same will happen with `State`
Ah that's a good point. Hopefully Nix on Windows improves in the future. I haven't needed to distribute my stuff on Windows, but I suppose if I did that would be a pain and I would probably have to maintain a parallel build system.
Haven't tried it, but Nix ought to work fine on WSL. Now that WSL is out of beta and can be enabled on vanilla Windows 10, that might very well be the direction of things.
I'm worried about debugging this mess of machine-runnable Haskell. With megaparsec I can do the usual things, including, but not limited to, staring at my code.
If your curious you should just give it a go. Reflex is one of the more actively used and maintained projects and it has been optimized for quickly starting out. Additionally the support provided in the irc chatroom #reflex-frp on freenode is excellent. The whole thing works surprisingly well.
I found a way to deal with this in the case where you're using Cofree. You can interleave monadic effects with effects from the base functor if you use `Cofree` over a composition of the monad and the base functor. I still need to find a nice way to integrate this into the existing row-based framework. http://try.purescript.org/?backend=core&amp;gist=d0fea74115565603dd78e98372e6dafa 
"... and then I called him a Social Justice Warrior, because he wanted justice, and I wanted to be on the wrong side of history."
You can play with the [`deriving-via`](https://github.com/RyanGlScott/ghc/tree/deriving-via) branch Ryan has backported it into his [*deriving-compat*](https://hackage.haskell.org/package/deriving-compat) package so you can test it out without installing GHC: [`Data.Deriving.Via`](https://hackage.haskell.org/package/deriving-compat-0.4.1/docs/Data-Deriving-Via.html) Feedback is welcome
He's talking about -- Assuming (forall mm. Monad mm =&gt; Monad (trans mm)) =&gt; MonadTrans trans instance (MonadTrans trans, MonadState s m) =&gt; MonadState s (trans m) where get :: trans m s get = lift get put :: s -&gt; trans m () put = lift . put which can be attached to a newtype and derived
The problem isn't really solved with Monad -- it's solved with Traversable :)
For what it's worth, if you want to return some value and not care what it is, it's best to return '()'. you can use 'void' on S.updateArticleBody to turn it into an m ().
That doesn't solve the problem of distribution though, right? My users would have to also be using WSL. Which I suppose is fine for command line applications etc, but if I'm using Nix to distribute a proper Windows app (a game for example), this wouldn't work.
+1 Nix Endorsement
Yeah
Jesus christ, you might wanna step out of your echo-chamber there. Let's take this step-by-step. The comment I responded to, was a response to the following, &gt; This aggressive Twitter posturing used to harass or supress those you don't agree with is the real bigotry. The comment takes what is a real thing---Twitter being used as a medium to shame and harass people, based on the viewpoints---and calls it bigotry, because that is exactly what it is, by the definition of the word. It is by no means limited to people that identify by "alt right" or "alt left". The comment I'm replying to then takes this, and immediately jumps to the conclusion that if they don't back this specific way of tackling such an issue as we are currently debating, then they clearly must be against us, feeding into the us-vs-them rhetoric. &gt; This rhetoric is straight out of the far right's playbook: classic reversal to victimise the victims by presenting them as "the real [fascist/racist/sexist/bigot]" Now, I don't need to care about the far right to see that it is faulty reasoning to blame someone for supporting one side, because they are not supporting the other---what if both are sides are wrong for their own reasons: the alt-right with their ignorant morales having learned nothing from history, and the alt-left with their exceptionally polarising argumentative-style that only feeds into making the problem worse and more polarising (hence pushing center people towards the right). In the spirit of your own comment, I'd recommend checking out Jordan Peterson and maybe Jonathan Heidt, for a more nuanced take on our society today. I almost suspect that you might already think that Jordan Peterson is someone on the alt-right, if you have literally never heard him speak but are only aware of him through second-hand media, but I can assure you that nothing is further from the truth. 
I would be very interested to hear experiences from other people that have had a chance to toy with this, or perhaps also experiences from people using GHCJS for mobile development.
I'd love to have a guide like this for raspberry pi. I want to deploy some haskell there and run into problems when getting cabal to cross-build. 
Position independent code. You need it to link object files into a shared library. In my case, I want to use this with FFI to build a shared library in Haskell that can be called into from Python / C++ / whatever.
I'm not sure why Firefox struggles so much, I opened an issue a while back to remind myself to investigate further. It's not bad on Chrome/Safari/Edge. I pushed a commit a couple of hours ago which sped it up by ~2x on my machine.
[As before](https://www.reddit.com/r/haskell/comments/7s076d/announce_ghc_841alpha2_available/dt33ezl/), here's a [stack.yaml](https://gist.github.com/DanBurton/b9d199ddd7e23a4c7351f1ba56d64a71) that can get you started playing with this release. (And [here's the script](https://gist.github.com/DanBurton/5b23b45103852636b6e30b9f11224bba) that generated that stack.yaml)
Or `response (Nothing @Int)`, which might be more obvious 🙂
yeah, the reflex project nix file is working pretty well for me 
I know right? There's a bunch of other cool stuff in Haskell (and Category Theory more generally) where the same basic thing shows up in multiple places. But this is one of my favorites. The reason that `Applicative f, Monoid a =&gt; Monoid (f a)` is a bad idea is because it conflicts with the Monoid instances for [] and Maybe. (And both of those instances are important because they're the free object-to-monoid and free semigroup-to-monoid functors, respectively.) ...And the fact that I *can't* do this in Haskell (without resorting to Newtypes) is one of the reasons I'm trying (**trying**) to write my own programming language, where multiple class instances for one data type *don't* break things.
You can pass compiler flags like fPIC, the problem is that everything has to be built with fPIC to fit together, which means you have to rebuild the entire GHC runtime and base libs yourself with this enabled, as well as get all your cabal deps to build with it, and then finally, your project. Cabal also won’t really help you link together all the object files into a dylib, so you have to do all that yourself, too, which is another can of worms. But it is possible to do all this, and hopefully there will be some infrastructure evolution at some point to mechanize it.
It wants to install its own libc, gcc, ghc, bash, etc. Basically, it's like I'm running two operating systems instead of one.
Playing this purely as type tetris, that is, ignoring the understanding of the functions involved: hog :: (c -&gt; d) -&gt; (a -&gt; b -&gt; c ) -&gt; a -&gt; b -&gt; d :: (c -&gt; d) -&gt; (a -&gt; (b -&gt; c)) -&gt; (a -&gt; (b -&gt; d)) -- right-associativity of -&gt; This doesn't directly match any of our existing functions, so we will be composing two or more to get there: `hog = _a . _b`. Now we're getting somewhere - looking from the right to the left, we will want something as `_a` that can go from `a -&gt; x` to `a -&gt; y`, where `x = b -&gt; c` and `y = b -&gt; d`, with some other as yet unidentified input. `.` is our only option from the given list, so we will have a function looking like `(.) . _b`. The type of `_b` is very, very constrained now - it must be `_b :: (c -&gt; d) -&gt; (b -&gt; c) -&gt; (b -&gt; d)`. The good news is this type, after α-transform, is precisely the type of `.`, so `_b = (.)` and `hog = (.) . (.)`. 
Maybe try reversing the two lists first and then process the lists in tandem? Also what does the empty list mean? 0? Also, you might want to check out r/haskellquestions.
&gt; as well as simply inviting women who are doing interesting/amazing work Apparently LambdaConf has a blind process for selecting panels? The advantage of this is that you know everyone is there for what they do, rather than for who they are.
Empty list as in the base? I'm assuming that `(__, res)` is the accumulator and base = (0,[]) is how it should start with the folding function? Why would you want to reverse the two lists first?
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/haskellquestions] [Need help with part of a homework assignment](https://www.reddit.com/r/haskellquestions/comments/7w18uc/need_help_with_part_of_a_homework_assignment/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Sorry I did not realize that you need to fill out the skeleton, not just come up with _some_ implementation for `bigPlus`. I suggested a different way because it seemed reasonable -- you start adding from the units place and then proceed to the 10's place and so on. You can find formatting info [here](http://reddittext.com/). Also, how is `foldRight` defined? It doesn't have the same type as `foldr`....
Yes, much nicer. Thank you for creating code world. My kids love the blocks version and I've started working with my 9 year old on the normal version. Is there an easy way to pop out the output to a new window or run it full screen? If not do you mind if I create an issue? It would make viewing on mobile much easier.
Oh god my eyes. Indent by 4 spaces for the love of all that isn't unholy. bigPlus :: [Int] -&gt; [Int] -&gt; [Int] bigPlus l1 l2 = removeZero res where (l1', l2') = padZero l1 l2 (_ , res) = foldRight f base args f (x1, x2) (carry, sum) = error "TBD" base = error "TBD" args = error "TBD" -- padZero [1,2,3] [1] &gt;&gt;&gt; ([1,2,3][0,0,1]) -- removeZero [0,0,1,0,2] &gt; [1,0,2] f (x1, x2) (carry, sum) = f (x1, x2) (carry, sum) where sum = x1 + x2 + carry carry = sum / 10 res = (sum `mod` 10) : res base = (0, []) args = error "TBD" 
I'm not aware of any package simply called 'haskell' via any packaging system (app store, nix, brew, ports). What did you actually install and with what system?
Why is it not correct?
This is awesome(!), thanks so much for writing it up! BTW: the whole cabal story should get much(!) better once [#5018](https://github.com/haskell/cabal/pull/5018) is merged. Also [#4874](https://github.com/haskell/cabal/pull/4874) should make it much more pleasant, as it stops `configure` from putting generated files into the source tree, and rather puts generated files into the `dist/build` folder.
Thanks for your suggestions! Unfortunately, it still doesn't compile on my machine. Can you perhaps put your changes on github? Or post the relevant part of your cabal file (perhaps along with your ghc version). I'm getting the following error with your adapted 'defTbl' definition: https://gist.github.com/anonymous/8fb26373d974e419ae7d2ccf597a1e94
Which version of GHC are you on? Unfortunately, TH code between different versions can be quite fiddly. Rewriting it to be less explicit and instead use quotation would make it more resilient, but that's a bigger change...
I am using GHC '8.0.2'. Should I try with older versions? I would really appreciate a fix that would also work with my GHC version.
These kinds of UI kits are what are missing from FP UI frameworks/languages. Thank you for doing this. Btw, I noticed that the [documentation site](https://tomsmalley.github.io/semantic-reflex/#) doesn't have a progress bar when some data is being fetched from the server (eg. when you're navigating to a different page). How easy/tough would it be do add this in a central place using Reflex? I'd be really interested in seeing a commit where this is implemented, if you ever get around to doing it.
I stumbled upon this while using the Freer Reader monad: data ReaderEff r r where Read :: ReaderEff r r The traditional implementation would be this: runReaderEff :: Reader r a -&gt; r -&gt; a runReaderEff (Pure a) _ = a runReaderEff (Impure (Read) f) r = runReader (f r) r However, I found a more interesting way of using it, along with `data Stream a = a :&lt; Stream a`: runReaderEffStream :: Reader r a -&gt; Stream r -&gt; a runReaderEffStream (Pure a) _ = a runReaderEffStream (Impure (Read) f) (h :&lt; t) = runReaderEffStream (f h) t ...which allows for the data being fed in to change over the course of the program. (Incidentally, the traditional interpretation can be recovered easily, by using `runReaderTraditional a r = runReaderEffStream a (repeat r) where repeat r = r :&lt; repeat r`)
That sounds great! :) I'll try to keep this updated as things progress. One thing I was struggling a bit with, is how one would call Swift from Haskell code? I know that I need to dive into some C FFI, but the changes to Swift over the different versions have made whatever I a bit confusing if it's outdated, or simply not working (added to the fact that I'm not the most experienced with Haskell FFI). I was wondering if you had toyed around with this?
Yes, it is a bit annoying. You can do C -&gt; ObjC -&gt; Swift, or try to fiddle with the swift function name directly. I've done both, but that was ~1yr ago. I hope I'll get around to that once, all this cabal stuff is done.
Thanks for writing this article, it convey the idea about monad transformer eloquently, however, I have a comment: run = do runA runB is run = runA &gt;&gt;= runB shouldn't `run` be `run = runA &gt;&gt; runB` or `runA &gt;&gt;= \_ -&gt; runB`
Hmm... So you never have reason to use global mutable state, then? That's the only reason why I use `unsafePerformIO`: because I have a mutable variable that's used all over the place, by multiple threads, and passing it around as a parameter is impossible or impractical. In particular, how would you implement a global cache, used by multiple threads? 
I do understand how the bind operator work,but I cannot find how it is useful in this example?
&gt; how one would call Swift from Haskell code Long-term I'm not even sure how desirable that is. Swift is a good language, but the iOS Foundation/UIKit libraries are reeeally showing their age. They're built in a really convoluted, untyped, lazy-initialized, sort of gc'd but not really fashion. Worse, they don't compose *at all* - there are certain widgets you're "allowed" to put inside other widgets, and certain ones you're not, and it's all just a jumbled mess of runtime hardcoded nonsense. Of course, the plus is that it exists. But long-term, I would much prefer for us to just make our own UI kit in a more modern, composable way. I don't think it needs to be done completely from scratch - most of the CoreFoundation / CoreAnimation / text rendering (whatever they call that) is in C, and it should be possible to build a more sensible UI library on top of these pieces (although these show some legacy, too, like forcing you to perform operations from certain threads, etc., but writing a UI kit starting truly from scratch is a huge amount of work).
Create one (or more) IORefs (or MVars, or some other mutable reference), and pass them in as arguments. This is greatly simplified by stuffing them all in a record type.
isn't it runA &gt;&gt; runB ?
Hi, the Author here. It sounds like your setup is all good (being that you have run the tests). You can jump into the examples directory (it's a subproject with its own cabal file, just use mafia and it will pick up the package dependency properly) and play with one of the example files there. There's an MNIST convolution neural net and a GAN version of it for example, as well as an LSTM network for character prediction. Grenade is also on Cabal, so you can treat it as just another dependency. But I would start with the examples. Cheers, Huw
First shalt thou take out the Holy Pin. Then, shalt thou count to three, no more, no less. Three shall be the number thou shalt count, and the number of the counting shall be three. Four shalt thou not count, nor either count thou two, excepting that thou then proceed to three. Five is right out! Once the number three, being the third number, be reached, then lobbest thou thy Holy Hand Grenade of Antioch towards thou foe, who being naughty in my sight, shall snuff it.
Does what nix does step on you when you're not nix-building / in a nix-shell? Did you install using nix-env?
Yes, you're correct. I will update it. Thanks a lots.
Stealing my joke :P
Proper punctuation can make all the difference as in "I like cooking my family and my pets" vs "I like cooking, my family and my pets"!
[removed]
I saw [a blog about cross compiling](https://medium.com/@zw3rk/relocatable-ghc-cross-compiler-binary-distributions-f55080b837b1) not long ago - perhaps that would be helpful. I should say that I've not tried any of this out, but there are a series of articles there suggesting it might be a good resource for you.
&gt; "I like cooking my family and my pets" vs "I like cooking my family, and my pets"! You seem to like cooking your family either way... ;)
Ok thanks I knew it was something simple ... Just ran ../mafia build in the examples folder. I was confused that there was no mafia script inside Nice to see the library author answers himself so quickly ! 
I do provide a raspberry pi cross compiler on http://hackage.mobilehaskell.org The process is pretty much the same as the one detailed in this article, you will however need to build you own raspberry pi SDK for that (I'm still pondering if I should provide those or not. As they would be tied to a specific raspbian and package state; which might in most cases not matter so much?). For the SDK see [making a raspbian cross compilation sdk](https://medium.com/@zw3rk/making-a-raspbian-cross-compilation-sdk-830fe56d75ba) In general you may find the posts on Raspberry Pi on https://medium.com/@zw3rk/ useful.
As far as I'm aware, it keeps everything in /nix, but that's not the point. I already have libc, compilers, etc. installed, so why does nix insist on installing its own? I have enough trouble maintaining one operating system, I'd rather not have to maintain two.
always welcome and please keep writing about Haskell :) I am looking to start my own blog the soonest as well.
Ah, that's actually a very nice idea.
would you mind please explaining how does Traversable solve this problem?
I installed the package from the site linked on the side a couple of months ago. Using Mac OS. 
Wouldn't it be possible to achieve the same thing without freer monads by writing code inside custom monad typeclass that derives from `MonadState`, and then running it against different instances of it?
Bad bot.
Thank you BoteboTsebo for voting on LimbRetrieval-Bot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
If you get these instructions wrong, you will experience truly deep learning.
Right, your suggestion is the real way to do this, but it doesn't satisfy the homework requirement. In fact: bigPlus x y = toRadix 10 $ fromRadix 10 x + fromRadix 10 y toRadix b = reverse . map (`mod` b) . takeWhile (&gt;0) . iterate (`div` b) fromRadix b = foldl' ((+) . (* b)) 0
It depends on your model. If you are using Nix as a deployment tool for end users, then yes, your end users need to have WSL enabled. You could do that in an installer. You could even do it in Nix, using PowerShell. If you are just using Nix as a build tool for developers, then only developers would need WSL enabled. Your Nix in WSL could happily run GHC builds either using WSL-based GHC or using NT-based GHC.
Hi, thanks for the response. I seem I have some material to study now. Thanks! :)
&gt; GHC doesn't currently support this Hasn't GHC supported it for quite a while now?
A few months ago I was also looking for the same thing and found nothing, so I wrote this: https://github.com/vagarenko/record-storable/blob/master/src/Foreign/Storable/Promoted.hs
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [vagarenko/record-storable/.../**Promoted.hs** (master → cb90eb4)](https://github.com/vagarenko/record-storable/blob/cb90eb46eb3105e68df6c4515013beb23fd40b8c/src/Foreign/Storable/Promoted.hs) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dtxe1up.)
What's the downside of `-fPIC`? I can't understand why it's not the default.
ISTR Stack installing its own GHC.
&gt; why does nix insist on installing its own? Because it's supposed to produce repeatable builds. It can't do that without requiring you to use a specific toolchain.
&gt; But the solve function happens to tend to the Nothing values as there are more and more packages, more and more constraints, giving rise to cabal hell happening more and more often. This is not really the case, or at least doesn't get to the heart of the matter. The single biggest restriction was that a package database couldn't contain two distinct instances of the same package version (different specifically because they are linked against different dependencies). I don't know if they've removed this *restriction* but cabal new-build reportedly solves the *problem*.
As for mutable state: it's not so much that I need mutable state to optimize code, but because stuff simply... changes. So I have a window with buttons to access different devices (computer / ereader 1 / ereader 2). If a new ereader gets connected or an old one removed, these buttons need to appear / disappear with it. To do this effectively, I need to keep track of which I have already. So I have an `IORef [Device]`s. Same for the book collection. Per device, I have an `IORef [Book]` to know which books are in there. If a use transfers a book from one device to another or removes one, these change. I need these collections so I can have functionality like filtering for example. I'm pretty sure this is not the best way to approach this however. I don't see how to otherwise keep track of which books I have, though. If they weren't usable the shown books and the Haskell state would start to diverge.
As for mutable state: it's not so much that I need mutable state to optimize code, but because stuff simply... changes. So I have a window with buttons to access different devices (computer / ereader 1 / ereader 2). If a new ereader gets connected or an old one removed, these buttons need to appear / disappear with it. To do this effectively, I need to keep track of which I have already. So I have an IORef [Device]s. Same for the book collection. Per device, I have an IORef [Book] to know which books are in there. If a use transfers a book from one device to another or removes one, these change. I need these collections so I can have functionality like filtering for example. I'm pretty sure this is not the best way to approach this however. I don't see how to otherwise keep track of which books I have, though. If they weren't usable the shown books and the Haskell state would start to diverge. 
I'm also unsure how useful it is to be able to switch interpreters that drastically change semantics like turning state into a reader. When I write an effectful monadic program, I usually have some idea of what I want the effects to *do* when I use them. That is in contrast with less visible differences such as implementing state via the usual way (i.e., `s -&gt; m (a, s)`), or via `IORef`, or just adding a logging side effect.
In Conal's Github page you can find the following: https://github.com/conal?utf8=%E2%9C%93&amp;tab=repositories&amp;q=para&amp;type=&amp;language=
Yes, but those are just some snippets of code. I could write the implementations from the paper, but I was wondering if someone knew of any proper packaging (since it looks like this work will develop further / be subject to revisions).
Cool. I'll ping him on github. Thanks!
Thanks Taylor! Just a suggestion. In the last section you mention events, and you write US states in the same level as countries in the world. Especially because there is a country that is named "Georgia" in the occident, I would not recommend this. Even if most Haskellers are from the U.S. and it is a big country, put the country in the end, this would put countries in the same ground of equality.
Thanks for the suggestion! I updated the locations to include "United States" for Georgia and Michigan in [this commit](https://github.com/haskellweekly/haskellweekly.github.io/commit/905453b84663ae4e74f252d10bc99a95b0422742). More generally, I'm having a hard time with events and their locations. I added locations based on [a suggestion](https://github.com/haskellweekly/haskellweekly.github.io/issues/150). Previously I had included the meetup name, which was frequently the name of the city it was hosted in (like "Quito lambda"). I would love to have something better, like the [Rust community calendar](https://calendar.google.com/calendar/embed?src=apd9vmbc22egenmtu5l6c5jbfc@group.calendar.google.com&amp;pli=1). I don't have the time to devote to such a project right now, but I will happily accept contributions! 
This is already very good, thank you!
I did get that far thanks to your help in the posts. I had issues getting cabal to work with that compiler though. Not sure why but it wasn’t passing the options. Is there a version requirement for cabal to correctly pass options to ghc? I might try again on a clean VM.
&gt; I don't know if they've removed this restriction It has been removed, originally motivated for supporting `cabal new-build`; you can see evidence of this in `ghc-pkg --help`'s output mentioning --enable-multi-instance allow registering multiple instances of the same package version since GHC 7.10; and `cabal new-build` makes use of `--enable-multi-instance` when available. However, it turns out that there's a hack to trick GHCs before 7.10 into having a multi-instance package db as well, which is what today's `cabal new-build` uses for supporting GHC 7.0 through GHC 7.8. Btw, it seems to me, this discussion referring to "cabal hell" lacks the obligatory reference to the blog posts: - https://www.well-typed.com/blog/2014/09/how-we-might-abolish-cabal-hell-part-1/ - https://www.well-typed.com/blog/2015/01/how-we-might-abolish-cabal-hell-part-2/ - http://blog.ezyang.com/2015/09/is-no-reinstall-cabal-coming-to-ghc-8/ (at the time the pre-ghc-7.8 hack wasn't known iirc) 
thank you for your answer, do you mean the `forM` imported from `Data.Traversablt`? 
&gt; it turns out that there's a hack to trick GHCs before 7.10 into having a multi-instance package db as well Registering each package in a separate DB?
Nope, same db... otherwise you couldn't call it a "multi-instance package db"... turns out there's a hack by which you can bypass `ghc-pkg`'s validation which would have `ghc-pkg` reject any attempt to register multiple instances... :-)
Is TypeLits really much more magical than GHCs runtime primitives? (Int# ect)
Cool! Anyway, new-build seems like The Right Thing^TM. Perhaps we should try to get the notion of "cabal heaven" into the public consciousness.
So.... are you saying you installed the Haskell Platform?
I loled at this.
Is that Jesus?
Yes but I have two versions. One is an older version but I installed the new version yesterday. 
Generally in my experience you don't want to drastically switch semantics, but drastically switch backends. For example, conceptually Redis is just a key value store, which you can model as a `KVStore k v` effect. However, that's not as useful when you want to write unit tests, so you can instead interpret your `KVStore k v` as a `State (Map k v)`. This means things that are traditionally considered implementation details behind your business logic become library code. It's actually quite a joy to experience when nontrivial apps turn out to be 10 lines of business logic, and you get testing for free.
Drastically changing semantics can be useful to inspect information about your program, for example to optimize it. For example as in: http://lukajcb.github.io/blog/functional/2018/01/03/optimizing-tagless-final.html .
The wiki says you just `sudo uninstall-hs`. Looking at the help message the command `sudo uninstall-hs thru 8.0.2 -r` should work too. As an aside: I don't use the Haskell platform. On OS-X I use nix-env such as `nix-env -i ghc` and `nix-env -f "&lt;nixpkgs&gt;" -iA haskellPackages.cabal-install`.
Thank you very much. Have a good day. 
runA *&gt; runB
Hi HuwCampbell, I have an out of topic question about grenade. Can grenade be adapted to use tensorflow as backend maybe using tensorflow bindings for haskell. I really wish there was a keras like library for haskell!
No, this is Patrick.
&gt; make our own UI kit Hopefully one day! One problem with this approach is that the app will never feel like a 100% native app. And if Apple ever does a major overhaul of the way iOS looks (think iOS 6 -&gt; 7), an app with a custom UI will suddenly look even more out of place. Sadly, Swift/UIKit remains IMO the way to go to build "real" iOS apps. I'd love to do it in Haskell, but such a project would have to be really well funded and maintained. I mean, even the Microsoft juggernaut tried to pull cross-platform off with Xamarin. That didn't turn out too well AFAIK. There continues to be demand for native Swift/UIKit devs and they make a decent living AFAIK, and there appear to be good reasons for it.
Strictly speaking, I don't think that's *your* joke, is it? It would be an incredible coincidence, if so! :) ... unless of course you're one of the non-deceased Pythons.
I like `streaming` for it's all-around simplicity; it's the one I usually reach for first. It even makes a great `FreeT` replacement. Once things get more complicated, I prefer `pipes`, since that's the one I've worked with the most. I like the way it uses lenses and grouping to thinking about destructuring input. But depending on your use case, you might find `conduit` the best for getting something working that has the semantics you expect without thinking too hard.
In my mind, optimizations are the opposite of drastically changing semantics.
`-&gt;` is the function type constructor. So `(-&gt;) Int String` is a function from ints to strings (same as `Int -&gt; String`). instance Monad ((-&gt;) s) where f &gt;&gt;= g = ... `f` has type `(-&gt;) s a` and `g` has type `a -&gt; (-&gt;) s b` and you need to give back something of type `(-&gt;) s b`.
A really heavy solution to a minor problem.
Quite the contrary -- I gave code that works with the TH shipped with 8.2.2. For 8.0.2, change the last argument to `dataD` from a raw list to `(cxt [])`. As I said, the changes between versions are a bit fiddly :-)
Yes, the optimization itself should probably be the same semantics. But there might be an intermediate step involved which might use different semantics to obtain a result on which the optimization can be based.
I've been keeping my eye on [streamly](https://hackage.haskell.org/package/streamly) because it looks super nifty but I haven't gotten around to actually doing anything with it yet. I'm particularly a fan of how easy it looks to use different typeclasses to compose streams together in different ordering schemes (sequential, concurrent, interleaved, etc)
Basically what /u/Solonarv said. You can see an example of that in [msg](https://github.com/soupi/msg/blob/master/src/Msg/Server/Run.hs#L21). Global state almost always hinders your ability to maintain/debug/test/compose your application. Notice how with a tiny change of extracting the port out of the definition of a socket server i could run multiple isolated chat servers just by calling `run` more than once and passing different ports. This is not something you would've been able to do with global state + `unsafePerformanceIO`. And you could also use `State` or `Reader` if you don't want to pass arguments.
Out of interest, why isn't this just in nixpkgs?
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [soupi/msg/.../**Run.hs#L21** (master → 2402059)](https://github.com/soupi/msg/blob/240205900868f46469258fa52de34ab78c19ac0d/src/Msg/Server/Run.hs#L21) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dtyc8od.)
It kind of is https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/haskell-modules/hie-packages.nix But it got marked broken. Not sure why. The real question is why hasn't any of this been released to Hackage? Proper releases are the only thing standing in the way of a completely *normal* installation process.
`streaming` is my goto. It has the nicest, simplest API by far—it feels almost identical to programming with normal lists! I recently rewrote some `pipes` code at work using `streaming` and really enjoyed the experience. The code got cleaner, it was easier to write and, incidentally, it improved performance by ~30% (all saved by allocating less and spending less time in GC). I prefer `streaming` because it's easier for me and would be easier for people new to the team. The API is clean, it's straightforward (just three type variables, not six!) and it's easy to transition from "normal" Haskell without running into an abstraction overload.
From Control.Monad, alternatively you can use `for` and `for_` from `Data.Foldable`/`Data.Traversable` (or `traverse`/`traverse_` which are just the flipped versions) 
Or to someone who wants evidence that you can accomplish a lot in Servant with very little code. 
I've written a proxy-and-faux-TDS-server that, upon receiving a query request, makes a request to a web service and (1) streams the response, (2) parses the response as JSON array elements in a streaming fashion, (3) yields the data as rows in the TDS protocol in a streaming fashion to an ODBC/MS SQL Server client. All in constant memory (which was a requirement and a typical one for a proxy), using Conduit. It wasn't even hard. I just piped the things together and Conduit did the needful. I can see why it looks like a heavy solution to supposedly minor problems, but when you have major problems then it's a really light solution.
Another vote for `streaming`. The library is clean yet expressive, it focuses on producers and doesn't have a separate type for intermediate stages—you simply have functions that transform producers and compose them with vanilla `.`. I haven found in Hackage the streaming version of something like `pipes-text`. I just use `pipes-text` and convert to and from as needed. 
Thank you for that clarification!
I primarily use `conduit`, as `persistent` and `yesod` use it heavily.
A streaming library for general use is only as useful as the library set written in it. I use Conduit because it has a large range of consumers and producers (http-conduit, xml-conduit, aeson-conduit, csv-conduit, html-conduit, persistent exposes APIs for it, Yesod supports it, etc. and conduit-extra has a big toolbox of networking, file I/O, zlib, attoparsec, ..). pipes has a large set of bindings too and isn't hugely different. But I learned conduit first and I like leftovers. The APIs are otherwise kind of the same.
Meta comment: It would be awesome if the authors of those three packages collaborated on a document which compared and contrasted each of them and gave recommendations for when to use which one. I feel like I've seen this question asked a number of times over the years, and having a canonical place to point people to would be great! Eh, it may even lead to taking the best of each and combining them into a single package ;)
I think there was a Haskell Cast episode where the pipes and conduit creators did that.
If you had issues with cabal new-build, you currently need to build it from source (hit head).
That sounds very cool
Awesome, this will make it easy enough to try that I can't put it off any more. Is anyone already using HIE to replace something like Intero for Emacs?
[quiver](https://hackage.haskell.org/package/quiver) claims to generalize both. There are probably still a few more "streaming libraries" than those mentioned here. A proper comparison would be helpful indeed!
(streamly)[https://hackage.haskell.org/package/streamly]
Sure, i will keep writing. Wish you create your blog soon.
In brief, the answer is no. Dependent types are not going to provide a way to work around the levity polymorphism binding rule. &gt; i would also think that most of the time the runtime-rep is known statically, so maybe GHC can eliminate this in reality This is a good thought, and it's entirely orthogonal to your original question. The Levity Polymorphism paper opens with the humble `twice` function: bTwice :: ∀ a. Bool → a → (a → a) → a bTwice b x f = case b of True → f (f x) False → x It goes on to conclude that such a function cannot be made levity polymorphic, since the code generator must know the representation of type `a`. But, this conclusion assumes that the body of `bTwice` is not inlined or specialized at the use site. If these could happen, then `bTwice` could happily be levity polymorphic. However, this isn't even always possible (ie, if `bTwice` is passed as an argument to a higher order levity-polymorphic function), so it would create a weird situation where some functions were second-class, so to speak. Also, you might be interested in [Trac Issue #13955](https://ghc.haskell.org/trac/ghc/ticket/13955), which will be resolved in GHC 8.4.
Don't overlook the `foldl` package. I find this frequently scratches the same itch with less cognitive overhead.
Done! I hadn't thought of editing the comment with what I ended up doing, so I guess that was kinda selfish of me. I don't know if it can really help anyone but I wrote it up nonetheless, just in case. At the very least to signal that the suggestions were helpful and the problem *did* get solved.
Machines!
I too think something like this is necessary. I mean Storable should have both size and alignment at the type level. This can also make some of the alloca-variants better. I have been dabbling with these issues in the raaz crypto library where I want to make use of these informations at the type level. I will be happy to contribute. 
What about pattern matching? filter (\(n,_) -&gt; n == 1) list That will also help you for your full goal.
Free monads do that just as well
I too always use `streaming`, but I wouldn't call it simple. I usually hang out in `Streaming.Prelude`, but every once in a while I'll wander into `Streaming` and try to use one of the functor-general combinators. In the end the only functor that ever makes sense to me is `Of`.
The problem is function application. You're trying to apply three arguments to averageThree like this averageThree(a b c) but function application syntax in haskell doesn't use parentheses. For example, to use the `min` function, you would write min 5 7 and not min(5 7)
When you are using curried functions in Haskell, you cannot put parentheses around the arguments. You need to write `averageThree a b c` instead of `averageThree (a b c)`. More details if you're still confused... While most languages collect function argument first and then invoke the function, Haskell uses a convention called "currying", where arguments are supplied one at a time. That means that an expression like `averageThree a b c` actually means this: `((averageThree a) b) c`. In other words, you start with `averageThree`, and pass it just the argument `a`. The *result* of this is another function. You pass the second argument, `b`, to *that* function, and get back yet *another* function. Finally, you pass the third argument, `c`, to that function, to get the result. You can leave out the parentheses because function application associates to the left by default. So `averageThree a b c` is parsed correctly with implied parentheses to the left; but `averageThree (a b c)` incorrectly groups the three arguments together, breaking up the initial subexpression `averageThree a`. If you read your error message, you'll notice that it's talking about `a` being a *function* applied to two arguments. In Haskell, juxtaposing two expressions without any kind of operator means function application. So when you wrote `(a b c)`, the compiler thought you were trying to apply `a` as a function to two arguments `b` and `c`. Of course, it rightly complained that this is nonsense. You might wonder *why* Haskell uses this currying convention. The answer is that it's extremely convenient. It means that if you have a function of several parameters, and you know the values you want for some of them, *if* they happen to be the first parameters, you can just pass in those, and be left with a function that has fewer parameters. That's actually absurdly convenient when you're doing higher-order programming where parameters and results of functions are often other functions. It's a convention in Haskell to put the parameters that you are most likely to know in advance in the *first* positions; that sometimes seems weird, until you need to partially apply the function.
If you wanna be a smart ass f :: [Int] -&gt; Int f = read . concatMap show g :: Int -&gt; [Int] g = map (\x -&gt; read [x]) . show bigPlus :: [Int] -&gt; [Int] -&gt; [Int] bigPlus x y = g (f x + f y) but if you wanna pass do anything else
I use conduit because it is the one I started with. It also seems to have a larger ecosystem.
Sounds like something Liquid Haskell would take care of.
Thanks, Liquid Haskell looks like the kind of solution I'm looking for.
Currently you can use fromHandle and toHandle in the Streamly.Prelude module to stream Strings to or from file handles. Bytestring streaming combinators coming soon.
Given `throwTo` exists, any function can throw any exception. There, I did your static analysis for you :p
You may also like Java then... a majority starts out with Java and it also seems to have a larger ecosystem!
&gt; If you do get this working properly, it might be worth doing a new hackage release with the fixes? Please do! I have very fond memories of using peggy and truly enjoyed every time I had a chance to. I never got why Haskell prefers parsec-style combinators libraries over parser generators.
Thank you, I completely forgot you could but the \n into brackets! 
there are even more different bottom values - just look at a harmless list - you can have - [] :: [a] - x : xs :: [a] - undefined :: [a] - undefined : xs :: [a] where `xs` can contain all that stuff yet again (there is a nice picture of that here https://en.wikibooks.org/wiki/Haskell/Denotational_semantics#Recursive_Data_Types_and_Infinite_Lists)
I recently started use conduit. I picked conduit because it has - a good ecosytem - a nice the tutorial - I liked the frequent small exercises in the tutorial with snippets runnable with stack I.e, it was easy to learn it lazily. I planned to look at pipes as well, but never got around to it as conduit worked out well.
But is `undefined : xs` really a bottom value? You can pattern match on it just fine.
I haven't seen `streaming` and `streamly` before.. could someone do a comparison between them?
true - just wanted to say that there are a lot more additional inhabitatnts (on top of undefined :: [a]) sorry
The 'dual' answer to that of /u/guaraqe is to project from the tuple inside the lambda using `fst :: (a, b) -&gt; a`: filter (\n -&gt; fst n == 1) list Or, if you want, pointfree: filter ((== 1) . fst) list
To me, conduit seems to be the least like Java. Most streaming libraries in Haskell focus on the stream itself, just like `java.util.stream`. Conduit is the only one I've seen that focuses on the transformation (the `Conduit`).
It is not a bottom value.
It's complicated. The gist of it is we need to get cabal-helper and ghc-mod-core onto hackage, then hie can go. Nearly there ....
I see your point now. I guess with DT, your `id` would be: id :: pi (r :: RuntimeRep). forall (a :: Type r). a -&gt; a I guess the binder rule could conceivably be lifted for runtime representations bound with a relevant quantifier. The problem is that for code generation, GHC likes to fully saturate function calls for performance reasons, and calls to `id` could never be allowed to be fully saturated. It would have to dispatch on `r` and choose from infinitely many copies of the rest of the `id` function (one copy for each possible runtime representation). If `RuntimeRep` had only a finite number of inhabitants, perhaps this could work, but as things are, it cannot.
this is exactly what I mean! I expected that this is not possible with the current GHC like I said, it's more of a thought experiment.
Yay for simple(r) APIs! I'm delighted to see when people mention a library that I haven't heard of/tried and they explicitly say that it has a nice API. This is the case here as well. I haven't heard of `streaming` before, but I did consider trying conduits, pipes, and decided I didn't want the additional complexity, while so far being able to do without the advantages. I hope Haskell library authors will continue striving towards simple and powerful abstractions on the their packages' surface -- while still letting us use the lower level ingredients of their modules for the edge cases where they are necessary.
Well written answer. Helped this noob also. Thanks. 
&gt; Pure functions don't "throw" in the usual sense. All types - regardless of how many values they claim to contain - also contain the value "bottom" (or `_|_`), which when evaluated, crashes a Haskell program. This is incorrect. A pure function can throw any exception: import Control.Exception -- | -- &gt;&gt;&gt; throwsIOException -- *** Exception: &lt;&lt;deadlock&gt;&gt; throwsIOException :: a throwsIOException = throw Deadlock In fact, `undefined` and `error` are both defined using `throw`, and we can demonstrate this by catching the exception they throw: -- | -- &gt;&gt;&gt; catchesUndefined -- caught. catchesUndefined :: IO () catchesUndefined = do r &lt;- try $ do print (undefined :: Int) case r :: Either ErrorCall () of Left _ -&gt; putStrLn "caught." Right () -&gt; putStrLn "no exception." -- | -- &gt;&gt;&gt; catchesError -- caught. catchesError :: IO () catchesError = do r &lt;- try $ do print (error "not an Int" :: Int) case r :: Either ErrorCall () of Left _ -&gt; putStrLn "caught." Right () -&gt; putStrLn "no exception." Bottom is not a real value. It is not even a special expression which crashes the program when evaluated. Instead, it is [a mathematical value we use to talk about expressions which diverge or throw exceptions](https://www.reddit.com/r/haskell/comments/5h4o3u/a_beginnerfriendly_explanation_of_bottom_taken/day73ue/), such as `undefined`, `error myErrorMessage`, and `throw myException`.
[The word "value" is overloaded](https://www.reddit.com/r/haskell/comments/4zm2gc/notes_on/d75o4wt/). I would say it is a WHNF value, and therefore not bottom, but it is not a total value, because it contains a bottom.
Great info! We stumbled upon this at work once we passed a few dozen entities a few years ago. We don't use `persistent` for our migrations so we didn't need everything in one quasiquote block. --- A word of warning to anyone working on large Haskell projects: beware not to create "bottleneck" modules for recompilation. Any module that imports _your code_ from a bunch of other modules and then just re-exports it is what I mean by "bottleneck" (imagine the dependency graph of your modules converging on this module and then diverging to downstream modules). If you have modules like this, then any change in an upstream module means you have to recompile all of the downstream modules. A practical example is for entities, just like in this blog post. Imagine you separated your entities into different files because you read this blog post and thought "hey, that's a good idea". But then, you stuck a `MyApp.Entities.Import` module into your code that just imports and re-exports all of your entities. Now when you change one entity, sure you don't have to recompile all the other entities. However, any module that imports `MyApp.Entities.Import` will need to be recompiled! Another common bottleneck is lens modules, where you import a ton of modules so you can run a template haskell function that produces classy lenses. This function requires all of your lens definitions to be in the same file so they can reuse the same type classes. At work we are in the process of just manually producing these type classes and manually creating the instances in our entities. One more tip: I learned recently that when you are using `stack` to compile multiple packages, changing an upstream package does not necessarily mean you need to recompile an entire downstream package. That is, if you have a local package `foo` that depends on a local package `bar`, and you change `Bar.Missiles`, only modules in `foo` that import `Bar.Missiles` (directly or transitively) need to be recompiled. The moral of the story is: if you value minimal recompilation in a large Haskell project, then make sure you don't have bottlenecks in your module dependency graph.
Your static analysis is approximately as precise as Python's type system :p
I use [doctest](http://hackage.haskell.org/package/doctest) and [ghcid](http://hackage.haskell.org/package/ghcid) every day, to experiment with small snippets of code. I have a "toy.cabal" project which I use for this. For concurrent programming, [async](http://hackage.haskell.org/package/async) is much less error-prone than [Control.Concurrent](https://hackage.haskell.org/package/base-4.10.1.0/docs/Control-Concurrent.html), and [stm](http://hackage.haskell.org/package/stm) is much less error-prone than [Control.Concurrent.MVar](https://hackage.haskell.org/package/base-4.10.1.0/docs/Control-Concurrent-MVar.html).
Try perusing [this.](https://github.com/krispo/awesome-haskell)
[removed]
Despite the name, "awesome Haskell" is not providing a curated list of Haskell packages which are considered particularly awesome, instead it's a list of every single Haskell package ever. Most links are simply redirecting to the corresponding hackage category.
optparse-generic, shelly, and servant are my goto libs.
Yes yes, I know it's *a* solution to streaming IO in bounded memory. I also believe you that it wasn't hard. But I'm not convinced that it's worth the trouble because every time I've needed to do stream IO I haven't had to use a streaming library, for whatever reason. I will say Conduit isn't the most overwrought of the streaming libraries.
Thanks for this, my previous understanding was completely wrong.
Checked the first few posts, and I'm suspecting this will be a both hilarious and insightful series. :) 
It seems that it's already happened. I tried pop' :: State Stack Int pop' = State $ \(x:stack) -&gt; (x, stack) but the same happened, had to use the variable state as in: pop' :: State Stack Int pop' = state $ \(x:stack) -&gt; (x, stack) 
If I had yo choseone it would be [mtl](https://hackage.haskell.org/package/mtl)
Invaluable/using all the time: `attoparsec`, `vector`, `containers`,`aeson` ... Best-in-class: `req` for HTTP connection handling
[optparse-applicative](https://hackage.haskell.org/package/optparse-applicative), [http-conduit](https://hackage.haskell.org/package/http-conduit), [cassava](https://hackage.haskell.org/package/cassava), [aeson](https://hackage.haskell.org/package/aeson)
* servant - because I've been making lots of rest interfaces these days. This bullet goes for the entire dependency chain, such as aeson. * optparse-applicative - if you need a rather powerful command line interface this is great. * vector, containers, unordered-containers - not sure where I'd be without basic data structures. * async - because Control.Concurrent is good but too sharp sometimes. * transformers - every big project is an exercise in designing a new domain specific language and coding that up as a monad stack. * postgresql-simple - when you need it you're happy it's there. * text, bytestring - the lack of reuse such as "vector-bytestring" or "vector-text" does make me sad, but these libraries do well. The quality is such that people almost never even question them - parts of text have even been proven via Liquid Haskell. Remember back before hackage or bytestring existed? Bad days. I mean, aes :: [Word8] -&gt; ... ugh. * criterion - There really isn't a competitor
&gt; Another common bottleneck is lens modules, where you import a ton of modules so you can run a template haskell function that produces classy lenses. This function requires all of your lens definitions to be in the same file so they can reuse the same type classes. At work we are in the process of just manually producing these type classes and manually creating the instances in our entities. Sounds like it would be a great idea to be able to take TH and spit out all of the code it generates in a nice readable "normal Haskell" format that could be manually put into your codebase. &gt; The moral of the story is: if you value minimal recompilation in a large Haskell project, then make sure you don't have bottlenecks in your module dependency graph. Do you think it would be possible to make a linter tool that could scan your files and point out potential module dependency bottlenecks?
To be fair, I'd call your explanation "morally correct" even though, technically, any function can throw an exception :)
I have discovered Universum just today, and it seems not many people know about it, so that's why I linked the github page here.
HIE can theoretically already work with emacs. The problem is that the LSP server implementations for emacs don't seem to be nearly as actively worked on as the vim ones, so in practice, it's a little trickier... I need to burn a Sunday or two sometime and see how it works out as I haven't tried the LSP in emacs yet.
Wow, I always wanted this! 
&gt; criterion - There really isn't a competitor There is: * https://github.com/vincenthz/hs-gauge
It's funny because it's true
Could you point to ressources / tutorials on transformers and your comment on them? 
I'm a huge fan of your tradeoffs for what it's worth; some of our most powerful ideas in FP have come from a refusal to figure out how to make the "normal way" work. I'm pretty confident that a strong functional design can later be made efficient and tied into other frameworks eventually. I'd rather have the good design and ease of use at first :)
Yeah, freer and free are basically the same idea, [just constructed differently](https://www.reddit.com/r/haskell/comments/7q4sku/_/dsmlnh7)
I see a future language called "Kmett" which is a variant of Haskell with all of Kmett's libraries in the prelude.
I use https://github.com/emacs-lsp/lsp-haskell in my daily work. It is a thin configuration layer on top of https://github.com/emacs-lsp/lsp-mode which is under very active development, showing the benefits of having the basic client functionality based on the protocol, so benefiting all languages.
Umm... no? I mean, most Haskell learning material covers it but conflated with MTL. Consider most the common [bo](http://book.realworldhaskell.org/read/monad-transformers.html)[oks](http://book.realworldhaskell.org/), [wikibooks](https://en.wikibooks.org/wiki/Haskell/Monad_transformers), and monad tutorials.
Hurm. Not sure I'd call criterion-light a competitor or just another point in the design space for the same code. Thanks for the pointer though, I didn't mean to say there aren't other benchmark libraries just that this is the go-to library that is more popular by probably an order-of-magnitude.
[Haskell Programming from First Principles](http://haskellbook.com/) does an in-depth treatment, without jumping right into mtl. u/tom-md has a point in that many transformer tutorials jump into mtl just quickly. If you're just starting out with transformers, you might be tempted to do that as well. But *when*, not *if*, you do something wrong you will run into error messages that are difficult to understand. For free beer, look into the corresponding chapter in [Real World Haskell](http://book.realworldhaskell.org/). Also, I quite liked what I remember as [the kqr gist](https://github.com/kqr/gists/blob/master/articles/gentle-introduction-monad-transformers.md).
Next advent season, someone needs to do 24 Days of Custom Preludes.
ah, because of TupleRep and SumRep being n-ary. 
Are you guys taking any interns in formal verification? Also, do you guys use any tools like Haskell, Agda, Idris, Coq, or languages like that? The posting only mentions verilog and VDHL which are more about hardware verification than software verification. (I'm also curious as to whether or not Intel has any teams that work on verification at levels higher than the raw circuitry but I'm pretty sure that information is under an NDA of some sort)
Yeah it literally says "clone of criterion" Although as it develops it'll be interesting to see if it makes any improvements or changes overall. Sometimes I get annoyed trying to get criterion to graph the data I want in a way that I want it.
`import Control.Lens` makes a shockingly good Prelude
We occasionally get intern opportunities, though the positions we are advertising are for full-time employment. Please get in contact if you are interested in internships so we can keep it in mind if something comes up. We are solely focused on Hardware; which is coded System Verilog. We do not restrict our engineers as to the tools they use: People pick the best tool available to address the verification concerns. But you can imagine focusing on hardware restricts the choices here. I personally use Haskell at work for "everything else," meaning things that do not have to work directly on the hardware itself. Other people use other tools as they see fit. There's a lot of infrastructure work that we use Haskell/Python routinely for. (Even TCL, because of legacy support in most EDA tools.) Verification at higher levels is done at Intel; though not in my team. We are solely focused on hardware.
&gt; Please get in contact if you are interested in internships so we can keep it in mind if something comes up. Will do! I live across the street from one of the Intel campuses so I think about it a lot. &gt; But you can imagine focusing on hardware restricts the choices here. Absolutely :) I figured the hardware team would be using hardware specialized tooling. Glad to hear there's Haskell in use, even if it's just for internals and "everything else" stuff. &gt; Verification at higher levels is done at Intel; though not in my team. We are solely focused on hardware. Awesome! I've always been more interested in the higher levels of abstraction, but formal verification is a fun problem for me at any level. Good luck on the job hunt
I find myself just writing a custom Prelude for each project. I don't call it that or even do it intentionally, but when I actually look at my code, there's pretty much always one module that re-exports 100 various useful things that I just end up including and using everywhere. Which is basically a Prelude.
Also interested in this: * https://github.com/tweag/hyperion#readme
I am going to write not about package-the-library but rather about package-the-executable. I am a fan of [fast-tags](http://hackage.haskell.org/package/fast-tags) - a very fast and robust tags generator (tags are be used by editors to implement jump to definition). By robustness here I mean the ability to produce tags when input is malformed, i.e. when some files do not parse. I employ this tool to index all the third-party dependencies of a large projects I have at work in order to quickly navigate between the functions. I tend to just grab sources of all dependencies and index them without building. Some dependencies that use preprocessor within their source code could not be parsed without properly expanding preprocessor first (i.e. without building). But thanks to the fast-tags tool being robust I can skip the time-consuming building process and just index them. So, for my workflow that emerged evolutionary, I think that fast-tags is the best choice for a tag generator.
Jordon Peterson... has very weird and wrong views on the world: https://twitter.com/classiclib3ral/status/961461529555210240
That is not a list. `(a,b)` is a tuple. When a tuple has two elements you can also call it a "pair". List syntax uses braces instead of parenthesis like `[a,b,c]`.
Here are a few packages that I use and like: - async, stm - they are easy to use and work great! - optparse-generic - is more lightweight than optparse-applicative and works great when i need something simple - megaparsec, prettyprinter - when i need some parsing/pretty printing done - sdl2 - it's very thorough and works great - spock, lucid - when i need a web server and html templates these are the ones i reach to. i find spock easy enough to use while being powerful enough for less trivial things - file-embed - when i need to add files to an executable - process - when i need to communicate with other processes - tasty, quickcheck - for testing. lately i've been hearing some good things on hedgehog and i might check it out as well 
The linked job offering sounds like it has a lot higher requirement than generly being interested in formal verification. Should one bother without MS and 4 years of _relevant_ experience + verilog knowledge?
precisely
For context, Levent constantly churns out code on sbv, fascinating Haskell package
I'd suggest applying if you have interest and desire. You'll never know if there's a good match if you don't apply!
If you are familiar with SBV and interested in Hardware, you should definitely apply!
Besides the commonly listed ones like attoparsec, servant, aeson, etc. One of my favorite libraries is [pretty-show](https://hackage.haskell.org/package/pretty-show-1.6.16/docs/Text-Show-Pretty.html). I use it frequently to dump data structures to the terminal with `pPrint` if I am trying to debug things. Does a good job of making things look pretty so that I can read the data structure without going insane and without having to do anything complicated to make things look nice.
Awesome, please keep it up! 
&gt; I thought it would be cool if i declare the same functions with same parameters and names with different implementations. So i could change the imports or qualify them and can use them in my application. This drop-in replacement pattern is used by a few common modules such as `Data.Map.Lazy` vs `Data.Map.Strict`, but it's not a very composable abstraction mechanism. For example, if I have a module which implements an algorithm using `Data.Map.Lazy` and I want to switch to `Data.Map.Strict`, I can do that easily by changing one import line; but if I implement a more complex algorithm which uses a library which uses `Data.Map.Lazy`, I can't switch to `Data.Map.Strict` without forking that library. I would instead try to capture the commonalities between your different exchanges in a way which allows you to write code which works with any exchange. &gt; On the other side I dont want this impure code everywhere. Why not? It makes sense to structure your code as an imperative shell around a functional core, but that doesn't mean you should have an imperative module which calls functions from modules which only define pure functions. Each module could define a few IO actions and several pure functions, which could be used on their own as an imperative shell around a functional core, and then your main module could construct a more complicated imperative shell by calling the IO actions from all those modules, around a more complicated core which calls the pure functions from all those modules.
I do this as well.
`fold`?
I've come to like `pretty-simple` the most among the pretty printer libraries.
Whoops! Don't know how I missed that. Must have mistyped something into Hoogle.
Proper `head` is useful for writing programs that work. It's one less thing that can go wrong.
Well I think the point was that it's not much more useful to have the safe one than to have neither. I don't ever find myself wishing I had a head variant at all, safe or not
What's that, a factorial function?
There’s definitely some overlap, like pulling in Contravariant or (&lt;&gt;), but they do include a fair amount more specific to the project, too, for example stuff like the UserId type.
That actually doesn't do what I wanted :-/. I'm seeing `fold (fmap (++) Nothing) "World" == ""` whereas I'd expect `fold (fmap (++) Nothing) == id`. What I was looking to do is get an identity function when using the `Monoid` on `a -&gt; a`... This doesn't work mFold (Just x) = x mFold Nothing = mempty but this does mFold (Just f) = f mFold (Nothing) = id even though, if I understand correctly, `id` is the `mempty` for `a -&gt; a` so both should work identically?
The problem is what instance you are using. In your case, you have: fmap (++) Nothing :: Maybe ([a] -&gt; [a]) which implies that `fold` is considering `[a] -&gt; [a]` as a `Monoid`. The instance that matches this shape is `Monoid b =&gt; Monoid (a -&gt; b)`, and that does not give the behavior you expect. Instead, what you want is to have: fmap (Endo . (++)) Nothing and apply it using `appEndo`: λ appEndo (fold (fmap (Endo . (++)) Nothing)) "World" "World" 
Streamly is pretty new. I have done comprehensive benchmarking against most popular libraries, and it seems to be doing better than other libraries in many cases and worse in some others. I have not finished optimizing it yet, I will try publishing the benchmarks and the results sometime in near future.
A desirable property of `groupBy` on streams is that it doesn't force you to keep entire groups in memory at any time. For example, imagine that you want to split a incoming stream of text into lines, without having an unusually long line arrive and clog your memory. `streaming` represents that by parameterizing the stream with a functor... that is another stream! The idea is that the outer `Stream` represents line divisions. When you "unwrap" a step of the outer stream (using something like [next](https://hackage.haskell.org/package/streaming-0.2.0.0/docs/Streaming-Prelude.html#v:next) or some other higher-level function) you encounter another `Stream` which represents a streamed line, which you must go through and "exhaust" to arrive at the next `Stream (Stream (Of a) m) m r` and repeat the process.
Boom, rekt
Hello everyone! I'm the maintainer of `universum` at the moment. And I'm really interested in getting as much feedback as possible. Personally, I like `universum`, but I think it might be not so convenient for everyone. And I guess that the reason for this is that it doesn't get much feedback at the moment. So, please, share your thoughts on what you find useful, what you hate, comment on issues (or just add :+1: or :-1: reactions), or even create new issues! I appreciate this a lot!!
Thank you! 
Why don't you seperate that into an project-independent prelude and a project-dependent one? I mean if it works for you then it works, but according to my taste I would split it up a bit further.
I do this too. I have this rule that every module only gets to have one unqualified mass import. That way, assuming you know that the code compiles, if something is used unqualified and it's not defined in the module itself and it's not imported individually, you *know* it must be coming from the one mass import... which is the custom prelude. (This rule also applies to the custom prelude itself, which only mass-reexports the normal `Prelude` unqualified and everything else is specific.) I also don't think there's any sense in writing the same standard imports over and over and over again in every file, so when the names wouldn't conflict (or be ambiguous to the reader) anyway, I prefer to just do it once.
Yes, you can replace `fold . fmap f` by `foldMap f`.
There's also [this](https://github.com/joom/th-new).
Thanks for the response! I'll be interested in seeing the results.
Thanks for the explanation! :)
I am absolutely interested.
Then I'll write some more explanations on readme in a day or two.
This sounds very similar to something I am doing. https://github.com/McGizzle/crypto-binder Send a me a dm with your thoughts. 
Thank you for writing this! I don't have anything useful to add, but as a beginner I found this to be amazingly helpful. Especially the extensions breakdown.
&gt; Nix is an alternative way to manage Haskell dependencies, and it seems pretty cool. It has a reputation for being large and complicated, and that reputation does not seem especially unfair, but you get lots of benefits if you’re willing to pay the cost. Unfortunately, I have never used it (though I’ve read a lot about it), so I can’t comment much on it here. Perhaps I’ll try to go all-in with Nix when I purchase my next computer, but for now, my workflow works well enough that I don’t feel compelled to switch. My experience with Nix has been consistently poor. I think this is because it's still rough around the edges, perhaps it's OS X that it's not good on. But every single time I've been handed a project to work on and it has a simple Nix one liner to run in the README, I do this: (1) install Nix fresh, (2) run the suggested Nix command verbatim, (3) wait 5 minutes while the screen scrolls, (4) read the resulting inscrutable error message and copy/paste it to the Nix guru on the team working on that project. The answer has so far always been "I have no idea what's going on there". It might be that when Nix works, it just works flawlessly, so people aren't used to debugging its output when it falls on its arse. In theory I like it, though.
Funny, my fist nix experience was precisely this. Also on OS X. 
&gt; When I write in most programming languages, I must constantly accept that my program will never be robust in all the ways I want it to be, and I might as well give up before I even start. Haskell’s greatest weakness is that it tempts me to try. Very true!
also: stack test -j 8 --fast --haddock-deps --file-watch
I ran into this issue as well. The underlying cause is that the boot.tar has not been updated with the patched boot packages. You need to run utils/makePackages.sh and then utils/updateBootArchive.sh . You will then need to rebuild ghcjs-boot so that the updated data files are installed to the correct place. It is possible that your other issue is related to this as well.
`file-embed` is really clever; I learned about it while contributing to `datasets`
One that takes ages to build, too. But don't get me wrong, the Kmett-o-verse is a fascinating place
Nice, I did another tool for the plotting in the terminal, but less ambitious: https://github.com/jimenezrick/termplot brick rocks! :)
The observation that lenses are almost dynamically typed is pretty interesting. I implemented lenses a couple times in their different incarnations while learning them and the process is very much type tetris after writing the core aliases. Preferring specialized (or at least scoped akin to lens-aeson) lenses for frequent abstractions might help with this? I think most of the problems crop up because of type classes but those are kinda hard to avoid if you want to keep indexed lenses. Anyway, I found the use of TypeFamilies and DataKinds without TypeInType interesting. I usually just flip it on for type programming since it removes the small bit of confusion when trying to promote a type with fancy kind. Haven't run into any annoying bugs so far, can that extension reasonably be used yet in real code?
Also notice that your second case, `[[a]]`, matches the third one (`x` being `[a]` and `xs` being `[]`) and does the same thing so you can remove it.
Cool stuff!!
That's very neat, thanks for sharing! I've been thinking about how the heck should I fit multiple data sources to the screen and how to get the data, your way looks really cool :). After logging in to GitHub it actually seems like I've starred your project quite a while ago, small world :D!
I ran into a related problem; I wonder if this approach would extend to it. I wanted to use TH to check the type of an expression. The API only has `reify`, which works on `Name`s, and I can't bind the expression to a name because of the stage restriction.
That doesn't seem to be enough. `llvm-hs` is looking for a `llvm-config` executable. Would it help to extend the `bin-path` stack uses, and if so how can I do that?
Very cool!
Nah it’s better than that, it’s domenkozar
This is a neat trick, and it’s good to know, but I don’t really like `RebindableSyntax`, so I probably won’t use it.
Are you sure these fears are well founded? None of your examples had a profitable business model if they had one at all. Not arguing against self hosted infra but this sounds a little like fud. (In my personal opinion, github's one of the least evil software companies in the world right now, would hate to have them dismissed just because it's not old.)
Wow, thank you! Wouldn't have gotten the idea to try this without bumping into the Brick wall :). Thank you for all your work!
Read this: https://hackage.haskell.org/package/vty-5.20/docs/Graphics-Vty-Input.html I'm on mobile now so I can't give a very detailed answer, but the tl;dr is: keyboard input is a mess. I wouldn't do this to yourself especially if you're a beginner. You will probably spend most of your time learning about keyboard input and no time learning about haskell.
&gt; The problem is that the type errors suck I wonder if it would be possible to use some of GHC 8(?)'s custom type error facilities to make this better? Honestly, even just straight up substituting the type aliases back into the type messages rather than the expanded types would likely go a long way towards making the error messages cleaner...
We shall see. Call me naive and paranoid, but making yourself dependent an entity that is using you to generate a profit rarely turns out well. Why not just accept the incentives for what they are and pursue better systems? I do depend on a lot of things, like Linux, Haskell, etc, because as I see it, these communities are not designed to exploit people like me, but designed *for* people like me.
Is the `-j` option implicit in `stack build --fast`? Specifying `-j1`, for example, reduced the speed of my build.
Make sure your nix guru has a Mac to test stuff on! The stuff in nixpkgs is often broken for certain versions of macOS and not for linux, but the alternatives (homebrew and macports) are in my experience at least as bad. To make it reproducible it is a good idea to pin the nixpkgs used to a version you know works for your project. This is the equivalent of specifying a `resolver` a `stack.yaml` file. Here is how it is done in Leksah's [default.nix](https://github.com/leksah/leksah/blob/master/default.nix#L3). My workflow for debugging tricky nix build issues is typically: * Run the broken `nix-build` with `-K` to keep the temp files. * `chown -R hamish` the temp files (only needed if you have multi user install of Nix). * Look for the `/nix/store/#-broken.drv` that failed (near the end of the output). * Run `nix-shell /nix/store/#-broken.drv`. * `cd` to the temp files. * Rerun the broken phase manually with something like `NIX_DEBUG=9 eval "$compileBuildDriverPhase"`. * Poke around with temp files and the environment to figure out what went wrong. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [leksah/leksah/.../**default.nix#L3** (master → 81f5c06)](https://github.com/leksah/leksah/blob/81f5c06dcc918067611baba53b376dbb2e3ff57c/default.nix#L3) ---- 
&gt; Run `nix-shell /nix/store/#-broken.drv`. Adding to this, it's also useful to run `nix-store --read-log /nix/store/#-broken.drv` to isolate the log output of the derivation that failed.
What are the benefits comparing to a simple stack build? 
I don't use Windows, but where does the Linux subsystem fall here? Does brick work there?
1. Binary caching is freakin ridiculous. I can't really imagine working on a large project without this anymore. Though in theory there's nothing preventing stack from adding something like this 2. The sheer level of control you can acquire in a pinch is pretty useful. Like the ability to apply patches to dependencies without having to clone or fork them is quite nice. 3. System dependencies can be pinned. *Super* important IMO. The most common breakages I had when I used Stack had nothing to do with Stack. 4. The functional, declarative style is sweet. Makes it insanely easy to manipulate things in a really composable way. For instance, I'm planning on writing an (awful) Nix combinator that takes a derivation, dumps its TH splices, then applies those as patches so you can cross compile derivations that use TH. This will literally just be a function in Nix. Very convenient to use. 5. Deployment with NixOS is super easy. You define *you're entire system* declaratively with Nix modules. You can build the same configuration for VMs, containers, local systems, and remote systems alike and just deploy to whatever suits your needs. I use this to setup local dev environments in a NixOS container that match what I would deploy identically. These NixOS modules are composable too, so you can piece them together like lego blocks if you want. 6. Hydra is *pretty cool.* I wouldn't call this a killer feature of Nix, because it's such a massive pain to get going. But once you understand it, it's definitely a lot more sane than other CI services. 7. Nixpkgs provides a much more composable concept of package management. Having the ability to just import some other complicated Nix project and not have to redefine all of its dependencies or systems is really nice. 8. NixOS has this concept of "generations" and "profiles," which are a really modular way to talk about system and user upgrades, and make rollbacks completely painless.
Just to expand on this a little bit, it would be possible to do something like this with conduit as well. For example, `ConduitM i o m (ConduitM i o m a)` to do one stream after another. Then, `type T = ConduitM i o m T` for a "stream of streams". However, the truly genius part of what `streaming` does in my opinion is that the functions in "Streaming" will still work and do what you expect on a "stream of streams".
Reminds me of the terminal-based graphing calculator program I wrote, though that's C and not Haskell: https://github.com/flarn2006/MiscPrograms/blob/master/graph.c Someone made a video of it here: https://www.youtube.com/watch?v=FZwwS6RLHFM
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [flarn2006/MiscPrograms/.../**graph.c** (master → 582c906)](https://github.com/flarn2006/MiscPrograms/blob/582c906d5f940a860b4aee2eba384130661ab114/graph.c) ---- 
First, use code blocks for your post. Put the code on a new line and indent 4 spaces. Second, you just compose them, with an uncurry thrown in. shuffle 0 = id shuffle n = shuffle (n-1) . uncurry riffle . split 
It fails because it's not native windows. There's nothing inherently Linux about displaying graphs and charts, so the fact that this is Linux only is really due to an abstraction problem from a lacking ecosystem, something that is slightly embarrassing for a language like Haskell whose ecosystem often brags about how generic and general it's libraries can be.
I would say that this issue is overblown. Sure stack downloads and compiles for your first project. But the rest of them on the same machine using the same stack lts will reuse compiled packages. 
&gt; Calling this "embarrassing" is like saying it's "embarrassing" that Windows doesn't support some arbitrary Unix application. It's an unhelpful way to characterize the situation That's fair. I suppose it's also unfair of me to mention this when, like you said, an incredibly low amount of people have actively expressed interest in this sort of thing. Perhaps it would be a good HSOC project to work on making more platform agnostic versions of popular "utility" libraries...
Eh, it's super nice on laptops. I can usually count on being able to grab a cup of coffee before I run stack build on anything I've cloned from a git repo for the first time. I also like to change my lts to the newest one fairly frequently because I have no reason not to for small personal projects, so that exasperates the issue.
I think you have to have it before you realize what you're missing without it. We have a pretty big in-house dependency graph at work that changes often, and not having to rebuild all of that when we update something lower down once or twice a week is a huge time saver. But perhaps more importantly, projects like reflex-platform, which change lots of low level stuff often, benefit a ton from the cache, especially since it's building custom cross compilers and stuff.
The initial setup hurdles are what stopping me from using it. I even tried to install it once, only to find out after several hours that nix is currently broken on archlinux. Also I hear all the time that packages on nix often fall behind because maintainers have no time to keep up with current hackage. Stack is also reliant on hackage. But at least it has a big and very active community that keeps things in sync. And finally, I recognize that nix perhaps is more useful to people who use custom toolchains like ghcjs - reflex - reflex-dom etc.
Yeah, I've never actually used it except to see if it would work, but there's still a big part of me that *wants* to use it.
thank you, i think this should work. Sorry to bother, but is there any tutorial of how to use vty? because the documentation isn't very clear at least for me. The only thing I need to do is map an especific keystroke (Key) with certain action, for example just making a putChar.
Spiritually Nix is very similar to Stack (i.e. curated package set), but it also works for things that are not entirely written in Haskell. For example, suppose that you are trying to build a larger system where Haskell is only one component in that system. With NixOS you can specify the entire system as one complete Nix expression that can have your Haskell project as one dependency of that system.
I'm glad some of us are working on overcoming the TH stage restriction limitation. Thanks for sharing /u/terrorjack. I wonder how easy or hard it would be to solve this properly on the level of GHC though. Anyone knows? And while we are at it, maybe we can even overcome the issue of splicing, i.e. that having declaration splices break the recursivity of declarations above and below them.
Unfortunately, even if I can obtain the type via ghc api, there is no way I can bring the type back. Only values of known type can be retrieved. To type check an Exp and bind it to a name requires work at the level of ghc.
I haven't tried porting this to GHC though. Ideally it would be just adding a few methods to the Quasi class, and a bit of more tinkering.
&gt; Setting up a remote binary cache is not trivial Really? It's two lines in a config file. I agree it's not well documented though. Nix-darwin makes it even easier and is actually kind of documented. &gt; There's no easy way to build binaries that can run on really old existing servers. This sounds a little nontrivial either way :P Short of just building on the server itself. But yea, that is actually going to be a lot easier than making Nix do it. &gt; I have not run into this personally, but my coworkers found that nix-on-docker-on-mac is even less reliable than nix-on-mac. I have heard the opposite. But I also haven't tried I personally.
Yeah, this was just superstition on my part. I’ve expunged the explicit uses of `-j` from the blog post.
&gt; &gt; Setting up a remote binary cache is not trivial &gt; Really? It's two lines in a config file. Oh, you meant using an existing cache. I meant maintaining the cache itself. We needed to do things like build our own GHC to work around nix-on-mac issues (IIRC). I remembered one more issue I had: * When trying to build after making an edit, `nix-build` couldn't reuse partially built Haskell artifacts (because it tried to get an isolated environment), which cost a lot of time. Is there a better way to develop multiple interdependent packages?
It compiles and works in WSL, that's something :)..
Yeah, in other languages you can blame it on the language. In Haskell, you know it's your stupidity :)
&gt; With NixOS you can specify the entire system ... I think it'd be good to emphasize that "entire system" here means down to the kernel compilation flags.
Even less ambitious thingy I did to monitor all my Ryzen cores while doing stuff: https://gitlab.com/dpwiz/coregram Maybe I should consider brick too, for extra fancy.
&gt; join ((\() () -&gt; baz) &lt;$&gt; (foo &gt;&gt; return ()) &lt;*&gt; (bar &gt;&gt; return ())) This doesn't seem right, isn't the whole point of `ApplicativeDo` avoiding a `Monad` constraint whenever possible. This desugaring introduces one through the use of `join` unnecessarily.
I have a [project](https://github.com/danidiaz/streamy/tree/master/streamy-sig) that tries to give a common interface to streaming / pipes / conduit using the Backpack module system (it could also serve as a kind of "streaming rosetta stone"). I remember that I didn't manage to implement streaming-like grouping funcions for `conduit`, but I can't remember what was the exact roadblock.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [danidiaz/streamy/.../**streamy-sig** (master → 2d16756)](https://github.com/danidiaz/streamy/tree/2d167569f3a3ea82eeb1b664d444a5c637618859/streamy-sig) ---- 
&gt; Is there a better way to develop multiple interdependent packages? `cabal new-build` works really well inside a nix-shell. ElvishJerricco has added a cool feature to reflex-platform that helps create a shell suitable for working on multiple packages with `cabal new-build`. The instructions are [here](https://github.com/reflex-frp/reflex-platform/blob/develop/docs/project-development.md). Once it is set up you can run: nix-shell -A shells.ghc This will drop you into a shell with all of the dependencies of your packages installed in `ghc-pkg list` with nix (but it will not try to build the packages themselves).
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [reflex-frp/reflex-platform/.../**project-development.md** (develop → b365d0b)](https://github.com/reflex-frp/reflex-platform/blob/b365d0b3f55ebcca0c6f8517b20cf5d0b7b1cd37/docs/project-development.md) ---- 
[Serokell's](https://github.com/serokell) team seems to be a main power behind [cardano sl](https://github.com/input-output-hk/cardano-sl/blob/develop/CONTRIBUTING.md#code) development and Universum is a project of Serokell.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [input-output-hk/cardano-sl/.../**CONTRIBUTING.md#code** (develop → 0ceca33)](https://github.com/input-output-hk/cardano-sl/blob/0ceca33c290f07ecdbb6ee8789dcdeef8e2d8d93/CONTRIBUTING.md#code) ---- 
 {-# OPTIONS_GHC -Wall -Werror #-} is my preferred way to the the flags because I couldn't figure out hot to set them in package.yaml 
I'm currently using Stack's Docker integration on macOS to build my web apps. Then I upload the web app binaries to a Linux web server. (I use the same Docker image on both the Linux server and the local macOS machine.) I'm not sure yet what Nix can add here. I was thinking of replacing my Docker setup with Nix, but that would require me to switch to Linux for local development or compile my web app on the server. (The latter makes little sense IMO.) Am I missing something? 
If you need Control.DeepSeq so frequently that you put it into your Prelude, something is wrong.
&gt; Hydra is pretty cool. I'm looking forward to this project: * https://github.com/hercules-ci/hercules
I had a little bit of difficulty figuring it out too: ghc-options: - -Wall - -Werror default-extensions: - BangPatterns [...] 
``` ghc-options: - -Wcompat - -Wincomplete-record-updates - -Wincomplete-uni-patterns - -Wredundant-constraints ``` This works on top level and per-target too.
One use I find for `-j` is to _decrease_ the parallelism intentionally to leave one core free (e.g. `-j3` on a 4 core machine) when compiling on my laptop so that it's still usable during the compilation process.
Iirc there are simd primops in `GHC.Prim` that only work with the llvm backend, but they will never be generated from normal code and need to be used manually
These are really, really good though. I just go directly to YouTube.
Header, video player and the footer is fixed, I just want to browse the shownotes :(
Glad to hear you like the `sdl2` library!
Yes the primops were added as part of the wip/SIMD branch itself: https://github.com/ghc/ghc/commits/wip/simd
I tried that responsive player view for a while, but it worked best on desktop. I've removed it now as it probably just gets in your way. Try force-reloading the site and should have regular scroll.
Thanks! LGTM now! :D
not for me :p you can download a package with lens and haskell-src-meta dependencies (i.e. with many transitive dependencies and a slow build), for three compiler versions, in like a minute. Building them the first time took me an hour. You might not value that (and I didn't when I was using cabal sandboxes, but I began to when I switched to stack, and now even more that I switched again to nix), but it's literal order of magnitude (hours to minutes). Like, I've been recently testing my packages for wider compatibility (compiler versions and flags), because it's so quick and easy to, whereas beforehand the delay made me reluctant. And, stack wasn't even always sharing (but was caching) binaries locally (though a developer told me it's a bug that's getting fixed), since I like fragmenting my packages and cloning random stuff, so that was wasting disk. 
Relatedly, I began feeling some aversion to foreign dependencies, despite many packages being performant/featured/tested by binding a popular C library, because of how frequently they failed to build for me and/or how much effort it took to install. With nix, packages depending on foreign libraries almost always just work, because they're tracked. tbf, using stack's `nix` integration is a reasonable compromise. 
very much. thank you all for your hard work!
fwiw, I've done some type level programming with records, and I've never needed TypeInType yet. 
Except for DPH (which has sadly been in a state of suspended animation for many years now), the design as written on that page is fully implemented. However, there are a few [issues](https://ghc.haskell.org/trac/ghc/query?status=infoneeded&amp;status=merge&amp;status=new&amp;status=patch&amp;status=upstream&amp;keywords=~SIMD&amp;col=id&amp;col=summary&amp;col=status&amp;col=type&amp;col=priority&amp;col=milestone&amp;col=component&amp;order=priority) which reduce the usability of the feature as it's currently implemented: * The is no support for shuffle operations, which makes some applications difficult or impossible to implement. * The operations are only supported by `-fllvm`; adding support to the native code generator would be a great project for someone (see [#7741](https://ghc.haskell.org/trac/ghc/ticket/7741)). * Prior to 8.4 GHC would [spill AVX vector arguments](https://ghc.haskell.org/trac/ghc/ticket/8033#comment:32) to the stack instead of passing them in registers; this almost always erases any benefit had from using these operations. Despite these limitations, it is quite possible to use the implementation in its current state.
Yes. During development I normally use one `cabal new-repl` per package that I am working on and restart it when its dependencies have changed (that triggers a new-build of the dependencies if needed). I actually let Leksah run the `cabal new-repl` and send the `:reload` commands for me (but other options like running `ghcid -c 'cabal new-repl'` also work). Leksah can also run `cabal new-build` after `:reload` works and then runs the tests (highlighting doctest failures in the code). One feature still to add to leksah is that it does not currently restart `cabal new-repl` when dependencies change. So you have to do that manually still by clicking on the ghci icon on the toolbar twice (I'll fix that soon). I still run a `nix-build` before pushing any changes of course. It typically will have to rebuild all the changed packages from scratch and rerun the tests, but I don't think that is necessarily a bad thing.
Yea giving brick windows support would be a great HSoC project! You should submit a PR to the ideas page if no one has already.
thank you, that was of great help!
We have it in our prelude (not `universum`) too, because we need to write `instance NFData OurDomainType`.
I agree, `NFData` instances needed quite often. Also utility functions like these ones: * https://github.com/serokell/universum/blob/master/src/Universum/DeepSeq.hs You will have `deepseq` package as an indirect dependency of your big enough project anyway.
FYI, I've already been looking around for interested parties: https://www.reddit.com/r/haskell/comments/7tutxa/vty_needs_your_help_supporting_windows/
Your blog/library on testing and design of effects for testability was one of the three approaches I was considering adopting. Hopefully you keep exploring that space and stay working in Haskell.
There are a few things that the Nix ecosystem can offer for that sort of use case First, you can use NixOps to provision and deploy the server that you deploy to. NixOps can reuse an existing host that you've already provisioned or provision one for you such as an AWS instance. You can do this on OS X, too, if you run a Linux virtual machine locally to use as a build slave (the same way that `docker` works on OS X). For example, my work laptop and personal laptop are both OS X and I use both to deploy to Linux machines. Second, you get "pushbutton deploys". For example, suppose that you use NixOps to deploy your server. You make a Haskell change and the run `nixops deploy` and it will compile your Haskell project and deploy the diff to the server. This gets more useful the more complex your system is because without Nix you typically wind up with complicated pipelines for publishing changes to production the deeper they are in your stack. Here are some examples: * Using Nix/NixOps I can easily patch GHC (it's just a few extra lines of Nix code) and then run `nixops deploy` and everything downstream of `ghc` will get rebuilt and deployed automatically. * We have build hooks at work written in Nix to generate Haskell bindings to gRPC services from `.proto` service definitions. If we update the tool that generates Haskell bindings then all projects that depend on that tool are automatically updated and rebuilt by Nix. We don't have to remember to do it ourselves (which is error prone and time-consuming) Another useful feature is Nix's support for [NixOS tests](https://nixos.org/nixos/manual/index.html#sec-nixos-tests). These make it really easy to author integration tests to make sure that your component plays nicely with other components. However, I think the best way to get started is to just try playing with NixOS because that's the first thing that introduces you to the idea that Nix manages multiple abstraction levels besides just a package manager. Once you try it out then it will be more clear how it generalizes to other use cases and how it relates to containers. Also, NixOS does supports `systemd-nspawn` containers, too, and I prefer them to `docker` containers. However, I found that most things that people use `docker` containers for are better served by using NixOS without containers.
RemindMe! April 20th, 2018
I will be messaging you on [**2018-04-20 02:18:45 UTC**](http://www.wolframalpha.com/input/?i=2018-04-20 02:18:45 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/haskell/comments/6x7ms0/category_theory_for_programmers_has_been_finished/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/haskell/comments/6x7ms0/category_theory_for_programmers_has_been_finished/]%0A%0ARemindMe! April 20th, 2018) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
I'm the maintainer of Vty and the author of Brick. Please feel free to get in touch with me directly if you need help, and also check out the various help resources in the Brick README. Since I took over maintenance for Vty I have not invested as much time into it as I have for the Brick documentation, so contributions are very much welcome there!
Author here. Feel free to ask questions or point out issues/mistakes/typos.
Strongly typed new types over string types require polymorphic string literals unfortunately.
I think RDB has better migration tools, when I read the early architecture post, the data migration part let me feel unacceptable 
This is simply amazing! Thanks so much!
It would certainly be better sticking to standardized tools and workflows, but in our case, the data is already there and all we are doing is a refactoring in the way migration code is written, not big architectural changes :)
If you enable this extension, instances no longer have global scope. They are still coherent, in the same way that all data types are coherent.
Surprisingly, no one has mentioned `basic-prelude` or `safe` yet - those two give us the fundamentals done right.
A simple article with a not-so-complex example that gets the point across - now that's a rarity in the Haskell world. :P Jokes apart, great article and I look forward to the next one in the series. I never got around to learning about the `mtl` and `transformers` packages because their documentation isn't quite beginner-friendly.
Maybe another one can chime in, but I think this is related to: www.cs.cmu.edu/%7Erwh/papers/intensional/popl95.pdf
&gt; data Matcher a = forall m. Matcher (Traversal' a m) Why not `type Matcher a = Traversal' a ()`? (`focus m = Focus [m . united]`)
Is there a way to launch Haskell scripts on windows? On a Ubuntu machine I can simply add magic lines to my file ``` #!/usr/bin/env stack -- stack runghc --resolver lts-10.4 --install-ghc ``` then `chmod +x myAwesomeScript.hs` and the script is ready to be used. The best I can do atm on windows is to run `stack runhaskell myAwesomeScript.hs --resolver=lts-10.4` in my powershell, which kind of defeats the purpose of having this script. All ideas are welcome=)
Any plans for putting it on hackage? :)
Hmm, not a bad idea. Gotta check how that's done :). Thx!
No, the show notes should contain the same information as the video. As stated in the summary, you should indeed be very careful about using this technique, as it's harder to understand and might not give you much benefit. What I wanted to show with this video was not how to avoid regular recursion and pattern matching, but to show the coupling between Reporting and Project, and how to make the Project data type extensible (with Attr) in a generic way. With this technique you'd probably do traversals and transformations using the Fixplate operations, rather than using regular pattern matching. I was actually skeptical about making this video in the first place, as it's so easy to jump to the conclusion that "more advanced is always better." That's not at all what I'm trying to say. There should be a big "YAGNI" warning sign to recursion schemes for practical Haskell programming, IMHO. The first time I encountered them in a project I had to start reading up to get anything done. I'm not saying learning a new thing is bad, but it did require some extra time. Nonetheless, to give a fuller picture, I wanted to highlight the "last flaw" in the WriterT approach from the previous video. It was not a big problem, but one that seemed interesting enough to me. Hope that clears things up a bit. :)
I think the series should highlight just that, how different techniques give you different benefits/trade-offs. At least that was my goal. :)
 - -Wincomplete-record-updates - -Wincomplete-uni-patterns Golly gosh goodness we mightn't need these for much longer! https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0012-Wall-uni-patterns.rst 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [ghc-proposals/ghc-proposals/.../**0012-Wall-uni-patterns.rst** (master → 9f415df)](https://github.com/ghc-proposals/ghc-proposals/blob/9f415df405a00f4a1df59843c37e080b86acb07b/proposals/0012-Wall-uni-patterns.rst) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply du4fwxg.)
I don't think this is the way you are meant to add developer dependencies. The correct way I think would be to define a helper function which adds the dependencies to the .env attribute. I have `mkHaskellShell` defined in a global overlay but inlined it here to present everything in a single file. https://gist.github.com/mpickering/4832285a86a218a477804804aabede1e 
&gt; e.g. RHEL6, which has an old glibc Could you elaborate on this? As far as I can tell, nix-built binaries should be linked against the glibc from nixpgks (I checked on my system) and thus should work no matter how old your host OS or glibc are.
&gt; And all but one of those cases was 100% Apple's fault in an OS update, breaking some extremely simple thing you'd never expect anyone in the right mind to even change. It seems like Mac OS is simply not a very developer-friendly environment. I'm not using it myself, but I've heard from many that do that they are frustrated about how Apple breaks their tools with arbitrary bugs and changes delivered via updates, and that they consider switching to Linux to get a better UX. For example, they shipped an update in Sierra that [broke nix](https://github.com/NixOS/nixpkgs/pull/27536) by introducing an arbitrary limit on how many shared libraries you can link against. (Note it would break any other Haskell build tool as well if you put enough dependencies into `build-depends`, nix just found it first because its paths are slightly longer.) Apple discourages static linking, but now also punishes you for dynamic linking. That doesn't seem to make any sense.
Also rarely known: You can download all haddocks for an entire Stackage snapshot, so that you can access it offline during journeys without Internet. There is a little link `Download documentation archive` on each [snapshot page](https://www.stackage.org/lts).
using QuantifiedConstraints, is it possible to write: class (C a =&gt; B (F a)) =&gt; B a where .... so that for all instances of B a that are also C a are required to have (F a) as an instance of B. I don't know whether this makes sense and is even part of QuantifiedConstraints, since there is no forall. 
Could you have 2 different Ord instances for the same data-type? Could 2 Map values of that same key type exist in different places? 
Can't you do that without QuantifiedConstraints? On mobile so I can't test, but it would definitely require `FlexibleContexts` and probably `UndecidableInstances`: instance (C a, B (F a)) =&gt; B a where
is this the same? I have an Implication in my constraint, I don't think this is the same as `(C a, B (F a))`.
maybe my intuition what the implication means is wrong 😉 I should look into the proposal, I guess it's defined there. My understanding: `instance (C a, B (F a)) =&gt; B a where` "for a to be an instance of B, a has to be an instance of C and F a and instance of B" `class (C a =&gt; B (F a)) =&gt; B a where` "for a to be an instance of B, if it is an instance of C, F a has to be an instance of B"
Ah I see the difference now. I don't think the extension will cover that. The usefulness of that seems to be the ability to define `B a` while only conditionally requiring `C a =&gt; B (F a)`. I think the open world assumption would never allow you to create such an instance that doesn't have a `B (F a)`, because you can never prove that there is no `C a`
It's been a while since I ran into this, and I didn't fully understand it at the time either, but here's my best shot at explaining it: There's an intimate interaction between the kernel and libc, which means that you can't run a program built against too new a libc on too old a kernel due to abi incompatibilities. I'd love to be proven wrong, though.
It did a pretty great job at that! I just felt, particularly with the last post, that once there's a certain level of abstraction that's hit, it's really hard to see immediate benefits. For example, you mention that there's some trade-offs with the most abstract way of doing things, but there aren't any concrete examples of the benefits and what they enable you to do. One thing I particularly liked about [this post](http://storm-country.com/blog/gof-strategy) is that when it gets complicated with the `Monad m` in the type signature, it gives concrete examples of how that's just a generalization of the previous stuff and shows how you can recover the other functions easily; the hidden bonus, random sorting, etc., also give a really concrete feel to "oh hey this abstraction can really pay off" I do want to stress that I've really been enjoying your articles and that this isn't a criticism; they're already awesome :)
That's exactly my feeling, as someone stuck developing on a Mac, but it's not usually bad enough to justify developing in a VM (and the NixOS virtualbox image didn't work), and it's certainly not bad enough to justify moving an existing Mac team to Linux (from an organizational standpoint).
OK, I see your point. :) It does get tricky to squeeze in examples as I want to keep the videos &lt; 10 minutes. I think when it's about these kinds of techniques I'll just be able to scratch the surface and hopefully inspire further learning. Sorry if I sounded defensive and irritated, and thanks for your kind words!
I don't believe windows has shebang support. You can associate a file extension with a program, which would be the interpreter, but that's about it.
&gt; For multiple big projects I had to go through all files and move language extensions from the cabal files to the top of the files, before being able to use the tooling I needed in order to solve a problem. Depending on the size of the project, this takes hours to tens of hours. It sounds to me like your time would be better spent fixing broken tooling to read the `default-extensions` list out of the `.cabal` file rather than occupying yourself with such busywork. `stack repl` and `cabal repl` cope with `default-extensions` just fine, so I’m not sure what the `ghci` problem you describe is. You make it sound like this is some looming disaster, but I wrote Haskell professionally for two years, and all the tooling I used was able to understand `default-extensions`. It sounds to me like the tools that don’t are the problem here, not `default-extensions`.
The Currnet simd primops have the wrong design for a lot of reasons, and I’ve been meaning to put together a proposal to change them. Good quality simd code 
My haskell knowledge is a bit rough on some edges...i thought there is not open-world assumption with typeclasses? Can't the compiler check whether an instance is existing? I know that it's always possible to add further instances, but I don't see how this would prevent this feature. Wouldn't this be possible: Typecheck and see whether this instance could be found, if yes check if F a has an instance, if not it's not valid. I mean the mechanism for checking whether a typeclass has an instance is already there, or am I missing some details?
I am a bit confused, but the compiler tells me when no instance is found and just doesn't crash at runtime?
It knows which instances it can see but doesn't guarantee that can see all possible instances. -- Foo.hs module Foo where data A = ... -- Bar.hs module Bar where import Foo instance Show A where ... -- Baz.hs module Baz where import Foo baz :: String baz = show A -- Error, can't find `Show A`. If we added `import Bar` to `Baz.hs`, the error would go away. So Haskell knows about a potentially inexhaustive set of instances.
I'm not a Haskell developer nor Nix user, but I find Docker is surprisingly convenient, if only for its immutable layers file &amp; build system: as I test different packages, I only pay for what's changed or removed, not the full setup. For example, for a C library, you might start with RUN apt install -y build-essential RUN apt install -y libopenssl-dev RUN cd src &amp;&amp; ./configure but if libopenssl-dev is the wrong package, change that line, and rebuild, and the build-essential installation isn't redone, only what's change and subsequent lines. Any sort of snapshotting at file system level (e.g. ZFS) would do the job as well, but Docker puts it together in a convenient way. I guess Nix is better by using a DAG, but it's probably more complicated and harder the reason about (at least for those of us lacking in headspace).
 substr n len = take len . drop n matcher a b = substr 1 2 a == substr 1 2 b matcher "A17F838D8" "B17DSDSK"
Yes, I have already discovered that shebangs do not exit on windows. But maybe there wasa way to set up the interpreter (not windows!) to respect shebangs. Also, I found that with `git bash` terminal emulator on windows you have the support of shebangs. However, using two different terminals at the same time is not really practical.
The point-free version of that is pretty nice as well: import Data.Function (on) matcher = (==) `on` substr 1 2 And of course there’s the stupidest hardcoded thing that could possibly work: matcher (_:a:b:_) (_:c:d:_) = (a, b) == (c, d) matcher _ _ = False 
A somewhat less general approach: do2nd3rdmatch :: String -&gt; String -&gt; Bool do2nd3rdmatch (_:a1:a2:_) (_:b1:b2:_) = if a1 == b1 &amp;&amp; a2 == b2 then True else False do2nd3rdmatch _ _ = False This approach uses pattern matching to extract the second and third character of each string and returns `True` if they are both the same. Also if the patterns don't match (for example, this would happen if one string was less than 3 characters) then it will return `False`. Since you're starting out with Haskell, don't worry about this *too* much but keep it in the back of your head - The default `String` type is actually an alias for a list of `Char`. There's no way to perform random access - to get a specific character, you have to traverse the list up to that point. More efficient types are `ByteString` from the bytestring package (but it's just an array of bytes, so stuff like Unicode characters may not work the way you expect) and `Text` from the text package (this still requires O(n) access for characters but it's backed up a more efficient type than `String`). You can find the mentioned packages on [Hackage](https://hackage.haskell.org/). I recommend using [Stack](https://docs.haskellstack.org/en/stable/README/) to manage your installed compiler and package versions but there are certainly other approaches that would work also.
Which 'Prelude' are you using and what set of packages you almost always import? 
Now there are two hundred of them!
**Reported for referral link spam.** https://www.reddit.com/user/UnkindTabore/submitted/ https://www.reddit.com/user/fegertsa/overview/ https://www.reddit.com/user/trukirukia/submitted/ https://www.reddit.com/user/buyuksd/submitted/
Thanks for the response!
Appreciate it, thanks!
Thanks for the thorough response! As a beginner I really appreciate the explanation, it's easy enough to copy and paste some code but actually understanding it is something else :) I'm having to use an online compiler at the moment as I'm away from my computer, and when I'm trying to run the code I'm getting this error: [error](https://i.gyazo.com/e6a0ba23e998ae8212d978a478426dc7.png) Could you point out where I'm going wrong? Thanks! 
For GADTs like [`Message`](https://git.haskell.org/ghc.git/blob/f489c12c9fe4e24dce55269e6998323fd1d9b2a4:/libraries/ghci/GHCi/Message.hs#l63) mentioned about `Binary`, it seems that the main obstacle is defining *Rep*, which the first part of the post addresses without quantified contexts. Quantified contexts would help with the existential wrapper `Msg :: forall a. (Show a, Binary a) =&gt; Message a`, but it is just one constructor so that is much less of an issue. Furthermore, I'm not sure what these constraints are doing there in the first place, because pattern matching on `Message` will instantiate `a` fully anyway.
[This paragraph of the Quantified Constraints proposal](https://github.com/Gertjan423/ghc-proposals/blob/quantified-constraints/proposals/0000-quantified-constraints.rst#overlap) suggests that it will be allowed.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [Gertjan423/ghc-proposals/.../**0000-quantified-constraints.rst#overlap** (quantified-constraints → 5efe006)](https://github.com/Gertjan423/ghc-proposals/blob/5efe006d531a86704e9b1cfd00a98999cfab01ea/proposals/0000-quantified-constraints.rst#overlap) ---- 
Both [Parallel and Concurrent Programming in Haskell](https://web.archive.org/web/20180117182938/http://chimera.labs.oreilly.com/books/1230000000929/index.html) and [Real World Haskell](http://book.realworldhaskell.org/) are free to read. (though former is only in webarchive atm :( )
Article mentions `ad` in one comment, but does not dtell how the libraries differ. Maybe the key is in the word *heterogenous*, but it's not described.
You didn't sound defensive at all, I really should've clarified further in my first post and didn't come off very clearly at all, that's my bad. I'm looking forward to seeing future stuff from you!
I'll repeat my /r/programming comment here: ---- Some remarks to the two Haskell books: * **Real World Haskell** (RWH) is rather old, as it was published in 2008. You can read it [online for free](http://book.realworldhaskell.org/read/). Comments in the online version show outdated and broken content ([incomplete list of obsolete features](https://stackoverflow.com/q/23727768/1139697)). * **Parallel and Concurrent Programming in Haskell** was online for free (see [author's page]), but apparently not anymore (still via [archive.org](https://web.archive.org/web/20180117182938/http://chimera.labs.oreilly.com/books/1230000000929/index.html)). It's a full-blown version of [Simon Marlow's paper with the same name](https://simonmar.github.io/bib/papers/par-tutorial-cefp-2012.pdf). [author's page]: https://simonmar.github.io/pages/pcph.html
Thanks for the note! I've added this to the body of the article.
The code is being compiled, not interpreted. So you need to type that last line into some sort of REPL. Alternatively you could make some third function testStrings = (your function with the test strings) I'd probably suggest writing: main = print (do2nd3rdmatch "string 1" "string 2") Since I think that'll let the compiler automatically run main and tell you the result?
&gt; Thanks for the thorough response! Glad to help! /u/jared--w's second suggestion should do the trick for you. The first one won't do anything since it'll just make a function that runs your *other* function - but from what you posted it doesn't seem like that would ever run. Since the online thing is compiling the code it would probably fail if you don't define `main`. The type for main is: main :: IO () And the type for print is: print :: Show a =&gt; a -&gt; IO () Basically, `a` fills in for any type, but the `Show a =&gt;` part means a must be part of the typeclass Show - which is stuff that can be converted to a string. `print` is the same as `putStrLn (show some_showable_value_here)`
Yes that works too but not composable. Can you still write the `zoomFocus` function with this definition?
This is a duplicate: https://www.reddit.com/r/haskell/comments/7x38n4/humble_book_bundle_functional_programming_has_a/
I believe this is achieving something different. The tag is on the outer level of the object, not within `key "contents" . nth 0`. 
Usually the only interaction between the kernel and any userspace program (with or without libc) is via system calls. The only way I can imagine an incompatibility to occur would be if Linux changes a system call, which is extremely rare (like it hasn't happened in 10 years or something like that, the `don't break userspace` mantra), or if you're downloading a nix binary package built against a newer kernel using a newer system call that's not available on the older kernel (which should be quite rare but possible; usually that means that if you compiled that nix package yourself, it should fail at the configure stage trying to to check if that syscall exists).
I describe the exact problem with `ghci` in the third sentence of the link I posted above: &gt; you cannot trivially [...] load a couple of different modules from different packages into one ghci by using the `-i` flag (because `-X` flags to ghci are global) `stack repl` and `cabal repl` don't handle this case, they can only load one package into the interpreter. So with this restriction, how would you do, for example, breakpoint debugging in ghci? If you want to load your application's `main` and set a breakpoint in another package of yours, what would be your approach? &gt; It sounds to me like your time would be better spent fixing broken tooling We did sink significant effort and cost into trying to make that work, but changing this part about ghci isn't easy. &gt; to read the `default-extensions` list out of the `.cabal` file With enough effort you could teach ghci to understand cabal files, but that feels a bit like a broken tool order to me ("inner tools reading outer tools' configuration files"). It's like asking that gcc could read Makefiles to automatically include header files for convenience. I wouldn't complain if somebody does that, but would as well understand if others complained that it's not the right approach. &gt; You make it sound like this is some looming disaster Excellent! ;-)
&gt; Could that transformation not be automated? I would love to have such a tool. It's not super easy though if you don't want to mess up top-level comments and so on (some people write comments before the language extensions so just prepending to the file would split the language extension section, that works but isn't nice and certainly doesn't please the people who didn't put them in for the sake of aesthetics in the first place). The reason the fixing takes a long time is that, e.g. for the use case of iterating (fast `:reload`) and breakpoint-debugging in ghci, you need to load not only your own packages via `-i` but also your dependencies. Let's say I want to fix how a bug in `aeson` breaks my code, then I first need to download aeson and move all its `default-extensions` into its `.hs` files. So I need to do the transformation not only on my code base, but any upstream dependency I want to include in my debugging. A lot of work! Thus I lobby hard now against `default-extensions` so that everybody has an easier time doing this.
Thanks for your detailed answer! The slight inconvenience of copy-pasting the same headers is a reasonable cost to being able to pinpoint exactly the dialect of Haskell in use without looking at auxiliary files.
Can you elaborate on how you were able to build and run this on Windows? I saw [this StackOverflow question](https://stackoverflow.com/questions/39489880/stack-in-msys2-extra-include) that suggested that Brick does not work even on Windows 10. Was wondering if I'd need to resort to Cygwin or if that would even work.
Are there any experience reports of running a `brick` application *outside* of `cmd.exe`? E.g. with ConEmu, Cygwin, or perhaps even the Windows 10 Linux integrations (which I don't have experience with). I am considering developing an application for which I'd like to claim Windows support, even if it is "qualified" in some way.
For what it's worth, cabal is pretty much the same :) Just used stack instructions because i saw you were using stack
Real World Haskell is: 1. already free to read online: http://book.realworldhaskell.org/read/ 2. somewhat out of date (published 10 years ago) So... don't get this bundle for the Haskell.
Also worth noting: Real World Haskell was published about 10 years ago, and has fallen a bit out of date. Parallel and Concurrent Programming in Haskell is probably still timely and relevant, though.
What is a "concrete Haskell object"? Haskell doesn't have any concept of objects :o
This is a great resource. Do you have anything to say about default / custom Prelude?
My recollection (I don't have the exact error on hand, but I can try to dig it up tomorrow if you like) is that we built our binary on a modern machine and copied it and all its dynamic dependencies onto the RHEL6 machine and got an error when we tried to start the program about a missing symbol in libc. Perhaps we were going about it wrong. If you had to build a Haskell application with various dependencies and have the result run on a system you do not have unrestricted root access to, which is potentially very old, how would you go about doing it.
&gt; Everything I wrote on May 29 still rings true for me today, with the exception that I’m no longer of the mind that government shouldn’t suppress hate speech. As I witness what is becoming of my country, I think that’s a discussion we all need to have, and a possibility we need to entertain. I promise you, I will use all my money and technical knowledge to stop the government from suppressing speech on the Internet.
Nix packages are immutable and also allow multiple versions to coexist
The key thing that differentiates Nix from Docker is that Nix derivations are composable whereas Docker containers or Dockerfiles are not. "Composable" in this context means that I can combine two or more Nix derivations into a single derivation. I cannot do the same for Docker containers. To make this concrete, suppose you have a CentOS container that provides a Tensorflow setup and another Debian container that provides a GHCJS installation. You cannot combine those two into a new container where you can use both GHCJS and Tensorflow. However, if I had a Nix derivation for Tensorflow and a Nix derivation for GHCJS I can use them as inputs to a new Nix derivation that builds upon the two.
Great news! Indeed, thanks to everyone who helped to make this happen.
It takes very little time to get started in stack. But each week you spend using it, you are investing deeper in the tool, the manual, and learning what is fast/slow and common workflows. It's the incremental knowledge you gain from staying within stack that could alternatively be building up more general purpose incremental knowledge in nix language and ecosystem that seems like a potential opportunity cost not that I would weigh before selecting any tool for your daily workflow. The key question is for most scenarios, can you get started with nix within a week or two (on Linux). Once you have a simple workflow that builds what you need minimally, you can incrementally learn on demand in stack or nix. I think Gabriel's tutorial has brought nix documentation to the point where people reach a working nix build for their library or exe within a reasonable amount of time.
Check this out: https://docs.microsoft.com/en-us/windows/wsl/install-win10 It's not so much "in Windows", also it's a bitch to find a font and all that actually works in the windows shell. 
This is probably a good place to start: www.parsonsmatt.org/2017/04/26/basic_type_level_programming_in_haskell.html
 matchAtPosns :: [Int] -&gt; String -&gt; String -&gt; Bool matchAtPosns posns s1 s2 = and $ map snd $ filter (\(i, _) -&gt; i `elem` posns) $ zip [0..] $ zipWith (==) s1 s2 matchAtPosns [1,2] "abcd" "ebcf"
I would just define a Haskell type and let Aeson parse the JSON to produce a value of such type, fail if necessary. When interoperating with other languages or ill-defined JSON values, then it's another story...
[removed]
Is there anything special you have to do to produce random bytes at 6Gbps? I tried generating `Word8`s one by one (using `insecurely` and `random` every time), and it was really slow. After a minute or two, I was at a few tens of KB of generated data. I'm guessing you have to generate the data in larger chunks to benefit from the speed? What chunk size do you recommend?
Someone else might be defining the json-schema for you (example: api docs). Might as well take advantage of it!
We've used jsonschema in a python/c# app to give a measure of type safety and documentation. We also use it to autogenerate configuration UIs (ie by writing a jsonschema file describing the type of config a script requires will automatically provide a UI for providing that config for the script) The big advantage jsonschema has over aeson etc is there is no need for compilation. We keep a set of jsonschema files in a repository and update the "types" our app will accept by updating the schema repository. It is not as safe as haskell, but works well enough in practice (at the moment). I'm sure we could do something similar with haskell but haven't yet. 
I think there is still some confusion involved. The article you linked is about running new applications on old glibcs. But with nix you don't do that. Nixpkgs brings its own glibc, and programs you build with nix use that new glibc. That means there should always be compatibility between glibc and your program. So this article may not be describing your problem accurately. The only way I can imagine breakage could happen is incompatibility between nixpkgs's newer glibc, and older kernels. Say, for example, that your build machine (or the nixpkgs Hydra binary build machines, for that matter), have a newer kernel than your old RHEL machine and the software uses the `recvmmsg()` syscall which was added in Linux `2.6.33`. If now you copy this built software to a machine with kernel `&lt; 2.6.33`, then at the time the syscall happens, you'll get a crash. The solution in this case would have been to compile the code on the older machine, so that it either detects that `recvmmsg()` isn't available and falls back to a less efficient, older syscall at the time of `./configure`-style detection of what syscalls are available, or fails to `./configure` completely, telling you that this software requires this syscall. That would also be the answer to &gt; If you had to build a Haskell application with various dependencies and have the result run on a system you do not have unrestricted root access to, which is potentially very old, how would you go about doing it? Also, nix in general assumes you have root access at least once during its installation, as it writes stuff to `/nix` which you cannot even create if you're not root. (You can subsequently `chown` it to an unpriviliged user but that needs root at least one time.) However, even though this sounds like the most sensible explanation to me, there might be another thing involved, as you clearly seem to remember some glibc related error message and my reasoning excludes this, so there might be something we are missing.
You should either join a preexisting proposal (https://summer.haskell.org/ideas.html) or submit your own as a github pull request (https://github.com/haskell-org/summer-of-haskell/pulls). New proposals must however mention one or more mentors (so you should agree with a more experienced Haskeller first). Apart from that, the proposal will be evaluated according to relevance to the language/compiler/ecosystem, so talking to more experienced programmers might help in fleshing this out too. HTH, feel free to reach out if you have more questions
Firstly the speed that you see in the benchmarks are the raw buffer generation speeds also in Gbits not Gbytes per sec. Generating on `Word8` is not really recommended if you want to generate random data in bulk. If you want to generate a fixed number of bytes then consider the `randomByteString`. If you are willing to go a bit more low level there is always the `fillRandomBytes` available. You can see its use in the source code for the raaz executable. (see the source https://github.com/raaz-crypto/raaz/blob/master/bin/Command/Rand.hs). I have used a buffer size of 32K as it matches with the L1 cache of most modern machines. The raaz executable that is exposed with this version gives a speed of about 700 MBytes/sec for the following shell command. $ raaz --version raaz version 0.2.0 $ raaz rand | pv &gt; /dev/null In comparison the openssl rand $ openssl rand 1000000000 | pv &gt; /dev/null gives about 60 MiB (yes raaz rand is 10 times faster). 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [raaz-crypto/raaz/.../**Rand.hs** (master → 7742757)](https://github.com/raaz-crypto/raaz/blob/7742757572bc292f7c7794465c643d0c7bc3e218/bin/Command/Rand.hs) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply du6dy6q.)
I was going to expose an endpoint in my API for users to POST json and receive the output from attempting to parse. I don't have a solution for describing the expected format of the json without jsonschema yet. I may implement some logic in Haskell that will generate the json schema. I guess having a type level description, with two interpretations would be ideal: aeson parser interpretation and jsonschema generating interpretation.
Just one more data point. $ cat /dev/urandom | pv &gt; /dev/null Gives about 200MiB.
good summary :) 
Incredibly basic question: why `R` for vectors and `L` for matrices?
It's considerably more developer-friendly than Windows. However it's also updated more often than Windows, and open-source teams tend not to track the betas as far as I can see (potentially because it may cost money). So things like GHC are never ready the day the new OS version is released. So the typical Apple workflow is to apply the OS updates six months after it's been released, by which time the dev tools have usually been updated. It's also worth saying that Apple works much better with proprietary infrastructure (think Exchange) than Linux. As such it's a good half-way house between the two.
The simplest one would be that google pays for it.
While I don't like Google, this feat sounds great. I am happy to read that Haskell and Eta are getting attention they deserve.
You left out the `x` in the second argument of `&amp;&amp;` (the test of your second guard, for instance, should be `x &gt;= 11501 &amp;&amp; x &lt; 45000`). By the way, do not post images of code. Just copy the code and paste it in your post as text -- it makes things easier for everyone.
No support for time zones in chronos?
That's great news. We joined the 2nd year - 2006. Does this make it our 11th GSoC? 
That one sure makes sense. :) 
That's what [OffsetDatetime](http://hackage.haskell.org/package/chronos-1.0.1/docs/Chronos.html#t:OffsetDatetime) does. I call it an offset instead of a timezone because the way the library deals with them, it never would use the name of a name time zone or daylight-savingsness of a time zone. The `time` library offers [slightly better support](http://hackage.haskell.org/package/time-1.9/docs/Data-Time-LocalTime.html) for timezone operations since it can do stuff like getting the user timezone (both the name and the offset). I never implemented this because I've never needed it.
hmatrix offers `R` for real vectors and `C` for complex vectors, so that might be what is going on there. For matrices, `L` is for real matrices and `M` is for complex matrices; i'm not exactly sure what the story is there to be honest!
I actually think you do know what I'm talking about. There are primitives that people use that allow for mutable package content and the top level name bindings in Nix change. It's up to individual discretion w/ nice package developers to present a sane version interface and many packages or development packages simply don't. A freshly provisioned nixos system can and does do subtly different things from previous versions. These properties are well-motivated, but because of the huge pressure on nix maintainers to accept or clear the PR backlog we can see inconsistent states exposed on channels. There are techniques (not tooling but I hope someday nix's tooling will be more than an underpopulated manual) to freeze nixpkgs for a given project so that name bindings can be relied upon. Of course it's bad for some types of code (openssl comes to mind), but it's better than broken builds.
&gt; Also, nix in general assumes you have root access at least once during its installation I think this points to the issue of what I failed to mention. We had the constraint that we could not install nix on the machine we were deploying to. We wanted to build a binary with nix and ship it and all its dynamic dependencies to another machine. This worked well enough to be encouraging until we tried to put it on an RHEL6 machine. &gt; But with nix you don't do that. Nixpkgs brings its own glibc, and programs you build with nix use that new glibc. We also tried shipping the new glibc, and to my recollection got an immediate crash with no error message. &gt; The solution in this case would have been to compile the code on the older machine, We did not try this. I don't know if it would have worked if we made sure that our build server had the same kernel version as our target machine, but it's an avenue for exploration if we try this again. Thank you.
You could use github's gists or something like pastebin to post code too :)
See also: [Which parts of Real World Haskell are now obsolete or considered bad practice?](https://stackoverflow.com/q/23727768/1139697) ^(Feel free to update the answer if you found something else that has changed)
Feel free to open PRs that are incomplete/work-in-progress, that way you can get feedback earlier.
I think you are confusing immutability with determinism. Nix guarantees immutability, meaning that once you create a package the only thing you can do to it is garbage collect it if it is not reachable from a garbage collection root. A container can be mutated after it is built. Regarding determinism, Nix is not perfect but it is still waaaay better than Docker. Every derivation (not just fetchgit) can optionally specify an expected hash to enforce determinism if is reproducible (if it is not then the build will fail due to a hash mismatch). Also, Nix makes it much easier to create deterministic builds than Docker does and the Nix derivations in the wild are significantly more deterministic than their Docker counterparts. I know because on several occasions I've had to built my entire systems from scratch (i.e. no cache) for security reasons when bootstrapping CI.
There were a few years where we weren't accepted (sadly). So I think it's only our 9th?
Indeed, this method works, thank you=) However, if I associate .hs files with `stack`, when I run my scripts, a new cmd window opens where the script is executed and then the window immediately close, I can not see the output at all. I ended up with compiling all my scripts and putting theme where PATH can see them, much less of a hassle.
I believe that's equivalent to disallowing open world assumptions and enforcing closed world typeclasses. In which case, I think that you could have OR and NOT and have full classical logic because the law of excluded middle would be valid, but I could be wrong.
It's our 11th: &gt; length $ [2006 .. 2018] \\ [2016, 2017] 11
Well, now I feel silly :) Thanks for the correction, and also thanks for all your work on GSoC!
Very nice implementations and uses. I remember seeing the Data.List implementation of permutations and wondering why it wasn't like that; it turns out the implementation they use has maximal laziness
Does anyone know a path to participation for people who can't afford to be in an undergraduate program. 
We use conduit in our production web apps. The reasons have been mentioned by others in various posts here. I'll summarize them together: * Best integration with `yesod` and `persistent`, both of which we use. * Built from the ground up to handle the complex interactions of exceptions and concurrency that happen in real-life high-load applications, especially web apps. * Mature and stable, in API, correctness, and performance. Widely used in major production applications. * Robust and mature ecosystem. * Great tutorials and documentation make it easy to use.
/u/hvr_ has created a [PPA for GHC on WSL Ubuntu](https://launchpad.net/~hvr/+archive/ubuntu/ghc-wsl), parallel to his [PPA for GHC on native Ubuntu](https://launchpad.net/~hvr/+archive/ubuntu/ghc). Thanks for this! Here is the [announcement](https://mail.haskell.org/pipermail/haskell-cafe/2018-February/128591.html), with more details.
&gt; Docker images are trivially mutable (and by mutable I really mean non-deterministic). If that' the case then so are nix packages. &gt; Nix packages are immutable The exact same thing can happen with nix; they change the names referred. &gt; It sounds like you're really arguing about how nix isn't 100% deterministic. It's weird how docker images aren't extended this same definition. 
&gt; Every derivation (not just fetchgit) can optionally specify an expected hash Apt-get also offers something like this...
Hello Haskellers; So I'm working on a CQRS/ES-based system as my first real-world, intended-for-production application in Haskell. I have modules full of `Command` objects and `Event` objects that I model with record types. I feel like I'm running through a field of problems about 30cm high. The immediate problem being that field types are global. My code is compiling and things are working but I feel like my types and patterns are getting verbose and ugly. What are some of the patterns and libraries I should look at at to make working with records, sum-types of records, and matching on records a little more ergonomic and terse?
There would be a subclass/superclass relationship. So in the Haskell type class notation, it would be something like: class EuclideanRing a =&gt; Integer a Then all the signed Integer types would have instances declared for that class.
It's a shame that no good tutorial on type-level functions exists at the moment... Maybe someone will write good blog post. I can suggest several more links in addition. Usually I give them to people as well as exercises on this topics: * Simple type families: https://kseo.github.io/posts/2017-01-16-type-level-functions-using-closed-type-families.html * Associated type families: https://kseo.github.io/posts/2017-01-16-type-level-functions-using-closed-type-families.html * GADT simple wiki: https://en.wikibooks.org/wiki/Haskell/GADT * Nice example of small application for thise stuff: https://stackoverflow.com/questions/40939508/translate-a-scala-type-example-to-haskell/40939719
It's a shame that no good tutorial on type-level functions exists at the moment... Maybe someone will write good blog post. I can suggest several more links in addition. Usually I give them to people as well as exercises on this topics: * Simple type families: https://kseo.github.io/posts/2017-01-16-type-level-functions-using-closed-type-families.html * Associated type families: https://kseo.github.io/posts/2017-01-16-type-level-functions-using-closed-type-families.html * GADT simple wiki: https://en.wikibooks.org/wiki/Haskell/GADT * Nice example of small application for thise stuff: https://stackoverflow.com/questions/40939508/translate-a-scala-type-example-to-haskell/40939719
What kind of expectations are there for mentors? Is it like a collaborative coding exercise, do you just make yourself available on Slack/IRC/email, do you meet the student in person? I'm interested in signing up as a mentor for all of the Persistent projects but want to make sure I know what I'm getting myself into.
That sounds like a good idea. I'm generally a fan of providing specialized aliases or names for general functions. Haskell's `time` library uses a lot of `Num` and `Fractional` methods, and having special aliases is helpful and useful for learning.
When the application process opens for google students, you register on their site, and submit proposals directly. They can be based on existing ideas, or your own. Doing work early on to figure out what proposals you want to make, etc. really improves your proposal, and improves your project if you are accepted. The general google student guide is a good resource: https://developers.google.com/open-source/gsoc/resources/guide
It would be cool if there was an implementations of permutations that also maintained maximal laziness via `sortM`—maybe something to do with incremental sorting?
No. I mean in general. This year's SoH _is_ via GSoC. We may have a few other slots on the side, but that'll be figured out later. If you want to do a summer of haskell project, you do it by submitting an application to the gsoc site during the student applications period.
So if I'm graduating this semester, I'm ineligible, right?
You cannot do this. I've seen a trick somewhere where someone used template haskell to make `Set` that fell back on `Eq` when `Ord` was not available, but it required checking all in-scope instances and defining another instance based on the results of that. One reason why this cannot possibly work is because of orphan instances. Consider this: module Control.Exception where class Exception e where ... module Data.Wibble where wibble :: NoExceptionInstance e =&gt; ExceptT e IO a module Foo where import Data.Wibble data Foo = Foo foo :: ExceptT Foo IO () foo = wibble module Bar where import Control.Exception import Foo instance Exception Foo myFunc :: ExceptT Foo IO Bool myFunc = foo &gt;&gt; return True Should this be accepted? The `wibble` function was supposed to provide a guarantee that it's type does not have an `Exception` instance, but with separate compilation, it is impossible to provide this guarantee.
Also, be aware that ghci and ghc may behave differently. Also the shell from which you launch (cmd vs. 'command' vs clicking on an icon vs powershell vs the 17 different bash shells for windows (won't even mention ksh, csh, zsh, ...)). 
I was upselling hashes because you asked to compare to Docker. If I were comparing to apt I would market a different set of advantages (such as ease of packaging and the fact that Nix can "package" and distribute logical function on a much larger scale than apt, such as an entire system configuration). The reason I started off by mentioning composability as the key property is because composability allows Nix to work across multiple abstraction layers, all the way from individual files to clusters of machines. That means that any new feature Nix supports (like hashing outputs, distributed builds, or programmatic configuration) automatically works at every layer without having to learn a new set of tools. Compare that with traditional software engineering where you have separate tools for configuring the kernel, building a project, packaging a project, configuring a system, configuring a container, configuring a network of containers, provisioning systems, and configuring system parameters.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/amaaggregator] [FOAM Protocol Developer Oriented AMA - FOAM is bringing spatial parameters and applications to blockchain.](https://www.reddit.com/r/AMAAggregator/comments/7xd492/foam_protocol_developer_oriented_ama_foam_is/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Thank you for these tremendous insights. **pv**: what a great tool you've shown me :) I did some experiments. If I stream ByteStrings of length X (created with randomByteString) into stdout, I get around Y speed. Here's a rough table: X [bytes] Y ---------------------- 10 8 KiB/s 1000 750 KiB/s 100000 63 MiB/s 1000000 290 MiB/s 10000000 530 MiB/s 100000000 596 MiB/s So it seems that to benefit from Raaz's speed, I have to generate the data in 10 MB chunks. Going from 10 MB to 100 MB doesn't improve things much, so it seems that around 10 MB is a sweet spot - at least on my machine. Is this something you would have expected? By the way, Raaz is **way** faster than System.Random (which gives me a paltry 2.63 MiB/s). This surprised me because the former is cryptographically secure. One would think that one could do even better than Raaz if one didn't need cryptographic security. (But then at the same time, with System.Random we have to generate the random numbers one by one.) (BTW, I'm using the streaming library to do the streaming.) 
From their faq: "Yes, as long as you are accepted into or enrolled in a college or university program as of the date accepted students are announced, you are eligible to participate in the program. Students must provide proof of enrollment during the proposal period." (https://developers.google.com/open-source/gsoc/faq)